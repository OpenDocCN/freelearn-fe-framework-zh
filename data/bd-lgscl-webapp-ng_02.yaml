- en: Personal Trainer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练
- en: The *7 Minute Workout* app has been an excellent opportunity for us to learn
    about Angular. Working through the app, we have covered a number of Angular constructs.
    Still, there are areas such as Angular form support and client-server communication
    that remain unexplored. This is partially due to the fact that 7 Minute Workout,
    from a functional standpoint, has limited touch points with the end user. Interactions
    are limited to starting, stopping, and pausing the workout. Also, the app neither
    consumes nor produces any data (except workout history).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟健身* 应用程序为我们学习 Angular 提供了绝佳的机会。通过使用该应用程序，我们已经涵盖了许多 Angular 构造。尽管如此，仍然有一些领域，比如
    Angular 表单支持和客户端-服务器通信，尚未被探索。这在一定程度上是因为从功能角度来看，7分钟健身对最终用户的接触点有限。交互仅限于启动、停止和暂停健身。此外，该应用程序既不消费也不生成任何数据（除了健身历史记录）。'
- en: In this chapter, we plan to delve deeper into one of the two aforementioned
    areas, Angular form support. Keeping up with the health and fitness theme (no
    pun intended), we plan to build a *Personal Trainer* app. The new app will be
    an extension to *7 Minute Workout*, allowing us to build our own customized workout
    plans that are not limited to the *7 Minute Workout* plans we already have.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们计划更深入地研究前面提到的两个领域之一，即 Angular 表单支持。为了跟上健康和健身主题（无恶意），我们计划构建一个 *个人教练* 应用程序。新的应用程序将是
    *7分钟健身* 的延伸，使我们能够构建属于自己的定制健身计划，而不仅仅局限于我们已经拥有的 *7分钟健身* 计划。
- en: This chapter is dedicated to understanding Angular forms and how to put them
    to use as we build out our *Personal Trainer* app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于理解 Angular 表单以及如何在构建 *个人教练* 应用程序时将其应用。
- en: 'The topics that we will cover in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括以下内容：
- en: '**Defining Personal Trainer requirements**: Since we are building a new app
    in this chapter, we start with defining the app requirements.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义个人教练需求**：因为我们在本章构建一个新应用程序，所以我们从定义应用程序需求开始。'
- en: '**Defining the Personal Trainer model**: Any app design starts with defining
    its model. We define the model for *Personal Trainer*, which is similar to the
    *7 Minute Workout* app built earlier.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义个人教练模型**：任何应用程序设计都始于定义其模型。我们定义了 *个人教练* 的模型，它与之前构建的 *7分钟健身* 应用程序类似。'
- en: '**Defining the Personal Trainer layout and navigation**: We define the layout,
    navigation patterns, and views for the new app. We also set up a navigation system
    that is integrated with Angular routes and the main view.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义个人教练布局和导航**：我们为新应用程序定义布局、导航模式和视图。我们还设置了与 Angular 路由和主视图集成的导航系统。'
- en: '**Adding support pages**: Before we focus on the form capability and build
    a Workout component, we build some supporting components for workout and exercise
    listing.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加支持页面**：在我们专注于表单功能并构建健身组件之前，我们要构建一些用于健身和锻炼列表的支持组件。'
- en: '**Defining the Workout Builder component structure**: We lay out the Workout
    Builder components that we will use to manage workouts.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义健身构建器组件结构**：我们布置了健身构建器组件，我们将用它来管理健身。'
- en: '**Building forms**: We make extensive use of HTML forms and input elements
    to create custom workouts. In the process, we will learn more about Angular Forms.
    The concepts that we cover include:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建表单**：我们广泛使用 HTML 表单和输入元素来创建自定义健身计划。在这个过程中，我们将了解更多关于 Angular 表单的概念。我们将覆盖的概念包括：'
- en: '**Form types**: The two types of form that can be built with Angular are template-driven
    and reactive. We''re working with both template-driven and reactive forms in this
    chapter.'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单类型**：在 Angular 中可以构建的两种表单类型分别是模板驱动型和响应式型。本章我们将使用这两种类型的表单。'
- en: '**ngModel**: This provides two-way data binding for template driven forms and
    allows us to track changes and validate form input.'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ngModel**：这为模板驱动表单提供了双向数据绑定，允许我们跟踪更改并验证表单输入。'
- en: '**Reactive Form Controls**: These include the form builder, form control, form
    group, and form array. These are used to construct forms programmatically.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式表单控件**：这些包括表单构建器、表单控件、表单组和表单数组。这些用于以编程方式构建表单。'
- en: '**Data formatting**: These are the CSS classes that permit us to style our
    feedback to the user.'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据格式化**：这些是允许我们对用户的反馈进行样式化的 CSS 类。'
- en: '**Input validation**: We will learn about the validation capabilities of Angular
    forms.'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入验证**：我们将了解 Angular 表单的验证能力。'
- en: Personal Trainer requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练需求
- en: 'Based on the notion of managing workouts and exercises, these are some of the
    requirements that our *Personal Trainer* app should fulfill:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基于管理训练和练习的概念，这是我们的*个人教练*应用程序应该满足的一些要求：
- en: The ability to list all available workouts.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有可用的训练的能力。
- en: 'The ability to create and edit a workout. While creating and editing a workout,
    it should have:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建和编辑训练**的能力。在创建和编辑训练时，它应包括：'
- en: The ability to add workout attributes including name, title, description, and
    rest duration
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为训练添加名称、标题、描述和休息时间等训练属性的能力
- en: The ability to add/remove multiple exercises for workouts
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为训练添加/移除多个练习的能力
- en: The ability to order exercises in the workout
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对训练中的练习进行排序的能力
- en: The ability to save workout data
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存训练数据**的能力'
- en: The ability to list all available exercises.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有可用的练习的能力。
- en: 'The ability to create and edit an exercise. While creating and editing an exercise,
    it should have:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建和编辑练习**的能力。在创建和编辑练习时，它应包括：'
- en: The ability to add exercise attributes such as name, title, description, and
    procedure
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够添加诸如名称、标题、描述和程序之类的练习属性
- en: The ability to add pictures for the exercise
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为练习添加图片的能力
- en: The ability to add related videos for the exercise
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为练习添加相关视频的能力
- en: The ability to add audio clues for the exercise
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为练习添加**音频提示**的能力
- en: All the requirements seem to be self-explanatory, so let's start with the design
    of the application. As customary, we first need to think about the model that
    can support these requirements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有要求似乎都很简单明了，所以让我们先从应用程序的设计开始。依照惯例，我们首先需要考虑能够支持这些要求的模型。
- en: Getting started with the code for Personal Trainer
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用个人教练的代码
- en: First, download the base version of the new *Personal Trainer* app from `checkpoint4.1`
    in the GitHub repository for the book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从GitHub仓库中的`checkpoint4.1`下载新*个人教练*应用程序的基本版本。
- en: 'The code is available on GitHub [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)
    for everyone to download. Checkpoints are implemented as branches in GitHub. The
    branch to download is as follows: `GitHub Branch: checkpoint4.1`. If you are not
    using Git, download the snapshot of Checkpoint 4.1 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '该代码可在GitHub [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)
    上下载。检查点在GitHub中作为分支实现。要下载的分支如下：`GitHub Branch: checkpoint4.1`。如果您未使用Git，请从以下GitHub位置下载Checkpoint
    4.1的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。'
- en: 'This code has the complete *7 Minute Workout (Workout Runner)* app. We have
    added some more content to support the new *Personal Trainer* app. Some of the
    relevant updates are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码包含完整的*7分钟训练（训练运行器）*应用程序。我们添加了一些内容来支持新的*个人教练*应用程序。一些相关的更新包括：
- en: Adding the new `WorkoutBuilder` feature. This feature contains implementations
    pertaining to *Personal Trainer*.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的`WorkoutBuilder`功能。此功能包含与*个人教练*相关的实现。
- en: Updating the layout and styles of the app.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新应用程序的布局和样式。
- en: Adding some components and HTML templates with placeholder content for *Personal
    Trainer* in the `workout-builder` folder under `trainer/src/app`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`trainer/src/app`的`workout-builder`文件夹下为*个人教练*添加一些组件和带有占位内容的HTML模板。
- en: Defining a new route to the `WorkoutBuilder` feature. We will cover setting
    up this route within the app in the coming section.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义到`WorkoutBuilder`功能的新路由。我们将在接下来的部分介绍如何在应用程序中设置这个路由。
- en: As we just mentioned, moving the existing  `model.ts` file into the `core` folder.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，将现有的`model.ts`文件移动到`core`文件夹中。
- en: Let's discuss how we will be using the model.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下我们将如何使用这个模型。
- en: Using the Personal Trainer model in Workout Builder services
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Workout Builder服务中使用个人教练模型
- en: Services are useful for sharing data across controllers and other Angular constructs.
    Open the `model.ts` file present in the `core` folder under `app`. In this class,
    we essentially do not have any data, but a blueprint that describes the shape
    of the data. The plan is to use services to expose this model structure.  We have
    already done that in Workout Runner. Now, we will do the same in Workout Builder.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对于在控制器和其他 Angular 结构之间共享数据非常有用。打开位于 `app` 下 `core` 文件夹中的 `model.ts` 文件。在这个类中，实际上我们并没有任何数据，而是描述了数据的形状。我们计划使用服务来公开这个模型结构。
    在 Workout Runner 中，我们已经做到了这一点。现在，我们将在 Workout Builder 中做同样的事情。
- en: 'The `model.ts` file has been moved into the `core` folder as it is shared across
    the *Workout Builder* and *Workout Runner* apps. Note: in `checkpoint4.1` we have
    updated the import statements in `workout-runner.component.ts` , `workout-audio.component.ts`, and `workout-history-tracker-service.ts` to
    reflect this change.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`model.ts` 文件已经移动到 `core` 文件夹中，因为它在*健身计划生成器*和*健身计划执行器*应用程序之间共享。注意：在 `checkpoint4.1`
    中，我们已经更新了 `workout-runner.component.ts`、`workout-audio.component.ts` 和 `workout-history-tracker-service.ts`
    中的导入语句，以反映这一变化。'
- en: In [Chapter 1](8eb47c1f-58fe-45dd-9afe-b955ef2080be.xhtml), *Building Our First
    App - 7 Minute Workout*, we reviewed the class definitions in the model file: `Exercise`,
    `ExercisePlan`, and `WorkoutPlan`**.** As we then mentioned, these three classes
    constitute our base model. We will now start using this base model in our new
    app.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](8eb47c1f-58fe-45dd-9afe-b955ef2080be.xhtml) *建立我们的第一个应用程序 - 7分钟锻炼* 中，我们回顾了模型文件中的类定义：`Exercise`,
    `ExercisePlan`, 和 `WorkoutPlan`**。** 正如我们之前提到的，这三个类构成了我们的基础模型。我们现在将开始在我们的新应用程序中使用这个基础模型。
- en: That's all on the model design front. The next thing we are going to do is define
    the structure for the new app.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是模型设计的全部内容。我们接下来要做的是定义新应用程序的结构。
- en: The Personal Trainer layout
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人健身教练布局
- en: 'The skeleton structure of *Personal Trainer* looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*个人健身教练* 的骨架结构���下所示：'
- en: '![](img/38aaf003-6900-4429-8954-72093475d5d3.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38aaf003-6900-4429-8954-72093475d5d3.png)'
- en: 'This has the following components:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有以下组件：
- en: 'Top Nav: This contains the app branding title and history link.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部导航：这包含应用程序品牌标题和历史链接。
- en: 'Sub Nav: This has navigation elements that change based on the active component.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子导航：这里有导航元素，根据活动组件的变化而变化。
- en: 'Left Nav: This contains elements that are dependent upon the active component.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧导航：这包含依赖于活动组件的元素。
- en: 'Content Area: This is where the main view for our component will display. This
    is where most of the action happens. We will create/edit exercises and workouts
    and show a list of exercises and workouts here.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容区域：这是我们组件的主视图显示的地方。这里发生了大部分的操作。我们将在这里创建/编辑练习和健身计划，并在这里显示练习和健身计划列表。
- en: Look at the source code files; there is a new folder `workout-builder` under
    `trainer/src/app`. It has files for each component that we described previously,
    with some placeholder content. We will be building these components as we go along
    in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 看看源代码文件；在 `trainer/src/app` 下有一个新的 `workout-builder` 文件夹。它具有我们先前描述的每个组件的文件，还有一些占位符内容。在本章中我们将按照这一过程逐步构建这些组件。
- en: However, we first need to link up these components within the app. This requires
    us to define the navigation patterns for the Workout Builder app and accordingly
    define the app routes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们首先需要在应用程序中连接这些组件。这要求我们定义健身计划生成器应用程序的导航模式，并相应地定义应用程序路由。
- en: Personal Trainer navigation with routes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人健身教练导航及路线
- en: 'The navigation pattern that we plan to use for the app is the list-detail pattern.
    We will create list pages for the exercises and workouts available in the app.
    Clicking on any list item takes us to the detailed view for the item where we
    can perform all CRUD operations (create/read/update/delete). The following routes
    adhere to this pattern:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算在应用程序中使用的导航模式是列表-详细信息模式。我们将为应用程序中可用的练习和健身计划创建列表页面。单击任何列表项将带我们到该项目的详细视图，我们可以在这里执行所有
    CRUD 操作（创建/读取/更新/删除）。以下路线遵循这一模式：
- en: '| **Route** | **Description** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **路线** | **描述** |'
- en: '| `/builder` | This just redirects to **builder/workouts** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `/builder` | 这只是重定向到 **builder/workouts** |'
- en: '| `/builder/workouts` | This lists all the available workouts. It is the landing
    page for *Workout Builder* |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/workouts` | 这列出了所有可用的健身计划。这是*健身计划生成器*的登陆页面 |'
- en: '| `/builder/workout/new` | This creates a new workout |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/workout/new` | 这将创建一个新的健身计划 |'
- en: '| `/builder/workout/:id` | This edits an existing workout with the specific
    ID |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/workout/:id` | 这将编辑具有特定 ID 的现有健身计划 |'
- en: '| `/builder/exercises` | This lists all the available exercises |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/exercises` | 这列出所有可用的练习 |'
- en: '| `/builder/exercise/new` | This creates a new exercise |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/exercise/new` | 这创建一个新的练习 |'
- en: '| `/builder/exercise/:id` | This edits an existing exercise with the specific
    ID |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/exercise/:id` | 这将使用特定ID编辑现有练习 |'
- en: Getting started with Personal Trainer navigation
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用个人健身教练导航
- en: At this point, if you look at the route configuration in `app-routing.module.ts`
    in the `src/app` folder, you will find one new route definition, `builder`**:**
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果您查看`app-routing.module.ts`中的路由配置，您将在`src/app`文件夹中找到一个新的路由定义，`builder`**：**
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And if you run the application, you will see that the start screen shows another
    link, Create a Workout:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行应用程序，您会发现起始屏幕显示另一个链接，创建一个锻炼：
- en: '![](img/91aeb5b5-d0e6-4423-b679-0dd4c8b1d79f.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91aeb5b5-d0e6-4423-b679-0dd4c8b1d79f.png)'
- en: 'Behind the scenes, we have added another router link for this link into `start.component.html`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 幕后，我们已将另一个路由链接添加到`start.component.html`中的此链接中：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And if you click on this link, you will be taken to the following view:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击这个链接，你将进入以下视图：
- en: '![](img/c4bb197b-3abd-4895-be6c-ced456c6b230.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4bb197b-3abd-4895-be6c-ced456c6b230.png)'
- en: 'Again, behind the scenes we have added  `workout-builder.component.ts` to the
    `trainer/src/app/workout-builder` folder with the following inline template:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在幕后，我们已将`workout-builder.component.ts`添加到`trainer/src/app/workout-builder`文件夹，并包含以下内联模板：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And this view is displayed on the screen under the header using the router
    outlet in our `app.component.html` template:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这个视图在屏幕上显示在我们的`app.component.html`模板中使用的路由器插座下的标题下：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have wrapped this component (along with the other files we have stubbed out
    for this feature) in a new module named `workout-builder.module.ts:`
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将此组件（以及我们为此功能生成的其他文件）包装在名为`workout-builder.module.ts`的新模块中：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The only thing that might look different here from the other modules that we
    have created is that we are importing `CommonModule` instead of `BrowserModule`.
    This avoids importing the whole of `BrowserModule` a second time, which would
    generate an error when we get to implementing lazy loading for this module.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能与我们创建的其他模块有所不同的是，我们导入的是`CommonModule`而不是`BrowserModule`。这样避免了第二次导入整个`BrowserModule`，这会在实现此模块的延迟加载时产生错误。
- en: 'Finally, we have added an import for this module to `app.module.ts`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已向`app.module.ts`添加了此模块的导入：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, nothing surprising here. Following these patterns, we should now begin to
    think about adding the additional navigation outlined previously for our new feature.
    However, before we jump into doing that, there are a couple of things we need
    to consider.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，没有什么新奇的地方。根据这些模式，我们现在应该开始考虑为我们的新功能添加先前概述的附加导航。然而，在我们着手进行之前，有一些事情我们需要考虑。
- en: First, if we start adding our routes to the `app.routing-module.ts` file, then
    the number of routes stored there will grow. These new routes for *Workout Builder*
    will also be intermixed with the routes for *Workout Runner***.** While the number
    of routes we are now adding might seem insignificant, over time this could get
    to be a maintenance problem.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们开始将我们的路由添加到`app.routing-module.ts`文件中，那么存储在那里的路由数量将增加。这些用于*Workout Builder*的新路由也将与*Workout
    Runner*的路由混合在一起。虽然我们现在添加的路由数量可能看起来微不足道，但随着时间的推移，这可能成为一个维护问题。
- en: Second, we need to take into consideration that our application now consists
    of two features—*Workout Runner* and *Workout Builder*. We should be thinking
    about ways to separate these features within our application so that they can
    be developed independently of each other.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要考虑到我们的应用程序现在由两个功能组成——*Workout Runner*和*Workout Builder*。我们应该考虑如何在应用程序中分离这些功能，以便它们可以独立开发。
- en: Put differently, we want **loose coupling** between the features that we build.
    Using this pattern allows us to swap out a feature within our application without
    affecting the other features. For example, somewhere down the line, we may want
    to convert the *Workout Runner* into a mobile app but leave the *Workout Builder*
    intact as a web-based application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们希望我们构建的功能之间具有**松耦合**。使用这种模式可以让我们在应用程序中替换功能而不影响其他功能。例如，远期，我们可能希望将*Workout
    Runner*转换为移动应用程序，但保留*Workout Builder*作为基于Web的应用程序。
- en: This ability to separate our components from each other is one of the key advantages
    of using the **component design pattern** that Angular implements. Fortunately,
    Angular's router gives us the ability to separate out our routing into logically
    organized **routing configurations** that closely match the features in our application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离我们组件的能力是Angular实现的**组件设计模式**的重要优势之一。幸运的是，Angular的路由器为我们提供了将我们的路由分离成逻辑上组织良好的**路由配置**的能力，这些路由配置与我们应用程序的特性紧密匹配。
- en: In order to accomplish this separation, Angular allows us to use **child routing**,
    where we can isolate the routing for each of our features. In this chapter, we
    will use **child routing** to separate out the routing for *Workout Builder*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种分离，Angular允许我们使用**子路由**，在这里我们可以隔离每个功能的路由。在本章中，我们将使用**子路由**来分离*Workout
    Builder*的路由。
- en: Introducing child routes to Workout Builder
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍为Workout Builder添加子路由
- en: Angular supports our goal of isolating the routing for our new *Workout Builder*
    by providing us with the ability to create a hierarchy of router components within
    our application. We currently have just one router component, which is in the
    root component of our application. But Angular allows us to add what are called
    **child router components** under our root component. This means that one feature
    can be ignorant of the routes the other is using and each is free to adapt its routes
    in response to changes within that feature.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持我们隔离新*Workout Builder*的路由的目标，它为我们提供了在我们应用程序中创建路由器组件层次结构的能力。目前，我们只有一个路由器组件，它位于我们应用程序的根组件中。但是Angular允许我们在根组件下添加所谓的**子路由器组件**。这意味着一个功能可以对另一个功能使用的路由一无所知，每个功能都可以自由地根据该功能内部的更改来调整其路由。
- en: 'Getting back to our application, we can use **child routing** in Angular to
    match the routing for the two features of our application with the code that will
    be using them. So in our application, we can structure the routing into the following
    routing hierarchy for our *Workout Builder* (at this point, we are leaving the
    *Workout Runner* as is to show the before and after comparison):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 返回我们的应用程序，我们可以在Angular中使用**子路由**来匹配我们应用程序的两个功能的路由与将要使用它们的代码。因此，在我们的应用程序中，我们可以将路由结构化为以下路由层次结构，用于我们的*Workout
    Builder*（此时，我们将*Workout Runner*保持不变，以展示之前和之后的比较）：
- en: '![](img/f4b8f0b2-c5a8-41fc-b7ad-a0b0606092b2.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4b8f0b2-c5a8-41fc-b7ad-a0b0606092b2.png)'
- en: With this approach, we can create a logical separation of our routes by feature
    and make them easier to manage and maintain.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们可以通过特性进行逻辑分离，并使其更易于管理和维护。
- en: So, let's get started by adding child routing to our application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始为我们的应用程序添加子路由。
- en: 'From this point on in this section, we''ll be adding to the code that we downloaded
    earlier for this chapter. If you want to see the complete code for this next section,
    you can download it from `checkpoint 4.2` in the GitHub repository. If you want
    to work along with us as we build out the code for this section, still be sure
    to add the changes in `styles.css` in the `trainer/src` folder that are part of
    this checkpoint, since we won''t be discussing them here. Also be sure and add
    the files for exercise(s) ,workout(s), and navigation from the `trainer/src/app/workout-builder`
    folder in the repository. At this stage, these are just stub files, which we will
    implement later in this chapter. However, you will need these stub files here
    in order to implement navigation for the *Workout Builder* module. The code is
    available to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.2` . If you are not using Git, download the
    snapshot of `Checkpoint 4.2` (a ZIP file) from the following GitHub location:
    [https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节开始，我们将添加到前面在本章中下载的代码中。如果您想查看下一节的完整代码，可以在 GitHub 仓库的 `checkpoint 4.2` 中下载。如果您想和我们一起为该部分编写代码，请确保在这个检查点中添加
    `trainer/src` 文件夹中的 `styles.css` 中的更改，因为我们在这里不会讨论它们。还要确保从仓库的 `trainer/src/app/workout-builder`
    文件夹中添加 exercise(s)、workout(s) 和 navigation 的文件。在这个阶段，这些只是存根文件，我们将在本章后面实现它们。但是，您需要这些存根文件来实现
    *Workout Builder* 模块的导航。该代码可以在 GitHub 上下载：[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。检查点在
    GitHub 中作为分支实现。要下载的分支如下：`GitHub 分支：checkpoint4.2`。如果您不使用 Git，请从以下 GitHub 位置下载
    `Checkpoint 4.2` 的快照（ZIP 文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip)。在第一次设置快照时，请参考
    `trainer` 文件夹中的 `README.md` 文件。
- en: Adding the child routing component
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加子路由组件
- en: 'In the `workout-builder` directory, add a new TypeScript file named `workout-builder.routing.module.ts`
    with the following imports:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `workout-builder` 目录中，添加一个名为 `workout-builder.routing.module.ts` 的新的 TypeScript
    文件，并加入以下引用：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we are importing the components we just mentioned; they will
    be part of our *Workout Builder* (exercise, exercises, workout, and workouts).
    Along with those imports, we are also importing `NgModule` from the Angular core
    module and `Routes` and `RouterModule` from the Angular router module. These imports
    will give us the ability to add and export child routes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们正在引入刚提到的组件；它们将成为我们的 *Workout Builder*（exercise, exercises, workout 和
    workouts）的一部分。除了这些引用外，我们还从 Angular 核心模块中引入 `NgModule`，以及从 Angular 路由器模块中引入 `Routes`
    和 `RouterModule`。这些引用将使我们能够添加和导出子路由。
- en: We are not using the Angular CLI here because it does not have a standalone
    blueprint for creating a routing module. However, you can have the CLI create
    a routing module at the time that you create a module using the `--routing` option.
    In this case, we already had an existing module created so we couldn't use that
    flag. See [https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md](https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md)
    for more details about how to do this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在这里使用 Angular CLI，因为它没有一个单独的蓝图用于创建路由模块。然而，您可以在创建模块时使用 `--routing` 选项让 CLI
    创建一个路由模块。在这种情况下，我们已经有一个现有的模块创建，所以我们无法使用该标志。查看如下链接以了解更多关于如何实现这一点的细节：[https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md](https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md)。
- en: 'Then, add the following route configuration to the file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在文件中添加以下路由配置：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first configuration, `path: ''builder''`, sets the base URL for the child
    routes so that each of the child routes prepends it. The next configuration identifies
    the `WorkoutBuilder` component as the feature area root component for the child
    components in this file. This means it will be the component in which each of
    the child components is displayed using `router-outlet`. The final configuration
    is a list of one or more children that defines the routing for the child components.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个配置`path: ''builder''`设置了子路由的基本URL，以便每个子路由都会将其作为前缀。下一个配置将`WorkoutBuilder`组件标识为此文件中子组件的特色区域根组件。这意味着它将是每个子组件使用`router-outlet`显示的组件。最后的配置是一个或多个子级，定义了子组件的路由。'
- en: 'One thing to note here is that we have set up `Workouts` as the default for
    the child routes with the following configuration:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，我们已经设置`Workouts`作为默认的子路由，配置如下：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This configuration indicates that if someone navigates to `builder`, they will
    be redirected to the `builder/workouts` route. The `pathMatch: ''full''` setting
    means that the match will only be made if the path after workout/builder is an
    empty string. This prevents the redirection from happening if the routes are something
    else, such as `workout/builder/exercises` or any of the other routes we have configured
    within this file.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '这个配置表示如果有人导航到`builder`，它们将被重定向到`builder/workouts`路由。`pathMatch: ''full''`设置意味着只有当workout/builder之后的路径为空字符串时才会进行匹配。这可以防止如果路由是其他内容，比如`workout/builder/exercises`或者在这个文件中配置的其他路由，那么重定向就不会发生。'
- en: 'Finally, add the following class declaration preceded by an `@NgModule` decorator
    that defines imports and exports for our module:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加以下类声明，前面有一个`@NgModule`装饰器，定义了我们模块的导入和导出：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This import is very similar to the one in `app.routing-module.ts`, with one
    difference - instead of `RouterModule.forRoot`, we are using `RouterModule.forChild`.
    The reason for the difference may seem self-explanatory: we are creating child
    routes, not the routes in the root of the application, and this is how we signify
    that. Under the hood, however, there is a significant difference. This is because
    we cannot have more than one router service active in our application. `forRoot`
    creates the router service but `forChild` does not.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入与`app.routing-module.ts`中的导入非常相似，只有一个区别 - 我们使用的是`RouterModule.forChild`，而不是`RouterModule.forRoot`。这种差异的原因似乎是不言自明的：我们创建子路由，而不是应用程序根目录中的路由，这就是我们表示的方式。然而，在底层，有一个显著的区别。这是因为我们的应用程序中不能有多个路由器服务处于激活状态。`forRoot`创建路由器服务，但`forChild`不会。
- en: Updating the WorkoutBuilder component
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新WorkoutBuilder组件
- en: 'We next need to update the `WorkoutBuilder` component to support our new child
    routes. To do so, change the `@Component` decorator for Workout Builder to:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要更新`WorkoutBuilder`组件以支持我们的新子路由。为此，将Workout Builder的`@Component`装饰器改为：
- en: Remove the `selector`
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除`selector`
- en: Add a `<abe-sub-nav-main>` custom element to the template
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中添加一个`<abe-sub-nav-main>`自定义元素
- en: Add a `<router-outlet>` tag to the template
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中添加一个`<router-outlet>`标签
- en: 'The decorator should now look like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器现在应该看起来像下面这样：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are removing the selector because `WorkoutBuilderComponent` will not be embedded
    in the application root, `app.component.ts`. Instead, it will be reached from
    `app.routing-module.ts` through routing. And while it will handle incoming routing
    requests from `app.routes.ts`, it will, in turn, be routing them to the other
    components contained in the Workout Builder feature.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除选择器，因为`WorkoutBuilderComponent`不会被嵌入到应用程序根目录`app.component.ts`中。相反，它将通过路由从`app.routing-module.ts`中到达。虽然它将处理来自`app.routes.ts`的传入路由请求，但它将反过来将它们路由到Workout
    Builder特色中包含的其他组件。
- en: And those components will display their views using the `<router-outlet>` tag
    that we have just added to the `WorkoutBuilder` template. Given that the template
    for `Workout BuilderComponent` will be simple, we are using an inline `template`
    instead of a `templateUrl`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件将使用我们刚刚添加到`WorkoutBuilder`模板中的`<router-outlet>`标签来显示它们的视图。考虑到`Workout BuilderComponent`的模板将是简单的，我们使用内联`template`而不是`templateUrl`。
- en: Typically, for a component's view we recommend using a `templateUrl` that points
    to a separate HTML template file. This is especially true when you anticipate
    that the view will involve more than a few lines of HTML. In that situation, it
    is much easier to work with a view inside its own HTML file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们建议为组件的视图使用`templateUrl`指向一个单独的HTML模板文件。特别是当你预期该视图会涉及超过几行HTML时。在这种情况下，更容易处理一个视图在其自己的HTML文件中。
- en: We are also adding an `<abe-sub-nav-main>` element that will be used to create
    a secondary top-level menu for navigating within the *Workout Builder* feature.
    We'll discuss that a little later in this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`<abe-sub-nav-main>`元素，它将用于创建用于在*Workout Builder*功能内进行导航的二级顶级菜单。我们稍后在本章中会讨论这一点。
- en: Updating the Workout Builder module
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Workout Builder模块
- en: 'Now, let''s update `WorkoutBuilderModule`.  First, add the following import
    to the file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们更新`WorkoutBuilderModule`。首先，在文件中添加以下导入:'
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It imports the child routing that we just set up. Next, update the `@NgModule`
    decorator to add `workoutBuilderRoutingModule`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '它导入了我们刚刚设置的子路由。接下来，更新`@NgModule`装饰器以添加`workoutBuilderRoutingModule`:'
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, add the imports and declarations for the new navigation components
    that can be found in `checkpoint4.2`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，添加新的导航组件的导入和声明，可以在`checkpoint4.2`中找到:'
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Updating App Routing module
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新App路由模块
- en: 'One last step: return to `app.routing-module.ts` and remove the import of the
    `WorkoutBuilderComponent` and the route definition that points to the builder:`{
    path: ''builder'', component: WorkoutBuilderComponent },`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一步：返回`app.routing-module.ts`，删除`WorkoutBuilderComponent`的导入和指向构建器的路由定义：`{
    path: ''builder'', component: WorkoutBuilderComponent },`。'
- en: Be sure to leave the import of the `WorkoutBuilderModule`  in `app.module.ts`
    unchanged. We'll discuss removing that in the next section when we cover lazy
    loading.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不要改变在`app.module.ts`中的`WorkoutBuilderModule`的导入。当我们讨论懒加载时，我们会在下一节中讨论删除它。
- en: Putting it all together
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容组合在一起
- en: We now have area or feature routing that contains child routes, and all the
    routes related to the *Workout Builder* are now separately contained in their
    own routing configuration. This means that we can manage all the routing for *Workout
    Builder* in the `WorkoutBuilderRoutes` component without affecting other parts
    of the application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有包含子路由的区域或功能路由，并且与*Workout Builder*相关的所有路由都分别包含在它们自己的路由配置中。这意味着我们可以在`WorkoutBuilderRoutes`组件中管理*Workout
    Builder*的所有路由，而不影响应用程序的其他部分。
- en: 'We can see how the router combines the routes in `app.routes.ts` with the default
    route in `workout-builder.routes.ts`, if we now navigate from the start page to
    the Workout Builder:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们现在从开始页面导航到Workout Builder，我们可以看到路由如何将`app.routes.ts`中的路由与`workout-builder.routes.ts`中的默认路由组合在一起:'
- en: '![](img/879d478e-200d-4a7f-9f42-46cda87c2735.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/879d478e-200d-4a7f-9f42-46cda87c2735.png)'
- en: If we look at the URL in the browser, it is `/builder/workouts`. You'll recall
    that the router link on the start page is `['/builder']`. So how did the router
    take us to this location?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中查看URL，它是`/builder/workouts`。你会记得开始页面上的路由链接是`['/builder']`。那么路由是如何带我们到这个位置的呢？
- en: 'It does it this way: when the link is clicked, the Angular router first looks
    to `app-routing.module.ts` for the `builder` path because that file contains the
    configuration for the root routes in our application. The router does not find
    that path because we have removed it from the routes in that file.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它是这样做的：当链接被点击时，Angular路由器首先查找`app-routing.module.ts`中的`builder`路径，因为该文件包含了我们应用程序中根路由的配置。路由器没有找到该路径，因为我们已经从该文件的路由中删除了它。
- en: However, `WorkoutBuilderModule` has been imported into our `AppModule` and that
    module in turn imports `workoutBuilderRoutingModule`. The latter file contains
    the child routes that we just configured. The router finds that `builder` is the
    parent route in that file and so it uses that route. It also finds the default
    setting that redirects to the child path `workouts` in the event that the `builder`
    path ends with an empty string, which it does in this case.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`WorkoutBuilderModule`已经被导入到`AppModule`中，而该模块又导入`workoutBuilderRoutingModule`。后者文件包含了我们刚刚配置的子路由。路由器发现`builder`是该文件中的父路由，因此它使用该路由。它还找到了默认设置，该设置将在`builder`路径以空字符串结尾时重定向到子路径`workouts`。
- en: If you look at the screen, you will see it is displaying the view for `Workouts`
    (and not as previously *Workout Builder*). This means that the router has successfully
    routed the request to `WorkoutsComponent`, which is the component for the default
    route in the child route configuration that we set up in `workoutBuilderRoutingModule`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看屏幕，您会看到它显示的是`Workouts`的视图（而不是以前的*Workout Builder*）。这意味着路由器已成功将请求路由到`WorkoutsComponent`，这是我们在`workoutBuilderRoutingModule`中设置的子路由配置中的默认路由的组件。
- en: 'This process of route resolution is illustrated here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 路由分辨过程如下所示：
- en: '![](img/a8a361ee-a043-4814-893c-6eb4cb067fc0.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8a361ee-a043-4814-893c-6eb4cb067fc0.png)'
- en: One final thought on child routing. When you look at our child routing component, `workout-builder.component.ts`,
    you will see that it has no references to its parent component, `app.component.ts`
    (the `<selector>` tag has been removed, so  `WorkoutBuilderComponent`  is not
    being embedded in the root component). This means that we have successfully encapsulated
    `WorkoutBuilderComponent` (and all of its related components that are imported
    in the `WorkoutBuilderModule`) in a way that will allow us to move all of it elsewhere
    in the application, or even into a new application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于子路由的最后一个想法。当您查看我们的子路由组件`workout-builder.component.ts`时，您会发现它没有引用其父组件`app.component.ts`（`<selector>`标签已被删除，因此`WorkoutBuilderComponent`没有嵌入在根组件中）。这意味着我们已经成功地封装了`WorkoutBuilderComponent`（以及在`WorkoutBuilderModule`中导入的所有相关组件），这将使我们能够将其全部移到应用程序的其他位置，甚至是到一个新的应用程序中。
- en: Now, it's time for us to move on to converting our routing for the Workout Builder
    to use lazy loading and building out its navigation menus. If you want to see
    the completed code for this next section, you can download it from the companion
    codebase in `checkpoint 4.3`. Again, if you are working along with us as we build
    the application, be sure and update the `styles.css` file, which we are not discussing
    here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将我们的Workout Builder的路由转换为使用延迟加载，并构建其导航菜单了。如果您想查看此下一部分的已完成代码，您可以从`checkpoint
    4.3`中的相关代码库中进行下载。同样，如果您正在跟着我们构建应用程序，请确保更新`styles.css`文件，这里我们不讨论。
- en: 'The code is also available on GitHub: [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.3` (folder - `trainer`). If you are not using
    Git, download the snapshot of `Checkpoint 4.3` (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 代码也可以在GitHub上找到：[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。检查点在GitHub中实现为分支。要下载的分支如下：`GitHub分支：checkpoint4.3`（文件夹
    - `trainer`）。如果您没有使用Git，请从以下GitHub位置下载`Checkpoint 4.3`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Lazy loading of routes
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由的延迟加载
- en: When we roll out our application, we expect that our users will be accessing
    the Workout Runner every day (and we know that this will be the case for you!).
    But, we anticipate that they will only occasionally be using the Workout Builder
    to construct their exercises and workout plans. It would, therefore, be nice if
    we could avoid the overhead of loading the Workout Builder when our users are
    just doing their exercises in the Workout Runner. Instead, we would prefer to
    load Workout Builder only on demand when a user wants to add to or update their
    exercises and workout plans. This approach is called **lazy loading**. Lazy loading
    allows us to employ an asynchronous approach when loading our modules. This means
    that we can load just what is required to get the application started and then
    load other modules as we need them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们推出我们的应用程序时，我们期望我们的用户每天都会访问Workout Runner（我们知道这对你来说是必须的！）。但是，我们预计他们只会偶尔使用Workout
    Builder来构建他们的练习和锻炼计划。因此，如果我们能够避免在用户只是在Workout Runner中做练习时加载Workout Builder的开销，那将是很好的。相反，我们更希望在用户想要添加或更新他们的练习和锻炼计划时，仅在需要时加载Workout
    Builder。这种方法称为**延迟加载**。延迟加载允许我们在加载模块时采用异步方法。这意味着我们可以仅加载启动应用程序所需的内容，然后在需要时加载其他模块。
- en: Under the hood, when we use the Angular CLI to build and serve our application,
    it uses WebPack's bundling and chunking capabilities to accomplish lazy loading.
    We'll be discussing these capabilities as we work through how to implement lazy
    loading in our application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，当我们使用 Angular CLI 构建和提供我们的应用程序时，它使用了 WebPack 的捆绑和分块功能来实现惰性加载。在我们实现应用程序中的惰性加载时，我们将讨论这些功能。
- en: So in our *Personal Trainer*, we want to change the application so that it only
    loads the **Workout Builder** on demand. And the Angular router allows us to do
    just that using lazy loading.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的 *个人健身教练* 中，我们希望更改应用程序，以便只在需要时才加载**Workout Builder**。而 Angular 路由器允许我们仅仅用惰性加载来实现这一点。
- en: 'But before we get started implementing lazy loading, let''s take a look at
    our current application and how it is loading our modules. With the developer
    tools open in the Sources tab, start up the application; when the start page appears
    in your browser, if you look under the webpack node in the source tree, you will
    see that all the files in the application have loaded, including both the *Workout
    Runner* and *Workout Builder* files:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但在开始实现惰性加载之前，让我们来看看我们当前的应用程序以及它如何加载我们的模块。在开发者工具中的"来源"选项卡打开后，启动应用程序；当你的浏览器中出现起始页面时，如果你在源树中查看
    web pack 节点下，你将看到应用程序中加载的所有文件，包括 *Workout Runner* 和 *Workout Builder* 文件：
- en: '![](img/a3d91ddd-3613-4e72-af09-10f7c84551a8.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3d91ddd-3613-4e72-af09-10f7c84551a8.png)'
- en: So, even though we may just want to use the *Workout Runner*, we have to load
    the *Workout Builder* as well. In a way, this makes sense if you think of our
    application as a **Single Page Application** (**SPA**). In order to avoid round
    trips to the server, an SPA will typically load all the resources that will be
    needed to use the application when it is first started up by a user. But in our
    case, the important point is that we do not need the *Workout Builder* when the
    application is first loaded. Instead, we would like to load those resources only
    when the user decides that they want to add or change a workout or exercise.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使我们可能只想使用 *Workout Runner*，我们也必须加载 *Workout Builder*。在某种程度上，如果你将我们的应用程序视为**单页面应用程序**（**SPA**），这是有道理的。为了避免与服务器的往返，SPA通常会在用户首次启动应用程序时加载所有需要使用应用程序的资源。但就我们来说，重要的一点是，当应用程序首次加载时，我们不需要
    *Workout Builder*。相反，我们希望只有在用户决定添加或更改训练或练习时才加载这些资源。
- en: So, let's get started with making that happen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始做到这一点。
- en: 'First, modify `app.routing-module.ts` to add the following route configuration
    for `WorkoutBuilderModule`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改 `app.routing-module.ts` 以添加以下路由配置用于 `WorkoutBuilderModule`：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice that the `loadChildren` property is:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `loadChildren` 属性是：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This configuration provides the information that will be needed to load and
    instantiate `WorkoutBuilderModule`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置提供了加载和实例化 `WorkoutBuilderModule` 所需的信息。
- en: 'Next go back to `workout-builder-routing.module.ts` and change the `path` property
    to an empty string:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来回到 `workout-builder-routing.module.ts` 并将 `path` 属性更改为空字符串：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are making this change because we are now setting the path (`builder`) to
    the `WorkoutBuilderRoutes` in the new configuration for them that we added in
    `app.routing-module.ts`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行此更改是因为现在我们将 `path`（`builder`）设置为 `app.routing-module.ts` 中新增的对应的 `WorkoutBuilderRoutes`
    的新配置中。
- en: Finally go back to `app-module.ts`  and remove the `WorkoutBuilderModule` import
    in the `@NgModule` configuration in that file. What this means is that instead
    of loading the **Workout Builder** feature when the application first starts,
    we only load it when a user accesses the route to *Workout Builder*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回到 `app-module.ts` ，并在该文件中的 `@NgModule` 配置中移除 `WorkoutBuilderModule` 的导入。这意味着，与其在应用程序首次启动时加载**Workout
    Builder**功能，我们只在用户访问*Workout Builder*路由时加载它。
- en: 'Let''s go build and run the application again using `ng serve`. In the Terminal
    window, you should see something like the following output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `ng serve` 再次构建和运行应用程序。在终端窗口中，你应该看到类似如下的输出：
- en: '![](img/4ac5d80c-d801-4ec7-acdf-5b4e30f5174e.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ac5d80c-d801-4ec7-acdf-5b4e30f5174e.png)'
- en: What's interesting here is the last line that shows a separate file for the
    `workout.builder.module` called `workout-builder.module.chunk.js.`. **WebPack**
    has used what is called code splitting to carve out our workout builder module
    into a separate chunk. This chunk will not be loaded in our application until
    it is needed (that is when the router navigates to `WorkoutBuilderModule`).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的地方在于最后一行显示了一个名为`workout.builder.module`的单独文件，名为`workout-builder.module.chunk.js.`。**WebPack**使用了所谓的代码拆分来将我们的锻炼构建模块划分为一个单独的块。该块在需要时才会在我们的应用程序中加载（即路由器导航到`WorkoutBuilderModule`时）。
- en: 'Now, keeping the Sources tab open in the Chrome developer tools bring up the
    application in the browser again. When the start page loads, only the files related
    to the *Workout Runner* appear and not those related to the *Workout Builder*,
    as shown here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 Chrome 开发者工具中保持 Sources 标签页打开，再次在浏览器中打开应用程序。当起始页面加载时，只有与*Workout Runner*相关的文件出现，而与*Workout
    Builder*相关的文件却没有出现，如下图所示：
- en: '![](img/be994372-be5b-4fb3-bfcc-1aa0a96f2ded.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be994372-be5b-4fb3-bfcc-1aa0a96f2ded.png)'
- en: 'Then, if we clear the Network tab and click on the Create a Workout link, we''ll
    see the `workout-builder.module` chunk load:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们清除网络标签页并点击“创建锻炼”链接，我们将看到加载`workout-builder.module`块：
- en: '![](img/adfb8093-199e-4ef7-8afa-984364ffeeec.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adfb8093-199e-4ef7-8afa-984364ffeeec.png)'
- en: This means that we have achieved encapsulation of our new feature and with asynchronous
    routing we are able to use lazy loading to load all its components only when needed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经实现了我们新功能的封装，并且通过异步路由，我们能够使用惰性加载在需要时加载所有其组件。
- en: Child and asynchronous routing make it straightforward to implement applications
    that allow us to have our cake and eat it too. On one hand, we can build SPAs
    with powerful client-side navigation, while on the other hand we can also encapsulate
    features in separate child routing components and load them only on demand.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 子级和异步路由使得实现允许我们应用程序在客户端具有强大导航的同时，还可以将功能封装在单独的子路由组件中，并且只在需要时加载它们变得简单。
- en: This power and flexibility of the Angular router give us the ability to meet
    user expectations by closely mapping our application's behavior and responsiveness
    to the ways they will use the application. In this case, we have leveraged these
    capabilities to achieve what we set out to do: immediately load *Workout Runner *so
    that our users can get to work on their exercises right away, but avoid the overhead
    of loading *Workout Builder *and instead only serve it when a user wants to build
    a workout.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由器的这种强大和灵活性赋予我们能力，通过密切映射应用程序的行为和响应性来满足用户的期望。在这种情况下，我们利用了这些功能来实现我们的目标：*立即加载Workout
    Runner*，这样我们的用户就可以立即开始锻炼，但避免加载*Workout Builder*的开销，而是在用户想要构建锻炼时才加载它。
- en: Now that we have the routing configuration in place in the *Workout Builder*,
    we will turn our attention to building out the sub-level and left navigation;
    this will enable us to use this routing. The next sections cover implementing
    this navigation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在*Workout Builder*中设置好了路由配置，我们将把注意力转向构建子级和左侧导航；这将使我们能够使用此路由。接下来的部分将介绍实现此导航。
- en: Integrating sub- and side-level navigation
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成子级和侧边级导航
- en: The basic idea around integrating sub- and side-level navigation into the app
    is to provide context-aware sub-views that change based on the active view. For
    example, when we are on a list page as opposed to editing an item, we may want
    to show different elements in the navigation. An e-commerce site is a great example
    of this. Imagine Amazon's search result page and product detail page. As the context
    changes from a list of products to a specific product, the navigation elements
    that are loaded also change.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将子级和侧面级导航集成到应用程序的基本理念是为基于活动视图变化而变化的上下文感知子视图提供支持。例如，当我们在列表页面而不是编辑项目时，我们可能希望在导航中显示不同的元素。一个很好的例子是电子商务网站。想象亚马逊的搜索结果页面和产品详情页面。随着上下文从产品列表变为特定产品，加载的导航元素也会发生变化。
- en: Sub-level navigation
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子级导航
- en: 'We''ll start by adding sub-level navigation to the *Workout Builder*. We have
    already imported our `SubNavMainComponent` into the *Workout Builder*. But, currently
    it is just displaying placeholder content:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在*Workout Builder*中添加子级导航。我们已经将`SubNavMainComponent`导入到*Workout Builder*中。但是，目前它只显示占位内容：
- en: '![](img/28e60e18-8309-4acd-b151-5b2a584a74ee.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28e60e18-8309-4acd-b151-5b2a584a74ee.png)'
- en: 'We''ll now replace that content with three router links: Home, New Workout,
    and New Exercise.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将用三个路由链接替换该内容：首页、新锻炼和新练习。
- en: 'Open the `sub-nav-main.component.html` file and change the HTML in it to the
    following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`sub-nav-main.component.html`文件，并将其HTML更改为以下内容：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, rerun the application and you will see the three navigation links. If
    we click on the New Exercise link button, we will be routed to `ExerciseComponent`
    and its view will appear in the Router Outlet in the *Workout Builder* view:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新运行应用程序，你将会看到三个导航链接。如果我们点击“新练习”链接按钮，我们将被路由到`ExerciseComponent`，并且其视图将会出现在*Workout
    Builder*视图的路由器出口中。
- en: '![](img/0fb35542-d5c7-42b7-bc20-2a5f20ca0b98.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fb35542-d5c7-42b7-bc20-2a5f20ca0b98.png)'
- en: The New Workout link button will work in a similar fashion; when clicked on,
    it will take the user to the `WorkoutComponent` and display its view in the router
    outlet. Clicking on the Home link button will return the user to the `WorkoutsComponent` and
    view.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 新锻炼链接按钮的工作方式类似；点击时，它将把用户带到`WorkoutComponent`并在路由器出口中显示其视图。点击首页链接按钮将返回用户到`WorkoutsComponent`和视图。
- en: Side navigation
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边导航
- en: Side-level navigation within the *Workout Builder* will vary depending on the
    child component that we navigate to. For instance, when we first navigate to the
    *Workout Builder*, we are taken to the Workouts screen because the `WorkoutsComponent` route
    is the default route for the *Workout Builder*. That component will need side
    navigation; it will allow us to select to view a list of workouts or a list of
    exercises.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*Workout Builder*内的侧边导航将根据我们导航到的子组件而异。例如，当我们首次导航到*Workout Builder*时，我们被带到了锻炼屏幕，因为`WorkoutsComponent`路由是*Workout
    Builder*的默认路由。该组件将需要侧边导航；它将允许我们选择查看锻炼列表或练习列表。'
- en: 'The component-based nature of Angular gives us an easy way to implement these
    context-sensitive menus. We can define new components for each of the menus and
    then import them into the components that need them. In this case, we have three
    components that will need side menus: **Workouts**, **Exercises**, and **Workout**.
    The first two of these components can actually use the same menu so we really
    only need two side menu components: `LeftNavMainComponent`, which will be like
    the preceding menu and will be used by the `Exercises` and `Workouts` components,
    and `LeftNavExercisesComponent`, which will contain a list of existing exercises
    and will be used by the `Workouts` component.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的基于组件的特性为我们实现这些上下文敏感菜单提供了一种简单的方法。我们可以为每个菜单定义新的组件，然后将其导入到需要它们的组件中。在这种情况下，我们有三个需要侧边菜单的组件：**锻炼**，**练习**和**锻炼**。前两个组件实际上可以使用相同的菜单，所以我们实际上只需要两个侧边菜单组件：`LeftNavMainComponent`，它将类似于前面的菜单，并将被`Exercises`和`Workouts`组件使用，以及`LeftNavExercisesComponent`，它将包含现有练习列表，并将被`Workouts`组件使用。
- en: We already have files for the two menu components, including template files,
    and have imported them into `WorkoutBuilderModule`. We will now integrate these
    into the components that need them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了两个菜单组件的文件，包括模板文件，并已将它们导入到`WorkoutBuilderModule`。我们现在将把它们整合到需要它们的组件中。
- en: 'First, modify the `workouts.component.html` template to add the selector for
    the menu:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改`workouts.component.html`模板以添加菜单的选择器：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, replace the placeholder text in the `left-nav-main.component.html` with
    the navigation links to `WorkoutsComponent` and `ExercisesComponent`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`left-nav-main.component.html`中用导航链接替换占位符文本到`WorkoutsComponent`和`ExercisesComponent`：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the application and you should see the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，你应该看到以下内容：
- en: '![](img/021d2798-3ff7-47bf-8fe9-e122f98333f0.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/021d2798-3ff7-47bf-8fe9-e122f98333f0.png)'
- en: Follow the exact same steps to complete the side menu for the `Exercises` component.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循完全相同的步骤来完成`Exercises`组件的侧边菜单。
- en: We won't show the code for this menu here, but you can find it in the `workout-builder/exercises`
    folder under `trainer/src/app` in `checkpoint 4.3` of the GitHub repository.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里展示菜单的代码，但你可以在GitHub存储库的`checkpoint 4.3`中`trainer/src/app`下的`workout-builder/exercises`文件夹中找到它。
- en: 'For the menu for the Workout screen, the steps are the same except that you
    should change `left-nav-exercises.component.html` to the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于锻炼屏幕的菜单，步骤相同，只是你应该将`left-nav-exercises.component.html`更改为以下内容：
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will use this template as the starting point for building out a list of exercises
    that will appear on the left-hand side of the screen and can be selected for inclusion
    in a workout.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个模板作为构建出现在屏幕左侧的锻炼列表的起点，并且可以选择加入到锻炼中的起点。
- en: Implementing workout and exercise lists
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施运动和练习列表
- en: Even before we start implementing the Workout and Exercise list pages, we need
    a data store for exercise and workout data. The current plan is to have an in-memory
    data store and expose it using an Angular service. In [Chapter 3](cba52e86-29c5-4c51-a34f-5db71de16503.xhtml),
    *Supporting Server Data Persistence*, where we talk about server interaction,
    we will move this data to a server store for long-term persistence. For now, the
    in-memory store will suffice. Let's add the store implementation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在我们开始实现运动和练习列表页面之前，我们需要一个用于练习和运动数据的数据存储。当前计划是使用内存数据存储并使用Angular服务公开它。在[第3章](cba52e86-29c5-4c51-a34f-5db71de16503.xhtml)中，*支持服务器数据持久化*中，我们会将这些数据移到服务器存储以进行长期持久化。目前，内存存储就足够了。让我们添加存储实现。
- en: WorkoutService as a workout and exercise repository
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WorkoutService作为运动和练习库
- en: 'The plan here is to create a `WorkoutService` instance that is responsible
    for exposing the exercise and workout data across the two applications. The main
    responsibilities of the service include:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的计划是创建一个`WorkoutService`实例，负责在两个应用程序之间公开运动和锻炼数据。服务的主要职责包括：
- en: '**Exercise-related CRUD operations**: Get all exercises, get a specific exercise
    based on its name, create an exercise, update an exercise, and delete it'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与练习相关的CRUD操作**：获取所有练习，根据名称获取特定练习，创建练习，更新练习并删除它'
- en: '**Workout-related CRUD operations**: These are similar to the exercise-related
    operations, but targeted toward the workout entity'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与锻炼相关的CRUD操作**：这些操作与与运动相关的操作类似，但针对的是运动实体'
- en: 'The code is available to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    The branch to download is as follows: **GitHub Branch: checkpoint4.4** (folder`trainer`).
    If you are not using Git, download the snapshot of `Checkpoint 4.4` (a ZIP file)
    from the following GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure to update the `styles.css` file, which we are not discussing here. Because
    some of the files in this section are rather long, rather than showing the code
    here, we are also going to suggest at times that you simply copy the files into
    your solution.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可在GitHub上下载，链接为[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。要下载的分支如下：**GitHub分支：checkpoint4.4**（文件夹`trainer`）。如果您不使用Git，请从以下GitHub位置下载`Checkpoint
    4.4`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。再次提醒，如果您跟随我们构建应用程序，请确保更新`styles.css`文件，这里我们不讨论。由于本节中的一些文件相当长，而不是在这里显示代码，我们有时还会建议您简单地将文件复制到您的解决方案中。
- en: 'Locate `workout-service.ts` in the `trainer/src/core` folder. The code in that
    file should look like the following, except for the implementation of the two
    methods `setupInitialExercises` and `setupInitialWorkouts`, which we have left
    out because of their length:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trainer/src/core`文件夹中找到`workout-service.ts`。该文件中的代码应该如下所示，除了我们由于长度而留出的两个方法`setupInitialExercises`和`setupInitialWorkouts`的实现：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we have mentioned before, the implementation of an Angular service is straightforward.
    Here, we are declaring a class with the name `WorkoutService` and decorating it
    with `@Injectable` . Within the `@Injectable` decorator, we have set the `provided-in`
    property to `CoreModule`.  This registers `WorkoutService` as a provider with
    Angular's **Dependency Injection** framework and makes it available throughout
    our application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Angular服务的实现是直截了当的。在这里，我们声明了一个名为`WorkoutService`的类，并用`@Injectable`进行装饰。在`@Injectable`装饰器中，我们设置了`provided-in`属性为`CoreModule`。这样就把`WorkoutService`注册为Angular的**依赖注入**框架的提供者，并使其在整个应用程序中可用。
- en: In the class definition, we first create two arrays: one for `Workouts` and
    one for `Exercises`. These arrays are of types `WorkoutPlan` and `Exercise` respectively,
    and we, therefore, need to import `WorkoutPlan` and `Exericse` from `model.ts`
    to get the type definitions for them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义中，我们首先创建两个数组：一个用于`Workouts`，一个用于`Exercises`。这些数组分别属于`WorkoutPlan`和`Exercise`类型，因此我们需要从`model.ts`中导入`WorkoutPlan`和`Exericse`以获取它们的类型定义。
- en: The constructor calls two methods to set up the Workouts and Services List.
    At the moment, we are just using an in-memory store that populates these lists
    with data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '-   构造函数调用两个方法来设置Workouts和Services列表。目前，我们只是使用一个内存存储来填充这些列表数据。'
- en: The two methods, `getExercises` and `getWorkouts`, as the names suggest, return
    a list of exercises and workouts respectively. Since we plan to use the in-memory
    store to store workout and exercise data, the `Workouts` and `Exercises` arrays
    store this data. As we go along, we will be adding more functions to the service.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '-   两个方法，`getExercises`和`getWorkouts`，顾名思义，分别返回练习和锻炼的列表。由于我们计划使用内存存储来存储锻炼和锻炼数据，`Workouts`和`Exercises`数组存储着这些数据。随着我们的进展，我们将向服务添加更多的功能。'
- en: Time to build out the components for the workout and exercise lists!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '-   是时候为锻炼和练习列表构建组件了！'
- en: Workout and exercise list components
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '-   训练和锻炼列表组件'
- en: 'First, open the `workouts.component.ts` file in the `trainer/src/app/workout-builder/workouts`
    folder and update the imports as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '-   首先，打开`trainer/src/app/workout-builder/workouts`文件夹中的`workouts.component.ts`文件，并按以下方式更新导入：'
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This new code imports the Angular  `Router` as well as `WorkoutService` and
    the `WorkoutPlan` type.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '-   这段新代码导入了Angular的`Router`，以及`WorkoutService`和`WorkoutPlan`类型。'
- en: 'Next, replace the class definition with the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '-   接下来，用以下代码替换类定义：'
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code adds a constructor into which we are injecting the `Router` and the
    `WorkoutService`. The `ngOnInit` method then calls the `getWorkouts` method on
    the `WorkoutService` and populates a `workoutList`  array with a list of `WorkoutPlans`
    returned from that method call. We'll use that `workoutList` array to populate
    the list of workout plans that will display in the `Workouts` component's view.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '-   这段代码在构造函数中添加了`Router`和`WorkoutService`。然后，在`ngOnInit`方法中调用`WorkoutService`的`getWorkouts`方法，并用从该方法调用返回的`WorkoutPlans`列表填充了一个`workoutList`数组。我们将使用`workoutList`数组来填充将在`Workouts`组件视图中显示的锻炼计划列表。'
- en: You'll notice that we are putting the code for calling `WorkoutService` into
    the `ngOnInit` method. We want to avoid placing this code in the constructor.
    Eventually, we will be replacing the in-memory store that this service uses with
    a call to an external data store and we do not want the instantiation of our component
    to be affected by this call. Adding these method calls to the constructor would
    also complicate testing the component.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '-   你会注意到，我们将调用`WorkoutService`的代码放在了`ngOnInit`方法中。我们不想把这段代码放在构造函数中。最终，我们将把这个服务使用的内存存储替换为对外部数据存储的调用，我们不希望我们组件的实例化受到这个调用的影响。将这些方法调用添加到构造函数中也会使组件的测试变得更加复杂。'
- en: To avoid such unintended side effects, we instead place the code in the `ngOnInit`
    method. This method implements one of Angular's lifecycle hooks, `OnInit`, which
    Angular calls after creating an instance of the service. This way, we rely on
    Angular to call this method in a predictable way that does not affect the instantiation
    of the component.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '-   为避免这种意外副作用，我们将代码放在`ngOnInit`方法中。这个方法实现了Angular的生命周期钩子之一，`OnInit`，Angular在创建服务实例后调用这个方法。这样，我们依赖于Angular以一种可预测的方式调用这个方法，不会影响组件的实例化。'
- en: Next, we'll make almost identical changes to the `Exercises` component. As with
    the `Workouts` component, this code injects the workout service into our component.
    This time, we then use the workout service to retrieve the exercises.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '-   接下来，我们将对`Exercises`组件进行几乎相同的更改。与`Workouts`组件一样，这段代码将锻炼服务注入到我们的组件中。这次，我们然后使用锻炼服务来检索练习。'
- en: As it is similar to the `Workouts` component, we won't show that code here.
    Just add it from the `workout-builder/exercises` folder in  `checkpoint 4.4`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '-   由于这与`Workouts`组件类似，我们这里不会显示代码。只需从`检查点4.4`的`workout-builder/exercises`文件夹中添加它。'
- en: Workout and exercise list views
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '-   锻炼和练习列表视图'
- en: Now, we need to implement the list views that have so far been empty!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '-   现在，我们需要实现到目前为止一直为空的列表视图！'
- en: In this section, we will be updating the code from `checkpoint 4.3` with `checkpoint
    4.4`. So if you are coding along with us, simply follow the steps laid out in
    this section. If you want to see the finished code, then just copy the files from
    `checkpoint 4.4` into your solution.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '-   在本节中，我们将用`检查点4.4`更新`检查点4.3`的代码。所以，如果你正在跟着我们编码，只需按照本节中列出的步骤进行操作。如果你想看到完成的代码，那就把`检查点4.4`的文件复制到你的解决方案中。'
- en: Workouts list views
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '-   工作列表视图'
- en: 'To get the view working, open `workouts.component.html` and add the following
    markup:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '-   要使视图正常工作，打开`workouts.component.html`并添加以下标记：'
- en: '[PRE24]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are using one of the Angular core directives, `ngFor`, to loop through the
    list of workouts and display them in a list on the page. We add the `*` sign in
    front of `ngFor` to identify it as an Angular directive. Using a `let` statement,
    we assign `workout` as a local variable that we use to iterate through the workout
    list and identify the values to be displayed for each workout (for example, `workout.title`).
    We then use one of our custom pipes, `orderBy`, to display a list of workouts
    in alphabetical order by title. We are also using another custom pipe, `secondsToTime`,
    to format the time displayed for the total workout duration.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Angular核心指令之一，`ngFor`，来循环遍历锻炼计划列表并在页面上以列表形式显示它们。我们在`ngFor`前面添加`*`号来标识它为Angular指令。使用`let`语句，我们将`workout`分配为一个本地变量，我们用它来遍历锻炼计划列表并识别每个锻炼计划要显示的值（例如`workout.title`）。然后，我们使用我们的自定义管道之一，`orderBy`，以按标题字母顺序显示锻炼计划列表。我们还使用另一个自定义管道，`secondsToTime`，来格式化显示总锻炼计划持续时间的时间。
- en: If you are coding along with us, you will need to move the `secondsToTime` pipe
    into the shared folder and include it in the `SharedModule`. Then, add `SharedModule`
    to `WorkoutBuilderModule` as an additional import. That change has already been
    made in `checkpoint 4.4` in the GitHub repository.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在与我们一起编码，您将需要将`secondsToTime`管道移动到共享文件夹中，并将其包含在`SharedModule`中。然后，将`SharedModule`添加到`WorkoutBuilderModule`作为额外的导入。这个更改已经在GitHub存储库的`checkpoint
    4.4`中进行了。
- en: 'Finally, we bind the click event to the following `onSelect` method that we
    add to our component:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将点击事件绑定到以下`onSelect`方法，我们将其添加到我们的组件中：
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This sets up navigation to the workout details page. This navigation happens
    when we click on an item in the workout list. The selected workout name is passed
    as part of the route`/URL` to the workout detail page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置导航到锻炼计划详情页面。当我们点击锻炼计划列表中的项目时，导航将发生。所选锻炼计划名称作为路由`/URL`的一部分传递到锻炼计划详情页面。
- en: 'Go ahead and refresh the builder page (`/builder/workouts`); one workout is
    listed, the 7 Minute Workout. Click on the tile for that workout. You''ll be taken
    to the Workout screen and the workout name, `7MinWorkout`, will appear at the
    end of the URL:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续刷新构建器页面（`/builder/workouts`）；显示一个锻炼计划，即7分钟锻炼。点击该锻炼计划的瓷砖。您将被带到锻炼屏幕，锻炼计划名称`7MinWorkout`将出现在URL末尾：
- en: '![](img/52e68978-023c-4c2a-baaa-3bdc273eb151.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52e68978-023c-4c2a-baaa-3bdc273eb151.png)'
- en: The Workout screen
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼计划屏幕
- en: Exercises list views
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锻炼计划列表视图
- en: 'We are going to follow the same approach for the `Exercises` list view as we
    did for the `Workouts` list view, except that in this case, we will actually be
    implementing two views: one for the `Exercises` component (which will display
    in the main content area when a user navigates to that component) and one for
    the `LeftNavExercisesComponent` exercises context menu (which will display when
    the user navigates to the `Workouts` component to create or edit a workout).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`锻炼`列表视图，我们将按照与`锻炼计划`列表视图相同的方式进行操作，只是在这种情况下，我们实际上将实现两个视图：一个用于`锻炼`组件（当用户导航到该组件时将显示在主内容区域中），另一个是用于`LeftNavExercisesComponent`锻炼上下文菜单（当用户导航到`锻炼计划`组件以创建或编辑锻炼计划时将显示）。
- en: For the `Exercises` component, we will follow an approach that is almost identical
    to what we did to display a list of workouts in the `Workouts` component. So,
    we won't show that code here. Just add the files for `exercises.component.ts`
    and `exercises.component.html` from `checkpoint 4.4`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`锻炼`组件，我们将遵循几乎与在`锻炼计划`组件中显示锻炼计划列表相同的方法。所以，我们不会在这里显示那些代码。只需添加来自`checkpoint
    4.4`的`exercises.component.ts`和`exercises.component.html`文件。
- en: When you are done copying the files, click on the Exercises link in the left
    navigation to load the 12 exercises that you have already configured in `WorkoutService`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 复制文件完成后，请点击左侧导航中的`锻炼`链接，以加载您在`WorkoutService`中已经配置的12个锻炼计划。
- en: As with the `Workouts` list, this sets up the navigation to the exercise detail
    page. Clicking on an item in the exercises list takes us to the exercise detail
    page. The selected exercise name is passed as part of the route`/URL` to the exercise
    detail page.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 针对`锻炼计划`列表，这将设置导航到锻炼计划详情页面。在锻炼计划列表中点击项目会带我们到锻炼计划详情页面。所选锻炼计划名称作为路由`/URL`的一部分传递到锻炼计划详情页面。
- en: In the final list view, we will add a list of exercises that will display in
    the left context menu for the *Workout Builder* screen. This view is loaded in
    the left navigation when we create or edit a workout. Using Angular's component-based
    approach, we will update the `leftNavExercisesComponent` and its related view
    to provide this functionality. Just add the files for `left-nav-exercises.component.ts`
    and `left-nav-exercises.component.html` from the `trainer/src/app/navigation`
    folder in `checkpoint 4.4`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终列表视图中，我们将添加一个显示在*锻炼计划生成器*屏幕左侧上下文菜单中的锻炼列表。当我们创建或编辑锻炼计划时，该视图会加载在左侧导航中。使用Angular的基于组件的方法，我们将更新`leftNavExercisesComponent`及其相关视图以提供此功能。只需从`trainer/src/app/navigation`文件夹中`checkpoint
    4.4`中添加`left-nav-exercises.component.ts`和`left-nav-exercises.component.html`文件。
- en: Once you are done copying those files, click on the New Workout button on the
    sub-navigation menu in the *Workout Builder* and you will now see a list of exercises
    displayed in the left navigation menu—exercises that we have already configured
    in `WorkoutService`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 复制完那些文件后，点击*锻炼计划生成器*的子导航菜单中的新建锻炼计划按钮，您将会在左侧导航菜单中看到一份现有配置在`WorkoutService`中的锻炼的列表。
- en: Time to add the ability to load, save, and update exercise/workout data!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加加载、保存和更新锻炼/锻炼计划数据的功能了！
- en: Building a workout
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建锻炼计划
- en: The core functionality *Personal Trainer* provides centers around workout and
    exercise building. Everything is there to support these two functions. In this
    section, we focus on building and editing workouts using Angular.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*个人健身教练*提供的核心功能主要集中在锻炼和锻炼计划的构建上。所有功能都旨在支持这两个功能。在这一部分，我们将重点放在使用Angular构建和编辑锻炼计划。'
- en: The `WorkoutPlan` model has already been defined, so we are aware of the elements
    that constitute a workout. The *Workout Builder* page facilitates user input and
    lets us build/persist workout data.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutPlan`模型已经定义，因此我们知道构成锻炼计划的各个元素。*锻炼计划生成器*页面促进用户输入，并允许我们构建/保存锻炼计划数据。'
- en: 'Once complete, the *Workout Builder* page will look like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，*锻炼计划生成器*页面将如下所示：
- en: '![](img/876d3637-e3f8-468e-92e7-6f89cb85c636.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/876d3637-e3f8-468e-92e7-6f89cb85c636.png)'
- en: The page has a left navigation that lists all the exercises that can be added
    to the workout. Clicking on the arrow icon on the right adds the exercise to the
    end of the workout.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 页面左侧导航列出了可以添加到锻炼计划中的所有锻炼。点击右侧的箭头图标即可将锻炼添加到锻炃计划的末尾。
- en: The center area is designated for workout building. It consists of exercise
    tiles laid out in order from top to bottom and a form that allows the user to
    provide other details about the workout such as name, title, description, and
    rest duration.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 中间区域专门用于构建锻炼计划。它由按顺序排列的锻炼磁贴和一个表单组成，允许用户提供关于锻炼计划的其他详细信息，如名称、标题、描述和休息时间。
- en: 'This page operates in two modes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面操作有两种模式：
- en: 'Create/New: This mode is used for creating a new workout. The URL is `#/ builder/workout/new`.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建/新建：此模式用于创建新的锻炼计划。网址为`#/ builder/workout/new`。
- en: 'Edit: This mode is used for editing the existing workout. The URL is `#/ builder/workout/:id`,
    where `:id` maps to the name of the workout.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑：此模式用于编辑现有的锻炼计划。网址为`#/ builder/workout/:id`，其中的`:id`映射到锻炼计划的名称。
- en: With this understanding of the page elements and layout, it's time to build
    each of these elements. We will start with left nav (navigation).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了页面元素和布局的情况后，现在是时候构建每个元素了。我们将首先从左侧导航开始。
- en: Finishing left nav
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成左侧导航
- en: At the end of the previous section, we updated the left navigation view for
    the `Workout` component to show a list of exercises. Our intention was to let
    the user click on an arrow next to an exercise to add it to the workout. At the
    time, we deferred implementing the `addExercise` method in the `LeftNavExercisesComponent`
    that was bound to that click event. Now, we will go ahead and do that.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的最后，我们更新了`Workout`组件的左导航视图，以显示锻炼列表。我们的意图是让用户点击锻炼旁边的箭头将其添加到锻炼计划中。当时，我们推迟了对绑定到该点击事件的`LeftNavExercisesComponent`中的`addExercise`方法的实现。现在，我们将继续实现这一步。
- en: We have a couple of options here. The `LeftNavExercisesComponent` is a child
    component of the `WorkoutComponent`, so we can implement child/parent inter-component
    communication to accomplish that. We covered this technique in the previous chapter
    while working on *7 Minute Workout*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有一些选择。`LeftNavExercisesComponent`是`WorkoutComponent`的子组件，因此我们可以实现子/父组件间的通信来完成这一功能。我们在上一章中处理*7分钟锻炼*时已经涵盖了这种技术。
- en: However, adding an exercise to the workout is part of a larger process of building
    the workout and using child/parent inter-component communication would make the
    implementation of the `AddExercise` method differ from the other functionality
    that we will be adding going forward.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将锻炼添加到锻炼计划中是构建锻炼计划的更大过程的一部分，使用子/父级组件间通信会使`AddExercise`方法的实现与我们将要添加的其他功能有所不同。
- en: For this reason, it makes more sense to follow another approach for sharing
    data, one that we can use consistently throughout the process of building a workout.
    That approach involves using a service. As we get into adding the other functionality
    for creating an actual workout, such as save/update logic and implementing the
    other relevant components, the benefits of going down the service route will become
    increasingly clear.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，更合理的做法是采用另一种数据共享方法，这样我们可以在整个制定锻炼计划的过程中始终保持一致。这种方法涉及使用服务。当我们开始添加其他功能来创建实际的锻炼计划，比如保存/更新逻辑和实现其他相关组件时，选择使用服务的好处将变得越来越明显。
- en: So, we introduce a new service into the picture: `WorkoutBuilderService`. The
    ultimate aim of `WorkoutBuilderService` service is to coordinate between `WorkoutService`
    (which retrieves and persists the workout) and the components (such as `LeftNavExercisesComponent`
    and others we will add later), while the workout is being built, hence reducing
    the amount of code in `WorkoutComponent` to the bare minimum.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这种情况下引入了一个新的服务：`WorkoutBuilderService`。`WorkoutBuilderService`服务的最终目标是在构建锻炼计划时协调`WorkoutService`（用于检索和持久化锻炼计划）和组件（如`LeftNavExercisesComponent`和其他我们稍后将添加的组件）之间的关系，从而将`WorkoutComponent`中的代码量减少到最低程度。
- en: Adding WorkoutBuilderService
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加WorkoutBuilderService
- en: '`WorkoutBuilderService` monitors the state of the workout that a user of the
    application is building. It:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`监视应用程序用户正在构建的锻炼计划的状态。它：'
- en: Tracks the current workout
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪当前的锻炼计划
- en: Creates a new workout
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的锻炼计划
- en: Loads the existing workout
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载现有的锻炼计划
- en: Saves the workout
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存锻炼计划
- en: Copy `workout-builder-service.ts` from the `workout-builder/builder-services` folder
    under `trainer/src/app` in `checkpoint 4.5`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从`checkpoint 4.5`中的`trainer/src/app`的`workout-builder/builder-services`文件夹下复制`workout-builder-service.ts`文件。
- en: 'The code is also available for everyone to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.5` (folder—`trainer`). If you are not using
    Git, download the snapshot of `Checkpoint 4.5` (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure to update the `styles.css` file, which we are not discussing here.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码也可供所有人在GitHub上下载，网址为[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。在GitHub上，检查点作为分支进行了实现。要下载的分支如下：`GitHub分支：checkpoint4.5`（文件夹—`trainer`）。如果你不使用Git，可以从以下GitHub位置下载`Checkpoint
    4.5`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip)。在首次设置快照时，请参阅`trainer`文件夹中的`README.md`文件。再次强调，如果你跟着我们一起构建应用程序，请确保更新`styles.css`文件，这里我们不讨论。
- en: 'While we normally make services available application-wide,  `WorkoutBuilderService`
    will only be used in the *Workout Builder* feature. Therefore, instead of registering
    it with the providers in `AppModule`, we have registered it in the provider array
    of `WorkoutBuilderModule` as follows (after adding it as an import at the top
    of the file):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们通常会使服务在整个应用程序中可用，但`WorkoutBuilderService`只会在*Workout Builder*功能中使用。因此，我们并没有在`AppModule`中的提供者中注册它，而是在`WorkoutBuilderModule`的提供者数组中注册如下（在文件顶部添加了导入后）：
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Adding it as a provider here means that it will only be loaded when the *Workout
    Builder* feature is being accessed and it cannot be reached outside this module.
    This means that it can be evolved independently of other modules in the application
    and can be modified without affecting other parts of the application.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里将其作为提供者添加意味着只有在访问*Workout Builder*功能时才会加载它，外部无法访问。这意味着它可以独立于应用程序中的其他模块进行演化，并且可以在不影响应用程序其他部分的情况下进行修改。
- en: Let's look at some of the relevant parts of the service.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下服务的一些相关部分。
- en: '`WorkoutBuilderService` needs the type definitions for `WorkoutPlan`, `ExercisePlan`,
    and `WorkoutService`, so we import these into the component:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService` 需要 `WorkoutPlan`、`ExercisePlan` 和 `WorkoutService`
    的类型定义，因此我们将这些导入到组件中。'
- en: '[PRE27]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`WorkoutBuilderService` has a dependency on `WorkoutService` to provide persistence
    and querying capabilities. We resolve this dependency by injecting `WorkoutService`
    into the constructor for `WorkoutBuilderService`**:**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService` 依赖于 `WorkoutService` 来提供持久性和查询功能。我们通过将 `WorkoutService`
    注入到 `WorkoutBuilderService` 的构造函数中来解决这个依赖**：**'
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`WorkoutBuilderService` also needs to track the workout being built. We use
    the `buildingWorkout` property for this. The tracking starts when we call the
    `startBuilding` method on the service:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService` 还需要跟踪正在构建的训练。我们使用 `buildingWorkout` 属性来进行跟踪。当我们在服务上调用
    `startBuilding` 方法时，跟踪开始：'
- en: '[PRE29]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The basic idea behind this tracking function is to set up a `WorkoutPlan` object
    (`buildingWorkout`) that will be made available to components to manipulate the
    workout details. The `startBuilding` method takes the workout name as a parameter.
    If the name is not provided, it implies we are creating a new workout, and hence
    a new `WorkoutPlan` object is created and assigned; if not, we load the workout
    details by calling `WorkoutService.getWorkout(name)`. In any case, the `buildingWorkout`
    object has the workout being worked on.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个跟踪函数的基本思想是设置一个 `WorkoutPlan` 对象 (`buildingWorkout`)，以便让组件可以操作训练细节。`startBuilding`
    方法以训练名作为参数。如果没有提供名称，那么意味着我们正在创建一个新的训练，因此会创建并分配一个新的 `WorkoutPlan` 对象；如果有提供名称，则通过调用
    `WorkoutService.getWorkout(name)` 加载训练细节。无论如何，`buildingWorkout` 对象都有正在进行的训练。
- en: The `newWorkout` object signifies whether the workout is new or an existing
    one. It is used to differentiate between save and update situations when the `save`
    method on this service is called.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`newWorkout` 对象表示训练是新的还是已经存在。在调用该服务的 `save` 方法时，它用于区分保存和更新情况。'
- en: The rest of the methods, `removeExercise`, `addExercise`, and `moveExerciseTo`, are
    self-explanatory and affect the exercise list that is part of the workout (`buildingWorkout`).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的方法 `removeExercise`、`addExercise` 和 `moveExerciseTo` 是不言自明的，并影响训练的练习列表 (`buildingWorkout`)。
- en: '`WorkoutBuilderService` is calling a new method, `getWorkout`, on `WorkoutService`,
    which we have not added yet. Go ahead and copy the `getWorkout` implementation
    from the `workout-service.ts` file in the `services` folder under `trainer/src`
    in `checkpoint 4.5`. We will not dwell on the new service code as the implementation
    is quite simple.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService` 调用了 `WorkoutService` 上的一个新方法 `getWorkout`，我们还没有添加这个方法。继续复制`checkpooint
    4.5`下`trainer/src`文件夹中`services`文件夹中的`workout-service.ts`文件中的`getWorkout`实现。我们不会深究新的服务代码，因为实现相当简单。'
- en: Let's get back to left nav and implement the remaining functionality.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到左侧导航并实现剩余的功能。
- en: Adding exercises using ExerciseNav
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ExerciseNav 添加练习
- en: 'To add exercises to the workout we are building, we just need to import `WorkoutBuilderService`
    and `ExercisePlan`, inject `WorkoutBuilderService` into the `LeftNavExercisesComponent`,
    and call its `addExercise` method, passing the selected exercise as a parameter:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们正在构建的训练中添加练习，我们只需要导入 `WorkoutBuilderService` 和 `ExercisePlan`，将 `WorkoutBuilderService`
    注入 `LeftNavExercisesComponent` 中，并调用其 `addExercise` 方法，传递所选练习作为参数：
- en: '[PRE30]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Internally, `WorkoutBuilderService.addExercise` updates the `buildingWorkout`
    model data with the new exercise.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，`WorkoutBuilderService.addExercise` 使用新的练习更新 `buildingWorkout` 模型数据。
- en: The preceding implementation is a classic case of sharing data between independent
    components. The shared service exposes the data in a controlled manner to any
    component that requests it. While sharing data, it is always a good practice to
    expose the state/data using methods instead of directly exposing the data object.
    We can see that in our component and service implementations too. `LeftNavExercisesComponent`
    does not update the workout data directly; in fact, it does not have direct access
    to the workout being built. Instead, it relies upon the service method, `addExercise`,
    to change the current workout's exercise list.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现是共享数据在独立组件之间的经典案例。共享服务以受控的方式向任何请求数据的组件提供数据。在共享数据时，最好的做法始终是使用方法来暴露状态/数据，而不是直接暴露数据对象。我们也可以在组件和服务的实现中看到这一点。`LeftNavExercisesComponent`
    不直接更新训练数据；事实上，它没有直接访问正在构建的训练。相反，它依赖于服务方法 `addExercise` 来改变当前训练的练习列表。
- en: Since the service is shared, there are pitfalls to be aware of. As services
    are injectable through the system, we cannot stop any component from taking dependency
    on any service and calling its functions in an inconsistent manner, leading to
    undesired results or bugs. For example, `WorkoutBuilderService` needs to be initialized
    by calling `startBuilding` before `addExercise` is called. What happens if a component
    calls `addExercise` before the initialization takes place?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务是共享的，需要注意一些潜在的问题。由于服务可以通过系统进行注入，我们无法阻止任何组件依赖于任何服务并以不一致的方式调用其函数，从而导致不希望的结果或错误。例如，`WorkoutBuilderService`需要在调用`addExercise`之前通过调用`startBuilding`来初始化。如果组件在初始化之前调用`addExercise`会发生什么？
- en: Implementing the Workout component
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现锻炼组件
- en: The `WorkoutComponent` is responsible for managing a workout. This includes
    creating, editing, and viewing the workout. Due to the introduction of `WorkoutBuilderService`,
    the overall complexity of this component will be reduced. Other than the primary
    responsibility of integrating with, exposing, and interacting with its template
    view, we will delegate most of the other work to `WorkoutBuilderService`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutComponent`负责管理锻炼。这包括创建、编辑和查看锻炼。由于引入了`WorkoutBuilderService`，这个组件的整体复杂性将会减少。除了与其模板视图集成、公开和交互的主要责任外，我们将大部分其他工作委托给`WorkoutBuilderService`。'
- en: The `WorkoutComponent` is associated with two `routes/views`, namely `/builder/workout/new`
    and `/builder/workout/:id`. These routes handle both creating and editing workout
    scenarios. The first job of the component is to load or create the workout that
    it needs to manipulate.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutComponent`与两个`路线/视图`相关联，即`/builder/workout/new`和`/builder/workout/:id`。这些路线处理创建和编辑锻炼的情况。组件的第一个任务是加载或创建它需要操作的锻炼。'
- en: Route parameters
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路线参数
- en: But before we get to building out the `WorkoutComponent`and its associated view,
    we need to touch briefly on the navigation that brings a user to the screen for
    that component. This component handles both creating and editing workout scenarios.
    The first job of the component is to load or create the workout that it needs
    to manipulate. We plan to use Angular's routing framework to pass the necessary
    data to the component, so that it will know whether it is editing an existing
    workout or creating a new one, and in the case of an existing workout, which component
    it should be editing.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 但在开始构建`WorkoutComponent`及其关联视图之前，我们需要简要介绍将用户带到该组件的屏幕的导航。这个组件处理创建和编辑锻炼的情况。组件的第一个任务是加载或创建它需要操作的锻炼。我们计划使用Angular的路由框架向组件传递必要的数据，以便它知道是否正在编辑现有的锻炼还是创建新的锻炼，并在现有的锻炼的情况下，应该编辑哪个组件。
- en: How is this done? The `WorkoutComponent` is associated with two routes, namely
    `/builder/workout/new` and `/builder/workout/:id`. The difference in these two
    routes lies in what is at the end of these routes; in one case, it is `/new`,
    and in the other,` /:id`. These are called **route parameters.** The `:id` in
    the second route is a token for a route parameter. The router will convert the
    token to the ID for the workout component. As we saw earlier, this means that
    the URL that will be passed to the component in the case of *7 Minute Workout*
    will be `/builder/workout/7MinuteWorkout`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何实现的呢？`WorkoutComponent`与两个路线相关，即`/builder/workout/new`和`/builder/workout/:id`。这两个路线的不同之处在于这些路线的结尾;
    在一种情况下，它是`/new`，在另一种情况下，它是`/:id`。这些被称为**路线参数**。第二个路线中的`:id`是一个路线参数的令牌。路由器将令牌转换为锻炼组件的ID。正如我们之前看到的，这意味着在*7分钟锻炼*的情况下，将传递给组件的URL将是`/builder/workout/7MinuteWorkout`。
- en: 'How do we know that this workout name is the right parameter for the ID? As
    you recall, when we set up the event for handling a click on the Workout tiles
    on the Workouts screen that takes us to the Workout screen, we designated the
    workout name as the parameter for the ID, like so:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么知道这个锻炼名称是ID的正确参数呢？当你回忆起我们设置了处理在锻炼屏幕上的锻炼图块点击事件的事件时，那会带我们到锻炼屏幕上，我们将锻炼名称指定为ID的参数，就像这样：
- en: '[PRE31]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we are constructing the route using the programmatic interface for the
    router. The `router.navigate` method accepts an array. This is called the **link
    parameters array**. The first item in the array is the path of the route, and
    the second is a route parameter that specifies the ID of the workout. In this
    case, we set the `id` parameter to the workout name. We can also construct the
    same type of URL as part of a router link or simply enter it in the browser to
    get to the Workouts screen and edit a particular workout.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用路由器的程序化接口来构建路由。`router.navigate`方法接受一个数组。这被称为**链接参数数组**。数组中的第一项是路由的路径，第二项是一个路由参数，指定workout的ID。在这种情况下，我们将`id`参数设置为workout名称。我们还可以通过路由链接构建相同类型的URL，或者直接在浏览器中输入它，以便转到Workouts屏幕并编辑特定的workout。
- en: The other of the two routes ends with `/new`. Since this route does not have
    a `token` parameter, the router will simply pass the URL unmodified to the `WorkoutComponent`.
    The `WorkoutComponent` will then need to parse the incoming URL to identify that
    it should be creating a new component.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 两条路由中的另一条以`/new`结尾。由于这条路由没有`token`参数，路由器将简单地将URL无修改地传递给`WorkoutComponent`。然后，`WorkoutComponent`需要解析传入的URL，以确定它应该创建一个新组件。
- en: Route guards
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由守卫
- en: But before the link takes the user to the `WorkoutComponent`, there is another
    step along the way that we need to consider. The possibility always exists that
    the ID that is passed in the URL for editing a workout could be incorrect or missing.
    In those cases, we do not want the component to load, but instead, we want to
    have the user redirected to another page or back to where they came from.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在链接将用户带到`WorkoutComponent`之前，我们还需要考虑另一个步骤。始终存在ID在URL中传递用于编辑workout可能是不正确或丢失的情况。在这种情况下，我们不希望加载组件，而是希望将用户重定向到另一个页面或返回到他们来自的页面。
- en: Angular offers a way to accomplish this result with **route guards**. As the
    name implies, route guards **provide a way to prevent navigation to a route**.
    A route guard can be used to inject custom logic that can do things such as check
    authorization, load data, and make other verifications to determine whether the
    navigation to the component needs to be canceled or not. And all of this is done
    before the component loads so it is never seen if the routing is canceled.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一种使用**路由守卫**来实现这一结果的方法。顾名思义，路由守卫**提供了一种阻止导航到路由的方法**。路由守卫可以用于注入自定义逻辑，可以执行诸如检查授权、加载数据和进行其他验证以确定是否需要取消对组件的导航等操作。所有这些都是在组件加载之前完成的，因此如果取消了路由，则永远不会看到组件。
- en: Angular offers several route guards, including `CanActivate`, `CanActivateChild`,
    `CanDeActivate`, `Resolve`, and `CanLoad`**.** At this point, we are interested
    in the `Resolve` route guard**. **The `Resolve` guard will allow us not only to
    check for the existence of a workout, but also to load the data associated with
    a workout before loading the `WorkoutComponent`. The advantage of doing the latter
    is that we avoid the necessity of checking to make sure the data is loaded in
    the `WorkoutComponent` and it eliminates adding conditional logic throughout its
    component template to make sure that the data is there when it is rendered.  This
    will be especially useful when in the next chapter when we start using `observables`
    where we must wait for the observable to complete before we are guaranteed of
    having the data that it will provide. The `Resolve` guard will handle waiting
    for the observable to complete, which means that the `WorkoutComponent` will be
    guaranteed to have the data that it needs before it loads.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了几种路由守卫，包括`CanActivate`、`CanActivateChild`、`CanDeActivate`、`Resolve`和`CanLoad`**。**目前，我们对`Resolve`路由守卫感兴趣**。**`Resolve`守卫不仅允许我们检查workout的存在，还允许在加载`WorkoutComponent`之前加载与workout相关的数据。这样做的优势是我们避免了在`WorkoutComponent`中检查数据是否加载的必要性，并且在其组件模板中去添加条件逻辑以确保在渲染时数据已经存在。
    这在下一章中使用`observables`时将会特别有用，因为我们必须等待observable完成，然后才能保证它提供的数据已经存在。 `Resolve`守卫将处理等待observable完成的问题，这意味着`WorkoutComponent`在加载之前将保证拥有它所需的数据。
- en: Implementing the resolve route guard
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现resolve路由守卫
- en: The `Resolve` guard allows us to prefetch the data for a workout. In our case,
    what we want to do is use `Resolve` to check the validity of any ID that is passed
    for an existing workout. Specifically, we will run a check on that ID by making
    a call to the `WorkoutBuilderService` to retrieve the Workout Plan and see if
    it exists. If it exists, we will load the data associated with the Workout Plan
    so that it is available to the `WorkoutComponent`; if not we will redirect back
    to the Workouts screen.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resolve` 保护允许我们预取训练的数据。在我们的情况下，我们想使用 `Resolve` 来检查已有训练的任何ID的有效性。具体来说，我们将通过调用
    `WorkoutBuilderService` 来检查该 ID，以检索训练计划并查看是否存在。如果存在，我们将加载与训练计划相关的数据，以便它可用于 `WorkoutComponent`；如果不存在，我们将重定向回训练页面。'
- en: 'Copy `workout.resolver.ts` from the `workout-builder/workout` folder under
    `trainer/src/app/workout` in `checkpoint 4.5` and you will see the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `trainer/src/app/workout` 下 `workout-builder/workout` 文件夹中的 `checkpoint 4.5`
    复制 `workout.resolver.ts`，你会看到以下代码：
- en: '[PRE32]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the `WorkoutResolver` is an injectable class that implements
    the `Resolve` interface.  The code injects the `WorkoutBuilderService` and `Router`
    into the class and implements the interface with the `resolve` method. The `resolve`
    method accepts two parameters; `ActivatedRouteSnapshot` and `RouterStateSnapshot`.
    In this case, we are only interested in the first of these two parameters, `ActivatedRouteSnapshot`. 
    It contains a `paramMap` from which we extract the ID parameter for the route.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`WorkoutResolver` 是一个可注入的类，实现了 `Resolve` 接口。 代码将 `WorkoutBuilderService`
    和 `Router` 注入到类中，并使用 `resolve` 方法实现了接口。`resolve` 方法接受两个参数；`ActivatedRouteSnapshot`
    和 `RouterStateSnapshot`。在这种情况下，我们只对这两个参数中的第一个感兴趣，即 `ActivatedRouteSnapshot`。它包含一个
    `paramMap`，我们从中提取路由的 ID 参数。
- en: The `resolve` method then calls the `startBuilding` method of `WorkoutBuildingService` using
    the parameter supplied in the route. If the workout exists, then `resolve` returns
    the data and the navigation proceeds; if not, it re-routes the user to the workouts
    page and returns false. If `new` is passed as an ID, `WorkoutBuilderService` will
    load a new workout and the `Resolve` guard will allow navigation to proceed to
    the `WorkoutComponent`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve` 方法然后使用路由中提供的参数调用 `WorkoutBuildingService` 的 `startBuilding` 方法。如果训练存在，`resolve`
    就会返回数据并继续导航；如果不存在，它会重新定向用户到训练页面并返回 false。如果将 `new` 作为一个ID传递，`WorkoutBuilderService`
    将加载一个新的训练计划，`Resolve` 保护将允许导航到 `WorkoutComponent`。'
- en: The `resolve` method can return a `Promise` , an `Observable,` or a synchronous
    value. If we return an `Observable`,  we will need to make sure that the `Observable`
    completes before proceeding with navigation. In this case, however, we are making
    a synchronous call to a local in-memory data store, so we are just returning a
    value.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve` 方法可以返回一个 `Promise`、一个 `Observable` 或一个同步值。如果我们返回一个 `Observable`，我们需要确保在继续导航之前
    `Observable` 完成。然而，在这种情况下，我们只是对本地内存数据存储进行同步调用，所以我们只返回一个值。'
- en: 'To complete the implementation of the `WorkoutResolver`, first make sure to
    import and add it to `WorkoutBuilderModule` as a provider:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成 `WorkoutResolver` 的实现，首先确保导入并将其添加到 `WorkoutBuilderModule` 中作为提供者：
- en: '[PRE33]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, add it to the route configuration for `WorkoutComponent` by updating `workout-builder-routing.module.ts`
    as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过更新 `workout-builder-routing.module.ts`，将其添加到 `WorkoutComponent` 的路由配置中：
- en: '[PRE34]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, we add `WorkoutResolver` to the routing module''s imports.
    Then, we add `resolve { workout: WorkoutResolver }` to the end of the route configuration
    for `workout/new` and `workout/:id` . This instructs the router to use the `WorkoutResolver` resolve
    method and assign its return value to `workout` in the route''s data. This configuration
    means that `WorkoutResolver` will be called prior to the router navigating to `WorkoutComponent`
    and that the workout data will be available to the `WorkoutComponent` when it
    loads. We''ll see how to extract this data in the `WorkoutComponent` in the next
    section.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你所见，我们将 `WorkoutResolver` 添加到路由模块的导入中。然后，我们将 `resolve { workout: WorkoutResolver
    }` 添加到 `workout/new` 和 `workout/:id` 路由配置的末尾。这指示路由器使用 `WorkoutResolver` 的解析方法，并将其返回值分配给路由数据中的
    `workout`。这个配置意味着 `WorkoutResolver` 将在路由器导航到 `WorkoutComponent` 之前被调用，并且在加载时将可用于
    `WorkoutComponent`。接下来我们将看到如何在 `WorkoutComponent` 中提取这些数据。'
- en: Implementing the Workout component continued...
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现训练组件继续...
- en: Now that we have established the routing that takes us to the `Workout` component,
    let's turn to completing its implementation. So, copy the `workout.component.ts`
    file from the `workout-builder/workout` folder under `trainer/src/app` in `checkpoint
    4.5`. (Also, copy `workout-builder.module.ts` from the `workout-builder` folder.
    We'll discuss the changes in this file a little later when we get to Angular forms.)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了将我们带到“训练”组件的路由，让我们转向完成它的实现。因此，从“checkpoint 4.5”下的“trainer/src/app/workout-builder/workout”文件夹中复制`workout.component.ts`文件。（同时，从“workout-builder”文件夹中复制`workout-builder.module.ts`文件。当我们到达Angular表单时，我们将稍后讨论对该文件的更改。）
- en: 'Open `workout.component.ts` and you''ll see that we have added a constructor
    that injects `ActivatedRoute` and `WorkoutBuilderService`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout.component.ts`，你会看到我们已经添加了一个注入`ActivatedRoute`和`WorkoutBuilderService`的构造函数：
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In addition, we have added the following `ngOnInit` method:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们添加了以下`ngOnInit`方法：
- en: '[PRE36]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The method subscribes to the `route` and extracts the `workout` from the `route.data`.
    There is no need to check the workout exists because we have already done that
    in the `WorkoutResolver`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法订阅了`route`并从`route.data`中提取了`workout`。没有必要检查训练是否存在，因为我们在“训练解析器”中已经做过了。
- en: We are subscribing to the `route.data` because as an `ActivatedRoute`, the `route`
    exposes its `data` as an  `Observable`, which can change during the lifetime of
    the component. This gives us the ability to reuse the same component instance
    with different parameters, even though the `OnInit` life cycle event for that
    component is called only once. We'll cover `Observables` in detail in the next
    chapter.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们订阅`route.data`，因为作为“ActivatedRoute”，`route`将其`data`公开为一个`Observable`，在组件的生命周期内可以随时改变。这给了我们能力在同一组件实例中使用不同的参数，即使该组件的`OnInit`生命周期事件只被调用一次。我们将在下一章节详细介绍`Observables`。
- en: In addition to this code, we have also added a series of methods to the `Workout
    Component` for adding, removing,  and moving a workout. These methods all call
    corresponding methods on the `WorkoutBuilderService` and we will not review them
    in detail here. We've also added an array of `durations` for populating the duration
    drop-down list.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这段代码外，我们还为“训练组件”添加了一系列方法，用于添加、删除和移动训练。这些方法都调用了“训练生成器服务”上的相应方法，我们将不在这里详细审查它们。我们还添加了一个“持续时间”数组用于填充持续时间下拉列表。
- en: For now, this is enough for the **component** class implementation. Let's update
    the associated `Workout` template.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这就足够了**组件**类的实现。让我们更新相关的“训练”模板。
- en: Implementing the Workout template
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现训练模板
- en: Now, copy the `workout.component.html` files from the `workout-builder/workout`
    folder under `trainer/src/app` in `checkpoint 4.5`. Run the app, navigate to `/builder/workouts`,
    and double-click on the *7 Minute Workout* tile. This should load the *7 Minute
    Workout* details with a view similar to the one shown at the start of the *Building
    a workout* section.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从“checkpoint 4.5”下的“trainer/src/app/workout-builder/workout”文件夹中复制`workout.component.html`文件。运行应用程序，导航至“/builder/workouts”，双击“7分钟训练”磁贴。这应该会加载类似于“构建训练”章节开头所示的视图的“7分钟训练”细节。
- en: 'In the event of any problem, you can refer to the `checkpoint4.5` code in the
    `GitHub repository: Branch: checkpoint4.5` (folder - `trainer`).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现任何问题的情况下，您可以参考“GitHub仓库：分支：checkpoint4.5”中的“checkpoint4.5”代码（文件夹-`trainer`）。
- en: We will be dedicating a lot of time to this view, so let's understand some specifics
    here.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会在这个视图上花费很多时间，所以让我们在这里了解一些具体内容。
- en: 'The exercise list div (`id="exercise-list"`) lists the exercises that are part
    of the workout in order. We display them as top-to-bottom tiles in the left part
    of the content area. Functionally, this template has:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 练习列表div（`id="exercise-list"`）按顺序列出组成训练的练习。我们在内容区域的左边以从上到下的形式显示它们。在功能上，这个模板有：
- en: The Delete button to delete the exercise
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除按钮用于删除练习
- en: Reorder buttons to move the exercise up and down the list, as well as to the
    top and bottom
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新排列按钮可以将练习移到列表中的上下位置，以及移到顶部和底部。
- en: 'We use `ngFor` to iterate over the list of exercises and display them:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ngFor`来遍历练习列表并显示它们：
- en: '[PRE37]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will notice that we are using the `*` asterisk in front of `ngFor`,  which
    is shorthand for the `<template>` tag. We are also using `let` to set two local
    variables: `exerisePlan` to identify an item in the list of exercises and `i`
    to set up an index value that we will use to show a number for the exercises as
    they are displayed on the screen. We will also use the index value to manage reordering
    and deleting exercises from the list.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在`ngFor`前面使用了 `*` 星号，这是`<template>`标签的简写。我们还使用`let`来设置两个局部变量：`exerisePlan`用于标识练习列表中的项目，`i`用于设置一个索引值，我们将用它来在屏幕上显示练习的编号。我们还将使用索引值来管理重新排序和从列表中删除练习。
- en: The second div element for workout data (`id="workout-data"`) contains the HTML
    input element for details such as name, title, and rest duration, and a button
    to save workout changes.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 用于训练数据的第二个div元素（`id="workout-data"`）包含了HTML输入元素，用于输入名称、标题和休息时长，并有一个保存训练变动的按钮。
- en: The complete list has been wrapped inside the HTML form element so that we can
    make use of the form-related capabilities that Angular provides. So, what are
    these capabilities?
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 完整列表被包裹在HTML表单元素内，以便我们可以利用Angular提供的与表单相关的功能。那么这些功能是什么呢？
- en: Angular forms
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular表单
- en: Forms are such an integral part of HTML development that any framework that
    targets client-side development just cannot ignore them. Angular provides a small
    but well-defined set of constructs that make standard form-based operations easier.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是HTML开发的一个不可或缺的部分，任何旨在客户端开发的框架都不能忽视它们。Angular提供了一组小而明确定义的构造，使标准的基于表单的操作更加容易。
- en: 'If we think carefully, any form of interaction boils down to:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细考虑的话，任何形式的交互都可以归结为：
- en: Allowing user inputs
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户输入
- en: Validating those inputs against business rules
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据业务规则对输入进行验证
- en: Submitting the data to the backend server
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据提交到后端服务器
- en: Angular has something to offer for all the preceding use cases.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Angular对所有以上用例都有所提供。
- en: For user input, it allows us to create two-way bindings between the form input
    elements and the underlying model, hence avoiding any boilerplate code that we
    may have to write for model input synchronization.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户输入，它允许我们在表单输入元素和底层模型之间创建双向绑定，从而避免我们为模型输入同步而必须编写的样板代码。
- en: It also provides constructs to validate the input before it can be submitted.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了构造来在提交之前验证输入。
- en: Lastly, Angular provides HTTP services for client-server interaction and persisting
    data to the server. We'll cover those services in [Chapter 3](cba52e86-29c5-4c51-a34f-5db71de16503.xhtml),
    *Supporting Server Data Persistence*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Angular提供了用于客户端服务器交互和将数据持久化到服务器的HTTP服务。我们将在[第3章](cba52e86-29c5-4c51-a34f-5db71de16503.xhtml)中涵盖这些服务，*支持服务器数据持久化*。
- en: Since the first two use cases are our main focus in this chapter, let's learn
    more about Angular user input and data validation support.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前两个用例是本章的主要关注点，让我们更多地了解一下Angular用户输入和数据验证支持。
- en: Template-driven and reactive forms
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板驱动和响应式表单
- en: 'Angular offers two types of forms: **template-driven** and **reactive**. We''ll
    be discussing both types of form in this chapter. Because the Angular team indicates
    that many of us will primarily use **template-driven forms**, that is what we
    will start in this chapter.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供两种类型的表单：**模板驱动**和**响应式**。在本章中我们将讨论这两种类型的表单。因为Angular团队表示我们中的许多人主要将使用**模板驱动表单**，这就是我们将在本章开始使用的内容。
- en: Template-driven forms
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板驱动表单
- en: As the name suggests, **template-driven forms** place the emphasis on developing
    a form within an HTML template and handling most of the logic for the form inputs,
    data validation, saving, and updating in-form directives placed within that template.
    The result is that very little form-related code is required in the component
    class that is associated with the form's template.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名，**模板驱动表单**侧重于在HTML模板内开发表单，并处理大部分表单输入、数据验证、保存和更新逻辑的工作。结果就是，在与表单模板关联的组件类中几乎不需要写太多与表单相关的代码。
- en: '**Template-driven forms** make heavy use of the `ngModel` form directive. We
    will be discussing it in the next sections. It provides two-way data binding for
    form controls, which is a nice feature indeed. It allows us to write much less
    boilerplate code to implement a form. It also helps us to manage the state of
    the form (such as whether the form controls have changed and whether these changes
    have been saved). And, it also gives us the ability to easily construct messages
    that display if the validation requirements for a form control have not been met
    (for example, a required field not provided, email not in the right format, and
    so on).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板驱动表单**大量使用`ngModel`表单指令。我们将在接下来的章节中讨论它。它为表单控件提供双向数据绑定，这确实是一个很好的特性。它让我们编写更少的样板代码来实现一个表单。它还帮助我们管理表单的状态（例如，表单控件是否已更改，这些更改是否已保存）。而且，它还能轻松构造消息，显示出表单控件的验证要求未满足的情况（例如，未提供必填字段，电子邮件格式不正确等）。'
- en: Getting started
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'In order to use Angular forms in our `Workout` component, we must first add
    some additional configuration. Open  `workout-buider.module.ts` from the `workout-builder`
    folder under `trainer/src/app` in `checkpoint 4.5`. You will see that it imports
    `FormsModule`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`Workout`组件中使用Angular表单，我们必须首先添加一些额外的配置。在`checkpoint 4.5`的`trainer/src/app`文件夹下的`workout-builder`文件夹中打开`workout-buider.module.ts`。您将看到它导入了`FormsModule`：
- en: '[PRE38]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This brings in all that we will need to implement our form, including:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了我们实现表单所需的一切，包括：
- en: '`NgForm`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgForm`'
- en: '`ngModel`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngModel`'
- en: Let's start using these to build our form.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用这些来构建我们的表单。
- en: Using NgForm
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NgForm
- en: 'In our template (`workout.component.html`), we have added the following `form`
    tag:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模板（`workout.component.html`）中，我们添加了以下`form`标签：
- en: '[PRE39]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's take a look at what we have here. One interesting thing is that we are
    still using a standard `<form>` tag and not a special Angular tag. We've also
    used `#` to define a local variable `f` to which we have assigned `ngForm`. Creating
    this local variable provides us with the convenience of being able to use it for
    form-related activity in other places within the form. For example, you can see
    that we are using it at the end of the opening `form` tag in a parameter, `f.form`,
    which is being passed to the `onSubmit` event bound to `(ngSubmit)`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在这里有什么。一个有趣的是，我们仍然使用标准的`<form>`标签，而不是特殊的Angular标签。我们还使用`#`来定义一个本地变量`f`，并将`ngForm`分配给它。创建这个本地变量使我们能够方便地在表单中的其他地方使用它进行与表单相关的活动。例如，您可以看到我们在将`f.form`传递给绑定到`(ngSubmit)`的`onSubmit`事件的打开`form`标签的结束处使用它作为参数。
- en: That last binding to `(ngSubmit)` should tell us that something different is
    going on here. Even though we did not explicitly add the `NgForm` directive, our
    `<form>` now has additional events such as `ngSubmit` to which we can bind actions.
    How did this happen? Well, this was not triggered by our assigning `ngForm` to
    a local variable. Instead, it happened *automagically* because we imported the
    forms module into `workout-builder.module.ts`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后那个绑定到`(ngSubmit)`的内容告诉我们这里有些不同。尽管我们没有明确添加`NgForm`指令，但我们的`<form>`现在具有额外的事件，如`ngSubmit`，我们可以对其绑定操作。这是怎么发生的？嗯，这不是因为我们为本地变量分配了`ngForm`而触发的。相反，这是*自动*发生的，因为我们将表单模块导入了`workout-builder.module.ts`。
- en: With that import in place, Angular scanned our template for a `<form>` tag and
    wrapped that `<form>` tag within an `NgForm` directive. The Angular documentation
    indicates that `<form>` elements in the component will be upgraded to use the
    Angular form system. This is important because it means that various capabilities
    of  `NgForm` are now available to use with the form. These include the `ngSubmit`
    event, which signals when a user has triggered a form submission and provides
    the ability to validate the entire form before submitting it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个导入，Angular扫描我们的模板以查找`<form>`标签，并将该`<form>`标签包装在`NgForm`指令内。Angular文档指出，组件中的`<form>`元素将升级为使用Angular表单系统。这很重要，因为这意味着`NgForm`的各种功能现在可以与表单一起使用。这包括`ngSubmit`事件，它在用户触发表单提交时发出信号，并提供在提交表单之前验证整个表单的能力。
- en: ngModel
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngModel
- en: One of the fundamental building blocks for template-driven forms is `ngModel`,
    and you will find it being used throughout our form. One of the primary roles
    of `ngModel` is to support two-way binding between user input and an underlying
    model. With such a setup, changes in the model are reflected in the view, and
    updates to the view too are reflected back on the model. Most of the other directives
    that we have covered so far only support one-way binding from models to views.
    `ngModel` goes both ways. But, be aware that it is only available within `NgForm`
    for use with elements that allow user input.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`是模板驱动表单的基本构建块之一，并且你会发现它在整个表单中都被使用。`ngModel`的主要作用之一是支持用户输入和底层模型之间的双向绑定。有了这样的设置，模型中的更改会反映在视图中，视图的更新也会反映回模型中。到目前为止，我们讨论过的大多数其他指令都只支持从模型到视图的单向绑定。`ngModel`是双向的。但是，请注意，它仅在`NgForm`中可用，用于允许用户输入的元素。'
- en: 'As you know, we already have a model that we are using for the Workout page,
    `WorkoutPlan`. Here is the `WorkoutPlan` model from `model.ts`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，我们已经有一个用于锻炼页面的模型，`WorkoutPlan`。下面是来自`model.ts`的`WorkoutPlan`模型：
- en: '[PRE40]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note the use of the `?` after `description`. This means that it is an optional
    property in our model and is not required to create a `WorkoutPlan`. In our form,
    this will mean that we will not require that a description be entered and everything
    will work fine without it.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`description`后面使用`?`。这意味着它是我们模型中的一个可选属性，不需要创建`WorkoutPlan`。在我们的表单中，这意味着我们不需要输入描述，一切都可以正常运行。
- en: 'Within the `WorkoutPlan` model, we also have a reference to an array made up
    of instances of another type of model: `ExercisePlan`. `ExercisePlan` in turn
    is made up of a number (`duration`) and another model (`Exercise`), which looks
    like this:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WorkoutPlan`模型中，我们还引用了由另一种类型的模型实例组成的数组：`ExercisePlan`。`ExercisePlan`又由一个数字（`duration`）和另一个模型（`Exercise`）组成，看起来像这样：
- en: '[PRE41]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The use of these nested classes shows that we can create complex hierarchies
    of models that can all be data-bound within our form using `NgModel`. So throughout
    the form, whenever we need to update one of the values in a `WorkoutPlan` or an
    `ExercisePlan`, we can use `NgModel` to do that (the `WorkoutPlan` model will
    be represented by a local variable named `workout` in the following examples).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些嵌套类显示了我们可以创建复杂的模型层次结构，这些模型都可以在我们的表单中使用`NgModel`进行数据绑定。因此，在整个表单中，每当我们需要更新`WorkoutPlan`或`ExercisePlan`中的一个值时，我们都可以使用`NgModel`来做到这一点（在以下示例中，`WorkoutPlan`模型将由名为`workout`的本地变量表示）。
- en: Using ngModel with input and textarea
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ngModel`处理input和textarea
- en: 'Open `workout-component.html` and look for `ngModel.` It has been applied to
    form elements that allow user data input. These include input, textarea, and select.
    The workout name input setup looks like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout-component.html`，查找`ngModel`。它已被应用于允许用户输入数据的表单元素，包括input、textarea和select。选练名输入设置如下所示：
- en: '[PRE42]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding `[(ngModel)]` directive sets up a two-way binding between the
    input control and the `workout.name` model property. The brackets and parentheses
    should each look familiar. Previously, we used them separately from each other:
    the `[]` brackets for property binding and the `()` parentheses for event binding.
    In the latter case, we usually bound the event to a call to a method in the component
    associated with the template. You can see an example of this in the form with
    the button that a user clicks on to remove an exercise:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`[(ngModel)]`指令在输入控件和`workout.name`模型属性之间建立了双向绑定。方括号和括号应该各自很熟悉。以前，我们将它们分开使用：`[]`方括号用于属性绑定，`()`括号用于事件绑定。在后一种情况下，我们通常将事件绑定到与模板相关联的组件中的方法的调用。你可以在用户点击以删除练习的按钮的表单中看到这样的例子：
- en: '[PRE43]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the click event is explicitly bound to a method called `removeExercise`
    in our `Workout` component class. But for the `workout.name` input, we do not
    have an explicit binding to a method on the component. So what's going on here
    and how does the update happen without us calling a method on the component? The
    answer to that question is that the combination `[( )]` is shorthand for both
    binding a model property to the input element and wiring up an event that updates
    the model.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，点击事件明确绑定到我们`Workout`组件类中名为`removeExercise`的方法。但对于`workout.name`输入，我们没有将方法显式绑定到组件上。那么这里发生了什么，更新如何进行而我们没有在组件上调用方法？对这个问题的答案是，组合`[(
    )]`是绑定模型属性到输入元素和连接更新模型的事件的速记方式。
- en: Put differently, if we reference a model element in our form, `ngModel` is smart
    enough to know that what we want to do is update that element (`workout.name`
    here) when a user enters or changes the data in the input field to which it is
    bound. Under the hood, Angular creates an update method similar to what we would
    otherwise have to write ourselves. Nice! This approach keeps us from having to
    write repetitive code to update our model.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们在表单中引用一个模型元素，`ngModel`足够聪明以知道我们要做的是更新该元素（这里是`workout.name`）当用户输入或更改与其绑定的输入字段中的数据时。在幕后，Angular创建了一个类似于我们否则必须自己编写的更新方法。太棒了！这种方法让我们不必编写重复的代码来更新我们的模型。
- en: Angular supports most of the HTML5 input types, including text, number, select,
    radio, and checkbox. This means binding between a model and any of these input
    types just works out of the box.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持大多数HTML5输入类型，包括文本、数字、选择、单选和复选框。这意味着模型和任何这些输入类型之间的绑定都可以直接使用。
- en: 'The `textarea` element works the same as the input:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`textarea`元素与输入框的用法相同：'
- en: '[PRE44]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we bind `textarea` to `workout.description`. Under the hood, `ngModel`
    updates the workout description in our model with every change we type into the
    text area.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`textarea`绑定到`workout.description`。在幕后，`ngModel`会根据我们在文本区域中键入的内容每次改变都更新我们模型中的workout描述。
- en: 'To test out how this works, why don''t we verify this binding? Add a model
    interpolation expression at the end of any of the linked inputs, such as this
    one:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这是如何工作的，为什么不验证一下这个绑定？在任何一个链接的输入框的末尾添加一个模型插值表达式，比如这样一个：
- en: '[PRE45]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Open the Workout page, type something in the input, and see how the interpolation
    is updated instantaneously. The magic of two-way binding!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Workout页面，在输入框中输入一些内容，看看插值是如何立即更新的。双向绑定的神奇！
- en: '![](img/f8286d8e-bfb3-44e6-a448-771693aa1e64.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8286d8e-bfb3-44e6-a448-771693aa1e64.png)'
- en: Using ngModel with select
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ngModel与select
- en: 'Let''s look at how `select` has been set up:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`select`是如何设置的：
- en: '[PRE46]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We are using `ngFor` here to bind to an array, `durations`, which is in the
    `Workout` component class. The array looks like this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`ngFor`绑定到一个数组，`durations`，它在`Workout`组件类中。数组的结构如下：
- en: '[PRE47]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `ngFor` component will loop over the array and populate the drop-down values
    with the corresponding values in the array with the title for each item being
    displayed using interpolation, `{{duration.title}}`. And `[(ngModel)]` then binds
    the drop-down selection to the `exercisePlan.duration` in the model.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`组件将循环数组，并使用插值将下拉框的值与数组中相应的值填充，每个项目的标题使用插值显示，`{{duration.title}}`。 然后`[(ngModel)]`将下拉选择绑定到模型中的`exercisePlan.duration`。'
- en: Notice here that we are binding to the nested model: `ExercisePlan`. And, we
    may have multiple exercises to which we will be applying this binding. With that
    being the case, we have to make use of another Angular form directive—`ngModelGroup`—to
    handle these bindings. `ngModelGroup` will allow us to create a nested group within
    our model that will contain the list of exercises included in the workout and
    then in turn loop over each exercise to bind its duration to the model.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，我们将绑定到嵌套模型：`ExercisePlan`。 可能会有多个练习要应用这个绑定。在这种情况下，我们必须使用另一个Angular表单指令—
    `ngModelGroup`—来处理这些绑定。`ngModelGroup`将允许我们在我们的模型中创建一个包含在训练中包含的练习列表的嵌套组，并然后循环每个练习来将其持续时间绑定到模型。
- en: 'To start with, we will add `ngModelGroup` to the div tag that we have created
    within the form to hold our list of exercises:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在表单中创建的div标签上添加`ngModelGroup`，以保存我们的练习列表：
- en: '[PRE48]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'That takes care of creating the nested list of exercises. Now, we have to handle
    the individual exercises within that list, and we can do that by adding another
    `ngModelGroup` to the individual divs that contain each exercise:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就创建了嵌套的练习列表。现在，我们必须处理列表中的单个练习，我们可以在包含每个练习的单独div中添加另一个`ngModelGroup`来做到这一点：
- en: '[PRE49]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, we are using the index in our for loop to dynamically create an individual
    model group for each of our exercises. These model groups will be nested inside
    the first model group that we created. Temporarily, add the tag `<pre>{{ f.value
    | json }}</pre>` to the bottom of the form and you will be able to see the structure
    of this nested model:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用循环的索引动态创建每个练习的单独模型组。这些模型组将嵌套在我们创建的第一个模型组中。临时地，在表单的底部添加标签`<pre>{{ f.value
    | json }}</pre>`，就可以看到这个嵌套模型的结构：
- en: '[PRE50]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is powerful stuff that enables us to create complicated forms with nested
    models, all of which can use `ngModel` for databinding**.**
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强大的功能，让我们能够创建带有嵌套模型的复杂表单，所有这些都可以使用`ngModel`进行数据绑定**。**
- en: You may have noticed a subtle difference in the two `ngModelGroup` directive
    tags we just introduced. The second of the two is wrapped in angle brackets, `[]`,
    while the first is not. This is because with the first tag we are just naming
    our model group, whereas with the second we are binding it dynamically to each
    exercise's div tag using the index of our for loop.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们刚刚介绍的两个`ngModelGroup`指令标记之间微妙的区别。其中第二个标记被包裹在尖括号`[]`中，而第一个没有。这是因为在第一个标记中，我们只是为我们的模型组命名，而在第二个标记中，我们是动态地将其绑定到每个练习的div标记，使用我们的for循环的索引。
- en: Like input, select too supports two-way binding. We saw how changing select
    updates a model, but the model-to-template binding may not be apparent. To verify
    that a model to a template binding works, open the *7 Minute Workout* app and
    verify the duration dropdowns. Each one has a value that is consistent with the
    model value (30 seconds).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 和输入一样，选择也支持双向绑定。我们已经看到了改变选择项会更新模型，但是模型到模板的绑定可能不太明显。要验证模型到模板的绑定是否有效，打开 *7分钟锻炼*
    应用程序并验证持续时间下拉菜单。每个下拉菜单的值都与模型值（30秒）一致。
- en: Angular does an awesome job of keeping the model and view in sync using `ngModel`.
    Change the model and see the view updated; change the view and watch as the model
    is updated instantaneously.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Angular通过使用`ngModel`很好地保持了模型和视图的同步。更改模型并查看视图更新；更改视图并观察模型立即更新。
- en: Now, let's add validation to our form.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给表单添加验证。
- en: 'The code for the next section is also available for everyone to download on
    GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.6` (folder—`trainer`). Or if you are not
    using Git, download the snapshot of Checkpoint 4.6 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure and update the `styles.css` file, which we are not discussing here.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节的代码也可以在GitHub上下载：[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。检查点在GitHub里作为分支实现。要下载的分支如下：`GitHub分支：checkpoint4.6`（文件夹—`trainer`）。或者如果没有使用Git，可以从以下GitHub位置下载Checkpoint
    4.6的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip)。第一次设置完快照，参考`trainer`文件夹里的`README.md`文件。同样，如果和我们一起构建应用程序，请务必更新`styles.css`文件，在这里我们不会讨论。
- en: Angular validation
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular验证
- en: As the saying goes, *never trust user input*. Angular has support for validation,
    including the standard required, min, max, and pattern, as well as custom validators.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 俗话说，“不要相信用户输入”。Angular支持验证，包括标准的required、min、max和pattern，以及自定义验证器。
- en: ngModel
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngModel
- en: '`ngModel` is the building block that we will use to implement validation. It
    does two things for us: it maintains the model state and provides a mechanism
    for identifying validation errors and displaying validation messages.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`是我们用来实现验证的基本模块。它为我们做了两件事情：维护模型状态并提供一种机制来识别验证错误并显示验证消息。'
- en: 'To get started, we need to assign `ngModel` to a local variable in all of our
    form controls that we will be validating. In each case, we need to use a unique
    name for this local variable. For example, for workout name we add `#name="ngModel"`
    within the `input` tag for that control along with the HTML 5 `required` attribute.
    The workout name `input` tag should now look like this:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要在所有要验证的表单控件中，为`ngModel`分配一个本地变量。在每种情况下，我们需要为这个本地变量使用一个唯一的名称。例如，对于锻炼名称，我们在该控件的`input`标签内添加`#name="ngModel"`，以及HTML
    5的`required`属性。现在锻炼名称的`input`标签应该是这样的：
- en: '[PRE51]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Continue through the form, assigning `ngModel` to local variables for each of
    the inputs. Also, add the required attribute for all the required fields.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 通过表单，为每个输入分配`ngModel`到本地变量。同时，为所有必填字段添加`required`属性。
- en: The Angular model state
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular模型状态
- en: 'Whenever we use `NgForm`, every element within our form, including input, text
    area, and select, has some states defined on the associated model. `ngModel` tracks
    these states for us. The states tracked are:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用`NgForm`时，我们表单中的每个元素（包括输入、文本区域和选择）都会有与相关模型定义的某些状态。`ngModel`为我们跟踪这些状态。跟踪的状态包括：
- en: '`pristine`: The value of this is `true` as long as the user does not interact
    with the input. Any update to the `input` field and `ng-pristine` is set to `false`.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pristine`：只要用户不与输入进行交互，其值就为`true`。对`input`字段的任何更新都将使`ng-pristine`更改为`false`。'
- en: '`dirty`: This is the reverse of `ng-pristine`. This is `true` when the input
    data has been updated.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dirty`：这与`ng-pristine`相反。当输入数据已更新时为`true`。'
- en: '`touched`: This is `true` if the control ever had focus.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touched`：如果控件曾经获得焦点，则为`true`。'
- en: '`untouched`: This is `true` if the control has never lost focus. This is just
    the reverse of `ng-touched`.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`untouched`：如果控件从未失去焦点，则为`true`。这只是`ng-touched`的相反。'
- en: '`valid`: This is `true` if there are validations defined on the `input` element
    and none of them are failing.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valid`：如果`input`元素上定义了验证，并且没有任何验证失败，则为`true`。'
- en: '`invalid`: This is `true` if any of the validations defined on the element
    are failing.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalid`：如果元素上定义的任何验证失败，则为`true`。'
- en: '`pristine``dirty` or `touched``untouched` are useful properties that can help
    us decide when error labels are shown.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`pristine``dirty`或`touched``untouched`是有用的属性，可帮助我们决定何时显示错误标签。'
- en: Angular CSS classes
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular CSS类
- en: 'Based on the model state, Angular adds some CSS classes to an input element.
    These include the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 基于模型状态，Angular会向输入元素添加一些CSS类。这些包括以下内容：
- en: '`ng-valid`: This is used if the model is valid'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-valid`：如果模型有效，则使用该标识。'
- en: '`ng-invalid`: This is used if the model is invalid'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-invalid`：如果模型无效，则使用该标识。'
- en: '`ng-pristine`: This is used if the model is pristine'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-pristine`：如果模型是原始的，则使用该标识'
- en: '`ng-dirty`: This is used if the model is dirty'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-dirty`：如果模型已更改，则使用该标识。'
- en: '`ng-untouched`: This is used when the input is never visited'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-untouched`：如果输入从未被访问过，则使用该标识'
- en: '`ng-touched`: This is used when the input has focus'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-touched`：如果输入已获得焦点，则使用该标识。'
- en: 'To verify it, go back to the `workoutName` input tag and add a template reference
    variable named `spy` inside the `input` tag:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行验证，请返回到`workoutName`输入标签，并在`input`标签内添加名为`spy`的模板引用变量。
- en: '[PRE52]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, below the tag, add the following label:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在标签下面添加以下标签：
- en: '[PRE53]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Reload the application and click on the New Workout link in the *Workout Builder*.
    Before touching anything on the screen, you will see the following displayed:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载应用程序，并点击*训练构建器*中的新训练链接。在屏幕上什么都不动之前，会显示以下内容：
- en: '![](img/f8643209-7e90-4b2f-8665-60fad1fd0777.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8643209-7e90-4b2f-8665-60fad1fd0777.png)'
- en: 'Add some content into the Name input box and tab away from it. The label changes
    to this:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 将一些内容添加到名称输入框中，并切换到其他位置。标签会更改为：
- en: '![](img/a44e53db-4fdf-4545-8ac7-6a986a1aa973.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a44e53db-4fdf-4545-8ac7-6a986a1aa973.png)'
- en: What we are seeing here is Angular changing the CSS classes that apply to this
    control as the user interacts with it. You can also see these changes by inspecting
    the `input` element in the developer console.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到的是，随着用户与其交互，Angular会更改应用于该控件的CSS类。您还可以通过在开发者控制台中检查`input`元素来查看这些更改。
- en: 'These CSS class transitions are tremendously useful if we want to apply visual
    clues to the element depending on its state. For example, look at this snippet:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望根据其状态对元素应用可视提示，这些CSS类转换将非常有用。例如，看看这个片段：
- en: '[PRE54]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This draws a red border around any input control that has invalid data.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在任何输入控件周围绘制红色边框，表示数据无效。
- en: As you add more validations to the Workout page, you can observe (in the developer
    console) how these classes are added and removed as the user interacts with the
    `input` element.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向训练页面添加更多验证时，您可以观察（在开发者控制台中）这些类在用户与`input`元素交互时是如何添加和删除的。
- en: Now that we have an understanding of model states and how to use them, let's
    get back to our discussion of validations (before moving on, remove the variable
    name and label that you just added).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了模型状态及其用法，让我们回到验证的讨论（在继续之前，请删除刚刚添加的变量名和标签）。
- en: Workout validation
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练验证
- en: The workout data needs to be validated for a number of conditions.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 需要验证训练数据是否符合一系列条件。
- en: After taking the step of adding the local variable references for `ngModel`
    and the required attribute to our `input` fields, we have been able to see how
    `ngModel` tracks changes in the state of these controls and how it toggles the
    CSS styles.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在为`input`字段添加了`ngModel`和`required`属性的本地变量引用之后，我们已经能够看到`ngModel`如何跟踪这些控件的状态变化以及如何切换CSS样式。
- en: Displaying appropriate validation messages
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示适当的验证消息
- en: Now, the input needs to have a value; otherwise, the validation fails. But,
    how can we know if the validation has failed? `ngModel` comes to our rescue here.
    It can provide the validation state of the particular input. And that gives us
    what we need to display an appropriate validation message.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入必须有值，否则验证将失败。但是，我们如何知道验证是否失败呢？`ngModel`在这里来拯救我们。它可以提供特定输入的验证状态。这就给了我们显示适当验证消息所需的信息。
- en: 'Let''s go back to the input control for the Workout name. In order to get a
    validation message to display, we have to first modify the input tag to the following:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们回到训练计划名称的输入控件。为了显示验证消息,我们必须先修改输入标签如下:'
- en: '[PRE55]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We have added a local variable called `#name` and assigned `ngModel` to it.
    This is called a template reference variable and we can use it with the following
    label to display a validation message for the input:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '我们添加了一个名为`#name`的本地变量,并将`ngModel`分配给它。这被称为模板引用变量,我们可以使用以下标签来显示输入的验证消息:'
- en: '[PRE56]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are showing the validation message in the event that the name is not provided
    and the control has been touched. To check the first condition, we retrieve the
    `hasError` property of the control and see if the error type is `required`. We
    check to see if the name input has been `touched` because we do not want the message
    to display when the form first loads for a new workout.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 当未提供名称并且控件已被触摸时，我们会显示验证消息。为了检查第一个条件，我们检索控件的`hasError`属性并查看错误类型是否为`required`。我们检查名称输入是否已被`touched`，因为我们不希望在表单首次加载新训练计划时显示消息。
- en: You will notice that we are using a somewhat more verbose style to identify
    validation errors than is required in this situation. Instead of `name.control.hasError('required')`,
    we could have used `!name. valid` and it would have worked perfectly fine. However,
    using the more verbose approach allows us to identify validation errors with greater
    specificity, which will be essential when we start adding multiple validators
    to our form controls. We'll look at using multiple validators a little later in
    this chapter. For consistency, we'll stick with the more verbose approach.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们使用了一种相对冗长的方式来识别验证错误，而不是简单地使用`!name.valid`。这种方法允许我们以更具体的方式识别验证错误，这在我们开始为表单控件添加多个验证器时将非常重要。我们将在本章稍后讨论使用多个验证器。为了保持一致性，我们将坚持使用这种更冗长的方法。
- en: 'Load the new Workout page (`/builder/workouts/new`) now. Enter a value in the
    name input box and then delete it. The error label appears as shown in the following
    screenshot:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加载新的训练计划页面(`/builder/workouts/new`)。在名称输入框中输入一个值,然后删除它。错误标签会像下面的截图所示的那样显示出来。
- en: '![](img/a29cbdcd-9184-49cb-9e78-ab45b6605d97.png)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a29cbdcd-9184-49cb-9e78-ab45b6605d97.png)'
- en: Adding more validation
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多验证
- en: 'Angular provides several out-of-the-box validators, including:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了几个现成的验证器，包括：
- en: '`required`'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`'
- en: '`minLength`'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minLength`'
- en: '`maxLength`'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxLength`'
- en: '`email`'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`'
- en: '`pattern`'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pattern`'
- en: For the complete list of out-of-the box validators, see the documentation for
    the `Validators` class at [https://angular.io/api/forms/Validators.](https://angular.io/api/forms/Validators)
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 有关现成验证器的完整列表，请参阅[https://angular.io/api/forms/Validators](https://angular.io/api/forms/Validators)中`Validators`类的文档。
- en: 'We''ve seen how the `required` validator works. Now, let''s look at two of
    the other out-of-the-box validators: `minLength` and `maxLength`. In addition
    to making it required, we want the title of the workout to be between 5 and 20
    characters (we''ll look at the `pattern` validator a little later in this chapter).'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`required`验证器的工作原理。现在,让我们看看另外两个现成的验证器:`minLength`和`maxLength`。除了将其设为必填项外，我们还希望训练计划的标题长度在5到20个字符之间（我们稍后将介绍`pattern`验证器）。
- en: 'So, in addition to the `required` attribute we added previously to the title
    input box, we will add the `minLength` attribute and set it to `5`, and add the
    `maxLength` attribute and set it to `20`, like so:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前添加到标题输入框的`required`属性外，我们还将添加`minLength`属性并将其设置为`5`，并添加`maxLength`属性并将其设置为`20`。
- en: '[PRE57]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, we add another label with a message that will display when this validation
    is not met:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们添加另一个标签，其中包含在不满足此验证条件时将显示的消息:'
- en: '[PRE58]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Managing multiple validation messages
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理多个验证消息
- en: 'You''ll see that the conditions for displaying the message now test for the
    length not being zero. This prevents the message from displaying in the event
    that the control is touched but left empty. In that case, the title required message
    should display. This message only displays if nothing is entered in the field
    and we accomplish this by checking explicitly to see if the control''s `hasError`
    type is `required`:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '你会发现，现在显示消息的条件是测试长度不为零。这可以防止在控件被触摸但留空的情况下显示消息。在这种情况下，标题需要的消息应该显示。这条消息只有在字段中没有输入任何内容时才显示，我们通过明确检查控件的`hasError`类型是否为`required`来实现这一点:'
- en: '[PRE59]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Since we are attaching two validators to this input field, we can consolidate
    the check for the input being touched by wrapping both validators in a div tag
    that checks for that condition being met:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们将两个验证器附加到此输入字段，我们可以通过在检查是否满足该条件的div标签中包含两个验证器来简化对输入被触摸的检查:'
- en: '[PRE60]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: What we just did shows how we can attach multiple validations to a single input
    control and also display the appropriate message in the event that one of the
    validation conditions is not met. However, it's pretty clear that this approach
    will not scale for more complicated scenarios. Some inputs contain a lot of validations
    and controlling when a validation message shows up can become complex. As the
    expressions for handling the various displays get more complicated, we may want
    to refactor and move them into a custom directive. Creating a custom directive
    will be covered in detail in [Chapter 4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml),
    *Angular Directives in Depth*.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚所做的展示了如何将多个验证附加到单个输入控件，并在不满足其中一个验证条件时显示适当的消息。然而，很明显，这种方法在处理更复杂的场景时并不可扩展。一些输入包含很多验证，并且控制验证消息何时显示可能变得复杂。随着处理各种显示的表达式变得更加复杂，我们可能希望重构并将它们移入一个自定义指令中。如何创建自定义指令将在[第4章](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml)，*深入理解
    Angular 指令*中详细介绍。
- en: Custom validation messages for an exercise
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于一个锻炼的自定义验证消息
- en: A workout without any exercise is of no use. There should at least be one exercise
    in the workout and we should validate this restriction.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 运动而没有任何锻炼是无用的。锻炼中至少应该有一种锻炼，我们应该验证这一限制。
- en: The problem with exercise count validation is that it is not something that
    the user inputs directly and the framework validates. Nonetheless, we still want
    a mechanism to validate the exercise count in a manner similar to other validations
    on this form.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼计数验证的问题在于用户没有直接输入它，而框架却要验证它。尽管如此，我们仍然希望一种机制来验证锻炼计数，类似于此表单上的其他验证。
- en: 'What we will do is add a hidden input box to the form that contains the count
    of the exercises. We will then bind this to `ngModel` and add a pattern validator
    that will check to make sure that there is more than one exercise. We will set
    the value of the input box to the count of the exercises:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '我们要做的是向表单中添加一个隐藏的输入框，其中包含了锻炼的计数。然后我们将其绑定到`ngModel`并添加一个模式验证器，以确保有多于一个锻炼。我们将输入框的值设置为锻炼的计数:'
- en: '[PRE61]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we will attach a validation message to it similar to what we just did
    with our other validators:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们将类似于我们刚刚对其他验证器所做的操作附加到它的验证消息:'
- en: '[PRE62]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We are not using `ngModel` in its true sense here. There is no two-way binding
    involved. We are only interested in using it to do custom validation.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里并没有真正使用`ngModel`。这里没有涉及双向绑定。我们只对使用它进行自定义验证感兴趣。
- en: 'Open the new Workout page, add an exercise, and remove it; we should see this
    error:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '打开新的锻炼页面，添加一个锻炼，然后将其删除; 我们应该看到这个错误:'
- en: '![](img/a46fd29c-0d4f-4157-ba8d-e6d2cd3b5e60.png)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a46fd29c-0d4f-4157-ba8d-e6d2cd3b5e60.png)'
- en: What we did here could have been easily done without involving any model validation
    infrastructure. But, by hooking our validation into that infrastructure, we do
    derive some benefits. We can now determine errors with a specific model and errors
    with the overall form in a consistent and familiar manner. Most importantly, if
    our validation fails here, the entire form will be invalidated.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的事情本来可以很容易地完成，而不涉及任何模型验证基础设施。但是，通过将我们的验证钩入该基础设施中，我们会获得一些好处。我们现在可以以一种一致而熟悉的方式确定特定模型的错误和整个表单的错误。最重要的是，如果我们的验证在这里失败，整个表单将无效。
- en: Implementing custom validation the way we just did is not what you would want
    to do very often. Instead, it will usually make more sense to implement this kind
    of complicated logic inside a custom directive. We'll cover creating custom directives
    in detail in [Chapter 4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml), *Angular
    Directives in Depth*.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 实现刚刚进行的自定义验证通常不是您经常想要做的事情。相反，通常更合理的做法是在自定义指令内部实现这种复杂逻辑。我们将在[第4章](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml)的*深入理解Angular指令*中详细介绍创建自定义指令。
- en: One nuisance with our newly implemented `Exercise Count` validation is that
    it shows when the screen for a new `Workout` first appears. With this message,
    we are not able to use `ng-touched` to hide the display. This is because the exercises
    are being added programmatically and the hidden input we are using to track their
    count never changes from untouched as exercises are added or removed.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新实现的`Exercise Count`验证的一个讨厌之处是，在新的`Workout`屏幕首次出现时就会显示。使用这个消息，我们无法使用`ng-touched`来隐藏显示。因为练习是以程序方式添加的，并且我们使用来跟踪其数量的隐藏输入在练习被添加或删除时从未改变为已接触的状态。
- en: 'To fix this problem, we need an additional value to check when the state of
    the exercise list has been reduced to zero, except when the form is first loaded.
    The only way that situation can happen is if the user adds and then removes exercises
    from a workout to the point that there are no more exercises. So, we''ll add another
    property to our component that we can use to track whether the remove method has
    been called. We call that value `removeTouched` and set its initial value to `false`:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们需要一个额外的值来检查练习列表的状态何时减少到零，除非表单是第一次加载。这种情况发生的唯一方式是用户添加然后从锻炼中删除练习，直到没有更多的练习为止。因此，我们将向组件添加另一个属性，用于跟踪删除方法是否已被调用。我们称这个值为`removeTouched`并设置其初始值为`false`：
- en: '[PRE63]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, in the remove method we will set that value to `true`:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在删除方法中，我们将该值设置为`true`：
- en: '[PRE64]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we will add `removeTouched` to our validation message conditions, like
    so:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将将`removeTouched`添加到我们的验证消息条件中，如下所示：
- en: '[PRE65]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, when we open a new workout screen, the validation message will not display.
    But if the user adds and then removes all the exercises, then it will display.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们打开一个新的锻炼屏幕时，验证消息将不会显示。但是，如果用户添加然后删除所有练习，那么它将显示。
- en: To understand how model validation rolls up into form validation, we need to
    understand what form-level validation has to offer. However, even before that,
    we need to implement saving the workout and calling it from the workout form.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解模型验证如何转化为表单验证，我们需要了解表单级别验证提供了什么。但是，即使在那之前，我们也需要实现保存锻炼并从锻炼表单中调用它。
- en: Saving the workout
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存锻炼
- en: The workout that we are building needs to be persisted (in-memory only). The
    first thing that we need to do is extend `WorkoutService` and `WorkoutBuilderService`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的锻炼需要被持久化（仅内存中）。我们需要做的第一件事就是扩展`WorkoutService`和`WorkoutBuilderService`。
- en: '`WorkoutService` needs two new methods, `addWorkout` and `updateWorkout`:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutService`需要两个新方法，`addWorkout`和`updateWorkout`：'
- en: '[PRE66]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `addWorkout` method does a basic check on the workout name and then pushes
    the workout into the workout array. Since there is no backing store involved,
    if we refresh the page, the data is lost. We will fix this in the next chapter
    where we persist the data to a server.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`addWorkout`方法对锻炼名称进行基本检查，然后将锻炼推入锻炼数组中。由于没有涉及后备存储，如果刷新页面，数据就会丢失。我们将在下一章中修复这个问题，将数据持久保存到服务器。'
- en: The `updateWorkout` method looks for a workout with the same name in the existing
    workouts array and if found, updates and replaces it.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateWorkout`方法在现有的锻炼数组中查找具有相同名称的锻炼，并在找到时进行更新和替换。'
- en: 'We only add one save method to `WorkoutBuilderService` as we are already tracking
    the context in which workout construction is going on:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要向`WorkoutBuilderService`添加一个保存方法，因为我们已经在追踪进行中的锻炼构建的上下文：
- en: '[PRE67]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `save` method calls either `addWorkout` or `updateWorkout` in the `Workout`
    service based on whether a new workout is being created or an existing one is
    being edited.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`save`方法根据是否正在创建新的锻炼或正在编辑现有的锻炼，在`Workout`服务中调用`addWorkout`或`updateWorkout`。'
- en: From a service perspective, that should be enough. Time to integrate the ability
    to save workouts into the `Workout` component and learn more about the form directive!
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务的角度来看，这就足够了。是时候将保存锻炼的能力集成到`Workout`组件中，并了解更多关于表单指令的知识了！
- en: 'Before we look at `NgForm` in more detail, let''s add the save method to `Workout`
    to save the workout when the `Save` button is clicked on. Add this code to the
    `Workout` component:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在更详细地查看`NgForm`之前，让我们向`Workout`添加保存方法，以便在单击`保存`按钮时保存训练计划。将以下代码添加到`Workout`组件中：
- en: '[PRE68]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We check the validation state of the form using its invalid property and then
    call the `WorkoutBuilderService.save` method if the form state is valid.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用其invalid属性检查表单的验证状态，如果表单状态有效，则调用`WorkoutBuilderService.save`方法。
- en: More on NgForm
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgForm更多内容
- en: Forms in Angular have a different role to play as compared to traditional forms
    that post data to the server. If we go back and look again at the form tag, we
    will see that it is missing the standard action attribute. The standard form behavior
    of posting data to the server using full-page post-back does not make sense with
    an SPA framework such as Angular. In Angular, all server requests are made through
    asynchronous invocations originating from directives or services.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，与传统的向服务器发送数据的表单相比，表单扮演了不同的角色。如果我们回头再看一下form标签，会发现它缺少标准的action属性。使用Angular等SPA框架时，通过完整页面的回发方式向服务器发送数据不合理。在Angular中，所有服务器请求都是通过起源于指令或服务的异步调用进行的。
- en: Under the hood, Angular is also turning off the browser's inbuilt validation.
    As you have seen in this chapter, we are still using validation attributes such
    as `required` that look the same as native HTML validation attributes. However,
    as the Angular documentation explains, inside an Angular form "Angular uses directives
    to match these attributes with validator functions in the framework." See  [https://angular.io/guide/form-validation#template-driven-validation](https://angular.io/guide/form-validation#template-driven-validation).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Angular还关闭了浏览器的内置验证。正如您在本章中看到的，我们仍在使用`required`等验证属性，看起来与原生HTML验证属性相同。然而，正如Angular文档所解释的那样，在Angular表单内部，“Angular使用指令将这些属性与框架中的验证器函数匹配。”
    参见[https://angular.io/guide/form-validation#template-driven-validation](https://angular.io/guide/form-validation#template-driven-validation)。
- en: 'The form here plays a different role. When the form encapsulates a set of input
    elements (such as input, textarea, and select) it provides an API for:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的表单扮演着不同的角色。当表单封装一组输入元素（如输入、文本框和选择）时，它提供了一个API来：
- en: Determining the state of the form, such as whether the form is dirty or pristine
    based on the input controls on it
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据表单上的输入控件确定表单的状态，例如表单是脏的还是原始的
- en: Checking validation errors at the form or control level
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表单或控制级别检查验证错误
- en: If you still want the standard form behavior, you can add an `ngNoForm` attribute
    to the `form` element, but this will definitely cause a full-page refresh. You
    can also turn on the browser's inbuilt validation by adding the `ngNativeValidate`
    attribute. We'll explore the specifics of the `NgForm` API a little later in this
    chapter when we look at saving the form and implementing validation.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍希望使用标准表单行为，可以向`form`元素添加`ngNoForm`属性，但这肯定会导致完整页面刷新。您还可以通过添加`ngNativeValidate`属性来开启浏览器的内置验证。在本章后面的部分，当我们看到如何保存表单和实现验证时，我们将更详细地探讨`NgForm`
    API的具体内容。
- en: The state of the `FormControl` objects within the form is being monitored by
    `NgForm`. If any of them are invalid, then `NgForm` sets the entire form to invalid.
    In this case, we have been able to use `NgForm` to determine that one or more
    of the `FormControl` objects is invalid and therefore the state of the form as
    a whole is invalid too.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 表单内FormControl对象的状态由`NgForm`监视。如果其中任何一个无效，那么`NgForm`会将整个表单设置为无效。在这种情况下，我们已经能够使用`NgForm`确定一个或多个`FormControl`对象是无效的，因此整个表单的状态也是无效的。
- en: Let's look at one more issue before we finish this chapter.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章节之前，让我们再看一起问题。
- en: Fixing the saving of forms and validation messages
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复表单的保存和验证消息
- en: 'Open a new Workout page and directly click on the Save button. Nothing is saved
    as the form is invalid, but validations on individual form input do not show up
    at all. It now becomes difficult to know what elements have caused validation
    failure. The reason behind this behavior is pretty obvious. If we look at the
    error message binding for the name input element, it looks like this:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的Workout页面，直接点击保存按钮。由于表单无效，什么也没有被保存，但是单个表单输入的验证根本不会显示出来。现在很难知道是哪些元素导致了验证失败。这种行为背后的原因非常明显。如果我们查看名称输入元素的错误消息绑定，会看到以下内容：
- en: '[PRE69]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Remember that, earlier in the chapter, we explicitly disabled showing validation
    messages until the user has touched the input control. The same issue has come
    back to bite us and we need to fix it now.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在本章的早些时候，我们明确禁用了显示验证消息，直到用户触摸输入控件为止。同样的问题又回来找我们了，我们现在需要修复它。
- en: 'We do not have a way to explicitly change the touched state of our controls
    to untouched. Instead, we will resort to a little trickery to get the job done.
    We''ll introduce a new property called `submitted`. Add it at the top of the `Workout`
    class definition and set its initial value to `false`, like so:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有办法显式地将控件的触摸状态更改为未触摸状态。相反，我们将求助于一点欺诈来完成工作。我们将引入一个名为`submitted`的新属性。将其添加在`Workout`类定义的顶部，并将其初始值设置为`false`，如下所示：
- en: '[PRE70]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The variable will be set to `true` on the Save button click. Update the save
    implementation by adding the highlighted code:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 当保存按钮被点击时，变量将被设置为`true`。通过添加以下高亮显示的代码来更新保存的实现：
- en: '[PRE71]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'However, how does this help? Well, there is another part to this fix that requires
    us to change the error message for each of the controls we are validating. The
    expression now changes to:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这有什么帮助呢？好吧，这个修复的另一个部分需要我们更改我们正在验证的每个控件的错误消息。现在表达式变成了：
- en: '[PRE72]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: With this fix, the error message is shown when the control is touched or the
    form submit button is pressed (`submitted` is `true`). This expression fix now
    has to be applied to every validation message where a check appears.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个修复，当控件被触摸时或表单提交按钮被按下时（`submitted`为`true`），错误消息将被显示。此表达式修复现在必须适用于每个出现检查的验证消息。
- en: 'If we now open the new Workout page and click on the Save button, we should
    see all validation messages on the input controls:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在打开新的Workout页面并点击保存按钮，则应该在输入控件上看到所有验证消息：
- en: '![](img/39735e3a-1907-4f9b-b1c6-b619a72a9c98.png)'
  id: totrans-536
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39735e3a-1907-4f9b-b1c6-b619a72a9c98.png)'
- en: Reactive forms
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式表单
- en: The other type of form that Angular supports is called **reactive** forms. **Reactive
    forms** start with a model that is constructed in a component class. With this
    approach, we use the **form builder API** to create a form in code and associate
    it with a model.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持的另一种表单类型称为**响应式**表单。**响应式表单**始于在组件类中构建的模型。通过这种方式，我们使用**表单构建器API**在代码中创建一个表单，并将其与一个模型关联起来。
- en: Given the minimal code we have to write to get template-driven forms working,
    why and when should we consider using reactive forms? There are several situations
    in which we might want to use them. These include cases where we want to take
    programmatic control of creating the form. This is especially beneficial, as we
    will see, when we are trying to create form controls dynamically based on data
    we are retrieving from the server.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们必须编写的最小代码来使模板驱动表单工作，那么为什么以及何时应考虑使用响应式表单呢？有几种情况下，我们可能想要使用它们。这些情况包括我们想要以编程方式控制创建表单的情况。尤其是在我们试图基于从服务器检索到的数据动态创建表单控件时，这是特别有益的，正如我们将看到的那样。
- en: If our validation gets complicated, it is often easier to handle it in code.
    Using reactive forms, we can keep this complicated logic out of the HTML template,
    making the template syntax simpler.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的验证变得复杂，通常更容易在代码中处理。使用响应式表单，我们可以将这些复杂的逻辑从HTML模板中分离出来，使模板语法更简单。
- en: Another significant advantage of reactive forms is that they make unit-testing
    the form possible, which is not the case with **template-driven forms.** We can
    simply instantiate our form controls in our tests and then test them outside the
    markup on our page.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式表单的另一个重要优势是，它使得对表单进行单元测试成为可能，这对**模板驱动表单**来说并非如此。我们可以在我们的测试中简单实例化我们的表单控件，然后在页面上的标记之外对它们进行测试。
- en: '**Reactive forms** use three new form directives that we haven''t discussed
    before: `FormGroup`, `FormControl`, and `FormArray`. These directives allow the
    form object that is constructed in code to be tied directly to the HTML markup
    in the template. The form controls that are created in the component class are
    then directly available in the form itself. Technically speaking, this means that
    we don''t need to use `ngModel` (which is integral to template-driven forms) with
    reactive forms (although it can be used). The overall approach is a cleaner and
    less cluttered template with more focus on the code that drives the form. Let''s
    get started with building a reactive form.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式表单**使用了三个我们之前没有讨论过的新表单指令：`FormGroup`、 `FormControl` 和 `FormArray`。这些指令允许在代码中构建的表单对象与模板中的
    HTML 标记直接绑定。在组件类中创建的表单控件随后也直接可用于表单本身。从技术上讲，这意味着我们不需要在响应式表单中使用 `ngModel`（这是模板驱动表单的核心部分），尽管它也可以使用。总体上，这种方法使得模板更清晰、更简洁，更专注于驱动表单的代码。让我们开始构建一个响应式表单。'
- en: Getting started with reactive forms
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用响应式表单入门
- en: We'll make use of reactive forms to build the form to add and edit Exercises.
    Among other things, this form will allow the user to add links to exercise videos
    on YouTube. And since they can add any number of video links, we will need to
    be able to add controls for these video links dynamically. This challenge will
    present a good test of how effective reactive forms can be in developing more
    complex forms.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用响应式表单来构建添加和编辑练习的表单。除其他内容外，该表单将允许用户在 YouTube 上添加练习视频的链接。由于他们可以添加任意数量的视频链接，我们需要能够动态添加这些视频链接的控件。这个挑战将对响应式表单在开发更复杂的表单时的有效性提出良好的测试。
- en: 'Here is how the form will look:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 表单将如下所示：
- en: '![](img/5dbd17b9-5bcb-41b1-b46d-5f1260402003.png)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dbd17b9-5bcb-41b1-b46d-5f1260402003.png)'
- en: 'To get started, open `workout-builder.module.ts` and add the following `import`:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请打开 `workout-builder.module.ts` 并添加以下`import`：
- en: '[PRE73]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`ReactiveFormsModule` contains what we will need to build reactive forms.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactiveFormsModule` 包含了构建响应式表单所需的内容。'
- en: 'Next, copy `exercise-builder-service.ts` from the `workout-builder/builder-services`
    folder under `trainer/src/app` in `checkpoint 4.6` and import it into `workout-builder.module.ts`:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从 `checkpoint 4.6` 下的 `trainer/src/app` 中的 `workout-builder/builder-services`
    文件夹中复制 `exercise-builder-service.ts` 并将其导入到 `workout-builder.module.ts` 中：
- en: '[PRE74]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, add it as an additional provider to the providers array in that same
    file:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一文件中的提供者数组中将其添加为附加提供者：
- en: '[PRE75]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You will notice here that we also have added `ExerciseResolver` as a provider.
    We won't be covering that here, but you should copy it from the `exercise` folder
    as well and also copy the updated `workout-builder-routing.module.ts`, which adds
    it as a route guard for the navigation to `ExerciseComponent`.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还已将 `ExerciseResolver` 添加为提供者。我们在这里不会讨论这个，但你应该从 `exercise` 文件夹下也复制它，并且还要复制更新后的
    `workout-builder-routing.module.ts`，将它作为导航到 `ExerciseComponent` 的路由守卫。
- en: 'Now, open `exercise.component.ts` and add the following import statement:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 `exercise.component.ts` 并添加以下导入语句：
- en: '[PRE76]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This brings in the following, which we will use to construct our form:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引入我们将用来构建表单的以下内容：
- en: '`FormBuilder`'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormBuilder`'
- en: '`FormGroup`'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormGroup`'
- en: '`FormControl`'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormControl`'
- en: '`FormArray`'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormArray`'
- en: 'Finally, we inject `FormBuilder` (as well as `Router`, `ActivatedRoute`, and
    `ExerciseBuilderService`) into the constructor of our class:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `FormBuilder`（以及 `Router`、 `ActivatedRoute` 和 `ExerciseBuilderService`）注入到我们类的构造函数中：
- en: '[PRE77]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: With these preliminary steps out of the way, we can now go ahead and start building
    out our form.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这些初步步骤，我们现在可以开始构建我们的表单了。
- en: Using the FormBuilder API
  id: totrans-565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FormBuilder API
- en: 'The `FormBuilder` API is the foundation for reactive forms. You can think of
    it as a factory for turning out the forms we are constructing in our code. Go
    ahead and add the `ngOnInit` lifecycle hook to your class, as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormBuilder` API 是响应式表单的基础。你可以把它想象成是在我们的代码中构建表单的工厂。现在，在你的类中添加 `ngOnInit` 生命周期钩子，如下所示：'
- en: '[PRE78]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: When `ngOnInit` fires, it will extract the data for an existing or new `exercise`
    from the route data that has been retrieved and returned by `ExerciseResolver`.
    This is the same pattern we followed with initializing the `Workout` component.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ngOnInit` 被触发时，它将从由 `ExerciseResolver` 检索和返回的路由数据中提取现有或新的 `exercise` 的数据。这与初始化
    `Workout` 组件时遵循的模式相同。
- en: 'Now, let''s implement the `buildExerciseForm` method by adding the following
    code:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加以下代码来实现 `buildExerciseForm` 方法：
- en: '[PRE79]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Let''s examine this code. To start with, we are using the injected instance
    of `FormBuilder` to construct the form and assign it to a local variable, `exerciseForm`.
    Using `formBuilder.group`, we add several form controls to our form. We add each
    of them by a simple key/value mapping:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这段代码。首先，我们使用注入的`FormBuilder`实例来构建表单并将其分配给一个本地变量`exerciseForm`。使用`formBuilder.group`，我们向表单添加了多个表单控件。我们通过简单的键/值映射添加了每个表单控件：
- en: '[PRE80]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The left side of the mapping is the name of the `FormControl`, and the right
    is an array containing as its first element the value of the control (in our case,
    the corresponding element on our exercise model) and the second a validator (in
    this case, the out-of-the-box required validator). Nice and neat! It's definitely
    easier to see and reason about our form controls by setting them up outside the
    template.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的左侧是`FormControl`的名称，右侧是一个数组，它的第一个元素是控件的值（在我们的例子中是我们练习模型上对应的元素），第二个是验证器（在这种情况下是开箱即用的必需验证器）。非常整洁！通过在模板之外设置表单控件来设置它们，肯定更容易看到和理解我们的表单控件。
- en: 'We can not only build up `FormControls` in our form this way but also add `FormControlGroups`
    and `FormControlArray`, which contain `FormControls` within them. This means we
    can create complex forms that contain nested input controls. In our case, as we
    have mentioned, we are going to need to accommodate the possibility of our users
    adding multiple videos to an exercise. We can do this by adding the following
    code:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以用这种方式在我们的表单中构建`FormControls`，还可以添加`FormControlGroups`和`FormControlArray`，它们包含其中的`FormControls`。这意味着我们可以创建包含嵌套输入控件的复杂表单。在我们的情况下，正如我们已经提到的，我们需要考虑用户可能向练习中添加多个视频的情况。我们可以通过添加以下代码来实现：
- en: '[PRE81]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'What we are doing here is assigning a `FormArray` to videos, which means we
    can assign multiple controls in this mapping. To construct this new `FormArray`,
    we add the following `addVideoArray` method to our class:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是将一个`FormArray`分配给视频，这意味着我们可以在这个映射中分配多个控件。为了构造这个新的`FormArray`，我们向我们的类添加了以下`addVideoArray`方法：
- en: '[PRE82]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This method constructs a `FormControl` for each video; each is then added each
    to a `FormArray` that is assigned to the videos control in our form.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法为每个视频构造了一个`FormControl`；然后将每个视频添加到分配给我们的表单中的`videos`控件的`FormArray`中。
- en: Adding the form model to our HTML view
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将表单模型添加到我们的HTML视图
- en: 'So far, we have been working behind the scenes in our class to construct our
    form. The next step is to wire up our form to the view. To do this, we use the
    same controls that we used to build the form in our code: `formGroup`, `formControl`,
    and `formArray`.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在我们的类中幕后工作来构建我们的表单。下一步是将我们的表单连接到视图。为此，我们使用了同样的控件，用来在我们的代码中构建表单：`formGroup`，`formControl`和`formArray`。
- en: 'Open `exercise.component.html` and add a `form` tag as follows:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`exercise.component.html`并添加如下的`form`标签：
- en: '[PRE83]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Within the tag, we are first assigning the `exerciseForm` that we just built
    in code to `formGroup`. This establishes the connection between our coded model
    and the form in the view. We also wire up the `ngSubmit` event to an `onSubmit`
    method in our code (we'll discuss this method a little later).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签内，我们首先将我们刚刚在代码中构建的`exerciseForm`分配给`formGroup`。这样建立了我们编码模型与视图中表单的连接。我们还将`ngSubmit`事件与代码中的`onSubmit`方法连接起来（我们稍后会讨论这个方法）。
- en: Adding form controls to our form inputs
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将表单控件添加到我们的表单输入中
- en: 'Next, we start constructing the inputs for our form. We''ll start with the
    input for the name of our exercise:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始构建我们表单的输入。我们将以我们练习名称的输入开始：
- en: '[PRE84]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We assign the name of our coded form control to `formControlName`. This establishes
    the link between the control in our code and the `input` field in the markup.
    Another item of interest here is that we do not use the `required` attribute.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们编码的表单控件的名称分配给`formControlName`。这样就建立了我们代码中的控件与标记中的`input`字段之间的链接。这里另一个值得注意的是，我们没有使用`required`属性。
- en: Adding validation
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加验证
- en: 'The next thing that we do is add a validation message to the control that will
    display in the event of a validation error:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的是向控件添加验证消息，以便在验证出错时显示：
- en: '[PRE85]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Notice that this markup is very similar to what we used in template-driven forms
    for validation, except that the syntax for identifying the control is somewhat
    more verbose Again, it checks the state of the `hasError` property of the control
    to make sure it is valid.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种标记非常类似于我们在模板驱动表单中用于验证的内容，只是用于识别控件的语法有点更冗长。它再次检查控件的`hasError`属性状态，以确保它是有效的。
- en: 'But wait a minute! How can we validate this input? Haven''t we removed the
    required attribute from our tag? This is where the control mappings that we added
    in our code come into play. If you look back at the code for the form model, you
    can see the following mapping for the `name` control:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '但等一下！我们如何验证此输入？我们难道没有从标签中删除`required`属性吗？这就是我们在代码中添加的控件映射发挥作用的地方。如果回顾一下表单模型的代码，您可以看到`name`控件的以下映射:'
- en: '[PRE86]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The second element in the mapping array assigns the required validator to the
    name form control. This means that we don't have to add anything to our template;
    instead, the form control itself is attached to the template with a required validator.
    The ability to add a validator in our code enables us to conveniently add validators
    outside our template. This is especially useful when it comes to writing custom
    validators with complex logic behind them.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 映射数组中的第二个元素将必填验证器分配给名称表单控件。这意味着我们不必在模板中添加任何内容；相反，表单控件本身附加了一个必填验证器到模板上。在代码中添加验证器的能力使我们能够方便地在模板之外添加验证器。当涉及编写具有复杂逻辑的自定义验证器时，这是特别有用的。
- en: Adding dynamic form controls
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动态表单控件
- en: 'The Exercise form that we are building requires that we allow the user to add
    one or more videos to the exercise. Since we don''t know how many videos the user
    may want to add, we will have to build the `input` fields for these videos dynamically
    as the user clicks on the Add Video button. Here''s how it will look:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '我们正在构建的练习表单要求允许用户向练习中添加一个或多个视频。由于我们不知道用户可能希望添加多少视频，我们将不得不在用户点击添加视频按钮时动态构建这些视频的`input`字段。它将如下所示:'
- en: '![](img/94aa6524-5112-41ea-8ce0-6c9e622cdce8.png)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94aa6524-5112-41ea-8ce0-6c9e622cdce8.png)'
- en: We have already seen the code in our component class that we use to do this.
    Now, let's take a look at how it is implemented in our template.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的组件类中看到了用于执行此操作的代码。现在，让我们看看如何在我们的模板中实现它。
- en: 'We first use `ngFor` to loop through our list of videos. Then, we assign the
    index in our videos to a local variable, `i`. No surprises so far:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`ngFor`循环遍历视频列表。然后，我们将视频在列表中的索引赋值给本地变量`i`。到目前为止，没有什么意外。
- en: '[PRE87]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Inside the loop, we do three things. First, we dynamically add a video `input` field
    for each of the videos currently in our exercise:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内，我们做了三件事。首先，我们为当前练习中的每个视频动态添加一个视频`input`字段。
- en: '[PRE88]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, we add a button to allow the user to delete a video:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们添加一个按钮，允许用户删除视频:'
- en: '[PRE89]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We bind a `deleteVideo` method in our component class to the button's `click`
    event and pass to it the index of the video being deleted.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组件类中的`deleteVideo`方法绑定到按钮的`click`事件上，并传递给它被删除的视频的索引。
- en: 'We then add a validation message for each of the video `input` fields:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们为每个视频`input`字段添加验证消息:'
- en: '[PRE90]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The validation message follows the same pattern for displaying the message that
    we have used elsewhere in this chapter. We drill into the `exerciseFormControls`
    group to find the particular control by its index. Again, the syntax is verbose
    but easy enough to understand.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 验证消息遵循了在本章其他地方使用的显示消息的相同模式。我们进入`exerciseFormControls`组以找到特定索引的控件。再次，语法冗长但足够容易理解。
- en: Saving the form
  id: totrans-609
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存表单
- en: 'The final step in building out our reactive form is to handle saving the form.
    When we constructed the form tag earlier, we bound the `ngSubmit` event to the
    following `onSubmit` method in our code:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 构建响应式表单的最后一步是处理表单的保存。在先前构造表单标签时，我们将`ngSubmit`事件绑定到代码中的以下`onSubmit`方法上。
- en: '[PRE91]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This method sets `submitted` to `true`, which will trigger the display of any
    validation messages that might have been previously hidden because the form had
    not been touched. It also returns without saving in the event that there are any
    validation errors on the form. If there are none, then it calls the following
    `mapFormValues` method, which assigns the values from our form to the `exercise`
    that will be saved:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将`submitted`设置为`true`，这将触发可能之前因表单未被触摸而隐藏的任何验证消息的显示。如果没有任何验证错误，则返回而不保存。如果没有错误，则调用以下`mapFormValues`方法，将表单中的值分配给将要保存的`exercise`。
- en: '[PRE92]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: It then calls the save method in `ExerciseBuilderService` and routes the user
    back to the exercise list screen (remember that any new exercise will not display
    in that list because we have not yet implemented data persistence in our application).
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它调用了`ExerciseBuilderService`中的保存方法，并将用户路由回练习列表屏幕（请记住，任何新练习不会显示在该列表中，因为我们尚未在应用程序中实现数据持久性）。
- en: We hope this makes it clear; reactive forms offer many advantages when we are
    trying to build more complicated forms. They allow programming logic to be removed
    from the template. They permit validators to be added to the form programmatically.
    And, they support building forms dynamically at runtime.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这让事情变得清晰起来；当我们尝试构建更复杂的表单时，响应式表单提供了许多优势。它们允许将编程逻辑从模板中移除。它们允许以编程方式向表单添加验证器。而且，它们支持在运行时动态构建表单。
- en: Custom validators
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义验证器
- en: Now, we'll take a look at one more thing before we conclude this chapter. As
    anyone who has worked on building web forms (either in Angular or any other web
    technology) knows, we are often called on to create validations that are unique
    to the application we are building. Angular provides us with the flexibility to
    enhance our reactive form validation by building custom validators.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们结束本章之前，我们再看一件事。任何在构建Web表单上工作过的人（无论是在Angular还是任何其他Web技术上）都知道，我们经常需要创建适用于我们正在构建的应用程序的独特验证。Angular为我们提供了通过构建自定义验证器来增强我们的响应式表单验证的灵活性。
- en: In building our exercise form, we need to be sure about what is entered, as
    a name contains only alphanumeric characters and no spaces. This is because when
    we get to storing the exercises in a remote data store, we are going to use the
    name of the exercise as its key. So, in addition to the standard required field
    validator, let's build another validator that checks to make sure that the name
    entered is in alphanumeric form only.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的运动形式时，我们需要确保输入的内容，因为名称只包含字母数字字符且没有空格。这是因为当我们开始将练习存储在远程数据存储中时，我们将使用练习的名称作为其键。因此，除了标准的必填字段验证器之外，让我们构建另一个验证器，以确保输入的名称只以字母数字形式存在。
- en: 'Creating a custom control is quite straightforward. In its simplest form, an
    Angular custom validator is a function that takes a control as an input parameter,
    runs the validation check, and returns true or false. So, let''s start by adding
    a TypeScript file with the name `alphanumeric-validator.ts`. In that file, first
    import `FormControl` from `@angular/forms`, then add the following class to that
    file:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义控件非常简单。在其最简单的形式中，Angular自定义验证器是一个以控件作为输入参数的函数，运行验证检查，并返回true或false。因此，让我们首先添加一个名为`alphanumeric-validator.ts`的TypeScript文件。在该文件中，首先从`@angular/forms`中导入`FormControl`，然后在该文件中添加以下类：
- en: '[PRE93]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The code follows the pattern for creating a validator that we just mentioned.
    The only thing that may be a little surprising is that it returns true when the
    validation fails! As long as you are clear on this one quirk, you should have
    no problem writing your own custom validator.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码遵循我们刚提到的创建验证器的模式。唯一可能有点意外的是当验证失败时它返回true！只要你明白这个怪癖，你就应该没有问题编写自己的自定义验证器。
- en: Integrating a custom validator into our forms
  id: totrans-622
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义验证器整合到我们的表单中
- en: 'So how do we plug our custom validator into our form? If we are using reactive
    forms, the answer is pretty simple. We add it just like a built-in validator when
    we build our form in code. Let''s do that. Open `exercise.component.ts` and first
    add an import for our custom validator:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何将自定义验证器插入我们的表单中？如果我们使用响应式表单，答案非常简单。当我们在代码中构建表单时，我们就像添加内置验证器那样添加它。让我们这样做。打开`exercise.component.ts`并首先为我们的自定义验证器添加一个导入：
- en: '[PRE94]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then, modify the form builder code to add the validator to the `name` control:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改表单构建器代码，将验证器添加到`name`控件中：
- en: '[PRE95]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Since the name control already has a required validator, we add `AlphaNumericValidator`
    as a second validator using an array that contains both validators. The array
    can be used to add any number of validators to a control.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 由于名称控件已经具有必填验证器，我们使用一个包含两个验证器的数组将`AlphaNumericValidator`作为第二个验证器添加到控件中。该数组可以用于向控件添加任意数量的验证器。
- en: 'The final step is to incorporate the appropriate validation message for the
    control into our template. Open `workout.component.html` and add the following
    label just below the label that displays the message for the required validator:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在我们的模板中将控件的适当验证消息合并到我们的模板中。打开`workout.component.html`并在显示所需验证器消息的标签下方添加以下标签：
- en: '[PRE96]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The exercise screen will now display a validation message if a non-alphanumeric
    value is entered in the name input box:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在名称输入框中输入了非字母数字值，练习屏幕现在将显示验证消息：
- en: '![](img/62930377-9559-4807-8c6f-b86049e996e2.png)'
  id: totrans-631
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62930377-9559-4807-8c6f-b86049e996e2.png)'
- en: As we hope you can see, reactive forms give us the ability to add custom validators
    to our forms in a straightforward manner that allows us to maintain the validation
    logic in our code and easily integrate it into our templates.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所希望的那样，响应式表单使我们能够以简单的方式向我们的表单添加自定义验证器，这样我们就可以在代码中维护验证逻辑，并将其轻松地集成到我们的模板中。
- en: You may have noticed that in this chapter, we have not covered how to use custom
    validators in template-driven forms. That is because implementing them requires
    the additional step of building a custom directive. We'll cover that in [Chapter
    4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml), *Angular Directives in Depth*.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在本章中，我们没有涵盖如何在模板驱动的表单中使用自定义验证器。因为实现它们需要额外的步骤，即构建一个自定义指令。我们将在[第四章](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml)中进行介绍，《深入理解
    Angular 指令》。
- en: Configuration options for running validation
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行验证的配置选项
- en: Before we move on from validation, there is one more topic to cover and that
    is configuration options for running the validations. So far, we have been using
    the default option, which runs validation checks on every input event. However,
    you have the choice of configuring them to run either on "blur"(that is when the
    user leaves an input control) or when the form is submitted. You can set this
    configuration at the form level or on a control-by-control basis.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从验证中离开之前，还有一个话题要覆盖，那就是运行验证的配置选项。到目前为止，我们一直使用默认选项，即在每次输入事件上运行验证检查。然而，你可以选择将它们配置为在“blur”（即用户离开输入控件时）或在表单提交时运行。你可以在表单级别或逐个控件的基础上进行配置。
- en: 'For example, we might decide that to avoid the complexity of handling missing
    exercises in the workout form, we will set that form to validate only upon submit.
    We can set this by adding the following highlighted assignment of `NgFormOptions`
    to the form tag:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能决定为避免在锻炼表单中处理缺少的锻炼的复杂性，我们将该表单设置为仅在提交时进行验证。我们可以通过向表单标签添加以下高亮显示的`NgFormOptions`来设置：
- en: '[PRE97]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This instructs Angular to run our validations only upon `submit`. Try it and
    you’ll see that no validations appear when you make entries into the form. Leave
    the form blank and press the Save button, and you will see the validation messages
    appear. Taking this approach, of course, means that there are no visual cues to
    the user regarding validation until they press the Save button.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示 Angular 仅在`submit`时进行验证。尝试一下，你会发现当你在表单中输入时，不会出现任何验证。留空表单并按保存按钮，你会看到验证信息出现。当然，采用这种方法意味着用户在按保存按钮之前不会收到关于验证的任何视觉提示。
- en: There are also a couple of other unintended side effects to using this approach
    in our form. The first is that the title no longer updates at the top of the screen
    as we type into the title input box. That value will only be updated when we press
    Save. Second, you will also see a validation message appear if you add one or
    more workouts and then remove all of them. This is because of the special conditions
    we set up for this control, which cause it to fire outside the normal validation
    flow.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的表单中使用这种方法的时候也会有一些意想不到的副作用。首先是，当我们在标题输入框中输入时，标题不会再在屏幕顶部更新。只有在按保存按钮时，该值才会更新。其次，如果你添加一个或多个锻炼然后移除所有的锻炼，你还会看到一个验证信息出现。这是因为我们为这个控件设置了特殊的条件，导致它在常规验证流程之外触发。
- en: 'So, maybe we should take a different approach. Angular provides the option
    of implementing more fine-grained control of the validation flow by allowing us
    to make such configurations at the control level using `ngModelOptions`. For example,
    let’s remove the `ngFormOptions` assignment from the form tag and modify the title
    input control to add `ngModelOptions` as follows:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，也许我们应该采取一种不同的方法。Angular 提供了一种更细粒度地控制验证流程的选项，即允许我们在控件级别上做这样的配置，使用`ngModelOptions`。例如，让我们从表单标签中移除`ngFormOptions`的赋值，并修改标题输入控件以添加`ngModelOptions`，如下所示：
- en: '[PRE98]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You’ll then notice that as you type the title into the input box, it does not
    update the title on the screen until you move off it (which triggers the `updateOn`
    event):'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在输入框里输入标题时，你会注意到直到你移开它（触发`updateOn`事件），标题才更新到屏幕上：
- en: '![](img/b8ffe1dc-c01d-4c0d-a100-d45672b67cfe.png)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8ffe1dc-c01d-4c0d-a100-d45672b67cfe.png)'
- en: As you will remember, the default option caused the title to update with every
    keystroke. This is a contrived example but it illustrates how the differences
    in these configurations work.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你记得的，将标题更新为每次按键都会造成默认选项。这是一个刻意的例子，但它说明了这些配置的差异如何工作。
- en: 'You probably don’t see the need to use the on blur setting here. But, in case
    where you may be doing validation by calling an external data store, this approach
    could be helpful in limiting the number of calls that are being made. And making
    such remote calls is exactly what we will be doing in [Chapter 4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml), *Angular
    Directives in Depth*, when we implement a custom directive. The directive will
    be checking for duplicate names that already exist in our remote data store. So,
    let’s remove this configuration from the title input control and place it instead
    on the name input control, like so:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能看不出在这里使用模糊设置的必要性。但是，在可能需要通过调用外部数据存储进行验证的情况下，这种方法可以帮助限制调用的次数。在我们实现自定义指令时，会进行这样的远程调用，这就是我们将在[第4章](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml)中所做的事情，*深入理解
    Angular 指令*。该指令将检查我们远程数据存储中已经存在的重复名称。因此，让我们将此配置从标题输入控件中移除，并放置在名称输入控件中，就像这样：
- en: '[PRE99]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We also can set the validation timing options within a reactive form. From
    what we have already learned about reactive forms, you will not be surprised to
    learn that we will be applying these settings in our code rather than the template.
    For example, to set them for a form group you use the following syntax:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在响应式表单中设置验证的时间选项。根据我们已经学到的关于响应式表单的知识，你可能不会感到惊讶，我们将在代码中应用这些设置而不是模板中。例如，要为表单组设置它们，使用以下语法：
- en: '[PRE100]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We can also apply them to individual form controls and that is what we will
    do in the case of our exercise form. Like the workout form, we will want to be
    able to validate the uniqueness of the name by making a remote call. So, we will
    want to limit the validation checking in a similar manner. We’ll do that by adding
    the following to the code that creates the name form control:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将它们应用到单个表单控件上，在我们的锻炼表单的情况下就是这样。与锻炼表单一样，我们希望能够通过远程调用验证名称的唯一性。因此，我们希望以类似的方式限制验证检查。我们将通过在创建名称表单控件的代码中添加以下内容来实现该目的：
- en: '[PRE101]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Note that we are putting the setting, along with the `validators` array, in
    the options object inside a pair of curly braces.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将设置和`validators`数组放在大括号对内的选项对象中。
- en: Summary
  id: totrans-652
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have a *Personal Trainer* app. The process of converting a specific *7
    Minute Workout* app to a generic *Personal Trainer* app helped us learn a number
    of new concepts. We started the chapter by defining the new app requirements.
    Then, we designed the model as a shared service.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个*个人教练*应用程序。将特定的*7分钟锻炼*应用程序转换为通用的*个人教练*应用程序的过程帮助我们学习了许多新概念。本章开始时，我们定义了新应用程序的需求。然后，我们将模型设计为共享服务。
- en: We defined some new views and corresponding routes for the *Personal Trainer*
    app. We also used both child and asynchronous routing to separate out *Workout
    Builder* from the rest of the app.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为*个人教练*应用程序定义了一些新视图和对应的路由。我们还使用了子路由和异步路由来将*锻炼构建器*从应用程序的其余部分分离出来。
- en: We then turned our focus to workout building. One of the primary technological
    focuses in this chapter was on Angular forms. The *Workout Builder* employed a
    number of form input elements and we implemented a number of common form scenarios
    using both template-driven and reactive forms. We also explored Angular validation
    in depth, and implemented a custom validator. We also covered configuring the
    timing options for running validation.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将注意力转到了锻炼建设上。本章的主要技术焦点之一是 Angular 表单。*锻炼构建器*使用了许多表单输入元素，并且我们使用了模板驱动和响应式表单实现了许多常见的表单场景。我们还深入探讨了
    Angular 验证，并实现了自定义验证器。我们还介绍了配置运行验证的时间选项。
- en: The next chapter is all about client-server interaction. The workouts and exercises
    that we create need to be persisted. In the next chapter, we build a persistence
    layer, which will allow us to save workout and exercise data on the server.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论客户端-服务器交互。我们创建的锻炼和练习需要被持久化。在下一章中，我们将构建一个持久化层，这将允许我们在服务器上保存锻炼和练习数据。
- en: Before we conclude this chapter, here is a friendly reminder. If you have not
    completed the exercise building routine for *Personal Trainer*, go ahead and do
    it. You can always compare your implementation with what has been provided in
    the companion code base. There are also things you can add to the original implementation,
    such as file uploads for the exercise image, and once you are more familiar with
    client-server interaction, a remote check to determine whether the YouTube videos
    actually exist.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，这里有一个友好的提醒。如果你还没有完成*个人教练*的练习建设例程，请继续。您可以随时将您的实施与伴侣代码库中提供的内容进行比较。您还可以在原始实施中添加一些内容，例如练习图像的文件上传，一旦您对客户端-服务器交互更加熟悉，还可以远程检查确定YouTube视频是否真的存在。
