- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Recipes – Reusability, Routing, and Caching
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配方 – 可重用性、路由和缓存
- en: In the next two chapters, we will complete the majority of the implementation
    of LemonMart and round out our coverage of the router-first approach. In this
    chapter, I will reinforce the idea of a decoupled component architecture through
    the creation of a reusable and routable component that also supports data binding.
    We use Angular directives to reduce boilerplate code and leverage classes, interfaces,
    enums, validators, and pipes to maximize code reuse with TypeScript and ES features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将完成 LemonMart 的主要实现，并完善我们对路由优先方法的覆盖。在本章中，我将通过创建一个可重用且可路由的组件，同时支持数据绑定，来强化解耦组件架构的概念。我们使用
    Angular 指令来减少样板代码，并利用类、接口、枚举、验证器和管道，通过 TypeScript 和 ES 特性最大化代码重用。
- en: In addition, we will create a multi-step form that architecturally scales well
    and supports a responsive design. Then, we will differentiate between user controls
    and components by introducing a lemon rater and a reusable form part that encapsulates
    the name object.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将创建一个在架构上可扩展且支持响应式设计的多步骤表单。然后，我们将通过引入柠檬评分器和封装名称对象的可重用表单部分来区分用户控件和组件。
- en: Make sure to have your **lemon-mart-server** up and running as you implement
    the recipes mentioned in this chapter. Refer to *Chapter 10*, *RESTful APIs and
    Full-Stack Implementation*, for more information.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在实现本章中提到的配方时，你的 **lemon-mart-server** 正在运行。有关更多信息，请参阅 *第 10 章*，*RESTful API
    和全栈实现*。
- en: This chapter covers a lot of ground. It is organized in recipe format, so you
    can quickly refer to a particular implementation when you are working on your
    projects. I will cover the architecture, design, and major components of the implementations.
    I will highlight important pieces of code to explain how the solution comes together.
    Leveraging what you've learned so far, I expect the reader to fill in routine
    implementation and configuration details. However, you can always refer to the GitHub
    project if you get stuck.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容丰富。它以配方格式组织，因此当你正在处理项目时，可以快速参考特定的实现。我将涵盖实现的结构、设计和主要组件。我将突出显示重要的代码片段，以解释解决方案是如何组合在一起的。利用你迄今为止所学到的知识，我期望读者能够填写常规实现和配置细节。然而，如果你遇到困难，始终可以参考
    GitHub 项目。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: HTTP PUT requests with caching service responses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存服务响应的 HTTP PUT 请求
- en: Multi-step responsive forms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多步骤响应式表单
- en: Reusing repeating template behavior with directives
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指令重用重复模板行为
- en: Scalable form architecture with reusable form parts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展的表单架构，具有可重用表单部分
- en: Input masking
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入掩码
- en: Custom controls with `ControlValueAccessor`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ControlValueAccessor` 的自定义控件
- en: Layouts using grid list
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网格列表布局
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked shortly. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking at the end-of-chapter snapshot of the code under the `projects` folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 样本代码的最新版本可在 GitHub 上找到，链接将在稍后提供。该存储库包含代码的最终和完成状态。你可以在本章末尾通过查看 `projects` 文件夹下的代码快照来验证你的进度。
- en: 'To get set up for this chapter, do the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备本章内容，请执行以下操作：
- en: Clone the repo at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆 [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
    上的存储库。
- en: Execute `npm install` on the root folder to install the dependencies.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行 `npm install` 以安装依赖项。
- en: 'The code sample for this chapter is available under the following subfolder:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章的代码示例位于以下子文件夹下：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run the Angular app for this chapter, execute the following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular 应用程序，请执行以下命令：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run Angular unit tests for this chapter, execute the following command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular 单元测试，请执行以下命令：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run Angular e2e tests for this chapter, execute the following command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular e2e 测试，请执行以下命令：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To build a production-ready Angular app for this chapter, execute the following
    command:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建本章的生产就绪 Angular 应用程序，请执行以下命令：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the `dist/ch11` folder at the root of the repository will contain
    the compiled result.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，存储库根目录下的 `dist/ch11` 文件夹将包含编译结果。
- en: Beware that the source code in the book or on GitHub may not always match the
    code generated by the Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time. Also on GitHub, expect
    to find corrections, fixes to support newer versions of libraries, or side-by-side
    implementations of multiple techniques for the reader to observe. The reader is
    only expected to implement the ideal solution recommended in the book. If you
    find errors or have questions, please create an issue or submit a pull request
    on GitHub for the benefit of all readers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，书中或GitHub上的源代码可能并不总是与Angular CLI生成的代码相匹配。由于生态系统不断演变，书中代码与GitHub上代码之间的实现也可能存在细微差异。随着时间的推移，示例代码发生变化是自然的。在GitHub上，您可能会找到更正、支持库新版本的修复或多种技术的并排实现，供读者观察。读者只需实现书中推荐的理想解决方案即可。如果您发现错误或有问题，请创建一个issue或提交一个pull
    request到GitHub，以惠及所有读者。
- en: You can read more about updating Angular in *Appendix C*, *Keeping Angular and
    Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    or at [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*附录C*，*保持Angular和工具常青*中了解更多关于更新Angular的信息。您可以从[https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)或[https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen)在线找到此附录。
- en: Let's start with implementing a user service to retrieve data, so we can build
    out a form to display and edit profile information. Later, we will refactor this
    form to abstract out its reusable parts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现一个用户服务来检索数据开始，这样我们就可以构建一个表单来显示和编辑个人资料信息。稍后，我们将重构此表单以抽象出其可重用部分。
- en: Implementing a user service with GET
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GET实现用户服务
- en: 'In order to implement a user profile, we need a service that can perform CRUD
    operations on `IUser`. We will be creating a user service that implements the
    following interface:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现用户个人资料，我们需要一个可以执行`IUser`上的CRUD操作的服务。我们将创建一个实现以下接口的用户服务：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before creating the service, make sure to start the **lemon-mart-server** and
    set your application's `AuthMode` to `CustomServer`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建服务之前，请确保启动**lemon-mart-server**并将应用程序的`AuthMode`设置为`CustomServer`。
- en: In this section, we will implement the `getUser` and `updateUser` functions.
    We will implement `getUsers` in *Chapter 12*, *Recipes – Master/Detail, Data Tables,
    and NgRx*, to support pagination with a data table.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现`getUser`和`updateUser`函数。我们将在*第12章*，*食谱 – 主/详细信息，数据表和NgRx*中实现`getUsers`，以支持数据表分页。
- en: 'Start by creating the user service:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建用户服务：
- en: Create a `UserService` under `src/app/user/user`
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/app/user/user`下创建一个`UserService`：
- en: Declare the `IUserService` interface from the preceding snippet, excluding the
    `getUsers` function.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的片段中声明`IUserService`接口，不包括`getUsers`函数。
- en: Extend the `UserService` class with `CacheService` and implement `IUserService`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CacheService`扩展`UserService`类并实现`IUserService`。
- en: 'Inject the `HttpClient` in the constructor as shown:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示在构造函数中注入`HttpClient`：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement the `getUser` function as shown:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示实现`getUser`函数：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We provide a `getUser` function that can load any user's profile information.
    Note that the security for this function is provided in the server implementation
    with the authenticate middleware. The requestor can either get their own profile
    or they'll need to be a manager. We use `getUser` with a resolve guard later in
    the chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个`getUser`函数，可以加载任何用户的个人资料信息。请注意，此函数的安全性由服务器实现中的认证中间件提供。请求者可以获取自己的个人资料，或者他们需要是管理员。我们将在本章后面使用`getUser`与解析守卫。
- en: Implementing PUT with caching
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现带有缓存的PUT
- en: 'Implement `updateUser`, which accepts an object that implements the `IUser`
    interface, so the data can be sent to a PUT endpoint:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`updateUser`，它接受一个实现了`IUser`接口的对象，因此数据可以发送到PUT端点：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note the use of the cache service with `setItem` to save user-entered data in
    case the `put` call fails. When the call succeeds, we remove the cached data using
    `removeItem`. Also note how we hydrate a user coming from the server as a `User`
    object with `map(User.Build)`, which calls the constructor of `class User`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用缓存服务中的 `setItem` 来保存用户输入的数据，以防 `put` 调用失败。当调用成功时，我们使用 `removeItem` 删除缓存数据。同时注意我们如何使用
    `map(User.Build)` 将来自服务器的用户作为 `User` 对象进行润滑，这调用 `class User` 的构造函数。
- en: Hydrate is a common term that refers to populating an object with data from
    a database or a network request. For example, the `User` JSON object we pass between
    components or receive from the server fits the `IUser` interface, but it is not
    of the `class User` type. We serialize objects to JSON using the `toJSON` method.
    When we hydrate and then instantiate a new object from JSON, we do the reverse
    and deserialize the data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: “Hydrate”是一个常用术语，指的是用数据库或网络请求中的数据填充一个对象。例如，我们在组件之间传递或从服务器接收的 `User` JSON 对象符合
    `IUser` 接口，但它不是 `class User` 类型。我们使用 `toJSON` 方法将对象序列化为 JSON。当我们从 JSON 润滑并实例化一个新对象时，我们执行相反的操作并反序列化数据。
- en: It is important to highlight that you should always stick to interfaces, and
    not concrete implementations like `User`, when passing data around. This is the
    **D** in **SOLID** – the Dependency Inversion Principle. Depending on concrete
    implementations creates a lot of risk, because they change a lot, whereas an abstraction
    such as `IUser` will seldom change. After all, you wouldn't solder a lamp directly
    to the electrical wiring in the wall. Instead, you would first solder the lamp
    to a plug and then use the plug to get the electricity you need.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，在传递数据时，你应该始终坚持使用接口，而不是像 `User` 这样的具体实现。这是 **SOLID** 原则中的 **D**（依赖倒置原则）。依赖于具体实现会带来很多风险，因为它们经常变化，而像
    `IUser` 这样的抽象很少会变化。毕竟，你不会直接将灯泡焊接在墙上的电线中。相反，你首先将灯泡焊接在插头上，然后使用插头获取所需的电力。
- en: With this code completed, `UserService` can now be used for basic CRUD operations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此代码后，`UserService` 现在可以用于基本的 CRUD 操作。
- en: Multi-step responsive forms
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多步骤响应式表单
- en: Overall forms are a different beast than the rest of your application and they
    require special architectural considerations. I don't recommend over-engineering
    your form solution with dynamic templates or route-enabled components. By definition,
    the different parts of a form are tightly coupled. From the perspectives of maintainability
    and ease of implementation, creating one giant component is a better strategy
    than using some of the aforementioned strategies and over-engineering.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，表单与你的应用程序的其他部分不同，它们需要特殊的架构考虑。我不建议过度设计你的表单解决方案，使用动态模板或启用路由的组件。从可维护性和易于实施的角度来看，创建一个巨大的组件比使用上述一些策略和过度设计更好。
- en: We will be implementing a multi-step input form to capture user profile information
    in a single component. I will be covering my recommended technique to split forms
    up into multiple components later in the chapter in the *Reusable form parts and
    scalability* section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个多步骤输入表单，在单个组件中捕获用户配置文件信息。我将在本章的“可重用表单部分和可扩展性”部分介绍我推荐的将表单拆分为多个组件的技术。
- en: Since the implementation of the form changes dramatically between this section
    and later in the chapter, you can find the code for the initial version on GitHub
    at `projects/ch11/src/app/user/profile/profile.initial.component.ts` and `projects/ch11/src/app/user/profile/profile.initial.component.html`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表单的实现在这部分和本章后面的内容中变化很大，你可以在 GitHub 上找到初始版本的代码，地址为 `projects/ch11/src/app/user/profile/profile.initial.component.ts`
    和 `projects/ch11/src/app/user/profile/profile.initial.component.html`。
- en: 'We will also make this multi-step form responsive for mobile devices using
    media queries:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用媒体查询使这个多步骤表单对移动设备响应：
- en: 'Let''s start by adding some helper data that will help us display an input
    form with options:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从添加一些辅助数据开始，这些数据将帮助我们显示带有选项的输入表单：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add new validation rules to `common/validations.ts`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将新的验证规则添加到 `common/validations.ts`:'
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, implement `profile.component.ts` as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，按照以下方式实现 `profile.component.ts`:'
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Upon load, we request the current user from `authService`, but this might take
    a while, so we first build an empty form with `this.buildForm()` as the first
    statement. We also store the user's ID in the `currentUserId` property, which
    we will need later when implementing the `save` functionality.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载时，我们从`authService`请求当前用户，但这可能需要一些时间，所以我们首先使用`this.buildForm()`作为第一条语句构建一个空表单。我们还将用户的ID存储在`currentUserId`属性中，稍后当我们实现`save`功能时将需要它。
- en: Note that we filter out users that are `null` or `undefined`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们过滤掉了`null`或`undefined`的用户。
- en: Later in this chapter, we will implement a resolve guard to load a user based
    on their `userId` provided on a route to increase the reusability of this component.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将实现一个解析守卫，根据路由上提供的`userId`加载用户，以提高该组件的可重用性。
- en: Form controls and form groups
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单控件和表单组
- en: As you may recall, `FormControl` objects are the most elemental parts of a form,
    usually representing a single input field. We can use `FormGroup` to group together
    a collection of related `FormControl` objects, such as the individual first, middle,
    and last parts of a person's name. `FormGroup` objects can also group together
    a mix of `FormControl`, `FormGroup`, and `FormArray` objects, the latter of which
    allows us to have dynamically repeating elements. `FormArray` is covered later
    in the chapter in the *Dynamic form arrays* section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所忆，`FormControl`对象是表单的最基本部分，通常代表单个输入字段。我们可以使用`FormGroup`将一组相关的`FormControl`对象组合在一起，例如一个人的名字的各个部分（首、中、姓）。`FormGroup`对象还可以将`FormControl`、`FormGroup`和`FormArray`对象组合在一起，后者允许我们拥有动态重复的元素。`FormArray`将在本章的“动态表单数组”部分进行介绍。
- en: Our form has many input fields, so we will use a `FormGroup` created by `this.formBuilder.group`
    to house our various `FormControl` objects. Additionally, children `FormGroup`
    objects will allow us to maintain the correct shape of the data structure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形式有很多输入字段，因此我们将使用由`this.formBuilder.group`创建的`FormGroup`来容纳我们的各种`FormControl`对象。此外，子`FormGroup`对象将允许我们保持数据结构的正确形状。
- en: Since the implementation of the form changes dramatically between this section
    and later in the chapter, you can find the code for the initial version on GitHub
    at `projects/ch11/src/app/user/profile/profile.initial.component.ts` and `projects/ch11/src/app/user/profile/profile.initial.component.html`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表单的实现在这部分和本章后面的部分之间发生了巨大变化，您可以在GitHub上找到初始版本的代码，位于`projects/ch11/src/app/user/profile/profile.initial.component.ts`和`projects/ch11/src/app/user/profile/profile.initial.component.html`。
- en: 'Start building the `buildForm` function, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 开始构建`buildForm`函数，如下所示：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`buildForm` optionally accepts an `IUser` to prefill the form, otherwise, all
    fields are set to their default values. The `formGroup` property itself is the
    top-level `FormGroup`. Various `FormControls` are added to it, such as `email`,
    with validators attached to them as needed. Note how `name` and `address` are
    their own `FormGroup` objects. This parent-child relationship ensures the proper
    structure of the form data, when serialized to JSON, which fits the structure
    of `IUser` in a manner that the rest of our application and server-side code can
    utilize.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildForm`函数可以接受一个`IUser`对象来预填充表单，否则所有字段都将设置为它们的默认值。`formGroup`属性本身是顶级`FormGroup`。根据需要，各种`FormControls`被添加到其中，例如`email`，并附加了相应的验证器。注意`name`和`address`是它们自己的`FormGroup`对象。这种父子关系确保了表单数据在序列化为JSON时的正确结构，这样我们的应用程序和服务器端代码就可以以`IUser`的结构来利用它。'
- en: You will be completing the implementation of the `formGroup` independently by
    following the sample code provided for the chapter. I will be going over sections
    of the code piece by piece over the next few sections to explain certain key capabilities.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您将通过遵循本章提供的示例代码独立完成`formGroup`的实现。我将在接下来的几个部分中逐段解释代码，以解释某些关键功能。
- en: Stepper and responsive layout
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步进器和响应式布局
- en: 'Angular Material''s stepper ships with the `MatStepperModule`. The stepper
    allows for form inputs to be broken up into multiple steps so that the user is
    not overwhelmed with processing dozens of input fields all at once. The user can
    still track their place in the process and, as a side effect, as the developer,
    we break up our `<form>` implementation and enforce validation rules on a step-by-step
    basis or create optional workflows where certain steps can be skipped or required.
    As with all Material user controls, the stepper has been designed with a responsive
    UX in mind. In the next few sections, we will implement three steps covering different
    form-input techniques in the process:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material 的步进器自带 `MatStepperModule`。步进器允许将表单输入分成多个步骤，这样用户就不会一次性处理数十个输入字段而感到不知所措。用户仍然可以跟踪他们在过程中的位置，作为副作用，作为开发者，我们可以将
    `<form>` 实现拆分，并逐步实施验证规则或创建可选的工作流程，其中某些步骤可以跳过或必填。与所有 Material 用户控件一样，步进器是考虑到响应式
    UX 而设计的。在接下来的几节中，我们将实现三个步骤，涵盖过程中的不同表单输入技术：
- en: Account information
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户信息
- en: Input validation
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入验证
- en: Responsive layout with media queries
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式布局与媒体查询
- en: Calculated properties
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性
- en: DatePicker
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期选择器
- en: Contact information
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系信息
- en: Typeahead support
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动完成支持
- en: Dynamic form arrays
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态表单数组
- en: Review
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复习
- en: Read-only views
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读视图
- en: Saving and clearing data
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和清除数据
- en: 'Let''s prep the `UserModule` for some new Material modules:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为一些新的材料模块准备 `UserModule`：
- en: As we start adding sub-Material modules, it makes sense to rename our root `material.module.ts`
    file to `app-material.modules.ts` in line with how `app-routing.module.ts` is
    named. Going forward, I will be using the latter convention.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始添加子材料模块，将我们的根 `material.module.ts` 文件重命名为 `app-material.modules.ts`，以符合
    `app-routing.module.ts` 的命名方式。从现在开始，我将使用后者的约定。
- en: Rename the `src/app/material.modules.ts` file to `app-material.module.ts`, and
    then rename the `MaterialModule` class to `AppMaterialModule`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `src/app/material.modules.ts` 文件重命名为 `app-material.module.ts`，然后将 `MaterialModule`
    类重命名为 `AppMaterialModule`。
- en: 'Create a `user-material.module.ts` file containing the following Material modules:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下材料模块的 `user-material.module.ts` 文件：
- en: '[PRE13]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Ensure `user.module.ts` correctly imports the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 `user.module.ts` 正确导入以下内容：
- en: The new `user-material.module`
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `user-material.module`
- en: The baseline `app-material.module`
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基线 `app-material.module`
- en: The required `ReactiveFormsModule` and `FlexLayoutModule`
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的 `ReactiveFormsModule` 和 `FlexLayoutModule`
- en: 'Implement a horizontal stepper with a form containing the first step:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个包含第一步的横向步进器表单：
- en: Since the implementation of the form changes dramatically between this section
    and later in the chapter, you can find the code for the initial version on GitHub
    at `projects/ch11/src/app/user/profile/profile.initial.component.ts` and `projects/ch11/src/app/user/profile/profile.initial.component.html`.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于本节和本章后面的表单实现变化很大，你可以在 GitHub 上的 `projects/ch11/src/app/user/profile/profile.initial.component.ts`
    和 `projects/ch11/src/app/user/profile/profile.initial.component.html` 找到初始版本的代码。
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, start implementing the `name` row of the `Account Information` step in
    place of the ellipses in the preceding step:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始实现 `Account Information` 步骤中的 `name` 行，以替换前一个步骤中的省略号：
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Take care to understand how the stepper and the form configuration work so far.
    You should see the first row render, pulling in data from **lemon-mart-server**:![](img/B14094_11_01.png)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意理解到目前为止步进器和表单配置是如何工作的。你应该能看到第一行渲染，从 **lemon-mart-server** 拉取数据：![](img/B14094_11_01.png)
- en: 'Figure 11.1: Multi-step form – Step 1'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.1：多步骤表单 – 第 1 步
- en: 'Note that adding `fxLayout.lt-sm="column"` to a row with `fxLayout="row"` enables
    a responsive layout of the form, as shown:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将 `fxLayout.lt-sm="column"` 添加到具有 `fxLayout="row"` 的行中，可以启用表单的响应式布局，如下所示：
- en: '![](img/B14094_11_02.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_11_02.png)'
- en: 'Figure 11.2: Multi-step form on mobile'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：移动端的多步骤表单
- en: Before we move on to how to implement the **Date of Birth** ﬁeld, let's reevaluate
    our strategy by implementing error messages.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续介绍如何实现 **出生日期** 字段之前，让我们通过实现错误消息来重新评估我们的策略。
- en: Reusing repeating template behavior with directives
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指令重用重复模板行为
- en: In the previous section, we implemented a `mat-error` element for every validation
    error for every field part of the `name` object. This quickly adds up to seven
    elements for three fields. In *Chapter 8*, *Designing Authentication and Authorization*,
    we implemented `common/validations.ts` to reuse validation rules. We can reuse
    the behavior we implement within `mat-error`, or any other `div` for that matter,
    using an attribute directive.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们为 `name` 对象的每个字段部分的每个验证错误实现了一个 `mat-error` 元素。对于三个字段，这会迅速增加到七个元素。在 *第八章*，*设计身份验证和授权*
    中，我们实现了 `common/validations.ts` 以重用验证规则。我们可以使用属性指令重用我们在 `mat-error` 中实现的行为，或者任何其他
    `div`，使用属性指令。
- en: Attribute directives
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性指令
- en: In *Chapter 1*, *Introduction to Angular and Its Concepts*, I mentioned that
    Angular components represent the most basic unit of an Angular app. With components,
    we define our own HTML elements that can reuse features and functionality represented
    by a template and some TypeScript code. On the other hand, a directive augments
    the capabilities of an existing element or component. In a sense, a component
    is a super directive that augments basic HTML capabilities.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第一章*，*Angular及其概念简介* 中，我提到 Angular 组件代表 Angular 应用程序的最基本单元。通过组件，我们定义自己的 HTML
    元素，这些元素可以重用模板和一些 TypeScript 代码所表示的功能和特性。另一方面，指令增强了现有元素或组件的功能。在某种程度上，组件是一个超级指令，它增强了基本的
    HTML 功能。
- en: 'With this view in mind, we can define three kinds of directives:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个视图，我们可以定义三种类型的指令：
- en: Components
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: Structural directives
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构指令
- en: Attribute directives
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性指令
- en: Basically, components are directives with templates, and this is the most common
    type of directive you will use. Structural directives modify the DOM by adding
    or removing elements, `*ngIf` and `*ngFor` being the canonical examples. Finally,
    attribute directives allow you to define new attributes that you can add to HTML
    elements or components to add new behavior to them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，组件是带有模板的指令，这是你将最常使用的指令类型。结构指令通过添加或删除元素来修改 DOM，`*ngIf` 和 `*ngFor` 是典型的例子。最后，属性指令允许你定义可以添加到
    HTML 元素或组件的新属性，以向它们添加新行为。
- en: Let's implement an attribute directive that can encapsulate field-level error
    behavior.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个可以封装字段级错误行为的属性指令。
- en: Field error attribute directive
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段错误属性指令
- en: 'Imagine how we could use a directive to reduce repetitive elements to display
    field errors. Consider the following example using the first name field as an
    example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们如何使用指令来减少重复元素以显示字段错误。以下是一个使用姓名字段作为示例的例子：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have the standard layout structure for a material form field, but there''s
    only a single `mat-error` element. There are three new properties on `mat-error`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个标准布局结构用于材料表单字段，但只有一个 `mat-error` 元素。`mat-error` 上有三个新属性：
- en: '`input` binds to the HTML input element that was tagged with `#name` using
    a template reference variable, so that we can tap into the blur event of the input
    element and be able to read the `placeholder`, `aria-label`, and `formControlName`
    properties.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input` 通过模板引用变量绑定到标记为 `#name` 的 HTML 输入元素，这样我们就可以访问输入元素的模糊事件，并能够读取 `placeholder`、`aria-label`
    和 `formControlName` 属性。'
- en: '`group` binds to the parent form group object that contains the form control,
    so using the `formControlName` property from input, we can retrieve the `formControl`
    object, while avoiding extra code.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group` 绑定到包含表单控件的父表单组对象，因此我们可以使用输入的 `formControlName` 属性来检索 `formControl`
    对象，同时避免额外的代码。'
- en: '`appFieldError` binds to an array of validation errors that need to be checked
    against the `formControl` object, such as `required`, `minlength`, `maxlength`,
    and `invalid`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appFieldError` 绑定到一个数组，该数组包含需要与 `formControl` 对象进行校验的验证错误，例如 `required`、`minlength`、`maxlength`
    和 `invalid`。'
- en: Using the preceding information, we can craft a directive that can render one
    or more lines of error messages inside the `mat-error` element, effectively replicating
    the verbose method we used in the previous section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的信息，我们可以创建一个指令，可以在 `mat-error` 元素内渲染一行或多行错误消息，有效地复制我们在上一节中使用的冗长方法。
- en: 'Let''s go ahead and create an attribute directive named `FieldErrorDirective`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个名为 `FieldErrorDirective` 的属性指令：
- en: Create `FieldErrorDirective` under `src/app/user-controls`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/app/user-controls` 下创建 `FieldErrorDirective`。
- en: 'Define the directive''s selector as a bindable attribute named `appFieldError`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将指令的选择器定义为名为 `appFieldError` 的可绑定属性：
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Outside of the directive, define a new type named `ValidationError`, which
    defines the kinds of error conditions we will deal with:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指令外部，定义一个新的类型名为`ValidationError`，它定义了我们将要处理的错误条件类型：
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similar to the way we grouped validations, let''s define two sets of commonly
    occurring error conditions, so we don''t have to type them out over and over again:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似于我们分组验证的方式，让我们定义两组常见的错误条件，这样我们就不必反复输入它们：
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, let''s define the `@Input` targets for the directive:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义指令的`@Input`目标：
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that we already went over the purpose of the top three attributes. `fieldControl`
    and `fieldLabel` are optional attributes. If `input` and `group` are specified,
    the optional attributes can be auto-populated. Since they are class-wide variables,
    it made sense to expose them, in case the user wants to override the default behavior
    of the directive. This is an easy win for creating flexible and reusable controls.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们已经讨论了前三个属性的目的。`fieldControl`和`fieldLabel`是可选属性。如果指定了`input`和`group`，可选属性可以自动填充。由于它们是类级别的变量，因此公开它们是有意义的，以防用户想要覆盖指令的默认行为。这有助于创建灵活且可重用的控件。
- en: 'Import the element reference in the `constructor`, which can be later used
    by a `renderErrors` function display error in the inner HTML of the `mat-error`
    element:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中导入元素引用，这可以在稍后由`renderErrors`函数用于在`mat-error`元素的内部HTML中显示错误：
- en: '[PRE21]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement a function that can return canned error messages depending on the
    error type:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个函数，该函数可以根据错误类型返回预定义的错误信息：
- en: '[PRE22]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we can extract the required `minlength` or `maxlength` amount dynamically
    from the `fieldControl`, greatly reducing the number of custom messages we need
    to generate.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们可以从`fieldControl`动态提取所需的`minlength`或`maxlength`值，这大大减少了我们需要生成的自定义消息的数量。
- en: 'Implement the algorithm that can loop through all the elements in `appFieldError`
    and the errors that need to be displayed in an array using the `getStandardErrorMessage`
    method:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个算法，该算法可以使用`getStandardErrorMessage`方法遍历`appFieldError`中的所有元素以及需要显示在数组中的错误：
- en: '[PRE23]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At the end, we can display the error messages using the `renderErrors` method.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`renderErrors`方法来显示错误信息。
- en: Note the use of function delegates. Since this piece of code will execute hundreds
    of times a minute, it is important to avoid unnecessary invocations. Function
    delegates help organize our code better, while deferring the execution of their
    logic unless absolutely necessary.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意函数委托的使用。由于这段代码可能每分钟执行数百次，因此避免不必要的调用非常重要。函数委托有助于更好地组织我们的代码，同时将它们的逻辑执行推迟到绝对必要时。
- en: 'Now, initialize the `fieldControl` property, which represents a `formControl`.
    We will listen to the `valueChanges` events of the control and, if the validation
    status is invalid, then we execute our custom `updateErrorMessage` logic to display
    error messages:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，初始化`fieldControl`属性，它代表一个`formControl`。我们将监听控制的`valueChanges`事件，如果验证状态无效，则执行我们的自定义`updateErrorMessage`逻辑来显示错误信息：
- en: '[PRE24]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that, since we're subscribing to `valueChanges`, we must also unsubscribe.
    We unsubscribe once with `ngOnDestroy` and again right before subscribing. This
    is because `initFieldControl` may be called multiple times. If we don't clear
    the prior subscription, it will result in a memory leak and related performance
    issues.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，由于我们正在订阅`valueChanges`，我们必须取消订阅。我们使用`ngOnDestroy`取消订阅一次，然后在订阅之前再次取消订阅。这是因为`initFieldControl`可能被多次调用。如果我们不清除之前的订阅，将导致内存泄漏和相关性能问题。
- en: Additionally, if we can't bind to a `fieldControl`, we throw an error message,
    since this usually points to a coding error.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，如果我们无法绑定到`fieldControl`，我们将抛出一个错误信息，因为这通常表明编码错误。
- en: 'Finally, we configure all major attributes with the `ngOnChanges` event, which
    triggers any time an `@Input` attribute is updated. This ensures that in the case
    where form elements could be dynamically added or removed, we will always consider
    the newest values. We call `initFieldControl` to start listening to value changes,
    we implement an `onblur` event handler that triggers `updateErrorMessage()` for
    the HTML input element, and we assign the value of `fieldLabel`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`ngOnChanges`事件配置所有主要属性，该事件在更新任何`@Input`属性时触发。这确保了在表单元素可能动态添加或删除的情况下，我们始终考虑最新的值。我们调用`initFieldControl`以开始监听值变化，实现一个`onblur`事件处理器，该处理器触发`updateErrorMessage()`为HTML输入元素，并分配`fieldLabel`的值：
- en: '[PRE25]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that if we can't bind to an HTML `input` element, this usually means that
    the developer simply forgot to wire things up correctly. In this case, we throw
    a new `Error` object, which generates a helpful stack trace in the console, so
    you can pinpoint the location in the template where the error is happening.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果我们无法绑定到HTML `input`元素，这通常意味着开发者忘记正确连接这些元素。在这种情况下，我们抛出一个新的`Error`对象，这在控制台中生成一个有用的堆栈跟踪，以便你可以确定模板中错误发生的位置。
- en: 'This wraps up the implementation of the directive. Now, we need to package
    the directive in a module named `field-error.module.ts`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了指令的实现。现在，我们需要将指令打包到一个名为`field-error.module.ts`的模块中：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now go ahead and use the directive in our existing forms:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续在我们的现有表单中使用这个指令：
- en: Import the module in `app.module.ts` and `user.module.ts`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.module.ts`和`user.module.ts`中导入模块。
- en: Update `profile.component.html` with the new directive.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新指令更新`profile.component.html`。
- en: Update `login.component.html` with the new directive.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新指令更新`login.component.html`。
- en: Be sure to define `ErrorSets` as a public property variable in the `component`
    class so that you can use it in the template.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`component`类中将`ErrorSets`定义为公共属性变量，以便你可以在模板中使用它。
- en: Test your forms to ensure that our validation messages are being displayed as
    expected and that there are no console errors.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的表单以确保我们的验证消息按预期显示，并且没有控制台错误。
- en: Congratulations! You've learned how you can inject new behavior into other elements
    and components using directives. By doing this, we are able to avoid a lot of
    repeated code and standardize error messages across our app.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经学会了如何使用指令将新行为注入其他元素和组件。通过这样做，我们能够避免大量的重复代码，并在我们的应用程序中标准化错误消息。
- en: Before moving on, finish implementation of the form by looking at the implementation
    on GitHub. You can find the code for the form template at `projects/ch11/src/app/user/profile/profile.initial.component.html`
    and the `component` class at `projects/ch11/src/app/user/profile/profile.initial.component.ts`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，通过查看GitHub上的实现来完成表单的实现。你可以在`projects/ch11/src/app/user/profile/profile.initial.component.html`找到表单模板的代码，在`projects/ch11/src/app/user/profile/profile.initial.component.ts`找到`component`类。
- en: Do not include the `app-lemon-rater` and `app-view-user` elements, and remove
    the `mask` attribute from the phone number, which we will implement later in the
    chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 不要包含`app-lemon-rater`和`app-view-user`元素，并从电话号码中移除`mask`属性，我们将在本章后面实现它。
- en: 'Here, you can see the User Profile as it will appear on LemonMart:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到用户资料在LemonMart上的显示方式：
- en: '![](img/B14094_11_03.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_11_03.png)'
- en: 'Figure 11.3: Profile component in a mostly completed state'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：基本完成的配置文件组件
- en: Next, let's continue going over the `profile` component and see how the **Date
    of Birth** ﬁeld works.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续查看`profile`组件，看看**出生日期**字段是如何工作的。
- en: Calculated properties and DatePicker
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算属性和DatePicker
- en: 'We can display calculated properties based on user input. For example, to display
    a person''s age based on their date of birth, introduce class properties that
    calculate the age and display it as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据用户输入显示基于计算属性的值。例如，为了显示一个人的年龄，基于他们的出生日期，引入计算年龄的类属性，并如下显示它：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To validate a date within the last hundred years, implement a `minDate` class
    property:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证过去一百年内的日期，实现一个`minDate`类属性：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The usage of the calculated properties in the template looks like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中计算属性的使用如下所示：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Refer to the highlighted `[min]` and `[max]` attributes in the preceding snippet
    for the application of the hundred-year date range.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面片段中突出显示的`[min]`和`[max]`属性，了解一百年日期范围的适用。
- en: 'The `DatePicker` in action looks as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatePicker`的实际效果如下所示：'
- en: '![](img/B14094_11_04.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_11_04.png)'
- en: 'Figure 11.4: Selecting a date with DatePicker'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：使用DatePicker选择日期
- en: 'Note that dates beyond April 26, 2020 are grayed out. After the date is selected,
    the calculated age is displayed as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，2020年4月26日之后的日期将以灰色显示。选择日期后，计算出的年龄将如下显示：
- en: '![](img/B14094_11_05.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_11_05.png)'
- en: 'Figure 11.5: Calculated age property'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：计算年龄属性
- en: Now, let's move on to the next step, **Contact Information**, and see how we
    can enable a convenient way to display and input the state portion of the address
    field.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行下一步，**联系信息**，看看我们如何能够方便地显示和输入地址字段的状态部分。
- en: Typeahead support
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动完成支持
- en: 'In `buildForm`, we set a listener on `address.state` to support a typeahead
    filtering drop-down experience:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `buildForm` 中，我们监听 `address.state` 以支持类型提示过滤下拉菜单体验：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'On the template, implement `mat-autocomplete`, bound to the filtered states
    array with an `async` pipe:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板上实现 `mat-autocomplete`，绑定到过滤后的状态数组，并使用 `async` 管道：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s how it looks when a user enters the `V` character:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入 `V` 字符时，它看起来是这样的：
- en: '![](img/B14094_11_06.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_11_06.png)'
- en: 'Figure 11.6: Dropdown with typeahead support'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6：带有自动完成支持的下拉菜单
- en: In the next section, let's enable the input of multiple phone numbers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们启用多个电话号码的输入。
- en: Dynamic form arrays
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态表单数组
- en: 'Note that `phones` is an array, potentially allowing for many inputs. We can
    implement this by building a `FormArray` with the `this.formBuilder.array` function.
    We also define several helper functions to make it easier to build the `FormArray`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`phones` 是一个数组，可能允许许多输入。我们可以通过使用 `this.formBuilder.array` 函数构建 `FormArray`
    来实现这一点。我们还定义了几个辅助函数，以使构建 `FormArray` 更容易：
- en: '`buildPhoneFormControl` helps to build `FormGroup` objects of individual entries.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildPhoneFormControl` 有助于构建单个条目的 `FormGroup` 对象。'
- en: '`buildPhoneArray` creates as many `FormGroup` objects as needed or, if the
    form is empty, it creates an empty entry.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildPhoneArray` 根据需要创建尽可能多的 `FormGroup` 对象，或者如果表单为空，则创建一个空条目。'
- en: '`addPhone` adds a new empty `FromGroup` object to the `FormArray`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addPhone` 向 `FormArray` 添加一个新的空 `FormGroup` 对象。'
- en: '`get phonesArray()` is a convenient property to get the `phones` control from
    the form.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get phonesArray()` 是一个方便的属性，可以从表单中获取 `phones` 控件。'
- en: 'Let''s see how the implementation comes together:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现是如何结合在一起的：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`buildPhoneArray` supports initialization of a form with a single phone input
    or filling it with the existing data, working in tandem with `buildPhoneFormControl`.
    The latter function comes in handy when a user clicks on an **Add** button to
    create a new row for the entry:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildPhoneArray` 支持使用单个电话输入初始化表单或用现有数据填充它，与 `buildPhoneFormControl` 一起工作。当用户点击
    **添加** 按钮创建新行时，后者非常有用：'
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `phonesArray` property getter is a common pattern to make it easier to
    access certain form properties. However, in this case, it is also necessary because
    `get(''phones'')` must be typecast to `FormArray` so that we can access the `length`
    property on it on the template:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`phonesArray` 属性获取器是一个常见的模式，可以使访问某些表单属性更容易。然而，在这种情况下，这也是必要的，因为 `get(''phones'')`
    必须转换为 `FormArray`，这样我们就可以在模板上访问其 `length` 属性：'
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note the highlighted `convertTypeToPhoneType` function, which converts a `string`
    to `enum PhoneType`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意突出显示的 `convertTypeToPhoneType` 函数，它将 `string` 转换为 `enum PhoneType`。
- en: Also highlighted in the preceding code block, note how the `remove` function
    is implemented inline in the template, making it easier to read and maintain.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，也突出显示了 `remove` 函数是如何在模板中内联实现的，这使得它更容易阅读和维护。
- en: 'Let''s see how the dynamic array should be working:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看动态数组应该如何工作：
- en: '![](img/B14094_11_07.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_11_07.png)'
- en: 'Figure 11.7: Multiple inputs using FormArray'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7：使用 FormArray 的多个输入
- en: Now that we're done with inputting data, we can move on to the last step of
    the stepper, **Review**. However, as was mentioned earlier, the **Review** step
    uses the `<app-view-user>` directive to display its data. Let's build that view
    first.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了数据输入，我们可以继续到步骤器的最后一步，**审查**。然而，如前所述，**审查**步骤使用 `<app-view-user>` 指令来显示其数据。让我们首先构建这个视图。
- en: Creating shared components
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建共享组件
- en: Here's a minimal implementation of the `<app-view-user>` directive that is a
    prerequisite for the **Review** step.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `<app-view-user>` 指令的最小实现，它是 **审查** 步骤的先决条件。
- en: 'Create a new `viewUser` component under the `user` module, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `user` 模块下创建一个新的 `viewUser` 组件，如下所示：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding component uses input binding with `@Input` to get user data, compliant
    with the `IUser` interface, from an outside component. We implement the `ngOnChanges`
    event, which fires whenever the bound data changes. In this event, we hydrate
    the simple JSON object stored in the `user` property as an instance of the `User`
    class with `User.Build`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的组件使用 `@Input` 输入绑定从外部组件获取用户数据，符合 `IUser` 接口。我们实现了 `ngOnChanges` 事件，该事件在绑定数据更改时触发。在这个事件中，我们使用
    `User.Build` 将存储在 `user` 属性中的简单 JSON 对象作为 `User` 类的实例进行填充。
- en: We then define a read-only `BehaviorSubject`, named `this.currentUser$`, so
    we can asynchronously push updates to it using the next function. This flexibility
    will come in handy when we later make this component reusable in multiple contexts.
    Even if we wanted to, we couldn't directly bind to `user`, because calculated
    properties such as `fullName` will only work if the data is hydrated into an instance
    of the `User` class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个只读的`BehaviorSubject`，命名为`this.currentUser$`，这样我们就可以使用下一个函数异步地将其更新。这种灵活性将在我们稍后使该组件在多个上下文中可重用时派上用场。即使我们想这样做，我们也不能直接绑定到`user`，因为像`fullName`这样的计算属性只有在数据被注入到`User`类的实例中时才会工作。
- en: Now, we are ready to complete the multi-step form.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好完成多步骤表单。
- en: Reviewing and saving form data
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看并保存表单数据
- en: 'On the last step of the multistep form, users should be able to review and
    then save the form data. As a good practice, a successful `POST` request will
    return the data that was saved back to the browser. We can then reload the form
    with the information received back from the server:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在多步骤表单的最后一步，用户应该能够查看并保存表单数据。作为一个好的实践，成功的`POST`请求将返回保存的数据回浏览器。然后我们可以用从服务器返回的信息重新加载表单：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that `updateUser` returns the saved value of the user. It is possible that
    the database returns a different version of `user` than what we had before, so
    we use `formGroup.patchValue` to update the data powering the form. The form automatically
    updates to reflect any changes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`updateUser`返回用户的保存值。数据库可能返回与之前不同的`user`版本，因此我们使用`formGroup.patchValue`来更新支撑表单的数据。表单会自动更新以反映任何更改。
- en: 'If there are errors when saving the data, they''ll be set to `userError` to
    be displayed on the form. And before saving the data, we present it in a compact
    format with the reusable `app-view-user` component that we can bind the form data
    to:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在保存数据时出现错误，它们将被设置为`userError`以在表单上显示。在保存数据之前，我们以紧凑的格式展示数据，使用可重用的`app-view-user`组件，我们可以将其绑定到表单数据：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that we use `formGroup.getRawValue()` to extract the JSON of the form data.
    See how we bind `userError` to display error messages. Also, the **Reset** button
    uses `stepper.reset()`, which can conveniently reset all the user input.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`formGroup.getRawValue()`来提取表单数据的JSON。看看我们是如何将`userError`绑定以显示错误消息的。此外，**重置**按钮使用`stepper.reset()`，它可以方便地重置所有用户输入。
- en: 'This is how the final product should appear:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最终产品应该看起来是这样的：
- en: '![](img/B14094_11_08.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_11_08.png)'
- en: 'Figure 11.8: Review step'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：查看步骤
- en: Now that the user profile input is done, we are about halfway to our eventual
    goal of creating a master/detail view where a **Manager** can click on a user
    and view their profile details. We still have a lot more code to add, and along
    the way, we have fallen into a pattern of adding lots of boilerplate code to load
    the requisite data for a component.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户配置文件输入已完成，我们离最终目标——创建一个主/详细视图还有一半的路要走，在这个视图中，**经理**可以点击用户并查看他们的配置文件详情。我们还有更多的代码要添加，并且在过程中，我们陷入了添加大量样板代码来加载组件所需数据的模式。
- en: Next, let's refactor our form to make our code reusable and scalable, so even
    if our form has dozens of fields, the code is still maintainable and we don't
    introduce an exponential cost increase to make changes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们重构我们的表单，使其代码可重用和可扩展，即使我们的表单有数十个字段，代码仍然是可维护的，我们不会引入指数级成本增加来做出更改。
- en: Scaling architecture with reusable form parts
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可重用表单部分扩展架构
- en: As mentioned in the introduction to the *Multi-step responsive forms* section,
    forms are tightly coupled beasts that can grow large, and using the wrong architectural
    pattern to scale your implementation can cause significant issues when implementing
    new features or maintaining existing ones.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*多步骤响应式表单*部分的介绍中提到的，表单是紧密耦合的怪物，可能会变得很大，使用错误的架构模式来扩展你的实现可能会在实现新功能或维护现有功能时引起重大问题。
- en: 'To demonstrate how you can break up your form into multiple parts, we will
    refactor the form to extract the highlighted section in the following screenshot,
    the name form group, as its own component. The technique to accomplish this is
    the same as you''d use when you want to put each step of your form into a separate
    component:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示你如何将表单拆分成多个部分，我们将重构表单，提取以下截图中的突出显示部分，即名字表单组，作为一个单独的组件。完成这一点的技术与你想要将表单的每个步骤放入单独组件时使用的技术相同：
- en: '![](img/B14094_11_09.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_11_09.png)'
- en: 'Figure 11.9: User profile''s name part highlighted'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：用户配置文件的名字部分被突出显示
- en: By making the name form group reusable, you will also learn about how you can
    reuse the business logic that you build into that form group in other forms. We
    will extract the name form group logic into a new component named `NameInputComponent`.
    In doing so, we also have an opportunity to extract some reusable form functionality
    to a `BaseFormComponent` as an `abstract class`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使名称表单组可重用，你还将了解如何将你构建到该表单组中的业务逻辑在其他表单中重用。我们将名称表单组逻辑提取到一个名为 `NameInputComponent`
    的新组件中。在这个过程中，我们也有机会将一些可重用表单功能提取到 `BaseFormComponent` 作为 `抽象类`。
- en: There are going to be several components that are working together here, including
    `ProfileComponent`, `ViewUserComponent`, and `NameInputComponent`. We need all
    the values in these three components to be up to date as the user enters them.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将会有几个组件协同工作，包括 `ProfileComponent`、`ViewUserComponent` 和 `NameInputComponent`。我们需要这三个组件中的所有值在用户输入时都保持最新。
- en: '`ProfileComponent` will own the master form to which we''ll need to register
    any child form. Once we do this, all the form validation techniques you''ve learned
    so far will still apply.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProfileComponent` 将拥有主表单，我们需要在其中注册任何子表单。一旦我们这样做，你之前学到的所有表单验证技术仍然适用。'
- en: 'This is a key way to make your form able to scale across many components and
    continue to be easy to work with, without introducing unnecessary validation overhead.
    Hence, it is useful to review the different interactions between these objects
    to solidify your understanding of the asynchronous and decoupled nature of their
    behavior:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是让你的表单能够在许多组件之间扩展并继续易于使用的关键方式，同时不会引入不必要的验证开销。因此，回顾这些对象之间的不同交互，有助于巩固你对它们异步和解耦行为性质的理解：
- en: '![](img/B14094_11_10.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_11_10.png)'
- en: 'Figure 11.10: Form component interactions'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10：表单组件交互
- en: In this section, we bring together a lot of the different concepts that you've
    learned over the course of the book. Utilize the preceding diagram to understand
    how the various form components interact with each other.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将汇集你在本书学习过程中学到的许多不同概念。利用前面的图来理解各种表单组件如何相互交互。
- en: In the preceding diagram, properties in bold indicate data binding. Underlined
    function elements indicate event registrations. Arrows show the points of connection
    between the components.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，粗体属性表示数据绑定。下划线函数元素表示事件注册。箭头显示了组件之间的连接点。
- en: The workflow begins with the instantiation of `ProfileComponent`. The `OnInit`
    event of the component begins building the `formGroup` object, while asynchronously
    loading any potential `initialData` that may need to be patched into the forms.
    Refer to the preceding diagram for a visual representation of `initialData` coming
    in from a service or cache.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程从 `ProfileComponent` 的实例化开始。组件的 `OnInit` 事件开始构建 `formGroup` 对象，同时异步加载可能需要修补到表单中的任何潜在
    `initialData`。请参考前面的图来查看 `initialData` 从服务或缓存中到达的视觉表示。
- en: '`NameInputComponent` is used in the `ProfileComponent` form as `<app-name-input>`.
    In order to synchronize `initialData` with the `NameInputComponent`, we bind a
    `nameInitialData$` subject using the `async` pipe, since `initialData` is coming
    in asynchronously.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`NameInputComponent` 在 `ProfileComponent` 表单中以 `<app-name-input>` 的形式使用。为了使
    `initialData` 与 `NameInputComponent` 同步，我们使用 `async` 管道绑定一个 `nameInitialData$`
    主题，因为 `initialData` 是异步到达的。'
- en: '`NameInputComponent` implements the `OnChanges` life cycle hook, so whenever
    `nameInitialData$` updates, its value is patched into the `NameInputComponent`
    form.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`NameInputComponent` 实现了 `OnChanges` 生命周期钩子，因此每当 `nameInitialData$` 更新时，其值就会被修补到
    `NameInputComponent` 表单中。'
- en: Like `ProfileComponent`, `NameInputComponent` also implements the `OnInit` event
    to construct its `formGroup` object. Since this is an asynchronous event, `NameInputComponent`
    needs to expose a `formReady` event that `ProfileComponent` can subscribe to.
    Once the `formGroup` object is ready, we emit the event, and the `registerForm`
    function on `ProfileComponent` triggers. `registerForm` adds the `formGroup` object
    of `NameInputComponent` as a child element to the parent `formGroup` on `ProfileComponent`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ProfileComponent` 类似，`NameInputComponent` 也实现了 `OnInit` 事件来构建其 `formGroup`
    对象。由于这是一个异步事件，`NameInputComponent` 需要公开一个 `formReady` 事件，`ProfileComponent` 可以订阅它。一旦
    `formGroup` 对象就绪，我们发出事件，`ProfileComponent` 上的 `registerForm` 函数被触发。`registerForm`
    将 `NameInputComponent` 的 `formGroup` 对象作为子元素添加到父 `formGroup` 上。
- en: '`ViewUserComponent` is used in the `ProfileComponent` form as `<app-view-user>`.
    When the values in the parent form change, we need `<app-view-user>` to stay up
    to date. We bind to the `user` property on `ViewUserComponent`, which implements
    `OnChanges` to receive updates. Every time there is an update, the `User` object
    is hydrated from the `IUser` object, so that calculated fields such as `fullName`
    can continue to work. The updated `User` is pushed to `currentUser$`, which is
    bound to the template with an `async`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewUserComponent` 在 `ProfileComponent` 表单中用作 `<app-view-user>`。当父表单中的值发生变化时，我们需要
    `<app-view-user>` 保持最新状态。我们绑定到 `ViewUserComponent` 上的 `user` 属性，该属性实现了 `OnChanges`
    以接收更新。每次更新时，`User` 对象都会从 `IUser` 对象中恢复，以便计算字段如 `fullName` 可以继续工作。更新的 `User` 被推送到
    `currentUser$`，该对象通过 `async` 绑定到模板。'
- en: We will begin by building a `BaseFormComponent`, which `NameInputComponent`
    and `ProfileComponent` will then implement.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建一个 `BaseFormComponent`，然后 `NameInputComponent` 和 `ProfileComponent` 将实现它。
- en: Base form component as an abstract class
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础表单组件作为一个抽象类
- en: We can share common functionality and standardize the implementation of all
    components that implement a form by implementing a base abstract class. An abstract
    class cannot be instantiated on its own because it wouldn't make sense to do so,
    since it will not have a template, making it useless on its own.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现一个基抽象类，我们可以共享通用功能并标准化实现所有实现表单的组件。抽象类不能单独实例化，因为它本身没有模板，单独使用是没有意义的。
- en: Note that `BaseFormComponent` is just a `class` and not an Angular component.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`BaseFormComponent` 只是一个 `class`，而不是 Angular 组件。
- en: '`BaseFormComponent` will standardize the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseFormComponent` 将标准化以下内容：'
- en: '`@Input initialData`, and disable as binding targets'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Input initialData`，并禁用为绑定目标'
- en: The `@Output formReady` event
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Output formReady` 事件'
- en: '`formGroup`, the `FormGroup` to be used in the template''s `buildForm` function
    to build the `formGroup`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`formGroup`，在模板的 `buildForm` 函数中使用的 `FormGroup` 以构建 `formGroup`'
- en: 'With the preceding assumptions, the base class can provide some generic functionality:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的假设下，基类可以提供一些通用功能：
- en: '`patchUpdatedData`, which can update the data (partially or fully) in the `formGroup`
    without having to rebuild it.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patchUpdatedData`，可以在不重建的情况下更新 `formGroup` 中的数据（部分或全部）。'
- en: '`registerForm` and `deregisterForm` can register or deregister child forms.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerForm` 和 `deregisterForm` 可以注册或注销子表单。'
- en: '`deregisterAllForms` can automatically deregister any registered child form.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deregisterAllForms` 可以自动注销任何已注册的子表单。'
- en: '`hasChanged` can determine whether `initialData` has changed given a `SimpleChange`
    object provided by the `ngOnChange` event handler.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasChanged` 可以确定在 `ngOnChange` 事件处理器提供的 `SimpleChange` 对象的情况下，`initialData`
    是否已更改。'
- en: '`patchUpdatedDataIfChanged` leverages `hasChanged` and uses `patchUpdatedData`
    to update the data if, and only if, there has been an update to `initialData`
    and `formGroup` is already initialized.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patchUpdatedDataIfChanged` 利用 `hasChanged` 并使用 `patchUpdatedData` 来更新数据，前提是
    `initialData` 和 `formGroup` 已经初始化，并且有更新。'
- en: 'Create a new class, `BaseFormComponent`, under `src/common` as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/common` 下创建一个新的类，`BaseFormComponent`，如下所示：
- en: '[PRE38]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's implement `NameInputComponent` using the `BaseFormComponent`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `BaseFormComponent` 实现 `NameInputComponent`。
- en: Implementing a reusable form part
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现可重用的表单部分
- en: 'Start by identifying the name form group in the `profile` component code and
    template files:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `profile` 组件代码和模板文件中开始识别名称表单组：
- en: 'The following is the name form group implementation:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下为名称表单组实现：
- en: '[PRE39]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that when we move these validation rules to a new component, we still want
    them to be in effect when determining the overall validation status of the parent
    form. We achieve this by using the `registerForm` function we implemented in the
    previous section. Once our new `FormGroup` is registered with the existing one,
    they work exactly the same way before our refactor.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，当我们将这些验证规则移动到新组件时，我们仍然希望它们在确定父表单的整体验证状态时仍然有效。我们通过使用上一节中实现的 `registerForm`
    函数来实现这一点。一旦我们的新 `FormGroup` 与现有的一个注册，它们的工作方式与重构前完全相同。
- en: 'Next is the name form group template:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是名称表单组的模板：
- en: '[PRE40]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You will be moving most of this code to the new component.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将把大部分代码移动到新组件中。
- en: Create a new `NameInputComponent` under the `user` folder.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `user` 文件夹下创建一个新的 `NameInputComponent`。
- en: Extend the class from `BaseFormComponent`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `BaseFormComponent` 扩展类。
- en: 'Inject `FormBuilder` in the `constructor`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `constructor` 中注入 `FormBuilder`：
- en: For components with small or limited pieces of functionality, I prefer creating
    them with an inline template and styling, so it is easier to change the code from
    one place.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Remember that the base class already implements `formGroup`, `initialData`,
    `disable`, and `formReady` properties, so you don't need to redefine them.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that we are forced to implement the `buildForm` function since it was defined
    as abstract. This is a great way to enforce standards across developers. Also,
    note that any base function provided can be overridden by the implementing class
    by simply redefining the function. You'll see this in action when we refactor
    the `ProfileComponent`.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement the `buildForm` function.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `name` property part of the `formGroup` in `ProfileComponent` to `null`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Implement the template by bringing over the content from `ProfileComponent`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Implement the `ngOnInit` event handler:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is critical to get the implementation of the `ngOnInit` event handler right
    in every implementation of `BaseFormComponent`. The preceding example is fairly
    standard behavior for any `child` component you may implement.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the implementation in `ProfileComponent` will be a bit different.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `ngOnChanges` event handler, leveraging the base `patchUpdatedDataIfChanged`
    behavior:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that in `patchUpdatedDataIfChanged`, setting `onlySelf` to `false` will
    cause the parent form to also update. If you'd like to optimize this behavior,
    you may override the function.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now you have a fully implemented `NameInputComponent` that you can integrate
    into `ProfileComponent`.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To verify your `ProfileComponent` code going forward, refer to `projects/ch11/src/app/user/profile/profile.component.ts`
    and `projects/ch11/src/app/user/profile/profile.component.html`.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before you begin using `NameInputComponent`, perform the following refactors:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Refactor `ProfileComponent` to extend `BaseFormComponent` and conform to its
    default values as needed.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a readonly `nameInitialData$` property with the `BehaviorSubject<IName>`
    type and initialize it with empty strings.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content in `ProfileComponent` with the new `<app-name-input>` component:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that the base form component function, `registerForm`, is leveraged here.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ensure that your `ngOnInit` is implemented correctly:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that there are some additional refactors present on the updated `ProfileComponent`,
    such as the `patchUser` function seen in the following snippet. Don't miss these
    updates when you update your component.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is important to update the current form's data with `pathUpdatedData`, as
    well as `nameInitialData$`, when there's an update to `initialData`.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ensure that `ngOnDestroy` is implemented correctly:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Always remember to unsubscribe from subscriptions, which you can do so easily
    with the `SubSink` package. You can also leverage the base class functionality
    to automatically deregister from all child forms.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's learn about masking user input to increase the quality of our data.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Input masking
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入掩码
- en: 'Masking user input is an input UX tool, as well as a data quality one. I''m
    a fan of the **ngx-mask** library, which makes it really easy to implement input
    masking in Angular. We will demonstrate input masking by updating the phone number
    input field so we can ensure that users input a valid phone number, as shown in
    the following screenshot:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 掩码用户输入是一种输入用户体验工具，同时也是数据质量工具。我是**ngx-mask**库的粉丝，它使得在Angular中实现输入掩码变得非常简单。我们将通过更新电话号码输入字段来演示输入掩码，以确保用户输入有效的电话号码，如下面的截图所示：
- en: '![](img/B14094_11_11.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_11_11.png)'
- en: 'Figure 11.11: Phone number field with input masking'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11：带有输入掩码的电话号码字段
- en: 'Set up your input masking as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式设置您的输入掩码：
- en: Install the library via npm with `npm i ngx-mask`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm i ngx-mask`通过npm安装库。
- en: 'Import the `forRoot` module:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`forRoot`模块：
- en: '[PRE49]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Import the module in the `user` feature module as well:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user`功能模块中导入模块：
- en: '[PRE50]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Update the `number` field in `ProfileComponent` as follows:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式更新`ProfileComponent`中的`number`字段：
- en: '[PRE51]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: And it's that simple. You can learn more about the module and its capabilities
    on GitHub at [https://github.com/JsDaddy/ngx-mask](https://github.com/JsDaddy/ngx-mask).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 简单就是这样。您可以在GitHub上了解更多关于模块及其功能的信息：[https://github.com/JsDaddy/ngx-mask](https://github.com/JsDaddy/ngx-mask)。
- en: Custom controls with ControlValueAccessor
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有`ControlValueAccessor`的自定义控件
- en: So far, we've learned about forms using standard form controls and input controls
    provided by Angular Material. However, it is possible for you to create custom
    user controls. If you implement the `ControlValueAccessor` interface, then your
    custom controls will play nicely with forms and the `ControlValueAccessor` interface's
    validation engine.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了使用Angular Material提供的标准表单控件和输入控件来使用表单。然而，您也可以创建自定义用户控件。如果您实现了`ControlValueAccessor`接口，那么您的自定义控件将与表单和`ControlValueAccessor`接口的验证引擎很好地协同工作。
- en: 'We will be creating the custom rater control shown in the following screenshot,
    and will place it as a control on the first step of `ProfileComponent`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下截图所示的定制评分控件，并将其放置在`ProfileComponent`的第一步中：
- en: '![](img/B14094_11_12.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_11_12.png)'
- en: 'Figure 11.12: The lemon rater user control'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12：柠檬评分器用户控件
- en: User controls are inherently highly reusable, tightly coupled, and customized
    components to enable rich user interactions. Let's implement one.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 用户控件本质上是高度可重用、紧密耦合且定制的组件，用于实现丰富的用户交互。让我们来实现一个。
- en: Implementing a custom rating control
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义评分控件
- en: The lemon rater will highlight the number of lemons selected dynamically as
    the user interacts with the control in real time. As such, creating a high-quality
    custom control is an expensive endeavor.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 柠檬评分器将根据用户与控件实时交互时选择的柠檬数量动态突出显示。因此，创建高质量的定制控件是一项耗时的任务。
- en: The Lemon Rater is a modified version of Jennifer Wadella's Galaxy Rating App
    sample found at [https://github.com/tehfedaykin/galaxy-rating-app](https://github.com/tehfedaykin/galaxy-rating-app).
    I highly recommend that you watch Jennifer's Ng-Conf 2019 talk on `ControlValueAccessor`,
    linked in the *Further reading* section.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Lemon Rater是Jennifer Wadella在[https://github.com/tehfedaykin/galaxy-rating-app](https://github.com/tehfedaykin/galaxy-rating-app)找到的Galaxy评分应用示例的修改版本。我强烈推荐您观看Jennifer在Ng-Conf
    2019上关于`ControlValueAccessor`的演讲，链接在*进一步阅读*部分。
- en: 'Set up your custom rating control as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式设置您的自定义评分控件：
- en: Generate a new component called `LemonRater` under the `user-controls` folder.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user-controls`文件夹下创建一个名为`LemonRater`的新组件。
- en: Create a `LemonRaterModule` in the same folder.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中创建一个`LemonRaterModule`。
- en: Declare and export the component.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并导出组件。
- en: 'In `LemonRater`, implement the `ControlValueAccess` interface:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LemonRater`中实现`ControlValueAccess`接口：
- en: '[PRE52]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add the `NG_VALUE_ACCESSOR` provider with the `multi` property set to `true`.
    This will register our component with the form''s change events, so form values
    can be updated when the user interacts with the rater:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NG_VALUE_ACCESSOR`提供者与`multi`属性设置为`true`。这将注册我们的组件到表单的更改事件，以便在用户与评分器交互时更新表单值：
- en: '[PRE53]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Implement a custom rating scheme with a function to allow for setting the selected
    rating based on user input:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个自定义评分方案，该方案包含一个函数，允许根据用户输入设置所选评分：
- en: '[PRE54]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that by using `@ViewChild`, we're getting the HTML element named `#displayText`
    (highlighted in the following template). Using `setSelectText`, we replace the
    `textContent` of the element.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，通过使用`@ViewChild`，我们获取了名为`#displayText`的HTML元素（在下面的模板中已突出显示）。使用`setSelectText`，我们替换了元素的`textContent`。
- en: 'Implement the template, referring to the sample code for the contents of the
    `svg` tag:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现模板，参考`svg`标签内容的示例代码：
- en: '[PRE55]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The three most important attributes in the template are `mouseover`, `mouseout`,
    and `click`. `mouseover` displays the text for the rating that the user is currently
    hovering over, `mouseout` resets the display text to the selected value, and `click`
    calls the `setRating` method we implemented to record the user's selection. However,
    the control can have even richer user interactivity by highlighting the number
    of lemons when the user hovers over a rating or selects it. We will accomplish
    this via some CSS magic.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模板中最重要的三个属性是`mouseover`、`mouseout`和`click`。`mouseover`显示用户当前悬停的评分文本，`mouseout`将显示文本重置为所选值，`click`调用我们实现的`setRating`方法来记录用户的选择。然而，控件可以通过突出显示用户悬停在评分或选择它时柠檬的数量来提供更丰富的用户交互。我们将通过一些CSS魔法来实现这一点。
- en: 'Implement the `css` for the user control:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现用户控件的`css`：
- en: '[PRE56]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The most interesting bit is with `.lemons .lemon:hover~.lemon #fill-area`.
    Note that the operator `~` or the general sibling combinator is used to select
    a range of elements so that a dynamic number of lemons will be highlighted as
    the user hovers over them.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '最有趣的部分是`.lemons .lemon:hover~.lemon #fill-area`。请注意，运算符`~`或通用兄弟组合器用于选择一系列元素，以便在用户悬停在它们上时突出显示动态数量的柠檬。'
- en: '`#fill-area` refers to a `<path>` defined within the lemon `svg`, which allows
    for the lemon''s color to be adjusted dynamically. I had to manually inject this
    ID field into the `svg` file.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`#fill-area`指的是在柠檬`svg`内部定义的`<path>`，这允许动态调整柠檬的颜色。我不得不手动将此ID字段注入到`svg`文件中。'
- en: Now, let's see how you can use this new user control in a form.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看你如何在表单中使用这个新的用户控件。
- en: Using custom controls in forms
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在表单中使用自定义控件
- en: We will use the lemon rater in the `profile` component to record the Limoncu
    level of the employee.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`profile`组件中使用柠檬评分器来记录员工的Limoncu等级。
- en: Limoncu, meaning a person who grows or sells lemons in Turkish, is Lemon Mart's
    proprietary employee engagement and performance measurement system.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Limoncu，在土耳其语中意味着种植或出售柠檬的人，是Lemon Mart的专有员工参与度和绩效测量系统。
- en: 'Let''s integrate the lemon rater:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们集成柠檬评分器：
- en: Start by importing the `LemonRaterModule` in `UserModule`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在`UserModule`中导入`LemonRaterModule`。
- en: 'Ensure that the level form control is initialized in `buildForm`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`buildForm`中初始化级别表单控件：
- en: '[PRE57]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Insert the lemon rater as the last element of the first `mat-step`, inside
    the `form` element:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将柠檬评分器作为第一个`mat-step`的最后一个元素插入到`form`元素中：
- en: '[PRE58]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We simply integrate with the custom control by implementing `formControlName`
    as you would with any other control.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需通过实现`formControlName`与任何其他控件一样的方式，简单地与自定义控件集成。
- en: Congratulations! You should have a working custom control that is integrated
    with your form.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你应该有一个与你的表单集成的可工作的自定义控件。
- en: Layouts using grid list
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格列表布局
- en: 'The Angular Flex Layout library is great for laying out content using CSS Flexbox.
    Angular Material provides another mechanism to lay out content by using CSS Grid
    with its Grid List functionality. A good way to demonstrate this functionality
    is by implementing a helpful list for fake login information in the `LoginComponent`,
    demonstrated here:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Flex Layout库非常适合使用CSS Flexbox布局内容。Angular Material通过使用CSS Grid及其网格列表功能提供另一种布局内容的机制。演示此功能的一个好方法是在`LoginComponent`中实现一个用于伪造登录信息的帮助列表，如下所示：
- en: '![](img/B14094_11_13.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![img/B14094_11_13.png](img/B14094_11_13.png)'
- en: 'Figure 11.13: Login helper with the grid list'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：带有网格列表的登录助手
- en: 'Implement your list as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式实现你的列表：
- en: 'Start by defining a `roles` property that is an array of all the roles:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先定义一个`roles`属性，它是一个包含所有角色的数组：
- en: '[PRE59]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Import `MatExpansionModule` and `MatGridListModule` into `AppMaterialModule`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MatExpansionModule`和`MatGridListModule`导入到`AppMaterialModule`中：
- en: 'Implement a new `mat-card-content` below the existing one:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的`mat-card-content`下方实现一个新的`mat-card-content`：
- en: '[PRE60]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Inside the new `mat-card-content`, put in a label to display the authentication
    mode:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`mat-card-content`内部，放入一个标签以显示认证模式：
- en: '[PRE61]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Beneath the label, implement an expansion list:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标签下方实现一个展开列表：
- en: '[PRE62]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'After `mat-expansion-panel-header`, in the area marked with ellipses in the
    preceding step, implement a table of roles and email addresses, along with some
    hint text regarding password length using `mat-grid-list`, shown in the following
    code block:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mat-expansion-panel-header`之后，在上一个步骤中用省略号标记的区域，实现一个角色和电子邮件地址的表格，以及一些有关密码长度的提示文本，使用`mat-grid-list`，如下面的代码块所示：
- en: '[PRE63]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We use `colspan` to control the width of each row and cell. We leverage `fxLayoutAlign`
    to right-align the contents of the **E-mail** column. We use `*ngIf; else` to
    selectively display content. Finally, a **Fill** button helps us to populate the
    login form with fake login information.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`colspan`来控制每行和每个单元格的宽度。我们利用`fxLayoutAlign`将**电子邮件**列的内容右对齐。我们使用`*ngIf;
    else`来选择性地显示内容。最后，一个**填充**按钮帮助我们用假登录信息填充登录表单。
- en: In your application, you can use an expansion panel to communicate password
    complexity requirements to your users.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，你可以使用展开面板来向用户传达密码复杂性的要求。
- en: You can read more about expansion panels at [https://material.angular.io/components/expansion](https://material.angular.io/components/expansion)
    and Grid List at [https://material.angular.io/components/grid-list/overview](https://material.angular.io/components/grid-list/overview).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://material.angular.io/components/expansion](https://material.angular.io/components/expansion)了解更多关于展开面板的信息，以及在[https://material.angular.io/components/grid-list/overview](https://material.angular.io/components/grid-list/overview)了解更多关于网格列表的信息。
- en: Restoring cached data
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复缓存数据
- en: 'At the beginning of the chapter, when implementing the `updateUser` method
    in `UserService`, we cached the `user` object in case of any errors that may wipe
    out user-provided data:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，当在`UserService`中实现`updateUser`方法时，我们缓存了`user`对象，以防任何可能清除用户提供的数据的错误：
- en: '[PRE64]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Consider a scenario where the user may be temporarily offline when they attempt
    to save their data. In this case, our `updateUser` function will save the data.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，当用户尝试保存数据时，他们可能暂时离线。在这种情况下，我们的`updateUser`函数将保存数据。
- en: 'Let''s see how we can restore this data in `ProfileComponent` when loading
    the user profile:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在`ProfileComponent`中加载用户配置文件时恢复这些数据：
- en: 'Start by adding functions named `loadFromCache` and `clearCache` to the `ProfileComponent`
    class:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先向`ProfileComponent`类中添加名为`loadFromCache`和`clearCache`的函数：
- en: '[PRE65]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: After loading the data, we parse the data into a JSON object, using `JSON.parse`,
    and then hydrate the `User` object with `User.Build`.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在加载数据后，我们使用`JSON.parse`将数据解析为JSON对象，然后使用`User.Build`来填充`User`对象。
- en: 'Update the template to call the `clearCache` function, so when the user resets
    the form, we also clear the cache:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新模板以调用`clearCache`函数，这样当用户重置表单时，我们也会清除缓存：
- en: '[PRE66]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Update `ngOnInit` to conditionally load data from cache or the latest `currentUser$`
    from `authService`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ngOnInit`更新为有条件地从缓存加载数据或从`authService`的最新`currentUser$`：
- en: '[PRE67]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We leverage the `combineLatest` operator to combine the outputs of `loadFromCache`
    and `currentUser$`. We check to see that one of the streams is returning a non-null
    value. If a cached user exists, it takes precedence over the value received from
    `currentUser$`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用`combineLatest`运算符将`loadFromCache`和`currentUser$`的输出合并。我们检查是否有流返回非空值。如果存在缓存的用户，它将优先于从`currentUser$`接收到的值。
- en: 'You can test your cache by setting the network status of your browser to be
    offline, as shown:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将浏览器的网络状态设置为离线来测试你的缓存，如下所示：
- en: '![](img/B14094_11_14.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_11_14.png)'
- en: 'Figure 11.14: Offline network status'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14：离线网络状态
- en: 'Set the network status of your browser to offline as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 将浏览器的网络状态设置为离线，如下所示：
- en: In Chrome DevTools, navigate to the **Network** tab.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Chrome DevTools中，导航到**网络**选项卡。
- en: Select **Offline** in the dropdown marked as **2** in the preceding screenshot.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的截图标记为**2**的下拉菜单中选择**离线**。
- en: Make a change to your form, such as the name, and hit **Update**.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的表单，例如名称，然后点击**更新**。
- en: You'll see an error reading **An unknown error has occurred** displayed at the bottom
    of the form.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会在表单底部看到**发生未知错误**的错误信息。
- en: In the **Network** tab, you'll see that your PUT request has failed.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**网络**选项卡中，你会看到你的PUT请求失败了。
- en: Now, refresh your browser window and observe that the new name you entered is
    still present.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，刷新你的浏览器窗口，观察你输入的新名称仍然存在。
- en: 'Refer to the following screenshot, which shows the toast notification you get
    after loading data from the cache:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下截图，它显示了从缓存加载数据后你收到的吐司通知：
- en: '![](img/B14094_11_15.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_11_15.png)'
- en: 'Figure 11.15: Data loaded from cache'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15：从缓存加载数据
- en: Implementing a great UX around caching is incredibly challenging. I provided
    a rudimentary method to show what is possible. However, there are many edge cases
    that can impact how caching in your application works.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存周围实现一个优秀的用户体验非常具有挑战性。我提供了一个基本的方法来展示什么是可能的。然而，有许多边缘情况可能会影响你的应用程序中缓存的工作方式。
- en: In my case, the cache stubbornly sticks around until we successfully save the
    data to the server. This may be frustrating for some users.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，缓存固执地存在，直到我们成功将数据保存到服务器。这可能会让一些用户感到沮丧。
- en: Congratulations! You've successfully implemented a sophisticated form to capture
    data from your users!
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功实现了一个复杂的表单来捕获用户数据！
- en: Exercise
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Further enhance the `login` component to add a login helper for `AuthMode.CustomServer`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步增强`login`组件，以添加`AuthMode.CustomServer`的登录助手。
- en: Summary
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered forms, directives, and user control-related functionality
    for LemonMart. We created reusable components that can be embedded within another
    component using data binding. We showed that you can use PUT to send data to the
    server and cache data input by the user. We also created a multistep input form
    that is responsive to changing screen sizes. We removed the boilerplate code from
    our components by leveraging reusable form parts, a base form class to house common
    functionality, and an attribute directive to encapsulate field-level error behavior
    and messages.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了LemonMart的表单、指令和用户控制相关功能。我们创建了可重用的组件，可以使用数据绑定嵌入到另一个组件中。我们展示了您可以使用PUT向服务器发送数据并缓存用户输入的数据。我们还创建了一个响应屏幕尺寸变化的分步输入表单。通过利用可重用表单部分、基类表单以容纳常用功能以及属性指令来封装字段级错误行为和消息，我们消除了组件中的样板代码。
- en: We created dynamic form elements with a date picker, typeahead support, and
    form arrays. We implemented interactive controls with input masking and the lemon
    rater. Using the `ControlValueAccessor` interface, we integrated the lemon rater
    seamlessly with our form. We showed that we can scale the size and complexity
    of our forms linearly by extracting the name as its own form section. Additionally,
    we covered building layouts using grid list.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用日期选择器、自动完成支持和表单数组创建了动态表单元素。我们实现了具有输入掩码和柠檬评分器的交互式控件。通过使用`ControlValueAccessor`接口，我们将柠檬评分器无缝集成到我们的表单中。我们展示了我们可以通过提取名称作为其自己的表单部分来线性扩展表单的大小和复杂性。此外，我们还介绍了使用网格列表构建布局。
- en: In the next chapter, we will further enhance our components so that we can orchestrate
    them using the router. We will also implement a master/detail view and a data
    table, and explore NgRx as an alternative to using RxJS/BehaviorSubject.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步增强我们的组件，以便我们可以使用路由器来编排它们。我们还将实现主/详细视图和数据表，并探索NgRx作为使用RxJS/BehaviorSubject的替代方案。
- en: Further reading
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Reactive forms*, 2020, available at [https://angular.io/guide/reactive-forms](https://angular.io/guide/reactive-forms
    )'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*响应式表单*，2020年，可在[https://angular.io/guide/reactive-forms](https://angular.io/guide/reactive-forms)找到'
- en: '*Attribute directives*, 2020, available at [https://angular.io/guide/attribute-directives](https://angular.io/guide/attribute-directives
    )'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性指令*，2020年，可在[https://angular.io/guide/attribute-directives](https://angular.io/guide/attribute-directives)找到'
- en: '*rxweb: Good way to show the error messages in Angular Reactive Forms*, Ajay
    Ojha, 2019, available at [https://medium.com/@oojhaajay/rxweb-good-way-to-show-the-error-messages-in-angular-reactive-forms-c27429f51278](https://medium.com/@oojhaajay/rxweb-good-way-to-show-the-error-messages-in-angular-reactive-forms-c2)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*rxweb: 在Angular Reactive Forms中显示错误消息的好方法*，Ajay Ojha，2019年，可在[https://medium.com/@oojhaajay/rxweb-good-way-to-show-the-error-messages-in-angular-reactive-forms-c27429f51278](https://medium.com/@oojhaajay/rxweb-good-way-to-show-the-error-messages-in-angular-reactive-forms-c2)找到'
- en: '*The Control Value Accessor*, Jennifer Wadella, 2019, available at [https://www.youtube.com/watch?v=kVbLSN0AW-Y](https://www.youtube.com/watch?v=kVbLSN0AW-Y)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制值访问器*，Jennifer Wadella，2019年，可在[https://www.youtube.com/watch?v=kVbLSN0AW-Y](https://www.youtube.com/watch?v=kVbLSN0AW-Y)找到'
- en: '*CSS Combinators*, 2020, available at [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators
    )'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CSS组合器*，2020年，可在[https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators)找到'
- en: Questions
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地回答以下问题，以确保你在不使用谷歌搜索的情况下理解了本章的关键概念。你需要帮助回答这些问题吗？请参阅*附录D*，*自我评估答案*，在线访问[https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)或访问[https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment)。
- en: What is the difference between a component and a user control?
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件和用户控件之间的区别是什么？
- en: What is an attribute directive?
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性指令是什么？
- en: What is the purpose of the `ControlValueAccessor` interface?
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ControlValueAccessor`接口的目的是什么？'
- en: What are serialization, deserialization, and hydration?
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列化、反序列化和活化是什么？
- en: What does it mean to patch values on a form?
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单上修补值意味着什么？
- en: How do you associate two independent `FormGroup` objects with each other?
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何将两个独立的`FormGroup`对象相互关联？
