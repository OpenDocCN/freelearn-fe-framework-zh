- en: Developing Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发插件
- en: The available third-party plugins provide a bevy of options for enhancing our
    coding experience, but sometimes we need to reach a bit farther. When we write
    code that could be reused by others or even just ourselves, we may want to package
    it up as a new plugin. Fortunately, the process of developing a plugin is not
    much more involved than writing the code that uses it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的第三方插件提供了丰富的选项来增强我们的编码体验，但有时我们需要更进一步。当我们编写可以被其他人甚至只是我们自己重复使用的代码时，我们可能希望将其打包为一个新的插件。幸运的是，开发插件的过程与编写使用它的代码并没有太大区别。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Adding new global functions within the `jQuery` namespace
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`jQuery`命名空间中添加新的全局函数
- en: Adding jQuery object methods that allow us to act on DOM elements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加jQuery对象方法以允许我们对DOM元素进行操作
- en: Creating widget plugins using the jQuery UI widget factory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery UI小部件工厂创建小部件插件
- en: Distributing plugins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发插件
- en: Using the dollar ($) alias in plugins
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在插件中使用美元（$）别名
- en: When we write jQuery plugins, we must assume that the jQuery library is loaded.
    We cannot assume, however, that the dollar (`$`) alias is available. Recall from
    [Chapter 3](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml), *Handling Events*, that
    the `$.noConflict()` method can relinquish control of this shortcut. To account
    for this, our plugins should always call jQuery methods using the full jQuery
    name or internally define `$` themselves.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写jQuery插件时，必须假设jQuery库已加载。但是我们不能假设美元（$）别名可用。回顾一下[第3章](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml)中的内容，*事件处理*，`$.noConflict()`方法可以放弃对这个快捷方式的控制。为了解决这个问题，我们的插件应该始终使用完整的jQuery名称调用jQuery方法，或者在内部定义`$`自己。
- en: 'Especially in larger plugins, many developers find that the lack of the dollar
    (`$`) shortcut makes code more difficult to read. To combat this, the shortcut
    can be locally defined for the scope of the plugin by defining a function and
    immediately invoking it. This syntax for defining and invoking a function at once,
    often referred to as an **Immediately Invoked Function Expression** (**IIFE**),
    looks like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在较大的插件中，许多开发人员发现缺少美元符号（`$`）快捷方式使得代码更难阅读。为了解决这个问题，可以通过定义一个函数并立即调用它来为插件的范围定义快捷方式。这种定义并立即调用函数的语法，通常被称为**立即调用函数表达式**（**IIFE**），看起来像这样：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The wrapping function takes a single parameter to which we pass the global `jQuery`
    object. The parameter is named `$`, so within the function we can use the dollar
    (`$`) alias with no conflicts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 包装函数接受一个参数，我们将全局`jQuery`对象传递给它。参数被命名为`$`，所以在函数内部我们可以使用美元（$）别名而不会出现冲突。
- en: Adding new global functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的全局函数
- en: Some of the built-in capabilities of jQuery are provided via what we have been
    calling global functions. As we've seen, these are actually methods of the jQuery
    object, but practically speaking, they are functions within a `jQuery` namespace.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的一些内置功能是通过我们一直称为全局函数的方式提供的。正如我们所见，这些实际上是jQuery对象的方法，但从实际操作上来说，它们是`jQuery`命名空间中的函数。
- en: A prime example of this technique is the `$.ajax()` function. Everything that
    `$.ajax()` does could be accomplished with a regular global function called `ajax()`,
    but this approach would leave us open for function name conflicts. By placing
    the function within the `jQuery` namespace, we only have to worry about conflicts
    with other jQuery methods. This `jQuery` namespace also signals to those who might
    use the plugin that the jQuery library is required.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的一个典型例子是`$.ajax()`函数。`$.ajax()`所做的一切都可以通过一个名为`ajax()`的常规全局函数来实现，但是这种方法会使我们容易遇到函数名冲突。通过将函数放置在`jQuery`命名空间中，我们只需要担心与其他jQuery方法的冲突。这个`jQuery`命名空间还向那些可能使用插件的人们表明，需要jQuery库。
- en: Many of the global functions provided by the core jQuery library are utility
    methods; that is, they provide shortcuts for tasks that are frequently needed,
    but not difficult to do by hand. The array-handling functions `$.each()`, `$.map()`,
    and `$.grep()` are good examples of these. To illustrate the creation of such
    utility methods, we'll add two simple functions to their number.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery核心库提供的许多全局函数都是实用方法；也就是说，它们为经常需要但不难手动完成的任务提供了快捷方式。数组处理函数`$.each()`、`$.map()`和`$.grep()`就是这样的好例子。为了说明创建这种实用方法，我们将向其中添加两个简单的函数。
- en: 'To add a function to the `jQuery` namespace, we can just assign the new function
    as a property of the `jQuery` object:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要将函数添加到`jQuery`命名空间中，我们只需将新函数作为`jQuery`对象的属性赋值即可：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Listing 8.1
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1
- en: 'Now, in any code that uses this plugin, we can write:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在使用此插件的任何代码中，我们可以写：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will work just like a basic function call, and the code inside the function
    will be executed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将像基本函数调用一样工作，并且函数内部的代码将被执行。
- en: 'This `sum` method will accept an array, add the values in the array together,
    and return the result. The code for our plugin is quite brief:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`sum`方法将接受一个数组，将数组中的值相加，并返回结果。我们插件的代码相当简洁：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listing 8.2
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 8.2**'
- en: To compute the sum, we're calling `reduce()` on the array, which simply iterates
    over each item in the array, and adding it to the `result`. In the preceding code,
    there's two callback functions that return values. Neither of them have a `return`
    statement because they're arrow functions. When we don't include the curly braces
    (`{}`), the return value is implicit.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算总和，我们在数组上调用`reduce()`，它简单地迭代数组中的每个项，并将其添加到`result`中。在前面的代码中，有两个返回值的回调函数。它们都没有`return`语句，因为它们是箭头函数。当我们不包括花括号（`{}`）时，返回值是隐式的。
- en: 'To test our plugins, we''ll build a simple table with an inventory of groceries:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的插件，我们将构建一个简单的带有杂货清单的表格：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting the example code
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 获取示例代码
- en: You can access the example code from the following GitHub repository: [https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下GitHub存储库访问示例代码：[https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3)。
- en: 'Now, we''ll write a short script that populates the appropriate table footer
    cell with the sum of all quantities:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个简短的脚本，将适当的表格页脚单元格填充为所有数量的总和：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Listing 8.3
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 8.3**'
- en: 'A look at the rendered HTML page verifies that our plugin is working correctly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 查看呈现的HTML页面可验证我们的插件是否正常工作：
- en: '![](img/5297_08_01.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_08_01.png)'
- en: Adding multiple functions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加多个函数
- en: 'If our plugin needs to provide more than one global function, we could declare
    them independently. Here, we''ll revise our plugin, adding a function to compute
    the average of an array of numbers:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的插件需要提供多个全局函数，我们可以独立声明它们。在这里，我们将修改我们的插件，添加一个计算数字数组平均值的函数：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listing 8.4
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 8.4**'
- en: For convenience and brevity, we're using the `$.sum()` plugin to assist us in
    returning the value for `$.average()`. To decrease the chance of errors, we also
    check the argument to make sure it is an array before computing the average.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便和简洁，我们使用`$.sum()`插件来辅助我们返回`$.average()`的值。为了减少错误的几率，我们还检查参数以确保其是一个数组，然后再计算平均值。
- en: 'Now that a second method is defined, we can call it in the same fashion:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义了第二种方法，我们可以以相同的方式调用它：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Listing 8.5
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 8.5**'
- en: 'The average now appears in the third column:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值现在显示在第三列中：
- en: '![](img/5297_08_02.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_08_02.png)'
- en: Extending the global jQuery object
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展全局jQuery对象
- en: 'We can also employ an alternate syntax in defining our functions using the
    `$.extend()` function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`$.extend()`函数以定义我们的函数的另一种语法：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 8.6
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 8.6**'
- en: When called this way, `$.extend()` adds or replaces properties of the global
    jQuery object. This, therefore, produces the same results as the previous technique.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这样调用时，`$.extend()`添加或替换全局jQuery对象的属性。因此，这与先前的技术产生相同的结果。
- en: Isolating functions within namespaces
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在命名空间内隔离函数
- en: 'Our plugin now creates two separate global functions within the `jQuery` namespace.
    We risk a different kind of namespace pollution here, though; we could still have
    a conflict with function names defined in other jQuery plugins. To avoid this,
    it is best to encapsulate all the global functions for a given plugin into a single
    object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的插件在`jQuery`命名空间内创建了两个单独的全局函数。在这里，我们面临一种不同类型的命名空间污染风险；虽然我们仍然可能与其他jQuery插件中定义的函数名冲突。为了避免这种情况，最好将给定插件的所有全局函数封装到单个对象中：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Listing 8.7
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 8.7**'
- en: 'This pattern essentially creates another namespace for our global functions,
    called `jQuery.mathUtils`. Though we will still informally call these functions
    global, they are now methods of the `mathUtils` object, which is itself a property
    of the global jQuery object. We, therefore, have to include the plugin name in
    our function calls:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式实质上为我们的全局函数创建了另一个命名空间，称为`jQuery.mathUtils`。虽然我们仍然非正式地称这些函数为全局函数，但它们现在是`mathUtils`对象的方法，后者本身是全局jQuery对象的属性。因此，在我们的函数调用中，我们必须包含插件名称：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this technique (and a sufficiently unique plugin name), we are protected
    from namespace collisions in our global functions. We now have the basics of plugin
    development in our repertoire. After saving our functions in a file called `jquery.mathutils.js`,
    we can include this script and use the functions from other scripts on the page.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种技术（和足够独特的插件名称），我们可以在全局函数中避免命名空间冲突。这样，我们就掌握了插件开发的基础知识。将我们的函数保存在名为`jquery.mathutils.js`的文件中后，我们可以包含此脚本，并在页面上的其他脚本中使用这些函数。
- en: Choosing a namespace
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 选择命名空间
- en: For functions that are solely for personal use, it often makes more sense to
    place them within our own project's global namespace. So, instead of using `jQuery`,
    we may instead choose to expose one global object of our own. We could, for example,
    have a global object called `ljQ` and define the `ljQ.mathUtils.sum()` and `ljQ.mathUtils.average()`
    methods instead of `$.mathUtils.sum()` and `$.mathUtils.average()`. This way,
    we completely remove the chance of namespace collisions with third-party plugins
    that we choose to include.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仅供个人使用的功能，将其放置在我们项目的全局命名空间中通常更合理。因此，我们可以选择暴露我们自己的一个全局对象，而不是使用`jQuery`。例如，我们可以有一个名为`ljQ`的全局对象，并定义`ljQ.mathUtils.sum()`和`ljQ.mathUtils.average()`方法，而不是`$.mathUtils.sum()`和`$.mathUtils.average()`。这样，我们完全消除了选择包含的第三方插件发生命名空间冲突的可能性。
- en: So, we've now seen the namespace protection and guaranteed library availability
    that jQuery plugins grant. These are just organizational benefits, though. To
    really tap into the power of jQuery plugins, we need to learn how to create new
    methods on individual jQuery object instances.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经了解了jQuery插件提供的命名空间保护和保证库的可用性。然而，这些仅仅是组织上的好处。要真正发挥jQuery插件的威力，我们需要学会如何在单个jQuery对象实例上创建新方法。
- en: Adding jQuery object methods
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加jQuery对象方法
- en: Most of jQuery's built-in functionality is provided through its object instance
    methods, and this is where plugins shine as well. Whenever we would write a function
    that acts on part of the DOM, it is probably appropriate instead to create an
    **instance method**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数jQuery内置功能是通过其对象实例方法提供的，插件的具有同样出色的表现。每当我们要编写作用于DOM一部分的函数时，可能更适合创建一个**实例方法**。
- en: 'We have seen that adding global functions requires extending the `jQuery` object
    with new methods. Adding instance methods is similar, but we instead extend the
    `jQuery.fn` object:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，添加全局函数需要使用`jQuery`对象扩展新方法。添加实例方法是类似的，但我们要扩展`jQuery.fn`对象：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `jQuery.fn` object is an alias to `jQuery.prototype`, provided for conciseness.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery.fn`对象是`jQuery.prototype`的别名，用于简洁性。'
- en: 'We can then call this new method from our code after using any selector expression:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在使用选择器表达式后，从我们的代码中调用这个新方法：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our alert is displayed (once for each `<div>` in the document) when we invoke
    the method. We might as well have written a global function, though, as we haven't
    used the matched DOM nodes in any way. A reasonable method implementation acts
    on its context.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用方法时，我们的警报显示（对于文档中的每个`<div>`都会显示一次）。不过，我们既然没有以任何方式使用匹配的DOM节点，我们可能也可以编写一个全局函数。一个合理的方法实现会作用于其上下文。
- en: Object method context
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象方法上下文
- en: Within any plugin method, the keyword `this` is set to the current jQuery object.
    Therefore, we can call any built-in jQuery method on `this` or extract its DOM
    nodes and work on them. To examine what we can do with object context, we'll write
    a small plugin to manipulate the classes on the matched elements.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何插件方法中，关键字`this`被设置为当前的jQuery对象。因此，我们可以在`this`上调用任何内置的jQuery方法，或者提取其DOM节点并对它们进行操作。为了检查我们可以用对象上下文做什么，我们将编写一个小插件来操作匹配元素上的类。
- en: 'Our new method will take two class names and swap which class is applied to
    each element with every invocation. While jQuery UI has a robust `.switchClass()`
    method that even permits animating the class change, we''ll provide a simple implementation
    for demonstration purposes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新方法将接受两个类名，并交换每次调用时应用于每个元素的类。虽然jQuery UI有一个强大的`.switchClass()`方法，甚至允许动画地改变类，但我们将提供一个简单的实现作为演示目的：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Listing 8.8
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8
- en: In our plugin, we first test for the presence of `class1` on the matched element
    and substitute `class2` if it is found. Otherwise, we test for `class2` and switch
    in `class1` if necessary. If neither class is currently present, we do nothing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的插件中，我们首先测试匹配元素上是否存在`class1`，如果存在则用`class2`替换。否则，我们测试是否存在`class2`，如果必要则切换为`class1`。如果当前没有任何类，则我们不执行任何操作。
- en: In the code that uses the plugin, we bind a `click` handler to the table, calling
    `.swapClass()` on every row when the table is clicked on. We'd expect this to
    change the class of the header row from `one` to `two` and to change the class
    of the sum row from `two` to `one`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用插件的代码中，我们将`click`处理程序绑定到表格上，在单击表格时对每一行调用`.swapClass()`。我们希望这将把标题行的类从`one`更改为`two`，并将总和行的类从`two`更改为`one`。
- en: 'However, we observe a different result:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们观察到了不同的结果：
- en: '![](img/5297_08_03.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_08_03.png)'
- en: Every row has received the `two` class. To fix this, we need to correctly handle
    jQuery objects with multiple selected elements.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都收到了`two`类。要解决这个问题，我们需要正确处理具有多个选定元素的 jQuery 对象。
- en: Implicit iteration
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式迭代
- en: We need to remember that a jQuery selector expression can always match zero,
    one, or multiple elements. We must allow for any of these scenarios when designing
    a plugin method. In this case, we are calling `.hasClass()`, which only examines
    the first matched element. Instead, we need to check each element independently
    and act on it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，jQuery 选择器表达式总是可以匹配零个、一个或多个元素。在设计插件方法时，我们必须考虑到这些情况中的任何一种。在这种情况下，我们正在调用`.hasClass()`，它仅检查第一个匹配的元素。相反，我们需要独立地检查每个元素并对其采取行动。
- en: 'The easiest way to guarantee proper behavior, regardless of the number of matched
    elements, is to always call `.each()` on the method context; this enforces implicit
    iteration, which is important for maintaining consistency between plugin and built-in
    methods. Within the `.each()` callback function, the second argument refers to
    each DOM element in turn, so we can adjust our code to separately test for and
    apply classes to each matched element:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无论匹配的元素数量如何，保证正确行为的最简单方法是始终在方法上下文中调用`.each()`；这强制执行隐式迭代，这对于保持插件和内置方法之间的一致性至关重要。在`.each()`回调函数中，第二个参数依次引用每个
    DOM 元素，因此我们可以调整我们的代码来分别测试和应用类到每个匹配的元素：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing 8.9
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9
- en: 'Now, when we click on the table, the classes are switched without affecting
    the rows that have neither class applied:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们点击表格时，切换类而不影响没有应用任何类的行：
- en: '![](img/5297_08_04.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_08_04.png)'
- en: Enabling method chaining
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用方法链
- en: 'In addition to implicit iteration, jQuery users should be able to rely on chaining
    behavior. This means that we need to return a jQuery object from all plugin methods,
    unless the method is clearly intended to retrieve a different piece of information.
    The returned jQuery object is usually just the one provided as `this`. If we use
    `.each()` to iterate over `this`, we can just return its result:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了隐式迭代之外，jQuery 用户还应该能够依赖链接行为。这意味着我们需要从所有插件方法中返回一个 jQuery 对象，除非该方法明确用于检索不同的信息片段。返回的
    jQuery 对象通常只是作为`this`提供的一个。如果我们使用`.each()`来迭代`this`，我们可以直接返回其结果：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Listing 8.10
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10
- en: Previously, when we called `.swapClass()`, we had to start a new statement to
    do anything else with the elements. With the `return` statement in place, though,
    we can freely chain our plugin method with built-in methods.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，当我们调用`.swapClass()`时，我们必须开始一个新语句来处理元素。然而，有了`return`语句，我们可以自由地将我们的插件方法与内置方法链接起来。
- en: Providing flexible method parameters
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供灵活的方法参数
- en: In [Chapter 7](e101ee08-ea8f-40f0-966c-e00b6af852ed.xhtml), *Using Plugins*,
    we saw some plugins that can be fine-tuned to do exactly what we want through
    the use of parameters. We saw that a cleverly constructed plugin helps us by providing
    sensible defaults that can be independently overridden. When we make our own plugins,
    we should follow this example by keeping the user in mind.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](e101ee08-ea8f-40f0-966c-e00b6af852ed.xhtml) *使用插件* 中，我们看到了一些插件，可以通过参数进行微调，以达到我们想要的效果。我们看到，一个构造巧妙的插件通过提供合理的默认值来帮助我们，这些默认值可以被独立地覆盖。当我们制作自己的插件时，我们应该以用户为重心来遵循这个例子。
- en: 'To explore the various ways in which we can let a plugin''s user customize
    its behavior, we need an example that has several settings that can be tweaked
    and modified. As our example, we''ll replicate a feature of CSS by using a more
    brute-force JavaScript approach--an approach that is more suitable for demonstration
    than for production code. Our plugin will simulate a shadow on an element by creating
    a number of copies that are partially transparent overlaid in different positions
    on the page:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索各种方法，让插件的用户自定义其行为，我们需要一个具有多个可以进行调整和修改的设置的示例。作为我们的示例，我们将通过使用更为武断的 JavaScript
    方法来复制 CSS 的一个特性--这种方法更适合于演示而不是生产代码。我们的插件将通过在页面上不同位置叠加部分透明的多个副本来模拟元素上的阴影：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 8.11
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码清单 8.11
- en: 'For each element this method is called on, we make a number of clones of the
    element, adjusting their opacity. These clones are positioned absolutely at varying
    offsets from the original element. For the moment, our plugin takes no parameters,
    so calling the method is simple:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个调用此方法的元素，我们会制作多个元素的克隆，并调整它们的不透明度。这些克隆元素被绝对定位在原始元素的不同偏移量处。目前，我们的插件不接受参数，因此调用该方法很简单：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This method call produces a very simple shadow effect on the header text:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用会在标题文本上产生一个非常简单的阴影效果：
- en: '![](img/5297_08_05.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_08_05.png)'
- en: Next, we can introduce some flexibility to the plugin method. The operation
    of the method relies on several numeric values that the user might want to modify.
    We can turn these into parameters so they can be changed on demand.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以为插件方法引入一些灵活性。该方法的操作依赖于用户可能希望修改的几个数值。我们可以将它们转换为参数，以便根据需要进行更改。
- en: Options objects
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项对象
- en: 'We have seen many examples in the jQuery API of `options` objects being provided
    as parameters of methods such as `.animate()` and `$.ajax()`. This can be a much
    friendlier way to expose options to a plugin user than the simple parameter list
    we just used with the `.swapClass()` plugin. An object literal provides a visual
    label for each parameter and also makes the order of the parameters irrelevant.
    In addition, any time we can mimic the jQuery API in our plugins, we should do
    so. This will increase the consistency and therefore ease of use:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 jQuery API 中看到了许多示例，其中`options`对象被提供为方法的参数，例如`.animate()`和`$.ajax()`。这可以是向插件用户公开选项的更友好的方式，而不是我们刚刚在`.swapClass()`插件中使用的简单参数列表。对象文字为每个参数提供了可视标签，并且使参数的顺序变得无关紧要。此外，每当我们可以在我们的插件中模仿
    jQuery API 时，我们都应该这样做。这将增加一致性，从而提高易用性：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Listing 8.12
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 代码清单 8.12
- en: The number of copies made and their opacity are now customizable. Within our
    plugin, each value is accessed as a property of the `options` argument to the
    function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以自定义制作的副本数量及其不透明度。在我们的插件中，每个值都作为函数的`options`参数的属性访问。
- en: 'Calling this method now requires us to provide an object containing the option
    values:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用此方法需要我们提供包含选项值的对象：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The configurability is an improvement, but we now have to provide both options
    every time. Next, we'll take a look at how we can allow our plugin users to omit
    either option.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可配置性是一种改进，但现在我们必须每次都提供两个选项。接下来，我们将看看如何允许我们的插件用户省略任一选项。
- en: Default parameter values
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数值
- en: 'As the number of parameters for a method grows, it becomes less likely that
    we will always want to specify each one. A sensible set of default values can
    make a plugin interface much more usable. Fortunately, using an object to pass
    in our parameters helps with this task; it is simple to omit any item from the
    object and replace it with a default:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 随着方法的参数数量增加，我们不太可能总是想要指定每个参数。合理的默认值集合可以使插件接口更加易用。幸运的是，使用对象传递参数可以帮助我们完成这项任务；简单地省略对象中的任何项并用默认值替换它是很简单的：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Listing 8.13
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代码清单 8.13
- en: Here, we have defined a new object called `defaults`. The utility function `$.extend()`
    lets us take the `opts` object provided as an argument and use it to create a
    new `options` object using `defaults` where necessary. The `extend()` function
    merges any objects passed to it into the first argument. This is why we've passed
    an empty object as the first argument, so that we create a new object for options,
    rather than accidentally destroying existing data. For example, what if defaults
    were defined somewhere else in the code and we accidentally replaced it's values?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`defaults`的新对象。 实用函数`$.extend（）`允许我们使用提供的`opts`对象作为参数，并使用`defaults`在必要时创建一个新的`options`对象。
    `extend（）`函数将传递给它的任何对象合并到第一个参数中。 这就是为什么我们将空对象作为第一个参数传递的原因，以便我们为选项创建一个新对象，而不是意外地销毁现有数据。
    例如，如果默认值在代码的其他位置定义，并且我们意外地替换了其值呢？
- en: 'We still call our method using an object literal, but now we can specify only
    the parameters that need to take different values than their defaults:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然使用对象字面量调用我们的方法，但现在我们只能指定需要与其默认值不同的参数：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Unspecified parameters use their default values. The `$.extend()` method even
    accepts null values, so if the default parameters are all acceptable, our method
    can be called without producing JavaScript errors:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 未指定的参数使用其默认值。 `$.extend（）`方法甚至接受null值，因此如果默认参数都可接受，则我们的方法可以在不产生JavaScript错误的情况下调用：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Callback functions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调函数
- en: Of course, some method parameters can be more complicated than a simple numeric
    value. One common parameter type we have seen frequently throughout the jQuery
    API is the callback function. The callback function can lend flexibility to a
    plugin without requiring a great deal of preparation when creating the plugin.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有些方法参数可能比简单的数字值更复杂。 我们在整个jQuery API中经常看到的一种常见参数类型是回调函数。 回调函数可以为插件提供灵活性，而无需在创建插件时进行大量准备。
- en: 'To use a callback function in our method, we need to simply accept the function
    object as a parameter and call that function wherever appropriate in our method
    implementation. As an example, we can extend our text shadow method to allow the
    user to customize the position of the shadow relative to the text:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的方法中使用回调函数，我们只需将函数对象作为参数接受，并在我们的方法实现中适当地调用该函数。 例如，我们可以扩展我们的文本阴影方法，以允许用户自定义阴影相对于文本的位置：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Listing 8.14
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.14
- en: 'Each slice of the shadow has a different offset from the original text. Previously,
    this offset has simply been equal to the index of the copy. Now, though, we''re
    calculating the offset using the `copyOffset()` function, which is an option that
    the user can override. So, for example, we could provide negative values for the
    offset in both dimensions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影的每个片段与原始文本的偏移量不同。 以前，此偏移量仅等于副本的索引。 但是，现在，我们正在使用`copyOffset（）`函数计算偏移量，该函数是用户可以覆盖的选项。
    因此，例如，我们可以为两个维度的偏移提供负值：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will cause the shadow to be cast up and to the left-hand side rather than
    down and to the right-hand side:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致阴影向左上方投射，而不是向右下方：
- en: '![](img/5297_08_06.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_08_06.png)'
- en: The callback allows simple modifications to the shadow's direction, or much
    more sophisticated positioning if the plugin user supplies the appropriate callback.
    If the callback is not specified, then the default behavior is once again used.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数允许简单修改阴影的方向，或者如果插件用户提供了适当的回调，则允许更复杂的定位。 如果未指定回调，则再次使用默认行为。
- en: Customizable defaults
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可定制的默认值
- en: We can improve the experience of using our plugins by providing reasonable default
    values for our method parameters, as we have seen. However, sometimes it can be
    difficult to predict what a reasonable default value will be. If a script author
    needs to call our plugin multiple times with a different set of parameters than
    we set as the defaults, the ability to customize these defaults could significantly
    reduce the amount of code that needs to be written.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为我们的方法参数提供合理的默认值，我们可以改善使用插件的体验，正如我们所见。 但是，有时很难预测什么是合理的默认值。 如果脚本作者需要多次调用我们的插件，并且需要不同于我们设置的默认值的参数集，那么自定义这些默认值的能力可能会显着减少需要编写的代码量。
- en: 'To make the defaults customizable, we need to move them out of our method definition
    and into a location that is accessible by outside code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使默认值可定制，我们需要将它们从我们的方法定义中移出，并放入可由外部代码访问的位置：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Listing 8.15
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.15
- en: 'The defaults are now in the namespace of the shadow plugin, and can be directly
    referred to with `$.fn.shadow.defaults`. Now, code that uses our plugin can change
    the defaults that all subsequent calls to `.shadow()` will use. Options can also
    still be supplied at the time the method is invoked:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值现在在阴影插件的命名空间中，并且可以直接使用 `$.fn.shadow.defaults` 引用。现在，使用我们的插件的代码可以更改所有后续对 `.shadow()`
    的调用所使用的默认值。选项也仍然可以在调用方法时提供：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This script will create a shadow using `10` copies of the element, because
    that is the new default value, but will also cast the shadow to the left-hand
    side and down due to the `copyOffset` callback that is provided along with the
    method call:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将使用 `10` 个元素的副本创建一个阴影，因为这是新的默认值，但也会通过提供的 `copyOffset` 回调将阴影投射到左侧和向下：
- en: '![](img/5297_08_07.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_08_07.png)'
- en: Creating plugins with the jQuery UI widget factory
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jQuery UI 小部件工厂创建插件。
- en: As we saw in [Chapter 7](e101ee08-ea8f-40f0-966c-e00b6af852ed.xhtml), *Using
    Plugins*, jQuery UI has an assortment of widgets--plugins that present a particular
    kind of UI element, such as a button or slider. These widgets present a consistent
    API to JavaScript programmers. This consistency makes learning to use one easy.
    When a plugin that we're writing will create a new user interface element, extending
    the jQuery UI library with a widget plugin is often the right choice.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 7 章](e101ee08-ea8f-40f0-966c-e00b6af852ed.xhtml)中看到的，*使用插件*，jQuery UI
    有各种各样的小部件--呈现特定类型的 UI 元素的插件，如按钮或滑块。这些小部件向 JavaScript 程序员提供一致的 API。这种一致性使得学习使用其中一个变得容易。当我们编写的插件将创建一个新的用户界面元素时，通过使用小部件插件扩展
    jQuery UI 库通常是正确的选择。
- en: A widget is an intricate piece of functionality, but fortunately we are not
    left to our own devices in creating one. The jQuery UI core contains a `factory`
    method called `$.widget()`, which does a lot of the work for us. Using this factory
    will help ensure that our code meets the API standards shared by all jQuery UI
    widgets.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件是一段复杂的功能，但幸运的是我们不需要自己创建。jQuery UI 核心包含一个名为 `$.widget()` 的 `factory` 方法，它为我们做了很多工作。使用这个工厂将有助于确保我们的代码符合所有
    jQuery UI 小部件共享的 API 标准。
- en: 'Plugins we create using the widget factory have many nice features. We get
    all of these perks (and more) with very little effort on our part:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小部件工厂创建的插件具有许多不错的功能。我们只需很少的努力就能得到所有这些好处（以及更多）：
- en: The plugin becomes **stateful**, meaning that we can examine, alter, or even
    completely reverse the effects of the plugin after it has been applied
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件变得 **有状态**，这意味着我们可以在应用插件后检查、修改或甚至完全撤销插件的效果。
- en: User-supplied options are merged with customizable default options automatically
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户提供的选项会自动与可定制的默认选项合并。
- en: Multiple plugin methods are seamlessly combined into a single jQuery method,
    accepting a string to identify which submethod is being called
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个插件方法被无缝地合并为单个 jQuery 方法，接受一个字符串来标识调用哪个子方法。
- en: Custom event handlers triggered by the plugin get access to the widget instance's
    data
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件触发的自定义事件处理程序可以访问小部件实例的数据。
- en: In fact, these advantages are so nice that we may wish to use the widget factory
    to construct any suitably complex plugin, UI-related or otherwise.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些优势非常好，以至于我们可能希望使用小部件工厂来构建任何合适复杂的插件，无论是 UI 相关的还是其他的。
- en: Creating a widget
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个小部件。
- en: For our example, we'll craft a plugin that adds custom tooltips to elements.
    A simple tooltip implementation creates a `<div>` container for each element on
    the page that gets a tooltip and positions that container next to the element
    when the mouse cursor hovers over the target.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的示例为例，我们将制作一个插件，为元素添加自定义工具提示。一个简单的工具提示实现会为页面上每个要显示工具提示的元素创建一个 `<div>` 容器，并在鼠标光标悬停在目标上时将该容器定位在元素旁边。
- en: The jQuery UI library contains its own built-in tooltip widget that is more
    advanced than the one we'll develop here. Our new widget will override the built-in
    `.tooltip()` method, which is not something we would likely do in a real project,
    but it will allow us to demonstrate several important concepts without needless
    complexity.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery UI 库包含其自己内置的高级工具提示小部件，比我们将在这里开发的更为先进。我们的新小部件将覆盖内置的 `.tooltip()` 方法，这不是我们在实际项目中可能做的事情，但它将允许我们演示几个重要的概念而不会增加不必要的复杂性。
- en: A jQuery UI plugin is created by the widget factory each time `$.widget()` is
    called. This function accepts the name of the widget and an object containing
    widget properties. The name of the widget must be namespaced; we'll use the namespace
    `ljq` and the plugin name `tooltip`. As a result, our plugin will be invoked by
    calling `.tooltip()` on a jQuery object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`$.widget()`时，小部件工厂都会创建一个jQuery UI插件。此函数接受小部件的名称和包含小部件属性的对象。小部件的名称必须被命名空间化；我们将使用命名空间`ljq`和插件名称`tooltip`。因此，我们的插件将通过在jQuery对象上调用`.tooltip()`来调用。
- en: 'The first widget property we''ll define is `._create()`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个小部件属性我们将定义为`._create()`：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Listing 8.16
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.16
- en: This property is a function that will be invoked by the widget factory whenever
    `.tooltip()` is called, once per matched element in the jQuery object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性是一个函数，当调用`.tooltip()`时，小部件工厂将每匹配一个元素在jQuery对象中调用一次。
- en: Widget properties, such as `_create`, which begin with an underscore, are considered
    private. We will discuss public functions later.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件属性，如`_create`，以下划线开头，被认为是私有的。我们稍后将讨论公共函数。
- en: Inside this creation function, we set up our tooltip for future displaying.
    To do this, we make the new `<div>` element and add it to the document. We're
    storing the created element in `this._tooltipDiv` for later use.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个创建函数内部，我们设置了我们的提示以便未来显示。为此，我们创建了新的`<div>`元素并将其添加到文档中。我们将创建的元素存储在`this._tooltipDiv`中以备后用。
- en: In the context of our function, `this` refers to the current widget instance
    and we can add whatever properties we want to this object. The object has some
    built-in properties that can be handy for us as well; in particular, `this.element`
    gives us a jQuery object pointing to the element that was originally selected.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的函数上下文中，`this`指的是当前小部件实例，我们可以向该对象添加任何属性。该对象还具有一些内置属性，对我们也很方便；特别是，`this.element`给了我们一个指向最初选定的元素的jQuery对象。
- en: We use `this.element` to bind the `mouseenter` and `mouseleave` handlers to
    the tooltip trigger element. We need these handlers to open the tooltip when the
    mouse begins hovering over the trigger and to close it when the mouse leaves.
    Note that the events are namespaced with the name of our plugin. As we discussed
    in [Chapter 3](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml), *Handling Events*,
    namespacing makes it easier for us to add and remove event handlers without stepping
    on the toes of other code that also wants to bind handlers to the elements.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`this.element`将`mouseenter`和`mouseleave`处理程序绑定到提示触发元素上。我们需要这些处理程序在鼠标开始悬停在触发器上时打开提示，并在鼠标离开时关闭它。请注意，事件名称被命名空间化为我们的插件名称。正如我们在[第三章](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml)中讨论的*处理事件*，命名空间使我们更容易添加和删除事件处理程序，而不会影响其他代码也想要绑定处理程序到元素上。
- en: 'Next, we need to define the `._open()` and `._close()` methods that we bound
    to the `mouseenter` and `mouseleave` handlers:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义绑定到`mouseenter`和`mouseleave`处理程序的`._open()`和`._close()`方法：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Listing 8.17
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.17
- en: The `._open()` and `._close()` methods themselves are self-explanatory. These
    are not special names, but rather illustrate that we can create whatever private
    functions we need within our widget, so long as their names begin with underscores.
    When the tooltip is opened, we position it with CSS and show it; when it is closed,
    we simply hide it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`._open()`和`._close()`方法本身是不言自明的。这些不是特殊名称，而是说明我们可以在我们的小部件中创建任何私有函数，只要它们的名称以下划线开头。当提示被打开时，我们用CSS定位它并显示它；当它关闭时，我们只需隐藏它。'
- en: During the opening process, we need to populate the tooltip with information.
    We're using the `.data()` method for this, which can get and set arbitrary data
    associated with any element. In this case, we are using the method to fetch the
    value of the `data-tooltip-text` attribute of each element.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开过程中，我们需要填充提示信息。我们使用`.data()`方法来做到这一点，它可以获取和设置与任何元素关联的任意数据。在这种情况下，我们使用该方法来获取每个元素的`data-tooltip-text`属性的值。
- en: 'With our plugin in place, the code `$(''a'').tooltip()` will cause a tooltip
    to be displayed when the mouse is over any anchor:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的插件，代码`$('a').tooltip()`将导致鼠标悬停在任何锚点上时显示提示：
- en: '![](img/5297_08_08.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_08_08.png)'
- en: The plugin, thus far, is not very long, but densely packed with sophisticated
    concepts. To make this sophistication pay off, the first thing we can do is to
    make our widget stateful. The widget's state will allow users to enable and disable
    it as needed, or even destroy it entirely after creation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，插件并不是很长，但是密集地包含了复杂的概念。为了让这种复杂性发挥作用，我们可以做的第一件事就是使我们的小部件具有状态。小部件的状态将允许用户根据需要启用和禁用它，甚至在创建后完全销毁它。
- en: Destroying widgets
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁小部件
- en: We've seen that the widget factory creates a new jQuery method, in our case
    called `.tooltip()`, that can be called with no arguments to apply the widget
    to a set of elements. There's much more that this method can do, though. When
    we give this method a string argument, it calls the method with the appropriate
    name.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，小部件工厂创建了一个新的 jQuery 方法，在我们的案例中称为 `.tooltip()`，可以不带参数调用以将小部件应用于一组元素。不过，这个方法还可以做更多的事情。当我们给这个方法一个字符串参数时，它会调用相应名称的方法。
- en: 'One of the built-in methods is called `destroy`. Calling `.tooltip(''destroy'')` will
    remove the tooltip widget from the page. The widget factory does most of the work,
    but if we have modified parts of the document inside `._create()` (as we have
    here, by creating the tooltip text `<div>`), we need to clean up after ourselves:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 内置方法之一称为 `destroy`。调用 `.tooltip('destroy')` 将从页面中删除提示小部件。小部件工厂会完成大部分工作，但如果我们在
    `._create()` 中修改了文档的某些部分（正如我们在这里所做的，通过创建提示文本 `<div>`），我们需要自己清理：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Listing 8.18
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.18
- en: This new code is added as a new property of the widget. The function undoes
    the modifications we performed, then calls the prototype's version of destroy
    so that the automatic cleanup occurs. The `_super()` and `_superApply()` methods
    call the base widget methods of the same name. It's always a good idea to do this,
    so that the proper initialization actions in the base widget are performed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码被添加为小部件的一个新属性。该函数撤销了我们所做的修改，然后调用原型的 destroy 版本，以便自动清理发生。 `_super()` 和 `_superApply()`
    方法调用了同名的基础小部件方法。这样做总是一个好主意，这样基础小部件中的适当初始化操作就会执行。
- en: Note that destroy is not preceded with an underscore; this is a `public` method
    that we can call with `.tooltip('destroy')`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 destroy 前面没有下划线；这是一个 `public` 方法，我们可以用 `.tooltip('destroy')` 调用它。
- en: Enabling and disabling widgets
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用和禁用小部件
- en: 'In addition to being destroyed completely, any widget can be temporarily disabled
    and later re-enabled. The base widget methods, `enable` and `disable`, help us
    by setting the value of `this.options.disabled` to `true` or `false` as appropriate.
    All we have to do to support these methods is to check this value before our widget
    takes any action:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了完全销毁之外，任何小部件都可以被暂时禁用，稍后重新启用。基础小部件方法 `enable` 和 `disable` 通过将 `this.options.disabled`
    的值设置为 `true` 或 `false` 来帮助我们。我们所要做的就是在我们的小部件采取任何行动之前检查这个值：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Listing 8.19
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.19
- en: With this extra check in place, the tooltips stop displaying once `.tooltip('disable')`
    is called and display once again after `.tooltip('enable')` is invoked.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个额外的检查放置后，一旦调用 `.tooltip('disable')`，提示就停止显示，并且在调用 `.tooltip('enable')` 之后再次显示。
- en: Accepting widget options
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受小部件选项
- en: 'Now it''s time to make our widget customizable. As we saw when constructing
    the `.shadow()` plugin, it''s friendly to provide a customizable set of defaults
    for a widget, and then to override those defaults with options the user specifies.
    Nearly all of the work in this process is performed by the widget factory. All
    we need to do is to provide an `options` property:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使我们的小部件可定制了。就像我们在构建 `.shadow()` 插件时看到的那样，为小部件提供一组可定制的默认值并用用户指定的选项覆盖这些默认值是友好的。几乎所有这个过程中的工作都是由小部件工厂完成的。我们所需要做的就是提供一个
    `options` 属性：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Listing 8.20
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.20
- en: The `options` property is a plain object. All the valid options for our widget
    should be represented, so that none of them are mandatory for the user to provide.
    Here we're supplying x and y coordinates for the tooltip relative to its trigger
    element, as well as a function that generates the tooltip text for each element.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`options` 属性是一个普通对象。我们的小部件的所有有效选项都应该被表示出来，这样用户就不需要提供任何强制性的选项。在这里，我们为提示相对于其触发元素的
    x 和 y 坐标提供了一个函数，以及一个为每个元素生成提示文本的函数。'
- en: 'The only piece of our code that needs to examine these options is `._open()`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中唯一需要检查这些选项的部分是 `._open()`：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Listing 8.21
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.21
- en: 'Inside the `_open` method, we can access these properties using `this.options`.
    We will always get the correct value for the option this way: the default value
    or the overridden value if the user has provided one.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_open`方法内部，我们可以使用`this.options`访问这些属性。通过这种方式，我们总是能够得到选项的正确值：默认值或者用户提供的覆盖值。
- en: 'We can still add our widget without arguments, such as `.tooltip()`, and get
    the default behavior. Now we can supply options that override the default behavior:
    `.tooltip({ offsetX: -10, offsetX: 25 })`. The widget factory even lets us change
    these options after the widget is instantiated: `.tooltip(''option'', ''offsetX'',
    20)`. The next time the option is accessed, we will see the new value.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '我们仍然可以像`.tooltip()`这样无参数地添加我们的小部件，并获得默认行为。现在我们可以提供覆盖默认行为的选项：`.tooltip({ offsetX:
    -10, offsetX: 25 })`。小部件工厂甚至让我们在小部件实例化后更改这些选项：`.tooltip(''option'', ''offsetX'',
    20)`。下次访问选项时，我们将看到新值。'
- en: Reacting to option changes
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对选项更改做出反应
- en: If we need to immediately react to an option change, we can add a `_setOption`
    function to our widget that handles the change and then calls the default implementation
    of `_setOption`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要立即对选项更改做出反应，我们可以在小部件中添加一个`_setOption`函数来处理更改，然后调用`_setOption`的默认实现。
- en: Adding methods
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加方法
- en: 'The built-in methods are convenient, but often we will want to expose more
    hooks to the users of our plugin, as we''ve done with the built-in `destroy` method.
    We''ve already seen how to create new private functions inside our widget. Creating
    public methods is just the same, except that the widget property names do not
    begin with an underscore. We can use this to create methods that manually open
    and close the tooltip quite simply:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 内置方法很方便，但通常我们希望向插件的用户公开更多的钩子，就像我们使用内置的`destroy`方法所做的那样。我们已经看到如何在小部件内部创建新的私有函数。创建公共方法也是一样的，只是小部件属性的名称不以下划线开头。我们可以利用这一点很简单地创建手动打开和关闭工具提示的方法：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Listing 8.22
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.22
- en: That's it! By adding public methods that call the private functions, we can
    now open a tooltip with `.tooltip('open')` and close it with `.tooltip('close')`.
    The widget factory even takes care of details for us like ensuring that chaining
    continues to work even if we don't return anything from our method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！通过添加调用私有函数的公共方法，我们现在可以使用`.tooltip('open')`打开工具提示，并使用`.tooltip('close')`关闭它。小部件工厂甚至会为我们处理一些细节，比如确保链式调用继续工作，即使我们的方法不返回任何东西。
- en: Triggering widget events
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发小部件事件
- en: 'A great plugin not only extends jQuery, but also offers plenty of opportunities
    for other code to extend the plugin itself. One simple way to offer this extensibility
    is to support a set of custom events related to the plugin. The widget factory
    makes this process straightforward:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优秀的插件不仅扩展了 jQuery，而且还为其他代码提供了许多扩展插件本身的机会。提供这种可扩展性的一个简单方法是支持与插件相关的一组自定义事件。小部件工厂使这个过程变得简单：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Listing 8.23
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.23
- en: Calling `this._trigger()` in one of our functions allows code to listen for
    the new custom event. The event's name will be prefixed with our widget name,
    so we don't have to worry much about conflicts with other events. If we call `this._trigger('open')`
    in our tooltip's opening function, for example, the event called `tooltipopen`
    will be issued each time the tooltip opens. We can listen for this event by calling
    `.on('tooltipopen')` on the element.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的函数中调用`this._trigger()`允许代码监听新的自定义事件。事件的名称将以我们的小部件名称为前缀，因此我们不必过多担心与其他事件的冲突。例如，在我们的工具提示打开函数中调用`this._trigger('open')`，每次工具提示打开时都会发出名为`tooltipopen`的事件。我们可以通过在元素上调用`.on('tooltipopen')`来监听此事件。
- en: This only scratches the surface of what's possible with a full-fledged widget
    plugin, but gives us the tools we need to build a widget that has the features
    and conforms to the standards that jQuery UI users have come to expect.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是揭示了一个完整的小部件插件可能具有的潜力，但给了我们构建一个具有 jQuery UI 用户所期望的功能和符合标准的小部件所需的工具。
- en: Plugin design recommendations
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件设计建议
- en: 'Now that we have examined common ways to extend jQuery and jQuery UI by creating
    plugins, we can review and supplement what we''ve learned with a list of recommendations:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经研究了通过创建插件来扩展 jQuery 和 jQuery UI 的常见方式，我们可以回顾并补充我们学到的内容，列出一些建议：
- en: Protect the dollar (`$`) alias from potential interference from other libraries
    by using `jQuery` instead or passing `$` into an IIFE, so that it can be used
    as a local variable.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`jQuery`或将`$`传递给IIFE来保护`$`别名免受其他库的潜在干扰，以便它可以用作局部变量。
- en: Whether extending the jQuery object with `$.myPlugin` or the jQuery prototype
    with `$.fn.myPlugin`, add no more than one property to the `$` namespace. Additional
    public methods and properties should be added to the plugin's namespace (for example,
    `$.myPlugin.publicMethod` or `$.fn.myPlugin.pluginProperty`).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论是扩展 jQuery 对象与 `$.myPlugin` 还是扩展 jQuery 原型与 `$.fn.myPlugin`，都不要向 `$` 命名空间添加超过一个属性。额外的公共方法和属性应添加到插件的命名空间中（例如，`$.myPlugin.publicMethod`
    或 `$.fn.myPlugin.pluginProperty`）。
- en: 'Provide an object containing default options for the plugin: `$.fn.myPlugin.defaults
    = {size: ''large''}`.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '提供包含插件默认选项的对象：`$.fn.myPlugin.defaults = {size: ''large''}`。'
- en: 'Allow the plugin user to optionally override any of the default settings for
    all subsequent calls to the method (`$.fn.myPlugin.defaults.size = ''medium'';`)
    or for a single call (`$(''div'').myPlugin({size: ''small''});`).'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '允许插件用户选择性地覆盖所有后续调用方法的默认设置（`$.fn.myPlugin.defaults.size = ''medium'';`）或单个调用的默认设置（`$(''div'').myPlugin({size:
    ''small''});`）。'
- en: In most cases when extending the jQuery prototype `($.fn.myPlugin`), return
    `this` to allow the plugin user to chain additional jQuery methods to it (for
    example, `$('div').myPlugin().find('p').addClass('foo')`).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，当扩展 jQuery 原型时（`$.fn.myPlugin`），返回 `this` 以允许插件用户将其他 jQuery 方法链接到它（例如，`$('div').myPlugin().find('p').addClass('foo')`）。
- en: When extending the jQuery prototype (`$.fn.myPlugin`), enforce implicit iteration
    by calling `this.each()`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当扩展 jQuery 原型时（`$.fn.myPlugin`），通过调用 `this.each()` 强制隐式迭代。
- en: Use callback functions when appropriate to allow for flexible modification of
    the plugin's behavior without having to change the plugin's code.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当的情况下使用回调函数，以允许灵活修改插件的行为，而无需更改插件的代码。
- en: If the plugin calls for user interface elements or needs to track elements'
    state, create it with the jQuery UI widget factory.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果插件需要用户界面元素或需要跟踪元素状态，请使用 jQuery UI 小部件工厂创建。
- en: Maintain a set of automated unit tests for the plugin with a testing framework
    such as QUnit to ensure that it works as expected. See Appendix A for more information
    about QUnit.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像 QUnit 这样的测试框架为插件维护一组自动化单元测试，以确保其按预期工作。有关 QUnit 的更多信息，请参见附录 A。
- en: Use a version control system such as Git to track revisions to the code. Consider
    hosting the plugin publicly on GitHub ([http://github.com/](http://github.com/))
    and allowing others to contribute.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用诸如 Git 等版本控制系统跟踪代码的修订。考虑在 GitHub（[http://github.com/](http://github.com/)）上公开托管插件，并允许其他人贡献。
- en: If making the plugin available for others to use, make the licensing terms clear.
    Consider using the MIT license, which jQuery also uses.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要使插件可供他人使用，请明确许可条款。考虑使用 MIT 许可证，jQuery 也使用此许可证。
- en: Distributing a plugin
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发插件
- en: By following the previous recommendations, we can produce a clean, maintainable
    plugin that follows time-tested conventions. If it performs a useful, reusable
    task, we may want to share it with the jQuery community.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循前述建议，我们可以制作出符合经过时间考验的传统的干净、可维护的插件。如果它执行一个有用的、可重复使用的任务，我们可能希望与 jQuery 社区分享。
- en: In addition to properly preparing plugin code as defined earlier, we should
    be sure to adequately document the operation of the plugin prior to distribution.
    We can choose a documentation format that suits our style, but may want to consider
    a standard such as JSDoc (described at [http://usejsdoc.org/](http://usejsdoc.org/)).
    Several automatic documentation generators, including docco ([http://jashkenas.github.com/docco/](http://jashkenas.github.com/docco/))
    and dox ([https://github.com/visionmedia/dox](https://github.com/visionmedia/dox))
    are available. Regardless of format, we must ensure that our documentation covers
    every parameter and option available for use with our plugin's methods.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除了按照早前定义的方式正确准备插件代码之外，我们还应该在分发之前充分记录插件的操作。我们可以选择适合我们风格的文档格式，但可能要考虑一种标准，比如 JSDoc（在
    [http://usejsdoc.org/](http://usejsdoc.org/) 中描述）。有几种自动文档生成器可用，包括 docco（[http://jashkenas.github.com/docco/](http://jashkenas.github.com/docco/)）和
    dox（[https://github.com/visionmedia/dox](https://github.com/visionmedia/dox)）。无论格式如何，我们都必须确保我们的文档涵盖了插件方法可用的每个参数和选项。
- en: Plugin code and documentation can be hosted anywhere; npm ([https://www.npmjs.com/](https://www.npmjs.com/))
    is the standard option. For more information about publishing jQuery plugins as
    npm packages, take a look at this page: [http://blog.npmjs.org/post/112064849860/using-jquery-plugins-with-npm](http://blog.npmjs.org/post/112064849860/using-jquery-plugins-with-npm).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 插件代码和文档可以托管在任何地方；npm（[https://www.npmjs.com/](https://www.npmjs.com/)）是标准选项。有关将jQuery插件发布为npm软件包的更多信息，请查看此页面：[http://blog.npmjs.org/post/112064849860/using-jquery-plugins-with-npm](http://blog.npmjs.org/post/112064849860/using-jquery-plugins-with-npm)。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how the functionality that is provided by the
    jQuery core need not limit the library's capabilities. In addition to the readily
    available plugins we explored in [Chapter 7](e101ee08-ea8f-40f0-966c-e00b6af852ed.xhtml),
    *Using Plugins*, we now know how to extend the menu of features ourselves.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到jQuery核心提供的功能不必限制库的功能。除了我们在[第7章](e101ee08-ea8f-40f0-966c-e00b6af852ed.xhtml)*使用插件*中探讨的现成插件外，我们现在知道如何自己扩展功能菜单。
- en: The plugins we've created contain various features, including global functions
    that use the jQuery library, new methods of the jQuery object for acting on DOM
    elements, and sophisticated jQuery UI widgets. With these tools at our disposal,
    we can shape jQuery--and our own JavaScript code--into whatever form we desire.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的插件包含各种功能，包括使用jQuery库的全局函数、用于操作DOM元素的jQuery对象的新方法以及复杂的jQuery UI小部件。有了这些工具，我们可以塑造jQuery和我们自己的JavaScript代码，使其成为我们想要的任何形式。
- en: Exercises
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The challenge exercises may require the use of the official jQuery documentation
    at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战练习可能需要使用[http://api.jquery.com/](http://api.jquery.com/)上的官方jQuery文档。
- en: Create new plugin methods called `.slideFadeIn()` and `.slideFadeOut()`, combining
    the opacity animations of `.fadeIn()` and `.fadeOut()` with the height animations
    of `.slideDown()` and `.slideUp()`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`.slideFadeIn()`和`.slideFadeOut()`的新插件方法，将`.fadeIn()`和`.fadeOut()`的不透明度动画与`.slideDown()`和`.slideUp()`的高度动画结合起来。
- en: Extend the customizability of the `.shadow()` method so that the z-index of
    the cloned copies can be specified by the plugin user.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展`.shadow()`方法的可定制性，以便插件用户可以指定克隆副本的z-index。
- en: Add a new submethod called `isOpen` to the tooltip widget. This submethod should
    return `true` if the tooltip is currently displayed and `false` otherwise.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为工具提示小部件添加一个名为`isOpen`的新子方法。该子方法应该在工具提示当前显示时返回`true`，否则返回`false`。
- en: Add code that listens for the `tooltipopen` event that our widget fires and
    logs a message to the console.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加监听我们小部件触发的`tooltipopen`事件的代码，并在控制台中记录一条消息。
- en: '**Challenge**: Provide an alternative `content` option for the tooltip widget
    that fetches the content of the page that an anchor''s `href` points to via Ajax,
    and displays that content as the tooltip text.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**挑战**：为工具提示小部件提供一个替代的`content`选项，该选项通过Ajax获取锚点的`href`指向页面的内容，并将该内容显示为工具提示文本。'
- en: '**Challenge**: Provide a new `effect` option for the tooltip widget that, if
    specified, applies the named jQuery UI effect (such as `explode`) to the showing
    and hiding of the tooltip.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**挑战**：为工具提示小部件提供一个新的`effect`选项，如果指定了，将应用指定的jQuery UI效果（比如`explode`）来显示和隐藏工具提示。'
