- en: Testing and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is crucial to building production-ready applications. In unit tests,
    we test a component independent of external sources to make sure it works as expected.
    Angular 2 has testing capabilities bundled with it out of the box. In this chapter,
    we will take a look at performing unit test on the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular 2 testing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the tools that aid testing in Angular 2 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Karma
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protractor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular 2 testing platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a deeper look at each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jasmine is an open source testing framework. It uses behavior-driven notation
    that brings about improved testing.
  prefs: []
  type: TYPE_NORMAL
- en: Main concepts of Jasmine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dig into so practical testing cases, here are some Jasmine concepts
    you should know:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Suites**: These are written in and described by the `describe` blocks. They
    appear in the form of functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spec definitions**: `it (string, function)` functions. The body of this function
    holds the actual assertions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expectations**: These are assertions that evaluate to a Boolean value. This
    is used to see if an input is equal to the expected value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matchers**:  These are helpers for common assertions, for example, `toB0` (expected),
    `toEqual` (expected).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Karma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Karma is a JavaScript test runner created by the Angular team. Karma can be
    a part of the continuous integration processes for a project as well as a part
    of its development.
  prefs: []
  type: TYPE_NORMAL
- en: Protractor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protractor is an end-to-end test framework for Angular applications. With Protractor,
    you can set up expectations and test against our assumptions. As the name implies,
    end-to-end tests not only ensure that the system works by itself but also validates
    its functionality with external systems. They explore the application as the end
    user experiences it.
  prefs: []
  type: TYPE_NORMAL
- en: Angular testing platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular testing platform is used to test the interaction of classes with Angular
    and the DOM. Angular testing platform gives us liberty to examine an instance
    of a class without any dependence on Angular or injected values.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be focusing on Jasmine and Karma for testing.
  prefs: []
  type: TYPE_NORMAL
- en: When a new project is created using Angular-CLI, the `e2e` folder containing
    the end-to-end tests using Protractor is also created, along with the `karma.conf.js` and
    `protractor.conf.js` files, which are the configuration files for Karma and Protractor
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Using Karma (with Jasmine)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Karma, you can test your code while running your application because Karma
    creates a browser environment for testing. Besides your browser, you can also
    test your code in other devices, such as phones and tablets.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine is a behavior-driven development framework for testing the JavaScript
    code. Being dependency free, Jasmine doesn't require a DOM and is often used together
    with Karma. We will now proceed to create a new project and test its elements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a new project named `Angular-test` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing the Karma CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install the Karma CLI, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test will be executed in a `.spec.ts` file. Create a new test file (`sampletest.spec.ts`)
    in the `./app/` folder and copy the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first write a sample test to showcase the main concepts
    in Jamine. We create a test suite, define our test suite, and write the expectations.
    In the sample test, we do a simple check to see that `true` is the same as `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also write a simple test for `AppComponent`. We expect the component to
    have a `hello` property that is equal to `Hello, World`. Let''s ensure that the
    test passes by updating `app.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have satisfied Karma's configuration by creating the file with the `.spec.ts` extension.
  prefs: []
  type: TYPE_NORMAL
- en: You can test several components as well. For example, when you create new components
    through Angular CLI, it automatically creates the test files (`.spec.ts`) for
    the components, which do nothing but test whether the components are working correctly
    together with the other components. For Angular, the convention is to have a `.spec.ts`
    file for each `.ts` file. The files are run using the Jasmine JavaScript test
    framework through the Karma task runner when you use the `ng test` command.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Karma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to configure our Karma, we need to update the `karma.conf.js` file.
    The default one has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are showing that the PhantomJS browser will be used; Jasmine testing
    framework and Webpack will be used for bundling the files.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are the centerpiece of Angular. They are the nucleus around which
    the rest of the framework is built. We'll explore what a component is, why it
    is important, and how to test it.
  prefs: []
  type: TYPE_NORMAL
- en: Our testing strategy revolves around verifying the correctness of the properties
    and methods of the classes that make up the components.
  prefs: []
  type: TYPE_NORMAL
- en: When writing unit tests for components, we initialize the component and inject
    any dependencies manually rather than bootstrapping the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `TestBed` function will be used for testing the component, which is the
    main entry to all of Angular's testing interface. It will enable us to create
    our components for use in running unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestBed` is the primary API for writing unit tests for Angular applications
    and libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component named `sample`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This automatically generates the `.ts` and `.spec.ts` files. We will also add
    some tests to the generated `.spec.ts` file to get a hang of how the testing works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the updated test spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `createComponent` method in `TestBed` creates an instance of the component.
    These tests tell Angular when to perform change detection through `fixture.detectChanges()`
    (which we received from `createComponent`). `TestBed.createComponent`, by default,
    doesn't trigger the change detection. This is why specific parts in our test won't
    show the changes on the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making use of `ComponentFixtureAutoDetect` from `@angular/core/testing` enables
    you to apply auto detection globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Testing services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a sample service. Our service has only one method that returns
    an array of the available users for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We instantiate the service using the `beforeEach` method. This is a good practice
    even if we only have one spec. We are checking each individual user and the total
    count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Testing using HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a `users.serviceHttp.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case it uses `http.get()` to fetch the data from a JSON file. We then
    used `Observable.map()` to transform the response into the final result using
    `json()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference that exists between this test and the previous one is the use
    of an asynchronous test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Testing using MockBackend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A more sensible approach is to replace HTTP calls with a MockBackend. For doing
    this, we can use the `beforeEach()` method. This will allow us to mock our responses
    and avoid hitting the real backend, thereby boosting our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We made our mocked response. So, when we finally make the call to our service,
    it gets the expected results.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The directive decorator in Angular is used to decorate a class that has the
    responsibility of extending components in the DOM, based on the defined methods
    and logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this directive that changes the background, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will be making use of an attribute directive, `logClicks`, which logs the
    number of clicks on the host element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `container` component. This will be our host, reproducing the
    events emitted by our directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the test spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `beforeEach` method is used to separate the logic for creating the component
    from the tests. DOM API is recommended and is used to trigger the click on the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pipes in Angular are functions that can transform input data into a user-readable
    format. Here is an example of a custom pipe called `capitalise` in our `src` folder,
    using the standard `String.toUpperCase()`. This is just an example; Angular already
    has its own pipe for capitalization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `capitalise.pipe.spec.ts` file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Augury is a Chrome extension for debugging Angular applications, just like Batarang
    was used for debugging Angular 1 apps. Once installed, the extension is seen as
    a dev tool plugin that has features for testing out your Angular app's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Augury
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Augury inspects and visualizes the component tree with different properties
    of one or more components. Install the Augury tools from the Augury Chrome extension
    page, ([https://chrome.google.com/webstore/detail/augury/elgalmkoelokbchhkhacckoklkejnhcd](https://chrome.google.com/webstore/detail/augury/elgalmkoelokbchhkhacckoklkejnhcd))
    and click on the ADD TO CHROME button. Once the installation is completed, the
    following steps need to be taken in order to work with Augury:'
  prefs: []
  type: TYPE_NORMAL
- en: Use *Ctrl* + *Shift* + *I* to open the Chrome Developer Tools window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on Augury to open the tool. It displays menu options such as Component
    Tree, Router Tree, and NgModules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Augury icon can be seen in the top-right corner of your browser once it
    is installed.
  prefs: []
  type: TYPE_NORMAL
- en: Open it and you will see a list of currently loaded components in your application,
    sorted by their hierarchy. You can also see where they are located in the DOM.
    Any change made to a component will also be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, it becomes easier for developers to get an insight on how their
    apps are performing and where the problems and bugs could be originating from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17bb4831-72e8-4616-a777-c4bb6fc873da.png)'
  prefs: []
  type: TYPE_IMG
- en: Augury features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at some of the Augury features in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Component tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the first view that is visible, which shows the loaded components belonging
    to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/e58b5b39-947e-488f-ae74-58e24c697d4c.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The component tree displays a hierarchical relationship of the components.
    More information about a component can also be shown by selecting each component:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/1ad9bd8c-856a-4eff-83d2-b40511d3c783.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Router tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The router tree displays information on how every component in your application
    tree is routed. It does this in a hierarchical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b88681df-420b-4e8e-ab85-bb7422aea80a.png)'
  prefs: []
  type: TYPE_IMG
- en: Source map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is noteworthy that the TypeScript code will show whether a source map file
    exists. In production, if no source map is found, only the compiled JavaScript
    code will be displayed, which may also be minified and difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on Inject Graph will display the dependency of components and services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/f9aaa886-20ea-4461-9cba-d00607c8b449.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that for the Augury debugging to work, the application has
    to be set to the development mode.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to do unit tests because they run faster and we'll be able to
    get feedback faster. A good advantage of testing is that it helps against regressions
    (the changes that break existing code).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging helps us identify and remove errors from our code. With Augury, developers
    can have visuals of the application through component trees and visual debugging
    tools. This makes debugging easier.
  prefs: []
  type: TYPE_NORMAL
