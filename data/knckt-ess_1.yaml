- en: Chapter 1. Refreshing the UI Automatically with KnockoutJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章 自动刷新 UI，使用 KnockoutJS
- en: If you are reading this book, it is because you have discovered that managing
    web user interfaces is quite complex. **DOM** (short for **Document Object Model**)
    manipulation using only native JavaScript is very hard. This is because each browser
    has its own JavaScript implementation. To solve this problem, different DOM manipulation
    libraries have been born in the last few years. The library most frequently used
    to manipulate the DOM is jQuery.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，那是因为你已经发现管理 web 用户界面是相当复杂的。 **DOM**（Document Object Model 的缩写）仅使用本地
    JavaScript 进行操作是非常困难的。这是因为每个浏览器都有自己的 JavaScript 实现。为了解决这个问题，过去几年中诞生了不同的 DOM 操作库。最常用于操作
    DOM 的库是 jQuery。
- en: It is increasingly common to find libraries that help developers to manage more
    and more features on the client side. As we have said, developers have obtained
    the possibility to manipulate the DOM easily and therefore to manage templates
    and format data. Also, these libraries provide developers with easy APIs to send
    and receive data from the server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越常见的是找到帮助开发人员在客户端管理越来越多功能的库。正如我们所说，开发人员已经获得了轻松操作 DOM 的可能性，因此可以管理模板和格式化数据。此外，这些库为开发人员提供了轻松的
    API 来发送和接收来自服务器的数据。
- en: However, DOM manipulation libraries don't provide us with mechanisms to synchronize
    input data with the models in our code. We need to write code that catches user
    actions and updates our models.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，DOM 操作库并不为我们提供同步输入数据与代码中模型的机制。我们需要编写代码来捕捉用户操作并更新我们的模型。
- en: 'When a problem occurs frequently in most projects, in almost all the cases,
    it can surely be solved in a similar way. It was then that libraries that manage
    the connection between the HTML files and JavaScript code began to appear. The
    pattern these libraries implement was named MV* (Model-View-Whatever). The asterisk
    can be changed by:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个问题在大多数项目中经常出现时，在几乎所有情况下，它肯定可以以类似的方式解决。然后，开始出现了管理 HTML 文件与 JavaScript 代码之间连接的库。这些库实现的模式被命名为
    MV*（Model-View-Whatever）。星号可以被更改为：
- en: Controller, MVC (for example, AngularJS)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器，MVC（例如，AngularJS）
- en: ViewModel, MVVM (for example, KnockoutJS)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ViewModel，MVVM（例如，KnockoutJS）
- en: Presenter (MVP) (for example, ASP.NET)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Presenter（MVP）（例如，ASP.NET）
- en: The library we are going to use in this book is Knockout. It uses view-models
    to bind data and HTML, so it uses the MVVM pattern to manage the data binding
    issue.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中我们要使用的库是 Knockout。它使用视图模型将数据和 HTML 进行绑定，因此它使用 MVVM 模式来管理数据绑定问题。
- en: In this chapter, you will learn the basic concepts of this library and you will
    begin a task to use Knockout in a real project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习这个库的基本概念，并开始在一个真实项目中使用 Knockout 的任务。
- en: KnockoutJS and the MVVM pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KnockoutJS 和 MVVM 模式
- en: '**KnockoutJS** is a very lightweight library (just 20 KB minified) that gives
    the ability to objects to become the nexus between views and models. It means
    that you can create rich interfaces with a clean underlying data model.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**KnockoutJS** 是一个非常轻量级的库（仅 20 KB 经过压缩），它赋予对象成为视图和模型之间的纽带的能力。这意味着你可以使用清晰的底层数据模型创建丰富的界面。'
- en: For this purpose, it uses declarative bindings to easily associate DOM elements
    with model data. This link between data and presentation layer (HTML) allows the
    DOM to refresh displayed values automatically.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，它使用声明性绑定来轻松将 DOM 元素与模型数据关联起来。数据与表示层（HTML）之间的这种链接允许 DOM 自动刷新显示的值。
- en: Knockout set up chains of relationships between model data to transform and
    combine it implicitly. Knockout is also trivially extensible. It is possible to
    implement custom behaviors as new declarative bindings. This allows the programmer
    to reuse them in a just few lines of code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 建立了模型数据之间的关系链，隐式地转换和组合它。Knockout 也是非常容易扩展的。可以将自定义行为实现为新的声明性绑定。这允许程序员在几行代码中重用它们。
- en: 'The advantages of using KnockoutJS are many:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 KnockoutJS 的优点有很多：
- en: It's free and open source.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是免费且开源的。
- en: It is built using pure JavaScript.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是使用纯 JavaScript 构建的。
- en: It can work together with other frameworks.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以与其他框架一起使用。
- en: It has no dependencies.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有依赖关系。
- en: It supports all mainstream browsers, even ancient ones such as IE 6+, Firefox
    3.5+, Chrome, Opera, and Safari (desktop/mobile).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持所有主流浏览器，甚至包括古老的 IE 6+、Firefox 3.5+、Chrome、Opera 和 Safari（桌面/移动）。
- en: It is fully documented with API docs, live examples, and interactive tutorials.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它完全有 API 文档、实时示例和交互式教程。
- en: 'Knockout''s function is specific: to join views and models. It doesn''t manage
    DOM or handle AJAX requests. For these purposes, I would recommend jQuery. Knockout
    gives us the freedom to develop our code the way we want.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout的功能很明确：连接视图和模型。它不管理DOM或处理AJAX请求。为了这些目的，我建议使用jQuery。 Knockout给了我们自由发展我们自己想要的代码。
- en: '![KnockoutJS and the MVVM pattern](img/7074OS_01_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![KnockoutJS和MVVM模式](img/7074OS_01_01.jpg)'
- en: MVVM-pattern diagram
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM模式图
- en: A real-world application – koCart
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个真实的应用程序—koCart
- en: In order to demonstrate how to use Knockout in a real application, we are going
    to build a simple shopping cart called koCart.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何在实际应用中使用Knockout，我们将构建一个名为koCart的简单购物车。
- en: 'First of all we are going to define the user stories. We just need a few sentences
    to know what we want to achieve, which are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义用户故事。我们只需要几句话来知道我们想要实现的目标，如下所示：
- en: The user should be able to view the catalog
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够查看目录
- en: We should have the ability to search the catalog
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该有能力搜索目录
- en: The user can click on a button to add items to the catalog
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以点击按钮将物品添加到目录中
- en: The application will allow us to add, update, and delete items from the catalog
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序将允许我们从目录中添加、更新和删除物品
- en: The user should be able to add, update, and delete items from the cart
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够向购物车中添加、更新和删除物品
- en: We will allow the user to update his personal information.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将允许用户更新他的个人信息。
- en: The application should be able to calculate the total amount in the cart
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该能够计算购物车中的总金额
- en: The user should be able to complete an order
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够完成订单
- en: 'Through user stories, we can see that our application has the following three
    parts:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用户故事，我们可以看到我们的应用程序有以下三个部分：
- en: The catalog, which contains and manages all the products we have in the shop.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录，包含和管理店内所有的商品。
- en: The cart, which has responsibility for calculating the price of each line and
    the total amount of the order.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车负责计算每行的价格和订单总额。
- en: The order, where the user can update his personal information and confirm the
    order.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单，用户可以在其中更新他的个人信息并确认订单。
- en: Installing components
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装组件
- en: To develop our real-world project, we need to install a few components and set
    up our first layout.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发我们的真实项目，我们需要安装一些组件并设置我们的第一个布局。
- en: 'These are all the components you need to download:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '这些都是你需要下载的组件:'
- en: 'Bootstrap: [https://github.com/twbs/bootstrap/releases/download/v3.2.0/bootstrap-3.2.0-dist.zip](https://github.com/twbs/bootstrap/releases/download/v3.2.0/bootstrap-3.2.0-dist.zip)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bootstrap: [https://github.com/twbs/bootstrap/releases/download/v3.2.0/bootstrap-3.2.0-dist.zip](https://github.com/twbs/bootstrap/releases/download/v3.2.0/bootstrap-3.2.0-dist.zip)'
- en: 'jQuery: [https://code.jquery.com/jquery-2.1.1.min.js](https://code.jquery.com/jquery-2.1.1.min.js)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'jQuery: [https://code.jquery.com/jquery-2.1.1.min.js](https://code.jquery.com/jquery-2.1.1.min.js)'
- en: 'KnockoutJS: [http://knockoutjs.com/downloads/knockout-3.2.0.js](http://knockoutjs.com/downloads/knockout-3.2.0.js)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'KnockoutJS: [http://knockoutjs.com/downloads/knockout-3.2.0.js](http://knockoutjs.com/downloads/knockout-3.2.0.js)'
- en: Since we just work on the client side in the first chapters, we can mock data
    in the client and will not need a server side for now. So we can choose any place
    in our computer to start our project. I recommend you use the environment you
    usually employ to do your projects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在前几章只在客户端工作，我们可以在客户端模拟数据，现在不需要服务器端。 所以我们可以选择我们通常用于项目的任何地方来开始我们的项目。 我建议您使用您通常用来做项目的环境。
- en: 'To start, we create a folder called `ko-cart` and then create three folders
    and a file inside it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`ko-cart`的文件夹，然后在其中创建三个文件夹和一个文件：
- en: In the `css` folder, we will put all our css.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`css`文件夹中，我们将放置所有的css。
- en: In the `js` folder, we will put all our JavaScript.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js`文件夹中，我们将放置所有的JavaScript。
- en: In the `fonts` folder, we will put all the font files needed by the Twitter
    Bootstrap framework.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`fonts`文件夹中，我们会放置Twitter Bootstrap框架所需的所有字体文件。
- en: Create an `index.html` file.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`index.html`文件。
- en: 'Now you should set up your files the same way as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该设置你的文件，就像以下截图所示：
- en: '![Installing components](img/7074OS_01_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![安装组件](img/7074OS_01_02.jpg)'
- en: The initial folder structure
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 初始文件夹结构
- en: 'Then we should set the content of the `index.html` file. Remember to set all
    the links to the files we will need using the `<script>` and `<link>` tags:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们应该设置`index.html`文件的内容。记得使用`<script>`和`<link>`标签设置所有我们需要的文件的链接：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With these lines of code, we have all we need to start our application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些行代码，我们就有了开始应用程序所需的一切。
- en: The view-model
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图-模型
- en: The **view-model** is a pure code representation of the data and operations
    on a UI. It isn't the UI itself. It doesn't have any concept of buttons or display
    styles. It's not the persisted data model either. It holds the unsaved data the
    user is working with. View-models are pure JavaScript objects that have no knowledge
    of HTML. Keeping the view-model abstract in this way lets it stay simple, so you
    can manage more sophisticated behaviors without getting lost.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图模型**是UI上的数据和操作的纯代码表示。它不是UI本身。它没有任何按钮或显示样式的概念。它也不是持久化的数据模型。它保存用户正在处理的未保存数据。视图模型是纯JavaScript对象，不了解HTML。以这种方式将视图模型保持抽象，让它保持简单，这样您就可以管理更复杂的行为而不会迷失。'
- en: 'To create a view-model, we just need to define a simple JavaScript object:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个视图模型，我们只需要定义一个简单的JavaScript对象：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then to activate Knockout, we will call the following line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后要激活Knockout，我们将调用以下行：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first parameter says which view-model object we want to use with the view.
    Optionally, we can pass a second parameter to define which part of the document
    we want to search for `data-bind` attributes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数指定我们要与视图一起使用的视图模型对象。可选地，我们可以传递第二个参数来定义我们想要搜索`data-bind`属性的文档的哪个部分。
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This restricts the activation to the element with `elementID` and its descendants,
    which is useful if we want to have multiple view-models and associate each with
    a different region of the page.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将限制激活到具有`elementID`及其后代的元素，这在我们想要有多个视图模型并将每个视图模型与页面的不同区域关联时非常有用。
- en: The view
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: A **view** is a visible, interactive UI representing the state of the view-model.
    It displays information from the view-model, sends commands to the view-model
    (for example, when the user clicks on buttons), and updates whenever the state
    of the view-model changes. In our projects, views are represented by the HTML
    markups.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**是表示视图模型状态的可见、交互式UI。它显示来自视图模型的信息，向视图模型发送命令（例如，当用户点击按钮时），并在视图模型状态更改时更新。在我们的项目中，视图由HTML标记表示。'
- en: 'To define our first view, we are going to build an HTML to display a product.
    Add this new content to the container:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义我们的第一个视图，我们将构建一个HTML来显示一个产品。将这个新内容添加到容器中：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Look at the `data-bind` attribute. This is called **declarative binding**. This
    attribute isn't native to HTML, though it is perfectly correct. But since the
    browser doesn't know what it means, you need to activate Knockout (the `ko.applyBindings`
    method) to make it take effect.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`data-bind`属性。这被称为**声明性绑定**。尽管这个属性对HTML来说并不是本机的，但它是完全正确的。但由于浏览器不知道它的含义，您需要激活Knockout（`ko.applyBindings`方法）才能使其生效。
- en: 'To display data from a product, we need to have a product defined inside our
    view-model:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示来自产品的数据，我们需要在视图模型内定义一个产品：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the view-model to the end of the script tags:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本标签的末尾添加视图模型：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中购买的所有Packt图书中下载示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册以直接通过电子邮件将文件发送给您。
- en: 'This will be the result of our app:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们应用的结果：
- en: '![The view](img/7074OS_01_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![视图](img/7074OS_01_03.jpg)'
- en: Result of data binding
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定的结果
- en: The model
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: This data represents objects and operations in your business domain (for example,
    products) and is independent of any UI. When using Knockout, you will usually
    make AJAX calls to some server-side code to read and write this stored model data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据表示业务域内的对象和操作（例如，产品）和任何UI无关。使用Knockout时，您通常会调用一些服务器端代码来读取和写入此存储的模型数据。
- en: 'Models and view-models should be separated from each other. In order to define
    our product model, we are going to follow some steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 模型和视图模型应该彼此分离。为了定义我们的产品模型，我们将按照一些步骤进行：
- en: Create a folder inside our `js` folder.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`js`文件夹内创建一个文件夹。
- en: Name it `models`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`models`。
- en: Inside the `models` folder, create a JavaScript file called `product.js`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`models`文件夹内，创建一个名为`product.js`的JavaScript文件。
- en: 'The code of the `product.js` file is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`product.js`文件的代码如下：'
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function creates a simple JavaScript object that contains the interface
    of the product. Defining the object using this pattern, called the **revealing
    module pattern**, allows us to clearly separate public elements from private elements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建一个包含产品接口的简单 JavaScript 对象。使用这种模式定义对象，称为**揭示模块模式**，允许我们清晰地将公共元素与私有元素分开。
- en: To learn more about the revealing module pattern, follow the link [https://carldanley.com/js-revealing-module-pattern/](https://carldanley.com/js-revealing-module-pattern/).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于揭示模块模式的信息，请访问链接 [https://carldanley.com/js-revealing-module-pattern/](https://carldanley.com/js-revealing-module-pattern/)。
- en: Link this file with your `index.html` file and set it at the bottom of all the
    script tags.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件与您的`index.html`文件链接，并将其设置在所有脚本标签的底部。
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can use the product model to define the product in the view-model:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用产品模型定义视图模型中的产品：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we run the code again, we will see the same result, but our code is more
    readable now. View-models are used to store and handle a lot of information, because
    of this view-models are commonly treated as modules and the revealing module pattern
    is applied on them. This pattern allows us in a clear manner to expose the API
    (public elements) of the view-model and hide private elements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行代码，将看到相同的结果，但我们的代码现在更易读了。视图模型用于存储和处理大量信息，因此视图模型通常被视为模块，并且在其上应用了揭示模块模式。此模式允许我们清晰地公开视图模型的
    API（公共元素）并隐藏私有元素。
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using this pattern when our view-model begins to grow helps us to clearly see
    which elements belong to the public part of the object and which ones are private.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的视图模型开始增长时使用此模式可以帮助我们清晰地看到哪些元素属于对象的公共部分，哪些是私有的。
- en: Observables to refresh the UI automatically
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察对象自动刷新 UI
- en: The last example shows us how Knockout binds data and the user interface, but
    it doesn't show the magic of the automatic UI refresh. To perform this task, Knockout
    uses observables.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例向我们展示了 Knockout 如何绑定数据和用户界面，但它没有展示自动 UI 刷新的魔法。为了执行此任务，Knockout 使用可观察对象。
- en: '**Observables** are the main concept of Knockout. These are special JavaScript
    objects that can notify subscribers about changes, and can automatically detect
    dependencies. For compatibility, `ko.observable` objects are actually functions.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**可观察对象**是 Knockout 的主要概念。这些是特殊的 JavaScript 对象，可以通知订阅者有关更改，并且可以自动检测依赖关系。为了兼容性，`ko.observable`对象实际上是函数。'
- en: To read an observable's current value, just call the observable with no parameters.
    In this example, `product.price()` will return the price of the product, and `product.name()`
    will return the name of the product.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取可观察对象的当前值，只需调用可观察对象而不带参数。在这个例子中，`product.price()`将返回产品的价格，`product.name()`将返回产品的名称。
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To write a new value to the observable, call the observable and pass the new
    value as a parameter. For example, calling `product.name('Jeans')` will change
    the `name` value to `'Jeans'`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新值写入可观察对象，请调用可观察对象并将新值作为参数传递。例如，调用`product.name('Jeans')`将把`name`值更改为`'Jeans'`。
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete documentation about observables is on the official Knockout website
    [http://knockoutjs.com/documentation/observables.html](http://knockoutjs.com/documentation/observables.html).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可观察对象的完整文档在官方 Knockout 网站上 [http://knockoutjs.com/documentation/observables.html](http://knockoutjs.com/documentation/observables.html)。
- en: To show how observables work, we are going to add some input data into our template.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示可观察对象的工作原理，我们将在模板中添加一些输入数据。
- en: Add these HTML tags over `div` that contain product information.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含产品信息的`div`上添加这些 HTML 标签。
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have linked inputs to the view-model using the `value` property. Run the
    code and try to change the values in the inputs. What happened? Nothing. This
    is because variables are not observables. Update your `product.js` file, adding
    the `ko.observable` method to each variable:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`value`属性将输入与视图模型链接起来。运行代码并尝试更改输入中的值。发生了什么？什么都没有。这是因为变量不是可观察对象。更新您的`product.js`文件，为每个变量添加`ko.observable`方法：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that when we update the data inside the inputs, our product values are
    updated automatically. When you change the `name` value to `Jeans`, the text binding
    will automatically update the text content of the associated DOM element. That's
    how changes to the view-model automatically propagate to the view.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们更新输入中的数据时，我们的产品值会自动更新。当您将`name`值更改为`Jeans`时，文本绑定将自动更新关联的 DOM 元素的文本内容。这就是视图模型的更改如何自动传播到视图的方式。
- en: '![Observables to refresh the UI automatically](img/7074OS_01_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![可观察对象自动刷新 UI](img/7074OS_01_04.jpg)'
- en: Observable models are updated automatically
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察模型会自动更新
- en: Managing collections with observables
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 observables 管理集合
- en: If you want to detect and respond to changes in one object, you'd use observables.
    If you want to detect and respond to changes in a collection of things, use an
    `observableArray`. This is useful in many scenarios where you're displaying or
    editing multiple values and need repeated sections of the UI to appear and disappear
    as items are added and removed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检测并响应一个对象的变化，你会使用 observables。如果你想检测并响应一组东西的变化，请使用`observableArray`。这在许多情况下都很有用，比如显示或编辑多个值，并且需要在添加和删除项时重复出现和消失
    UI 的部分。
- en: 'To display a collection of products in our application, we are going to follow
    some simple steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中显示一组产品，我们将按照一些简单的步骤进行：
- en: 'Open the `index.html` file and remove the code inside the `<body>` tag and
    then add a table where we will list our catalog:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`index.html`文件，删除`<body>`标签内的代码，然后添加一个表格，我们将列出我们的目录：
- en: '[PRE15]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define an array of products inside the view-model:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图模型内定义一个产品数组：
- en: '[PRE16]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Knockout has a binding to repeat a piece of code for each element in a collection.
    Update the `tbody` element in the table:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Knockout 中有一个绑定，用于在集合中的每个元素上重复执行一段代码。更新表格中的`tbody`元素：
- en: '[PRE17]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We use the `foreach` property to point out that all that is inside this tag
    should be repeated for each item in the collection. Inside this tag we are in
    the context of each element, so you can just bind properties directly. Observe
    the result in your browser.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`foreach`属性来指出该标记内的所有内容都应该针对集合中的每个项目进行重复。在该标记内部，我们处于每个元素的上下文中，所以你可以直接绑定属性。在浏览器中观察结果。
- en: 'We want to know how many items we have in our catalog, so add this line of
    code above the table:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想知道目录中有多少个项目，所以在表格上方添加这行代码：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Inserting elements in collections
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在集合中插入元素
- en: To insert elements in the products array, an event should occur. In this case,
    the user will click on a button and this action will fire an action that will
    insert a new product in the collection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要向产品数组中插入元素，应该发生一个事件。在这种情况下，用户将点击一个按钮，这个动作将触发一个操作，将一个新产品插入集合中。
- en: In future chapters, you will learn more about events. Now we will just need
    to know that there is a binding property named `click`. It receives a function
    as a parameter, and this function is fired when the user clicks on the element.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的章节中，你将会了解更多关于事件的内容。现在我们只需要知道有一个名为`click`的绑定属性。它接收一个函数作为参数，当用户点击元素时，该函数会被触发。
- en: 'To insert an element, we need a form to insert the values of the new product.
    Write this HMTL code just below the `<h1>` tag:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入一个元素，我们需要一个表单来插入新产品的值。将此 HTML 代码写在`<h1>`标签的下方：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this template, we find some new bindings:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们找到了一些新的绑定：
- en: 'The `with` binding: This creates a new binding context so that descendant elements
    are bound in the context of a specified object, in this case `newProduct`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with` 绑定：它创建一个新的绑定上下文，以便后代元素在指定对象的上下文中绑定，本例中为`newProduct`。'
- en: '[http://knockoutjs.com/documentation/with-binding.html](http://knockoutjs.com/documentation/with-binding.html)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://knockoutjs.com/documentation/with-binding.html](http://knockoutjs.com/documentation/with-binding.html)'
- en: 'The `textInput` binding: The `textInput` binding links a textbox (`<input>`)
    or text area (`<textarea>`) with a view-model property, providing two-way updates
    between the `viewmodel` property and the element''s value. Unlike the `value`
    binding property, `textInput` provides instant updates from the DOM for all types
    of user input, including autocomplete, drag-and-drop, and clipboard events. It
    is available from the 3.2 version of Knockout.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textInput` 绑定：`textInput` 绑定将文本框（`<input>`）或文本区域（`<textarea>`）与视图模型属性连接起来，提供视图模型属性和元素值之间的双向更新。与`value`绑定属性不同，`textInput`
    提供了对于所有类型的用户输入，包括自动完成、拖放和剪贴板事件的 DOM 的即时更新。它从 Knockout 的 3.2 版本开始提供。'
- en: '[http://knockoutjs.com/documentation/textinput-binding.html](http://knockoutjs.com/documentation/textinput-binding.html)'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://knockoutjs.com/documentation/textinput-binding.html](http://knockoutjs.com/documentation/textinput-binding.html)'
- en: 'The `click` binding: The `click` binding adds an event handler so that your
    chosen JavaScript function is invoked when the associated DOM element is clicked.
    When calling your handler, Knockout will supply the current model value as the
    first parameter. This is particularly useful if you''re rendering UI for each
    item in a collection, and you need to know which item''s UI was clicked.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`click` 绑定：`click` 绑定添加了一个事件处理程序，使得当关联的 DOM 元素被点击时，您选择的 JavaScript 函数被调用。在调用处理程序时，Knockout
    将当前模型值作为第一个参数提供。这在为集合中的每个项目渲染 UI，并且您需要知道哪个项目的 UI 被点击时特别有用。'
- en: '[http://knockoutjs.com/documentation/click-binding.html](http://knockoutjs.com/documentation/click-binding.html)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://knockoutjs.com/documentation/click-binding.html](http://knockoutjs.com/documentation/click-binding.html)'
- en: 'The `$parent` object: This is a binding context property. We use it to refer
    to data from outside the `foreach` loop.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$parent` 对象：这是一个绑定上下文属性。我们用它来引用`foreach`循环外的数据。'
- en: For more information about binding context properties, read the Knockout documentation
    at [http://knockoutjs.com/documentation/binding-context.html](http://knockoutjs.com/documentation/binding-context.html).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解有关绑定上下文属性的更多信息，请阅读 Knockout 文档：[http://knockoutjs.com/documentation/binding-context.html](http://knockoutjs.com/documentation/binding-context.html)。
- en: '![Inserting elements in collections](img/7074OS_01_05.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![在集合中插入元素](img/7074OS_01_05.jpg)'
- en: Using with to set a context and parent to navigate through them
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 with 设置上下文和 parent 通过它们导航
- en: 'Now it is time to add the `newProduct` object to our view-model. First we should
    define a new product with empty data:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向我们的视图模型添加 `newProduct` 对象了。首先，我们应该定义一个带有空数据的新产品：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have defined a literal object that will contain the information we want
    to put inside our new product. Also, we have defined a method to clear or reset
    the object once the insertion is done. Now we define our `addProduct` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个字面对象，将包含我们要放入新产品的信息。此外，我们已经定义了一个清除或重置对象的方法，一旦插入完成就会进行。现在我们定义我们的`addProduct`
    方法：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method creates a new product with the data received from the click event.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个从点击事件接收到的数据的新产品。
- en: The click event always sends the context as the first argument. Note also that
    you can use array methods such as `push` in an observable array. Check out the
    Knockout documentation ([http://knockoutjs.com/documentation/observableArrays.html](http://knockoutjs.com/documentation/observableArrays.html))
    to see all the methods available in arrays.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 点击事件始终将上下文作为第一个参数发送。还要注意，您可以在可观察数组中使用`push`等数组方法。请查看 Knockout 文档 ([http://knockoutjs.com/documentation/observableArrays.html](http://knockoutjs.com/documentation/observableArrays.html))
    以查看数组中可用的所有方法。
- en: 'We should implement the private method that will clean data from the new product
    once it is added to the collection:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该实现一个私有方法，一旦将新产品添加到集合中，就会清除新产品的数据：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Update the view-model:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更新视图模型：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you run the code, you will notice that when you try to add a new product
    nothing happens. This is because, despite the fact that our products have observable
    properties, our array is not an observable one. For this reason, Knockout is not
    listening to the changes. We should convert the array to an `observableArray`
    observable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行代码，您将注意到当您尝试添加新产品时什么也不会发生。这是因为，尽管我们的产品具有可观察属性，但我们的数组不是一个可观察的数组。因此，Knockout
    不会监听更改。我们应该将数组转换为`observableArray`可观察的数组。
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now Knockout is listening to what is going on with this array, but not what
    is happening inside each element. Knockout just tells us about inserting or deleting
    elements in the array, but not about editing elements. If you want to know what
    is happening in an element, the object should have observable properties.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Knockout 正在监听该数组的变化，但不会监听每个元素内部发生的事情。Knockout 只告诉我们在数组中插入或删除元素的情况，但不告诉我们修改元素的情况。如果您想知道元素内发生了什么，那么对象应具有可观察的属性。
- en: An `observableArray` observable just tracks which objects it holds, and notifies
    listeners when objects are added or removed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`observableArray` 只会跟踪它所持有的对象，并在添加或删除对象时通知监听者。'
- en: Behind the scenes, the `observableArray` is actually an observable whose value
    is an array. So you can get the underlying JavaScript array by invoking the `observableArray`
    observable as a function with no parameters, just like any other observable. Then
    you can read information from that underlying array.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`observableArray` 实际上是一个值为数组的可观察属性。因此，您可以像调用任何其他可观察属性一样，以无参数的方式将`observableArray`可观察属性作为函数进行调用，从而获取底层的
    JavaScript 数组。然后您可以从那个底层数组中读取信息。
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Computed observables
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算可观察属性
- en: It is not weird to think that some values we show in our interface depend on
    other values that Knockout is already observing. For example, if we would like
    to search products in our catalog by name, it is evident that the products in
    the catalog that we show in the list are related to the term we have entered in
    the search box. In these cases Knockout offers us **computed observables**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 想要思考一下我们在界面中显示的某些值是否取决于 Knockout 已经观察到的其他值并不奇怪。例如，如果我们想要按名称搜索我们目录中的产品，显然我们在列表中显示的目录产品与我们在搜索框中输入的术语相关联。在这些情况下，Knockout
    为我们提供了**计算可观察对象**。
- en: You can learn in detail about computed observables in the Knockout documentation
    at [http://knockoutjs.com/documentation/computedObservables.html](http://knockoutjs.com/documentation/computedObservables.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Knockout 文档中详细了解[计算可观察对象](http://knockoutjs.com/documentation/computedObservables.html)。
- en: 'To develop the search function, define a textbox where we can write a term
    to search. We are going to bind it to the `searchTerm` property. To update the
    value as we write, we should use the `textInput` binding. If we use the value
    binding, the value will be updated when the element loses the focus. Put this
    code over the products table:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发搜索功能，请定义一个文本框，我们可以在其中写入要搜索的术语。我们将把它绑定到`searchTerm`属性。要在编写时更新值，我们应该使用`textInput`绑定。如果我们使用值绑定，当元素失去焦点时，值将被更新。将此代码放在产品表上方：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To create a filtered catalog, we are going to check all our items and test if
    the `searchTerm` is in the item's `name` property.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个过滤目录，我们将检查所有项目，并测试`searchTerm`是否在项目的`name`属性中。
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `ko.utils` object is not documented in Knockout. It is an object used by
    the library internally. It has public access and has some functions that can help
    us with observables. There are a lot of unofficial examples about it on the Internet.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.utils`对象在 Knockout 中没有文档。它是库内部使用的对象。它具有公共访问权限，并具有一些可以帮助我们处理可观察对象的函数。互联网上有很多关于它的非官方示例。'
- en: One of its helpful functions is `ko.utils.arrayFilter`. If you look at line
    13, we have used this method to obtain a filtered array.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 它的一个有用函数是`ko.utils.arrayFilter`。如果您看一下第13行，我们已经使用了此方法来获取过滤后的数组。
- en: This function gets an array as the first parameter. Notice that we invoke the
    `catalog` array observable to get the elements. We don't pass the observable itself,
    but the contents of the observable.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数以数组作为第一个参数。请注意，我们调用`catalog`数组可观察对象以获取元素。我们不传递可观察对象本身，而是传递可观察对象的内容。
- en: The second parameter is the function that decides whether the item will be in
    the filtered array or not. It will return `true` if the item has the conditions
    to be in the filtered array. Otherwise it returns `false`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是决定项目是否在过滤数组中的函数。如果项目符合过滤数组的条件，它将返回`true`。否则返回`false`。
- en: 'On line 14 of this snippet, we can find an array called `fields`. This parameter
    will contain the fields that should comply with the criteria. In this case, we
    just check that the filter value is in the `name` value. If we are pretty sure
    that we are just going to check the `name` field, we can simplify the filter function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在此片段的第14行，我们可以找到一个名为`fields`的数组。此参数将包含应符合条件的字段。在这种情况下，我们只检查过滤值是否在`name`值中。如果我们非常确定只会检查`name`字段，我们可以简化过滤函数：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `ko.unwrap` function returns the value that contains the observable. We
    use `ko.unwrap` when we are not sure if the variable contains an observable or
    not, for example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.unwrap`函数返回包含可观察对象的值。当我们不确定变量是否包含可观察对象时，我们使用`ko.unwrap`，例如：'
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Expose the filtered catalog into the public API. Notice that now we need to
    use the filtered catalog instead of the original catalog of products. Because
    we are applying the **revealing** **module pattern**, we can keep the original
    API interface and just update the value of the catalog with the filtered catalog.
    We don''t need to alert the view that we are going to use a different catalog
    or other element, as long as we always maintain the same public interface:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将过滤后的目录暴露到公共 API 中。请注意，现在我们需要使用过滤后的目录而不是原始产品目录。因为我们正在应用**揭示模块模式**，我们可以保持原始 API
    接口，只需使用过滤后的目录更新目录的值即可。只要我们始终保持相同的公共接口，就不需要通知视图我们将使用不同的目录或其他元素：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, try to type some characters in the search box and see in your browser how
    the catalog updates the data automatically.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试在搜索框中键入一些字符，并在浏览器中查看目录如何自动更新数据。
- en: 'Wonderful! We have completed our first three user stories:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经完成了我们的前三个用户故事：
- en: The user should be able to view the catalog
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够查看目录
- en: The user should be able to search the catalog
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够搜索目录
- en: The user should be able to add items to the catalog
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够向目录添加项目
- en: 'Let''s see the final result:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最终结果：
- en: '![Computed observables](img/7074OS_01_06.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![计算观察对象](img/7074OS_01_06.jpg)'
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned the basics of the Knockout library. We have
    created a simple form to add products to our catalog. You have also learned how
    to manage observable collections and display them in a table. Finally, we have
    developed the search functionality using computed observables.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了 Knockout 库的基础知识。我们创建了一个简单的表单来将产品添加到我们的目录中。你还学会了如何管理 observable 集合并将其显示在表中。最后，我们使用计算观察对象开发了搜索功能。
- en: 'You have learned three important Knockout concepts:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了三个重要的 Knockout 概念：
- en: '**View-model**: This holds the data that represents the state of the view.
    It is a pure JavaScript object.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：这包含代表视图状态的数据。它是一个纯 JavaScript 对象。'
- en: '**Models**: This contains data from the business domain.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这包含了来自业务领域的数据。'
- en: '**Views**: This displays the data we store in the view-model in a given instant
    of time.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这显示了我们在视图模型中存储的数据在某一时刻的情况。'
- en: 'To build reactive UIs, the Knockout library provides us with some important
    methods:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为构建响应式 UI，Knockout 库为我们提供了一些重要的方法：
- en: '`ko.observable`: This is used to manage variables.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.observable`：用于管理变量。'
- en: '`ko.observableArray`: This is used to manage arrays.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.observableArray`：用于管理数组。'
- en: '`ko.computed`: They respond to changes from observables that are inside them.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.computed`：它们对其内部的 observable 的更改作出响应。'
- en: To iterate over the elements of an array, we use the `foreach` binding. When
    we use the `foreach` binding, we create a new context. This context is relative
    to each item. If we want to access out of this context we should use the `$parent`
    object.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要迭代数组的元素，我们使用`foreach`绑定。当我们使用`foreach`绑定时，我们会创建一个新的上下文。这个上下文是相对于每个项目的。如果我们想要访问超出此上下文的内容，我们应该使用`$parent`对象。
- en: When we want to create a new context relative to a variable, we can attach the
    `with` binding to any DOM element.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要为变量创建一个新的上下文时，我们可以将`with`绑定附加到任何 DOM 元素。
- en: We use the `click` binding to attach the click event to an element. Click on
    event functions to always get the context as the first parameter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`click`绑定将点击事件附加到元素上。点击事件函数始终将上下文作为第一个参数。
- en: To get values from a variable that we are not sure is an observable, we can
    use the `ko.unwrap` function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们不确定是否为 observable 的变量中获取值，我们可以使用`ko.unwrap`函数。
- en: We can use the `ko.utils.arrayFilter` function to filter collections.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ko.utils.arrayFilter`函数来筛选集合。
- en: In the next chapter, we are going to use templates to keep our code maintainable
    and clean. Template engines help us to keep our code arranged and allow us to
    update views in an easy way.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用模板来保持我们的代码易维护和干净。模板引擎帮助我们保持代码整洁，且方便我们以简单的方式更新视图。
- en: 'There is a copy of the code developed in this chapter at:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开发的代码副本在此处：
- en: '[https://github.com/jorgeferrando/knockout-cart/archive/chapter1.zip](https://github.com/jorgeferrando/knockout-cart/archive/chapter1.zip).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/jorgeferrando/knockout-cart/archive/chapter1.zip](https://github.com/jorgeferrando/knockout-cart/archive/chapter1.zip)。'
