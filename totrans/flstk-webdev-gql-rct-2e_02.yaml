- en: '*Chapter 1*: Preparing Your Development Environment'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application we are going to build in this book will be a simplified version
    of Facebook, called **Graphbook**. We will allow our users to sign up and log
    in to read and write posts and chat with friends, similar to what we can do on
    common social networks.
  prefs: []
  type: TYPE_NORMAL
- en: When developing an application, being well-prepared is always a requirement.
    However, before we start, we need to put our stack together. In this chapter,
    we will explore whether our techniques work well with our development process,
    what we need before getting started, and which tools can help us when building
    software.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains the architecture for our application by going through
    the core concepts, the complete process, and preparing for a working React setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture and technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thinking critically about how to architect a stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the React and GraphQL stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a React development environment with webpack, Babel, and other requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging React applications using Chrome DevTools and React Developer Tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter01).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the application architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since its initial release in 2015, GraphQL has become the new alternative to
    the standard SOAP and REST APIs. GraphQL is a specification, like SOAP and REST,
    that you can follow to structure your application and data flow. It is so innovative
    because it allows you to query specific fields of entities, such as users and
    posts. This functionality makes it very good for targeting multiple platforms
    at the same time. Mobile apps may not need all the data that''s displayed inside
    the browser on a desktop computer. The query you send consists of a JSON-like
    object that defines which information your platform requires. For example, a query
    for a `post` may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: GraphQL resolves the correct entities and data, as specified in your query object.
    Every field in GraphQL represents a function that resolves to a value. Those functions
    are called **Resolver functions**. The return value could be just the corresponding
    database value, such as the name of a user, or it could be a date, which is formatted
    by your server before returning it.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is completely database agnostic and can be implemented in any programming
    language. To skip the step of implementing a GraphQL library, we are going to
    use Apollo, which is a GraphQL server for the Node.js ecosystem. Thanks to the
    team behind Apollo, this is very modular. Apollo works with many of the common
    Node.js frameworks, such as Hapi, Koa, and Express.js.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use Express.js as our basis because it is used on a wide scale
    in the Node.js and GraphQL communities. GraphQL can be used with multiple database
    systems and distributed systems to offer a straightforward API over all your services.
    It allows developers to unify existing systems and handle data fetching for client
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: How you combine your databases, external systems, and other services into one
    server backend is up to you. In this book, we are going to use a MySQL server
    via Sequelize as our data storage. SQL is the most well-known and commonly used
    database query language, and with Sequelize, we have a modern client library for
    our Node.js server to connect with our SQL server.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is the standard protocol for accessing a GraphQL API. It also applies to
    Apollo Servers. However, GraphQL is not fixed to one network protocol. Everything
    we have mentioned so far is everything important for the backend.
  prefs: []
  type: TYPE_NORMAL
- en: When we get to the frontend of our **Graphbook** application, we are mainly
    going to use React. React is a JavaScript UI framework that was released by Facebook
    that has introduced many techniques that are now commonly used for building interfaces
    on the web, as well as on native environments.
  prefs: []
  type: TYPE_NORMAL
- en: Using React comes with a bunch of significant advantages. When building a React
    application, you always split your code into many components, targeting their
    efficiency and ability to be reused. Of course, you can do this without using
    React, but it makes it very easy. Furthermore, React teaches you how to update
    application states, as well as the UI, reactively. You never update the UI and
    then the data separately.
  prefs: []
  type: TYPE_NORMAL
- en: React makes rerendering very efficient by using a virtual DOM, which compares
    the virtual and actual DOM and updates it accordingly. Only when there is a difference
    between the virtual and real DOM does React apply these changes. This logic stops
    the browser from recalculating the layout, **Cascading Style Sheets** (**CSS**),
    and other computations that negatively impact the overall performance of your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we are going to use the Apollo client library. It naturally
    integrates with React and our Apollo Server.
  prefs: []
  type: TYPE_NORMAL
- en: If we put all this together, the result is the main stack consisting of Node.js,
    Express.js, Apollo, SQL, Sequelize, and React.
  prefs: []
  type: TYPE_NORMAL
- en: The basic setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic setup for making an application work is the logical request flow,
    which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Logical request workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.1_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – Logical request workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the logical request flow works:'
  prefs: []
  type: TYPE_NORMAL
- en: The client requests our site.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Express.js server handles these requests and serves a static HTML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client downloads all the necessary files, according to this HTML file. The
    files also include a bundled JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This bundled JavaScript file is our React application. After executing all the
    JavaScript code from this file, all the required Ajax alias GraphQL requests are
    made to our Apollo Server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Express.js receives the requests and passes them to our Apollo endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apollo queries all the requested data from all the available systems, such as
    our SQL server or third-party services, merges the data, and sends it back as
    JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React can render the JSON data as HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This workflow is the basic setup for making an application work. In some cases,
    it makes sense to offer server-side rendering for our client. The server would
    need to render and send all `XMLHttpRequests` itself before returning the HTML
    to the client. The user will save doing one or more round trips if the server
    sends the requests on the initial load. We will focus on this topic later in this
    book, but that is the application architecture in a nutshell. With that in mind,
    let's get hands-on and set up our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step of preparing our project is to install Node.js. There are two
    ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: One option is to install **Node Version Manager** (**NVM**). The benefit of
    using NVM is that you can easily run multiple versions of Node.js side by side,
    which handles the installation process for you on nearly all UNIX-based systems,
    such as Linux and macOS. Within this book, we do not need the option to switch
    between different versions of Node.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other option is to install Node.js via the package manager of your distribution
    if you are using Linux. The official PKG file is for Mac, while the MSI file is
    for Windows. We are going to use the regular Linux package manager for this book
    as it is the easiest method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can find the **Downloads** section of Node.js at the following link: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are going to be using the second option here. It covers the regular server
    configurations and is easy to understand. I will keep this as short as possible
    and skip all the other options, such as Chocolatey for Windows and Brew for Mac,
    which are very specialized for those specific operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: I assume that you are using a Debian-based system for ease of use with this
    book. It has got the normal APT package manager and repositories for easily installing
    Node.js and MySQL. If you are not using a Debian-based system, you can look up
    the matching commands to install Node.js at [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our project is going to be new so that we can use Node.js 14, which is the
    current LTS version:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add the correct repository for our package manager by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must install Node.js and the build tools for native modules using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s open a Terminal and verify that the installation was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Installing Node.js via the package manager will automatically install npm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! You are now set to run server-side JavaScript with Node.js and install
    Node.js modules for your projects with npm.
  prefs: []
  type: TYPE_NORMAL
- en: All the dependencies that our project relies on are available at [https://npmjs.com](https://npmjs.com)
    and can be installed with npm or Yarn. We will rely on npm as it is more widely
    used than Yarn. So, let's continue and start using npm to set up our project and
    its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The development environment for our project is ready. In this section, we are
    going to install and configure React, which is the primary aspect of this chapter.
    Let''s start by creating a new directory for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our project will use Node.js and many npm packages. We will create a `package.json`
    file to install and manage all the dependencies for our project. It stores information
    about the project, such as the version number, name, dependencies, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just run `npm init` to create an empty `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: npm will ask some questions, such as asking for the package name, which is,
    in fact, the project name. Enter `Graphbook` to insert the name of your application
    in the generated `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to start with version number 0.0.1 since the default version number
    that npm offers with 1.0.0 represents the first stable release for me. However,
    it is your choice regarding which version you use here.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can skip all the other questions by pressing the *Enter* key to save the
    default values of npm. Most of them are not relevant because they just provide
    information such as a description or the link to the repository. We are going
    to fill in the other fields, such as the scripts, while working through this book.
    You can see an example of the command line in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – npm project setup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.2_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – npm project setup
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and most crucial dependency for this book is React. Use npm to add
    React to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command installs two npm packages from [https://npmjs.com](https://npmjs.com)
    into our project folder under `node_modules`.
  prefs: []
  type: TYPE_NORMAL
- en: npm automatically edited our `package.json` file since we provided the `--save`
    option and added those packages with the latest available version numbers.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why we installed two packages, even though we only needed
    React. The `react` package only provides React-specific methods. All React Hooks,
    such as `componentDidMount`, `useState`, and even React's component class, come
    from this package. You need this package to write any React application.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you won't even notice that you have used `react-dom`. This package
    offers all the functions to connect the actual DOM of the browser to your React
    application. Usually, you use `ReactDOM.render` to render your application at
    a specific point in your HTML and only once in your code. We will cover how to
    render React later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a function called `ReactDOM.findDOMNode`, which gives you direct
    access to a DOMNode, but I strongly discourage using this since any changes on
    DOMNodes are not available in React itself. I have never needed to use this function,
    so try to avoid it if possible. Now, that our npm project has been set up and
    the two main dependencies have been installed, we need to prepare an environment
    that bundles all the JavaScript files we are going to write. We will focus on
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing and configuring webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our browser requests an `index.html` file when accessing our application. It
    specifies all the files that are required to run our application. We need to create
    this `index.html` file, which we serve as the entry point of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a separate directory for our `index.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, save this inside `index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, no JavaScript is loaded here. There is only one `div` tag with
    the `root` ID. This `div` tag is the DOMNode that our application will be rendered
    in by `ReactDOM`.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we get React up and running with this `index.html` file?
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, we need to use a web application bundler, which will prepare
    and bundle all our application assets. All the required JavaScript files and `node_modules`
    are bundled and minified; SASS and SCSS preprocessors are transpiled to CSS, as
    well as being merged and minified.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few application bundler packages are available, including webpack, Parcel,
    and Gulp. For our use case, we will use webpack. It is the most common module
    bundler and has a large community surrounding it. To bundle our JavaScript code,
    we need to install webpack and all its dependencies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This command adds all the development tools to `devDependencies` in the `package.json`
    file. We will need these to bundle our application. They are only installed in
    a development environment and are skipped in production.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not already aware, setting up webpack can be a bit of a hassle. Many
    options can interfere with each other and lead to problems when you're bundling
    your application. Now, let's create a `webpack.client.config.js` file in the root
    folder of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The webpack configuration file is just a regular JavaScript file where you
    can require `node_modules` and custom JavaScript files. This is the same as everywhere
    else inside Node.js. Let''s quickly go through all of the main properties of this
    configuration. Understanding these will make future custom webpack configs much
    easier. All the important points are explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HtmlWebpackPlugin`: This automatically generates an HTML file that includes
    all the webpack bundles. We pass our previously created `index.html` as a template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CleanWebpackPlugin`: This empties all of the provided directories to clean
    the old build files. The `cleanOnceBeforeBuildPatterns` property specifies an
    array of folders that are cleaned before the build process is started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `entry` field tells webpack where the starting point of our application
    is. This file needs to be created by us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `output` object specifies how our bundle is called and where it should be
    saved. For us, this is `dist/client/bundle.js`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside `module.rules`, we match our file extensions with the correct loaders.
    All the JavaScript files (except those located in `node_modules`) are transpiled
    by Babel as specified by `babel-loader` so that we can use ES6 features inside
    our code. Our CSS gets processed by `style-loader` and `css-loader`. There are
    many more loaders for JavaScript, CSS, and other file extensions available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `devServer` feature of webpack enables us to run the React code directly.
    This includes hot reloading code in the browser without rerunning a build or refreshing
    the browser tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you need a more detailed overview of the webpack configuration, have a look
    at the official documentation: [https://webpack.js.org/concepts/](https://webpack.js.org/concepts/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this in mind, let''s move on. We are missing the `src/client/index.js`
    file from our webpack configuration, so let''s create it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can leave this file empty for the moment. It can be bundled by webpack without
    content inside. We are going to change it later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To spin up our development webpack server, we will add a command to `package.json`
    that we can run using `npm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the `scripts` object inside `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, execute `npm run client` in your console and watch how a new browser window
    opens. We are running `webpack serve` with the newly created configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Sure, the browser is still empty, but if you inspect the HTML with Chrome DevTools,
    you will see that we have already got a `bundle.js` file and that our `index.html`
    file was taken as a template.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we've learned how to include our empty `index.js` file with the bundle
    and serve it to the browser. Next, we'll render our first React component inside
    our template `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering your first React component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many best practices for React. The central philosophy behind it is
    to split our code into separate components where possible. We are going to cover
    this approach in more detail in [*Chapter 5*](B17337_05_Final_ASB_ePub.xhtml#_idTextAnchor123),
    *Reusable React Components and React Hooks*.
  prefs: []
  type: TYPE_NORMAL
- en: Our `index.js` file is the main starting point of our frontend code, and this
    is how it should stay. Do not include any business logic in this file. Instead,
    keep it as clean and slim as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `index.js` file should include the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The release of *ECMAScript 2015* introduced the `import` feature. We can use
    it to load our `npm` packages – `react` and `react-dom` – and our first custom
    React component, which we must write now.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we need to cover the traditional `Hello World` program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `App.js` file next to your `index.js` file and ensure it contains
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we exported a single stateless function called `App` that is then imported
    by the `index.js` file. As we explained previously, we are now actively using
    `ReactDOM.render` in our `index.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter of `ReactDOM.render` is the component or function that we
    want to render, which is the exported function displaying the `DOMNode`, where
    it should render. We receive `DOMNode` with a plain `document.getElementById`
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: We defined our root element when we created the `index.html` file. After saving
    the `App.js` file, webpack will try to build everything again. However, it should
    not be able to do that. webpack will encounter a problem when bundling our `index.js`
    file because of the `<App />` tag syntax we are using in the `ReactDOM.render`
    method. It was not transpiled to a normal JavaScript function.
  prefs: []
  type: TYPE_NORMAL
- en: We configured webpack to load Babel for our JavaScript file but did not tell
    Babel what to transpile and what not to transpile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `.babelrc` file in the root folder that contains the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may have to restart the server because the `.babelrc` file is not reloaded
    when changes are made to the file. After a few moments, you should see the standard
    **Hello World!** message in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we told Babel to use `@babel/preset-env` and `@babel/preset-react`, which
    we installed together with webpack. These presets allow Babel to transform specific
    syntax, such as JSX. We can use those presets to create normal JavaScript that
    all browsers can understand and that webpack can bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering arrays from React state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Hello World!` is a must for every good programming book, but this is not what
    we are aiming for when we use React.'
  prefs: []
  type: TYPE_NORMAL
- en: A social network such as Facebook or Graphbook, which we are writing now, needs
    a newsfeed and an input to post news. Let's implement this.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is the first chapter of this book, we will do this inside `App.js`.
  prefs: []
  type: TYPE_NORMAL
- en: We should work with some fake data here since we have not set up our GraphQL
    API yet. We can replace this with real data later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a new variable above the `default` exported `App` function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to render these two fake posts in React. To prepare this, change
    the first line of the `App.js` file to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the `useState` function of React is imported and accessible
    by our stateless function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the current content of your `App` function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we initiated a `posts` array inside the function via the React `useState`
    function. It allows us to have a state without writing a real React class; instead,
    it only relies on raw functions. The `useState` function expects one parameter,
    which is the initial value of the state variable. In this case, this is the constant
    `initialPosts` array. This returns the `posts` state variable and a `setPosts`
    function, which you can use to update the local state.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we iterated over the `posts` array with the `map` function, which again
    executes the inner callback function, passing each array item as a parameter one
    by one. The second parameter is just called `i` and represents the index of the
    array element we are processing. Everything that's returned from the `map` function
    is then rendered by React.
  prefs: []
  type: TYPE_NORMAL
- en: We merely returned HTML by putting each post's data in ES6 curly braces. These
    curly braces tell React to interpret and evaluate the code inside them as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding code, we are relying on the posts that were returned
    by the `useState` function. This data flow is very convenient because we can update
    the state at any point in our application and the posts will rerender. The important
    thing is that this will only work by using the `setPosts` function and passing
    the updated array to it. In this case, React notices the change of state and rerenders
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding method is much cleaner, and I recommend this for readability
    purposes. When saving, you should be able to see rendered posts. They should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Unstyled demo posts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.3_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – Unstyled demo posts
  prefs: []
  type: TYPE_NORMAL
- en: The images I am using here are freely available. You can use any other material
    that you have got if the path matches the string from the `posts` array. You can
    find those images in the official GitHub repository for this book.
  prefs: []
  type: TYPE_NORMAL
- en: CSS with webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The posts in the preceding figure have not been designed yet. I have already
    added CSS classes to the HTML our component returns.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using CSS to make our posts look better, another method is to use
    CSS-in-JS using packages such as styled components, which is a React package.
    Other alternatives include Glamorous and Radium. There are numerous reasons for
    and against using such libraries. With those other tools, you are not able to
    use SASS, SCSS, or LESS effectively. I need to work with other people, such as
    screen and graphics designers, who can provide and use CSS, but do not program
    styled components. There is always a prototype or existing CSS that can be used,
    so why should I spend time translating this into styled components CSS when I
    could just continue with standard CSS?
  prefs: []
  type: TYPE_NORMAL
- en: There is no right or wrong option here; you are free to implement the styling
    in any way you like. However, in this book, we will keep using good old CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have already done in our `webpack.client.config.js` file is specify
    a CSS rule, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`style-loader` injects your bundled CSS right into the DOM. `css-loader` will
    resolve all `import` or `url` occurrences in your CSS code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `style.css` file in `/assets/css` and fill in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Refreshing your browser will leave you with the same old HTML you had previously.
  prefs: []
  type: TYPE_NORMAL
- en: This problem occurs because webpack is a module bundler and does not know anything
    about CSS; it only knows JavaScript. We must import the CSS file somewhere in
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using `index.html` and adding a `head` tag, we can use webpack and
    our CSS rule to load it right into `App.js`. This solution is very convenient
    since all the required CSS throughout our application gets minified and bundled.
    Webpack automates this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `App.js` file, add the following behind the React `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: webpack magically rebuilds our bundle and refreshes our browser tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, you have successfully rendered fake data via React and styled it
    with bundled CSS from webpack. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Styled demo posts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.04_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – Styled demo posts
  prefs: []
  type: TYPE_NORMAL
- en: The output looks very good already.
  prefs: []
  type: TYPE_NORMAL
- en: Event handling and state updates with React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this project, it would be great to have a simple `textarea` where we can
    click a button and then add a new post to the static `posts` array we wrote in
    the `App` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code above the `div` tag that contains the `feed` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can use forms in React without any problems. React can intercept the submit
    event of requests by giving the form an `onSubmit` property, which will be a function
    to handle the logic.
  prefs: []
  type: TYPE_NORMAL
- en: We are passing the `postContent` variable to the `value` property of `textarea`
    to get what is called a **controlled input**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an empty string variable to save the `textarea` value by using the `useState`
    function from React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `postContent` variable is already being used for our new `textarea` since
    we specified it in the `value` property. Furthermore, we directly implemented
    the `setPostContent` function in our post form. This is used for the `onChange`
    property or any event that is called whenever you type inside `textarea`. The
    `setPostContent` function receives the `e.target.value` variable, which is the
    DOM accessor for the value of `textarea`, which is then stored in the state of
    the React function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at your browser again. The form is there, but it is not pretty, so add
    the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to implement the `handleSubmit` function for our form. Add
    it straight after the state variables and the `return` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code looks more complicated than it is, but I am going to explain
    it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: We needed to run `event.preventDefault` to stop our browser from actually trying
    to submit the form and reload the page. Most people that come from jQuery or other
    JavaScript frameworks will know this.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we saved our new post in the `newPost` variable, which we want to add
    to our feed.
  prefs: []
  type: TYPE_NORMAL
- en: We faked some data here to simulate a real-world application. For our test case,
    the new post ID is the number of posts in our state variable plus one. React wants
    us to give every child in the ReactDOM a unique ID. By counting the number of
    posts with `posts.length`, we simulate the behavior of a real backend giving us
    unique IDs for our posts.
  prefs: []
  type: TYPE_NORMAL
- en: The text for our new post comes from the `postContent` state variable.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we do not have a user system right now that our GraphQL server
    can use to give us the newest posts, including the matching users and their avatars.
    We can simulate this by having a static user object for all the new posts we create.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we updated the state again. We did this by using the `setPosts` function
    and passing a merged array consisting of the new posts and the current `posts`
    array with a destructuring assignment. After that, we cleared `textarea` by passing
    an empty string to the `setPostContent` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go ahead and play with your working React form. Do not forget that all
    the posts you create do not persist since they are only held in the local memory
    of the browser and are not saved to a database. Consequently, refreshing deletes
    your posts.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling document heads with React Helmet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developing a web application, you must control your document heads. You
    might want to change the title or description, based on the content you are presenting.
  prefs: []
  type: TYPE_NORMAL
- en: 'React Helmet is a great package that offers this on the fly, including overriding
    multiple headers and server-side rendering. Let''s see how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install React Helmet with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `react-helmet` at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `Helmet` directly above `postForm div`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you reload the browser and watch the title on the tab bar of your browser
    carefully, you will see that it changes from `Graphbook` to `Graphbook - Feed`.
    This behavior happens because we already defined a title inside `index.html`.
    When React finishes rendering, the new document head is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Production build with webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step for our React setup is to have a production build. Until now,
    we were only using `webpack-dev-server`, but this naturally includes an unoptimized
    development build. Furthermore, webpack automatically spawns a web server. In
    the next chapter, we will introduce Express.js as our web server so that we don't
    need webpack to start it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A production bundle does merge all JavaScript files, but it also merges all
    the CSS files into two separate files. Those can be used directly in the browser.
    To bundle CSS files, we will rely on another webpack plugin, called `MiniCss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not want to change the current `webpack.client.config.js` file because
    it is made for development work. Add the following command to the `scripts` object
    of your `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This command runs webpack using an individual production webpack config file.
    Let's create this one. First, clone the original `webpack.client.config.js` file
    and rename it `webpack.client.build.config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the following things in the new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mode` needs to be `production`, not `development`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Require the `MiniCss` plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the current CSS rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are no longer using `style-loader`; instead, we're using the `MiniCss` plugin.
    The plugin goes through the complete CSS code, merges it into a separate file,
    and removes the `import` statements from the `bundle.js` file, which we generate
    in parallel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lastly, add the plugin to the plugins at the bottom of the configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the entire `devServer` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run the new configuration, it won't spawn a server or browser window;
    it will only create a production JavaScript and CSS bundle and will require them
    in our `index.html` file. According to our `webpack.client.build.config.js` file,
    those three files are going to be saved to the `dist/client` folder.
  prefs: []
  type: TYPE_NORMAL
- en: You can run this command by executing `npm run client:build`.
  prefs: []
  type: TYPE_NORMAL
- en: If you look in the `dist/client` folder, you will see three files. You can open
    the `index.html` file in your browser. Sadly, the images are broken because the
    image URLs are not correct anymore. We must accept this for the moment because
    it will be automatically fixed when we have a working backend.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have finished the basic setup for React.
  prefs: []
  type: TYPE_NORMAL
- en: Useful development tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're working with React, you want to know why your application rendered
    the way that it did. You need to know which properties your components received
    and how their current state looks. Since this is not displayed in the DOM or anywhere
    else in Chrome DevTools, you need a separate plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Facebook has got you covered. Visit [https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)
    and install React Developer Tools. This plugin allows you to inspect React applications
    and components. When you open Chrome DevTools again, you will see that there are
    two new tabs at the end of the row – one called **Components** and another called
    **Profiler**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – React developer tools'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.5_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – React developer tools
  prefs: []
  type: TYPE_NORMAL
- en: You will only be able to see those tabs if you are running a React application
    in development mode. If a React application is running or bundled in production,
    those extensions won't work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are unable to see this tab, you may need to restart Chrome completely.
    You can also find React Developer Tools for Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: The first tab allows you to view, search, and edit all the components of your
    ReactDOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The left-hand side panel looks much like the regular DOM tree (Elements) in
    Chrome DevTools, but instead of showing HTML markup, you will see all the components
    you used inside a tree. ReactDOM rendered this tree into real HTML, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – React component tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.6_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – React component tree
  prefs: []
  type: TYPE_NORMAL
- en: The first component in the current version of Graphbook should be `<App />`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking a component, your right-hand side panel will show its properties,
    state, and context. You can try this with the `App` component, which is the only
    real React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – React component state'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.7_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7 – React component state
  prefs: []
  type: TYPE_NORMAL
- en: The `App` function is the first component of our application. This is the reason
    why it received no props. Children can receive properties from their parents;
    with no parent, there are no props.
  prefs: []
  type: TYPE_NORMAL
- en: Now, test the `App` function and play around with the state. You will see that
    changing it rerenders your ReactDOM and updates the HTML. You can edit the `postContent`
    variable, which inserts the new text inside `textarea`. As you will see, all the
    events are thrown, and your handler runs. Updating the state always triggers a
    rerender, so try to update the state as little as possible to use as few computing
    resources as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we set up a working React environment. This is a good starting
    point for our frontend as we can write and build static web pages with this setup.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will primarily focus on our setup for the backend. We will
    configure Express.js to accept our first requests and pass all GraphQL queries
    to Apollo. Furthermore, you will learn how to use Postman to test your API.
  prefs: []
  type: TYPE_NORMAL
