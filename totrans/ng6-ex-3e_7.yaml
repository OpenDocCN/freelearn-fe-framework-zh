- en: Testing Personal Trainer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试个人教练
- en: Unless you are a superhero who codes perfectly, you need to test what you build.
    Also, unless you have loads of free time to test your application again and again,
    you need some test automation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您是一位编写代码完美的超级英雄，否则您需要测试您所构建的内容。此外，除非您有大量空闲时间不断测试您的应用程序，否则您需要一些测试自动化。
- en: When we say Angular was built with testability in mind, we really mean it. It
    has a strong **Dependency Injection** (**DI**) framework, some good mock constructs,
    and awesome tools that make testing in an Angular app a fruitful endeavor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说 Angular 是以可测试性为设计理念时，我们确实是认真的。它有一个强大的 **依赖注入**（**DI**）框架，一些良好的模拟构造，以及使在
    Angular 应用中进行测试变得富有成效的出色工具。
- en: This chapter is all about testing and is dedicated to testing what we have built
    over the course of this book. We test everything from components to pipes, services,
    and our app directives.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于测试，致力于测试本书过程中我们所构建的内容。我们从组件到管道、服务以及我们的应用指令，测试了所有内容。
- en: 'The topics we cover in this chapter include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括：
- en: '**Understanding the big picture**: We will try to understand how testing fits
    into the overall context of Angular app development. We will also discuss the
    types of testing Angular supports, including unit and **end-to-end** (**E2E**)
    testing.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解大局**：我们将尝试理解测试如何融入 Angular 应用开发的整体背景。我们还将讨论 Angular 支持的测试类型，包括单元测试和 **端到端**（**E2E**）测试。'
- en: '**Overview of tools and frameworks**: We will cover the tools and frameworks
    that help in both unit and end-to-end testing with Angular. These include **Karma**
    and **Protractor**.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具和框架概述**：我们将介绍帮助使用 Angular 进行单元测试和端到端测试的工具和框架。这些包括 **Karma** 和 **Protractor**。'
- en: '**Writing unit tests**: You will learn how to do unit testing with Angular
    using **Jasmine** and **Karma** inside a browser. We will unit test what we have
    built in the last few chapters. This section also teaches us how to unit-test
    various Angular constructs, including pipes, components, services, and directives.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写单元测试**：您将学习如何在浏览器中使用 **Jasmine** 和 **Karma** 进行 Angular 的单元测试。我们将对上一章构建的内容进行单元测试。本节还将教会我们如何对各种
    Angular 构造进行单元测试，包括管道、组件、服务和指令。'
- en: '**Creating end-to-end tests**: Automated end-to-end tests work by mimicking
    the behavior of the actual user through browser automation. You will learn how
    to use Protractor combined with WebDriver to perform end-to-end testing.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建端到端测试**：自动化的端到端测试通过模拟实际用户的行为并通过浏览器自动化来实现。您将学习如何使用 Protractor 结合 WebDriver
    进行端到端测试。'
- en: Let the testing begin!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让测试开始吧！
- en: 'As you start reading this chapter, we suggest that you download the code for
    `checkpoint 7.1`. It is available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub. If
    you are not using Git, download the snapshot of `checkpoint7.1` (a ZIP file) from
    this GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始阅读本章时，我们建议您下载 `checkpoint 7.1` 的代码。它可以在 GitHub 上供所有人下载（[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)）。检查点作为
    GitHub 上的分支实现。如果您不使用 Git，可以从此 GitHub 位置下载 `checkpoint7.1` 的快照（ZIP 文件）：[https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip)。在首次设置快照时，请参考
    `trainer` 文件夹中的 `README.md` 文件。
- en: This checkpoint contains the tests that were generated by the Angular CLI as
    we created components, services, pipes, and directives in the earlier chapters.
    We have made minor changes in these tests so that they all pass. For the most
    part these are basic "Hello World" tests that confirm the creation of a component
    or other Angular construct. We will not be covering these tests in this chapter,
    but encourage you to review them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此检查点包含在前面章节创建组件、服务、管道和指令时由 Angular CLI 生成的测试。我们对这些测试进行了细微的修改，以确保它们都能通过。大部分这些测试都是基本的“Hello
    World”测试，用于确认组件或其他 Angular 构造的创建。我们将在本章中不涉及这些测试，但鼓励您进行回顾。
- en: The need for automation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化的需求
- en: The size and complexity of apps being built for the web are growing with each
    passing day. The plethora of options that we now have to build web apps is just
    mind-boggling. Add to this the fact that the release cycles for products/apps
    have shrunk drastically from months to days, or even multiple releases per day!
    This puts a lot of burden on software testing. There is too much to be tested.
    Multiple browsers, multiple clients and screen sizes (desktop and mobile), multiple
    resolution, and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，为网络构建的应用的大小和复杂性都在增长。我们现在构建网络应用的可选方案繁多，令人眼花缭乱。再加上产品/应用的发布周期已经从几个月缩短到几天，甚至每天有多个版本发布！这给软件测试带来了很大的负担。有太多东西需要测试。多个浏览器、多个客户端和屏幕尺寸（桌面和移动）、多个分辨率等等。
- en: To be effective in such a diverse landscape, automation is the key. *Automate
    everything that can be automated* should be our mantra.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样一个多样化的环境中要有效，自动化是关键。“*自动化一切可以自动化的内容*”应该是我们的座右铭。
- en: Testing in Angular
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 中的测试
- en: The Angular team realized the importance of testability and hence created a
    framework that allowed easy testing (automated) for apps built on it. The design
    choice of using DI constructs to inject dependencies everywhere has helped. This
    will become clear as the chapter progresses and we build a number of tests for
    our apps. However, before that, let's understand the types of testing that we
    target when building apps on this platform.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 团队意识到了可测试性的重要性，因此创建了一个框架，使得基于该框架构建的应用可以轻松进行测试（自动化）。使用 DI 构造来注入依赖的设计选择有助于这一点。随着章节的推进，我们将为我们的应用构建多个测试，这一点将会变得清晰。然而，在那之前，让我们了解在构建该平台上的应用时，我们针对哪些类型的测试。
- en: Types of testing
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'There are broadly two forms of testing that we do for a typical Angular app:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的 Angular 应用，我们主要进行两种形式的测试：
- en: '**Unit testing**: Unit testing is all about testing a component in isolation
    to verify the correctness of its behavior. Most of the dependencies of the component
    under test need to be replaced with mock implementations to make sure that the
    unit tests do not fail due to failure in a dependent component.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：单元测试完全是针对组件进行隔离测试，以验证其行为的正确性。被测试组件的大多数依赖项需要用模拟实现来替换，以确保单元测试不会因为依赖组件的失败而失败。'
- en: '**End-to-end testing**: This type of testing is all about executing the application
    like a real end user and verifying the behavior of the application. Unlike unit
    testing, components are not tested in isolation. Tests are done against a running
    system in real browsers, and assertions are done based on the state of the user
    interface and the content displayed.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：这种测试类型完全模拟真实用户的操作，并验证应用的行为。与单元测试不同，组件不是单独测试的。测试是在真实浏览器中针对运行中的系统进行的，断言是基于用户界面状态和显示的内容进行的。'
- en: Unit testing is the first line of defense against bugs, and we should be able
    to iron out most issues with code during unit testing. But unless E2E is done,
    we cannot confirm that the software is working correctly. Only when all the components
    within a system interact in the desired manner can we confirm that the software
    works; hence, E2E testing becomes a necessity.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是防止错误的第一个防线，我们应该能够在单元测试期间用代码解决大多数问题。但除非进行了端到端测试，否则我们无法确认软件是否正确运行。只有当系统中的所有组件以期望的方式交互时，我们才能确认软件是正常工作的；因此，端到端测试成为了一种必需。
- en: You can view these two types of testing like a pyramid with E2E testing on the
    top and unit testing on the bottom. The pyramid indicates that the number of unit
    tests you write should substantially exceed the number of E2E tests. The reason
    is that with unit tests you are breaking your application down into small testable
    units, whereas with integration tests you are spanning multiple components from
    the UI through to the backend. Also setting up E2E tests tends to be more complicated
    than unit tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这两种测试类型看作是一个金字塔，端到端测试位于顶部，单元测试位于底部。金字塔表明，你编写的单元测试数量应该远多于端到端测试的数量。原因是，通过单元测试，你将应用分解成小的可测试单元，而通过集成测试，你跨越了从
    UI 到后端的多个组件。此外，设置端到端测试通常比单元测试更复杂。
- en: Who writes unit and E2E tests and when are they written are important questions
    to answer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 谁编写单元测试和端到端测试，以及何时编写，都是需要回答的重要问题。
- en: Testing – who does it and when?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 – 谁来做，何时做？
- en: Traditionally, E2E testing was done by the **Quality Assurance** (**QA**) team
    and developers were responsible for unit-testing their code before submitting.
    Developers did some amount of E2E testing too, but overall the E2E testing process
    was manual.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，端到端测试（E2E testing）是由**质量保证**（**QA**）团队执行的，而开发人员则负责在提交代码前进行单元测试。开发人员也会进行一定程度的端到端测试，但总体来说，端到端测试过程是手动的。
- en: With the changing landscape, modern testing tools, especially on the web front,
    have allowed developers to write automated E2E tests themselves and execute them
    against any deployment setup (such as development/stage/production). Tools such
    as Selenium, together with WebDrivers, allow easy browser automation, thus making
    it easy to write and execute E2E tests against real web browsers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着形势的变化，现代测试工具，尤其是在网络前端，已经允许开发人员自己编写自动化的端到端测试，并针对任何部署设置（如开发/测试/生产）执行它们。例如，Selenium
    与 WebDriver 一起使用，可以轻松实现浏览器自动化，从而使得编写和执行针对真实网络浏览器的端到端测试变得容易。
- en: A good time to write E2E scenario tests is when the development is complete
    and ready to be deployed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发完成并准备部署时是编写端到端场景测试的好时机。
- en: When it comes to unit testing, there are different schools of thought around
    when a test should be written. A *Test Driven Developer* writes tests before the
    functionality is implemented. Others write tests when the implementation is complete
    to confirm the behavior. Some write while developing the component itself. Choose
    a style that suits you, keeping in mind that the earlier you write your tests,
    the better.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到单元测试时，关于何时编写测试存在不同的观点。*测试驱动开发者*在功能实现之前编写测试。其他人则在实现完成后编写测试以确认行为。有些人则在开发组件的同时编写测试。选择一种适合你的风格，同时记住，你编写测试的时间越早，效果越好。
- en: We are not going to give any recommendations, nor are we going to get into an
    argument over which one is better. Any amount of unit tests is better than nothing.
    Our personal preference is to use the *middle approach*. With TDD, we feel that
    the test creation effort at times is lost as the specifications/requirements change.
    Tests written at the start are prone to constant fixes as the requirement changes.
    The problem with writing unit tests at the end is that our target is to create
    tests that pass according to the current implementation. The tests that are written
    are retrofitted to test the implementation where they should test the specifications.
    Adding tests somewhere in the middle works best for us.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会给出任何建议，也不会就哪种方法更好而争论。任何数量的单元测试都比没有好。我们个人的偏好是采用*中间方法*。在使用测试驱动开发（TDD）时，我们有时觉得测试创建的努力因为规格/需求的变化而白费。一开始编写的测试容易因为需求变化而需要不断修正。在最后编写单元测试的问题在于，我们的目标是创建符合当前实现的测试。编写的测试是为了测试实现，而不是测试规格。在中间某个地方添加测试对我们来说效果最好。
- en: Let's now try to understand the tooling and technology landscape available for
    Angular testing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来了解一下可用于 Angular 测试的工具和技术环境。
- en: The Angular testing ecosystem
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 测试生态系统
- en: 'Look at the following diagram to understand the tools and frameworks that support
    Angular testing:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表，了解支持 Angular 测试的工具和框架：
- en: '![](img/00070.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00070.jpeg)'
- en: The tools and frameworks that support Angular testing
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 支持Angular测试的工具和框架
- en: As we can see, we write our tests using unit testing libraries such as **Jasmine**
    or **Mocha**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们使用单元测试库，如**Jasmine**或**Mocha**来编写测试。
- en: At the moment, the Angular testing library works by default with *Jasmine*.
    However, the Angular team has indicated that they have made the framework more
    generic so that you can use other testing libraries such as Mocha with it. The
    Angular documentation has not yet been updated to include how to do this. For
    a discussion of using Mocha with the Angular CLI testing commands see [https://github.com/angular/angular-cli/issues/4071](https://github.com/angular/angular-cli/issues/4071).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Angular 测试库默认与*Jasmine*一起工作。然而，Angular 团队已经表明，他们已经使框架更加通用，这样你就可以使用其他测试库，如
    Mocha。Angular 文档尚未更新以包含如何做到这一点。有关使用 Mocha 与 Angular CLI 测试命令的讨论，请参阅[https://github.com/angular/angular-cli/issues/4071](https://github.com/angular/angular-cli/issues/4071)。
- en: These tests are executed by either Karma or Protractor depending on whether
    we are writing unit or integration tests. These test runners in turn run our tests
    in a browser such as Chrome, Firefox, IE, or headless browsers such as PhantomJS.
    It is important to highlight that not only E2E, but also unit tests are executed
    in a real browser.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试根据我们是否编写单元测试或集成测试，由 Karma 或 Protractor 执行。这些测试运行器反过来在浏览器（如 Chrome、Firefox、IE）或无头浏览器（如
    PhantomJS）中运行我们的测试。重要的是要强调，不仅端到端测试，单元测试也是在真实浏览器中执行的。
- en: All the tests in this chapter are written using Jasmine (both unit and integration
    tests). Karma will be our test runner for unit tests and Protractor for E2E tests.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有测试都是使用 Jasmine 编写的（包括单元测试和集成测试）。Karma 将作为单元测试的测试运行器，而 Protractor 将用于端到端测试。
- en: Getting started with unit testing
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用单元测试
- en: 'The ultimate aim of unit testing is to test a specific piece of code/component
    in isolation to make sure that the components work according to the specification.
    This reduces the chances of failures/bugs in the component when integrated with
    other parts of the software. Before we start writing tests, there are some guidelines
    that can help us write good and maintainable tests:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的最终目的是在隔离状态下测试特定的代码/组件，以确保组件按照规范工作。这减少了组件与其他软件部分集成时出现失败/错误的机会。在我们开始编写测试之前，有一些指导原则可以帮助我们编写良好且可维护的测试：
- en: One unit should test one behavior. For obvious reasons, testing one behavior
    per unit test makes sense. A failing unit test should clearly highlight the problem
    area. If multiple behaviors are tested together, a failed test requires more probing
    to assert what behavior was violated.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单元应该测试一个行为。出于明显的原因，每个单元测试测试一个行为是有意义的。失败的单元测试应清楚地突出问题区域。如果一起测试多个行为，失败的测试需要更多的调查来确定违反了哪个行为。
- en: Dependencies in a unit test should be mocked away using test doubles such as
    fakes, mocks, or st. Unit testing, as the name suggests, should test the unit
    and not its dependencies.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试中的依赖项应使用测试替身（如模拟、模拟或 st）来模拟。正如其名所示，单元测试应该测试单元，而不是其依赖项。
- en: Unit tests should not change the state of the component being tested permanently.
    If it does happen, other tests may get affected.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试不应该永久改变被测试组件的状态。如果发生了这种情况，其他测试可能会受到影响。
- en: The order of execution of unit tests should be immaterial. One unit test should
    not be dependent on another unit test to execute before it. This is a sign of
    a brittle unit test. It may also mean that the dependencies are not mocked.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的执行顺序应该是无关紧要的。一个单元测试不应该依赖于另一个单元测试在它之前执行。这是脆弱单元测试的迹象。这也可能意味着依赖项没有被模拟。
- en: Unit tests should be fast. If they are not fast enough, developers will not
    run them. This is a good reason to mock all dependencies such as database access,
    remote web service call, and others in a unit test.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该快速。如果它们不够快，开发者就不会运行它们。这是一个在单元测试中模拟所有依赖项（如数据库访问、远程Web服务调用等）的好理由。
- en: 'Unit tests should try to cover all code paths. Code coverage is a metric that
    can help us assess the effectiveness of unit tests. If we have covered all positive
    and negative scenarios during testing, the coverage will indeed be higher. A word
    of caution here: high code coverage does not imply that the code is bug-free,
    but low coverage clearly highlights a lack of areas covered in unit tests.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应尝试覆盖所有代码路径。代码覆盖率是一个可以帮助我们评估单元测试有效性的指标。如果在测试期间覆盖了所有正面和负面场景，覆盖率确实会更高。在此提醒一点：高代码覆盖率并不意味着代码没有错误，但低覆盖率明显表明单元测试中未覆盖的区域。
- en: Unit tests should test both positive and negative scenarios. Just don't concentrate
    on positive test cases; all software can fail, and hence unit testing failure
    scenarios are as important to test as success scenarios.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应测试正面和负面场景。只是不要只关注正面测试用例；所有软件都可能失败，因此单元测试失败场景与成功场景一样重要。
- en: These guidelines are not framework-specific, but give us enough ammunition for
    writing good tests. Let's begin the process of unit testing by setting up the
    components required for it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指导原则不是框架特定的，但为我们编写良好测试提供了足够的弹药。让我们通过设置单元测试所需的组件来开始单元测试的过程。
- en: Setting up Karma and Jasmine for unit testing
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为单元测试设置 Karma 和 Jasmine
- en: 'When we created our project using the Angular CLI, the CLI configured the setup
    for unit testing our code with Karma and Jasmine. It did so by adding several
    Karma and Jasmine modules to our project. It also added a Karma configuration
    file—`karma.config.js`—to the root directory of our application—`trainer/`—and
    a file called `tests.ts` in the `trainer/src` directory. The CLI makes use of
    these files at runtime to create the configuration for executing our tests. This
    means that we can run our tests by simply using the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Angular CLI 创建项目时，CLI 会配置使用 Karma 和 Jasmine 对我们的代码进行单元测试的设置。它是通过向我们的项目中添加几个
    Karma 和 Jasmine 模块来实现的。它还在应用程序的根目录 `trainer/` 中添加了一个名为 `karma.config.js` 的 Karma
    配置文件，并在 `trainer/src` 目录中添加了一个名为 `tests.ts` 的文件。CLI 在运行时使用这些文件来创建执行我们的测试的配置。这意味着我们可以通过简单地使用以下命令来运行我们的测试：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And the CLI will also watch our tests for changes and automatically rerun them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 还会监视我们的测试以检测更改，并自动重新运行它们。
- en: We will not be covering the configuration files in detail here. The out-of-the-box
    settings will be fine for our purposes. Refer to the Karma documentation ([http://karma-runner.github.io/1.0/config/configuration-file.html](http://karma-runner.github.io/1.0/config/configuration-file.html))
    to understand more about the various Karma configuration options.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会详细讲解配置文件。默认设置对我们的目的来说已经足够了。有关各种 Karma 配置选项的更多信息，请参阅 Karma 文档（[http://karma-runner.github.io/1.0/config/configuration-file.html](http://karma-runner.github.io/1.0/config/configuration-file.html)）。
- en: Organization and naming of our test files
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们测试文件的组织和命名
- en: To unit test our app, we should have one test (such as `workout-runner.spec.ts`)
    file for each TypeScript file that we plan to test in our project. And this is
    what the Angular CLI does for us. When we create a component, service, pipe, or
    directive using the CLI, the CLI will generate a corresponding test and place
    it in the same file directory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要对应用程序进行单元测试，我们应该为项目中计划测试的每个 TypeScript 文件有一个测试文件（例如 `workout-runner.spec.ts`）。这正是
    Angular CLI 为我们做的事情。当我们使用 CLI 创建组件、服务、管道或指令时，CLI 将生成相应的测试并将其放置在相同的文件目录中。
- en: Naming the test files with the name of the file under test plus `.spec` is a
    convention that is used by developers who test with Jasmine. It is also used to
    facilitate the mapping of files to tests in the configuration steps that we outlined
    previously.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用被测试文件名称加上 `.spec` 来命名测试文件是使用 Jasmine 进行测试的开发者所采用的一种约定。它也用于便于我们在之前概述的配置步骤中映射文件到测试。
- en: 'This test file contains the unit test specification for the corresponding component,
    as shown in the following screenshot (taken in the Karma debugger when running
    our unit tests):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试文件包含对应组件的单元测试规范，如下面的截图所示（在运行单元测试时在 Karma 调试器中捕获）：
- en: '![](img/00071.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00071.jpeg)'
- en: Unit-testing Angular applications
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试 Angular 应用程序
- en: Over the course of this book, we have built components that cover every construct
    available in Angular. We have built components, pipes, a few services, and finally
    some directives too. All of these are testable in unit tests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们构建了涵盖 Angular 中每个构造的组件。我们构建了组件、管道、一些服务，最后还有一些指令。所有这些都可以在单元测试中进行测试。
- en: The code for the rest of this chapter can be found in `checkpoint 7.2`. It is
    available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub. If
    you are not using Git, download the snapshot of `checkpoint7.2` (a ZIP file) from
    this GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint7.2.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余的代码可以在 `checkpoint 7.2` 中找到。它可以在 GitHub 上供每个人下载（[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)）。检查点作为
    GitHub 上的分支实现。如果您不使用 Git，可以从以下 GitHub 位置下载 `checkpoint7.2` 的快照（ZIP 文件）：[https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip)。在首次设置快照时，请参考
    `trainer` 文件夹中的 `README.md` 文件。
- en: 'Just to get the hang of unit testing with Jasmine, let''s test the smallest
    and easiest component first: the pipe.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉使用 Jasmine 进行单元测试，让我们首先测试最小且最简单的组件：管道。
- en: Unit-testing pipes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试管道
- en: Pipes are the easiest to test as they have minimum or zero dependencies on other
    constructs. The `SecondsToTimePipe` that we created for *Workout Runner* (the
    *7 Minute Workout* app) has no dependencies and can be easily unit-tested.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是最容易测试的，因为它们对其他构造的依赖最小或为零。我们为*Workout Runner*（*7分钟锻炼*应用程序）创建的`SecondsToTimePipe`没有依赖关系，可以轻松地进行单元测试。
- en: Look at the Jasmine framework documentation to understand how to write unit
    tests using Jasmine. The CLI is using Jasmine 2.6 for our unit tests ([http://jasmine.github.io/2.6/introduction.html](http://jasmine.github.io/2.0/introduction.html)).
    Jasmine has some of the best documentations available and the overall framework
    is very intuitive to use. We strongly recommend that you head over to the Jasmine
    site and get yourself familiar with the framework before you proceed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Jasmine框架文档，了解如何使用Jasmine编写单元测试。CLI正在使用Jasmine 2.6进行我们的单元测试（[http://jasmine.github.io/2.6/introduction.html](http://jasmine.github.io/2.0/introduction.html)）。Jasmine拥有一些最好的文档，并且整个框架非常直观易用。我们强烈建议您访问Jasmine网站，在继续之前熟悉这个框架。
- en: 'Open the  `seconds-to-time.pipe.spec.ts` file in the `trainer/src/app/shared `
    folder and update the unit test in there as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trainer/src/app/shared`文件夹中打开`seconds-to-time.pipe.spec.ts`文件，并按照以下方式更新那里的单元测试：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's take a look at what we are doing here in our test file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在我们的测试文件中我们正在做什么。
- en: 'Not surprisingly, we import `SecondsToTimePipe`, which we are going to test.
    This is just like the imports we have used elsewhere in our TypeScript classes.
    Notice that we use a relative path to the file in which it is located `''./seconds-to-time.pipe''`.
    In Angular, this means to look for the component to test in the same directory
    as the test itself. As you recall, this is the way we set up our file structure:
    putting our tests in the same directory as the file under test.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们导入了`SecondsToTimePipe`，这是我们将要测试的。这就像我们在TypeScript类中其他地方使用的导入一样。请注意，我们使用了一个相对路径来指向该文件的位置
    `'./seconds-to-time.pipe'`。在Angular中，这意味着在测试本身所在的目录中查找要测试的组件。如您所回忆的，这是我们设置文件结构的方式：将我们的测试放在与被测试文件相同的目录中。
- en: In the next line, we start using Jasmine syntax. First, we wrap the test in
    a `describe` function that identifies the test. The first parameter of this function
    is a user-friendly description of the test; in this case, it is `SecondsToTimePipe`.
    For the second parameter, we pass a lambda (fat arrow) function that will contain
    our test. After setting up a local variable to hold the pipe, we call Jasmine's
    `beforeEach` function and use this to inject an instance of our pipe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们开始使用Jasmine语法。首先，我们用`describe`函数包裹测试以标识测试。这个函数的第一个参数是对测试的用户友好描述；在这种情况下，它是`SecondsToTimePipe`。对于第二个参数，我们传递一个lambda（胖箭头）函数，它将包含我们的测试。在设置一个本地变量来保存管道后，我们调用Jasmine的`beforeEach`函数，并使用它来注入我们的管道实例。
- en: Since the `beforeEach` function runs before every test that is in our `describe` function,
    we can use it for common code that will run in each of our tests. In this case,
    it is not strictly necessary since there is only one test in our `describe` function.
    But it is a good idea to get into the habit of using it for common setup scenarios,
    as we will see going forward.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`beforeEach`函数在`describe`函数中的每个测试之前运行，我们可以用它来运行每个测试中都会运行的公共代码。在这种情况下，它不是严格必要的，因为我们的`describe`函数中只有一个测试。但养成使用它的习惯是一个好主意，正如我们将看到的那样。
- en: Next, we call Jasmine's `it` function and pass it a title, along with three
    calls to Jasmine's `expect` function (Jasmine's name for assertions). These are
    all self-explanatory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用Jasmine的`it`函数，并传递一个标题，以及三个对Jasmine的`expect`函数（Jasmine对断言的称呼）的调用。这些都是不言自明的。
- en: It is not necessary to explicitly import these Jasmine functions in our test.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中不需要显式导入这些Jasmine函数。
- en: Running our test files
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的测试文件
- en: 'Now it''s time to run our tests using the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用以下命令运行我们的测试了：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Angular CLI will transpile our TypeScript files to JavaScript and then watch
    for changes in these files.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI将把我们的TypeScript文件转换为JavaScript，并监视这些文件的变化。
- en: 'We should then see this output in the Terminal window (the total number of
    tests may be different for you):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在终端窗口中看到这个输出（对于您来说，测试的总数可能不同）：
- en: '![](img/00072.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: The last line shows that our test passed successfully (along with all our other
    tests).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行显示我们的测试成功通过（以及我们所有的其他测试）。
- en: 'You can also view the test results in the browser window that Karma will launch
    when it runs our tests:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在Karma运行我们的测试时它启动的浏览器窗口中查看测试结果：
- en: '![](img/00073.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00073.jpeg)'
- en: You'll notice here that Karma displays the `describe` statement (SecondsToTimePipe)
    that is used for our pipe tests and nests under it under the `it` statement (should
    convert integer to time format) for the test we have created in order to show
    us the expected results for our test. Reading the results as they are displayed
    makes it very easy to understand the outcome of our test.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这里，Karma 显示了用于我们管道测试的 `describe` 语句（SecondsToTimePipe），并且在其下嵌套了 `it` 语句（应将整数转换为时间格式），以展示我们创建的测试的预期结果。以显示的格式读取结果使得理解测试结果变得非常容易。
- en: 'To make sure that it is reporting the correct pass/fail results, let''s make
    a change in the test to cause one of the expectations to fail. Change the time
    in the first expectation to six seconds rather than five, like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它报告正确的通过/失败结果，让我们在测试中做一个更改，导致其中一个期望失败。将第一个期望中的时间从五秒更改为六秒，如下所示：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We get the following error message:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下错误消息：
- en: '![](img/00074.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00074.jpeg)'
- en: What's nice about this error message is that it combines the `describe` and
    `it` descriptions into a complete sentence that provides a clear summary of the
    error. This shows how Jasmine allows us to write readable tests so that someone
    who is new to our code can quickly understand any problems that may arise in it.
    The next line shows us which expectation was not met, what was expected, and what
    the actual results were that did not meet this expectation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误消息的优点是它将 `describe` 和 `it` 描述合并成一个完整的句子，提供了对错误的清晰总结。这显示了 Jasmine 如何允许我们编写可读的测试，以便新接触我们代码的人可以快速理解其中可能出现的任何问题。下一行显示了哪个期望未满足，期望的是什么，以及实际结果是什么，这些结果没有满足这个期望。
- en: 'We also get a stack trace below this message and a final line that shows the
    overall results of our tests:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此消息下方，我们还得到一个堆栈跟踪和一个显示我们测试总体结果的最后一条线：
- en: '![](img/00075.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00075.jpeg)'
- en: 'And in the browser, we see the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们看到以下内容：
- en: '![](img/00076.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00076.jpeg)'
- en: One thing you'll notice is that when we make the change to our test, we do not
    have to rerun Karma. Instead, it watches for any changes in our files and related
    tests and immediately reports success or failure whenever we make a change.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当我们更改测试时，我们不必重新运行 Karma。相反，它监视我们文件和相关测试的任何更改，并在我们做出更改时立即报告成功或失败。
- en: Pretty cool! Let's undo the last change that we made and put the test back into
    a passing state.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 非常酷！让我们撤销我们做的最后一个更改，将测试恢复到通过状态。
- en: Unit-testing components
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试组件
- en: Testing Angular components is more complicated than testing simple pipes or
    services. That is because Angular components are associated with views and also
    usually have more dependencies than services, filters, or directives.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 Angular 组件比测试简单的管道或服务更复杂。这是因为 Angular 组件与视图相关联，并且通常比服务、过滤器或指令有更多的依赖项。
- en: Angular testing utilities
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 测试实用工具
- en: Because of their complexity, Angular has introduced utilities that enable us
    to test our components more easily. These testing utilities include the `TestBed`
    class (which we previously used to initialize our tests) and several helper functions
    in `@angular/core/testing`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的复杂性，Angular 引入了使我们可以更容易地测试组件的实用工具。这些测试实用工具包括 `TestBed` 类（我们之前用来初始化测试的）和
    `@angular/core/testing` 中的几个辅助函数。
- en: '`TestBed` has a `createComponent` method that returns a `ComponentFixture`
    containing several members and methods, including:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestBed` 有一个 `createComponent` 方法，它返回一个包含多个成员和方法的 `ComponentFixture`，包括：'
- en: '`debugElement`: For debugging a component'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debugElement`：用于调试组件'
- en: '`componentInstance`: For accessing the component properties and methods'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentInstance`：用于访问组件属性和方法'
- en: '`nativeElement`: For accessing the view''s markup and other DOM elements'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nativeElement`：用于访问视图的标记和其它DOM元素'
- en: '`detectChanges`: For triggering the component''s change detection cycle'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detectChanges`：用于触发组件的变更检测周期'
- en: '`ComnponentFixture` also contains methods for overriding the view, directives,
    bindings, and providers of a component. Going forward, we will be using `TestBed`
    throughout the rest of our tests.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComnponentFixture` 还包含用于覆盖组件视图、指令、绑定和提供者的方法。从现在开始，我们将在剩余的测试中使用 `TestBed`。'
- en: '`TestBed` has a method called `configureTestingModule` that we can use to set
    up our testing as its own module. This means we can bypass the initial bootstrap
    process and compile our components under test within our test files. We can also
    use `TestBed` to specify additional dependencies and identify the providers that
    we will need.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestBed` 有一个名为 `configureTestingModule` 的方法，我们可以使用它来设置我们的测试作为一个单独的模块。这意味着我们可以绕过初始引导过程，并在我们的测试文件中编译要测试的组件。我们还可以使用
    `TestBed` 来指定额外的依赖项并识别我们需要的提供者。'
- en: According to the Angular documentation (https://angular.io/guide/testing#testbed-class-summary),
    it is important to *call TestBed methods within a* `beforeEach`*to ensure a fresh
    start before each individual test*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Angular文档（https://angular.io/guide/testing#testbed-class-summary），在 `beforeEach`
    中调用 `TestBed` 方法对于确保每个单独测试前的全新开始非常重要。
- en: Managing dependencies in our tests
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的测试中管理依赖项
- en: Components in Angular integrate the view with everything else. Due to this,
    components normally have more dependencies compared to any of the services, filters,
    or directives.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 中的组件将视图与所有其他内容集成。因此，与任何服务、过滤器或指令相比，组件通常有更多的依赖项。
- en: Notwithstanding the fact that our unit tests focus on the code within the component
    itself, we still need to account for these dependencies in our tests or else the
    tests will fail (we skipped the dependency setup for pipe testing as it did not
    have external dependencies).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的单元测试专注于组件内部的代码，但我们仍然需要在测试中考虑这些依赖项，否则测试将失败（我们跳过了管道测试的依赖项设置，因为它没有外部依赖）。
- en: 'Two approaches exist for handling these dependencies: inject them into our
    component or create a mock or fake for them that we can use in our tests. If a
    dependency is simple enough, we can just inject an instance of it into our test
    class. However, if the dependency is significantly complicated, especially if
    it has dependencies of its own and/or makes remote server calls, then we should
    be mocking it. The Angular testing library provides the tools for us to do that.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些依赖项有两种方法：将它们注入到我们的组件中或为它们创建一个模拟或伪造，我们可以在测试中使用它。如果一个依赖项足够简单，我们只需将其实例注入到测试类中即可。然而，如果一个依赖项非常复杂，特别是如果它有自己的依赖项并且/或者进行远程服务器调用，那么我们应该模拟它。Angular
    测试库为我们提供了进行此操作的工具。
- en: The component that we plan to test in this section is the `WorkoutRunner` component.
    Located inside `trainer/src/components/workout-runner/`, this is the component
    that runs a specific workout.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节计划测试的组件是 `WorkoutRunner` 组件。位于 `trainer/src/components/workout-runner/`
    中，这是运行特定锻炼的组件。
- en: Unit-testing WorkoutRunnerComponent
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试 WorkoutRunnerComponent
- en: With this background, let's get started with unit testing `WorkoutRunnerComponent`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，让我们开始对 `WorkoutRunnerComponent` 进行单元测试。
- en: 'First, open `workout-runner-component.spec.ts` and update the imports to the
    following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 `workout-runner-component.spec.ts` 并更新导入如下：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These imports identify the test utilities (and things such as `Router` and `of`
    from `RxJS`) that we will be using in our tests along with the types and dependencies
    that our component requires. We'll discuss these dependencies in a moment. One
    import that looks different from the others is the one that imports `NO_ERRORS_SCHEMA`
    from `@angular/core`. We will use this import to ignore elements in the component
    that we will not be testing. Again, we will discuss that further in a moment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些导入标识了我们在测试中将使用的测试工具（以及来自 `RxJS` 的 `Router` 和 `of` 等东西），以及我们的组件所需的类型和依赖项。我们稍后会讨论这些依赖项。其中一个与其他导入不同的导入是导入
    `@angular/core` 中的 `NO_ERRORS_SCHEMA`。我们将使用这个导入来忽略我们不会测试的组件中的元素。同样，我们稍后会进一步讨论这一点。
- en: One more thing to note with the imports is that `@angular/core/testing` is a
    part of the core module and not in a separate testing module. This is a common
    pattern with imports for Angular testing. For example, when we get to testing
    HTTP, you will see that we are importing from `@angular/http/testing`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于导入还有一点需要注意，即 `@angular/core/testing` 是核心模块的一部分，而不是单独的测试模块。这是Angular测试导入的常见模式。例如，当我们到达HTTP测试时，你会看到我们是从
    `@angular/http/testing` 导入的。
- en: Setting up component dependencies
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置组件依赖项
- en: 'Next, we need to establish our component''s dependencies and determine whether
    we need to inject or mock them. If we look at the code for the `WorkoutRunner`
    component, we see that there are three dependencies being injected into our component:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定我们的组件依赖项，并确定我们是否需要注入或模拟它们。如果我们查看 `WorkoutRunner` 组件的代码，我们会看到有三个依赖项被注入到我们的组件中：
- en: '`WorkoutHistoryTracker`: This is a component that has some behavior attached
    to it. So we definitely want to mock it.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkoutHistoryTracker`：这是一个附加了一些行为的组件。因此，我们肯定想要模拟它。'
- en: '`Router`: We''ll have to mock this too in order to isolate `WorkoutRunner`
    from the rest of the application and prevent our test from trying to navigate
    away from the `WorkoutRunner` view.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Router`：我们也必须模拟这个，以便将`WorkoutRunner`与应用程序的其余部分隔离开来，并防止我们的测试尝试从`WorkoutRunner`视图中导航离开。'
- en: '`WorkoutService:` This is a service that we will use to make an HTTP call to
    retrieve our workouts. We will mock this service as well since we don''t want
    to be making a call to an external system within our test.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkoutService`：这是一个我们将用它来发起HTTP调用以检索我们的锻炼的服务。我们也将模拟这个服务，因为我们不希望在测试中向外部系统发起调用。'
- en: Mocking dependencies - workout history tracker
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟依赖 - 锻炼历史跟踪器
- en: 'Angular allows us to mock our dependencies in a straightforward manner using
    simple classes. Let''s start with mocking `WorkoutHistoryTracker`. To do that,
    add the following class just after the imports:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Angular允许我们使用简单的类以直接的方式模拟我们的依赖。让我们从模拟`WorkoutHistoryTracker`开始。为此，在导入之后添加以下类：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We do not need to mock the entire `WorkoutHistoryTracker` class, but only the
    methods that `WorkoutRunner` will be calling. In this case, those methods are
    `startTracking()`, `endTracking()`, and `exerciseComplete()`. We have made these
    methods empty because we do not need anything returned from them in order to test
    `WorkoutRunner`. Now we can inject this dummy implementation into `WorkoutRunner` wherever
    it is looking for `WorkoutHistoryTracker`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要模拟整个`WorkoutHistoryTracker`类，而只需要模拟`WorkoutRunner`将要调用的方法。在这种情况下，这些方法包括`startTracking()`、`endTracking()`和`exerciseComplete()`。我们已经将这些方法设置为空，因为我们不需要从它们那里返回任何内容来测试`WorkoutRunner`。现在我们可以将这个虚拟实现注入到`WorkoutRunner`中，无论它在何处寻找`WorkoutHistoryTracker`。
- en: Mocking dependencies – workout service
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟依赖 - 锻炼服务
- en: 'In Chapter 5, *Supporting Server Data Persistence*, we extended the workout
    service to make a remote call to retrieve the data that populates a workout. For
    unit testing the workout runner, we will want to replace that call with a mock
    implementation that returns some static data that we can use to run the test.
    So we will add a third mock class, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章“支持服务器数据持久性”中，我们扩展了锻炼服务以进行远程调用以检索填充锻炼的数据。为了对锻炼运行器进行单元测试，我们希望用返回一些静态数据的模拟实现来替换这个调用，这样我们就可以使用这些数据来运行测试。因此，我们将添加第三个模拟类，如下所示：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that the `getWorkout` method is returning an `Observable`, as indicated
    by the use of the `of` operator. Otherwise the class is self-explanatory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`getWorkout`方法返回了一个`Observable`，正如使用`of`操作符所示。否则，这个类是自解释的。
- en: Mocking dependencies - router
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟依赖 - 路由
- en: 'As with `WorkoutHistoryTracker` and `WorkoutService`, we also will be using
    mocking to handle the dependency that we have on the Angular router. But here
    we will be taking a slightly different approach. We will assign a Jasmine spy
    to a `navigate` method on our mock:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`WorkoutHistoryTracker`和`WorkoutService`一样，我们也将使用模拟来处理我们对Angular路由的依赖。但在这里，我们将采取一种稍微不同的方法。我们将把一个Jasmine
    spy分配给我们的模拟上的`navigate`方法：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will be sufficient for our purposes because we only want to make sure that
    the router's `navigate` method is being called with the appropriate route (`finished`)
    as a parameter. The Jasmine spy will allow us to do that as we will see later.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于我们的目的来说已经足够了，因为我们只想确保路由器的`navigate`方法是以适当的路由（`finished`）作为参数被调用的。Jasmine的spy将允许我们做到这一点，就像我们稍后将要看到的那样。
- en: Configuring our test using TestBed
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TestBed配置我们的测试
- en: 'Now that we have our imports and dependencies out of the way, let''s get started
    with the tests themselves. We begin by adding a Jasmine `describe` function that
    will wrap our tests, followed by setting two local variables using `let`: one
    for `fixture` and the other for `runner`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理好了导入和依赖，让我们开始进行测试本身。我们首先添加一个Jasmine `describe`函数来包装我们的测试，然后使用`let`设置两个局部变量：一个用于`fixture`，另一个用于`runner`：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next we''ll add a `beforeEach` function that sets up our test configuration:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个`beforeEach`函数来设置我们的测试配置：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `beforeEach` method executes before each test, which means that we will
    only have to set this up once in our test file. Inside `beforeEach`, we add an
    `async` call. This is required because of the asynchronous `compileComponents`
    method that we are calling.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach`方法在每个测试之前执行，这意味着我们只需要在我们的测试文件中设置一次。在`beforeEach`内部，我们添加一个`async`调用。这是必需的，因为我们正在调用异步的`compileComponents`方法。'
- en: The Angular documentation indicates that the `async` function arranges for the
    tester's code to run in a special `async` test zone that hides the mechanics of
    asynchronous execution, just as it does when passed to an `it` test. For more
    information refer to `https://angular.io/docs/ts/latest/guide/testing.html#!#async-in-before-each`.
    We'll discuss this in more detail shortly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Angular文档表明，`async`函数安排测试者的代码在一个特殊的`async`测试区域内运行，这个区域隐藏了异步执行的机制，就像它传递给`it`测试时一样。有关更多信息，请参阅`https://angular.io/docs/ts/latest/guide/testing.html#!#async-in-before-each`。我们将在稍后详细讨论这一点。
- en: Let's go through each method call in the order that they are executed. The first
    method, `configureTestingModule`, allows us to build on the base configuration
    of the testing module and add things such as imports, declarations (of the components,
    directives, and pipes we will be using in our test), and providers. In the case
    of our test, we are first adding declarations for the workout runner, our component
    under test, and the `SecondsToTimePipe:`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照它们执行的顺序逐一查看每个方法调用。第一个方法是`configureTestingModule`，它允许我们在测试模块的基本配置上构建，并添加诸如导入、声明（我们将在测试中使用的组件、指令和管道）和提供者等。在我们的测试中，我们首先添加了关于锻炼运行者、我们正在测试的组件以及`SecondsToTimePipe`的声明：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we add three providers for our `Router`, `WorkoutHistoryTracker`, and
    `WorkoutService`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为我们的`Router`、`WorkoutHistoryTracker`和`WorkoutService`添加了三个提供者：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For each of these providers, we set the `useClass` property to our mocks instead
    of the actual components. Now, anywhere in our test, when the `WorkoutRunner`
    requires any of these components, the mock will be used instead.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些提供者中的每一个，我们将`useClass`属性设置为我们的模拟而不是实际组件。现在，在我们的测试中，当`WorkoutRunner`需要这些组件中的任何一个时，将使用模拟。
- en: 'The next configuration may seem a bit mysterious:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配置可能看起来有点神秘：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This setting allows us to bypass the errors we would otherwise get regarding
    the custom elements associated with two components that we are using in the component's
    template: `ExerciseDescriptionComponent` and `VideoPlayerComponent`. At this point,
    we don't want to be testing these components within the test for the `WorkoutRunnerComponent`.
    Instead, we should be testing them separately. One thing to be aware of, however,
    when you use this setting is that it will suppress all schema errors related to
    elements and attributes in the template of the component under test; so it may
    hide other errors that you do want to see.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置允许我们绕过与我们在组件模板中使用的两个组件（`ExerciseDescriptionComponent`和`VideoPlayerComponent`）相关的自定义元素可能产生的错误。在这个阶段，我们不想在`WorkoutRunnerComponent`的测试中测试这些组件。相反，我们应该单独测试它们。然而，需要注意的是，当你使用这个设置时，它将抑制与测试组件模板中的元素和属性相关的所有模式错误；因此，它可能会隐藏你希望看到的其他错误。
- en: When you set up a test using `NO_ERRORS_SCHEMA`, you are creating what is called
    a shallow test, one that does not go deeper than the component you are testing.
    Shallow tests allow you to reduce complexities in the templates within the component
    you are testing and reduce the need for mocking dependencies.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`NO_ERRORS_SCHEMA`设置测试时，你正在创建一个所谓的浅测试，它不会深入到你正在测试的组件。浅测试允许你减少你正在测试的组件模板中的复杂性，并减少对模拟依赖的需求。
- en: 'The final steps in the configuration of our test are to compile and instantiate
    our components:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试配置的最后一步是编译和实例化我们的组件：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As mentioned previously, we are using an `async` function in our `beforeEach`
    method because this is required when we call the `compileComponents` method. This
    method call is asynchronous and we need to use it here because our component has
    an external template that is specified in a `templateUrl`. This method compiles
    that external template and then inlines it so that it can be used by the `createComponent`
    method (which is synchronous) to create our component fixture. This component
    fixture in turn contains a `componentInstance`-`WorkoutRunner`. We then assign
    both the `fixture` and the `componentInstance` to local variables.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们在`beforeEach`方法中使用了一个`async`函数，因为当我们调用`compileComponents`方法时这是必需的。这个方法调用是异步的，我们需要在这里使用它，因为我们的组件有一个外部模板，该模板在`templateUrl`中指定。此方法编译该外部模板，然后将其内联，以便它可以由`createComponent`方法（它是同步的）使用来创建我们的组件固定装置。这个组件固定装置反过来包含一个`componentInstance`-`WorkoutRunner`。然后我们将`fixture`和`componentInstance`都分配给局部变量。
- en: As mentioned previously, the `async` function we are using creates a special
    `async` test zone in which our tests will run. You'll notice that this function
    is simplified from normal `async` programming and lets us do things such as using
    the `.then` operator without returning a promise.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们正在使用的`async`函数创建了一个特殊的`async`测试区域，我们的测试将在其中运行。你会注意到这个函数是从正常的`async`编程中简化的，并允许我们做一些事情，比如使用`.then`运算符而不返回一个承诺。
- en: You can also compile and instantiate test components inside individual test
    methods. But the `beforeEach` method allows us to do it once for all our tests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在单个测试方法内编译和实例化测试组件。但`beforeEach`方法允许我们为所有测试执行一次操作。
- en: Now that we have configured our test, let's move on to unit-testing `WorkoutRunner`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了测试，让我们继续对`WorkoutRunner`进行单元测试。
- en: Starting unit testing
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始单元测试
- en: Starting from the loading of workout data to transitioning of exercises, pausing
    workouts, and running exercise videos, there are a number of aspects of the `WorkoutRunner`
    that we can test. The `workout.spec.ts` file (available in the `components/workout-runner`
    folder under `trainer/src`) contains a number of unit tests that cover the preceding
    scenarios. We will pick up some of those tests and work through them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从加载数据到过渡到练习、暂停锻炼和运行练习视频，`WorkoutRunner`有许多方面我们可以进行测试。`workout.spec.ts`文件（位于`trainer/src/components/workout-runner`文件夹下）包含了一系列单元测试，覆盖了上述场景。我们将选择其中一些测试并逐一进行。
- en: 'To start with, let''s add a test case that verifies that the workout starts
    running once the component is loaded:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个测试用例来验证一旦组件加载，锻炼就开始运行：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This test asserts that the total duration of the workout is correct and the
    workout is in the running state (that is, not paused).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试断言锻炼的总时长正确，锻炼处于运行状态（即，没有暂停）。
- en: So let's execute the test. It fails (check the Karma console). Strange! All
    the dependencies have been set up correctly, but still the second `expect` function
    of the `it` block fails as it is undefined.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们执行测试。它失败了（检查Karma控制台）。奇怪！所有依赖项都已正确设置，但第二个`expect`函数在`it`块中仍然失败，因为它未定义。
- en: We need to debug this test.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调试这个测试。
- en: Debugging unit tests in Karma
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Karma中调试单元测试
- en: Debugging unit tests in Karma is easy as the tests are run in the browser. We
    debug tests as we debug the standard JavaScript code. And since our Karma configuration
    has added mappings from our TypeScript files to our JavaScript files, we can debug
    directly in TypeScript.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Karma中调试单元测试很容易，因为测试是在浏览器中运行的。我们像调试标准JavaScript代码一样调试测试。由于我们的Karma配置已将我们的TypeScript文件映射到我们的JavaScript文件，我们可以直接在TypeScript中进行调试。
- en: When Karma starts, it opens a specific browser window to run the tests. To debug
    any test in Karma, we just need to click on the Debug button available at the
    top of the browser window.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当Karma启动时，它会打开一个特定的浏览器窗口来运行测试。要调试Karma中的任何测试，我们只需点击浏览器窗口顶部的调试按钮。
- en: There is one window opened by Karma and one when we click on Debug; we can use
    the original window for testing too, but the original window is connected to Karma
    and does a live reload. Also, the script files in the original window are timestamped,
    which changes whenever we update the test and hence requires us to put in a breakpoint
    again to test.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Karma打开了一个窗口，当我们点击调试时又打开了一个窗口；我们也可以使用原始窗口进行测试，但原始窗口连接到Karma并执行实时刷新。此外，原始窗口中的脚本文件带有时间戳，每次更新测试时都会改变，因此我们需要再次设置断点来测试。
- en: Once we click on Debug, a new tab/window opens with all the tests and other
    app scripts loaded for testing. These are scripts that were defined during the
    Karma configuration setup in the `karma.conf.js` files section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击调试，就会打开一个新的标签页/窗口，其中加载了所有测试和其他应用程序脚本以供测试。这些是在`karma.conf.js`文件配置设置期间定义的脚本。
- en: To debug the preceding failure, we need to add breakpoints at two locations.
    One should be added inside the test itself and the second one inside  `WorkoutComponent`,
    where it loads the workout and assigns the data to the appropriate local variables.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试前面的失败，我们需要在两个位置添加断点。一个应该添加在测试本身内部，另一个应该添加在`WorkoutComponent`内部，在那里它加载锻炼并将数据分配给适当的局部变量。
- en: 'Perform the following steps to add a breakpoint in Google Chrome:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤在Google Chrome中添加断点：
- en: Open the Karma debug window/tab by clicking on the Debug button on the window
    loaded by Karma when it started.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击Karma启动时加载的窗口上的调试按钮，打开Karma调试窗口/标签页。
- en: Press the F12 key to open the developer console.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下F12键打开开发者控制台。
- en: Go to the Sources tab and the TypeScript files for your application will be
    located in the `source` folder.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往“源”标签页，你的应用程序的TypeScript文件将位于`source`文件夹中。
- en: 'We can now put breakpoints at the required locations just by clicking on the
    line number. This is the standard mechanism to debug any script. Add breakpoints
    at the locations highlighted here:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过单击行号来在所需位置设置断点。这是调试任何脚本的常规机制。在以下突出显示的位置添加断点：
- en: '![](img/00077.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00077.jpeg)'
- en: We refresh the Debug page (the one we opened when we clicked on the Debug button).
    The breakpoint in `workout-runner.ts` is never hit, causing the test to fail.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刷新调试页面（我们在点击调试按钮时打开的页面）。`workout-runner.ts`中的断点从未被触发，导致测试失败。
- en: 'What we overlooked is that the code that we were trying to reach is within
    the `start` method of `workout-runner`, and the `start` method is not being called
    in the constructor. Instead it is called in `ngDoCheck` after the data for the
    workout has been loaded through a call to the `getWorkout` method in `ngOnInit`.
    Add calls to `ngOnInit` and `ngDoCheck` in your test, like so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略的是，我们试图访问的代码位于`workout-runner`的`start`方法中，而`start`方法并没有在构造函数中被调用。相反，它在通过在`ngOnInit`中调用`getWorkout`方法加载锻炼数据之后，在`ngDoCheck`中被调用。在你的测试中添加对`ngOnInit`和`ngDoCheck`的调用，如下所示：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save the change and Karma will run the test again. This time it will pass.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改后，Karma将再次运行测试。这次它将通过。
- en: As the number of tests grows, unit testing may require us to concentrate on
    a specific test or a specific suite of tests. Karma allows us to target one or
    more tests by prepending `f` to the existing `it` block; that is, `it` becomes
    `fit`. If Karma finds tests with `fit`, it only executes those tests. Similarly,
    a specific test suite can be targeted by prepending `f` to the existing `describe`
    block: `fdescribe`. Also, if you prepend `x` to an `it` block, making it `xit`,
    then that block will be skipped.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 随着测试数量的增加，单元测试可能需要我们专注于特定的测试或特定的测试套件。Karma允许我们通过在现有的`it`块前添加`f`来定位一个或多个测试；也就是说，`it`变成了`fit`。如果Karma发现带有`fit`的测试，它只会执行这些测试。同样，可以通过在现有的`describe`块前添加`f`来定位特定的测试套件：`fdescribe`。此外，如果你在`it`块前添加`x`，使其变为`xit`，那么该块将被跳过。
- en: Let's continue unit-testing the component!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续对组件进行单元测试！
- en: Unit-testing WorkoutRunner continued...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试WorkoutRunner继续...
- en: 'What other interesting things can we test? We can test whether the first exercise
    has started. We add this test to `workout.spec.ts` after the one we just added:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能测试哪些有趣的事情呢？我们可以测试是否开始了第一个练习。我们在刚刚添加的测试之后，将这个测试添加到`workout.spec.ts`中：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second `expect` function in this test is interesting. It uses a Jasmine
    feature: spies. Spies can be used to verify method invocations and dependencies.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试中的第二个`expect`函数很有趣。它使用了Jasmine的一个特性：间谍。间谍可以用来验证方法调用和依赖关系。
- en: Using Jasmine spies to verify method invocations
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jasmine间谍来验证方法调用
- en: A spy is an object that intercepts every call to the function it is spying on.
    Once the call is intercepted, it can either return fixed data or pass the call
    to the actual function being invoked. It also records the call invocation details
    that can be used later in `expect` as we did in the preceding test.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍是一个拦截它所监视的函数每个调用的对象。一旦调用被拦截，它可以选择返回固定数据或将调用传递给实际被调用的函数。它还记录了调用调用详情，这些详情可以在之后的`expect`中使用，就像我们在前面的测试中所做的那样。
- en: Spies are very powerful and can be used in a number of ways during unit testing.
    Look at the documentation on spies at [http://jasmine.github.io/2.0/introduction.html#section-Spies](http://jasmine.github.io/2.0/introduction.html#section-Spies)
    to learn more about them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍非常强大，可以在单元测试期间以多种方式使用。查看有关间谍的文档[http://jasmine.github.io/2.0/introduction.html#section-Spies](http://jasmine.github.io/2.0/introduction.html#section-Spies)，了解更多信息。
- en: The second `expect` function verifies that the `startExercise` method was called
    when the workout started (`toHaveBeenCalledWith`). It is also asserting the correctness
    of the parameters passed to the function. The second `expect` statement asserts
    the behavior using a spy, but we first need to set up the spy to make this assert
    work.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`expect`函数验证了当锻炼开始时调用了`startExercise`方法（`toHaveBeenCalledWith`）。它还断言了传递给函数的参数的正确性。第二个`expect`语句使用间谍断言行为，但我们需要首先设置间谍以使这个断言生效。
- en: In this case, we are using the spy to mock a call to the `startExercise` method.
    We can use the spy to determine whether the method has been called and with what
    parameters, using Jasmine's `toHaveBeenCalledWith` function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用间谍来模拟对`startExercise`方法的调用。我们可以使用间谍来确定方法是否被调用以及调用时使用了什么参数，使用Jasmine的`toHaveBeenCalledWith`函数。
- en: Look at the Jasmine documentation for the `toHaveBeenCalled` and `toHaveBeenCalledWith`
    functions to learn more about these assert functions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Jasmine文档中的`toHaveBeenCalled`和`toHaveBeenCalledWith`函数，了解更多关于这些断言函数的信息。
- en: Here, the method is being called with the current `Exercise` as a parameter.
    Since the previous `expect` confirms that this is the first exercise, this `expect`
    confirms that a call to start that first exercise was executed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，方法是以当前`Exercise`作为参数被调用的。由于之前的`expect`确认这是第一个练习，这个`expect`确认启动第一个练习的调用已经执行。
- en: There are a couple of things to note here. First, you have to be careful to
    put the setup for `spyOn` prior to calling `ngOnInit`. Otherwise, the spy will
    not be *spying* when the `startExercise` method is called and the method invocation
    will not be captured.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个需要注意的事项。首先，你必须小心地将`spyOn`的设置放在调用`ngOnInit`之前。否则，当调用`startExercise`方法时，间谍将不会进行*监视*，并且方法调用不会被捕获。
- en: Second, since the spy is a mock, we will normally not be able to verify anything
    within the `startExercise` method. This is because the method itself is being
    mocked. This means that we cannot actually verify that the `currentExercise` property
    has been set, since that is being done inside the mocked method. However, Jasmine
    allows us to chain the spy with `and.callThrough`, which will mean that in addition
    to tracking the calls to the method, it will delegate to the actual implementation.
    This then allows us to test that the `currentExercise` has also been set correctly
    inside the `startExercise` method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，由于间谍是一个模拟，我们通常无法在`startExercise`方法内部进行验证。这是因为该方法本身正在被模拟。这意味着我们实际上无法验证`currentExercise`属性是否已经设置，因为这是在模拟的方法内部完成的。然而，Jasmine允许我们使用`and.callThrough`将间谍链式调用，这意味着除了跟踪方法的调用外，它还会委托到实际实现。这样我们就可以测试`currentExercise`是否在`startExercise`方法内部也正确设置了。
- en: Using Jasmine spies to verify dependencies
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jasmine间谍验证依赖项
- en: While we just used a spy to verify the call to a method within our class, Jasmine
    spies are also useful in mocking calls to external dependencies. But why test
    calls to our external dependencies at all? After all, we are trying to limit our
    testing to the component itself!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们只是使用间谍来验证我们类内部的方法调用，但Jasmine间谍在模拟外部依赖的调用时也非常有用。但为什么要测试对我们外部依赖的调用呢？毕竟，我们试图将测试限制在组件本身上！
- en: The answer is that we mock a dependency to make sure that the dependency does
    not adversely affect the component under test. From a unit testing perspective,
    we still need to make sure that these dependencies are called by the component
    being tested at the right time with the correct input. In the Jasmine world, spies
    help us assert whether dependencies were invoked correctly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们模拟一个依赖项以确保依赖项不会对测试中的组件产生不利影响。从单元测试的角度来看，我们仍然需要确保这些依赖项在正确的时间以正确的输入被测试组件调用。在Jasmine的世界里，间谍帮助我们断言依赖项是否被正确调用。
- en: If we look at the `WorkoutRunner` implementation, we emit a message with the
    details of the workout whenever the workout starts. An external dependency, `WorkoutHistoryTracker`,
    subscribes to this message/event. So let's create a spy and confirm that `WorkoutHistoryTracker`
    started when the workout started.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`WorkoutRunner`的实现，每当锻炼开始时，我们都会发出一个包含锻炼详情的消息。外部依赖项`WorkoutHistoryTracker`订阅了这个消息/事件。所以让我们创建一个间谍并确认当锻炼开始时`WorkoutHistoryTracker`也开始了。
- en: 'Add this `it` block after the preceding one:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个`it`块之后添加这个`it`块：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Within the `it` block, we add a spy on the `tracker`, a local instance of the
    `WorkoutHistoryTracker`. Then we use the spy to verify that the `startTracking`
    method of that dependency has been called. Simple and expressive!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`it`块内部，我们添加了对`tracker`的监视，它是`WorkoutHistoryTracker`的一个本地实例。然后我们使用这个间谍来验证那个依赖项的`startTracking`方法已经被调用。简单且表达清晰！
- en: You may recall that we are using `MockHistoryWorkoutTracker` here; it contains
    a mock, a `startTracking` method that is empty and returns nothing. That is fine
    because we are not testing the `WorkoutHistoryTracker` itself, but just the method
    invocation on it being made by the `WorkoutRunner`. This test shows how useful
    it is to be able to combine mocks with spies to fully test the inner workings
    of the `WorkoutRunner`, separately and apart from its dependencies.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得我们在这里使用的是`MockHistoryWorkoutTracker`；它包含一个模拟，一个空的`startTracking`方法，它不返回任何内容。这是可以的，因为我们不是在测试`WorkoutHistoryTracker`本身，而是在测试`WorkoutRunner`对其的调用方法。这个测试展示了能够将模拟与间谍结合使用来完全测试`WorkoutRunner`的内部工作方式，独立于其依赖项是多么有用。
- en: Testing event emitters
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试事件发射器
- en: 'Examining the code for the `WorkoutRunner`, we see that it sets up several
    event emitters that look like the following one for `workoutStarted`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`WorkoutRunner`的代码，我们发现它设置了几个事件发射器，其中一个是用于`workoutStarted`的如下所示：
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Angular documentation describes an event emitter as an output property that
    fires events to which we can subscribe with an event binding. In Chapter 2, *Building
    Our First App - 7 Minute Workout*, we described in detail how event emitters are
    used in Workout Runner. So we have a good understanding of what they do. But how
    do we unit-test our event emitters and determine that they are firing events in
    the way we expect?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Angular文档将事件发射器描述为一个输出属性，它触发我们可以通过事件绑定来订阅的事件。在第2章*构建我们的第一个应用 - 7分钟锻炼*中，我们详细描述了在Workout
    Runner中使用事件发射器的方式。因此，我们对它们的作用有很好的理解。但我们如何对事件发射器进行单元测试，并确定它们是否以我们期望的方式触发事件呢？
- en: 'It''s actually pretty easy to do. If we remember that an event emitter is an
    Observable Subject to which we can subscribe, we realize that we can simply subscribe
    to it in our unit test. Let''s revisit our test that verifies that a workout is
    starting and add the highlighted code to it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上做起来相当简单。如果我们记得事件发射器是一个我们可以订阅的Observable Subject，我们就会意识到我们可以在单元测试中简单地订阅它。让我们回顾一下验证锻炼开始的那个测试，并向其中添加高亮代码：
- en: '[PRE19]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We injected the `WorkoutService` and added a subscription to the `WorkoutStarted`
    event emitter and an expectation that checks to see whether the property is emitting
    a `WorkoutPlan` when the event is triggered. The subscription is placed before
    `ngOnInit` because that is the method that results in the `workoutStarted` event
    being triggered, and we need to have our subscription in place before that happens.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注入了`WorkoutService`，并添加了对`WorkoutStarted`事件发射器的订阅和一个期望检查，以查看当事件被触发时属性是否正在发射`WorkoutPlan`。订阅被放置在`ngOnInit`之前，因为这个方法会导致`workoutStarted`事件被触发，我们需要在它发生之前设置我们的订阅。
- en: Testing interval and timeout implementations
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试间隔和超时实现
- en: One of the interesting challenges for us is to verify that the workout progresses
    as time elapses. The `Workout` component uses `setInterval` to move things forward
    with time. How can we simulate time without actually waiting?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临的一个有趣的挑战是验证锻炼随着时间的流逝而进展。`Workout`组件使用`setInterval`来随着时间推进。我们如何在不实际等待的情况下模拟时间呢？
- en: The answer is the Angular testing library's `fakeAsync` function, which allows
    us to run otherwise asynchronous code synchronously. It does this by wrapping
    the function to be executed in a `fakeAsync` zone. It then supports using synchronous
    timers within that zone and also allows us to simulate the asynchronous passage
    of time with `tick()`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是Angular测试库的`fakeAsync`函数，它允许我们以同步的方式运行本应异步执行的代码。它是通过将待执行的函数包裹在`fakeAsync`区域中实现的。然后它支持在该区域内使用同步计时器，并允许我们使用`tick()`函数模拟异步时间的流逝。
- en: For more information about `fakeAsync`, see the Angular documentation at [https://angular.io/guide/testing#async-test-with-fakeasync.](https://angular.io/guide/testing#async-test-with-fakeasync)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`fakeAsync`的信息，请参阅Angular文档中的[https://angular.io/guide/testing#async-test-with-fakeasync.](https://angular.io/guide/testing#async-test-with-fakeasync)
- en: 'Let''s see how we can use the `fakeAsync` function to test the timeout and
    interval implementations in our code. Add the following test to `workout-runner.spec.ts`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`fakeAsync`函数来测试我们代码中的超时和间隔实现。将以下测试添加到`workout-runner.spec.ts`中：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In addition to injecting `WorkoutRunner`, we first wrap the test in `fakeAsync`.
    Then we add a call to the `WorkoutRunner`'s `ngOnit()` method. This kicks off
    the timers for the exercises within `WorkoutRunner`. Then within the test, we
    use the `tick()` function set at various durations to test the operation of the
    timer for an exercise, and make sure that it continues running for the duration
    that we expected it to run. Using `tick()` allows us to fast forward through the
    code and avoid having to wait for the exercise to complete over several seconds
    as it would if we ran the code asynchronously.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注入`WorkoutRunner`之外，我们首先使用`fakeAsync`包装测试。然后我们调用`WorkoutRunner`的`ngOnInit`方法。这将在`WorkoutRunner`内部启动练习的计时器。然后在测试中，我们使用设置在不同时间段的`tick()`函数来测试练习计时器的操作，并确保它以我们期望的持续时间继续运行。使用`tick()`允许我们快速前进通过代码，避免异步运行代码时需要等待几秒钟才能完成练习。
- en: At the end, we call `discardPeriodicTasks()` . This method is one of the Angular
    testing utilities and it can be used with  `fakeAsync` to clear any pending timers
    that may be in the task queue.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`discardPeriodicTasks()`。这是Angular测试实用工具之一，它可以与`fakeAsync`一起使用来清除任务队列中可能存在的任何挂起的计时器。
- en: More information about these and other Angular testing utilities can be found
    at [https://angular.io/guide/testing#testing-utility-apis](https://angular.io/guide/testing#testing-utility-apis)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于这些和其他Angular测试实用工具的信息可以在[https://angular.io/guide/testing#testing-utility-apis](https://angular.io/guide/testing#testing-utility-apis)找到。
- en: 'Let''s try another similar test. We want to make sure that the `WorkoutRunner`
    is correctly transitioning from one exercise to the next. Add the following test
    to `workout-runner.ts`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个类似的测试。我们想要确保`WorkoutRunner`能够正确地从一项练习过渡到下一项练习。请将以下测试添加到`workout-runner.ts`中：
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again we wrap the test in `fakeAsync` and call `runner.ngOnInit` to start the
    timer. Then we grab the duration of the first exercise and use the `tick()` function
    within the following `TestHelper` method to advance the timer one second beyond
    the duration of that exercise:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`fakeAsync`包装测试并调用`runner.ngOnInit`来启动计时器。然后我们获取第一项练习的持续时间，并在随后的`TestHelper`方法中使用`tick()`函数将计时器推进超过该练习持续时间的一秒。
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we test the expectation that we are now in the `rest` exercise and thus
    have transitioned from the first exercise.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试期望我们现在处于`rest`练习中，因此已经从第一项练习过渡过来。
- en: Testing workout pause and resume
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试锻炼暂停和恢复
- en: 'When we pause a workout, it should stop and the time counter should not lapse.
    To check this, add the following time test:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们暂停锻炼时，它应该停止，时间计数器不应中断。为了检查这一点，请添加以下时间测试：
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The test starts with verifying the state of the workout as not paused, advances
    the time for one second, pauses it, and then verifies that the time of `workoutTimeRemaining`
    does not change after the pause.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 测试从验证锻炼状态未暂停开始，将时间推进一秒，暂停它，然后验证在暂停后`workoutTimeRemaining`的时间没有变化。
- en: Unit-testing services
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试服务
- en: Unit testing of services is not much different from unit-testing components.
    Once we get the hang of how to set up a component and its dependencies (mostly
    using mocks), it becomes a routine affair to apply that learning to testing services.
    More often than not, the challenge is to set up the dependencies for the services
    so that testing can be done effectively.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试服务与单元测试组件没有太大区别。一旦我们掌握了如何设置组件及其依赖项（主要使用模拟），将这种学习应用到测试服务上就变成了一件例行公事。通常情况下，挑战在于设置服务的依赖项，以便能够有效地进行测试。
- en: Things are a little different for services that make remote requests (using
    either `http` or `jsonp`). There is some setup required before we can test such
    services in isolation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进行远程请求（使用`http`或`jsonp`）的服务来说，情况略有不同。在我们可以单独测试此类服务之前，需要进行一些设置。
- en: We will target `WorkoutService` and write some unit tests for it. Since this
    service makes remote requests to load workout data, we will explore how to test
    such a service with a mock HTTP backend. Angular provides us with the `HttpTestingController` for doing
    that.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将针对`WorkoutService`编写一些单元测试。由于此服务会向远程请求加载锻炼数据，我们将探讨如何使用模拟HTTP后端测试此类服务。Angular为我们提供了`HttpTestingController`来执行此操作。
- en: Mocking HTTP request/response with HttpTestingController
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HttpTestingController模拟HTTP请求/响应
- en: When testing services (or, as a matter of fact, any other Angular construct)
    that make remote requests, we obviously do not want to make actual requests to
    a backend to check the behavior. That does not even qualify for a unit test. The
    backend interaction just needs to be mocked away. Angular provides for precisely
    that. Using `HttpTestingController`, we intercept HTTP requests, mock actual responses
    from the server, and assert endpoints invocation too.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试进行远程请求的服务（或者实际上，任何其他 Angular 构造）时，我们显然不希望实际向后端发送请求来检查行为。这甚至都不符合单元测试的标准。后端交互只需要被模拟。Angular
    正好提供了这样的功能。使用 `HttpTestingController`，我们拦截 HTTP 请求，模拟来自服务器的实际响应，并断言端点调用。
- en: 'Open `workout-service.spec.ts`  and add the following import statements at
    the top of the file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `workout-service.spec.ts` 并在文件顶部添加以下导入语句：
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In addition to the imports from the `core/testing` module, we are importing
    both `HttpClientTestingModule`  and  `HttpTestingController` from the `http/testing`
     module. We are also importing `WorkoutService` and `WorkoutPlan` that we will
    be testing.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从 `core/testing` 模块导入之外，我们还从 `http/testing` 模块导入了 `HttpClientTestingModule`
    和 `HttpTestingController`。我们还导入了我们将要测试的 `WorkoutService` 和 `WorkoutPlan`。
- en: 'Once we have the imports in place, we will begin creating the test with the
    Jasmine `describe`  statement that wraps our tests, and will set several local
    variables:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了导入，我们将开始使用 Jasmine 的 `describe` 语句创建测试，该语句封装了我们的测试，并设置了一些局部变量：
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In addition to creating local variables for `HttpClient`, `HttpTestingController`,
    and `WorkoutService`, you'll also notice that we are setting local variables for
    our Mongo connection. To be clear, we are not setting these variables in order
    to make a remote call to Mongo, but instead to test that the connection properties
    are being set properly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为 `HttpClient`、`HttpTestingController` 和 `WorkoutService` 创建局部变量之外，你还会注意到我们为我们的
    MongoDB 连接设置了局部变量。为了明确，我们不是设置这些变量以向 MongoDB 发送远程调用，而是为了测试连接属性是否被正确设置。
- en: 'The next step is set up the providers and dependency injection for our tests.
    To handle the providers, add the following to the test file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置测试的提供者和依赖注入。为了处理提供者，将以下内容添加到测试文件中：
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we call `TestBed.configureTestingModule`  to import the `HttpClientTestingModule`
    and add the `WorkoutService`. According to the Angular documentation ([https://angular.io/api/common/http/testing/HttpClientTestingModule](https://angular.io/api/common/http/testing/HttpClientTestingModule)), `HttpClientTestingModule`
    sets up `HttpClient` to use `HttpClientTestingBackend` as `HttpBackend`. The nice
    thing here is that this setup is completely hidden from our test setup, so we
    don't have to write code to wire this up.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用 `TestBed.configureTestingModule` 来导入 `HttpClientTestingModule` 并添加 `WorkoutService`。根据
    Angular 文档（[https://angular.io/api/common/http/testing/HttpClientTestingModule](https://angular.io/api/common/http/testing/HttpClientTestingModule)），`HttpClientTestingModule`
    将 `HttpClient` 设置为使用 `HttpClientTestingBackend` 作为 `HttpBackend`。这里的好处是，这种设置完全隐藏在我们的测试设置中，所以我们不需要编写代码来连接它。
- en: 'Next we use the `TestBed.get` method to populate our local variables—`httpClient`,
    `httpTestingController`, and `workoutService`. We''ll also add the following `afterEach`
    method to make sure that after every test completes there are no more pending
    requests:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `TestBed.get` 方法填充我们的局部变量—`httpClient`、`httpTestingController` 和 `workoutService`。我们还将添加以下
    `afterEach` 方法以确保在每个测试完成后没有更多挂起的请求：
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this setup in place, we are now in a position to create tests for `WorkoutService`
    that avoid us making a remote call. We''ll start with a simple test that makes
    sure that `workoutService` loads:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这一切之后，我们现在可以创建针对 `WorkoutService` 的测试，以避免我们进行远程调用。我们将从一个简单的测试开始，确保 `workoutService`
    被加载：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While this test may seem trivial, it is important to place it here because it
    acts as a check to make sure that we have set up our configuration correctly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个测试可能看起来微不足道，但将其放在这里很重要，因为它作为一个检查，确保我们已经正确设置了配置。
- en: 'Next, we''ll add the following test to make sure that we are able to inject `HttpClient`
    when we instantiate `WorkoutService`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加以下测试以确保我们能够在实例化 `WorkoutService` 时注入 `HttpClient`：
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we''ll move to testing several of the methods in the workout-service.
    First, we will make sure that it returns all workouts when the `getWorkouts` method
    is called. To do that, add the following test:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将转向测试 workout-service 中的几个方法。首先，我们将确保当调用 `getWorkouts` 方法时，它返回所有锻炼项目。为此，添加以下测试：
- en: '[PRE30]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We'll start by declaring two arrays of `WorkoutPlans`—`expectedWorkouts` and
    `actualWorkouts`. We'll then populate `expectedWorkouts` with four  `WorkoutPlans`.
    Because we are testing retrieval of the `WorkoutPlans` and not their content,
    we have made these minimal workouts.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先声明两个`WorkoutPlans`数组——`expectedWorkouts`和`actualWorkouts`。然后我们将`expectedWorkouts`填充为四个`WorkoutPlans`。因为我们正在测试`WorkoutPlans`的检索而不是其内容，所以我们创建了这些最小的工作计划。
- en: Since the `Http` module returns `RxJS` Observables, we next use the pattern
    of subscribing to those Observables. You should be used to seeing this pattern
    from our coverage of Observables in Chapter 5, *Supporting Server Data Persistence*.
    Notice that we use `fail` as the second parameter, which will cause the test to
    fail if there is an issue with subscribing to the Observable.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Http`模块返回`RxJS` Observables，我们接下来使用订阅这些Observables的模式。你应该已经习惯了从第5章*支持服务器数据持久性*中我们关于Observables的介绍中看到这个模式。注意，我们使用`fail`作为第二个参数，如果订阅Observable存在问题，这将导致测试失败。
- en: 'Next we call a method on the `HttpTestingController` named `expectOne` passing
    our request URL. According to the Angular documentation ([https://angular.io/api/common/http/testing/HttpTestingController#expectone](https://angular.io/api/common/http/testing/HttpTestingController#expectone)),
    this method does two things: it expectsthat a request has been made that matches
    the URL provided in the method call and it returns a mock request. In the next
    line we make sure that the mock request is an HTTP GET. Finally, we flush the
    request with the `expectedWorkouts` and confirm that the `actualWorkouts` equal
    the `expectedWorkouts`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`HttpTestingController`上调用一个名为`expectOne`的方法，并传递我们的请求URL。根据Angular文档([https://angular.io/api/common/http/testing/HttpTestingController#expectone](https://angular.io/api/common/http/testing/HttpTestingController#expectone))，此方法执行两个操作：它期望一个请求已被发出，该请求与方法调用中提供的URL匹配，并返回一个模拟请求。在下一行中，我们确保模拟请求是一个HTTP
    GET。最后，我们使用`expectedWorkouts`刷新请求，并确认`actualWorkouts`等于`expectedWorkouts`。
- en: 'We''ll follow the same pattern to build additional tests that confirm that
    we are able to do the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循相同的模式来构建额外的测试，以确认我们能够做到以下事情：
- en: Return a `workout` plan with a specific name
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个具有特定名称的`workout`计划
- en: Map `exercises` correctly within the `getWorkout` method
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`getWorkout`方法中正确映射`exercises`
- en: 'You can review these tests in the code for `checkpoint 7.2`. But one thing
    to note is that in both these tests we are testing two HTTP calls. For example,
    here is the code in the second of these two tests:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`checkpoint 7.2`的代码中查看这些测试。但要注意的一点是，在这两个测试中，我们都在测试两个HTTP调用。例如，以下是这两个测试中的第二个测试的代码：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This may seem a little confusing at first until we realize that with the `getWorkout`
    method we are actually making two `Http` calls: one to retrieve a  `workout` and
    one to retrieve all  `exercises`. As you recall from Chapter 5, *Supporting Server
    Data Persistence*, we are doing that in order to create a fuller description of
    each `exercise` that is included within `workout`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始看起来有些令人困惑，直到我们意识到，实际上，使用`getWorkout`方法，我们实际上进行了两个`Http`调用：一个用于检索`workout`，另一个用于检索所有`exercises`。如您从第5章*支持服务器数据持久性*中回忆的那样，我们这样做是为了创建每个包含在`workout`中的`exercise`的更完整描述。
- en: With that, we are finished with testing our service.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了对服务的测试。
- en: Next, we need to learn how to test directives. The next section is dedicated
    to understanding the challenges in directive testing and how to overcome them.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要学习如何测试指令。下一节将专门介绍指令测试的挑战以及如何克服它们。
- en: Unit-testing directives
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试指令
- en: No other Angular constructs that we have tested so far do not involve any UI
    interaction. But directives, as we know, are a different beast. Directives are
    all about enhancing a component's view and extending the behavior of HTML elements.
    While testing directives, we cannot ignore the UI connections, and hence directive
    testing may not strictly qualify as unit testing.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们测试过的所有其他Angular构建项都不涉及任何UI交互。但正如我们所知，指令是另一回事。指令全部关于增强组件的视图和扩展HTML元素的行为。在测试指令时，我们不能忽视UI连接，因此指令测试可能并不严格符合单元测试的定义。
- en: 'The good thing about directive testing is that its setup process is not as
    elaborate as that for services or components. The pattern to follow while unit-testing
    directives is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 指令测试的好处是它的设置过程不像服务或组件那么复杂。在单元测试指令时应该遵循以下模式：
- en: Take an HTML fragment containing the directive markup
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个包含指令标记的HTML片段
- en: Compile and link it to a mock component
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并将其链接到一个模拟组件
- en: Verify that the generated HTML has the required attributes
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证生成的 HTML 是否具有所需的属性
- en: Verify if the changes that the directive created changes the state
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证指令创建的更改是否改变了状态
- en: The TestBed class
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TestBed 类
- en: As mentioned previously, Angular provides the `TestBed` class to facilitate
    this kind of UI testing. We can use it to dig into the markup in a component's
    view and check for DOM changes that are triggered by events. Armed with this tool,
    let's get started with the testing of our directives. In this section, we are
    going to test `remoteValidator`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Angular 提供了 `TestBed` 类来简化此类 UI 测试。我们可以使用它来深入查看组件视图中的标记，并检查由事件触发的 DOM 变化。有了这个工具，让我们开始对指令进行测试。在本节中，我们将测试
    `remoteValidator`。
- en: This will be a good time to revisit the directives that we built in the previous
    chapter. Also, keep the code handy for the tests that we will create in the following
    sections.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是回顾我们在上一章中构建的指令的好时机。同时，保留我们将要在以下部分创建的测试的代码。
- en: Testing remote validator
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试远程验证器
- en: Let's start with unit-testing `remoteValidatorDirective`. Just to refresh our
    memory, `remoteValidatorDirective` validates an input against remote rules. It
    does so by calling a component method that returns a promise. If the promise is
    resolved with success, the validation passes; otherwise, the validation fails.
    The `[validateFunction]` attribute provides the link between the DOM and the component's
    method that checks for the duplication.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从单元测试 `remoteValidatorDirective` 开始。为了刷新我们的记忆，`remoteValidatorDirective`
    通过调用返回一个 promise 的组件方法来验证输入与远程规则。如果 promise 成功解析，则验证通过；否则，验证失败。`[validateFunction]`
    属性提供了 DOM 和组件中检查重复的方法之间的链接。
- en: Similar to our other test files, we have a `remote-validator.directive.spec.ts`
    file in the shared folder. Refer to the file in `checkpoint 7.2` for the imports,
    which we will not cover at this point.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的其他测试文件类似，我们在共享文件夹中有一个 `remote-validator.directive.spec.ts` 文件。请参考 `checkpoint
    7.2` 中的文件以获取导入，我们在此处不会涉及。
- en: 'Just below the import statements, add the following component definition:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入语句下方，添加以下组件定义：
- en: '[PRE32]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This component looks a lot like the components that we set up in our other tests
    to mock dependencies. Here, however, it is serving a slightly different purpose;
    it is acting as a host container for the directive that we will be testing. Using
    this minimal component, lets us avoid having to load the actual host for this
    directive, which is the `Workout` component.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件看起来很像我们在其他测试中设置的组件，用于模拟依赖项。然而，在这里，它起着略微不同的作用；它充当我们将要测试的指令的主容器。使用这个最小组件，我们可以避免加载此指令的实际宿主组件，即
    `Workout` 组件。
- en: One thing to notice here is that we have set up a method for `validateWorkoutName`
    that will be called by our directive. It is essentially a stub that just returns
    a resolved `Promise` of `false`. Remember that we are not concerned with how this
    method handles its validation, but with verifying that the directive calls it
    and returns the correct result, either `true` or `false`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，我们为 `validateWorkoutName` 方法设置了一个方法，它将由我们的指令调用。它本质上是一个返回已解析的 `Promise`
    为 `false` 的存根。记住，我们并不关心这个方法如何处理其验证，而是要验证指令调用了它，并返回了正确的结果，即 `true` 或 `false`。
- en: 'Next, we set up the `describe` statement for our test suite by adding the following
    code, which injects  `RemoteValidatorDirective` into our tests:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过添加以下代码来设置测试套件的 `describe` 语句，该代码将 `RemoteValidatorDirective` 注入到我们的测试中：
- en: '[PRE33]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, we are setting up local variables for  `fixture`, its `componentInstance`,
    and `debugElement`. We are also using `by.css` (which we will see more of in our
    end-to-end tests) along with the query method on  `debugElement` to extract the
    `workoutName` input from our component. We'll be using these to delve into the
    rendered HTML in our directive.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在为 `fixture`、其 `componentInstance` 和 `debugElement` 设置局部变量。我们还在 `debugElement`
    上使用 `by.css`（我们将在端到端测试中了解更多）以及查询方法来从我们的组件中提取 `workoutName` 输入。我们将使用这些来深入查看指令中渲染的
    HTML。
- en: 'Now we are ready to write our individual tests. First, we''ll write a test
    to confirm that we have been able to load  `RemoteValidatorDirective`. So add
    the following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写我们的单个测试。首先，我们将编写一个测试来确认我们已经能够加载 `RemoteValidatorDirective`。因此，添加以下代码：
- en: '[PRE34]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What''s interesting about this test is that using the `debugElement`, we have
    been able to drill-down into the attributes of the input tag in our host component
    and find our validator, confirming that it has indeed been loaded. Also notice
    the use of `fakeAsync`, which we discussed in connection with unit testing. Using
    it makes it possible for us to write our tests in a synchronous fashion and avoid
    the complications that would otherwise exist with trying to manage the asynchronous
    rendering of our host component. Next, we''ll write two tests to confirm that
    our validator is working properly. The first test will make sure that an error
    is created if remote validation fails (that is, a workout with the same name as
    the one we are using is found). Add the following code for that test:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试有趣的地方在于，使用`debugElement`，我们已经能够深入挖掘我们宿主组件中输入标签的属性，并找到我们的验证器，确认它确实已经被加载。同时注意`fakeAsync`的使用，我们在单元测试中讨论过。使用它使得我们能够以同步的方式编写测试，并避免在尝试管理宿主组件的异步渲染时可能出现的复杂性。接下来，我们将编写两个测试来确认我们的验证器是否正常工作。第一个测试将确保如果远程验证失败（即找到与我们所使用的相同名称的锻炼），将创建一个错误。为此测试添加以下代码：
- en: '[PRE35]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Again, we are using `fakeAsync` to eliminate the challenges that we would otherwise
    have with the async behavior associated with the rendering and execution of our
    `remoteValidatorDirective`. Next, we add a spy to track the invocation of the
    `validateWorkoutName` method. We also set the spy to call through to our method,
    because in this case, we are expecting it to return false. The spy is being used
    to verify that our method has indeed been invoked. Next, we set `fixture.detectChanges`,
    which triggers a change detection cycle. We then set the value of our input and
    call tick, which will, we hope, trigger the response we are expecting from our
    remote validator. We then grab the form encapsulating our input tag using the
    injector that is available from the child element array of the debug element.
    From there, we extract the form control for our input box. Then we run several
    expectations that confirm that an error has been added both to our control and
    to the form and that both are now in an invalid state. The next test is the mirror
    opposite of this test and it checks for a positive:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用`fakeAsync`来消除我们可能面临的与我们的`remoteValidatorDirective`渲染和执行相关的异步行为带来的挑战。接下来，我们添加一个间谍来跟踪`validateWorkoutName`方法的调用。我们还设置间谍调用我们的方法，因为在这种情况下，我们期望它返回`false`。间谍被用来验证我们的方法确实被调用。接下来，我们设置`fixture.detectChanges`，这会触发一个变更检测周期。然后我们设置输入的值并调用tick，这将，我们希望，触发我们期望从远程验证器那里得到的响应。然后我们使用从调试元素的子元素数组中可用的注入器获取包含我们的输入标签的表单。从那里，我们提取我们的输入框的表单控件。然后我们运行几个期望，确认错误已经添加到我们的控件和表单中，并且它们现在都处于无效状态。下一个测试是这个测试的镜像相反，并检查一个积极的：
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Other than changing the expectations, the only change we are making from the
    previous test is setting up our spy to return a value of `true`. Unit-testing
    our `remoteValidatorDirective` shows how powerful the `TestBed` utilities are
    in testing our UI and the elements and behaviors associated with it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 除了改变期望之外，我们从上一个测试中做出的唯一改变是设置我们的间谍返回`true`的值。对`remoteValidatorDirective`进行单元测试展示了`TestBed`工具在测试我们的UI及其相关元素和行为时的强大功能。
- en: Getting started with E2E testing
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始进行端到端测试
- en: Automated **E2E** testing is an invaluable asset if the underlying framework
    supports it. As the size of an app grows, automated E2E testing can save a lot
    of manual effort.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层框架支持，自动化的**端到端（E2E）**测试是一项无价的资产。随着应用程序规模的扩大，自动化的端到端测试可以节省大量的手动工作。
- en: Without automation, it's just a never-ending battle to make sure that the app
    is functional. However, remember that in an E2E setup, not everything can be automated;
    automation may require a lot of effort. With due diligence, we can offload a sizable
    amount of manual effort, but not everything.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 没有自动化，确保应用程序功能正常只是一场永无止境的战斗。然而，记住在一个端到端（E2E）的设置中，并非所有事情都可以自动化；自动化可能需要大量的努力。经过尽职调查，我们可以减少大量的手动工作，但并非所有。
- en: The process of E2E testing of a web-based application is about running the application
    in a real browser and asserting the behavior of the application based on the user
    interface state. This is how an actual user does testing.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 基于用户界面状态对基于Web的应用程序进行端到端测试的过程是在真实浏览器中运行应用程序，并根据用户界面状态断言应用程序的行为。这就是实际用户进行测试的方式。
- en: Browser automation holds the key here, and modern browsers have become smarter
    and more capable in terms of supporting automation. Selenium tools for browser
    automation are the most popular option out there. Selenium has the WebDriver ([https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/))
    API that allows us to control the browser through the automation API that modern
    browsers natively support.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器自动化是这里的关键，现代浏览器在支持自动化方面已经变得更加智能和强大。Selenium浏览器自动化工具是当前最受欢迎的选项。Selenium拥有WebDriver
    API（[https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/)），它允许我们通过现代浏览器原生支持的自动化API来控制浏览器。
- en: The reason behind bringing up Selenium WebDriver is that the Angular E2E testing
    framework/runner **Protractor** also uses **WebDriverJS**, which is a JavaScript
    binding of WebDriver on Node. These language bindings (like the preceding JavaScript
    binding) allow us to use the automation API in the language of our choice.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 提出Selenium WebDriver的原因在于，Angular端到端测试框架/运行器**Protractor**也使用了**WebDriverJS**，这是WebDriver在Node上的JavaScript绑定。这些语言绑定（如前面的JavaScript绑定）允许我们使用我们选择的语言的自动化API。
- en: Let's discuss Protractor before we start writing some integration tests for
    our app.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为我们的应用程序编写一些集成测试之前，让我们先讨论一下Protractor。
- en: Introducting Protractor
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Protractor
- en: '**Protractor** is the de facto test runner for E2E testing in Angular. Protractor
    uses Selenium WebDriver to control a browser and simulate user actions.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**Protractor**是Angular端到端测试的默认测试运行器。Protractor使用Selenium WebDriver来控制浏览器并模拟用户操作。'
- en: 'A typical Protractor setup has the following components:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Protractor设置包含以下组件：
- en: A test runner (Protractor)
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试运行器（Protractor）
- en: A Selenium server
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium服务器
- en: A browser
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器
- en: We write our test in Jasmine and use some objects exposed by Protractors (which
    is a wrapper over WebDriverJS) to control the browser.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Jasmine编写测试，并使用Protractor（它是WebDriverJS的包装器）公开的一些对象来控制浏览器。
- en: When these tests run, Protractor sends commands to the Selenium server. This
    interaction happens mostly over HTTP.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些测试运行时，Protractor会向Selenium服务器发送命令。这种交互主要发生在HTTP上。
- en: The Selenium server, in turn, communicates with the browser using the *WebDriver
    Wire Protocol*, and internally the browser interprets the action commands using
    the browser driver (such as *ChromeDriver* in the case of Chrome).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium服务器反过来，使用*WebDriver Wire Protocol*与浏览器通信，并且内部浏览器使用浏览器驱动程序（例如Chrome中的*ChromeDriver*）来解释操作命令。
- en: It is not that important to understand the technicalities of this communication,
    but we should be aware of the E2E testing setup. Check out the article from the
    Protractor documentation at [http://angular.github.io/protractor/#/infrastructure](http://angular.github.io/protractor/#/infrastructure)
    to learn more about this flow.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种通信的技术细节并不那么重要，但我们应该了解端到端测试的设置。查看Protractor文档中的文章[http://angular.github.io/protractor/#/infrastructure](http://angular.github.io/protractor/#/infrastructure)，了解更多关于这个流程的信息。
- en: Another important thing to realize when using Protractor is that the overall
    interaction with the browser or the browser control flow is asynchronous in nature
    and promise-based. Any HTML element action, whether `sendKeys`, `getText`, `click`,
    `submit`, or any other, does not execute at the time of invocation; instead the
    action is queued up in a control flow queue. For this precise reason, the return
    value of every action statement is a promise that gets resolved when the action
    completes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Protractor时，还有一个重要的事情需要意识到，那就是与浏览器或浏览器控制流的整体交互本质上是异步的，基于Promise的。任何HTML元素操作，无论是`sendKeys`、`getText`、`click`、`submit`还是其他任何操作，都不会在调用时执行；相反，该操作会被排队到控制流队列中。正因为如此，每个操作语句的返回值都是一个Promise，当操作完成时得到解决。
- en: 'To handle this asynchronicity in Jasmine tests, Protractor patches Jasmine,
    and therefore assertions like these work:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理Jasmine测试中的这种异步性，Protractor对Jasmine进行了修补，因此像这样的断言是有效的：
- en: '[PRE37]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: They work despite the `getText` function returning a promise and not the element
    content.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`getText`函数返回一个Promise而不是元素内容，它们仍然可以正常工作。
- en: With this basic understanding of how Protractor works, let's set up Protractor
    for end-to-end testing.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对Protractor的工作原理有了基本的了解之后，让我们设置Protractor进行端到端测试。
- en: Setting up Protractor for E2E testing
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Protractor进行端到端测试
- en: 'The Angular CLI has already set up our project to allow us to use Protractor.
    The configurations for that setup can be found in the `protractor.config.js` file
    in the `trainer` folder. For the most part, you should be able to use those configurations
    without change to run your end-to-end tests. We did, however, make one change
    in that configuration file. We did extend the `defaultTimeoutInterval` in that
    file to 60000 milliseconds in order to give our tests that are running the workouts
    more time to finish:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 已经为我们设置了项目，以便我们可以使用 Protractor。该设置的配置可以在 `trainer` 文件夹中的 `protractor.config.js`
    文件中找到。在大多数情况下，你应该能够使用这些配置而不做任何更改来运行你的端到端测试。然而，我们在该配置文件中做了一项更改。我们将 `defaultTimeoutInterval`
    在该文件中扩展到 60000 毫秒，以便给运行锻炼的测试更多的时间来完成：
- en: '[PRE38]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The configuration file documentation on the Protractor website ([https://github.com/angular/protractor/blob/master/lib/config.ts](https://github.com/angular/protractor/blob/master/lib/config.ts))
    contains details on other supported configurations.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 网站上的配置文件文档（[https://github.com/angular/protractor/blob/master/lib/config.ts](https://github.com/angular/protractor/blob/master/lib/config.ts)）包含有关其他支持的配置的详细信息。
- en: 'That is enough to start testing with Protractor. In order to run our tests
    we simply execute the following command in the `trainer` folder:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够开始使用 Protractor 进行测试了。为了运行我们的测试，我们只需在 `trainer` 文件夹中执行以下命令：
- en: '[PRE39]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, let's get started with writing some end-to-end tests.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编写一些端到端测试。
- en: Writing E2E tests for the app
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用编写端到端测试
- en: Let's start in a simple manner and test our app start page (`#/start`). This
    page has some static content, a workout listing section with search capabilities,
    and the ability to start a workout by clicking on any workout file.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的方式开始，测试我们的应用启动页面（`#/start`）。这个页面包含一些静态内容，一个带有搜索功能的锻炼列表部分，以及通过点击任何锻炼文件来开始锻炼的能力。
- en: All our E2E tests will be added to the `e2e` folder under `trainer`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的端到端测试都将添加到 `trainer` 文件夹下的 `e2e` 文件夹中。
- en: 'Open the file called `app.e2e-spec.ts` to the `e2e` folder under `trainer`,
    which contains the following code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 `trainer` 文件夹下的 `e2e` 文件夹中的 `app.e2e-spec.ts` 文件，其中包含以下代码：
- en: '[PRE40]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's walk through this simple test.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步走过这个简单的测试。
- en: 'The first interesting piece is the import at the top of the page—`import {
    AppPage } from ''./app.po'';`. This is referring to a file in the same directory
    that contains what is called a page object.  This page object contains the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分是页面顶部的导入——`import { AppPage } from './app.po';`。这指的是同一目录下包含所谓的页面对象的文件。这个页面对象包含以下内容：
- en: '[PRE41]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The use of the page object allows us to simplify the code in our test so that
    it is more readable. So instead of directly calling `browser.get ('/')` in our
    test, we call the `navigateTo()` method from our page object.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 页面对象的使用允许我们简化测试中的代码，使其更易于阅读。因此，我们不是直接在我们的测试中调用 `browser.get ('/')`，而是从我们的页面对象中调用
    `navigateTo()` 方法。
- en: The browser object referred to in our page object is a global object exposed
    by Protractor and it is used to control the browser-level actions. Underneath,
    it is just a wrapper around WebDriver. The `browser.get("")` method navigates
    the browser to start the app page, every time, before the start of the test.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的页面对象中提到的浏览器对象是 Protractor 提供的全球对象，它用于控制浏览器级别的操作。在底层，它只是 WebDriver 的包装器。`browser.get("")`
    方法在测试开始之前每次都会导航到浏览器以启动应用页面。
- en: 'The same for the `getParagraphText()` method—it allows us to call that method
    in our test and look for some text on the screen without having to identify the
    exact location on the page where that will appear. We''ll discuss page objects
    in more detail as we get into more complicated end-to-end testing. The `getParagraphText()` in
    our page object also employs two new globals, `element` and `by`, which are made
    available by Protractor:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `getParagraphText()` 方法也是如此——它允许我们在测试中调用该方法，并在屏幕上查找一些文本，而无需确定该文本将在页面上出现的确切位置。随着我们进入更复杂的端到端测试，我们将更详细地讨论页面对象。在我们的页面对象中，`getParagraphText()`
    也使用了两个新的全局变量，`element` 和 `by`，这些变量由 Protractor 提供：
- en: '`element`: This function returns an `ElementFinder` object. The primary job
    of `ElementFinder` is to interact with the selected element. We will be using
    the `element` function to select `ElementFinder` extensively in our tests.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element`：这个函数返回一个 `ElementFinder` 对象。`ElementFinder` 的主要任务是交互所选元素。我们将使用 `element`
    函数在我们的测试中广泛选择 `ElementFinder`。'
- en: Refer to the documentation at `http://www.protractortest.org/#/locators#actions`
    to learn more about element manipulation API support. Functions such as `getText()`
    are actually defined on `WebElement`, but are always accessed using `ElementFinder`.
    As the documentation suggests, `ElementFinder` can be treated as `WebElement`
    for most purposes. For more information, you can refer to `http://www.protractortest.org/#/locators#behind-the-scenes-elementfinders-versus-webelements`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考`http://www.protractortest.org/#/locators#actions`文档了解有关元素操作API支持的更多信息。例如，`getText()`函数实际上是在`WebElement`上定义的，但总是通过`ElementFinder`来访问。正如文档所建议的，在大多数情况下可以将`ElementFinder`视为`WebElement`。更多详细信息，您可以参考`http://www.protractortest.org/#/locators#behind-the-scenes-elementfinders-versus-webelements`。
- en: '`by`: This object is there to locate elements. It has functions that create
    `locators`. In the preceding test, a locator is created to search for elements
    with a css tag equal to `abe-root h1` If you are familiar with CSS selectors,
    you will know that this identifies what we are looking for as an `h1` tag inside
    the custom element `abe-root`. There are a number of locators that can be used
    to search for a specific element. These include by class, by ID, and by css. Refer
    to the Protractor documentation on locators at [http://angular.github.io/protractor/#/locators](http://angular.github.io/protractor/#/locators)
    to learn about the supported locators.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`by`：此对象用于定位元素。它具有创建`locators`的函数。在先前的测试中，创建了一个定位器来搜索具有等于`abe-root h1`的CSS标签的元素。如果您熟悉CSS选择器，您将知道这标识了我们正在寻找的`h1`标签，它位于自定义元素`abe-root`内部。有几种定位器可以用来搜索特定元素，包括按类、按ID和按CSS。有关支持的定位器的详细信息，请参阅Protractor文档中的定位器部分[http://angular.github.io/protractor/#/locators](http://angular.github.io/protractor/#/locators)。'
- en: Just to reiterate what we discussed earlier, `getText()` in the page object
    does not return the actual text, but a Promise; we can still assert on the text
    value.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了重申我们之前讨论的内容，页面对象中的`getText()`并不返回实际的文本，而是一个Promise；我们仍然可以对文本值进行断言。
- en: Getting back to the actual test, it uses the methods in the page object to verify
    that some content ("Ready for a Workout?") is present on the page.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 回到实际的测试，它使用页面对象中的方法来验证某些内容（“Ready for a Workout?”）是否出现在页面上。
- en: This simple test highlights another salient feature of Protractor. It automatically
    detects when the Angular app is loaded and when data is available for testing.
    There are no ugly hacks to delay testing (using `timeouts`) that may otherwise
    be required in standard E2E testing scenarios.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的测试突出了Protractor的另一个显著特点。它自动检测Angular应用何时加载以及数据何时可用于测试。在标准E2E测试场景中，不需要使用`timeouts`等丑陋的技巧来延迟测试。
- en: Remember, this is an *SPA*; full-page browser refresh does not happen, so it
    is not that simple to determine when the page is loaded and when the data that
    is rendered for AJAX calls is available. Protractor makes it all possible.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这是一个*SPA*；页面不会进行全页刷新，因此确定页面何时加载以及为AJAX调用渲染的数据何时可用并不简单。Protractor使这一切成为可能。
- en: Protractor may still time out while trying to assess whether the page is available
    for testing. If you are hitting timeout errors with Protractor, this article from
    the Protractor documentation can be really helpful ([http://www.protractortest.org/#/timeouts](http://www.protractortest.org/#/timeouts))
    for debugging such issues.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试评估页面是否可用于测试时，Protractor可能会超时。如果您在使用Protractor时遇到超时错误，这篇来自Protractor文档的文章可能会对调试此类问题非常有帮助（[http://www.protractortest.org/#/timeouts](http://www.protractortest.org/#/timeouts)）。
- en: Setting up backend data for E2E testing
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置E2E测试的后端数据
- en: Setting up backend data for E2E testing is a challenge, irrespective of the
    E2E framework that we employ for testing. The ultimate aim is to assert the behavior
    of an application against some data, and unless the data is fixed, we cannot verify
    the behavior that involves getting or setting data.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 不论我们使用哪个E2E框架进行测试，设置E2E测试的后端数据都是一个挑战。最终目标是针对某些数据断言应用程序的行为，除非数据是固定的，否则我们无法验证涉及获取或设置数据的行为。
- en: One approach to setting up data for E2E tests is to create a test data store
    specifically for E2E tests with some seed data. Once the E2E tests are over, the
    data store can be reset to its original state for future testing. For *Personal
    Trainer*, we can create a new database in MongoLab dedicated exclusively to E2E
    testing.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 设置E2E测试数据的一个方法是为E2E测试创建一个专门的数据存储库，并包含一些种子数据。一旦E2E测试完成，数据存储库可以重置到原始状态，以便未来的测试。对于*Personal
    Trainer*，我们可以在MongoLab中创建一个专门用于E2E测试的新数据库。
- en: This may seem a lot of effort, but it is necessary. Who said E2E testing is
    easy! In fact, this challenge is there even if we do manual testing. For a real
    app, we always have to set up data stores/databases for every environment, whether *dev*,
    *test*, or *production*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来需要很多努力，但这是必要的。谁说端到端测试容易！实际上，即使我们进行手动测试，这个挑战也存在。对于一个真正的应用程序，我们总是必须为每个环境设置数据存储/数据库，无论是*dev*、*test*还是*production*。
- en: 'In this case, we will continue to use our existing backend, but go ahead and
    add another workout that we will use for testing. Name this workout `1minworkout`
    and give it a title of `1 Minute Workout`. Add two exercises to the workout: Jumping
    Jacks and Wall Sit. Set the duration of each exercise to 15 seconds and the rest
    time to one second.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将继续使用现有的后端，但添加另一个我们将用于测试的锻炼。将此锻炼命名为`1minworkout`，并给它一个标题`1 Minute Workout`。添加两个练习到锻炼中：跳绳和墙坐。将每个练习的持续时间设置为15秒，休息时间为1秒。
- en: We have deliberately kept our new workout short so that we can complete our
    end-to-end testing of this workout within the normal timeouts provided by Protractor.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意将新的锻炼保持简短，这样我们就可以在Protractor提供的正常超时时间内完成此锻炼的端到端测试。
- en: More E2E tests
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多端到端测试
- en: Let's get back to testing the workout search features on the start page. With
    the addition of *1 Minute Workout*, we now have two workouts and we can assert
    search behaviors against these.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到测试首页上的锻炼搜索功能。随着*1 Minute Workout*的添加，我们现在有两个锻炼，我们可以对这些进行断言。
- en: If you have added other workouts to the backend, just adjust the numbers in
    this test accordingly.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在后端添加了其他锻炼，只需相应地调整此测试中的数字。
- en: 'Add this test after the existing test in `workout-runner.spec.ts`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner.spec.ts`中现有测试之后添加此测试：
- en: '[PRE42]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The test uses `ElementFinder` and `Locator API` to look for elements on the
    page. Check the second line of the test. We are using the `element.all` function
    together with the `by.css` locator to do a multi-element match on all elements
    on the screen that are using the `.workout.tile` CSS class. This gives us a list
    of workouts against which the next line asserts the element count of 3.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用`ElementFinder`和`Locator API`在页面上查找元素。检查测试的第二行。我们正在使用`element.all`函数和`by.css`定位器对屏幕上使用`.workout.tile`CSS类的所有元素进行多元素匹配。这给我们一个锻炼列表，针对这个列表，下一行断言元素个数为3。
- en: The test then gets hold of the search input using the `element` function along
    with the `by.css` locator to do a single element match for an element using the
    `.form-contol` CSS class. We then use the `sendKeys` function to simulate data
    entry in the search input.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 测试随后使用`element`函数和`by.css`定位器获取搜索输入，以对使用`.form-contol`CSS类的元素进行单元素匹配。然后我们使用`sendKeys`函数来模拟搜索输入中的数据输入。
- en: The last two expect operations check for the count of elements in our list,
    which after the search should be 1\. Also, they check whether the correct workout
    is filtered based on a `div` tag using the `title` CSS class that is a child of
    the element that contains our workout. This last expect statement highlights how
    we can chain element filtering and get hold of child elements in HTML.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个期望操作检查列表中的元素数量，搜索后应为1。它们还检查是否根据`div`标签使用`title`CSS类正确过滤了正确的锻炼，该标签是包含我们的锻炼的元素的子元素。这个最后的期望语句突出了我们可以如何链式过滤元素并获取HTML中的子元素。
- en: 'There is one more test associated with the start page that we should add. It
    tests the navigation from the start page to the workout runner screen. Add this
    code for that test:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该添加与首页相关的一个附加测试。它测试从首页导航到锻炼运行器屏幕。为此测试添加以下代码：
- en: '[PRE43]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This test uses the `click`  function to simulate clicking on a workout tile,
    and then we use the `browser.getCurrentUrl` function to confirm that the navigation
    is correct.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试使用`click`函数来模拟点击锻炼瓷砖，然后我们使用`browser.getCurrentUrl`函数来确认导航是否正确。
- en: Run the test again (`protractor tests/protractor.conf.js`) and once again observe
    the magic of browser automation as the tests run one after another.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试（`protractor tests/protractor.conf.js`），再次观察浏览器自动化的魔力，因为测试一个接一个地运行。
- en: Can we automate E2E testing for *Workout Runner*? Well, we can try.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否自动化*Workout Runner*的端到端测试？嗯，我们可以试试。
- en: Testing Workout Runner
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Workout Runner
- en: One of the major challenges with testing Workout Runner is that everything is
    time-dependent. With unit testing, at least we were able to mock the interval,
    but not anymore. Testing exercise transitions and workout completion is definitely
    difficult.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Workout Runner的主要挑战之一是所有内容都是时间依赖的。在单元测试中，我们至少能够模拟间隔，但现在不行了。测试锻炼转换和工作完成确实很困难。
- en: 'However, before we tackle this problem or try to find an acceptable workaround,
    let''s digress and learn about an important technique to manage E2E testing: page
    objects!'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们解决这个问题或尝试找到一个可接受的解决方案之前，让我们暂时偏离一下，来了解一下管理端到端测试的一个重要技术：页面对象！
- en: Using page objects to manage E2E testing
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用页面对象来管理端到端测试
- en: We touched on page objects earlier. The concept of page objects is simple. We
    encapsulate the representation of page elements into an object so that we do not
    have to litter our E2E test code with `ElementFinder` and `locators`. If any page
    element moves, we just need to fix the page object.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到了页面对象的概念。页面对象的简单概念是将页面元素的表示封装到一个对象中，这样我们就不需要在端到端测试代码中充斥着`ElementFinder`和`locators`。如果任何页面元素移动，我们只需要修复页面对象。
- en: 'Here is how we can represent our Workout Runner page:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们如何表示我们的Workout Runner页面：
- en: '[PRE44]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This page object now encapsulates many of the elements that we want to test.
    By organizing the element selection code in one place, we increase the readability
    and hence the maintainability of E2E tests.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面对象现在封装了我们想要测试的许多元素。通过在一个地方组织元素选择代码，我们提高了端到端测试的可读性和可维护性。
- en: 'Now add the Workout Runner page object to the top of the test file. We''ll
    use it in a test for the workout runner. Add the following new describe block
    containing the first of our workout runner tests:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将Workout Runner页面对象添加到测试文件顶部。我们将在针对锻炼运行者的测试中使用它。添加以下新的describe块，包含我们的第一个锻炼运行者测试：
- en: '[PRE45]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The test verifies that the workout is loaded and the correct data is shown.
    We make full use of the page object that we defined earlier. Run the test and
    verify that it passes.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 测试验证了锻炼已加载并且显示了正确的数据。我们充分利用了我们之前定义的页面对象。运行测试并验证它是否通过。
- en: 'Let''s get back to the challenge of testing code based on `interval` or `timeout`.
    Let''s add a test that confirms a click event on the screen, when the pause button
    is pushed:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到基于`interval`或`timeout`测试代码的挑战。让我们添加一个测试来确认当按下暂停按钮时屏幕上的点击事件：
- en: '[PRE46]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What is interesting here is that we use the `browser.sleep` function within
    a promise to verify that the exercise time remaining is the same before and after
    the button is clicked. We are again using our `WorkoutRunner` page object to make
    the test more readable and understandable.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，我们在承诺中使用`browser.sleep`函数来验证在按钮点击前后剩余的练习时间是否相同。我们再次使用我们的`WorkoutRunner`页面对象来使测试更加可读和易懂。
- en: It's now time to wrap up the chapter and summarize our learning.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候总结本章内容并总结我们的学习了。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We do not need to reiterate how important unit- and E2E-testing are for any
    application. The way the Angular framework has been designed makes testing the
    Angular app easy. In this chapter, we covered how to write unit tests and E2E
    tests using libraries and frameworks that target Angular.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要重复说明单元测试和端到端测试对任何应用程序的重要性。Angular框架的设计方式使得测试Angular应用程序变得容易。在本章中，我们介绍了如何使用针对Angular的库和框架编写单元测试和端到端测试。
- en: For unit testing, we used Jasmine to write our tests and Karma to execute them.
    We tested pipes, components, services, and directives from *Personal Trainer*.
    In the process, we learned about the challenges and the techniques used to effectively
    test these types.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元测试，我们使用Jasmine编写测试，并使用Karma执行它们。我们测试了来自*Personal Trainer*的管道、组件、服务和指令。在这个过程中，我们了解了测试这些类型的挑战和所使用的技巧。
- en: For E2E testing, the framework of choice was Protractor. We still wrote out
    tests in Jasmine, but the test runner this time was Protractor. We learned how
    Protractor automates E2E testing using Selenium WebDriver, as we did some scenario
    testing for the *Start* and *Workout Runner* pages.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 对于端到端测试，我们选择的是Protractor框架。我们仍然使用Jasmine编写测试，但这次测试运行者是Protractor。我们学习了如何使用Selenium
    WebDriver自动化端到端测试，就像我们为*Start*和*Workout Runner*页面进行了一些场景测试一样。
- en: If you have reached this point, you are getting closer to becoming a proficient
    Angular developer. The next chapter reinforces this with more practical scenarios
    and implementations built using Angular. We will touch upon important concepts
    in the last chapter of this book; these include multilingual support, authentication
    and authorization, communication patterns, performance optimizations, and a few
    others. You certainly do not want to miss them!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经到达这个阶段，你正越来越接近成为一名熟练的 Angular 开发者。下一章通过更多使用 Angular 构建的实用场景和实现来加强这一点。我们将在本书的最后一章涉及一些重要概念；这些包括多语言支持、身份验证和授权、通信模式、性能优化以及一些其他内容。你当然不希望错过它们！
