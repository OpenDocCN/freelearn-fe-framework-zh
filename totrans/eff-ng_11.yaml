- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing Angular Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing automated tests for your applications is just as important as writing
    the application code. Many developers don’t like to write tests or skip them altogether
    because they feel it’s too time-consuming, but as your applications and workspace
    grow, having automated tests becomes ever more critical. When working on an extensive
    application, the chances are significant that your changes will impact many things
    throughout the application. Small changes can affect many things, which becomes
    even more apparent when you’re making changes in a library used in many applications.
    You’ll often find yourself in a scenario where you make changes and don’t even
    know every application surface your changes will impact. Because you don’t want
    to break features, you don’t want to work on or manually test the entire workspace
    each time you make a change; you need automated tests that can test all affected
    code for you. Automated tests will help you look at your code differently; they
    can help you write better, more sturdy code. Automated tests will also catch bugs
    at an early stage and should give you the confidence to safely release code changes
    to production once all tests have successfully passed.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will dive into different types of automated tests and their purpose
    within your Angular applications. Next, you will dive deeper into the topic of
    unit testing and get some hands-on experience by writing unit tests for our Nx
    monorepo using Jest. Lastly, you will learn more about end-to-end testing and
    gain some experience writing end-to-end tests using Cypress. By the end of this
    chapter, you will understand why you need automated tests and how to write them
    for your Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Different types of application testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing of Angular applications using Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end testing of Angular applications using Cypress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of application testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a world where software plays an increasingly important role and the applications
    we build are growing more complex, automated testing is becoming more critical.
    Companies are constantly looking to improve their applications to give users a
    better experience. To achieve this, many companies aim for continuous delivery
    of their software, meaning their updates can be automatically released to production
    at any given time. To ensure you can safely release updates without breaking things
    in production, you need automated tests that can run in your build pipelines to
    automatically test your software before releasing changes to your testing, acceptance,
    and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: As applications become more complex, manually testing all changes becomes too
    time-consuming, and the chances of not testing something affected by your code
    changes increase significantly. Manual testing is also much slower, repetitive,
    and boring. Tasks that are time-consuming, tedious, and repetitive tend to get
    skipped and lead to mistakes. All that manual labor is also a considerable expense
    for the business, so having a sound automated testing system in place is a necessity.
  prefs: []
  type: TYPE_NORMAL
- en: Besides speeding up the testing process and making it less error-prone, automated
    tests should give you the confidence that any code you merge will not break the
    existing application code. If you’ve ever merged a large code change in an environment
    without a good testing suite, you know what a nerve-wracking experience it is
    and that you never really feel confident that your changes didn’t break anything.
    If there are tests, they will catch bugs and help you think differently about
    how you implement your code, but having the ability to release changes confidently
    is the real goal we’re trying to achieve when writing automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to automated tests for your Angular applications, you can divide
    them into four major types:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s learn about these four types of tests, how they are used in Angular applications,
    and the differences between them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the fundamental aspects of software testing is **unit testing**. Simply
    put, unit tests validate small units of code, commonly individual functions, properties,
    or methods. Unit tests are used to test the update behavior of properties and
    the implementation of functions under different scenarios. Given a specified input,
    you expect the function to return a specific value and update certain properties.
    Unit tests run in isolation from the rest of your application, so you can test
    small units of code without them being affected by other parts of the application
    code; that way, you can quickly identify whether the function works as intended
    based on its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A common and popular technique for developing applications is **test-driven
    development** (**TDD**). In simple terms, when you use TDD to develop your applications,
    you first write the test scenarios and then the code implementations. Developing
    your code this way allows you to look at your code implementations from another
    perspective. Writing tests helps you to look at your code implementations differently
    in general. Still, when you first write all the possible test scenarios you want
    to cover and write the code implementation afterward, it changes your perspective.
  prefs: []
  type: TYPE_NORMAL
- en: In Angular applications, unit tests are commonly implemented using frameworks
    such as **Jest** or **Karma** and typically test specific Angular components,
    services, pipes, or directives. These tests are essential for verifying that each
    unit of code behaves as expected, adhering to its defined specifications and requirements.
    By isolating each unit of code, developers can identify and address bugs and issues
    early in development, promoting a more robust and stable application.
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of unit tests in Angular applications is to give developers
    confidence in their code implementations, ensuring properties are updated and
    functions work as expected. By thoroughly testing individual units of code under
    different scenarios, developers can ensure that each line of code functions as
    intended, even as the codebase evolves and changes over time. This confidence
    is crucial to enabling developers to make changes and enhancements to the application
    with the assurance that existing functionalities remain intact.
  prefs: []
  type: TYPE_NORMAL
- en: A characteristic of unit tests is that they are quick to run, allowing developers
    to run them multiple times during the development process, making it easy to identify
    unintended side effects and bugs early. Unit tests also aim to cover a specific
    percentage of the codebase. Typically, companies like to test between 80% and
    100% of the lines of code, functions, and branches (or paths) of the code; most
    unit test frameworks can enforce these thresholds, so you can’t merge the code
    if you don’t have enough testing coverage.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, unit tests are used to test small units of code such as functions,
    methods, and properties. With unit tests, you test code implementations under
    different scenarios to give you confidence that the code behaves as expected given
    a specified input. Commonly, you try to achieve a code testing coverage of between
    80% and 100% for unit tests; so, compared to the other testing types (end-to-end,
    component, and integration), your unit tests will have the most test cases. Unit
    tests are fast to run and rarely fail because of your environment because they
    run in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a good idea of what unit tests are and why they are useful,
    let’s dive into the next type of tests: end-to-end tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding end-to-end tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**End-to-end** (**e2e**) tests are an integral part of the testing strategy
    for Angular applications. They offer a comprehensive approach to validating the
    application’s behavior and functionality from the user’s perspective. Unlike unit
    tests, which focus on testing individual units of code in isolation, e2e tests
    simulate real user interactions with the application, spanning multiple components
    and services to ensure that the application functions correctly as a whole.'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of Angular applications, e2e tests are commonly implemented using
    frameworks such as **Cypress**, **Playwright**, or **Protractor**. These frameworks
    provide helpful tools to automate browser interactions, allowing them to simulate
    user actions such as clicking buttons, entering text, and navigating between pages.
    By automating these interactions, developers can thoroughly test the application’s
    user interface and workflow, identifying and addressing issues that may arise
    during real-world usage.
  prefs: []
  type: TYPE_NORMAL
- en: The primary goal of e2e tests is verifying that the applications work as expected
    from the perspective of the user, encompassing the application’s functional and
    non-functional aspects. e2e tests serve and render the application (or specific
    libraries or modules of the application) in a real browser (you can also run them
    headless without opening a browser), visit a specific URL, and interact with the
    application as a user would. With e2e tests, you are testing whether components
    render correctly and whether features such as form submission, data retrieval
    and display, models, and error handling work as intended. By testing the application
    end-to-end, developers can ensure that multiple components and services work together
    seamlessly to deliver a cohesive user experience.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of e2e tests is their ability to detect issues that
    may be absent when testing individual units of code in isolation. By exercising
    the entire application stack during the tests, including the frontend user interface,
    external dependencies, and (optionally) backend services, e2e tests can uncover
    issues related to data flow, communication between components, and interoperability
    with third-party services. This holistic approach to testing helps developers
    identify and address potential bottlenecks and failure points within the application,
    leading to a more robust and reliable software product.
  prefs: []
  type: TYPE_NORMAL
- en: However, while e2e tests offer many benefits, they also come with certain challenges
    and considerations that developers must address. The setup for e2e tests is more
    challenging than unit tests, and e2e tests are more prone to fail because of issues
    in the test environment. Nx already handles most of the setup for us, making starting
    with our e2e tests easier.
  prefs: []
  type: TYPE_NORMAL
- en: With e2e tests, you also don’t have an easy way to detect code coverage, so
    they require more planning and coordination to ensure you’re testing everything
    within your application and handling different scenarios and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, e2e tests can be more time-consuming and resource-intensive to
    execute than unit tests due to their reliance on browser automation and the need
    to simulate real user behavior. As a result, developers must strike a balance
    between the depth and scope of e2e test coverage and the practical constraints
    of test execution time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Despite these challenges, e2e tests play a crucial role in ensuring Angular
    applications’ overall quality and reliability, complementing other testing techniques
    such as unit tests and integration tests. By thoroughly testing the application
    from end to end, developers can gain confidence in its behavior and functionality,
    identify and address issues early in the development process, and ultimately deliver
    a high-quality user experience to their customers.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, e2e tests are designed to test your application from the user’s
    perspective and interact with your application in a real browser. They ensure
    your application (or specific libraries or modules) works as a whole and responds
    in the intended way to user interactions. e2e tests, while more time-consuming
    to write and execute than unit tests, provide the assurance that the user can
    interact with your applications as you intended, fostering a stronger connection
    with your end users.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what e2e tests are and how they differ from unit tests, I
    will briefly explain component and integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding component tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Component testing** is a relatively new concept compared to unit and e2e
    testing. In modern frontend frameworks such as Angular, we develop applications
    using **components**. Components can be simple components, such as buttons, or
    more complex ones, such as tables or forms.'
  prefs: []
  type: TYPE_NORMAL
- en: Using component tests, frameworks such as Cypress provide a new approach for
    testing component-based applications. Instead of visiting a URL and running the
    entire application, component tests mount individual components and test those
    components in isolation. Component testing is like unit testing of e2e testing.
    You still mount the component and show it in a browser to interact with the component
    like a user would, but you test it in isolation from the rest of your application.
    Testing components in isolation allows you to test the component from a user interaction
    perspective without worrying about the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is that even if all your component tests are passing,
    it does not automatically mean your application is working as expected. Components
    can work in isolation but fail when they’re combined or have to interact with
    other components in your application. Compared to e2e tests, component tests don’t
    need the entire system to be executed, so they can run faster and rarely fail
    due to issues with your test environment.
  prefs: []
  type: TYPE_NORMAL
- en: If you and your team want to implement component tests, it is up to you; these
    tests can help reduce the number of e2e tests you need to write. I like to write
    more e2e tests as opposed to component tests. Component tests still need to be
    adopted as an industry standard; most companies only require unit, e2e, and integration
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, component tests test individual components from the user’s perspective.
    Component tests ensure a component works in isolation but don’t ensure the component
    works within the context of your entire application. Component tests are easier
    to set up than e2e tests as they don’t need to run the entire application. You
    can think of component testing as a mix between unit and e2e testing.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what component tests are and how they differ from e2e tests,
    we will finish this section on different testing types by explaining integration
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding integration tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Integration tests** are used to test whether different modules and elements
    of your software integrate without breaking. They are generally the final testing
    stage before you release your changes to production. So, unit tests focus on testing
    individual units of code in isolation, end-to-end tests simulate and test user
    interactions for specific application libraries and modules, and integration tests
    are used to test the interactions between various modules and elements within
    the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests can be used and written for different integration levels within
    an application. For example, you can write functional tests comparable to unit
    tests. Still, instead of testing code implementations for an isolated component
    or service, you test whether your functionality and implementations work as expected
    for a group of components or services that work together. You can also write integration
    tests from the user’s perspective, similar to e2e tests. When you write integration
    tests from the user’s perspective, you can test whether your frontend works together
    with your API or whether your deployed application is composed of multiple Angular
    applications. You can also test whether the different applications can work together
    when everything is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create integration tests from the user’s perspective, you commonly
    run the tests in an environment that mirrors the production environment. You test
    with an actual deployed application with real APIs and data. By testing on a deployed
    system, you can test whether all elements of your software work together as expected
    without any boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know about unit, e2e, component, and integration tests, it’s time to
    get our hands dirty and write some tests ourselves. We will skip the integration
    tests because we don’t have a large system or a deployed version with different
    elements that integrate. We will start by writing and running unit tests for our
    Angular application using the Jest testing framework. After writing our unit test,
    we will finish the chapter by writing e2e tests using the Cypress testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing of Angular applications using Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you add an Angular project to your Nx monorepo, the application is set
    up to use Jest as a test runner by default. Jest is a testing framework commonly
    used to write and run automated unit tests for JavaScript and TypeScript-based
    applications. This section will give you hands-on experience writing unit tests
    for your Angular application using Jest. Before you start writing tests, let’s
    expand upon the default configuration Nx provided to make your testing experience
    better.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the coverage threshold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing you want to add in the Jest configuration is a coverage threshold
    for the minimum required percentage of lines, functions, and branches that unit
    tests should cover. A commonly used percentage is 80%, but you can set the coverage
    percentages to whatever you and your team deem enough to make you confident that
    new changes won’t break existing code. You can add the global configurations for
    testing coverage inside the `jest.preset.js` file in the root of your Nx monorepo.
    Additionally, you can set specific configurations for each project in the `jest.config.ts`
    file at the root of each project. I will only add the following configurations
    in `jest.preset.js` in the root of the Nx monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration ensures that all branches, functions, and lines
    have a minimum test coverage of 80%. The configuration also tells Jest to collect
    the coverage results and present you with a text-based coverage report. In the
    coverage report, you can see how much of your code is covered, what lines, functions,
    and branches are missing, and their respective page line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have configured your test coverage reports, it’s time to add a
    testing module for Transloco.
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The testing module makes it easy to import the correct configuration to test
    components using Transloco. In the root of your `expenses-registration` project,
    you can create a `transloco-testing.module.ts` file and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we created a `getTranslocoModule()` function. This
    function will be used inside our unit test files to add the necessary Transloco
    configuration for the test setup. It’s simply a function returning the `TranslocoTestingModule`
    class provided by the `Transloco` library. At the top of the file, we import two
    JSON files containing our translations. If you want to import these two JSON files
    without trouble, you need to add the following configurations inside your `tsconfig.base.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the preceding configuration and the `transloco-testing.module.ts`
    file with the `getTranslocoModule()` function, we are almost done with our addition
    to the default Jest setup Nx provided us with. Lastly, we need to update the `transformIgnorePatterns`
    configuration inside our `jest.config.ts` files to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When you change the `transformIgnorePatterns` configuration, you ensure Jest
    will not start to complain about missing imports and packages inside your `node_modules`
    folder. There already are `transformIgnorePatterns` configurations inside each
    `jest.config.ts` file in your Nx monorepo, but in many cases, you need to adjust
    them or else your tests might fail based on things inside your `node_modules`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: That is all the additional setup we will be doing. You can always add additional
    configurations as needed. You can find all additional Jest configurations in their
    official documentation at [https://jestjs.io/docs/configuration](https://jestjs.io/docs/configuration).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have added the configuration needed to test Transloco and obtained
    testing coverage reports, let’s start to write and run unit tests for our Angular
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and running unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You write your unit tests inside `.spec.ts` file for the created resource. These
    `.spec.ts` files contain the default-generated unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take the `expenses-registration` Angular application as our example. When
    you generated the application, Nx generated an `AppComponent` class for you and
    an `app.component.spec.ts` file where the default generated unit test for `AppComponent`
    resides. Additionally, we created `ExpensesOverviewPageComponent` and `ExpensesApprovalPageComponent`
    inside the *expenses-registration application*; for both these components, Nx
    also generated `.spec.ts` files. Let’s start with these files.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the generated spec files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you currently run the tests inside these spec files, they will fail. The
    tests will fail because we haven’t touched the spec files since they have been
    generated, but we did adjust the component classes. So before we try to run the
    tests, let’s fix the spec files one by one. We will also write some new tests
    and explain what Nx generated for us. Starting with the `app.component.spec.ts`
    file, let’s see what Nx has generated inside the spec file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Nx generated the preceding code for you. As you can see, there are `describe()`,
    `beforeEach()`, and two `it()` functions. All of these functions have some additional
    code inside their respective callback functions, but we will ignore that for now.
    Let’s first explain what `describe()`, `beforeEach()`, and `it()` functions are
    used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`describe()`: The `describe()` function is used to group multiple tests together
    and describe what element we are testing. You provide the `describe()` function
    with two parameters: a string with a description of what we’re writing tests for—in
    our example, `AppComponent`—and a callback function where we will write out specific
    test cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeEach()`: The `beforeEach()` function is used to perform specific steps
    before each test, commonly configurations such as setting up `TestBed`, creating
    the component, service, pipe, or directive we are testing, and any additional
    configuration we want to do before each test we run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it()`: The `it()` functions define each test case. An `it()` function takes
    in two parameters: a string containing a description of the test case and a callback
    function containing the testing logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know what `describe()`, `beforeEach()`, and `it()` functions are,
    let’s replace the generated code of your `app.component.spec.ts` file with something
    that reflects the current state of the app component.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our test cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we start adjusting the code inside the spec file, let’s first clarify
    what we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look inside your `AppComponent` class, you find two properties: a `translationService`
    and a `navItems` property. Additionally, inside the HTML template of your app
    component, you’ll find the navbar component with some inputs and an output for
    when the selected language changes. As we mentioned before, when writing unit
    tests, you want to test a single unit of code in isolation—in this case, our app
    component. So, what functionalities are related to the app component?'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the component class properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling the `setActiveLanguage` method on the `translationService` property
    of the navbar to emit a `languageChange` event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The aforementioned points are the only component logic related to the app component;
    checking whether the navbar inputs are correctly handled and whether the navbar
    renders correctly is logic related to the navbar and should be tested in the spec
    file of the navbar component. If we were to check these things inside the spec
    file of the app component, we would be testing whether the navbar and app components
    integrate correctly. For the same reason, we do not check whether `TranslationService`
    actually adjusts the active language after we call the method. This would test
    the integration between the app component and `TranslationService`. From the perspective
    of the app component, we are only interested if the app component actually makes
    the function call. Now we know what we will be testing, let’s define what `it()`
    statements we will be creating inside our spec file:'
  prefs: []
  type: TYPE_NORMAL
- en: They should create the component and set the component properties with the expected
    values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They should call the `setActiveLanguage` method when the `languageChange` event
    is emitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have defined the `it()` statements we’re about to define inside
    the `app.component.spec.ts` file, let’s start to adjust the file step by step
    so we can actually test these statements successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the code inside the spec file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We defined the test cases we wanted to write and learned about the three main
    functions inside the spec files. Now, let’s write our test cases and learn how
    to configure your testing modules, make assertions for your test cases, and actually
    run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: The describe() function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will start by removing all the code inside the `describe()` function so
    we can start fresh. The `describe()` function itself can remain as it was generated
    for you. After you remove the generated code, start by defining three properties
    inside the `describe()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code snippet, we added `component`, `fixture`,
    and `mockTranslationService` properties inside the `describe()` function. The
    `component` variable will hold an instance of our `AppComponent` class, `fixture`
    will be an element containing a test harness that can be used to debug and interact
    with the app component (the class, native element, element ref, lifecycle methods,
    etc.), and `mockTranslationService` will be used as a value for the `TranslationService`
    injectable we use inside the app component. We use this mock version of `TranslationService`
    to simplify the setup we need to do inside our spec file. Because we don’t want
    to test the integration between our app component and `TranslationService`, we
    want to test the app component in isolation. After you have defined these three
    properties, it’s time to add the `beforeEach()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The beforeEach() function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `beforeEach()` function will be added underneath the three properties we
    added just now and will be used to configure `TestBed` and assign our `component`
    and `fixture` properties before each test. Let’s start simply by defining the
    `beforeEach()` method itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now inside the callback of the `beforeEach()` function, we start by configuring
    the testing module using the `TestBed.configureTestingModule()` method. The testing
    module requires everything needed to create our app component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we need to import three classes and define
    a provider to configure the testing module. You need to import the `AppComponent`
    class because `AppComponent` is a standalone component, `RouterTestingModule`
    because we use the `RouterOutlet` inside the app component template, and `TranslocoTestingModule`
    using the `getTranslocoModule()` function we defined in the *Adding additional
    configurations* section of this chapter. Besides the imports, you need to create
    a provider for `TranslationService` so that the app component uses `mockTranslationService`
    during the tests. At the end of the `configureTestingModule()` method, you need
    to call the `compileComponents()` methods so that Jest will compile everything
    we defined inside the testing module configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `TestBed` testing module is configured, we will assign the `component`
    and `fixture` properties. The `fixture` property will be assigned using the `TestBed.createComponent()`
    method. Calling the `createComponent()` function on `TestBed` will freeze the
    current `TestBed` class, meaning you can’t call `TestBed` configuration methods
    anymore. It will also return a test harness that can be used to interact with
    the component created inside your test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After assigning `fixture`, you assign the `component` variable using the `componentInstance`
    property of `fixture`. This `componentInstance` property is an object containing
    all the properties and functions of the component you’re testing—in our case,
    `AppComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you need to call the `detectChanges()` method on `fixture` so that
    change detection will run for the created app component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have defined the `beforeEach()` function and configured `TestBed`,
    we can start with our first `it()` function and define the first test case.
  prefs: []
  type: TYPE_NORMAL
- en: The first it() function and test case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can define your `it()` function underneath the `beforeEach()` function.
    In our case, the first test case should test whether the component is successfully
    created and the `navItems` and `translationService` properties are correctly assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we start with the `it()` function and
    provide the function with a description. Then, in the callback function, we assess
    what we want to test using the `expect()` function combined with an assertion
    method. You provide the `expect()` method with the value you want to test and
    expect to be or not to be something. In our case, we first expect the component
    property (which is assigned without a component instance inside the `beforeEach()`
    function) to be defined. Next, we expect the `navItems` property of the component
    to equal the object we defined inside the component class for the `navItems` property.
    Lastly, we expect `translationService` to equal `mockTranslationService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have defined the `beforeEach()` function, configured `TestBed`, created
    the component inside the `beforeEach()` function, and written your first testing
    case. You can run the test inside the `app.component.spec.ts` file. You run unit
    tests by running the following command in the root of your Nx monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding Terminal command, you need to replace the `<project-name>`
    placeholder with the actual name of the project you want to run tests for. You
    can find the project name inside the `project.json` file of each application or
    library within your Nx monorepo. To run the unit tests for a specific file, add
    the `–test-file` flag at the end of the command. For example, to run the unit
    tests for our `app.component.spec.ts` file, you run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will run the tests inside the `app.component.spec.ts`
    file. After running the tests, you’ll notice that your test case is failing with
    the following error message: `NavbarComponent` and Jest doesn’t support signal
    inputs (at the time of writing).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a workaround, you can create a simplified replica of `NavbarComponent` that
    is used for unit testing components that use `NavbarComponent` in their template.
    Such a replica is commonly named a `AppComponent` functionality in isolation instead
    of having it integrated with `NavbarComponent`. You create the navbar stub component
    in your `common-components` library inside the `navbar` folder by adding a `navbar.component.stub.ts`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the stub component, export it in the `index.ts` file of your
    `common-components` library so you can access the stub component in your spec
    files. Now, inside the `beforeEach()` function of the `app.component.spec.ts`
    file, you can ensure the app component uses the stub navbar component during the
    tests instead of the regular navbar component. You can achieve this by changing
    the navbar component import for the stub navbar component using the `TestBed.overrideComponent()`
    method. You need to simply remove the `NavbarComponent` import and add the `StubNavbarComponent`
    import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we remove the `NavbarComponent` import
    from `AppComponent` and add `StubNavbarComponent`. It’s important that you overwrite
    the component imports before you call the `TestBed.createComponent()` method and
    freeze `TestBed`; otherwise, your override will not be included in `TestBed`.
  prefs: []
  type: TYPE_NORMAL
- en: Using stub components and services can be helpful in cases like this, where
    Jest still needs to add support for specific features. Additionally, stubs ensure
    that you’re not integration testing but focusing on units of code in isolation.
    If you want to unit test the navbar, for example, you should do so in the spec
    file of the navbar component and not in the spec file of the app component. Additionally,
    using stub components can simplify the setup you need in the `beforeEach()` method
    to ensure Jest can create the component or service you want to unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you rerun the app component unit tests after adding the stub navbar
    component. In that case, you’ll see that the test case we defined in the spec
    file is passing, meaning the test successfully creates `componentInstance`. Still,
    the test run fails because we don’t meet the configured coverage requirements
    of 80%. If you look at the coverage report in your terminal, you’ll see that the
    coverages of your `app.component.ts` and `app.component.html` files are 100%,
    but the coverage of your `translation.service.ts` file is 0%, bringing the total
    testing coverage under the required 80%.
  prefs: []
  type: TYPE_NORMAL
- en: So, why is the testing coverage including `translation.service.ts`, and should
    you care? The `translation.service.ts` file is included in your coverage report
    because, by default, Jest (and other test runners) will consist of all files in
    the coverage report you import and use within the class you’re testing—in this
    case, the `AppComponent` class. Should you care, and do you need to fix this shortfall
    in your coverage percentage?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is it depends on how you run the tests. If you’re running the tests
    for a single file, as we are doing now, you shouldn’t care and should only focus
    on the files related to the unit you’re testing—in our case, the app component.
    After all, you want to write shallow unit tests that only test a single unit of
    code in isolation, so if you have a testing coverage of 80% or higher for the
    files related to the unit you’re testing, everything is good! However, if you’re
    running the unit test for an entire project by omitting the `–test-file` flag,
    you should care about the coverage percentage. For your entire project, you should
    have enough coverage. In this example, the code related to the `translation.service.ts`
    file should be tested in a `translation.service.spec.ts` file. If you run the
    unit tests for the entire project and you cover the logic of your `translation.service.ts`
    file inside the `translation.service.spec.ts` file, you will not have the shortfall
    in your coverage report and the test run will succeed. Now that we have clarified
    that, let’s add our second `it()` function for `app.component.spec.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: The second it() function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we have 100% testing coverage for our app-component-related files, our
    test might not give us the confidence we need that everything works as expected.
    We don’t test whether the app component class calls the `setActiveLanguage` method
    when the navbar emits a `languageChange` event, so let’s add a test for this.
    You can add the following code to test whether the app component calls the `setActiveLanguage`
    method when it receives the `languageChange` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, quite a lot is happening, so let’s examine each line
    carefully.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the `it()` function and provide it with a description of our
    test case. Inside the callback function, we start by creating a spy element.
  prefs: []
  type: TYPE_NORMAL
- en: '`setActiveLanguage` method of the `translationService` property is called.
    Create the spy object by using the `jest.spyOn()` function. Inside the `jest.spyOn()`
    function, first provide the object containing the function you want to spy on
    and then, as a string, the function name you want to spy on.'
  prefs: []
  type: TYPE_NORMAL
- en: After creating the spy object, we use `debugElement` of `fixture` to access
    `StubNavbarComponent` inside our HTML template and save it in a constant named
    `navBarElement`. Next, we use the `triggerEventHandler` method on `navBarElement`
    to trigger the `languageChange` event and provide `nl` as the event data.
  prefs: []
  type: TYPE_NORMAL
- en: After triggering the `languageChange` event, we expect that `setActiveLanguage()`
    is called with the `nl` parameter. We check whether this is correct by providing
    the `expect()` function with the `setActiveLanguage` spy object and calling the
    `toHaveBeenCalledWith('nl')` assertion method on the `expect()` function.
  prefs: []
  type: TYPE_NORMAL
- en: After adding your second testing case to the `app.component.spec.ts` file, you
    can run the tests again, and you’ll notice that both test cases are successful.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, you learned that the `describe()` function is used to group test
    cases and the `beforeEach()` function is used to configure `TestBed` and define
    values before each test case runs. The `it()` functions are used to define your
    test cases, and inside the `it()` functions, you use the `expect()` function combined
    with assertion methods to perform your test statements. You can create and use
    spy objects to validate whether functions are called. When writing unit tests,
    you should write shallow unit tests that focus on a single unit of code instead
    of testing the integration of different components and services. You can write
    shallow unit tests and prevent issues with unsupported features by creating stub
    components and services, which are simplified replicas used within your unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of unit tests and you’ve created your
    first tests, we will fix the additional spec files of the `expenses-registration`
    component so we can do a successful test run for the application. Additionally,
    you will learn how to run unit tests for multiple projects in your Nx monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional unit tests for the expenses-registration application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now start writing some additional unit tests for the *expenses-registration
    application* so you can successfully run the unit tests for the entire application
    without specifying the `–test-file` flag. To start, we will remove the `expenses-approval-page.component.spec.ts`
    file because we haven’t added any code yet inside the expenses approval component.
    After removing `expenses-approval-page.component.spec.ts`, we will adjust the
    tests inside `expenses-overview-page.component.spec.ts`. We made quite some adjustments
    to the `ExpensesOverviewPageComponent` class, so fixing the related spec file
    will be a bit more work compared to the spec file for `AppComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by running the unit tests with the following command and see what
    pops up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It might come as no surprise that the test run fails. Let’s fix the issues with
    the spec file one by one, starting with the import of `ExpensesOverviewPageComponent`
    inside the spec file.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the code inside our other spec file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because we changed the export of `ExpensesOverviewPageComponent` to a default
    export, we also need to adjust the import inside the spec file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After changing the `import` statement, you need to adjust the spec file so
    `TestBed` can successfully create the `expenses-overview` component. Just like
    the app component, the `expenses-overview` component uses `TranslationService`,
    so we will make a mock object for this service (alternatively, you can create
    a stub service for it and also use that inside the spec file of the app component):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, `mockTranslationService` for this spec
    file differs from the `mockTranslationService` class we created for the spec file
    of the app component. The mock objects differ because we only include what we
    use inside the component we are about to test in the mock object; in this case,
    the `expenses-overview` component only uses the `translocoService` and `translationsLoaded`
    properties of the service. Besides `mockTranslationService`, we also need a stub
    for `ExpensesFacade`. You can copy `StubExpensesFacade` from the GitHub repository
    for this book. The `expenses.facade.stub.ts` file is located next to the regular
    `expenses.facade.ts` file inside the finance `data-access` library. After creating
    the mock and stub objects we need for our unit tests, we can create the `beforeEach()`
    function and set up `TestBed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we import `ExpensesOverviewPageComponent`
    and `TranslocoTestingModule` using the `getTranslocoModule()` function. After
    the imports for the testing module, we added some providers that needed to configure
    the testing module. We provide `ExpensesFacade` and `TranslationService` with
    the mock and stub values, and we provide the `TranslocoLocale` configuration because
    we use the localization pipes inside the `expenses-overview` page. After configuring
    the imports and providers for the testing module, we created and assigned the
    `fixture` and `component` properties and called `detectChanges()` on `fixture`.
    Now we have configured everything needed to create the component inside `TestBed`,
    let’s remove all `it()` functions and write our own test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the test cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create the following test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The test should create the component and initialize the properties correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should fetch expenses on `init`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should translate the title if translations are loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should change `summaryBtnText` if `onSummaryChange` is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should call `addExpense` on the expenses facade with the correct values when
    `onAddExpense` is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have defined our test cases, let’s create them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, this test is really straightforward;
    we simply check whether the component variable is defined and whether each component
    property is initialized with the value we expect. As you may have noticed, we
    used some new assertion methods here, such as `toBeFalsy()` and `toBeInstanceOf()`.
    These assertion methods can be used to check whether a value is false in a Boolean
    context and whether an object is an instance of a specific class. Besides `toBeFalsy()`
    and `toBeInstanceOf()`, we did nothing new in this test, so let’s move on to our
    next test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding test, we create a spy object to spy on the `fetchExpenses()`
    function of `ExpensesFacade`. After that, we call `ngOnInit()` for the component
    we are testing—in this case, the `expenses-overview` page component—and at the
    end of our test, we use the `expect()` function to check whether the `fetchExpenses()`
    function is called. As you can see, calling a method declared in the component
    we are testing is super straightforward; you simply use the `component` variable
    and call the method you want to run. Now that we’ve also covered this test, let’s
    move on to the next test case we defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, a bit more is going on, and we used some new techniques.
    Let’s explore what we do here in more detail. Because we are testing a signal
    effect in this test and signal effect are asynchronous, we wrapped the callback
    of our `it()` function inside a `fakeAsync()` function. Inside the `fakeAsync()`
    function, times are synchronous. You can manually execute microtasks by calling
    `flushMicroTasks()` and simulating time passing with the `tick()` function. After
    using the `fakeAsync()` function, we first define a spy object. Then, we check
    whether the `translationsLoaded` signal has a false value and that the `translate()`
    function that we use inside our signal effect isn’t called. Next, we set the value
    of the `translationsLoaded` signal to `true`. This should trigger the signal effect
    again, and this time, we should reach the part where we use the `translate()`
    function. Because the signal effect is asynchronous, we first call the `tick()`
    function to simulate the passing of time, and after that, we check whether our
    spy object is called with the correct translation key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have explained the `fakeAsync()` and `tick()` functions used in
    our last test case, let’s continue and add the next test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, this is a simple test. We first check
    whether the `showSummary` signal is false and the `summaryBtnText` computed signal
    returns `onSummaryChange()` function and check whether the `showSummary` signal
    and the `summaryBtnText` computed signal are adjusted correctly. After adding
    the preceding test, there is only one test case to add to our spec file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we first create a spy object to spy on the `addExpense()`
    function of `ExpensesFacade`. After creating the spy object, we create an `expense`
    object to provide to the `onAddExpense()` method. After creating `expense`, we
    call the `onAddExpense()` method and provide it with the `expenseToAdd` property.
    After we call the `onAddExpense()` method, the `addExpense()` function of the
    facade should be called with the `expenseToAdd` property as a function parameter.
    We verify that the `addExpense()` function is called with the correct parameter
    using the `toHaveBeenCalledWith()` assertion method. Lastly, we use the `toContainEqual()`
    assertion method to check whether `expense` is added to the `expenses` signal
    of the `expenses-overview` page component.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the last test case, you can run the tests again using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After you run the tests again, you’ll find that all tests are passing and you
    have 100% coverage for the files related to the `expenses-overview` component.
    You can write some additional tests to test the template, but this will also be
    covered with the e2e tests we will write in the next section. Now that you know
    how to run the unit tests for your individual spec file, let’s examine how to
    run unit tests for one or more projects within your Nx monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests for one or more projects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We ran the unit tests for the spec files one by one, so now let’s run them
    for the entire `finance-expenses-registration` project. When you run the unit
    tests for an entire project, it will run the tests in all spec files found inside
    that Nx project. Note that this will not include any library projects you use
    inside the project. For example, to run the test for all spec files inside the
    `finance-expenses-registration` project, you use the following Terminal command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When you run the preceding command, you’ll notice that the test run fails because
    we do not meet the coverage threshold of 80%. This is because we do not test the
    `translation.service.ts` file. As an exercise, you can create the spec file for
    `TranslationService` yourself; alternatively, you can lower the coverage threshold.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides running the unit tests for a single project, you can also run unit
    tests for multiple projects at the same time using the `run-many` command. When
    using the `run-many` command without any additional parameters, you will run the
    unit tests for projects found in your entire Nx monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, you can add specific project names at the end of the terminal
    command to only run the unit tests for specific projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run the unit tests for all projects and exclude specific projects
    from the test run using the `–``exclude` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you can use the `affected` terminal command. The `affected` command
    can be used to run the unit tests for all projects affected by your changes. Nx
    will look at its cache and check what projects have changed since the last time
    the unit tests ran. Any project affected by changes made after the latest cached
    test run will be run when using the `affected` command. The `affected` command
    is particularly useful when you run your unit tests on a build pipeline and want
    to test your code each time you’re merging code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, you can run tests for individual spec files, for one or more Nx
    projects, or for projects affected by your changes. Unit tests are meant to test
    isolated units and should make you confident that your changes will not break
    your existing code implementations. Unit tests consist of three main parts, the
    `describe()`, `beforeEach()` and `it()` functions, and inside your test cases,
    you assert them using the `expect()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to write and run unit tests, it’s time to dive deeper
    into the topic of e2e tests.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing of Angular applications using Cypress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you create an application using the Nx CLI or Nx console, two projects
    are created for you: a regular application (in our case, an Angular application)
    and an e2e project configured to test the generated application project using
    the Cypress testing framework. For example, when we created the `expenses-registration`
    project, Nx also created an `expenses-registration-e2e` project. The folder for
    the `expenses-registration-e2e` project is located next to the `expenses-registration`
    project folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start writing our own e2e tests, let’s see what Nx generated for
    us inside the `expenses-registration-e2e` folder. When you open the `expenses-registration-e2e`
    folder, you find some folders and four files. The `.eslintrc.json`, `cypress.config.ts`,
    `project.json`, and `tsconfig.json` files are all meant to configure Cypress and
    the e2e project. We want to adjust one small thing inside the `tsconfig.json`
    file; you can leave the rest of the files untouched. Inside this `tsconfig.json`
    file, you’ll find an `include` array; inside this `include` array, add the following
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the configurations created by Nx, you also want to add one small thing
    inside the `.eslintrc.json` file at the root of your Nx monorepo. Inside the `.eslintrc.json`
    file at the root of your Nx monorepo, you’ll find a `project` array; inside this
    array, add the following value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Without the two aforementioned additions to your configuration, you will run
    into some ESLint parsing errors. After adding the additional configurations, let’s
    see what else Nx has generated inside the `expenses-registration-e2e` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see a `cypress` folder and an `src` folder inside the `expenses-registration-e2e`
    folder. The `cypress` folder can be ignored; inside the `src` folder, you’ll find
    `e2e`, `fixtures`, and `support` folders that have the following purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`e2e`: Inside the `e2e` folder, you’ll add the files containing your e2e tests.
    Nx already generated an `app.cy.ts` file inside this folder. As you can see, the
    file name ends with `cy.ts`. This is a naming convention for the files containing
    your Cypress e2e tests. The `cy` at the end of your file is short for Cypress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixtures`: Inside the `fixture` folder, you can add JSON files containing
    the mock data you want to use inside your e2e test. Using fixtures is useful when
    you want to use specific data for e2e tests. Additionally, you often won’t have
    an API or mocking service you can or want to use during your e2e tests. Adding
    mocking services or APIs in your e2e tests often requires a lot of additional
    setup in both your local environment and in your pipelines where you want to run
    the e2e tests. Besides additional setup, using a real API or the same mocking
    service as your development environment can lead to more instability for your
    e2e test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`support`: Inside the `support` folder, you’ll find everything you need to
    write and run your e2e tests. Some things you place inside the `support` folder
    are a file containing all the imports you use inside the e2e project, a file containing
    page objects used inside your `.cy.ts` files, additional setup files, or files
    with custom Cypress commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have an idea of what Nx generated for you and what the files and
    folders inside your e2e project are used for, let’s start to write and run e2e
    tests for the `expenses-registration` project.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first e2e test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by removing the `app.cy.ts` file and replacing it with an `expenses-registration.cy.ts`
    file. Inside this `expenses-registration.cy.ts` file, we will write the e2e tests
    that will test the *expenses-registration application*. As we did with the unit
    tests, we define a `describe()` function. You use the `describe()` function for
    grouping multiple e2e tests, similar to the `describe()` function we used for
    the unit tests. The `describe()` function takes two arguments: a description and
    a callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the callback function of the `describe()` function, we will add
    a `beforeEach()` function. Inside the `beforeEach()` function, you can define
    the steps you want to perform before each e2e test. Some common steps defined
    inside the `beforeEach()` function are visiting the URL of your application, setting
    up interceptors, logging in as a user, and closing the cookie consent message.
    In our case, we will only visit the URL of the application, and later, we will
    create an interceptor to demonstrate how you can use the fixtures to provide mocked
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined the `beforeEach()` function, and inside the
    callback, we visited the base URL of our application using the `visit()` method
    on the `cy` object. The `cy` object is a global helper object provided to you
    by the Cypress framework used for all sorts of things, such as visiting pages,
    accessing page and window objects, reacting to events, setting up interceptors,
    and waiting for requests. In the preceding example, we used the `visit()` method.
    We provided it with an empty string as a function parameter to indicate Cypress
    should visit the base URL of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining the `beforeEach()` function and visiting your application base
    URL, let’s add our first simple e2e test. As with unit tests, your test cases
    are defined using the `it()` function. Similar to the unit tests, your `it()`
    functions receive a description and a callback function. Inside the callback function,
    you write the code for your test cases. Let’s start simple and write an e2e test
    to check whether the application redirects to the `expenses-overview` route when
    we visit the base URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we describe the test case and then write
    the logic for our test case inside the callback of the `it()` function. For the
    prior test case, we only need one line of logic. The `beforeEach()` function will
    open the application on the base URL. When we open our app on the base URL, we
    should be redirected to the `expenses-overview` route, so when we reach the `it()`
    function, the application should be redirected to the `expenses-overview` route.
    In this test case, you only have to assert whether the current URL equals `http://localhost:4200/expenses-overview`.
    In your Cypress tests, you generally get a page or window element and interact
    with them or assert the text, CSS classes, or attributes; in this case, you get
    the browser URL and assert whether the URL equals the text you expect.
  prefs: []
  type: TYPE_NORMAL
- en: The `cy` object exposes most window objects by default; if you want to access
    elements from within the HTML structure of your application, you can use the `.get()`
    method on the `cy` object. In our example, we are interested in the URL, which
    is located in the `location.href` property of the `window` object. The `cy` object
    exposes the `location.href` property by default using the `.``URL()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you get the element you want to assert, you can chain the `.should()`
    assertion method to make the assertion you want to make. The `.should()` method
    takes in two parameters: an assertion type and a value with which to perform the
    assertion. In our case, we provided the `.should()` method with the `equal` assertion
    type and provided the `http://localhost:4200/expenses-overview` value to check
    whether our provided value equals the element we want to assert—in this instance,
    the URL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a list of all assertion types in the official Cypress documentation:
    [https://docs.cypress.io/guides/references/assertions](https://docs.cypress.io/guides/references/assertions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve written the first e2e tests and explained how everything works,
    let’s run the e2e test and see whether the test will succeed. You can start your
    e2e tests by running the following terminal command at the root of your Nx monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, you need to replace `<project-name>` with the name
    found in the `project.json` file of the e2e project you want to run. Just as with
    the unit tests, you can also run the e2e tests for multiple projects using the
    `run-many` command or for affected projects with the `affected` command.
  prefs: []
  type: TYPE_NORMAL
- en: When running one of the aforementioned commands, the e2e tests will run headlessly,
    meaning no browser will be opened to execute your e2e tests. Running your e2e
    tests headlessly is ideal if you want to run your tests in a build pipeline or
    another environment where you don’t have access to a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is nice to see Cypress executing the tests in a real browser during the
    development process. When Cypress executes the tests in a real live browser, you
    can better understand why tests are failing. There is a nice user interface allowing
    you to easily spot what tests are failing and navigate to the specific steps in
    which they’re failing. To run the e2e tests in a real live browser, you can use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So let’s change the `<project-name>` placeholder with `finance-expenses-registration-e2e`
    and run the test we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in *Figure 11**.1*, the Cypress UI will be started and ask you to
    choose a browser when you run the preceding terminal command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Cypress UI start screen](img/B21625_11_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Cypress UI start screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `.cy.ts` files located inside the `e2e` folder of your e2e project;
    in our case, we only have one file, the `expenses-registration.cy.ts` file. When
    you click on the file name, Cypress will run the e2e tests for that specific file.
    In *Figure 11**.2*, you can see what the test run looks like for our `expenses-registration.cy.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: Cypress UI test run screen](img/B21625_11_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Cypress UI test run screen'
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 11**.2*, on the left side, you can see the tests that are
    being executed and whether they pass or fail, and on the right side, you can see
    the application and what Cypress is doing inside the application.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, Nx creates an e2e project for each application you generate using
    the Nx cli or Nx console. You create `.cy.ts` files inside the `e2e` folder to
    define your test cases. Test cases are grouped using the `describe()` function
    and the `beforeEach()` function, which can be used to execute logic before each
    e2e test. The test cases themselves are defined using the `it()` function, and
    inside the callback of your `it()` function, you define the test logic. You can
    get elements using the `cy` object and assert values using the `.should()` method
    combined with an assertion type and a value to assert. When you define your tests,
    you can execute them in a real browser or headlessly if you want to run them inside
    an environment where you don’t have access to a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned the basics of e2e testing, created your first test,
    and run your test using the Cypress UI, let’s add some extra e2e tests to learn
    about additional concepts and patterns commonly used within e2e testing.
  prefs: []
  type: TYPE_NORMAL
- en: Defining page objects for e2e testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common pattern in e2e testing is the **page object pattern**. When using the
    page object pattern, you abstract the selection of page elements away from the
    actual tests, resulting in more readable and maintainable tests. To demonstrate
    the page object pattern, let’s first create a new e2e test without using the page
    object pattern and then adjust the new test by using the page object pattern.
    The new test case will check whether the **Show summary** button is shown by default,
    and when we click the button, the summary will be shown. Additionally, the test
    checks whether the button text is changed to **Hide summary** and whether the
    summary disappears if we click on the button again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this test case, let’s start by defining the `it()` function and provide
    it with a description for the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the `it()` function has been defined and we have provided a fitting
    description, we need to add the testing logic inside the callback of the `it()`
    function. First, we need to get the button we used to toggle the summary. As mentioned
    before, you can get elements from within your application using `cy.get()`. You
    provide the `.get()` method with a query selector; these selectors work identically
    to jQuery selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, you can see we use `cy.get()` and provide it
    with the query selector to get the **Show summary** button. If you’re not familiar
    with jQuery selectors, you can alternatively copy the selector through the **DevTools**
    of the Chrome browser. Simply inspect the HTML page, find the element you want
    to use inside your Cypress test in your **DevTools**, right-click on the element,
    and select **Copy** | **Copy selector**. In *Figure 11**.3*, you can see where
    you can copy the selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: DevTools Copy selector](img/B21625_11_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: DevTools Copy selector'
  prefs: []
  type: TYPE_NORMAL
- en: 'The selectors copied using the **DevTools** always start at the root of your
    HTML document and can be simplified by removing the beginning of the selector.
    Now that you know how to select elements so you can use them within your tests,
    let’s write the rest of the test logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first define two constants, one for `button` and one
    for `summary`. As you can see, we use a function that returns the `cy.get()` method.
    Directly assigning the return value of `cy.get()` to a variable is an anti-pattern
    because you can modify the return value during your tests. Commonly, when you
    get the button, you want to get it unmodified, so we create a function that returns
    the `cy.get()` function call and assign that to our variables.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the two constants, we check whether the button contains the **Show
    summary** text and whether the summary element doesn’t exist yet. Afterward, we
    click the button and check whether the button text is changed to **Hide summary**
    and whether the summary element exists. Lastly, we click the button again and
    see if everything is toggled back to its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run your e2e tests now, you’ll find that the test succeeds. While there
    is nothing wrong with this test, there are some things we can do to clean it up
    a bit. First, we can simplify the selectors by adding a `data-test-id` attribute
    on the HTML elements we want to select. The `data-test-id` attribute is a simple
    HTML attribute commonly added to elements you want to use in your e2e tests. So,
    let’s add the attribute to the button and summary element inside your `expenses-overview-page.component.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '<td data-test-id attributes, you can simplify the selectors used inside your
    e2e test. Instead of the long selector used to select the button and summary elements,
    you can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this dramatically simplifies the selectors for your HTML elements.
    Besides simplifying the selectors by introducing the `data-test-id` attributes,
    you can create a function that checks the button text and checks whether the summary
    element exists. You don’t have to repeat it three times inside your test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined the logic for the test case, it’s time to improve
    it and move some logic to the page object file. Start by removing the `app.po.ts`
    file from the support folder and adding a `new expenses-overview.po.ts` file.
    As you might have figured out, the `.po.ts` is short for `.page-object.ts`. Inside
    the `expenses-overview.po.ts` file, you will define all the logic to get the elements
    needed for the e2e tests for the `expenses-overview` page. By abstracting the
    element selection to this page object file, you can easily reuse them, making
    your e2e tests smaller and easier to read, write, and maintain. Currently, we
    only have two elements we can move to the page object file—the summary button
    and the summary element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you can see that we moved the two constants defined
    inside the test case to the page object file and exported them so they can be
    accessed inside the e2e tests. We also gave the two constants a more descriptive
    name. Now, inside the `expenses-registration.cy.ts` file, import the two constants
    and adjust the e2e test to use the imported constants. If you now need the button
    or summary type in another e2e test, you can simply use the one defined inside
    the page object file instead of redefining the logic to get the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the page object file, we can also add the function to check the `toggle
    summary button` text and the visibility of the summary itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the preceding function, let’s update the e2e test to use the function
    and see the final result after adding the page object file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, now that we use the page object pattern,
    the test is much easier to understand and needs fewer lines of code; besides that,
    the code is easier to reuse in new test cases.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, you select elements using the `cy.get()` method combined with
    selectors identical to jQuery selectors. To simplify your selectors, you can use
    `data-test-id` attributes, and by using the page object pattern, you can abstract
    the element selection logic away from your test cases, making your tests easier
    to read, write, and maintain. Now that you have a better grasp of how to select
    elements and how the page object pattern can help you write better e2e tests,
    let’s learn how to intercept requests and use mock data from your fixtures inside
    your e2e tests.
  prefs: []
  type: TYPE_NORMAL
- en: Using fixtures in your e2e tests
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures are used to provide your e2e tests with specific mock data. Using mock
    data for your e2e tests ensures that you have stable data with which to run your
    e2e tests. Often, you need to run your e2e tests in an environment where you don’t
    have access to an API or mocking service; in this case, you can use the data defined
    in your fixtures. Another common scenario is that you run your e2e tests in your
    test or acceptance environment, and the data on these environments isn’t always
    stable and might change over time, resulting in failing tests. So, depending on
    your environment, fixtures can provide you with additional stability, ensuring
    that your tests don’t fail based on the data but only fail if you actually break
    something within your application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first run the e2e tests in production mode to demonstrate why you need
    fixtures. Our `mock.interceptor.ts` file will not return the mock data if we serve
    a production build of our application. You can use the following terminal command
    to run the e2e tests with a production build of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: After running the preceding command, you’ll notice the application doesn’t have
    any data to display during the e2e tests. For our current test cases, this is
    no issue, but when you have more tests, this will most likely result in some failing
    tests. Instead of relying on `mock.interceptor.ts`, we can use the fixtures to
    provide data during the e2e tests.
  prefs: []
  type: TYPE_NORMAL
- en: To use the data from your fixtures, you first need to add a file with mock data
    inside the `fixtures` folder. We will use the same mock data as we use for our
    mock interceptor, so start by copying the `expenses.json` file inside the `assets/api`
    folder from your *expenses-registration application* to the `fixtures` folder
    of your e2e project.
  prefs: []
  type: TYPE_NORMAL
- en: 'After copying the `expenses.json` file, you need to adjust the `beforeEach()`
    function inside the `expenses-registration.cy.ts` file. Inside the `beforeEach()`
    function, you need to set up an interceptor to intercept the API request we make
    to get the expenses and provide it with a file from your fixtures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see we set up the interceptor using the `cy.intercept()`
    method. The `cy.intercept()` method first takes a string to define what type of
    API request you want to intercept; in our case, we want to intercept a `GET` request.
    Next, you need to provide the API URL you want to intercept, and lastly, you need
    to provide an object with a fixture property assigned with the fixture file you
    want to use as a response for the intercepted request. At the end of the `cy.intercept()`
    method, we chain the `.as()` method and provide that with an alias for the interceptor;
    in this case, we used `getExpenses`.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up the interceptor, we define the `cy.visit()` method to visit
    the application page, just like we did before. After the `cy.visit()` method,
    we define the `cy.wait()` method, indicating that Cypress must wait for the interceptor
    we set up. Then, provide the `cy.wait()` method with the interceptor alias prefixed
    with an `@` sign.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding steps involve everything required to use the fixture file for
    your mock data during the e2e tests. If you need to set up the same interceptor
    and visit the same page for multiple testing files, you can abstract the logic
    away into a function and call that function inside the `beforeEach()` callback
    so that you don’t have to repeat yourself multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test whether the interceptor and fixture work by running the e2e tests
    in production using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: After running the preceding command, you’ll notice that the application shows
    data again when running the e2e tests.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, you learned that fixtures can be used to provide mock data during
    your e2e tests. Using mock data can provide your tests with additional stability
    and help you run them in an environment where you don’t have access to an API
    or mocking service. You use fixtures by setting up an interceptor in the `beforeEach()`
    function of your tests and providing the interceptor with the fixture file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about automated application testing. You learned
    that unit tests are used to test small code units in isolation to ensure the code
    implantation works as expected. e2e testing tests applications from the user’s
    perspective and checks whether the correct values are displayed and user interactions
    are processed and rendered correctly in the application view. Component testing
    is a relatively new concept, comparable to e2e testing, but instead of compiling
    and testing an entire application, component testing focuses on testing a single
    component from the perspective of a user. Lastly, integration tests are used to
    check how different modules and elements of your software integrate together.
    Integration tests can be implemented on various levels, for example, to check
    whether code implementation remains working when you combine multiple components
    and services or whether your application still works when you combine and deploy
    various Angular applications and backend APIs as a single product for your customers.
  prefs: []
  type: TYPE_NORMAL
- en: After learning about the different types of tests, you created your own unit
    and e2e tests. You learned about the `describe()`, `beforeEach()`, and `its()`
    functions and how they can be used for e2e and unit tests. You learned how to
    use mock data in e2e tests and stub components and services in your unit tests.
    Asserting values in unit tests is done using the `expect()` function, and in e2e
    tests, you use the `cy.should()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you learned about different terminal commands to run tests for individual
    files, single projects, multiple projects, or projects that are affected by your
    changes. In the next and final chapter of this book, you’ll add the finishing
    touches and learn about the different steps you need to take to deploy Angular
    applications in your Nx monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
