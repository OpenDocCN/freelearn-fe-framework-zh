<html><head></head><body>
		<div id="_idContainer021">
			<h1 id="_idParaDest-35"><em class="italic"><a id="_idTextAnchor055"/>Chapter 2</em>: Crafting States in Functions</h1>
			<p>In the previous chapter, we learned how to write function components in <em class="italic">React</em>. In this chapter, we will craft a special variable called a state in the function components. We will see what benefits a state can bring us, including requesting a new update, making a variable persistent, listening to a value change, as well as performing tasks upon the mount. We will also see an example of applying a state to a single-page application. In the end, we will look closely at what role the states play within the <em class="italic">UI</em>.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Crafting a state in a function component</li>
				<li>Applying states to single-page applications</li>
				<li>How states work with UIs</li>
				<li>Questions and answers</li>
			</ul>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor056"/>Technical requirements</h1>
			<p>Before beginning, I would like you to know about the timeline sketch:</p>
			<p class="source-code"><a id="_idTextAnchor057"/>|--x---x---x-x--x--x------&gt; user event</p>
			<p>The timeline sketch is a unique illustrative chart type that displays a series of events during a period. The left bar (<strong class="source-inline">|</strong>) stands for the time origin, representing the first update. The horizontal dash (<strong class="source-inline">-</strong>) moves with the time from left to right with an arrow <strong class="source-inline">&gt;</strong> at the end. Each letter or number, such as <strong class="source-inline">x</strong> , indicates one event that happened in this timeline. In this book, we will use the timeline sketch to better understand a situation when multiple things happen simultaneously along the timeline.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor058"/>Crafting a state in a function component</h1>
			<p>When you visit a typical web page, it asks for your username and password. After you log in, it displays<a id="_idIndexMarker055"/> the content of what the website provides, such<a id="_idIndexMarker056"/> as blogs, tweets, or videos, in a chronological order. You can vote on them and put your comments there – a very typical web experience these days.</p>
			<p>When you surf a website like that as a user, you don't put too much thought into how any of the actions are implemented, nor do you care about the order in which each is fired. However, when it comes to building the site yourself, each action and the time at which each gets fired starts to become important.</p>
			<p>An action handler fires when a user clicks a button, hovers over an icon, scrolls down a paragraph, types on the keyboard, and so on. A typical relationship between a user event and an action handler is illustrated in the following:</p>
			<p class="source-code">|--x---x---x-x--x--x------&gt; user event</p>
			<p class="source-code">|--a---a---a-a--a--a------&gt; action handler</p>
			<p>In the preceding sketch, basically, an <strong class="source-inline">x</strong> in the <strong class="source-inline">user event</strong> series is followed by an <strong class="source-inline">a</strong> in the <strong class="source-inline">user event</strong> series. Based on this, we can start to handle a user action. </p>
			<p>Let's turn ourselves to a "Hello World" <strong class="source-inline">Title</strong> component with a button inside. Each time we click the button, a counter gets incremented by one and appended after <strong class="bold">Hello World+</strong>, as shown in <em class="italic">Figure 2.1</em>:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/Figure_2.01_B17963.jpg" alt="Figure 2.1 – Hello World with no state&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Hello World with no state</p>
			<p>To implement that, we start with a <strong class="source-inline">count</strong> variable to store a number initialized as <strong class="source-inline">0</strong>:</p>
			<p class="source-code"><strong class="bold">function</strong> Title() {</p>
			<p class="source-code">  <strong class="bold">let</strong> count = 0  </p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    count = count + 1</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;button</strong> onClick={onClick}<strong class="bold">&gt;</strong>+<strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;h1&gt;</strong>Hello World+{count}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;/&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>In the preceding <strong class="source-inline">Title</strong> component, the response to the user click is implemented via a React event handler, <strong class="source-inline">onClick</strong>, wired to a <strong class="source-inline">button</strong> element.</p>
			<p>A <em class="italic">React</em> event handler is written slightly<a id="_idIndexMarker057"/> differently from a <em class="italic">DOM</em> event handler. You can tell<a id="_idIndexMarker058"/> from the <strong class="source-inline">onClick</strong> camel case name, rather than the <strong class="source-inline">onclick</strong> lowercase name. A <em class="italic">React</em> event is a synthetic event that is a cross-browser wrapper around the browser native event. In this book, we expect them to behave in exactly the same way.</p>
			<p>Thanks to the <em class="italic">JavaScript</em> closure, we can directly access any component variable inside the event handler. The <strong class="source-inline">count</strong> variable does not need to be passed into <strong class="source-inline">onClick</strong> as a function input argument to be accessed.</p>
			<p>If we run the code, we'd expect the title to display <strong class="bold">Hello World+1</strong> after we click the button. But to our surprise, no matter how many times we clicked the button, it still displayed <strong class="bold">Hello World+0</strong>. To figure out what happened, let's add <strong class="source-inline">console.log</strong> to two locations. </p>
			<p>One is placed before <strong class="source-inline">count = count + 1</strong> to confirm what the <strong class="source-inline">count</strong> is after incrementation. Another one is placed before the <strong class="source-inline">return</strong> statement to confirm what the updated <strong class="source-inline">count</strong> is when the <strong class="source-inline">Title</strong> component is updated. They are marked at <span class="Unnamed-Style-1">➀</span> and ➁ in the following code:</p>
			<p class="source-code"><strong class="bold">function</strong> Title() {</p>
			<p class="source-code">  <strong class="bold">let</strong> count = 0</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    console.log('clicked', count)      ➀</p>
			<p class="source-code">    count = count + 1</p>
			<p class="source-code">  }</p>
			<p class="source-code">  console.log('updated', count)        ➁</p>
			<p class="source-code">  <strong class="bold">return</strong> ...</p>
			<p class="source-code">}</p>
			<p>With these two logs placed, we can rerun the code and generate a new timeline sketch:</p>
			<p class="source-code">|----0--1-2--3-4----5------&gt; clicked   ➀</p>
			<p class="source-code">0--------------------------&gt; updated   ➁</p>
			<p>From the preceding printout, a <strong class="source-inline">clicked</strong> series at ➀ showed the <strong class="source-inline">count</strong> number when the button was clicked, and it was clicked<a id="_idIndexMarker059"/> six times. Let's turn to another log, the <strong class="source-inline">updated</strong> series at ➁; the <strong class="source-inline">count</strong> value got updated once as <strong class="source-inline">0</strong>, which explains<a id="_idIndexMarker060"/> why the display remained as <strong class="source-inline">Hello World+0</strong>.</p>
			<p>The <strong class="source-inline">updated</strong> series with only one printout at the very beginning indicates that there weren't any more updates after the first one. This is quite a discovery. If there were no more updates, how can we expect to see a change on the screen?</p>
			<p class="callout-heading">Playground – No State</p>
			<p class="callout">Feel free to play with this example online at <a href="https://codepen.io/windmaomao/pen/jOLNXzO">https://codepen.io/windmaomao/pen/jOLNXzO</a>. </p>
			<p>As you might already realize, we need to request a new update after the cl<a id="_idTextAnchor059"/>ick.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor060"/>Requesting a new update</h2>
			<p>To make an update, for the time<a id="_idIndexMarker061"/> being, we can borrow the <strong class="source-inline">render</strong> function provided by <em class="italic">React</em>, as we have already used it to update the <strong class="source-inline">rootEl</strong> element:</p>
			<p class="source-code">ReactDOM.render(&lt;Title /&gt;, rootEl)</p>
			<p>Let's take a minute to see how <em class="italic">React</em> updates the screen in general (see <em class="italic">Figure 2.2</em>). The detail involving updates can be quite complex; for now, let's treat it as a black box. We will get into more details later in the book:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/Figure_2.02_B17963.jpg" alt="Figure 2.2 – React update&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – React update</p>
			<p>When an app<a id="_idIndexMarker062"/> starts, it lands on an update. This first update is a bit special. Because all the DOM elements need to be created, we refer to this update as a mount. </p>
			<p>What's important to know is that a new update wouldn't arrive unless it's requested, just as we invoke a <strong class="source-inline">render</strong> function. When people first come to React, they might think it works as a game engine.</p>
			<p>For instance, a game engine would request a new update every 1/60 second behind the scenes. But <em class="italic">React</em> does not do that! Instead, the developer should get precise control of when a new update is requested. And most of the time, the frequency is a lot lower than 1/60 second, and it's more or less driven by how fast a user acts on the website.</p>
			<p>So with this, to bring the new <strong class="source-inline">count</strong> to the screen, another update needs to be requested manually; if we borrow the <strong class="source-inline">render</strong>, we can use it after the <strong class="source-inline">count</strong> is incremented:</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    console.log('clicked', count)      ➀</p>
			<p class="source-code">    count = count + 1</p>
			<p class="source-code">    ReactDOM.render(&lt;Title /&gt;, rootEl)</p>
			<p class="source-code">  }</p>
			<p>If we run the preceding code with the addition of <strong class="source-inline">render</strong>, the timeline sketch changes to the following:</p>
			<p class="source-code">|----0--0-0--0-0----0------&gt; clicked   ➀</p>
			<p class="source-code">0----0--0-0--0-0----0------&gt; updated   ➁</p>
			<p>To our surprise, all numbers<a id="_idIndexMarker063"/> displayed were <strong class="source-inline">0</strong>. Looking at the <strong class="source-inline">updated</strong> series at <strong class="source-inline">➁</strong>, note we got seven printouts, which means we got six more updates on top of the first update. However, the <strong class="source-inline">clicked</strong> series at <strong class="source-inline">➀</strong> shows that the <strong class="source-inline">count</strong> value changed to <strong class="source-inline">0</strong> and stopped to increment any more. Weird?!</p>
			<p>How could the <strong class="source-inline">count</strong> value be stuck at <strong class="source-inline">0</strong>? Something must happen to the new update, but the <strong class="source-inline">render</strong> function can't be the one that resets the <strong class="source-inline">count</strong> value back to <strong class="source-inline">0</strong>, can it?</p>
			<p>It's important to know that upon the <strong class="source-inline">render</strong> function being called and a function component being updated, the function that defines the component gets invoked, as shown in <em class="italic">Figure 2.3</em>:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/Figure_2.03_B17963.jpg" alt="Figure 2.3 – React render for a function component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – React render for a function component</p>
			<p>With this knowledge, let's take a look at the <strong class="source-inline">Title</strong> function again:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">let</strong> count = 0</p>
			<p class="source-code">  // omitting the onClick statement</p>
			<p class="source-code">  console.log('updated', count)       ➁</p>
			<p class="source-code">  // omitting the return statement</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we intentionally omit the <strong class="source-inline">onClick</strong> and <strong class="source-inline">return</strong> statements to make the code a bit cleaner. What was left became a <strong class="source-inline">let count = 0</strong> declaration statement. During each update, the <strong class="source-inline">Title</strong> function gets invoked, thus creating a new scope of the function. Inside this scope, there's a variable <strong class="source-inline">count</strong> value created locally to hold a <strong class="source-inline">0</strong> number. So this code doesn't seem to do much. </p>
			<p>It's not too difficult<a id="_idIndexMarker064"/> to see now why the <strong class="source-inline">count</strong> value remains at <strong class="source-inline">0</strong>, isn't it? It doesn't really matter if we have added the increment logic <strong class="source-inline">onClick</strong> or <strong class="source-inline">return</strong> statement. Upon each update, the entire function scope gets a new one with a <strong class="source-inline">count</strong> value declared and set to <strong class="source-inline">0</strong>. That explains why the <strong class="source-inline">console.log</strong> statement followed a printed <strong class="source-inline">0</strong>.</p>
			<p>This is actually the reason why a function component was named as a stateless function when it was introduced to <em class="italic">React</em> initially. "Stateless" refers to the fact that<a id="_idIndexMarker065"/> a function component can't carry or share a value to another update. In a simple word, the function reruns in each update with the same output.</p>
			<p>Okay, now we understand the problem. So, it makes us consider saving the <strong class="source-inline">count</strong> value somewhere and making it persistent for another u<a id="_idTextAnchor061"/>pdate. </p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor062"/>Making a value persistent</h2>
			<p><em class="italic">JavaScript</em> supports a function scope: Variables defined inside a function cannot be accessed from anywhere<a id="_idIndexMarker066"/> outside the function, thus each function has its own scope. If you invoke a function multiple times, there'll be multiple scopes. But no matter how many times we invoke it, it wouldn't create a different output, such as what happened in the movie <em class="italic">Groundhog Day</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The movie <em class="italic">Groundhog Day</em> is a 1993 fantasy comedy film, where Phil wakes up every day to find he experiences the previous day's events repeating exactly and believes he is experiencing déjà vu.</p>
			<p>For our <strong class="source-inline">count</strong> value, we can visualize<a id="_idIndexMarker067"/> what happened with the two updates in two different scopes in <em class="italic">Figure 2.4</em>: </p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_2.04_B17963.jpg" alt="Figure 2.4 – Two function scopes for the two updates&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Two function scopes for the two updates</p>
			<p>Luckily, <em class="italic">JavaScript</em> supports a function scope in a way that it can access all variables defined inside the scope in which it is defined. In our case, if a variable is defined outside of the <strong class="source-inline">Title</strong> function, we can access this variable inside the <strong class="source-inline">Title</strong> functions, as this value is shared now between multiple <strong class="source-inline">Title</strong> functions.</p>
			<p>The easiest way of sharing is to create a global variable because the global variable lives in the most outer scope of the <em class="italic">JavaScript</em> code, thus it can be accessed inside any function. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Don't be intimidated by a global variable used in this chapter. In <a href="B17963_03_Epub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Hooking into React</em>, we will refine this approach and see how <em class="italic">React</em> defines the variable in a better location.</p>
			<p>This way, each local <strong class="source-inline">count</strong> value can set/get this global <strong class="source-inline">count</strong> value, as shown in <em class="italic">Figure 2.5</em>:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_2.05_B17963.jpg" alt="Figure 2.5 – A shared value among the two updates&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – A shared value among the two updates</p>
			<p>Okay, with this new global variable<a id="_idIndexMarker068"/> idea, let's see whether we can break out of our <em class="italic">Groundhog Day</em> situation:</p>
			<p class="source-code"><strong class="bold">let</strong> m = <strong class="bold">undefined</strong></p>
			<p class="source-code"><strong class="bold">function</strong> _getM(initialValue) {</p>
			<p class="source-code">  <strong class="bold">if</strong> (m === <strong class="bold">undefined</strong>) {</p>
			<p class="source-code">    m = initialValue</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return</strong> m</p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">function</strong> _setM(value) { </p>
			<p class="source-code">  m = value</p>
			<p class="source-code">  ReactDOM.render(&lt;Title /&gt;, rootEl)</p>
			<p class="source-code">}</p>
			<p>In the preceding code, a global variable, <strong class="source-inline">m</strong>, is allocated, and it comes with <strong class="source-inline">_getM</strong> getter and <strong class="source-inline">_setM</strong> setter methods. The <strong class="source-inline">_getM</strong> function returns the value but sets the initial value for the first time. The <strong class="source-inline">_setM</strong> function sets the value and requests a new update. Let's apply <strong class="source-inline">_getM</strong> and <strong class="source-inline">_setM</strong> to our <strong class="source-inline">Title</strong> component:</p>
			<p class="source-code"><strong class="bold">function</strong> Title() {</p>
			<p class="source-code">  <strong class="bold">let</strong> count = _getM(0) </p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    console.log('clicked', count)      ➀</p>
			<p class="source-code">    count = count + 1</p>
			<p class="source-code">    _setM(count)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  console.log('updated', count)         ➁</p>
			<p class="source-code">  <strong class="bold">return</strong> ...</p>
			<p class="source-code">}</p>
			<p>Inside the preceding amended <strong class="source-inline">Title</strong> component, all <strong class="source-inline">count</strong> variables across updates are linked with<a id="_idIndexMarker069"/> the help of <strong class="source-inline">_getM</strong> and <strong class="source-inline">_setM</strong>. If we rerun the code, we can see the following timeline sketch:</p>
			<p class="source-code">|----0--1-2--3-4----5------&gt; clicked   ➀</p>
			<p class="source-code">0----1--2-3--4-5----6------&gt; updated   ➁</p>
			<p>Wow! The screen changes to <strong class="source-inline">Hello World+1</strong> upon the first click and increments further upon more clicks, as shown in Figure 2.6:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_2.06_B17963.jpg" alt="Figure 2.6 – Hello World counter using a state&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – Hello World counter using a state</p>
			<p>Congratulations! You just crafted a state inside a function component. </p>
			<p class="callout-heading">Playground – Count State</p>
			<p class="callout">Feel free to play with this example online at <a href="https://codepen.io/windmaomao/pen/KKvPJdg">https://codepen.io/windmaomao/pen/KKvPJdg</a>.</p>
			<p>The word "state" refers to the fact that it's persisted<a id="_idIndexMarker070"/> for all updates. For our convenience, we also change the state and request a new update afterward to reflect the change to the screen.</p>
			<p>So, now we know<a id="_idIndexMarker071"/> how to handle a user action with a state. Let's see whether we can expand this idea further to support multiple states instead of <a id="_idTextAnchor063"/>one state.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor064"/>Support multiple states</h2>
			<p>It's great that we<a id="_idIndexMarker072"/> can establish a state persistent within a function component. But we want more states like that. An app normally contains lots of buttons, switches, and actionable items; each requires a state to be persistent. So, it's a must-have to support multiple states in the same app.</p>
			<p>So, say we need two buttons and each needs to be driven by a state. Let's extend what we have learned from a single state:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">let</strong> countH = _getM(0)</p>
			<p class="source-code">  <strong class="bold">let</strong> countW = _getM(0)</p>
			<p class="source-code">  <strong class="bold">const</strong> onClickH = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    countH = countH + 1</p>
			<p class="source-code">    _setM(countH)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">const</strong> onClickW = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    countW = countW + 1</p>
			<p class="source-code">    _setM(countW)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;button</strong> onClick={onClickH}<strong class="bold">&gt;</strong>+<strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;h1&gt;</strong>Hello+{countH}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;button</strong> onClick={onClickW}<strong class="bold">&gt;</strong>+<strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;h1&gt;</strong>World+{countW}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;/&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we first created two buttons, one with a <strong class="bold">Hello</strong> label and one with a <strong class="bold">World</strong> label, and each have their separate event handler, <strong class="source-inline">onC1ickH</strong> and <strong class="source-inline">onClickW</strong> respectively. Also, we applied <strong class="source-inline">_getM</strong> and <strong class="source-inline">_setM</strong> to both of them, and installed a couple of logs to help the debug, as shown in the following timeline sketch:</p>
			<p class="source-code">|----0--1-2----------------&gt; clickedH   </p>
			<p class="source-code">|------------3-4----5------&gt; clickedW   </p>
			<p class="source-code">0----1--2-3--4-5----6------&gt; updatedH   </p>
			<p class="source-code">0----1--2-3--4-5----6------&gt; updatedW   </p>
			<p>From the preceding<a id="_idIndexMarker073"/> sketch, we clicked the <strong class="bold">Hello</strong> button three times and then clicked the <strong class="bold">World</strong> button three times. The numbers corresponding to both buttons all updated upon clicking, as shown in the <strong class="source-inline">updatedH</strong> and <strong class="source-inline">updatedW</strong> series. However, the two series seem to be inseparable and in sync, meaning clicking one button would increment both values at the same time!</p>
			<p class="callout-heading">Playground – Linked States</p>
			<p class="callout">Feel free to play with this example online at <a href="https://codepen.io/windmaomao/pen/qBXWgay">https://codepen.io/windmaomao/pen/qBXWgay</a>.</p>
			<p>Okay, it's not too difficult to find out that we actually made a mistake by wiring the same state to both buttons; no wonder they updated at the same time:</p>
			<p class="source-code">  <strong class="bold">let</strong> countH = _getM(0)</p>
			<p class="source-code">  <strong class="bold">let</strong> countW = _getM(0)</p>
			<p>Although this is not what we wanted to achieve, it's interesting to see that a state is shared by two buttons. Visually, we linked two buttons; clicking one triggers the click on another.</p>
			<p>So, what can we do if we want to have two separate states with each controlling one button? Well, we can just add another state. This time, we want to be a bit more generic in using a list to hold any number of states.</p>
			<p>There are lots of ways<a id="_idIndexMarker074"/> to keep track of a list of values in <em class="italic">JavaScript</em>; one of the ways is to use a key/value pair, as in an object:</p>
			<p class="source-code"><strong class="bold">let</strong> states = {}</p>
			<p class="source-code"><strong class="bold">function</strong> _getM2(initialValue, key) {</p>
			<p class="source-code">  <strong class="bold">if</strong> (states[key] === <strong class="bold">undefined</strong>) {</p>
			<p class="source-code">    states[key] = initialValue</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return</strong> states[key]</p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">function</strong> _setM2(v, key) {</p>
			<p class="source-code">  states[key] = v</p>
			<p class="source-code">  ReactDOM.render(&lt;Title /&gt;, rootEl)</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we declare a <strong class="source-inline">states</strong> object to store all state values. The <strong class="source-inline">_getM2</strong> and <strong class="source-inline">_setM2</strong> functions are almost similar to the single-value version we crafted earlier, except this time we store each state under <strong class="source-inline">states[key]</strong> instead of <strong class="source-inline">m</strong>, thus a <strong class="source-inline">key</strong> is needed to identify each state. With this change, let's amend the <strong class="source-inline">Title</strong> component:</p>
			<p class="source-code"><strong class="bold">function</strong> Title() {</p>
			<p class="source-code">  <strong class="bold">let</strong> countH = _getM2(0, 'H')</p>
			<p class="source-code">  <strong class="bold">let</strong> countW = _getM2(0, 'W')</p>
			<p class="source-code">  <strong class="bold">const</strong> onClickH = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    console.log('clickedH', countH)     </p>
			<p class="source-code">    countH = countH + 1</p>
			<p class="source-code">    _setM2(countH, 'H')</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">const</strong> onClickW = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    console.log('clickedW', countW)     </p>
			<p class="source-code">    countW = countW + 1</p>
			<p class="source-code">    _setM2(countW, 'W')</p>
			<p class="source-code">  }</p>
			<p class="source-code">  console.log('updatedH', countH)         </p>
			<p class="source-code">  console.log('updatedW', countW)          </p>
			<p class="source-code">  <strong class="bold">return</strong> ...</p>
			<p class="source-code">}</p>
			<p>In the preceding amended version, we give<a id="_idIndexMarker075"/> a key to two states as <strong class="source-inline">H</strong> and <strong class="source-inline">W</strong>. We need this key for both <strong class="source-inline">set</strong> and <strong class="source-inline">get</strong> when a state is involved. Rerun the code and take a look at the timeline sketch:</p>
			<p class="source-code">|----0--1-2----------------&gt; clickedH  </p>
			<p class="source-code">|------------0-1----2------&gt; clickedW  </p>
			<p class="source-code">0----1--2-3--3-3----3------&gt; updatedH  </p>
			<p class="source-code">0----0--0-0--1-2----3------&gt; updatedW  </p>
			<p>Once again, we clicked the <strong class="bold">Hello</strong> button three times and <strong class="bold">World</strong> button three times in a row. The numbers on both buttons all updated upon clicking, but this time, <strong class="source-inline">countH</strong> and <strong class="source-inline">countW</strong> are actually incremented separately, as you can see in the <strong class="source-inline">updatedH</strong> and <strong class="source-inline">updatedW</strong> series. </p>
			<p>After the first three clicks on the <strong class="bold">Hello</strong> button, <strong class="source-inline">countH</strong> stays at <strong class="source-inline">3</strong> when we click on the <strong class="bold">World</strong> button. This is what we want to have, two separate states, as shown in <em class="italic">Figure 2.7</em>:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_2.07_B17963.jpg" alt="Figure 2.7 – Hello and World buttons with two states&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Hello and World buttons with two states</p>
			<p class="callout-heading">Playground – Multiple States</p>
			<p class="callout">Feel free to play with this example online at <a href="https://codepen.io/windmaomao/pen/dyzbaVr">https://codepen.io/windmaomao/pen/dyzbaVr</a>.</p>
			<p>The state we crafted<a id="_idIndexMarker076"/> so far requests a new update. This is a very good use of persistency in a function component; since being persistent is actually quite a generic feature, it should be utilized for many different purposes. So, what other things can we do with it? Let's take a look at another usa<a id="_idTextAnchor065"/>ge of a state.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor066"/>Listen to a value change</h2>
			<p>You might wonder why we need to listen to a value change. Aren't the developers the ones who control the change<a id="_idIndexMarker077"/> of a value? As in the previous example, we use the event handler to change a counter. We know in this case exactly when the value gets changed.</p>
			<p>That's true for this case, but there are other cases. You might send a value into a child component via a prop, or there might be two components that touch a value at the same time. In either of these cases, you can lose track of the moment when the value is changed, but you still want to perform an action upon the value change. This means that you want to have the ability to listen to a value change. Let's set up one example to demonstrate this.</p>
			<p>Say in our <strong class="bold">Hello World</strong> button example that for any <strong class="source-inline">count</strong> change, we want to know whether this value has recently been changed: </p>
			<p class="source-code"><strong class="bold">function</strong> Changed({ count }) {</p>
			<p class="source-code">  <strong class="bold">let</strong> flag = 'N'</p>
			<p class="source-code">  <strong class="bold">return &lt;span&gt;</strong>{flag}<strong class="bold">&lt;/span&gt;</strong></p>
			<p class="source-code">}</p>
			<p>In the preceding <strong class="source-inline">Changed</strong> component, there's a <strong class="source-inline">count</strong> prop that is sent from its parent, say any of the <strong class="bold">Hello</strong> or <strong class="bold">World</strong> buttons that we built earlier. We want to display <strong class="source-inline">Y</strong> or <strong class="source-inline">N</strong>, depending on whether the <strong class="source-inline">count</strong> value has changed. We can use this <strong class="source-inline">Changed</strong> component in the <strong class="source-inline">Title</strong> component:</p>
			<p class="source-code"><strong class="bold">function</strong> Title() {</p>
			<p class="source-code">  ...</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;button</strong> onClick={onClickH}<strong class="bold">&gt;</strong>+<strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;h1&gt;</strong>Hello+{countH}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">      &lt;Changed count={countH} /&gt;</p>
			<p class="source-code">      <strong class="bold">&lt;button</strong> onClick={onClickW}<strong class="bold">&gt;</strong>+<strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;h1&gt;</strong>World+{countW}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;/&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>Note that in the preceding<a id="_idIndexMarker078"/> code, we add the <strong class="source-inline">Changed</strong> component between two buttons, and what we want to see is the <strong class="source-inline">Changed</strong> component display <strong class="source-inline">Y</strong> when we click the <strong class="bold">Hello</strong> button, and the <strong class="source-inline">Changed</strong> component display <strong class="source-inline">N</strong> when we click on the <strong class="bold">World</strong> button. Essentially, we want to know whether the change is coming from the <strong class="bold">Hello</strong> button or not. But when we ran the code, here's what we got in the timeline sketch:</p>
			<p class="source-code">0----1--2-3--3-3----3------&gt; updatedH   </p>
			<p class="source-code">0----0--0-0--1-2----3------&gt; updatedW   </p>
			<p class="source-code">N----N--N-N--N-N----N------&gt; Changed flag</p>
			<p>From the preceding sketch, you can see that no matter which button is clicked, the <strong class="source-inline">flag</strong> in the <strong class="source-inline">Changed flag</strong> series displayed <strong class="source-inline">N</strong>. This comes as no surprise, since you might have already noticed that the <strong class="source-inline">flag</strong> inside the <strong class="source-inline">Changed</strong> component is fixed at <strong class="source-inline">N</strong>, so it wouldn't work<a id="_idIndexMarker079"/> the way we wanted. But the reason we wrote <strong class="source-inline">N</strong> there is because we don't know what to write there to flip the <strong class="source-inline">flag</strong>. </p>
			<p>When the <strong class="bold">Hello</strong> button gets clicked three times, the <strong class="source-inline">countH</strong> value, as in the <strong class="source-inline">updatedH</strong> series, increments to <strong class="source-inline">3</strong>. Similarly, when the <strong class="bold">World</strong> button gets the next three clicks, the <strong class="source-inline">countW</strong> value, as in the <strong class="source-inline">updatedW</strong> series, increments to <strong class="source-inline">3</strong>. However, note that as the <strong class="source-inline">countW</strong> value increments, the <strong class="source-inline">countH</strong> value also gets printed out; see <strong class="source-inline">3-3-3</strong> in the <strong class="source-inline">updatedH</strong> series.</p>
			<p>This indicates that for each update, every element under the <strong class="source-inline">return</strong> statement gets updated. Either <strong class="source-inline">countW</strong> or <strong class="source-inline">countH</strong> changes; it comes to a new update of the <strong class="source-inline">Title</strong> component, thus updating all <strong class="source-inline">button</strong> and <strong class="source-inline">h1</strong> elements. The same applies to the <strong class="source-inline">Changed</strong> component; whichever button changes, the <strong class="source-inline">Changed</strong> function gets invoked. Therefore, we can't tell whether the update to the <strong class="source-inline">Changed</strong> component is due to the <strong class="bold">Hello</strong> button or the <strong class="bold">World</strong> button. </p>
			<p>If we print out the <strong class="source-inline">count</strong> prop under the <strong class="source-inline">Changed</strong> component, it will look the same as in the <strong class="source-inline">updatedH</strong> series:</p>
			<p class="source-code">0----1--2-3--3-3----3------&gt; count</p>
			<p>Looking at the preceding <strong class="source-inline">count</strong> value, in order to come up with the changed <strong class="source-inline">flag</strong> for whether it changes from the previous value, we need to make a value persistent again – in this case, to get hold of the previous value. For example, <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> is a change, but <strong class="source-inline">3</strong> to <strong class="source-inline">3</strong> isn't. </p>
			<p>Okay, to put this idea to work, let's borrow the state approach but this time apply it to a <strong class="source-inline">prev</strong> value:</p>
			<p class="source-code"><strong class="bold">let</strong> prev</p>
			<p class="source-code"><strong class="bold">function</strong> _onM(callback, value) {</p>
			<p class="source-code">  <strong class="bold">if</strong> (value === prev) <strong class="bold">return</strong> </p>
			<p class="source-code">  callback()</p>
			<p class="source-code">  prev = value</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we allocated a <strong class="source-inline">prev</strong> global variable and a <strong class="source-inline">_onM</strong> utility function. The <strong class="source-inline">onM</strong> function is designed to run a <strong class="source-inline">callback</strong> function when the <strong class="source-inline">value</strong> changes. It first checks whether<a id="_idIndexMarker080"/> the <strong class="source-inline">value</strong> is equal to the <strong class="source-inline">prev</strong> value. It returns if there's no change. But if there is, the <strong class="source-inline">callback</strong> function is then invoked, and the current <strong class="source-inline">value</strong> replaces the <strong class="source-inline">prev</strong> value. Let's apply this <strong class="source-inline">_onM</strong> function to the <strong class="source-inline">Changed</strong> component:</p>
			<p class="source-code"><strong class="bold">function</strong> Changed({ count }) {</p>
			<p class="source-code">  <strong class="bold">let</strong> flag = 'N'</p>
			<p class="source-code">  _onM(() <strong class="bold">=&gt;</strong> { flag = 'Y' }, count)</p>
			<p class="source-code">  <strong class="bold">return &lt;span&gt;</strong>{flag}<strong class="bold">&lt;/span&gt;</strong></p>
			<p class="source-code">}</p>
			<p>With the preceding change, we rerun the code and take a look at the updated timeline sketch:</p>
			<p class="source-code">0----1--2-3--3-3----3------&gt; updatedH </p>
			<p class="source-code">0----0--0-0--1-2----3------&gt; updatedW </p>
			<p class="source-code">Y----Y--Y-Y--N-N----N------&gt; Changed flag</p>
			<p>Interestingly enough, when we clicked the <strong class="bold">Hello</strong> button this time, it displayed <strong class="source-inline">Y</strong>, and when we clicked the <strong class="bold">World</strong> button afterward, it changed to <strong class="source-inline">N</strong>, as shown in <em class="italic">Figure 2.8</em>: </p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_2.08_B17963.jpg" alt="Figure 2.8 – Listen to value change&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – Listen to value change</p>
			<p>Wonderful! Also, notice the first <strong class="source-inline">Y</strong> at the mount in the <strong class="source-inline">Changed flag</strong> series, which is when <strong class="source-inline">countH</strong> changes from <strong class="source-inline">undefined</strong> to <strong class="source-inline">0</strong>. Please make a note here; we'll talk about it in the next section.</p>
			<p class="callout-heading">Playground – Listening to State Change</p>
			<p class="callout">Feel free to play with this example online at <a href="https://codepen.io/windmaomao/pen/MWvgxLR">https://codepen.io/windmaomao/pen/MWvgxLR</a>.</p>
			<p>Being able to listen to a value change is quite useful because it provides us with another way to perform tasks. Without it, we have to rely on an event handler, which is mostly driven by user actions. With <strong class="source-inline">_onM</strong>, we can perform a task upon a value change, which can come out of any other process.</p>
			<p>When listening<a id="_idIndexMarker081"/> to a value change, there exists a moment at the mount. This means that we can perform a task at the mount because of it. Let's take a look a<a id="_idTextAnchor067"/>t it more closely.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor068"/>Performing a task at the mount</h2>
			<p>Components mount<a id="_idIndexMarker082"/> and un-mount as things show up and disappear based on the business requirement. At the mount, it's common to want to perform a task such as initializing some variables, calculating some formulas, or fetching an <em class="italic">API</em> to get some resources over the internet. Let's use an <em class="italic">API</em> call as an example.</p>
			<p>Say a <strong class="source-inline">count</strong> value needs to be fetched from an online service called <strong class="source-inline">/giveMeANumber</strong>. When this fetch returns successfully, we would like to reflect the change to the screen:</p>
			<p class="source-code">fetch('/giveMeANumber').then(res <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  ReactDOM.render(&lt;Title /&gt;, rootEl)</p>
			<p class="source-code">})</p>
			<p>The preceding code is what we'd like to do; however, we run into a technical issue right away. Though a new update can be requested, how can we send the returned data to the <strong class="source-inline">Title</strong> component?</p>
			<p>Maybe we can set up a prop on the <strong class="source-inline">Title</strong> component to send it in. However, doing that would require us to change the component interface. Since we already have had states crafted to issue a new update, let's try that approach:</p>
			<p class="source-code">fetch('./giveMeANumber').then(res <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  _setM(res.data)</p>
			<p class="source-code">})</p>
			<p class="source-code"><strong class="bold">function</strong> Title() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> count = _getM("")    </p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>{count}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>In the preceding code, by using <strong class="source-inline">_setM</strong> after the fetch returns, we can update a state with the received <strong class="source-inline">res.data</strong> and request a new update afterward. The new update invokes <strong class="source-inline">Title</strong> and reads the latest <strong class="source-inline">count</strong> from the state via <strong class="source-inline">_getM</strong>.</p>
			<p>Currently, we define the <strong class="source-inline">fetch</strong> function parallel to the <strong class="source-inline">Title</strong> component, but this is not the right location since we want to fetch only at the mount. To fix that, we can listen to the mount, as we have learned in the previous section:</p>
			<p class="source-code"> _onM(() <strong class="bold">=&gt;</strong> { ... }, 0)</p>
			<p>Using the preceding<a id="_idIndexMarker083"/> line, we can listen for a mount moment. Note that we watched a constant <strong class="source-inline">0</strong> instead of any variable. During the mount, the value that <strong class="source-inline">_onM</strong> listens to changes from <strong class="source-inline">undefined</strong> to <strong class="source-inline">0</strong>, but for other future updates, the value stays at <strong class="source-inline">0</strong>; therefore, the <strong class="source-inline">...</strong> callback gets invoked only once at the mount. Let's write <strong class="source-inline">fetch</strong> inside this callback:</p>
			<p class="source-code"><strong class="bold">function</strong> Title() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> count = _getM(0)</p>
			<p class="source-code">  _onM(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">     fetch('./giveMeANumber').then(res <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">       _setM(res.data)</p>
			<p class="source-code">     })</p>
			<p class="source-code">  }, 0) </p>
			<p class="source-code">  console.log('u')</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>{count}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>If we run the preceding code, the timeline sketch should generate the following:</p>
			<p class="source-code">u-----u-------------------&gt; log</p>
			<p>At the mount of the <strong class="source-inline">Title</strong> component, the <strong class="source-inline">count</strong> state is set to be <strong class="source-inline">0</strong> initially. A <strong class="source-inline">fetch</strong> function is performed right away, depicted as the first <strong class="source-inline">u</strong> in the preceding <strong class="source-inline">updates</strong> series. Only when <strong class="source-inline">fetch</strong> returns successfully does the <strong class="source-inline">count</strong> state get updated to a new value and refreshed to the screen. The new update is depicted as the second <strong class="source-inline">u</strong> in the <strong class="source-inline">updates</strong> series.</p>
			<p class="callout-heading">Playground – Task at Mount</p>
			<p class="callout">Feel free to play with this example online at <a href="https://codepen.io/windmaomao/pen/PoKobVZ">https://codepen.io/windmaomao/pen/PoKobVZ</a>.</p>
			<p>Between the first<a id="_idIndexMarker084"/> and the second update, that's how long it takes for the API to finish. The relationship between the API, the state, and two updates is illustrated in <em class="italic">Figure 2.9</em>. Essentially, after the API returns, it communicates to the shared state where the new update picks up later:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_2.09_B17963.jpg" alt="Figure 2.9 – Fetch API within the stateful component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – Fetch API within the stateful component</p>
			<p>Now that we have crafted a state, and also seen how flexible a state can be used to either make a new update or listen to a value change, let's get hands-on and apply what we hav<a id="_idTextAnchor069"/>e learned to an app.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor070"/>Applying states to single-page application</h1>
			<p>We want to continue<a id="_idIndexMarker085"/> what we started in the previous chapter in building<a id="_idIndexMarker086"/> a single-page application. We couldn't finish it back then because we lacked a way to switch to a different page other than the home page. We had put together a <strong class="source-inline">Nav</strong> component:</p>
			<p class="source-code"><strong class="bold">const</strong> Nav = ({ items, selected }) <strong class="bold">=&gt;</strong> { ... }</p>
			<p>Given a list of pages, the <strong class="source-inline">Nav</strong> component displays them as links to navigate. The currently <strong class="source-inline">selected</strong> page needs to be provided as well. Now that we know how to define a state, let's use it to keep track of the <strong class="source-inline">selected</strong> page:</p>
			<p class="source-code"><strong class="bold">const</strong> App = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> selected = _getM("home") </p>
			<p class="source-code">  <strong class="bold">return</strong> ( </p>
			<p class="source-code">    <strong class="bold">&lt;div&gt;</strong></p>
			<p class="source-code">      &lt;Nav</p>
			<p class="source-code">        items={menus}</p>
			<p class="source-code">        selected={selected}</p>
			<p class="source-code">        onSelect={_setM}</p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">      ...</p>
			<p class="source-code">    <strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>In the preceding <strong class="source-inline">App</strong> component, we used<a id="_idIndexMarker087"/> a state for <strong class="source-inline">selected</strong> to hold the <strong class="source-inline">home</strong> key initially, which is then passed into the <strong class="source-inline">Nav</strong> component. To allow the state<a id="_idIndexMarker088"/> to be updated after a user click, we need to modify <strong class="source-inline">Nav</strong> by adding the support of an <strong class="source-inline">onSelect</strong> callback function:</p>
			<p class="source-code"><strong class="bold">const</strong> Nav = ({ items, selected, onSelect }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> isActive = item <strong class="bold">=&gt;</strong> item.key === selected</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = item <strong class="bold">=&gt;</strong> () <strong class="bold">=&gt;</strong> { </p>
			<p class="source-code">    onSelect(item.key)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  ...</p>
			<p class="source-code">}</p>
			<p>In the preceding amended <strong class="source-inline">Nav</strong> component, an <strong class="source-inline">onSelect</strong> prop is passed so that after <strong class="source-inline">onClick</strong>, the parent <strong class="source-inline">App</strong> component can be notified to update the <strong class="source-inline">selected</strong> page via the <strong class="source-inline">_setM</strong> function.</p>
			<p>To confirm that the user does reach<a id="_idIndexMarker089"/> a different page, based on the current selected<a id="_idIndexMarker090"/> page, we can use a <strong class="source-inline">Route</strong> component to switch between page content:</p>
			<p class="source-code"><strong class="bold">const</strong> Route = ({ selected }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">     <strong class="bold">return</strong> (</p>
			<p class="source-code">       <strong class="bold">&lt;div&gt;</strong></p>
			<p class="source-code">      {selected === 'home' &amp;&amp; &lt;Home /&gt;}</p>
			<p class="source-code">      {selected === 'product' &amp;&amp; &lt;Product /&gt;}</p>
			<p class="source-code">    <strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">     )</p>
			<p class="source-code">}</p>
			<p>What the preceding <strong class="source-inline">Route</strong> component does is display the page content based on the <strong class="source-inline">selected</strong> page. Note that it uses a <strong class="source-inline">&amp;&amp;</strong> symbol, which is a common line in <em class="italic">React</em> code. It's equivalent to the following:</p>
			<p class="source-code">      {selected === 'home' ? &lt;Home /&gt; : <strong class="bold">false</strong>}</p>
			<p>If the condition matches on the left part, it returns <strong class="source-inline">&lt;Home /&gt;</strong>; otherwise, it returns <strong class="source-inline">false</strong>. And according to <em class="italic">React</em>, any <strong class="source-inline">true</strong>, <strong class="source-inline">false</strong>, <strong class="source-inline">null</strong>, or <strong class="source-inline">undefined</strong> values are all valid elements, but when updated, they all get ignored without being displayed. Essentially, if the left part condition doesn't meet, it displays nothing.</p>
			<p>Putting the <strong class="source-inline">Nav</strong> and <strong class="source-inline">Route</strong> components together, we can amend the <strong class="source-inline">App</strong> component:</p>
			<p class="source-code"><strong class="bold">const</strong> Home = () <strong class="bold">=&gt; &lt;h1&gt;</strong>Home page<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code"><strong class="bold">const</strong> Product = () <strong class="bold">=&gt; &lt;h1&gt;</strong>Product page<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code"><strong class="bold">const</strong> App = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> selected = _getM("home")  </p>
			<p class="source-code">  <strong class="bold">return</strong> ( </p>
			<p class="source-code">    <strong class="bold">&lt;div&gt;</strong></p>
			<p class="source-code">      &lt;Nav</p>
			<p class="source-code">        items={menus} </p>
			<p class="source-code">        selected={selected} </p>
			<p class="source-code">        onSelect={_setM} </p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">      &lt;Routes selected={selected} /&gt;</p>
			<p class="source-code">    <strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>Finally, we got two pages working, as shown in <em class="italic">Figure 2.10</em>! If you click the <strong class="bold">Product</strong> link, it'll land on the product page: </p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_2.10_B17963.jpg" alt="Figure 2.10 – A single-page application using a state&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – A single-page application using a state</p>
			<p>To recap, the <strong class="source-inline">App</strong> component defines a <strong class="source-inline">selected</strong> state to hold the currently <strong class="source-inline">selected</strong> page. The <strong class="source-inline">Nav</strong> component<a id="_idIndexMarker091"/> is used to display all the links and allow<a id="_idIndexMarker092"/> it to choose a different page by clicking on the link. The <strong class="source-inline">Route</strong> component is used to display a page based on the <strong class="source-inline">selected</strong> state. Essentially, based on this setup, adding more pages is just a matter of adding new components under the <strong class="source-inline">Route</strong> component.</p>
			<p class="callout-heading">Playground – Single-Page Application</p>
			<p class="callout">Feel free to play with this example online at <a href="https://codepen.io/windmaomao/pen/PoKoWPG">https://codepen.io/windmaomao/pen/PoKoWPG</a>.</p>
			<p>Before we end this chapter, let's take a minute to look at how exactly a state<a id="_idTextAnchor071"/> drives the UI under <em class="italic">React</em>.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor072"/>How states work with UI </h1>
			<p>With the introduction<a id="_idIndexMarker093"/> of state to the function component, we sometimes can get dizzy<a id="_idIndexMarker094"/> by the roles that it plays. We will use three components to elaborate, as shown in <em class="italic">Figure 2.11</em>:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_2.11_B17963.jpg" alt="Figure 2.11 – Props in components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – Props in components</p>
			<p>We have three components depicted in solid boxes. The outer component contains the middle one as a child, and the middle one contains the inner one as a child. Props, depicted as arrow lines crossing the boundary of a solid box, pass values from a parent to a child component. </p>
			<p><em class="italic">React</em> is a state machine. For a given fixed set of variables, it paints the screen the same way. With props, this is quite straightforward since each component is solely determined by its props. Now, let's add the states to the picture, as shown in <em class="italic">Figure 2.12</em>. States, depicted as a symbol with a circle and a dot, are defined inside each component:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_2.12_B17963.jpg" alt="Figure 2.12 – States and props in components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.12 – States and props in components</p>
			<p>Taking the <strong class="bold">C</strong> inner component first, it doesn't have any state defined. So, it's still determined by its props. </p>
			<p>The <strong class="bold">B</strong> middle component<a id="_idIndexMarker095"/> has one state defined. With a fixed set of its props, the screen<a id="_idIndexMarker096"/> corresponding to the component still can vary because this state can take a different value on each update.</p>
			<p>The <strong class="bold">A</strong> outer component has two states defined. Similarly, with all its props fixed, the screen corresponding to it can still vary. The variation can come from any of its two states, and it can come from the state of the <strong class="bold">B</strong> component as well because the states of the parent and the child can work independently upon updates. </p>
			<p>Therefore, we can conclude that to get the screen painted for the <strong class="bold">A</strong> component, we need to fix all props and states within itself and all its child components underneath. This is not a mathematical theory, but given the states from multiple components, this observation is apparent.</p>
			<p>In short, props and states now both serve as the input of the component. The states can be especially vibrant since their values can be, but are not always, wired with an external system. The external system can be browser events or the <em class="italic">API</em> fetch, or anything else. Because a state can send to a child component via a prop, the effect of the state can cascade down de<a id="_idTextAnchor073"/>ep into the app tree quickly.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor074"/>Summary</h1>
			<p>In this chapter, we started to craft a new thing called a state inside the function component. The state is persistent across updates and can be used to request a new update, listen to a value change, as well as perform a task at the mount. Later, we applied the state we developed to a single-page application to draft a simplified <strong class="source-inline">Nav</strong> with a route system. In the end, we briefly studied how states work for <em class="italic">UI</em> under <em class="italic">React</em>.</p>
			<p>In the next chapter, we will introduce you to what a React hook is and how this persistent state is des<a id="_idTextAnchor075"/>igned under the <em class="italic">React</em> engine.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor076"/>Questions and answers</h1>
			<p>Here are some questions and answe<a id="_idTextAnchor077"/>rs to refresh your knowledge:</p>
			<ol>
				<li>What is a state?<p>For a function component, a state is a value created to be persistent during the life of the component. From each update, including the mount, this value can be acc<a id="_idTextAnchor078"/>essed from inside a function.</p></li>
				<li>What are the usages of states?<p>If a task can't be done within one update, that is the time we can think of using a state to reference a memory that can be accessed in multiple updates. We normally use a state to request a new update, listen to a value change, as well as perform a task at the mount. But the <a id="_idTextAnchor079"/>states can be very versatile.</p></li>
				<li>What does a state do to the UI?<p>To determine the screen corresponding to a component, we need to know its states as well as its props. While the props are passively defined on the component interface, the states are defined inside the component to actively refine its behavior. Apps built with states can change with time, driven by either user interactions or any other external processes.</p></li>
			</ol>
		</div>
	</body></html>