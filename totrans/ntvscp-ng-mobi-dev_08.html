<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building an Audio Recorder</h1>
                
            
            <article>
                
<p class="mce-root">Recording audio is the most performance-intensive operation our app must handle. It is also the one feature where having access to native APIs will be the most rewarding. We want our users to be able to record with the lowest latency possible for the mobile device in order to achieve the highest fidelity of sound. Additionally, this recording should optionally happen over the top of an existing mix of pre-recorded tracks all playing in sync .</p>
<p class="mce-root">Since this phase of our app development will dive the deepest into platform-specific native APIs, we will split our implementations into two phases. We will first build out the iOS-specific details of the recording features, followed by Android.</p>
<p class="mce-root">In this chapter, we will cover the following:</p>
<ul class="calibre13">
<li class="calibre14">Building a feature rich cross-platform audio recorder for iOS and Android with a consistent API</li>
<li class="calibre14">Integrating iOS framework libraries, such as AudioKit (<a href="http://audiokit.io" class="calibre3">http://audiokit.io</a>), which was built entirely with Swift</li>
<li class="calibre14">How to convert Swift/<span>Objective C </span>methods to NativeScript</li>
<li class="calibre14">Building custom reusable NativeScript view components based on native APIs, as well as how to use them inside Angular</li>
<li class="calibre14">Configuring a reusable Angular Component that can both be used via routing and opened via a popup modal</li>
<li class="calibre14">Integrate Android Gradle libraries</li>
<li class="calibre14">How to convert Java methods to NativeScript</li>
<li class="calibre14">Using multiple item templates with NativeScript's ListView</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Phase 1 – Building an audio recorder for iOS</h1>
                
            
            <article>
                
<p class="mce-root">The audio capabilities of the iOS platform are impressive, to say the least. A group of wonderfully talented audiophiles and software engineers have collaborated on building an open source framework layer on top of the platform's audio stack. This world class engineering effort is the awe inspiring AudioKit (<a href="http://audiokit.io/" class="calibre3">http://audiokit.io/</a>), led by the fearless Aurelius Prochazka, a true pioneer in audio technology.</p>
<p class="mce-root">The AudioKit framework is written entirely with Swift, which introduces a couple of interesting surface-level challenges when integrating with NativeScript.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Challenge detour – Integrate Swift based library into NativeScript </h1>
                
            
            <article>
                
<p class="mce-root">At the time of this writing, NativeScript can work with Swift if the codebase properly exposes the classes and types to Objective-C via what's called a <strong class="calibre1">bridging header</strong>, allowing both the languages to be mixed or matched. You can learn more about what a bridging header is here: <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html" class="calibre3">https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html</a>.<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html" class="calibre3"><br class="title-page-name"/></a> This bridging header is auto generated when the Swift codebase is compiled into a framework. Swift offers rich language features, some of which do not have a direct correlation to Objective C. Full featured support for the latest Swift language enhancements will likely come to NativeScript eventually however at the time of this writing there are a couple considerations to keep in mind.﻿</p>
<p class="mce-root">AudioKit utilizes the best of what the Swift language has to offer, including enriched <strong class="calibre1">enum</strong> capabilities. You can learn more about the expanded enum features in the Swift language here: <br class="title-page-name"/>
<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html" class="calibre3">https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html</a></p>
<p class="mce-root">In particular, there is this from the documentation: "t<em class="calibre21">hey adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration’s current value, and instance methods to provide functionality related to the values the enumeration represents.</em></p>
<p class="mce-root">Such <em class="calibre21">enums</em> are foreign to Objective C and, therefore, cannot be made available in the bridging header. Any code that uses Swift's exotic <em class="calibre21">enums</em> will be simply ignored when the bridging header is generated at compile time, resulting in Objective C not being able to interact with those sections of the code. This means you will not be able to use a method from a Swift codebase in NativeScript which utilizes these enhanced constructs out of the box (<em class="calibre21">at the time of this writing</em>).</p>
<p class="mce-root">To remedy this, we will fork the AudioKit framework and flatten the exotic enums used in the <kbd class="calibre11">AKAudioFile</kbd> extension files, which provide a powerful and convenient export method we will want to use to save our recorded audio files. The exotic <em class="calibre21">enum</em> we need to modify looks like this (<a href="https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift" class="calibre3">https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift</a>):</p>
<pre class="calibre22">// From AudioKit's Swift 3.x codebase<br class="title-page-name"/><br class="title-page-name"/>public enum ExportFormat {<br class="title-page-name"/>  case wav<br class="title-page-name"/>  case aif<br class="title-page-name"/>  case mp4<br class="title-page-name"/>  case m4a<br class="title-page-name"/>  case caf<br class="title-page-name"/><br class="title-page-name"/>  fileprivate var UTI: CFString {<br class="title-page-name"/>    switch self {<br class="title-page-name"/>    case .wav:<br class="title-page-name"/>      return AVFileTypeWAVE as CFString<br class="title-page-name"/>    case .aif:<br class="title-page-name"/>      return AVFileTypeAIFF as CFString<br class="title-page-name"/>    case .mp4:<br class="title-page-name"/>      return AVFileTypeAppleM4A as CFString<br class="title-page-name"/>    case .m4a:<br class="title-page-name"/>      return AVFileTypeAppleM4A as CFString<br class="title-page-name"/>    case .caf:<br class="title-page-name"/>      return AVFileTypeCoreAudioFormat as CFString<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  static var supportedFileExtensions: [String] {<br class="title-page-name"/>    return ["wav", "aif", "mp4", "m4a", "caf"]<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">This is unlike any <em class="calibre21">enum</em> you may be familiar with; as you can see, it includes properties in addition to what enums have. When this code is compiled and the bridging header is generated to mix or match with Objective-C, the bridging header will then exclude any code that uses this construct. We will flatten this out to look like the following:</p>
<pre class="calibre22">public enum ExportFormat: Int {<br class="title-page-name"/>  case wav<br class="title-page-name"/>  case aif<br class="title-page-name"/>  case mp4<br class="title-page-name"/>  case m4a<br class="title-page-name"/>  case caf<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>static public func stringUTI(type: ExportFormat) -&gt; CFString {<br class="title-page-name"/>  switch type {<br class="title-page-name"/>  case .wav:<br class="title-page-name"/>    return AVFileTypeWAVE as CFString<br class="title-page-name"/>  case .aif:<br class="title-page-name"/>    return AVFileTypeAIFF as CFString<br class="title-page-name"/>  case .mp4:<br class="title-page-name"/>    return AVFileTypeAppleM4A as CFString<br class="title-page-name"/>  case .m4a:<br class="title-page-name"/>    return AVFileTypeAppleM4A as CFString<br class="title-page-name"/>  case .caf:<br class="title-page-name"/>    return AVFileTypeCoreAudioFormat as CFString<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>static public var supportedFileExtensions: [String] {<br class="title-page-name"/>  return ["wav", "aif", "mp4", "m4a", "caf"]<br class="title-page-name"/>}</pre>
<p class="mce-root">We will then adjust the portions of the <kbd class="calibre11">AKAudioFile</kbd> extension to use our flattened properties. This will allow us to manually build <kbd class="calibre11">AudioKit.framework</kbd> we can use in our app, exposing the method we want to use: <kbd class="calibre11">exportAsynchronously</kbd>.</p>
<p class="mce-root">We won't go over the details of manually building <kbd class="calibre11">AudioKit.framework</kbd>, as it is well documented here: <a href="https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift" class="calibre3">https://github.com/audiokit/AudioKit/blob/master/Frameworks/INSTALL.md#building-universal-frameworks-from-scratch</a>. With our custom-built framework, we are now ready to integrate it into our app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integrating a custom-built iOS framework into NativeScript</h1>
                
            
            <article>
                
<p class="mce-root">We can now create an internal plugin to integrate this iOS framework into our app. Take the custom <kbd class="calibre11">AudioKit.framework</kbd> we have built and create a <kbd class="calibre11">nativescript-audiokit</kbd> directory at the root of our app. We then add a <kbd class="calibre11">platforms/ios</kbd> folder inside to drop the framework into. This will let NativeScript know how to build these iOS-specific files into the app. As we want this internal plugin to be treated like any standard npm plugin, we will also add <kbd class="calibre11">package.json</kbd> directly inside the <kbd class="calibre11">nativescript-audiokit</kbd> folder with the following contents:</p>
<pre class="calibre22">{<br class="title-page-name"/>  "name": "nativescript-audiokit",<br class="title-page-name"/>  "version": "1.0.0",<br class="title-page-name"/>  "nativescript": {<br class="title-page-name"/>    "platforms": {<br class="title-page-name"/>      "ios": "3.0.0"<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">We will now use the following command to add it to our app (NativeScript will look locally first and find the <strong class="calibre1">nativescript-audiokit</strong> plugin):</p>
<pre class="calibre22">tns plugin add nativescript-audiokit</pre>
<p class="mce-root">This will properly add the custom-built iOS framework into our app.<br class="title-page-name"/>
However, we need two more very important items:</p>
<ol class="calibre16">
<li value="1" class="calibre14">Since AudioKit is a Swift-based framework, we want to ensure our app includes the proper supporting Swift libraries. Add a new file, <kbd class="calibre11">nativescript-audiokit/platforms/ios/build.xcconfig</kbd>:</li>
</ol>
<pre class="calibre36">EMBEDDED_CONTENT_CONTAINS_SWIFT = true</pre>
<ol start="2" class="calibre16">
<li value="2" class="calibre14">Since we will be engaging with the user's microphone, we will want to ensure the microphone usage is indicated in our app's property list. We will also take this opportunity to add two additional property settings to enhance our app's abilities. So, in total, we will add three property keys for the following purposes: 
<ul class="calibre28">
<li class="calibre14">Let the device know our app needs access to the microphone and ensure the user's permission is requested on first access.</li>
<li class="calibre14">Continue playing audio if the app is placed into the background.</li>
<li class="calibre14">Provide the ability to see the app's <kbd class="calibre11">documents</kbd> folder in iTunes when the phone is connected to a computer. This will allow you to view recorded files right inside of iTunes via the app's Documents. This could be useful for integration into a desktop audio editing software.</li>
</ul>
</li>
</ol>
<p class="mce-root">Add a new file, <kbd class="calibre11">nativescript-audiokit/platforms/ios/Info.plist</kbd>, with the following code:</p>
<pre class="calibre22">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="title-page-name"/>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;<br class="title-page-name"/>&lt;plist version="1.0"&gt;<br class="title-page-name"/>&lt;dict&gt;<br class="title-page-name"/>  <strong class="calibre1">&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;</strong><br class="title-page-name"/><strong class="calibre1">  &lt;string&gt;Requires access to microphone.&lt;/string&gt;</strong><br class="title-page-name"/><strong class="calibre1">  &lt;key&gt;UIBackgroundModes&lt;/key&gt;</strong><br class="title-page-name"/><strong class="calibre1">  &lt;array&gt;</strong><br class="title-page-name"/><strong class="calibre1">    &lt;string&gt;audio&lt;/string&gt;</strong><br class="title-page-name"/><strong class="calibre1">  &lt;/array&gt;</strong><br class="title-page-name"/><strong class="calibre1">  &lt;key&gt;UIFileSharingEnabled&lt;/key&gt; </strong><br class="title-page-name"/><strong class="calibre1">  &lt;true/&gt;</strong><br class="title-page-name"/>&lt;/dict&gt;<br class="title-page-name"/>&lt;/plist&gt;</pre>
<p class="mce-root">Here is a screenshot to better illustrate the internal plugin structure in our app:</p>
<div class="mce-root1"><span><span><img class="image-border27" src="../images/00036.jpeg"/></span></span></div>
<p class="mce-root">Now, when NativeScript builds the iOS app, it will ensure <kbd class="calibre11">AudioKit.framework</kbd> is included as a library and merge the contents of <kbd class="calibre11">build.xcconfig</kbd> and <kbd class="calibre11">Info.plist</kbd> into our app's configuration. Any time we make changes to the files inside this internal plugin folder (<kbd class="calibre11">nativescript-audiokit</kbd>), we want to ensure our app picks up those changes. To do so, we can simply remove and add the plugin back, so let's do that now:</p>
<pre class="calibre22">tns plugin remove nativescript-audiokit<br class="title-page-name"/>tns plugin add nativescript-audiokit</pre>
<p class="mce-root">We are now ready to build our audio recorder using the AudioKit API for iOS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up native API type checking and generate AudioKit TypeScript definitions</h1>
                
            
            <article>
                
<p class="mce-root">The first thing we want to do is install <kbd class="calibre11">tns-platform-declarations</kbd>:</p>
<pre class="calibre22">npm i tns-platform-declarations --save-dev</pre>
<p class="mce-root">Now, we create a new file in the root of the project called <kbd class="calibre11">references.d.ts</kbd> with the following contents:</p>
<pre class="calibre22">/// &lt;reference path="./node_modules/tns-platform-declarations/ios.d.ts" /&gt;<br class="title-page-name"/>/// &lt;reference path="./node_modules/tns-platform-declarations/android.d.ts" /&gt;</pre>
<p class="mce-root">This provides us with full type checking and intellisense support for iOS and Android APIs.</p>
<p class="mce-root">We now want to generate typings for the AudioKit framework itself. We can execute this command to generate the typings for the included <kbd class="calibre11">AudioKit.framework</kbd>:</p>
<pre class="calibre22">TNS_TYPESCRIPT_DECLARATIONS_PATH="$(pwd)/typings" tns build ios</pre>
<p class="mce-root">We are setting the environment variable <kbd class="calibre11">TNS_TYPESCRIPT_DECLARATIONS_PATH</kbd> to the present working directory (<kbd class="calibre11">pwd</kbd>) with a folder prefix of <kbd class="calibre11">typings</kbd>. When NativeScript creates the iOS build, it will also generate type definition files for all the native APIs available to our app, including third-party libraries. We will now see a <kbd class="calibre11">typings</kbd> folder appear in our project, containing two folders: <kbd class="calibre11">i386</kbd> and <kbd class="calibre11">x86_64</kbd>. One is for the Simulator architecture and the other the device. Both will contain the same output, so we can just focus on one. Open the <kbd class="calibre11">i386</kbd> folder and you will find an <kbd class="calibre11">objc!AudioKit.d.ts</kbd> file.</p>
<p class="mce-root">We want to use only that file, so move it to the root of the <kbd class="calibre11">typings</kbd> folder: <kbd class="calibre11">typings/objc!AudioKit.d.ts</kbd>. We can then remove both the <kbd class="calibre11">i386</kbd> and <kbd class="calibre11">x86_64</kbd> folders, as we will no longer need them (the other API definition files are provided via <kbd class="calibre11">tns-platform-declarations</kbd>). We just generated these typings to get TypeScript definitions for the AudioKit library. This is a one-time thing, done to integrate easily with this native library, so you are safe to add this custom <kbd class="calibre11">typings</kbd> folder to source control.</p>
<p class="mce-root">Double-check <kbd class="calibre11">tsconfig.json</kbd> and ensure you have the <kbd class="calibre11">"skipLibCheck": true</kbd> option enabled. We can now modify our <kbd class="calibre11">references.d.ts</kbd> file to include the additional types for the AudioKit library:</p>
<pre class="calibre22">/// &lt;reference path="./node_modules/tns-platform-declarations/ios.d.ts" /&gt;<br class="title-page-name"/>/// &lt;reference path="./node_modules/tns-platform-declarations/android.d.ts" /&gt;<br class="title-page-name"/>/// &lt;reference path="./typings/objc!AudioKit.d.ts" /&gt;</pre>
<p class="cdpalignleft1">Our project structure should now look like this:</p>
<div class="mce-root1"><img class="image-border28" src="../images/00037.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Build recorder with AudioKit</h1>
                
            
            <article>
                
<p class="mce-root">We will begin by creating a model around our interaction with AudioKit's recording APIs. You could just start writing directly against these APIs right from your Angular component or service, but since we want to provide a consistent API across iOS and Android, there's a smarter way to architect this. Instead, we will abstract a simple API, usable across both platforms, which will tap into the correct native implementations under the hood. </p>
<p class="mce-root">There will be a lot of interesting details related to AudioKit going on here, but create <kbd class="calibre11">app/modules/recorder/models/record.model.ts</kbd> with the following and we will explain some of the bits in a moment:</p>
<div class="packt_infobox">Later, we will add the <kbd class="calibre29">.ios.ts</kbd> suffix to this model, since it will contain iOS-specific implementation details. However, here in Phase 1, we will use the model directly (omitting the platform suffix) while we develop our iOS recorder.</div>
<pre class="calibre22">import { Observable } from 'data/observable';<br class="title-page-name"/>import { knownFolders } from 'file-system';<br class="title-page-name"/><br class="title-page-name"/>// all available states for the recorder <br class="title-page-name"/>export enum RecordState {<br class="title-page-name"/>  readyToRecord,<br class="title-page-name"/>  recording,<br class="title-page-name"/>  readyToPlay,<br class="title-page-name"/>  playing,<br class="title-page-name"/>  saved,<br class="title-page-name"/>  finish<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// available events<br class="title-page-name"/>export interface IRecordEvents {<br class="title-page-name"/>  stateChange: string;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// for use when saving files<br class="title-page-name"/>const documentsFilePath = function(filename: string) {<br class="title-page-name"/>  return `${knownFolders.documents().path}/${filename}`;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>export class RecordModel extends Observable {<br class="title-page-name"/><br class="title-page-name"/>  // available events to listen to<br class="title-page-name"/>  private _events: IRecordEvents;<br class="title-page-name"/><br class="title-page-name"/>  // control nodes <br class="title-page-name"/>  private _mic: AKMicrophone;<br class="title-page-name"/>  private _micBooster: AKBooster;<br class="title-page-name"/>  private _recorder: AKNodeRecorder;<br class="title-page-name"/><br class="title-page-name"/>  // mixers<br class="title-page-name"/>  private _micMixer: AKMixer;<br class="title-page-name"/>  private _mainMixer: AKMixer;<br class="title-page-name"/><br class="title-page-name"/>  // state<br class="title-page-name"/>  private _state: number = RecordState.readyToRecord;<br class="title-page-name"/><br class="title-page-name"/>  // the final saved path to use <br class="title-page-name"/>  private _savedFilePath: string;<br class="title-page-name"/><br class="title-page-name"/>  constructor() {<br class="title-page-name"/>    super();<br class="title-page-name"/>    // setup the event names<br class="title-page-name"/>    this._setupEvents();<br class="title-page-name"/><br class="title-page-name"/>    // setup recording environment<br class="title-page-name"/>    // clean any tmp files from previous recording sessions<br class="title-page-name"/>    (&lt;any&gt;AVAudioFile).cleanTempDirectory();<br class="title-page-name"/><br class="title-page-name"/>    // audio setup <br class="title-page-name"/>    AKSettings.setBufferLength(BufferLength.Medium);<br class="title-page-name"/><br class="title-page-name"/>    try {<br class="title-page-name"/>      // ensure audio session is PlayAndRecord<br class="title-page-name"/>      // allows mixing with other tracks while recording<br class="title-page-name"/>      AKSettings.setSessionWithCategoryOptionsError(<br class="title-page-name"/>        SessionCategory.PlayAndRecord, <br class="title-page-name"/>        AVAudioSessionCategoryOptions.DefaultToSpeaker<br class="title-page-name"/>      );<br class="title-page-name"/>    } catch (err) {<br class="title-page-name"/>      console.log('AKSettings error:', err);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    // setup mic with it's own mixer<br class="title-page-name"/>    this._mic = AKMicrophone.alloc().init();<br class="title-page-name"/>    this._micMixer = AKMixer.alloc().init(null);<br class="title-page-name"/>    this._micMixer.connect(this._mic);<br class="title-page-name"/>    // Helps provide mic monitoring when headphones are plugged in<br class="title-page-name"/>    this._micBooster = AKBooster.alloc().initGain(&lt;any&gt;this._micMixer, 0);<br class="title-page-name"/><br class="title-page-name"/>    try {<br class="title-page-name"/>      // recorder takes the micMixer input node<br class="title-page-name"/>      this._recorder = AKNodeRecorder.alloc()<br class="title-page-name"/>        .initWithNodeFileError(&lt;any&gt;this._micMixer, null);<br class="title-page-name"/>    } catch (err) {<br class="title-page-name"/>      console.log('AKNodeRecorder init error:', err);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    // overall main mixer uses micBooster<br class="title-page-name"/>    this._mainMixer = AKMixer.alloc().init(null);<br class="title-page-name"/>    this._mainMixer.connect(this._micBooster);<br class="title-page-name"/><br class="title-page-name"/>    // single output set to mainMixer <br class="title-page-name"/>    AudioKit.setOutput(&lt;any&gt;this._mainMixer);<br class="title-page-name"/>    // start the engine!<br class="title-page-name"/>    AudioKit.start();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get events(): IRecordEvents {<br class="title-page-name"/>    return this._events;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get mic(): AKMicrophone {<br class="title-page-name"/>    return this._mic;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get recorder(): AKNodeRecorder {<br class="title-page-name"/>    return this._recorder;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get audioFilePath(): string {<br class="title-page-name"/>    if (this._recorder) {<br class="title-page-name"/>      return this._recorder.audioFile.url.absoluteString;<br class="title-page-name"/>    }<br class="title-page-name"/>    return '';<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get state(): number {<br class="title-page-name"/>    return this._state;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public set state(value: number) {<br class="title-page-name"/>    this._state = value;<br class="title-page-name"/>    // always emit state changes<br class="title-page-name"/>    this._emitEvent(this._events.stateChange, this._state);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get savedFilePath() {<br class="title-page-name"/>    return this._savedFilePath;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public set savedFilePath(value: string) {<br class="title-page-name"/>    this._savedFilePath = value;<br class="title-page-name"/>    if (this._savedFilePath)<br class="title-page-name"/>      this.state = RecordState.saved;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public toggleRecord() {<br class="title-page-name"/>    if (this._state !== RecordState.recording) {<br class="title-page-name"/>      // just force ready to record<br class="title-page-name"/>      // when coming from any state other than recording<br class="title-page-name"/>      this.state = RecordState.readyToRecord;<br class="title-page-name"/> <br class="title-page-name"/>      if (this._recorder) {<br class="title-page-name"/>        try {<br class="title-page-name"/>          // resetting (clear previous recordings)<br class="title-page-name"/>          this._recorder.resetAndReturnError();<br class="title-page-name"/>        } catch (err) {<br class="title-page-name"/>          console.log('Recorder reset error:', err);<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    switch (this._state) {<br class="title-page-name"/>      case RecordState.readyToRecord:<br class="title-page-name"/>        if (AKSettings.headPhonesPlugged) {<br class="title-page-name"/>          // Microphone monitoring when headphones plugged<br class="title-page-name"/>          this._micBooster.gain = 1;<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        try {<br class="title-page-name"/>          this._recorder.recordAndReturnError();<br class="title-page-name"/>          this.state = RecordState.recording;<br class="title-page-name"/>        } catch (err) {<br class="title-page-name"/>          console.log('Recording failed:', err);<br class="title-page-name"/>        }<br class="title-page-name"/>        break;<br class="title-page-name"/>      case RecordState.recording:<br class="title-page-name"/>        this.state = RecordState.readyToPlay;<br class="title-page-name"/>        this._recorder.stop();<br class="title-page-name"/>        // Microphone monitoring muted when playing back<br class="title-page-name"/>        this._micBooster.gain = 0;<br class="title-page-name"/>        break;<br class="title-page-name"/>    }<br class="title-page-name"/>  } <br class="title-page-name"/><br class="title-page-name"/>  public togglePlay() {<br class="title-page-name"/>    if (this._state === RecordState.readyToPlay) {<br class="title-page-name"/>      this.state = RecordState.playing;<br class="title-page-name"/>    } else {<br class="title-page-name"/>      this.stopPlayback();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public stopPlayback() {<br class="title-page-name"/>    if (this.state !== RecordState.recording) {<br class="title-page-name"/>      this.state = RecordState.readyToPlay;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public save() {<br class="title-page-name"/>    let fileName = `recording-${Date.now()}.m4a`;<br class="title-page-name"/>    this._recorder.audioFile<br class="title-page-name"/>    .exportAsynchronouslyWithNameBaseDirExportFormatFromSampleToSampleCallback(<br class="title-page-name"/>      fileName, BaseDirectory.Documents, ExportFormat.M4a, null, null, <br class="title-page-name"/>      (af: AKAudioFile, err: NSError) =&gt; {<br class="title-page-name"/>        this.savedFilePath = documentsFilePath(fileName);<br class="title-page-name"/>      });<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public finish() {<br class="title-page-name"/>    this.state = RecordState.finish;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _emitEvent(eventName: string, data?: any) {<br class="title-page-name"/>    let event = {<br class="title-page-name"/>      eventName,<br class="title-page-name"/>      data,<br class="title-page-name"/>      object: this<br class="title-page-name"/>    };<br class="title-page-name"/>    this.notify(event);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _setupEvents() {<br class="title-page-name"/>    this._events = {<br class="title-page-name"/>      stateChange: 'stateChange'<br class="title-page-name"/>    };<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root"><kbd class="calibre11">RecordModel</kbd> will behave a bit like a state machine, where the only states it could be in are the following:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre11">readyToRecord</kbd>: Default starting state. Must be in this state to enter the recording state.</li>
<li class="calibre14"><kbd class="calibre11">recording</kbd>: Quiet in the studio! Recording in process.</li>
<li class="calibre14"><kbd class="calibre11">readyToPlay</kbd>: User has stopped recording and now has a recorded file to play back with the mix.</li>
<li class="calibre14"><kbd class="calibre11">playing</kbd>: User is playing back the recorded file with the mix.</li>
<li class="calibre14"><kbd class="calibre11">saved</kbd>: User chose to save the recording, that should kick off actions to save the new track with the active composition.</li>
<li class="calibre14"><kbd class="calibre11">finish</kbd>: Once the save actions are complete, the recorder should shut down.</li>
</ul>
<p class="mce-root">We then define the shape of the events the recorder will provide with <span><kbd class="calibre11">IRecordEvents</kbd>. In this case, we will have a single event, <kbd class="calibre11">stateChange</kbd>, which will notify any listeners when the state changes (<em class="calibre21">see the state setter</em>). Our model will extend NativeScript's <kbd class="calibre11">Observable</kbd> class (hence, <kbd class="calibre11">RecordModel extends Observable</kbd>), which will provide us with the notify API to dispatch our events.</span></p>
<p class="mce-root">We then set up several references to the various AudioKit bits we will use. Most of what is designed is directly from this AudioKit example on recording: <a href="https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift" class="calibre3">https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift</a>. We even use the same state enum setup (with a few extras). In their example, AudioKit's <kbd class="calibre11">AKAudioPlayer</kbd> is used for playback; but, with our design, we will load our recorded files into our multitrack player design to play them back with our mix. We could work <kbd class="calibre11">AKAudioPlayer</kbd> into <kbd class="calibre11">TrackPlayerModel</kbd> for iOS; but, <kbd class="calibre11">TNSPlayer</kbd> (from the <strong class="calibre1">nativescript-audio</strong> plugin) is cross-platform compatible and will work just fine. We'll cover the details of how we load these new recorded files into our design shortly, but notifying listeners of the recorder's state will provide us all the flexibility we need to handle all that when we get there.</p>
<p class="mce-root">You may wonder why we type-cast this:</p>
<pre class="calibre22">(&lt;any&gt;AVAudioFile).cleanTempDirectory();</pre>
<p class="mce-root">Good question. AudioKit provides Extensions to Core Foundation classes such as <kbd class="calibre11">AVAudioFile</kbd>. These were known as <kbd class="calibre11">Categories</kbd> in Objective C: <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" class="calibre3">https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html</a>; however, in Swift, they are referred to as <kbd class="calibre11">Extensions</kbd>: <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html" class="calibre3">https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html</a>.</p>
<p class="mce-root">If you recall, we generated TypeScript definitions for AudioKit; but, we only kept the <kbd class="calibre11">objc!AudioKit.d.ts</kbd> file to reference. If we had looked in the foundation definitions, we would have seen the extension to <kbd class="calibre11">AVAudioFile</kbd>. However, since we did not keep those definitions around and instead are relying on the default <kbd class="calibre11">tns-platform-declarations</kbd> definitions, this <kbd class="calibre11">Extension</kbd> is not known to our TypeScript compiler, so we simply type-cast it, as we know AudioKit provides this.</p>
<p class="mce-root">It's also critical <kbd class="calibre11">RecordModel</kbd> sets the audio session to <kbd class="calibre11">PlayAndRecord</kbd>, as this will allow us to record while playing our mix at the same time:</p>
<pre class="calibre22">AKSettings.setSessionWithCategoryOptionsError(<br class="title-page-name"/>  SessionCategory.PlayAndRecord, <br class="title-page-name"/>  AVAudioSessionCategoryOptions.DefaultToSpeaker<br class="title-page-name"/>);</pre>
<p class="mce-root">You may also be curious why some classes use <kbd class="calibre11">init()</kbd> and others <kbd class="calibre11">init(null)</kbd>:</p>
<pre class="calibre22">this._mic = AKMicrophone.alloc().init();<br class="title-page-name"/>this._micMixer = AKMixer.alloc().init(null);<br class="title-page-name"/>this._micMixer.connect(this._mic);</pre>
<p class="mce-root">Some of the initializers for AudioKit's classes take an optional argument, for example, <kbd class="calibre11">AKMixer</kbd> takes an optional <kbd class="calibre11">NSArray</kbd> of <kbd class="calibre11">AVAudioNode</kbd> to connect. However, our TypeScript definitions have those defined as required, so we are just passing <kbd class="calibre11">null</kbd> to that argument and instead using the <kbd class="calibre11">connect</kbd> node API directly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to convert Swift/ObjC methods to NativeScript</h1>
                
            
            <article>
                
<p class="mce-root">The last point of interest from <kbd class="calibre11">RecordModel</kbd> might be the <kbd class="calibre11">save</kbd> method, which will export our recording from the app's <kbd class="calibre11">tmp</kbd> directory to the app's <kbd class="calibre11">documents</kbd> folder while converting it to the smaller filesize <kbd class="calibre11">.m4a</kbd> audio format:</p>
<pre class="calibre22">this._recorder.audioFile<br class="title-page-name"/>  .exportAsynchronouslyWithNameBaseDirExportFormatFromSampleToSampleCallback(<br class="title-page-name"/>    fileName, BaseDirectory.Documents, ExportFormat.M4a, null, null, <br class="title-page-name"/>    (af: AKAudioFile, err: NSError) =&gt; {<br class="title-page-name"/>      this.savedFilePath = documentsFilePath(fileName);<br class="title-page-name"/>  });</pre>
<p class="mce-root">Long method name, right? Yes, indeed; some Swift/ObjC parameterized method names collapse to become very long. That particular method in Swift is defined as follows:</p>
<pre class="calibre22">exportAsynchronously(name:baseDir:exportFormat:fromSample:toSample:callback:)<br class="title-page-name"/>// converted to NativeScript:<br class="title-page-name"/><strong class="calibre1">exportAsynchronouslyWithNameBaseDirExportFormatFromSampleToSampleCallback</strong></pre>
<p class="mce-root">Since we had the TypeScript definitions generated for AudioKit, they helped us out here. However, sometimes, you don't have that luxury. A Swift/ObjC method with various parameters for arguments collapse into each other while adding <kbd class="calibre11">With</kbd> in between the start of the method name and the start of the parameter argument names, while capitalizing the first character upon collapsing each.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building custom reusable NativeScript view for native audio Waveform display</h1>
                
            
            <article>
                
<p class="mce-root">Instead of creating an Angular Component for our Waveform display, we will create a custom NativeScript view component, that taps into native APIs, that we can then register with Angular to use in our components. The reason for doing this is due to NativeScript's powerful <kbd class="calibre11">view</kbd> base class that we can extend, which provides a nice API when using underlying native APIs for the <kbd class="calibre11">view</kbd>. This Waveform display will work in tandem with the <kbd class="calibre11">RecordModel</kbd> we just created to bring to life our real-time Waveform feedback display of the device's microphone. It would also be amazing to reuse this Waveform display as a static audio file waveform rendering on our track list, as an alternate view for our main composition view. AudioKit provides classes and APIs to do all this.</p>
<p class="mce-root">Since we want to be able to use this anywhere in our app, we will create it inside the shared module directory; however, keep in mind that it could live anywhere. It doesn't matter so much here, since this is not an Angular component that needs to be declared in <kbd class="calibre11">NgModule</kbd>. Additionally, since this will specifically work with native APIs, let's create it inside a new <kbd class="calibre11">native</kbd> folder to potentially house other NativeScript-specific view components.</p>
<p class="mce-root">Create <kbd class="calibre11">app/modules/shared/native/waveform.ts</kbd> with the following contents, which we will explain in a moment:</p>
<pre class="calibre22">import { View, Property } from 'ui/core/view';<br class="title-page-name"/>import { Color } from 'color';<br class="title-page-name"/><br class="title-page-name"/>// Support live microphone display as well as static audio file renders<br class="title-page-name"/>type WaveformType = 'mic' | 'file';<br class="title-page-name"/><br class="title-page-name"/>// define properties<br class="title-page-name"/>export const plotColorProperty = new Property&lt;Waveform, string&gt;({ name: 'plotColor' });<br class="title-page-name"/>export const plotTypeProperty = new Property&lt;Waveform, string&gt;({ name: 'plotType' });<br class="title-page-name"/>export const fillProperty = new Property&lt;Waveform, string&gt;({ name: 'fill' });<br class="title-page-name"/>export const mirrorProperty = new Property&lt;Waveform, string&gt;({ name: 'mirror' });<br class="title-page-name"/><br class="title-page-name"/>export interface IWaveformModel {<br class="title-page-name"/>  readonly target: any;<br class="title-page-name"/>  dispose(): void;<br class="title-page-name"/>}<br class="title-page-name"/>export class Waveform extends View {<br class="title-page-name"/>  private _model: IWaveformModel;<br class="title-page-name"/>  private _type: WaveformType;<br class="title-page-name"/><br class="title-page-name"/>  public set type(value: WaveformType) {<br class="title-page-name"/>    this._type = value;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get type() {<br class="title-page-name"/>    return this._type;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public set model(value: IWaveformModel) {<br class="title-page-name"/>    this._model = value;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get model() {<br class="title-page-name"/>    return this._model;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  createNativeView() {<br class="title-page-name"/>    switch (this.type) {<br class="title-page-name"/>      case 'mic':<br class="title-page-name"/>        this.nativeView = AKNodeOutputPlot.alloc()<br class="title-page-name"/>          .initFrameBufferSize(this._model.target, CGRectMake(0, 0, 0, 0), 1024);<br class="title-page-name"/>        break;<br class="title-page-name"/>      case 'file':<br class="title-page-name"/>        this.nativeView = EZAudioPlot.alloc().init();<br class="title-page-name"/>        break;<br class="title-page-name"/>    }<br class="title-page-name"/>    return this.nativeView;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  initNativeView() {<br class="title-page-name"/>    if (this._type === 'file') {<br class="title-page-name"/>      // init file with the model's target<br class="title-page-name"/>      // target should be absolute url to path of file<br class="title-page-name"/>      let file = EZAudioFile.alloc()<br class="title-page-name"/>        .initWithURL(NSURL.fileURLWithPath(this._model.target));<br class="title-page-name"/>      // render the file's data as a waveform<br class="title-page-name"/>      let data = file.getWaveformData();<br class="title-page-name"/>      (&lt;EZAudioPlot&gt;this.nativeView)<br class="title-page-name"/>        .updateBufferWithBufferSize(data.buffers[0], data.bufferSize);<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  disposeNativeView() {<br class="title-page-name"/>    if (this.model &amp;&amp; this.model.dispose) this.model.dispose();<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  [plotColorProperty.setNative](value: string) {<br class="title-page-name"/>    this.nativeView.color = new Color(value).ios;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [fillProperty.setNative](value: string) {<br class="title-page-name"/>    this.nativeView.shouldFill = value === 'true';<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [mirrorProperty.setNative](value: string) {<br class="title-page-name"/>    this.nativeView.shouldMirror = value === 'true';<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [plotTypeProperty.setNative](value: string) {<br class="title-page-name"/>    switch (value) {<br class="title-page-name"/>      case 'buffer':<br class="title-page-name"/>        this.nativeView.plotType = EZPlotType.Buffer;<br class="title-page-name"/>        break;<br class="title-page-name"/>      case 'rolling':<br class="title-page-name"/>        this.nativeView.plotType = EZPlotType.Rolling;<br class="title-page-name"/>        break;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// register properties with it's type<br class="title-page-name"/>plotColorProperty.register(Waveform);<br class="title-page-name"/>plotTypeProperty.register(Waveform);<br class="title-page-name"/>fillProperty.register(Waveform);<br class="title-page-name"/>mirrorProperty.register(Waveform);</pre>
<p class="mce-root">We are creating several properties using NativeScript's <kbd class="calibre11">Property</kbd> class, which will add great conveniences when exposing native view properties through the view binding properties. One such convenience in defining these properties with the <kbd class="calibre11">Property</kbd> class, these setters will only be called when <kbd class="calibre11">nativeView</kbd> is defined, avoiding double invoked property setters (one via a pure JS property setter, which is the alternative, and potentially another for when the underlying <kbd class="calibre11">nativeView</kbd> is ready).</p>
<div class="packt_tip">When wanting to expose native view properties that could be bound via your custom component, define several <kbd class="calibre29">Property</kbd> classes for them, referencing the name you'd like to use for the view binding.</div>
<pre class="calibre22">// define properties<br class="title-page-name"/>export const plotColorProperty = new Property&lt;Waveform, string&gt;({ name: 'plotColor' });<br class="title-page-name"/>export const plotTypeProperty = new Property&lt;Waveform, string&gt;({ name: 'plotType' });<br class="title-page-name"/>export const fillProperty = new Property&lt;Waveform, string&gt;({ name: 'fill' });<br class="title-page-name"/>export const mirrorProperty = new Property&lt;Waveform, string&gt;({ name: 'mirror' });</pre>
<p class="mce-root">By setting up these <kbd class="calibre11">Property</kbd> instances, we can now do this in our view component class:</p>
<pre class="calibre22">[plotColorProperty.setNative](value: string) {<br class="title-page-name"/>  this.nativeView.color = new Color(value).ios;<br class="title-page-name"/>}</pre>
<p class="mce-root">This will only be invoked once <kbd class="calibre11">nativeView</kbd> is ready, which is exactly what we want. You can read more about this particular syntax and notation in this draft written by core team member Alex Vakrilov: <br class="title-page-name"/>
<a href="https://gist.github.com/vakrilov/ca888a1ea410f4ea7a4c7b2035e06b07#registering-the-property" class="calibre3">https://gist.github.com/vakrilov/ca888a1ea410f4ea7a4c7b2035e06b07#registering-the-property</a>.</p>
<p class="mce-root">Then, at the bottom of our class (after it's defined), we register the class with the <kbd class="calibre11">Property</kbd> instances:</p>
<pre class="calibre22">// register properties<br class="title-page-name"/>plotColorProperty.register(Waveform);<br class="title-page-name"/>plotTypeProperty.register(Waveform);<br class="title-page-name"/>fillProperty.register(Waveform);<br class="title-page-name"/>mirrorProperty.register(Waveform);</pre>
<p class="mce-root">Okay, with that explained, let's look at some other elements to this implementation.</p>
<p class="mce-root">We are also introducing a helpful interface here, which we will apply to <kbd class="calibre11">RecordModel</kbd> in a moment:</p>
<pre class="calibre22">export interface IWaveformModel {<br class="title-page-name"/>  readonly target: any;<br class="title-page-name"/>  dispose(): void;<br class="title-page-name"/>}</pre>
<p class="mce-root">This will help define a shape for other models to implement, ensuring they conform to an API the Waveform display expects:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre11">target</kbd>: Defines the key input to be used with the native class.</li>
<li class="calibre14"><kbd class="calibre11">dispose()</kbd>: Each model should provide this method to handle any clean up when the view is destroyed.</li>
</ul>
<div class="packt_tip">This is the custom NativeScript 3.x View Life cycle call execution order:<br class="calibre24"/>
<ol class="calibre37">
<li value="1" class="calibre38"><kbd class="calibre29">createNativeView()</kbd>: <kbd class="calibre29">AnyNativeView;</kbd>  // Create your native view.</li>
</ol>
<ol start="2" class="calibre37">
<li value="2" class="calibre38"><kbd class="calibre29">initNativeView()</kbd>: <kbd class="calibre29">void;</kbd>  // Init your native view.</li>
</ol>
<ol start="3" class="calibre37">
<li value="3" class="calibre38"><kbd class="calibre29">disposeNativeView()</kbd>: <kbd class="calibre29">void<span class="calibre31">;</span></kbd>  // Clean up your native view.</li>
</ol>
</div>
<p class="mce-root">The <kbd class="calibre11">createNativeView</kbd> method overridden from NativeScript's <kbd class="calibre11">View</kbd> class is likely the most interesting:</p>
<pre class="calibre22">createNativeView() {<br class="title-page-name"/>  switch (this.type) {<br class="title-page-name"/>    case 'mic':<br class="title-page-name"/>      this.nativeView = AKNodeOutputPlot.alloc()<br class="title-page-name"/>        .initFrameBufferSize(this._model.target, CGRectMake(0, 0, 0, 0), 1024);<br class="title-page-name"/>      break;<br class="title-page-name"/>    case 'file':<br class="title-page-name"/>      this.nativeView = EZAudioPlot.alloc().init();<br class="title-page-name"/>      break;<br class="title-page-name"/>  }<br class="title-page-name"/>  return this.nativeView;<br class="title-page-name"/>}</pre>
<p class="mce-root">Here, we allow the <kbd class="calibre11">type</kbd> property to determine which type of Waveform display it should render.<br class="title-page-name"/>
In the case of <kbd class="calibre11">mic</kbd>, we utilize AudioKit's <kbd class="calibre11">AKNodeOutputPlot</kbd> (which actually extends <kbd class="calibre11">EZAudioPlot</kbd> under the hood) to initialize a waveform (that is, <kbd class="calibre11">audioplot</kbd>) using our model's target, which will end up being our RecordModel's microphone. <br class="title-page-name"/>
In the case of <kbd class="calibre11">file</kbd>, we utilize AudioKit's <kbd class="calibre11">EZAudioPlot</kbd> directly to create a static waveform representing an audio file.</p>
<p class="mce-root">The <kbd class="calibre11">initNativeView</kbd> method, also overridden from NativeScript's <kbd class="calibre11">View</kbd> class, is called second in its life cycle and provides a way to initialize your native view. You might find it interesting that we call the setters again here. The setters are called first when the component bindings are set via the XML and the class instantiates, which is <em class="calibre21">before</em> <kbd class="calibre11">createNativeView</kbd> and <kbd class="calibre11">initNativeView</kbd> are called. This why we cache the values in private references. However, we also want these setters to modify <kbd class="calibre11">nativeView</kbd> with Angular's view bindings (when changed dynamically), which is why we also have <kbd class="calibre11">if (this.nativeView)</kbd> inside the setters to change <kbd class="calibre11">nativeView</kbd> dynamically when available.</p>
<p class="mce-root">The <kbd class="calibre11">disposeNativeView</kbd> method (you guessed it, also overridden from the <kbd class="calibre11">{N}</kbd> of the <kbd class="calibre11">View</kbd> class) is called when <kbd class="calibre11">View</kbd> gets destroyed, which is where we call the model's <kbd class="calibre11">dispose</kbd> method if available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integrate a custom NativeScript view into our Angular app</h1>
                
            
            <article>
                
<p class="mce-root">To use our NativeScript Waveform view within Angular, we need to first register it. You can do this in the root module, root app component, or another place that is initialized at boot time (usually, not in a lazy-loaded module). To be tidy, we will register it within <kbd class="calibre11">SharedModule</kbd> in the same directory, so add the following in <kbd class="calibre11">app/modules/shared/shared.module.ts</kbd>:</p>
<pre class="calibre22">...<br class="title-page-name"/>// register nativescript custom components<br class="title-page-name"/><strong class="calibre1">import { registerElement } from 'nativescript-angular/element-registry';</strong><br class="title-page-name"/><strong class="calibre1">import { Waveform } from './native/waveform';</strong><br class="title-page-name"/><strong class="calibre1">registerElement('Waveform', () =&gt; Waveform);</strong><br class="title-page-name"/>...<br class="title-page-name"/>@NgModule({...<br class="title-page-name"/>export class SharedModule {...</pre>
<p class="mce-root">The <kbd class="calibre11">registerElement</kbd> method allows us to define the name of the Component we want to use within Angular components as the first argument, and takes a resolver function that should return the NativeScript <kbd class="calibre11">View</kbd> class to use for it. </p>
<p class="mce-root">Let's now use our new <kbd class="calibre11">IWaveformModel</kbd> and clean up some of <kbd class="calibre11">RecordModel</kbd> to use it, as well as prepare to create our Android implementation next. Let's refactor a couple things out of <kbd class="calibre11">RecordModel</kbd> into a common file to share code between our iOS and Android (coming soon!) models.</p>
<p class="mce-root">Create <kbd class="calibre11">app/modules/recorder/models/record-common.ts</kbd>:</p>
<pre class="calibre22">import { IWaveformModel } from '../../shared/native/waveform';<br class="title-page-name"/>import { knownFolders } from 'file-system';<br class="title-page-name"/><br class="title-page-name"/>export enum RecordState {<br class="title-page-name"/>  readyToRecord,<br class="title-page-name"/>  recording,<br class="title-page-name"/>  readyToPlay,<br class="title-page-name"/>  playing,<br class="title-page-name"/>  saved,<br class="title-page-name"/>  finish<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>export interface IRecordEvents {<br class="title-page-name"/>  stateChange: string;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>export interface IRecordModel extends IWaveformModel {<br class="title-page-name"/>  readonly events: IRecordEvents;<br class="title-page-name"/>  readonly recorder: any;<br class="title-page-name"/>  readonly audioFilePath: string;<br class="title-page-name"/>  state: number; <br class="title-page-name"/>  savedFilePath: string;<br class="title-page-name"/>  toggleRecord(): void;<br class="title-page-name"/>  togglePlay(startTime?: number, when?: number): void;<br class="title-page-name"/>  stopPlayback(): void;<br class="title-page-name"/>  save(): void;<br class="title-page-name"/>  finish(): void;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>export const documentsFilePath = function(filename: string) {<br class="title-page-name"/>  return `${knownFolders.documents().path}/${filename}`;<br class="title-page-name"/>}</pre>
<p class="mce-root">This contains most of what was at the top of <kbd class="calibre11">RecordModel</kbd>, with the addition of the <kbd class="calibre11">IRecordModel</kbd> interface, which extends <kbd class="calibre11">IWaveformModel</kbd>. Since we built out our iOS implementation, we now have a model shape we would like our Android implementation to adhere to. Abstracting that shape into an interface will provide us a clear path to follow when we move to Android momentarily. </p>
<p class="mce-root">For convenience, let's also create an index for our models, which would also expose this common file, in <kbd class="calibre11">app/modules/recorder/models/index.ts</kbd>:</p>
<pre class="calibre22">export * from './record-common.model';<br class="title-page-name"/>export * from './record.model';</pre>
<p class="mce-root">We can now modify <kbd class="calibre11">RecordModel</kbd> to import these common items, as well as implement this new <kbd class="calibre11">IRecordModel</kbd> interface. Since this new interface also <em class="calibre21">extends</em> <kbd class="calibre11">IWaveformModel</kbd>, it will immediately tell us we need to implement the <kbd class="calibre11">readonly target</kbd><strong class="calibre1"> </strong>getter and the <kbd class="calibre11">dispose()</kbd><strong class="calibre1"> </strong>method, as required to be used with our Waveform view:</p>
<pre class="calibre22">import { Observable } from 'data/observable';<br class="title-page-name"/><strong class="calibre1">import { IRecordModel, IRecordEvents, RecordState, documentsFilePath } from './common';</strong><br class="title-page-name"/><br class="title-page-name"/>export class RecordModel extends Observable <strong class="calibre1">implements IRecordModel</strong> {<br class="title-page-name"/>  ...<br class="title-page-name"/>  <strong class="calibre1">public get target() {</strong><br class="title-page-name"/><strong class="calibre1">    return this._mic;</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public dispose() {</strong><br class="title-page-name"/><strong class="calibre1">    AudioKit.stop();</strong><br class="title-page-name"/><strong class="calibre1">    // cleanup</strong><br class="title-page-name"/><strong class="calibre1">    this._mainMixer = null;</strong><br class="title-page-name"/><strong class="calibre1">    this._recorder = null;</strong><br class="title-page-name"/><strong class="calibre1">    this._micBooster = null;</strong><br class="title-page-name"/><strong class="calibre1">    this._micMixer = null;</strong><br class="title-page-name"/><strong class="calibre1">    this._mic = null;</strong><br class="title-page-name"/><strong class="calibre1">    // clean out tmp files</strong><br class="title-page-name"/><strong class="calibre1">    (&lt;any&gt;AVAudioFile).cleanTempDirectory();</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>  ...</pre>
<p class="mce-root">The <kbd class="calibre11">target</kbd> of <kbd class="calibre11">RecordModel</kbd> will be the microphone that the Waveform view will use. Our <kbd class="calibre11">dispose</kbd> method will stop the AudioKit engine while doing reference clean up, as well as ensuring to clean out any temporary files created while recording.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating the Recorder View layout</h1>
                
            
            <article>
                
<p class="mce-root">When the user taps on <span>Record</span> in the top right corner of the app, it prompts the user to authenticate, after which the app routes to the record view. Additionally, it would be nice to reuse this record view in a modal popup to show when the composition contains tracks, so the user doesn't feel like they are leaving the composition while recording. However, when the composition is new, it's fine to navigate to the record view via routing. We will show how this can be done, but let's first set up our layout using the new fancy Waveform view and our powerful new <kbd class="calibre11">RecordModel</kbd>.</p>
<p class="mce-root">Add the following to <kbd class="calibre11">app/modules/recorder/components/record.component.html</kbd>:</p>
<pre class="calibre22">&lt;ActionBar title="Record" icon="" class="action-bar"&gt;<br class="title-page-name"/>  &lt;NavigationButton visibility="collapsed"&gt;&lt;/NavigationButton&gt;<br class="title-page-name"/>  &lt;ActionItem text="Cancel" <br class="title-page-name"/>    ios.systemIcon="1" android.systemIcon="ic_menu_back" <br class="title-page-name"/>    (tap)="cancel()"&gt;&lt;/ActionItem&gt;<br class="title-page-name"/>&lt;/ActionBar&gt;<br class="title-page-name"/>&lt;FlexboxLayout class="record"&gt;<br class="title-page-name"/>  &lt;GridLayout rows="auto" columns="auto,*,auto" class="p-10" *ngIf="isModal"&gt;<br class="title-page-name"/>    &lt;Button text="Cancel" (tap)="cancel()" <br class="title-page-name"/>      row="0" col="0" class="c-white"&gt;&lt;/Button&gt;<br class="title-page-name"/>  &lt;/GridLayout&gt;<br class="title-page-name"/>  &lt;Waveform class="waveform" <br class="title-page-name"/>    [model]="recorderService.model" <br class="title-page-name"/>    type="mic" <br class="title-page-name"/>    plotColor="yellow" <br class="title-page-name"/>    fill="false" <br class="title-page-name"/>    mirror="true" <br class="title-page-name"/>    plotType="buffer"&gt;<br class="title-page-name"/>  &lt;/Waveform&gt;<br class="title-page-name"/>  &lt;StackLayout class="p-5"&gt;<br class="title-page-name"/>    &lt;FlexboxLayout class="controls"&gt;<br class="title-page-name"/>      &lt;Button text="Rewind" class="btn text-center" <br class="title-page-name"/>        (tap)="recorderService.rewind()" <br class="title-page-name"/>        [isEnabled]="state == recordState.readyToPlay || state == recordState.playing"&gt;<br class="title-page-name"/>      &lt;/Button&gt;<br class="title-page-name"/>      &lt;Button [text]="recordBtn" class="btn text-center" <br class="title-page-name"/>        (tap)="recorderService.toggleRecord()" <br class="title-page-name"/>        [isEnabled]="state != recordState.playing"&gt;&lt;/Button&gt;<br class="title-page-name"/>      &lt;Button [text]="playBtn" class="btn text-center" <br class="title-page-name"/>        (tap)="recorderService.togglePlay()" <br class="title-page-name"/>        [isEnabled]="state == recordState.readyToPlay || state == recordState.playing"&gt;<br class="title-page-name"/>      &lt;/Button&gt;<br class="title-page-name"/>    &lt;/FlexboxLayout&gt;<br class="title-page-name"/>    &lt;FlexboxLayout class="controls bottom" <br class="title-page-name"/>      [class.recording]="state == recordState.recording"&gt;<br class="title-page-name"/>      &lt;Button text="Save" class="btn" <br class="title-page-name"/>        [class.save-ready]="state == recordState.readyToPlay" <br class="title-page-name"/>        [isEnabled]="state == recordState.readyToPlay"<br class="title-page-name"/>        (tap)="recorderService.save()"&gt;&lt;/Button&gt;<br class="title-page-name"/>    &lt;/FlexboxLayout&gt;<br class="title-page-name"/>  &lt;/StackLayout&gt;<br class="title-page-name"/>&lt;/FlexboxLayout&gt;</pre>
<p class="mce-root">We are using <kbd class="calibre11">FlexboxLayout</kbd> because we want our Waveform view to stretch to cover the full available vertical space, leaving only the recorder's controls positioned at the bottom. <kbd class="calibre11">FlexboxLayout</kbd> is a very versatile layout container, which provides most of the same CSS styling attributes found with the the flexbox model on the web.</p>
<p class="mce-root">Interestingly, we show a <span>Cancel</span> button inside a <kbd class="calibre11">GridLayout</kbd> container only when displayed as a modal, since we need a way to close the modal. ActionBars are ignored and not displayed when the view is opened via a modal.</p>
<div class="packt_infobox">ActionBars are ignored when the view is opened via a modal, so they are not displayed in the modal. <kbd class="calibre29">ActionBar</kbd> is shown on navigated views only.</div>
<p class="mce-root">Furthermore, our <kbd class="calibre11">ActionBar</kbd> setup is rather interesting here and is one of the areas of NativeScript view layouts where iOS and Android differ the most. On iOS, <kbd class="calibre11">NavigationButton</kbd> has a default behavior, that automatically pops the view from the stack and animates back to the previous view. Additionally, any tap events on <kbd class="calibre11">NavigationButton</kbd> on iOS are completely ignored, whereas on Android, the tap event is triggered on <kbd class="calibre11">NavigationButton</kbd>. Because of this crucial difference, we want to completely ignore <kbd class="calibre11">NavigationButton</kbd> of <span><kbd class="calibre11">ActionBar</kbd> </span>by using <kbd class="calibre11">visibility="collapsed"</kbd> to ensure it is never shown. Instead, we use <kbd class="calibre11">ActionItem</kbd> with an explicit tap event to ensure the correct logic is triggered on our component for both platforms.</p>
<div class="packt_infobox"><kbd class="calibre29">NavigationButton</kbd> behavior on iOS and Android is different:<br class="calibre24"/>
<ul class="calibre39">
<li class="calibre38"><strong class="calibre27">iOS</strong>: <kbd class="calibre29">NavigationButton</kbd> ignores (tap) events, and this button appears by default when navigating to a view.</li>
</ul>
<ul class="calibre39">
<li class="calibre38"><strong class="calibre27">Android</strong>: <kbd class="calibre29">NavigationButton</kbd> (tap) events are triggered.</li>
</ul>
</div>
<p class="mce-root">You can see our Waveform (the custom NativeScript) view in use here. We use Angular's binding syntax when binding the model, since it's an object. For the other properties, we specify their values directly, since they are primitive values. We could, however, use Angular's binding syntax on those as well if we wanted to change those values dynamically via user interaction. For example, we could show a fun color picker, which would allow the user to change the color (<kbd class="calibre11">plotColor</kbd>) of the waveform on the fly.</p>
<p class="mce-root">We'll provide a component-specific stylesheet for our record component, <kbd class="calibre11">app/modules/recorder/components/record.component.css</kbd>:</p>
<pre class="calibre22">.record {<br class="title-page-name"/>  background-color: rgba(0,0,0,.5);<br class="title-page-name"/>  flex-direction: column;<br class="title-page-name"/>  justify-content: space-around;<br class="title-page-name"/>  align-items: stretch;<br class="title-page-name"/>  align-content: center;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>.record .waveform {<br class="title-page-name"/>  background-color: transparent;<br class="title-page-name"/>  order: 1;<br class="title-page-name"/>  flex-grow: 1;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>.controls {<br class="title-page-name"/>  width: 100%;<br class="title-page-name"/>  height: 200;<br class="title-page-name"/>  flex-direction: row;<br class="title-page-name"/>  flex-wrap: nowrap;<br class="title-page-name"/>  justify-content: center;<br class="title-page-name"/>  align-items: center;<br class="title-page-name"/>  align-content: center;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>.controls.bottom {<br class="title-page-name"/>  height: 90;<br class="title-page-name"/>  justify-content: flex-end;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>.controls.bottom.recording {<br class="title-page-name"/>  background-color: #B0342D;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>.controls.bottom .btn {<br class="title-page-name"/>  border-radius: 40;<br class="title-page-name"/>  height: 62;<br class="title-page-name"/>  padding: 2;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>.controls.bottom .btn.save-ready {<br class="title-page-name"/>  background-color: #42B03D;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>.controls .btn {<br class="title-page-name"/>  color: #fff;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>.controls .btn[isEnabled=false] {<br class="title-page-name"/>  background-color: transparent;<br class="title-page-name"/>  color: #777;<br class="title-page-name"/>}</pre>
<p class="mce-root">Some of these CSS properties may look familiar if you've used the flexbox model on the web. A great and fun resource to learn more about flexbox styling is Flexbox Zombies by Dave Geddes: <a href="http://flexboxzombies.com." class="calibre3">http://flexboxzombies.com</a>.</p>
<p class="mce-root">At this point, our CSS is starting to grow and we could clean things up a lot with SASS. We will do exactly that, coming up soon, so hang in there! </p>
<p class="mce-root">Now, let's take a look at the Component at <kbd class="calibre11">app/modules/recorder/components/record.component.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component, OnInit, OnDestroy, Optional } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// libs<br class="title-page-name"/>import { Subscription } from 'rxjs/Subscription';<br class="title-page-name"/><br class="title-page-name"/>// nativescript<br class="title-page-name"/>import { RouterExtensions } from 'nativescript-angular/router';<br class="title-page-name"/>import { ModalDialogParams } from 'nativescript-angular/directives/dialogs';<br class="title-page-name"/>import { isIOS } from 'platform';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { RecordModel, RecordState } from '../models';<br class="title-page-name"/>import { RecorderService } from '../services/recorder.service';<br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/>  moduleId: module.id,<br class="title-page-name"/>  selector: 'record',<br class="title-page-name"/>  templateUrl: 'record.component.html',<br class="title-page-name"/>  styleUrls: ['record.component.css']<br class="title-page-name"/>})<br class="title-page-name"/>export class RecordComponent implements OnInit, OnDestroy { <br class="title-page-name"/>  public isModal: boolean;<br class="title-page-name"/>  public recordBtn: string = 'Record';<br class="title-page-name"/>  public playBtn: string = 'Play';<br class="title-page-name"/>  public state: number;<br class="title-page-name"/>  public recordState: any = {};<br class="title-page-name"/><br class="title-page-name"/>  private _sub: Subscription;<br class="title-page-name"/><br class="title-page-name"/>  constructor(<br class="title-page-name"/>    private router: RouterExtensions,<br class="title-page-name"/>    @Optional() private params: ModalDialogParams,<br class="title-page-name"/>    public recorderService: RecorderService<br class="title-page-name"/>  ) { <br class="title-page-name"/>    // prepare service for brand new recording<br class="title-page-name"/>    recorderService.setupNewRecording();<br class="title-page-name"/><br class="title-page-name"/>    // use RecordState enum names as reference in view<br class="title-page-name"/>    for (let val in RecordState ) {<br class="title-page-name"/>      if (isNaN(parseInt(val))) {<br class="title-page-name"/>        this.recordState[val] = RecordState[val];<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  ngOnInit() {<br class="title-page-name"/>    if (this.params &amp;&amp; this.params.context.isModal) {<br class="title-page-name"/>      this.isModal = true;<br class="title-page-name"/>    }<br class="title-page-name"/>    this._sub = this.recorderService.state$.subscribe((state: number) =&gt; {<br class="title-page-name"/>      this.state = state;<br class="title-page-name"/>      switch (state) {<br class="title-page-name"/>        case RecordState.readyToRecord:<br class="title-page-name"/>        case RecordState.readyToPlay:<br class="title-page-name"/>          this._resetState();<br class="title-page-name"/>          break;<br class="title-page-name"/>        case RecordState.playing:<br class="title-page-name"/>          this.playBtn = 'Pause';<br class="title-page-name"/>          break;<br class="title-page-name"/>        case RecordState.recording:<br class="title-page-name"/>          this.recordBtn = 'Stop';<br class="title-page-name"/>          break;<br class="title-page-name"/>        case RecordState.finish:<br class="title-page-name"/>          this._cleanup();<br class="title-page-name"/>          break;<br class="title-page-name"/>      }<br class="title-page-name"/>    });<br class="title-page-name"/>  }<br class="title-page-name"/> <br class="title-page-name"/>  ngOnDestroy() {<br class="title-page-name"/>    if (this._sub) this._sub.unsubscribe();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public cancel() {<br class="title-page-name"/>    this._cleanup();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _cleanup() {<br class="title-page-name"/>    this.recorderService.cleanup();<br class="title-page-name"/>    invokeOnRunLoop(() =&gt; {<br class="title-page-name"/>      if (this.isModal) {<br class="title-page-name"/>        this._close();<br class="title-page-name"/>      } else {<br class="title-page-name"/>        this._back();<br class="title-page-name"/>      }<br class="title-page-name"/>    });<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _close() {<br class="title-page-name"/>    this.params.closeCallback();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _back() {<br class="title-page-name"/>    this.router.back();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _resetState() {<br class="title-page-name"/>    this.recordBtn = 'Record';<br class="title-page-name"/>    this.playBtn = 'Play';<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>/**<br class="title-page-name"/> * Needed on iOS to prevent this potential exception:<br class="title-page-name"/> * "This application is modifying the autolayout engine from a background thread after the engine was accessed from the main thread. This can lead to engine corruption and weird crashes."<br class="title-page-name"/> */<br class="title-page-name"/>const invokeOnRunLoop = (function () {<br class="title-page-name"/>  if (isIOS) {<br class="title-page-name"/>    var runloop = CFRunLoopGetMain();<br class="title-page-name"/>    return function(func) {<br class="title-page-name"/>      CFRunLoopPerformBlock(runloop, kCFRunLoopDefaultMode, func);<br class="title-page-name"/>      CFRunLoopWakeUp(runloop);<br class="title-page-name"/>    }<br class="title-page-name"/>  } else {<br class="title-page-name"/>    return function (func) {<br class="title-page-name"/>      func();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}());</pre>
<p class="mce-root">Starting from the bottom of that file, you'll probably wonder what the heck <kbd class="calibre11">invokeOnRunLoop</kbd> is<em class="calibre21">.</em> This is a handy way to ensure thread safety in conditions where the thread might rear its ugly head. In this case, AudioKit's engine is started from the UI thread in <kbd class="calibre11">RecordModel</kbd>, since NativeScript marshals native calls on the UI thread. However, when our record view closes (whether it be from a modal our navigating back), some background threads are invoked. Wrapping our handling of closing this view with <kbd class="calibre11">invokeOnRunLoop</kbd> helps solve this transient exception. It's the answer to how to use iOS <kbd class="calibre11">dispatch_async(dispatch_get_main_queue(…))</kbd> with NativeScript.</p>
<p class="mce-root">Working our way up the file, we'll encounter <kbd class="calibre11">this.recorderService.state$.subscribe((state: number) =&gt; …</kbd>. In a moment, we'll be implementing a way to observe the recording <kbd class="calibre11">state$</kbd> as an observable, so our view can simply react to its state changes.</p>
<p class="mce-root">Also of note, it is a handy way to collapse <kbd class="calibre11">RecordState enum</kbd> into properties we can use as view bindings to compare against the current state (<kbd class="calibre11">this.state = state;</kbd>).</p>
<p class="mce-root">When the component is constructed, <kbd class="calibre11">recorderService.setupNewRecording()</kbd> will prepare our service for a brand new recording each time this view appears.</p>
<p class="mce-root">Lastly, take note of the injection of <kbd class="calibre11">@Optional()<strong class="calibre1"> </strong>private params: ModalDialogParams</kbd><em class="calibre21">.</em> Earlier, we mentioned that <em class="calibre21">it would be nice to reuse this record view in a modal popup</em>. The interesting part is that <kbd class="calibre11">ModalDialogParams</kbd> is only provided to a component when it is opened in a modal. In other words, Angular's dependency injection doesn't know anything about a <kbd class="calibre11">ModalDialogParams</kbd> service unless the component is explicitly opened via NativeScript's <kbd class="calibre11">ModalService</kbd>, so this would break our ability to route to this component as we had originally set up, since Angular's DI would fail to recognize such a provider by default. In order to allow this component to continue working as a routing component, we will simply mark that argument as <kbd class="calibre11">@Optional()</kbd>, which will just set its value to null when not available instead of throwing a dependency injection error.</p>
<p class="mce-root">This will allow our component to be routed to, as well as be opened in a modal! Reuse in full swing!</p>
<p class="mce-root">In order to conditionally navigate to this component via routing, or open it in a modal, we can make a few small adjustments, bearing in mind that <kbd class="calibre11">RecorderModule</kbd> is lazy loaded, so we'll want to lazily load the module before opening it as a modal.</p>
<p class="mce-root">Open <kbd class="calibre11">app/modules/mixer/components/action-bar/action-bar.component.ts</kbd> and make the following modifications:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component, Input, <strong class="calibre1">Output, EventEmitter</strong> } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// nativescript<br class="title-page-name"/><strong class="calibre1">import { RouterExtensions } from 'nativescript-angular/router';</strong> <br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">import { PlayerService } from '../../../player/services/player.service';</strong><br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/>  moduleId: module.id,<br class="title-page-name"/>  selector: 'action-bar',<br class="title-page-name"/>  templateUrl: 'action-bar.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class ActionBarComponent {<br class="title-page-name"/>  ...<br class="title-page-name"/>  <strong class="calibre1">@Output() showRecordModal: EventEmitter&lt;any&gt; = new EventEmitter();</strong><br class="title-page-name"/>  ...<br class="title-page-name"/>  constructor(<br class="title-page-name"/>    <strong class="calibre1">private router: RouterExtensions,</strong><br class="title-page-name"/><strong class="calibre1">    private playerService: PlayerService</strong><br class="title-page-name"/>  ) { }<br class="title-page-name"/>  <br class="title-page-name"/>  <strong class="calibre1">public record() {</strong><br class="title-page-name"/><strong class="calibre1">    if (this.playerService.composition &amp;&amp;    </strong><br class="title-page-name"/><strong class="calibre1">        this.playerService.composition.tracks.length) {</strong><br class="title-page-name"/>      // display recording UI as modal<br class="title-page-name"/><strong class="calibre1">      this.showRecordModal.next();</strong><br class="title-page-name"/><strong class="calibre1">    } else {</strong><br class="title-page-name"/>      // navigate to it<br class="title-page-name"/><strong class="calibre1">      this.router.navigate(['/record']);</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>}</pre>
<p class="mce-root">Here, we conditionally emit an event using <kbd class="calibre11">EventEmitter</kbd> with a Component <kbd class="calibre11">Output</kbd> decorator if the composition contains tracks; otherwise we navigate to the record view. We then adjust <kbd class="calibre11">Button</kbd> in the view template to use the method:</p>
<pre class="calibre22">&lt;ActionItem <strong class="calibre1">(tap)="record()"</strong> ios.position="right"&gt;<br class="title-page-name"/>  &lt;Button text="Record" class="action-item"&gt;&lt;/Button&gt;<br class="title-page-name"/>&lt;/ActionItem&gt;</pre>
<p class="mce-root">We can now modify <kbd class="calibre11">app/modules/mixer/components/mixer.component.html</kbd> to use <kbd class="calibre11">Output</kbd> by its name as a normal event:</p>
<pre class="calibre22">&lt;action-bar [title]="composition.name" <strong class="calibre1">(showRecordModal)="showRecordModal()"</strong>&gt;&lt;/action-bar&gt;<br class="title-page-name"/>&lt;GridLayout rows="*, auto" columns="*" class="page"&gt;<br class="title-page-name"/>  &lt;track-list [tracks]="composition.tracks" row="0" col="0"&gt;&lt;/track-list&gt;<br class="title-page-name"/>  &lt;player-controls [composition]="composition" row="1" col="0"&gt;&lt;/player-controls&gt;<br class="title-page-name"/>&lt;/GridLayout&gt;</pre>
<p class="mce-root">Now for the fun part. Since we'd love to be able to open any component in a modal, whether it's part of a lazy loaded module or not, let's add a new method to <kbd class="calibre11">DialogService</kbd> that can be used anywhere.</p>
<p class="mce-root">Make the following changes to <kbd class="calibre11">app/modules/core/services/dialog.service.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Injectable, <strong class="calibre1">NgModuleFactory, NgModuleFactoryLoader, ViewContainerRef, NgModuleRef</strong> } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// nativescript<br class="title-page-name"/>import * as dialogs from 'ui/dialogs';<br class="title-page-name"/><strong class="calibre1">import { ModalDialogService } from 'nativescript-angular/directives/dialogs';</strong><br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class DialogService {<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">constructor(</strong><br class="title-page-name"/><strong class="calibre1">    private moduleLoader: NgModuleFactoryLoader,</strong><br class="title-page-name"/><strong class="calibre1">    private modalService: ModalDialogService</strong><br class="title-page-name"/><strong class="calibre1">  ) { }</strong><br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public openModal(componentType: any, vcRef: ViewContainerRef, context?: any, modulePath?: string): Promise&lt;any&gt; {</strong><br class="title-page-name"/><strong class="calibre1">    return new Promise((resolve, reject) =&gt; {</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">      const launchModal = (moduleRef?: NgModuleRef&lt;any&gt;) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">        this.modalService.showModal(componentType, {</strong><br class="title-page-name"/><strong class="calibre1">          moduleRef,</strong><br class="title-page-name"/><strong class="calibre1">          viewContainerRef: vcRef,</strong><br class="title-page-name"/><strong class="calibre1">          context</strong><br class="title-page-name"/><strong class="calibre1">        }).then(resolve, reject);</strong><br class="title-page-name"/><strong class="calibre1">      };</strong><br class="title-page-name"/><br class="title-page-name"/>      <strong class="calibre1">if (modulePath) {</strong><br class="title-page-name"/>        // lazy load module which contains component to open in modal<br class="title-page-name"/>        <strong class="calibre1">this.moduleLoader.load(modulePath)</strong><br class="title-page-name"/><strong class="calibre1">          .then((module: NgModuleFactory&lt;any&gt;) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">            launchModal(module.create(vcRef.parentInjector));</strong><br class="title-page-name"/><strong class="calibre1">          });</strong><br class="title-page-name"/><strong class="calibre1">      } else {</strong><br class="title-page-name"/>        // open component in modal known to be available without lazy loading<br class="title-page-name"/>        <strong class="calibre1">launchModal();</strong><br class="title-page-name"/><strong class="calibre1">      }</strong><br class="title-page-name"/><strong class="calibre1">    });</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>  ...<br class="title-page-name"/>}</pre>
<p class="mce-root">Here, we inject <kbd class="calibre11">ModalDialogService</kbd> and <kbd class="calibre11">NgModuleFactoryLoader</kbd> (which is actually <kbd class="calibre11">NSModuleFactoryLoader</kbd>, since, if you recall, we provided for in <a href="part0064.html#1T1400-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 5</a>, <em class="calibre21">Routing and Lazy Loading</em>) to load any module on demand to open a Component (declared in that lazy loaded module) in a modal. <em class="calibre21">It also works for components that do not need to be lazy loaded</em>. In other words, it will optionally lazily load any module by its path, if provided, and then use its <kbd class="calibre11">NgModuleFactory</kbd> to get a module reference, which we can pass along as an option (via the <kbd class="calibre11">moduleRef</kbd> key) to <kbd class="calibre11">this.modalService.showModal</kbd> to open a Component declared in that lazily-loaded module. </p>
<p class="mce-root">This will come in handy again later; however, let's put it to use now by making the following changes to <kbd class="calibre11">app/modules/mixer/components/mixer.component.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component, OnInit, OnDestroy, <strong class="calibre1">ViewContainerRef</strong> } from '@angular/core';<br class="title-page-name"/>import { ActivatedRoute } from '@angular/router';<br class="title-page-name"/>import { Subscription } from 'rxjs/Subscription';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/><strong class="calibre1">import { DialogService } from '../../core/services/dialog.service';</strong><br class="title-page-name"/>import { MixerService } from '../services/mixer.service';<br class="title-page-name"/>import { CompositionModel } from '../../shared/models';<br class="title-page-name"/><strong class="calibre1">import { RecordComponent } from '../../recorder/components/record.component';</strong><br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/> moduleId: module.id,<br class="title-page-name"/> selector: 'mixer',<br class="title-page-name"/> templateUrl: 'mixer.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class MixerComponent implements OnInit, OnDestroy {<br class="title-page-name"/><br class="title-page-name"/>  public composition: CompositionModel;<br class="title-page-name"/>  private _sub: Subscription;<br class="title-page-name"/><br class="title-page-name"/>  constructor(<br class="title-page-name"/>    private route: ActivatedRoute,<br class="title-page-name"/>    private mixerService: MixerService,<br class="title-page-name"/>    <strong class="calibre1">private dialogService: DialogService,</strong><br class="title-page-name"/><strong class="calibre1">    private vcRef: ViewContainerRef</strong><br class="title-page-name"/>  ) { }<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public showRecordModal() {</strong><br class="title-page-name"/><strong class="calibre1">    this.dialogService.openModal(<br class="title-page-name"/>      RecordComponent,<br class="title-page-name"/>      this.vcRef,<br class="title-page-name"/>      { isModal: true },<br class="title-page-name"/>      './modules/recorder/recorder.module#RecorderModule'<br class="title-page-name"/>    );</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>  ...<br class="title-page-name"/>}</pre>
<p class="mce-root">This will lazily load <kbd class="calibre11">RecorderModule</kbd> and then open <kbd class="calibre11">RecordComponent</kbd> in a popup modal. Cool!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Finishing implementation with RecorderService</h1>
                
            
            <article>
                
<p class="mce-root">Now, let's finish this implementation with <kbd class="calibre11">RecorderService</kbd> in <kbd class="calibre11">app/modules/recorder/services/recorder.service.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Injectable } from '@angular/core';<br class="title-page-name"/>import { Subject } from 'rxjs/Subject';<br class="title-page-name"/>import { Subscription } from 'rxjs/Subscription';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { DialogService } from '../../core/services/dialog.service';<br class="title-page-name"/>import { RecordModel, RecordState } from '../models';<br class="title-page-name"/>import { PlayerService } from '../../player/services/player.service';<br class="title-page-name"/>import { TrackModel } from '../../shared/models/track.model';<br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class RecorderService {<br class="title-page-name"/>  public state$: Subject&lt;number&gt; = new Subject();<br class="title-page-name"/>  public model: RecordModel;<br class="title-page-name"/>  private _trackId: number;<br class="title-page-name"/>  private _sub: Subscription;<br class="title-page-name"/><br class="title-page-name"/>  constructor(<br class="title-page-name"/>    private playerService: PlayerService,<br class="title-page-name"/>    private dialogService: DialogService<br class="title-page-name"/>  ) { } <br class="title-page-name"/> <br class="title-page-name"/>  public setupNewRecording() {<br class="title-page-name"/>    this.model = new RecordModel();<br class="title-page-name"/>    this._trackId = undefined; // reset<br class="title-page-name"/><br class="title-page-name"/>    this.model.on(this.model.events.stateChange, this._stateHandler.bind(this));<br class="title-page-name"/>    this._sub = this.playerService.complete$.subscribe(_ =&gt; {<br class="title-page-name"/>      this.model.stopPlayback();<br class="title-page-name"/>    });<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public toggleRecord() {<br class="title-page-name"/>    this.model.toggleRecord();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public togglePlay() {<br class="title-page-name"/>    this.model.togglePlay();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public rewind() {<br class="title-page-name"/>    this.playerService.seekTo(0); // reset to 0<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public save() {<br class="title-page-name"/>    this.model.save();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public cleanup() {<br class="title-page-name"/>    // unbind event listener<br class="title-page-name"/>    this.model.off(this.model.events.stateChange, this._stateHandler.bind(this));<br class="title-page-name"/>    this._sub.unsubscribe();<br class="title-page-name"/><br class="title-page-name"/>    if (!this.model.savedFilePath) {<br class="title-page-name"/>      // user did not save recording, cleanup<br class="title-page-name"/>      this.playerService.removeTrack(this._trackId);<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _stateHandler(e) {<br class="title-page-name"/>    this.state$.next(e.data);<br class="title-page-name"/><br class="title-page-name"/>    switch (e.data) {<br class="title-page-name"/>      case RecordState.readyToRecord:<br class="title-page-name"/>        this._stopMix();<br class="title-page-name"/>        break; <br class="title-page-name"/>      case RecordState.readyToPlay:<br class="title-page-name"/>        this._stopMix();<br class="title-page-name"/>        this._trackId = this.playerService<br class="title-page-name"/>          .updateCompositionTrack(this._trackId, this.model.audioFilePath);<br class="title-page-name"/>        break;<br class="title-page-name"/>      case RecordState.playing:<br class="title-page-name"/>        this._playMix();<br class="title-page-name"/>        break;<br class="title-page-name"/>      case RecordState.recording:<br class="title-page-name"/>        this._playMix(this._trackId);<br class="title-page-name"/>        break;<br class="title-page-name"/>      case RecordState.saved:<br class="title-page-name"/>        this._handleSaved();<br class="title-page-name"/>        break;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _playMix(excludeTrackId?: number) {<br class="title-page-name"/>    if (!this.playerService.playing) {<br class="title-page-name"/>      // ensure mix plays<br class="title-page-name"/>      this.playerService.togglePlay(excludeTrackId);<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _stopMix() {<br class="title-page-name"/>    if (this.playerService.playing) {<br class="title-page-name"/>      // ensure mix stops<br class="title-page-name"/>      this.playerService.togglePlay();<br class="title-page-name"/>    }<br class="title-page-name"/>    // always reset to beginning<br class="title-page-name"/>    this.playerService.seekTo(0);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _handleSaved() {<br class="title-page-name"/>    this._sub.unsubscribe();<br class="title-page-name"/>    this._stopMix();<br class="title-page-name"/>    this.playerService<br class="title-page-name"/>      .updateCompositionTrack(this._trackId, this.model.savedFilePath);<br class="title-page-name"/>    this.playerService.saveComposition();<br class="title-page-name"/>    this.model.finish();<br class="title-page-name"/>  } <br class="title-page-name"/>}</pre>
<p class="mce-root">The pinnacle of our recording service is its ability to react to the model's state changes. This, in turn, emits an Observable stream notifying observers (our <kbd class="calibre11">RecordComponent</kbd>) when the state changes, as well as internally doing the work necessary to control <kbd class="calibre11">RecordModel</kbd> along with <kbd class="calibre11">PlayerService</kbd>. The critical key to our design is we want our active composition's tracks to play in the background while we record, so we can play along with the mix. This case is important:</p>
<pre class="calibre22">case RecordState.readyToPlay:<br class="title-page-name"/>  this._stopMix();<br class="title-page-name"/>  this._trackId = this.playerService<br class="title-page-name"/>    .updateCompositionTrack(this._trackId, this.model.audioFilePath);<br class="title-page-name"/>  break;</pre>
<p class="mce-root">When <kbd class="calibre11">RecordModel</kbd> is <kbd class="calibre11">readyToPlay</kbd>, we know that a recording has been created and is now ready to play. We stop the playing mix, get a reference to the recorded file's path. Then, we update <kbd class="calibre11">PlayerService</kbd> to queue up this new track to be played back. We will show the updated <kbd class="calibre11">PlayerService</kbd> in a moment, which handles adding the new file to the mix, but it adds a new <kbd class="calibre11">TrackPlayer</kbd> like everything else in our mix. However, the file points to a temporary recorded file at the moment, as we don't want to save the composition until the user decides to officially commit and save the recording. The recording session will allow the user to re-record again if they are not happy with the recording. This is why we hold a reference to <kbd class="calibre11">_trackId</kbd>. If a recording had already been added to the mix, we use that <kbd class="calibre11">_trackId</kbd> to exclude it when re-recording, since we would not want to hear back the recording we are re-recording over:</p>
<pre class="calibre22">case RecordState.recording:<br class="title-page-name"/>  this._playMix(this._trackId);<br class="title-page-name"/>  break;</pre>
<p class="mce-root">We also use it to clean up after ourselves if the user chose to cancel instead of saving:</p>
<pre class="calibre22">public cleanup() {<br class="title-page-name"/>  // unbind event listener<br class="title-page-name"/>  this.model.off(this.model.events.stateChange, this._stateHandler.bind(this));<br class="title-page-name"/>  this._sub.unsubscribe();<br class="title-page-name"/><br class="title-page-name"/>  if (!this.model.savedFilePath) {<br class="title-page-name"/>    // user did not save recording, cleanup<br class="title-page-name"/>    this.playerService.removeTrack(this._trackId);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">Let's take a look at the <span>modifications to</span> <kbd class="calibre11">PlayerService</kbd> we need to make in order to support our recording:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">import { MixerService } from '../../mixer/services/mixer.service';</strong><br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class PlayerService {<br class="title-page-name"/><br class="title-page-name"/>  // default name of new tracks<br class="title-page-name"/>  <strong class="calibre1">private _defaultTrackName: string = 'New Track';</strong><br class="title-page-name"/>  ...<br class="title-page-name"/>  constructor(<br class="title-page-name"/>    private ngZone: NgZone,<br class="title-page-name"/>    <strong class="calibre1">private mixerService: MixerService</strong><br class="title-page-name"/>  ) { ... }<br class="title-page-name"/>  ...<br class="title-page-name"/>  <strong class="calibre1">public saveComposition() {</strong><br class="title-page-name"/><strong class="calibre1">    this.mixerService.save(this.composition);</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/>  public togglePlay(<strong class="calibre1">excludeTrackId?: number</strong>) {<br class="title-page-name"/>    if (this._trackPlayers.length) {<br class="title-page-name"/>      this.playing = !this.playing;<br class="title-page-name"/>      if (this.playing) {<br class="title-page-name"/>        this.play(<strong class="calibre1">excludeTrackId</strong>);<br class="title-page-name"/>      } else {<br class="title-page-name"/>        this.pause();<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public play(<strong class="calibre1">excludeTrackId?: number</strong>) {<br class="title-page-name"/>    // for iOS playback sync<br class="title-page-name"/>    let shortStartDelay = .01;<br class="title-page-name"/>    let now = 0;<br class="title-page-name"/><br class="title-page-name"/>    for (let i = 0; i &lt; this._trackPlayers.length; i++) {<br class="title-page-name"/>      let track = this._trackPlayers[i];<br class="title-page-name"/>      <strong class="calibre1">if (excludeTrackId !== track.trackId) {</strong><br class="title-page-name"/>        if (isIOS) {<br class="title-page-name"/>          if (i == 0) now = track.player.ios.deviceCurrentTime;<br class="title-page-name"/>          (&lt;any&gt;track.player).playAtTime(now + shortStartDelay);<br class="title-page-name"/>        } else {<br class="title-page-name"/>          track.player.play();<br class="title-page-name"/>        }<br class="title-page-name"/>      <strong class="calibre1">}</strong><br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public addTrack(track: ITrack): Promise&lt;any&gt; {</strong><br class="title-page-name"/><strong class="calibre1">    return new Promise((resolve, reject) =&gt; {</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">      let trackPlayer = this._trackPlayers.find((p) =&gt; p.trackId === track.id);</strong><br class="title-page-name"/><strong class="calibre1">      if (!trackPlayer) {</strong><br class="title-page-name"/>        // new track<br class="title-page-name"/><strong class="calibre1">        trackPlayer = new TrackPlayerModel();</strong><br class="title-page-name"/><strong class="calibre1">        this._composition.tracks.push(track);</strong><br class="title-page-name"/><strong class="calibre1">        this._trackPlayers.push(trackPlayer);</strong><br class="title-page-name"/><strong class="calibre1">      } else {</strong><br class="title-page-name"/>        // update track<br class="title-page-name"/><strong class="calibre1">        this.updateTrack(track);</strong><br class="title-page-name"/><strong class="calibre1">      }</strong><br class="title-page-name"/> <br class="title-page-name"/><strong class="calibre1">      trackPlayer.load(</strong><br class="title-page-name"/><strong class="calibre1">        track,</strong><br class="title-page-name"/><strong class="calibre1">        this._trackComplete.bind(this),</strong><br class="title-page-name"/><strong class="calibre1">        this._trackError.bind(this)</strong><br class="title-page-name"/><strong class="calibre1">      ).then(_ =&gt; {</strong><br class="title-page-name"/>        // report longest duration as totalDuration<br class="title-page-name"/><strong class="calibre1">        this._updateTotalDuration();</strong><br class="title-page-name"/><strong class="calibre1">        resolve();</strong><br class="title-page-name"/><strong class="calibre1">      });</strong><br class="title-page-name"/><strong class="calibre1">    })</strong><br class="title-page-name"/><strong class="calibre1">  }<br class="title-page-name"/><br class="title-page-name"/></strong>  <strong class="calibre1">public updateCompositionTrack(trackId: number, filepath: string): number {</strong><br class="title-page-name"/><strong class="calibre1">    let track;</strong><br class="title-page-name"/><strong class="calibre1">    if (!trackId) {</strong><br class="title-page-name"/>      // Create a new track<br class="title-page-name"/><strong class="calibre1">      let cnt = this._defaultTrackNamesCnt();</strong><br class="title-page-name"/><strong class="calibre1">      track = new TrackModel({</strong><br class="title-page-name"/><strong class="calibre1">        name: `${this._defaultTrackName}${cnt ? ' ' + (cnt + 1) : ''}`,</strong><br class="title-page-name"/><strong class="calibre1">        order: this.composition.tracks.length,</strong><br class="title-page-name"/><strong class="calibre1">        filepath</strong><br class="title-page-name"/><strong class="calibre1">      });</strong><br class="title-page-name"/><strong class="calibre1">      trackId = track.id;</strong><br class="title-page-name"/><strong class="calibre1">    } else {</strong><br class="title-page-name"/>      // find by id and update<strong class="calibre1"> </strong><br class="title-page-name"/><strong class="calibre1">      track = this.findTrack(trackId);</strong><br class="title-page-name"/><strong class="calibre1">      track.filepath = filepath;</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">    this.addTrack(track);</strong><br class="title-page-name"/><strong class="calibre1">    return trackId;</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">private _defaultTrackNamesCnt() {</strong><br class="title-page-name"/><strong class="calibre1">    return this.composition.tracks</strong><br class="title-page-name"/><strong class="calibre1">      .filter(t =&gt; t.name.startsWith(this._defaultTrackName)).length;</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>  ...</pre>
<p class="mce-root">These changes will support our recorder's ability to interact with the active composition. </p>
<div class="packt_tip"> Note: Considerations when reusing a Component to lazy load in a modal as well as allow lazy loading via routing.</div>
<p class="mce-root">Angular services must be provided <em class="calibre21">only</em> at the <em class="calibre21">root</em> level <em class="calibre21">if they are intended to be singletons</em> shared across all lazy loaded modules, as well as the root module. <kbd class="calibre11">RecorderService</kbd> is lazy loaded with <kbd class="calibre11">RecordModule</kbd> when it is navigated to, as well as being opened in a modal. Since we are now injecting <kbd class="calibre11">PlayerService</kbd> into our <kbd class="calibre11">RecorderService</kbd> (which is lazily loaded) and <kbd class="calibre11">PlayerService</kbd> now injects <kbd class="calibre11">MixerService</kbd> (which is also lazily loaded as the root route in our app), we will have to create a problem where our services are no longer singletons. In fact, you may even see an error like this if you were to try and navigate to <kbd class="calibre11">RecordComponent</kbd>:</p>
<div class="packt_quote">JS: ERROR Error: Uncaught (in promise): Error: No provider for PlayerService!</div>
<p class="mce-root">To solve this, we will drop the providers from <kbd class="calibre11">PlayerModule</kbd> and <kbd class="calibre11">MixerModule</kbd> (since those modules are both lazily loaded) and instead provide those services only in our <kbd class="calibre11">CoreModule</kbd>:</p>
<p class="mce-root">The modified <kbd class="calibre11">app/modules/player/player.module.ts</kbd> is as follows:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">//</strong> import { PROVIDERS } from './services'; <strong class="calibre1">// commented out now</strong><br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/> ...<br class="title-page-name"/> <strong class="calibre1">//</strong> providers: [...PROVIDERS], <strong class="calibre1">// no longer provided here</strong><br class="title-page-name"/> ...<br class="title-page-name"/>})<br class="title-page-name"/>export class <strong class="calibre1">PlayerModule</strong> {}</pre>
<p class="mce-root">The modified <kbd class="calibre11">app/modules/mixer/mixer.module.ts</kbd> is as follows:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">//</strong> import { PROVIDERS } from './services'; <strong class="calibre1">// commented out now</strong><br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/> ...<br class="title-page-name"/> <strong class="calibre1">//</strong> providers: [...PROVIDERS], <strong class="calibre1">// no longer provided here</strong><br class="title-page-name"/> ...<br class="title-page-name"/>})<br class="title-page-name"/>export class <strong class="calibre1">MixerModule</strong> {}</pre>
<p class="mce-root">Updated to provide these services as true singletons from <kbd class="calibre11">CoreModule</kbd> only, the code for <kbd class="calibre11">app/modules/core/core.module.ts</kbd> is as follows:</p>
<pre class="calibre22">...<br class="title-page-name"/>import { PROVIDERS } from './services';<br class="title-page-name"/><strong class="calibre1">import { PROVIDERS as MIXER_PROVIDERS } from '../mixer/services';</strong><br class="title-page-name"/><strong class="calibre1">import { PROVIDERS as PLAYER_PROVIDERS } from '../player/services';</strong><br class="title-page-name"/><br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  ...<br class="title-page-name"/>  providers: [<br class="title-page-name"/>    ...PROVIDERS,<br class="title-page-name"/>    <strong class="calibre1">...MIXER_PROVIDERS,</strong><br class="title-page-name"/><strong class="calibre1">    ...PLAYER_PROVIDERS</strong><br class="title-page-name"/>  ],<br class="title-page-name"/>  ...<br class="title-page-name"/>})<br class="title-page-name"/>export class CoreModule {</pre>
<p class="mce-root">This is how you can solve these types of issues; but, this is exactly the reason why we recommend using Ngrx in <span> </span><a href="https://cdp.packtpub.com/mastering_nativescript_mobile_development/wp-admin/post.php?post=104&amp;action=edit#post_361" class="calibre3">Chapter 10</a><span>, </span><em class="calibre21">@ngrx/store + @ngrx/effects for State Management</em>, coming up soon, as it can help alleviate these dependency injection issues. </p>
<p class="mce-root">At this point, our setup works nicely; but, it can be greatly improved and even simplified when we start integrating ngrx for a more Redux-style architecture. We have done a few reactive things here, such as our <kbd class="calibre11">RecordComponent</kbd> reacting to our service's <kbd class="calibre11">state$</kbd> observable; but, we needed to inject <kbd class="calibre11">MixerService</kbd> into <kbd class="calibre11">PlayerService</kbd>, which feels slightly wrong architecturally, since <kbd class="calibre11">PlayerModule</kbd> should not really have a dependency on anything <kbd class="calibre11">MixerModule</kbd> provides. Again, <em class="calibre21">this technically works just fine,</em> but when we start working with ngrx in <a href="part0121.html#3JCK20-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 10</a>, <em class="calibre21">@ngrx/store + @ngrx/effects for State Management</em>, you'll see how we can reduce our dependency mixing throughout the whole codebase.</p>
<p class="mce-root">Let's take a moment though, relax, and pat ourselves on the back, as this has been an impressive amount of work. Take a look at what the fruits of our labor are producing:</p>
<div class="mce-root1"><img class="image-border29" src="../images/00038.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Phase 2 – Building an audio recorder for Android</h1>
                
            
            <article>
                
<p class="mce-root">Believe it or not we've actually done most of the heavy lifting to make this work on Android already! That's the beauty of NativeScript. Designing an API that makes sense, as well as an architecture that can plug/play underlying native APIs, is key to NativeScript development. At this point, we just need to plug in the Android pieces into the shape we have designed. So, to summarize, we now have the following:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre11">RecorderService</kbd> that works in tandem with <kbd class="calibre11">PlayerService</kbd> to coordinate our multitrack handling abilities</li>
<li class="calibre14">A Waveform view that is flexible and ready to provide an Android implementation under the hood</li>
<li class="calibre14"><kbd class="calibre11">RecordModel</kbd> that should tap into the appropriate underlying target platform APIs and be ready for Android details to be plugged into</li>
<li class="calibre14">Built interfaces defining the shape of the model, for Android models to simply implement to know which API they should define</li>
</ul>
<p class="mce-root">Let's get to work.</p>
<p class="mce-root">We want to rename <kbd class="calibre11">record.model.ts</kbd> to <kbd class="calibre11">record.model.ios.ts</kbd>, since it's specific to iOS, but before doing so, we will want a TypeScript definition file (<kbd class="calibre11">.d.ts</kbd>) for it, so our codebase can continue importing as <kbd class="calibre11">'record.model'</kbd>. There are several ways this could be done, including just manually writing one out. However, the tsc compiler has a handy <kbd class="calibre11">-d</kbd> flag, which will generate definition files for us:</p>
<pre class="calibre22">tsc app/modules/recorder/models/record.model.ts references.d.ts -d true</pre>
<div class="packt_infobox">This will spit out<span class="calibre31"> a ton of TypeScript warnings and errors; but, it doesn't matter in this case, since our definition file will be generated correctly. We don't need to generate JavaScript, just the definition, so you can ignore the wall of issues that results.</span></div>
<p class="mce-root">We now have two new files:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre11">record-common.model.d.ts</kbd> (<em class="calibre21">you can delete this as we won't need it</em>)</li>
<li class="calibre14"><kbd class="calibre11">record.model.d.ts</kbd></li>
</ul>
<p class="mce-root">The <kbd class="calibre11">record-common.model</kbd> file is imported by <kbd class="calibre11">RecordModel</kbd>, which is why a definition was generated for it as well; but, you can <em class="calibre21">delete</em> that. Now, we have the definition file, but we want to modify it slightly. We don't need any of the <kbd class="calibre11">private</kbd> declarations and/or any native types it included; you would notice it contained the following:</p>
<pre class="calibre22">...<br class="title-page-name"/>readonly target: AKMicrophone;<br class="title-page-name"/>readonly recorder: AKNodeRecorder;<br class="title-page-name"/>...</pre>
<p class="mce-root">Since those are iOS-specific, we'll want to type those as <em class="calibre21">any</em>, so it's applicable to both iOS and Android. This is what things look like with our modifications:</p>
<pre class="calibre22">import { Observable } from 'data/observable';<br class="title-page-name"/>import { IRecordModel, IRecordEvents } from './common';<br class="title-page-name"/>export declare class RecordModel extends Observable implements IRecordModel {<br class="title-page-name"/>  readonly events: IRecordEvents;<br class="title-page-name"/>  readonly target: any;<br class="title-page-name"/>  readonly recorder: any;<br class="title-page-name"/>  readonly audioFilePath: string;<br class="title-page-name"/>  state: number;<br class="title-page-name"/>  savedFilePath: string;<br class="title-page-name"/>  toggleRecord(): void;<br class="title-page-name"/>  togglePlay(): void;<br class="title-page-name"/>  stopPlayback(): void;<br class="title-page-name"/>  save(): void;<br class="title-page-name"/>  dispose(): void;<br class="title-page-name"/>  finish(): void;<br class="title-page-name"/>}</pre>
<p class="mce-root">Perfect, now rename <kbd class="calibre11">record.model.ts</kbd> to <kbd class="calibre11">record.model.ios.ts</kbd>. We have now finalized our iOS implementation, as well as ensured maximum code reuse to turn our focus to Android. NativeScript will use the target platform suffix files at build time, so you don't ever need to worry that iOS-only code would end up on Android and vice versa. </p>
<p class="mce-root">The <kbd class="calibre11">.d.ts</kbd> definition file we generated previously will be used at JavaScript transpilation time by the TypeScript compiler, whereas the runtime will use the platform-specific JS files (without the extension).</p>
<p class="mce-root">Okay, now create <kbd class="calibre11">app/modules/recorder/models/record.model.android.ts</kbd>:</p>
<pre class="calibre22">import { Observable } from 'data/observable';<br class="title-page-name"/>import { IRecordModel, IRecordEvents, RecordState, documentsFilePath } from './common';<br class="title-page-name"/><br class="title-page-name"/>export class RecordModel extends Observable implements IRecordModel {<br class="title-page-name"/><br class="title-page-name"/>  // available events to listen to<br class="title-page-name"/>  private _events: IRecordEvents;<br class="title-page-name"/><br class="title-page-name"/>  // recorder <br class="title-page-name"/>  private _recorder: any;<br class="title-page-name"/><br class="title-page-name"/>  // state<br class="title-page-name"/>  private _state: number = RecordState.readyToRecord;<br class="title-page-name"/><br class="title-page-name"/>  // the final saved path to use <br class="title-page-name"/>  private _savedFilePath: string;<br class="title-page-name"/><br class="title-page-name"/>  constructor() {<br class="title-page-name"/>    super();<br class="title-page-name"/>    this._setupEvents();<br class="title-page-name"/>    // TODO<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get events(): IRecordEvents {<br class="title-page-name"/>    return this._events;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get target() {<br class="title-page-name"/>    // TODO<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get recorder(): any {<br class="title-page-name"/>    return this._recorder;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get audioFilePath(): string {<br class="title-page-name"/>    return ''; // TODO<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get state(): number {<br class="title-page-name"/>    return this._state;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public set state(value: number) {<br class="title-page-name"/>    this._state = value;<br class="title-page-name"/>    this._emitEvent(this._events.stateChange, this._state);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get savedFilePath() {<br class="title-page-name"/>    return this._savedFilePath;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public set savedFilePath(value: string) {<br class="title-page-name"/>    this._savedFilePath = value;<br class="title-page-name"/>    if (this._savedFilePath)<br class="title-page-name"/>      this.state = RecordState.saved;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public toggleRecord() {<br class="title-page-name"/>    if (this._state !== RecordState.recording) {<br class="title-page-name"/>      // just force ready to record<br class="title-page-name"/>      // when coming from any state other than recording<br class="title-page-name"/>      this.state = RecordState.readyToRecord;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    switch (this._state) {<br class="title-page-name"/>      case RecordState.readyToRecord:<br class="title-page-name"/>        this.state = RecordState.recording;<br class="title-page-name"/>        break;<br class="title-page-name"/>      case RecordState.recording:<br class="title-page-name"/>        this._recorder.stop();<br class="title-page-name"/>        this.state = RecordState.readyToPlay;<br class="title-page-name"/>        break;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public togglePlay() {<br class="title-page-name"/>    if (this._state === RecordState.readyToPlay) {<br class="title-page-name"/>      this.state = RecordState.playing;<br class="title-page-name"/>    } else {<br class="title-page-name"/>      this.stopPlayback();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public stopPlayback() {<br class="title-page-name"/>    if (this.state !== RecordState.recording) {<br class="title-page-name"/>      this.state = RecordState.readyToPlay;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public save() {<br class="title-page-name"/>    // we will want to do this<br class="title-page-name"/>    // this.savedFilePath = documentsFilePath(fileName);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public dispose() {<br class="title-page-name"/>    // TODO<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public finish() {<br class="title-page-name"/>    this.state = RecordState.finish;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _emitEvent(eventName: string, data?: any) {<br class="title-page-name"/>    let event = {<br class="title-page-name"/>      eventName,<br class="title-page-name"/>      data,<br class="title-page-name"/>      object: this<br class="title-page-name"/>    };<br class="title-page-name"/>    this.notify(event);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _setupEvents() {<br class="title-page-name"/>    this._events = {<br class="title-page-name"/>      stateChange: 'stateChange'<br class="title-page-name"/>    };<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">This may look a whole lot like the iOS side, and that's because it will be nearly the same! In fact, this setup works great, so now we just want to fill in the Android specifics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using nativescript-audio's TNSRecorder for Android in our RecordModel</h1>
                
            
            <article>
                
<p class="mce-root">We could use some fancy Android APIs and/or libraries for our recorder, but in this case, the <strong class="calibre1">nativescript-audio</strong> plugin we're using for our cross-platform multitrack player also provides a cross-platform recorder. We could have even used it with iOS, but we wanted to specifically work with AudioKit's powerful APIs there. However, here on Android, let's use the recorder from the plugin and make the following modifications to <kbd class="calibre11">record.model.android.ts</kbd>:</p>
<pre class="calibre22">import { Observable } from 'data/observable';<br class="title-page-name"/>import { IRecordModel, IRecordEvents, RecordState, documentsFilePath } from './common';<br class="title-page-name"/><strong class="calibre1">import { TNSRecorder, AudioRecorderOptions } from 'nativescript-audio';</strong><br class="title-page-name"/><strong class="calibre1">import { Subject } from 'rxjs/Subject';</strong><br class="title-page-name"/><strong class="calibre1">import * as permissions from 'nativescript-permissions';<br class="title-page-name"/><br class="title-page-name"/>declare var android: any;<br class="title-page-name"/>const RECORD_AUDIO = android.Manifest.permission.RECORD_AUDIO;</strong><br class="title-page-name"/><br class="title-page-name"/>export class RecordModel extends Observable implements IRecordModel {<br class="title-page-name"/><br class="title-page-name"/>  // available events to listen to<br class="title-page-name"/>  private _events: IRecordEvents;<br class="title-page-name"/><br class="title-page-name"/>  // target as an Observable<br class="title-page-name"/>  <strong class="calibre1">private _target$: Subject&lt;number&gt;;</strong><br class="title-page-name"/><br class="title-page-name"/>  // recorder <br class="title-page-name"/>  private _recorder: <strong class="calibre1">TNSRecorder</strong>;<br class="title-page-name"/>  // recorder options <br class="title-page-name"/>  <strong class="calibre1">private _options: AudioRecorderOptions;</strong><br class="title-page-name"/>  // recorder mix meter handling<br class="title-page-name"/>  <strong class="calibre1">private _meterInterval: number;</strong><br class="title-page-name"/><br class="title-page-name"/>  // state<br class="title-page-name"/>  private _state: number = RecordState.readyToRecord;<br class="title-page-name"/><br class="title-page-name"/>  // tmp file path<br class="title-page-name"/>  <strong class="calibre1">private _filePath: string;</strong><br class="title-page-name"/>  // the final saved path to use <br class="title-page-name"/>  private _savedFilePath: string;<br class="title-page-name"/><br class="title-page-name"/>  constructor() {<br class="title-page-name"/>    super();<br class="title-page-name"/>    this._setupEvents();<br class="title-page-name"/>    <br class="title-page-name"/>    // prepare Observable as our target<br class="title-page-name"/>    <strong class="calibre1">this._target$ = new Subject();</strong><br class="title-page-name"/><br class="title-page-name"/>    // create recorder<br class="title-page-name"/>    <strong class="calibre1">this._recorder = new TNSRecorder();</strong><br class="title-page-name"/><strong class="calibre1">    this._filePath = documentsFilePath(`recording-${Date.now()}.m4a`);</strong><br class="title-page-name"/><strong class="calibre1">    this._options = {</strong><br class="title-page-name"/>      <strong class="calibre1">filename: this._filePath,</strong><br class="title-page-name"/>      <strong class="calibre1">format: android.media.MediaRecorder.OutputFormat.MPEG_4,</strong><br class="title-page-name"/>      <strong class="calibre1">encoder: android.media.MediaRecorder.AudioEncoder.AAC,</strong><br class="title-page-name"/>      <strong class="calibre1">metering: true, </strong>// critical to feed our waveform view<br class="title-page-name"/><strong class="calibre1">      infoCallback: (infoObject) =&gt; {</strong><br class="title-page-name"/>        // just log for now<br class="title-page-name"/>        <strong class="calibre1">console.log(JSON.stringify(infoObject));</strong><br class="title-page-name"/><strong class="calibre1">      },</strong><br class="title-page-name"/><strong class="calibre1">      errorCallback: (errorObject) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">        console.log(JSON.stringify(errorObject));</strong><br class="title-page-name"/><strong class="calibre1">      }</strong><br class="title-page-name"/><strong class="calibre1">    };</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get events(): IRecordEvents {<br class="title-page-name"/>    return this._events;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get target() {<br class="title-page-name"/>    <strong class="calibre1">return this._target$;</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get recorder(): any {<br class="title-page-name"/>    return this._recorder;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get audioFilePath(): string {<br class="title-page-name"/>    <strong class="calibre1">return this._filePath;</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get state(): number {<br class="title-page-name"/>    return this._state;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public set state(value: number) {<br class="title-page-name"/>    this._state = value;<br class="title-page-name"/>    this._emitEvent(this._events.stateChange, this._state);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get savedFilePath() {<br class="title-page-name"/>    return this._savedFilePath;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public set savedFilePath(value: string) {<br class="title-page-name"/>    this._savedFilePath = value;<br class="title-page-name"/>    if (this._savedFilePath)<br class="title-page-name"/>      this.state = RecordState.saved;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public toggleRecord() {<br class="title-page-name"/>    if (this._state !== RecordState.recording) {<br class="title-page-name"/>      // just force ready to record<br class="title-page-name"/>      // when coming from any state other than recording<br class="title-page-name"/>      this.state = RecordState.readyToRecord;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    switch (this._state) {<br class="title-page-name"/>      case RecordState.readyToRecord:<br class="title-page-name"/>        <strong class="calibre1">if (this._hasPermission()) {</strong><br class="title-page-name"/><strong class="calibre1">          this._recorder.start(this._options).then((result) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">            this.state = RecordState.recording;</strong><br class="title-page-name"/><strong class="calibre1">            this._initMeter();</strong><br class="title-page-name"/><strong class="calibre1">          }, (err) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">            this._resetMeter();</strong><br class="title-page-name"/><strong class="calibre1">          });</strong><br class="title-page-name"/><strong class="calibre1">        } else {</strong><br class="title-page-name"/><strong class="calibre1">          permissions.requestPermission(RECORD_AUDIO).then(() =&gt; {</strong><br class="title-page-name"/>            // simply engage again<br class="title-page-name"/><strong class="calibre1">            this.toggleRecord();</strong><br class="title-page-name"/><strong class="calibre1">          }, (err) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">            console.log('permissions error:', err);</strong><br class="title-page-name"/><strong class="calibre1">          });</strong><br class="title-page-name"/><strong class="calibre1">        }</strong><br class="title-page-name"/>        break;<br class="title-page-name"/>      case RecordState.recording:<br class="title-page-name"/>        <strong class="calibre1">this._resetMeter();</strong><br class="title-page-name"/>        this._recorder.stop();<br class="title-page-name"/>        this.state = RecordState.readyToPlay;<br class="title-page-name"/>        break;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public togglePlay() {<br class="title-page-name"/>    if (this._state === RecordState.readyToPlay) {<br class="title-page-name"/>      this.state = RecordState.playing;<br class="title-page-name"/>    } else {<br class="title-page-name"/>      this.stopPlayback();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public stopPlayback() {<br class="title-page-name"/>    if (this.state !== RecordState.recording) {<br class="title-page-name"/>      this.state = RecordState.readyToPlay;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public save() {<br class="title-page-name"/>    // With Android, filePath will be the same, just make it final<br class="title-page-name"/>    <strong class="calibre1">this.savedFilePath = this._filePath;</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public dispose() {<br class="title-page-name"/>    <strong class="calibre1">if (this.state === RecordState.recording) {</strong><br class="title-page-name"/><strong class="calibre1">      this._recorder.stop();</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">    this._recorder.dispose();</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public finish() {<br class="title-page-name"/>    this.state = RecordState.finish;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">private _initMeter() {</strong><br class="title-page-name"/><strong class="calibre1">    this._resetMeter();</strong><br class="title-page-name"/><strong class="calibre1">    this._meterInterval = setInterval(() =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">      let meters = this.recorder.getMeters();</strong><br class="title-page-name"/><strong class="calibre1">      this._target$.next(meters);</strong><br class="title-page-name"/><strong class="calibre1">    }, 200); </strong>// use 50 for production - perf is better on devices<br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  private _resetMeter() {</strong><br class="title-page-name"/><strong class="calibre1">    if (this._meterInterval) {</strong><br class="title-page-name"/><strong class="calibre1">      clearInterval(this._meterInterval);</strong><br class="title-page-name"/><strong class="calibre1">      this._meterInterval = undefined;</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  private _hasPermission() {</strong><br class="title-page-name"/><strong class="calibre1">    return permissions.hasPermission(RECORD_AUDIO);</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/>  private _emitEvent(eventName: string, data?: any) {<br class="title-page-name"/>    let event = {<br class="title-page-name"/>      eventName,<br class="title-page-name"/>      data,<br class="title-page-name"/>      object: this<br class="title-page-name"/>    };<br class="title-page-name"/>    this.notify(event);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _setupEvents() {<br class="title-page-name"/>    this._events = {<br class="title-page-name"/>      stateChange: 'stateChange'<br class="title-page-name"/>    };<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">Wow! Okay, a lot of interesting things going on here. Let's get one necessary thing out of the way for Android and ensure for API level 23+ that permissions are properly handled. For this, you can install the permissions plugin:</p>
<pre class="calibre22">tns plugin add nativescript-permissions</pre>
<p class="mce-root">We also want to ensure our manifest file contains the proper permission key.</p>
<p class="mce-root">Open <kbd class="calibre11">app/App_Resources/Android/AndroidManifest.xml</kbd> and add the following in the correct place:</p>
<pre class="calibre22">&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt;<br class="title-page-name"/>&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;<br class="title-page-name"/>&lt;uses-permission android:name="android.permission.INTERNET"/&gt;<br class="title-page-name"/><strong class="calibre1">&lt;uses-permission android:name="android.permission.RECORD_AUDIO"/&gt;</strong></pre>
<p class="mce-root">We use the nativescript-audio plugin's <kbd class="calibre11">TNSRecorder</kbd> as our implementation and wire things up accordingly to its API. <kbd class="calibre11">AudioRecorderOptions</kbd> provides a <kbd class="calibre11">metering</kbd> option, allowing the ability to monitor the microphone's meters via an interval.</p>
<p class="mce-root">What is most versatile about our overall design is that our model's target can literally be anything. In this case, we create a RxJS Subject observable as <kbd class="calibre11">_target$</kbd>, which is then returned as our target getter. This allows us to emit the microphone's meter value through the <kbd class="calibre11">Subject</kbd> observable for consumption by our Waveform. You will see in a moment how we will take advantage of this.</p>
<p class="mce-root">We are now ready to move on to our Waveform implementation for Android.</p>
<p class="mce-root">Just like we did for the model, we will want to refactor the common bits into a shared file and handle the suffix.</p>
<p class="mce-root">Create <kbd class="calibre11">app/modules/shared/native/waveform-common.ts</kbd>:</p>
<pre class="calibre22">import { View } from 'ui/core/view';<br class="title-page-name"/><br class="title-page-name"/>export type WaveformType = 'mic' | 'file';<br class="title-page-name"/><br class="title-page-name"/>export interface IWaveformModel {<br class="title-page-name"/>  readonly target: any;<br class="title-page-name"/>  dispose(): void;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>export interface IWaveform extends View {<br class="title-page-name"/>  type: WaveformType;<br class="title-page-name"/>  model: IWaveformModel;<br class="title-page-name"/>  createNativeView(): any;<br class="title-page-name"/>  initNativeView(): void;<br class="title-page-name"/>  disposeNativeView(): void;<br class="title-page-name"/>}</pre>
<p class="mce-root">Then, just adjust <kbd class="calibre11">app/modules/shared/native/waveform.ts</kbd> to use it:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">import { IWaveform, IWaveformModel, WaveformType } from './waveform-common';</strong><br class="title-page-name"/><br class="title-page-name"/>export class Waveform extends View <strong class="calibre1">implements IWaveform</strong> {<br class="title-page-name"/>  ...</pre>
<p class="mce-root">Before renaming our waveform to contain an <kbd class="calibre11">.ios</kbd> suffix, let's generate a TypeScript definition file for it first:</p>
<pre class="calibre22">tsc app/modules/shared/native/waveform.ts references.d.ts -d true --lib es6,dom,es2015.iterable --target es5</pre>
<p class="mce-root">You may again see TypeScript errors or warnings, but we don't need to worry about those, as it should have still generated a <kbd class="calibre11">waveform.d.ts</kbd> file. Let's simplify it slightly to contain only the parts that are applicable to both iOS and Android:</p>
<pre class="calibre22">import { View } from 'ui/core/view';<br class="title-page-name"/>export declare type WaveformType = 'mic' | 'file';<br class="title-page-name"/>export interface IWaveformModel {<br class="title-page-name"/>  readonly target: any;<br class="title-page-name"/>  dispose(): void;<br class="title-page-name"/>}<br class="title-page-name"/>export interface IWaveform extends View {<br class="title-page-name"/>  type: WaveformType;<br class="title-page-name"/>  model: IWaveformModel;<br class="title-page-name"/>  createNativeView(): any;<br class="title-page-name"/>  initNativeView(): void;<br class="title-page-name"/>  disposeNativeView(): void;<br class="title-page-name"/>}<br class="title-page-name"/>export declare class Waveform extends View implements IWaveform {}</pre>
<p class="mce-root">Okay, now, rename <kbd class="calibre11">waveform.ts</kbd> to <kbd class="calibre11">waveform.ios.ts</kbd> and create <kbd class="calibre11">app/modules/shared/native/waveform.android.ts</kbd>:</p>
<pre class="calibre22">import { View } from 'ui/core/view';<br class="title-page-name"/>import { Color } from 'color';<br class="title-page-name"/>import { IWaveform, IWaveformModel, WaveformType } from './common';<br class="title-page-name"/><br class="title-page-name"/>export class Waveform extends View implements IWaveform {<br class="title-page-name"/>  private _model: IWaveformModel;<br class="title-page-name"/>  private _type: WaveformType;<br class="title-page-name"/><br class="title-page-name"/>  public set type(value: WaveformType) {<br class="title-page-name"/>    this._type = value;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get type() {<br class="title-page-name"/>    return this._type;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public set model(value: IWaveformModel) {<br class="title-page-name"/>    this._model = value;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get model() {<br class="title-page-name"/>    return this._model;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  createNativeView() {<br class="title-page-name"/>    switch (this.type) {<br class="title-page-name"/>      case 'mic':<br class="title-page-name"/>        // TODO: this.nativeView = ?<br class="title-page-name"/>        break;<br class="title-page-name"/>      case 'file':<br class="title-page-name"/>        // TODO: this.nativeView = ?<br class="title-page-name"/>        break;<br class="title-page-name"/>    }<br class="title-page-name"/>    return this.nativeView;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  initNativeView() {<br class="title-page-name"/>    // TODO<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  disposeNativeView() {<br class="title-page-name"/>    if (this.model &amp;&amp; this.model.dispose) this.model.dispose();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">Okay, excellent! This is the barebones setup we will need, <em class="calibre21">but what native Android view should we use?</em></p>
<p class="mce-root">If you're looking around for open source Android libs, you may come across a group of very talented developers with <strong class="calibre1">Yalantis</strong>, a fantastic mobile development company based out of Ukraine. Roman Kozlov and his team created an open source project, <strong class="calibre1">Horizon</strong>, which provides beautiful audio visualizations:<br class="title-page-name"/>
<a href="https://github.com/Yalantis/Horizon" class="calibre3">https://github.com/Yalantis/Horizon</a><br class="title-page-name"/>
<a href="https://yalantis.com/blog/horizon-open-source-library-for-sound-visualization/" class="calibre3">https://yalantis.com/blog/horizon-open-source-library-for-sound-visualization/</a></p>
<p class="mce-root">Just like for iOS, we also want to prepare for a multifaceted Waveform view that can also render a static waveform for just a file. Looking further through the open source options, we may come across another wonderfully talented team with <strong class="calibre1">Semantive</strong>, based in Warsaw, the sprawling capital of Poland. They created an incredibly powerful Waveform view for Android:<br class="title-page-name"/>
<a href="https://github.com/Semantive/waveform-android" class="calibre3">https://github.com/Semantive/waveform-android</a></p>
<p class="mce-root">Let's integrate both of these libraries for our Android Waveform integration.</p>
<p class="mce-root">Similar to how we integrated AudioKit for iOS, let's create a folder in the root called <kbd class="calibre11">android-waveform-libs</kbd> with the following setup, that provides <kbd class="calibre11">include.gradle</kbd>:</p>
<div class="mce-root1"><img class="image-border30" src="../images/00039.jpeg"/></div>
<div class="packt_tip">Why deviate from the <kbd class="calibre29">nativescript-</kbd> prefix when including native libs?<br class="calibre24"/>
The prefix is a good way to go if you plan to refactor the internal plugin into an open source plugin published via npm for the community down the road, using <a href="https://github.com/NathanWalker/nativescript-plugin-seed" class="calibre35">https://github.com/NathanWalker/nativescript-plugin-seed</a> for instance.</div>
<p class="mce-root">Sometimes, you just need to integrate several native libs for a specific platform, as we are in this case, so we don't really need the <kbd class="calibre11">nativescript-</kbd> prefix on our folder.</p>
<p class="mce-root">We make sure to add <kbd class="calibre11">package.json</kbd>, so we can add these native libs like we would any other plugin:</p>
<pre class="calibre22">{<br class="title-page-name"/>  "name": "android-waveform-libs",<br class="title-page-name"/>  "version": "1.0.0",<br class="title-page-name"/>  "nativescript": {<br class="title-page-name"/>    "platforms": {<br class="title-page-name"/>      "android": "3.0.0"<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">Now, we simply add them as a plugin to our project:</p>
<pre class="calibre22"><strong class="calibre1">tns plugin add android-waveform-libs</strong></pre>
<p class="mce-root">We are now ready to integrate these libs into our Waveform view.<br class="title-page-name"/>
Let's make the following modifications to the <kbd class="calibre11">app/modules/shared/native/waveform.android.ts</kbd> file:</p>
<pre class="calibre22">import { View } from 'ui/core/view';<br class="title-page-name"/>import { Color } from 'color';<br class="title-page-name"/><strong class="calibre1">import { Subscription } from 'rxjs/Subscription';</strong><br class="title-page-name"/>import { IWaveform, IWaveformModel, WaveformType } from './common';<br class="title-page-name"/>import { screen } from 'platform';<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">declare var com;<br class="title-page-name"/>declare var android;</strong><br class="title-page-name"/><strong class="calibre1">const GLSurfaceView = android.opengl.GLSurfaceView;</strong><br class="title-page-name"/><strong class="calibre1">const AudioRecord = android.media.AudioRecord;</strong><br class="title-page-name"/><br class="title-page-name"/>// Horizon recorder waveform<br class="title-page-name"/>// https://github.com/Yalantis/Horizon<br class="title-page-name"/><strong class="calibre1">const Horizon = com.yalantis.waves.util.Horizon;</strong><br class="title-page-name"/>// various recorder settings<br class="title-page-name"/><strong class="calibre1">const RECORDER_SAMPLE_RATE = 44100;</strong><br class="title-page-name"/><strong class="calibre1">const RECORDER_CHANNELS = 1;</strong><br class="title-page-name"/><strong class="calibre1">const RECORDER_ENCODING_BIT = 16;</strong><br class="title-page-name"/><strong class="calibre1">const RECORDER_AUDIO_ENCODING = 3;</strong><br class="title-page-name"/><strong class="calibre1">const MAX_DECIBELS = 120;</strong><br class="title-page-name"/><br class="title-page-name"/>// Semantive waveform for files<br class="title-page-name"/>// https://github.com/Semantive/waveform-android<br class="title-page-name"/><strong class="calibre1">const WaveformView = com.semantive.waveformandroid.waveform.view.WaveformView;</strong><br class="title-page-name"/><strong class="calibre1">const CheapSoundFile = com.semantive.waveformandroid.waveform.soundfile.CheapSoundFile;</strong><br class="title-page-name"/><strong class="calibre1">const ProgressListener = com.semantive.waveformandroid.waveform.soundfile.CheapSoundFile.ProgressListener;</strong><br class="title-page-name"/><br class="title-page-name"/>export class Waveform extends View implements IWaveform {<br class="title-page-name"/>  private _model: IWaveformModel;<br class="title-page-name"/>  private _type: WaveformType;<br class="title-page-name"/>  <strong class="calibre1">private _initialized: boolean;</strong><br class="title-page-name"/><strong class="calibre1">  private _horizon: any;</strong><br class="title-page-name"/><strong class="calibre1">  private _javaByteArray: Array&lt;any&gt;;</strong><br class="title-page-name"/><strong class="calibre1">  private _waveformFileView: any;</strong><br class="title-page-name"/><strong class="calibre1">  private _sub: Subscription;</strong><br class="title-page-name"/> <br class="title-page-name"/>  public set type(value: WaveformType) {<br class="title-page-name"/>    this._type = value;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get type() {<br class="title-page-name"/>    return this._type;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public set model(value: IWaveformModel) {<br class="title-page-name"/>    this._model = value;<br class="title-page-name"/>    <strong class="calibre1">this._initView();</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get model() {<br class="title-page-name"/>    return this._model;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  createNativeView() {<br class="title-page-name"/>    switch (this.type) {<br class="title-page-name"/>      case 'mic':<br class="title-page-name"/>        <strong class="calibre1">this.nativeView = new GLSurfaceView(this._context);</strong><br class="title-page-name"/><strong class="calibre1">        this.height = 200; </strong>// GL view needs height<br class="title-page-name"/>        break;<br class="title-page-name"/>      case 'file':<br class="title-page-name"/>        <strong class="calibre1">this.nativeView = new WaveformView(this._context, null);</strong><br class="title-page-name"/><strong class="calibre1">        this.nativeView.setSegments(null);</strong><br class="title-page-name"/><strong class="calibre1">        this.nativeView.recomputeHeights(screen.mainScreen.scale);</strong><br class="title-page-name"/><br class="title-page-name"/>        // disable zooming and touch events<br class="title-page-name"/><strong class="calibre1">        this.nativeView.mNumZoomLevels = 0;</strong><br class="title-page-name"/><strong class="calibre1">        this.nativeView.onTouchEvent = function (e) { return false; }</strong><br class="title-page-name"/>        break;<br class="title-page-name"/>    }<br class="title-page-name"/>    return this.nativeView;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  initNativeView() {<br class="title-page-name"/>    this._initView();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  disposeNativeView() {<br class="title-page-name"/>    if (this.model &amp;&amp; this.model.dispose) this.model.dispose();<br class="title-page-name"/>    <strong class="calibre1">if (this._sub) this._sub.unsubscribe();</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _initView() {<br class="title-page-name"/>    if (!this._initialized &amp;&amp; this.nativeView &amp;&amp; this.model) {<br class="title-page-name"/>      if (this.type === 'mic') {<br class="title-page-name"/>        <strong class="calibre1">this._initialized = true;</strong><br class="title-page-name"/><strong class="calibre1">        this._horizon = new Horizon(</strong><br class="title-page-name"/><strong class="calibre1">          this.nativeView,</strong><br class="title-page-name"/><strong class="calibre1">          new Color('#000').android,</strong><br class="title-page-name"/><strong class="calibre1">          RECORDER_SAMPLE_RATE,</strong><br class="title-page-name"/><strong class="calibre1">          RECORDER_CHANNELS,</strong><br class="title-page-name"/><strong class="calibre1">          RECORDER_ENCODING_BIT</strong><br class="title-page-name"/><strong class="calibre1">        );</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">        this._horizon.setMaxVolumeDb(MAX_DECIBELS);</strong><br class="title-page-name"/><strong class="calibre1">        let bufferSize = 2 * AudioRecord.getMinBufferSize(</strong><br class="title-page-name"/><strong class="calibre1">          RECORDER_SAMPLE_RATE, RECORDER_CHANNELS, RECORDER_AUDIO_ENCODING);</strong><br class="title-page-name"/><strong class="calibre1">        this._javaByteArray = Array.create('byte', bufferSize);</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">        this._sub = this._model.target.subscribe((value) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">          this._javaByteArray[0] = value;</strong><br class="title-page-name"/><strong class="calibre1">          this._horizon.updateView(this._javaByteArray);</strong><br class="title-page-name"/><strong class="calibre1">        });</strong><br class="title-page-name"/>      } else {<br class="title-page-name"/>        <strong class="calibre1">let soundFile = CheapSoundFile.create(this._model.target, </strong><br class="title-page-name"/><strong class="calibre1">          new ProgressListener({</strong><br class="title-page-name"/><strong class="calibre1">            reportProgress: (fractionComplete: number) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">              console.log('fractionComplete:', fractionComplete);</strong><br class="title-page-name"/><strong class="calibre1">              return true;</strong><br class="title-page-name"/><strong class="calibre1">            }</strong><br class="title-page-name"/><strong class="calibre1">          }));</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">        setTimeout(() =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">          this.nativeView.setSoundFile(soundFile);</strong><br class="title-page-name"/><strong class="calibre1">          this.nativeView.invalidate();</strong><br class="title-page-name"/><strong class="calibre1">        }, 0);</strong><br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">We begin our Android implementation by defining the <kbd class="calibre11">const</kbd> references to the various packaged classes we need to access, to alleviate having to reference the fully qualified package location each time in our Waveform. Just like on the iOS side, we design a dual-purpose Waveform by allowing the type (<kbd class="calibre11">'mic'</kbd> or <kbd class="calibre11">'file'</kbd>) to drive which rendering to use. This allows us to reuse this with our record view for real-time microphone visualization and the other to statically render our tracks as Waveforms (more on that soon!).</p>
<p class="mce-root">The Horizon lib utilizes Android's <kbd class="calibre11">GLSurfaceView</kbd> as the primary rendering, hence:</p>
<pre class="calibre22">this.nativeView = new GLSurfaceView(this._context);<br class="title-page-name"/>this.height = 200; // GL view needs height</pre>
<p class="mce-root">During development, we found that <kbd class="calibre11">GLSurfaceView</kbd> requires at least a height to constrain it, otherwise it would render at full screen height. Therefore, we explicitly set a reasonable <kbd class="calibre11">height</kbd> of <kbd class="calibre11">200</kbd> to the custom NativeScript view, which will automatically handle measuring the native view for us. Interestingly, we also found that sometimes our model setter would fire <em class="calibre21">before</em> <kbd class="calibre11">initNativeView</kbd> and other times <em class="calibre21">after</em>. Because the model is a critical binding for initializing our Horizon view, we designed a custom internal <kbd class="calibre11">_initView</kbd> method with the appropriate conditional, which could be called from <kbd class="calibre11">initNativeView</kbd>, as well as after our model setter fired. The condition (<kbd class="calibre11">!this._initialized &amp;&amp; this.nativeView &amp;&amp; this.model</kbd>) ensures it's only ever initialized once though. This is the way to handle any potential race conditions around the sequence of these method calls.</p>
<p class="mce-root">The native <kbd class="calibre11">Horizon.java</kbd> class provides an <kbd class="calibre11">update</kbd> method that expects a Java byte array with a signature:</p>
<pre class="calibre22">updateView(byte[] buffer)</pre>
<p class="mce-root">What we do in NativeScript for this is retain a reference to a construct that will represent this native Java byte array with the following:</p>
<pre class="calibre22">let bufferSize = 2 * AudioRecord.getMinBufferSize(<br class="title-page-name"/>  RECORDER_SAMPLE_RATE, RECORDER_CHANNELS, RECORDER_AUDIO_ENCODING);<br class="title-page-name"/><strong class="calibre1">this._javaByteArray = Array.create('byte', bufferSize);</strong></pre>
<p class="mce-root">Utilizing Android's <kbd class="calibre11">android.media.AudioRecord</kbd> class, in conjunction with the various recorder settings that we set up, we are able to gather an initial <kbd class="calibre11">bufferSize</kbd>, that we use to initialize our byte array size.</p>
<p class="mce-root">We then take advantage of our overall versatile design, wherein our model's target in this implementation is an rxjs Subject Observable, allowing us to subscribe to its event stream. For the <kbd class="calibre11">'mic'</kbd> type, this stream will be the metering value changes from the recorder, which we use to fill our byte array and in turn update the <kbd class="calibre11">Horizon</kbd> view:</p>
<pre class="calibre22">this._sub = this._model.target.subscribe((value) =&gt; {<br class="title-page-name"/>  this._javaByteArray[0] = value;<br class="title-page-name"/>  this._horizon.updateView(this._javaByteArray);<br class="title-page-name"/>});</pre>
<p class="mce-root">This provides our recorder a nice visualization, which will animate as the input level changes. Here's a preview; however, the style is still a little ugly, since we have not applied any CSS polish just yet:</p>
<div class="mce-root1"><img class="image-border31" src="../images/00040.jpeg"/></div>
<p class="mce-root">For our static audio file waveform rendering, we initialize <kbd class="calibre11">WaveformView</kbd> with the Android context. We then use its API to configure it for our use during construction in <kbd class="calibre11">createNativeView</kbd>.</p>
<p class="mce-root">During initialization, we create an instance of <kbd class="calibre11">CheapSoundFile</kbd> as required by <kbd class="calibre11">WaveformView</kbd>, and interestingly, we use <kbd class="calibre11">setSoundFile</kbd> inside <kbd class="calibre11">setTimeout</kbd>, alongside a call to <kbd class="calibre11">this.nativeView.invalidate()</kbd>, which is calling invalidate on <kbd class="calibre11">WaveformView</kbd>. This causes the native view to update with the processed file, as follows (again, we will address the styling polish later):</p>
<div class="mce-root1"><img class="image-border32" src="../images/00041.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="mce-root">This chapter has introduced a wealth of powerful concepts and techniques on how to work with native APIs on iOS and Android. Knowing how to work with open source native libraries is fundamental to getting the most out of your app development and achieving the feature set you are after. Direct access to these APIs right from TypeScript gives you the luxury of never leaving your preferred development environment, as well as engaging with the languages you love in a fun and accessible way.</p>
<p class="mce-root">Additionally, learning solid practices around how/when to create custom NativeScript views and interworking them throughout your Angular app are among the key elements to leverage the most of this tech stack.</p>
<p class="mce-root">In the next chapter, we will provide some extra goodies by empowering our track list view with more bells and whistles, leveraging some of what you've learned here.</p>


            </article>

            
        </section>
    </body></html>