- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Server-Side Rendering
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: As we discussed in *Chapter 1*, *Why React?*, the React library is remarkably
    flexible in terms of how our components can be transformed into various target
    formats. One such target format, as you might have guessed, is standard HTML markup,
    presented as a string and generated on the server. In this chapter, we will delve
    into how **server-side rendering** (**SSR**) works in React and the advantages
    it offers both users and developers. You will learn why this approach can be valuable
    for your application and how it enhances the overall user experience and performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第一章*，*为什么选择React*中讨论的那样，React库在将我们的组件转换为各种目标格式方面非常灵活。你可能已经猜到了，其中一个目标格式是标准的HTML标记，以字符串形式呈现并在服务器上生成。在本章中，我们将深入探讨React中**服务器端渲染**（**SSR**）的工作原理以及它为用户和开发者提供的优势。你将了解为什么这种方法对你的应用程序来说很有价值，以及它是如何增强整体用户体验和性能的。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Working on the server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上工作
- en: Using Next.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Next.js
- en: React Server Components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React服务器组件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files of this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter13](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter13).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter13](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter13)。
- en: Working on the server
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上工作
- en: Web technologies have come a long way or, more precisely, have come full circle.
    It all started with static web pages prepared by a server. Servers were the foundation
    of all website and application logic, as they were entirely responsible for their
    functioning. Then, we tried to move away from **SSR** in favor of rendering pages
    in the browser, which led to a significant leap in the development of web pages
    as fully fledged applications, now comparable to desktop ones. As a result, browsers
    became the core of application logic, while servers merely provided data for applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 网络技术已经走了很长的路，或者更准确地说，已经回到了起点。一切始于由服务器准备的静态网页。服务器是所有网站和应用逻辑的基础，因为它们完全负责其功能。然后，我们试图摆脱**SSR**，转向在浏览器中渲染页面，这导致了网页作为完整应用程序的开发取得了重大飞跃，现在可以与桌面应用程序相媲美。因此，浏览器成为了应用逻辑的核心，而服务器只是为应用程序提供数据。
- en: Currently, the development cycle has brought us back to SSR and server components,
    but now we have a unified logic and code for both the server and the client. Why
    this happened and what conclusions and experiences we have gained with the evolution
    of technologies are what we will try to understand in this section, and we will
    simultaneously learn about the types of work our applications do on the server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，开发周期已经让我们回到了SSR和服务器组件，但现在我们有了服务器和客户端的统一逻辑和代码。为什么会出现这种情况，以及我们在技术演变过程中获得了哪些结论和经验，我们将在本节中尝试理解，同时我们还将了解我们的应用程序在服务器上执行的工作类型。
- en: Server-side rendering
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: In a traditional **single-page application** (**SPA**) approach, we rely solely
    on local browser rendering. We write all the code, styles, and markup specifically
    for a browser, and during the application build, we get static HTML, CSS, and
    JavaScript files, which are then loaded into the browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的**单页应用程序**（**SPA**）方法中，我们完全依赖本地浏览器渲染。我们编写所有代码、样式和标记，专门针对浏览器，在应用程序构建过程中，我们得到静态的HTML、CSS和JavaScript文件，然后这些文件被加载到浏览器中。
- en: In most cases, the initial HTML file remains empty, without any content. The
    only important thing to have in this file is the connected JavaScript file, which
    will render everything we need.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，初始的HTML文件是空的，没有任何内容。在这个文件中唯一重要的事情是连接的JavaScript文件，它将渲染我们所需的一切。
- en: 'Below is a schematic illustration of how an SPA application is loaded and rendered:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示意图，说明了单页应用程序（SPA）应用是如何加载和渲染的：
- en: '![](img/B19636_13_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_13_01.png)'
- en: 'Figure 13.1: SPA application'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：单页应用程序（SPA）应用
- en: This approach brought interactivity, making applications feel and function like
    real desktop applications. There’s no longer a need to reload a page every time
    to update the content and receive notifications, new emails, or messages, as the
    entire application logic is directly in the browser. Over time, browser applications
    have almost entirely replaced desktop ones. Now, we can write emails, work with
    documents, watch movies, and do much more, all within a single browser. Many companies,
    instead of developing desktop applications, started creating their projects as
    web applications. The browser’s ability to operate across any architecture and
    operating system significantly reduced development costs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法引入了交互性，使得应用程序感觉和功能就像真正的桌面应用程序一样。不再需要每次更新内容、接收通知、新电子邮件或消息时都重新加载页面，因为整个应用程序逻辑直接在浏览器中。随着时间的推移，浏览器应用程序几乎完全取代了桌面应用程序。现在，我们可以在单个浏览器中写电子邮件、处理文档、观看电影以及做更多的事情。许多公司，而不是开发桌面应用程序，开始将他们的项目作为Web应用程序来创建。浏览器能够在任何架构和操作系统上运行的能力显著降低了开发成本。
- en: At the same time, servers also underwent changes, moving away from page templating,
    caching, etc. Backend developers no longer need to focus on page layout and can
    devote more time to more complex logic and architecture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，服务器也经历了变化，远离了页面模板、缓存等。后端开发者不再需要关注页面布局，可以更多地投入到更复杂的逻辑和架构中。
- en: However, SPA applications do have drawbacks, including the long initial load
    time due to the need to download and process the script. During this process,
    the user sees a white screen or a loading spinner. Additionally, the empty initial
    HTML file is not suitable for search engine optimization, as search engines perceive
    it as a blank page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单页应用程序（SPA）确实存在一些缺点，包括由于需要下载和处理脚本而导致的长时间初始加载时间。在这个过程中，用户会看到一个空白屏幕或加载指示器。此外，空白的初始HTML文件不适合搜索引擎优化，因为搜索引擎将其视为一个空白页面。
- en: In the context of creating, for example, an online store, a regular React SPA
    might not be suitable because it’s important for users and search engines to immediately
    see the page content. Before the advent of SPAs, such tasks were solved by tools
    that worked only on the server side, which always prepared the content. In React,
    solving this problem is more complex because, as we know, React works on the browser
    side.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建在线商店等场景的背景下，普通的React SPA可能不适合，因为用户和搜索引擎需要立即看到页面内容。在SPAs出现之前，这类任务是由仅在服务器端工作的工具解决的，这些工具始终准备内容。在React中，解决这个问题更复杂，因为我们知道React在浏览器端工作。
- en: The first step in the solution will obviously be the idea of rendering the page
    content on the server by React. And this won’t be a problem. Since its release,
    React has had the `renderToString` function for this purpose, which can be called
    in a **Node.js server** environment. This function returns an HTML string that,
    when sent to the browser, allows the content to be rendered on the user’s screen.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的第一步显然是使用React在服务器上渲染页面内容。这不会是问题。自从其发布以来，React就提供了用于此目的的`renderToString`函数，该函数可以在**Node.js服务器**环境中调用。此函数返回一个HTML字符串，当发送到浏览器时，允许内容在用户的屏幕上渲染。
- en: 'Let’s see how SSR with the `renderToString` function would work:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`renderToString`函数的SSR会如何工作：
- en: '![](img/B19636_13_02.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_13_02.png)'
- en: 'Figure 13.2: Server rendering using renderToString'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：使用renderToString进行服务器渲染
- en: In this example, when a page is requested in the browser, the server, by calling
    the function `renderToString` and passing it to the React component tree, outputs
    HTML. By sending this HTML string in response to the browser’s request, the browser
    renders the result.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当在浏览器中请求页面时，服务器通过调用`renderToString`函数并将它传递给React组件树，输出HTML。通过将这个HTML字符串作为对浏览器请求的响应发送，浏览器渲染结果。
- en: However, in such an example, the HTML generated on the server and rendered in
    the browser lacks interactivity and the capabilities of a client application.
    For functionalities like buttons, navigation, and everything we are accustomed
    to in SPAs, JavaScript is required. Therefore, the next step in implementing an
    interactive site or application rendered on the server is to transmit not only
    HTML but also JavaScript, which will provide all the interactivity we need.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这样的例子中，服务器上生成的并在浏览器中渲染的HTML缺乏交互性和客户端应用程序的功能。对于像按钮、导航以及我们在单页应用程序（SPAs）中习惯的所有功能，都需要JavaScript。因此，在实现服务器渲染的交互式网站或应用程序的下一步中，不仅要传输HTML，还要传输JavaScript，这将提供我们需要的所有交互性。
- en: To solve this problem, the approach of **isomorphic JavaScript** was introduced.
    Code written in this style can be executed first on the server and then on the
    client. This allows you to prepare the initial render on the server and send the
    ready HTML along with the JavaScript bundle to the client, allowing the browser
    to then provide interactivity. This approach speeds up the initial load of the
    application, while maintaining its functionality and allowing search engines to
    index the page in search results.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，引入了**同构JavaScript**的方法。以这种风格编写的代码可以先在服务器上执行，然后再在客户端执行。这允许你在服务器上准备初始渲染，并将准备好的HTML以及JavaScript包发送到客户端，然后允许浏览器提供交互性。这种方法加快了应用的初始加载速度，同时保持其功能，并允许搜索引擎在搜索结果中索引页面。
- en: When a user opens a page, they immediately see the rendering result performed
    on the server even before the JavaScript is loaded. This quick initial response
    significantly improves the user experience. After the page and JS bundle are loaded,
    it’s crucial for the browser to **hydrate** the page, as we know from the `renderToString`
    example that all our elements lack interactivity. For this, the script needs to
    attach all necessary event listeners to the elements. This process is called **hydration**
    and is a lighter and faster process compared to a full-page render from scratch.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开一个页面时，他们立即看到服务器上执行的渲染结果，甚至在JavaScript加载之前。这种快速的初始响应显著提高了用户体验。页面和JS包加载后，浏览器对页面进行**激活**至关重要，正如我们从`renderToString`示例中所知，我们所有的元素都缺乏交互性。为此，脚本需要将所有必要的事件监听器附加到元素上。这个过程被称为**激活**，与从头开始的全页渲染相比，这是一个更轻更快的过程。
- en: Another important feature of interactivity is the ability to navigate through
    an application instantly or smoothly without reloading a browser page. With isomorphic
    JavaScript, this became possible, as it is enough to load the JavaScript code
    of the next page, and the application can then render the next page locally.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 交互性的另一个重要特性是能够瞬间或平滑地导航到应用中的下一个页面，而无需重新加载浏览器页面。通过同构JavaScript，这成为了可能，因为只需要加载下一个页面的JavaScript代码，然后应用就可以在本地渲染下一个页面。
- en: '![](img/B19636_13_03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_13_03.png)'
- en: 'Figure 13.3: SSR'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：SSR
- en: The figure above schematically represents the SSR approach, where the application
    is fully interactive. Initially, when a page is requested, the server renders
    the content and returns HTML with an attached JavaScript bundle. Then, the browser
    loads the JS file and hydrates all the content previously displayed on the page.
    This approach is what has come to be known as SSR. It has become widely used among
    React developers and has found its place in the arsenal of modern web technologies.
    SSR combines the fast loading of page content and the high performance of server
    rendering with the flexibility and interactivity of a client application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上图以示意图的形式展示了SSR方法，其中应用是完全交互式的。最初，当请求一个页面时，服务器渲染内容并返回带有附加JavaScript包的HTML。然后，浏览器加载JS文件并使页面上先前显示的所有内容生效。这种方法就是现在所知的SSR。它已经在React开发者中得到了广泛应用，并在现代网络技术中找到了其位置。SSR结合了页面内容的快速加载和服务器渲染的高性能，以及客户端应用的灵活性和交互性。
- en: Static site and incremental static generation
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态站点和增量静态生成
- en: Although SSR represents a significant improvement, it is not a universal solution
    and has its drawbacks, including the need to generate a page from scratch for
    each request. For example, pages that do not have dynamic content must be generated
    on a server each time, which can cause display delays for the user. Additionally,
    even for the simplest applications or sites, SSR requires a Node.js server for
    rendering, unlike SPAs where it was sufficient to use a **content delivery network**
    (**CDN**) to position application files closer to the user, thereby speeding up
    loading.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SSR代表了一个重大的改进，但它并不是万能的解决方案，有其缺点，包括需要为每个请求从头生成一个页面。例如，没有动态内容的页面每次都必须在服务器上生成，这可能会使用户的显示延迟。此外，即使是简单的应用或网站，SSR也需要一个Node.js服务器进行渲染，与SPAs不同，在SPAs中，只需要使用**内容分发网络**（**CDN**）将应用文件放置得更靠近用户，从而加快加载速度。
- en: 'The solution to these problems was found in the **static site generation**
    (**SSG**) approach. The logic of SSG is to render all static pages on a server
    during the project build process. As a result, we get many HTML pages ready for
    immediate delivery upon request. As with SSR, in SSG, the JavaScript bundle hydrates
    the page after it has loaded, making it interactive. In the end, we get the same
    experience as with SPAs but not with an empty HTML file: rather, one full of content
    for quick rendering. SSG projects can be hosted on fast web servers or CDNs, which
    also allows for additional caching and speeding up the loading time of such applications.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的方案在于**静态站点生成**（**SSG**）方法。SSG的逻辑是在项目构建过程中在服务器上渲染所有静态页面。因此，我们得到许多准备就绪的HTML页面，可以在请求时立即交付。与SSR类似，在SSG中，JavaScript包在页面加载后进行激活，使其具有交互性。最终，我们获得与单页应用（SPAs）相同但不是空HTML文件的经验：而是充满内容以便快速渲染。SSG项目可以托管在快速Web服务器或CDNs上，这也允许进行额外的缓存，并加快此类应用程序的加载时间。
- en: SSG became an ideal solution for websites, blogs, and simple online stores,
    ensuring fast page load times without blocking requests, SEO support, and the
    same interactivity as SPAs. Moreover, it became possible to combine SSR for dynamic
    data and SSG for static pages. This hybrid approach opens up new possibilities
    to implement more complex projects, combining the advantages of both methods.
    It allows developers to optimize performance and user experience by choosing the
    best rendering method, depending on the specific requirements of each page of
    the site or application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: SSG成为网站、博客和简单在线商店的理想解决方案，确保快速页面加载时间，不阻塞请求，支持SEO，并且与SPAs具有相同的交互性。此外，现在可以将SSR用于动态数据和SSG用于静态页面结合起来。这种混合方法为实施更复杂的项目开辟了新的可能性，结合了两种方法的优势。它允许开发者通过选择最佳的渲染方法来优化性能和用户体验，具体取决于网站或应用的每一页的具体要求。
- en: Another issue faced by developers and companies is updating statically generated
    pages. For example, traditionally, adding a new blog post or updating an online
    store’s inventory required a complete rebuild of a project, which can be time-consuming
    and inconvenient, especially in large projects. Imagine a blog with 1,000 posts
    having to be completely rebuilt and re-rendered just because a new post being
    added.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者和公司面临的一个问题是更新静态生成的页面。例如，传统上，添加新的博客文章或更新在线商店的库存需要完全重建项目，这可能既耗时又麻烦，尤其是在大型项目中。想象一下，一个有1,000篇文章的博客因为添加了一篇新文章而不得不完全重建和重新渲染。
- en: This problem is solved by an approach known as **incremental static generation**
    (**ISR**). ISR combines the principles of SSG and SSR with caching functionality.
    To understand this approach, imagine all our generated HTML and JS files at the
    build stage simply as a **cache**, representing the current result of the project
    build. As with any cache, we now need to introduce a logic for its revalidation.
    As long as our cache is valid, all page requests work as before using the SSG
    approach. But when the revalidation time expires, the next request to the page
    initiates its re-rendering on the server in SSR mode. The resulting output is
    sent to the client and simultaneously replaces the old HTML file with a new one,
    i.e., updates the cache. The application then continues to operate in SSG mode.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题通过一种称为**增量静态生成**（**ISR**）的方法得到解决。ISR结合了SSG和SSR的原则以及缓存功能。为了理解这种方法，想象我们在构建阶段生成的所有HTML和JS文件只是一个**缓存**，代表项目构建的当前结果。与任何缓存一样，我们现在需要引入其重新验证的逻辑。只要我们的缓存有效，所有页面请求都像以前一样使用SSG方法工作。但是，当重新验证时间到期时，下一个页面请求将启动在SSR模式下在服务器上的重新渲染。生成的输出被发送到客户端，并同时用新的HTML文件替换旧的HTML文件，即更新缓存。然后应用程序继续在SSG模式下运行。
- en: Thanks to ISR, it became possible to implement large-scale projects with millions
    of pages, which do not need to be constantly rebuilt for minor updates. It also
    became possible to altogether skip the generation of pages at the build stage,
    as the required pages would be rendered and saved upon request. For huge projects,
    this provided a significant increase in project build speeds.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了**增量静态生成**（**ISR**），现在可以实施包含数百万页面的大规模项目，这些页面不需要为小更新而不断重建。还可能完全跳过构建阶段的页面生成，因为所需的页面将在请求时进行渲染和保存。对于大型项目，这提供了项目构建速度的显著提升。
- en: 'Currently, SSG with ISR, combined with traditional SSR, is one of the most
    popular approaches for implementing both simple websites and blogs, as well as
    complex applications. However, traditional SPAs remain a very popular solution.
    But if we know how to create and assemble SPAs, what about everything else we
    just discussed? In response to this question, it’s important to note that you
    don’t need to develop all these approaches manually. There are several frameworks
    based on React that provide all the functionalities described above:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，结合ISR的SSG和传统的SSR是实施简单网站、博客以及复杂应用程序中最受欢迎的方法之一。然而，传统的SPA仍然是一个非常受欢迎的解决方案。但如果我们知道如何创建和组装SPA，那么我们刚才讨论的所有其他内容又该如何呢？针对这个问题，重要的是要注意，你不需要手动开发所有这些方法。有几个基于React的框架提供了上述所有功能：
- en: '**Next.js**: This framework is known for its flexibility and powerful features.
    Next.js started with SSR but now supports both SSR and SSG, including ISR support.
    Recently, Next.js has been working extensively on a new concept for implementing
    applications using server components, which we will discuss at the end of the
    chapter.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Next.js**：这个框架以其灵活性和强大的功能而闻名。Next.js最初是SSR，但现在支持SSR和SSG，包括ISR支持。最近，Next.js一直在深入研究一个新的概念，即使用服务器组件实现应用程序，我们将在本章末尾讨论这一点。'
- en: '**Gatsby**: Gatsby’s main distinction is its strong focus on generating static
    sites using data from various sources (such as **CMS** or **Markdown**). While
    there are not as many differences from Next.js as there used to be, it remains
    a fairly popular solution.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gatsby**：Gatsby的主要区别在于它对使用来自各种来源（如**CMS**或**Markdown**）的数据生成静态站点的强烈关注。尽管与Next.js的差异没有以前那么大，但它仍然是一个相当受欢迎的解决方案。'
- en: '**Remix**: This is a relatively new framework that focuses on closer integration
    with web standards and improving the user experience. Remix offers unique approaches
    to data handling and routing, where we can work not page by page but by sections
    of a page, implementing nested navigation by changing and caching only the part
    of the page that requires dynamics.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Remix**：这是一个相对较新的框架，专注于与Web标准的更紧密集成和提升用户体验。Remix提供了独特的数据处理和路由方法，我们可以按页面部分而不是按页面工作，通过仅更改和缓存需要动态内容的页面部分来实现嵌套导航。'
- en: All these frameworks collectively provide a similar experience and implementation
    of the approaches we’ve discussed. Next, we’ll explore how to implement SSR and
    static generation using Next.js.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些框架共同提供了我们讨论过的方法的相似体验和实现。接下来，我们将探讨如何使用 Next.js 实现SSR和静态生成。
- en: Using Next.js
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Next.js
- en: After familiarizing ourselves with the theory of SSR, let’s see how we can implement
    all this in practice using the **Next.js** framework.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉了SSR的理论之后，让我们看看如何使用**Next.js**框架在实践上实现所有这些。
- en: '**Next.js** is a popular React-based framework specifically designed to simplify
    the process of SSR and static site generation. It offers powerful and flexible
    capabilities for creating high-performance web applications.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Next.js** 是一个流行的基于React的框架，专门设计用来简化SSR和静态站点生成的过程。它提供了创建高性能Web应用程序的强大和灵活的功能。'
- en: 'The features of Next.js:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js的功能：
- en: '**An easy-to-use API that automates SSR and static generation**: You just need
    to write code using the provided methods and functions, and the framework will
    automatically determine which pages should be rendered server-side and which can
    be rendered during the project build process.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个易于使用的API，自动实现SSR和静态生成**：你只需要使用提供的方法和函数编写代码，框架将自动确定哪些页面应该在服务器端渲染，哪些可以在项目构建过程中渲染。'
- en: '**File-based routing**: Next.js uses a simple and intuitive routing system
    based on the folder and file structure in the project. This greatly simplifies
    the creation and management of routes in the application.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于文件的路由**：Next.js使用基于项目文件夹和文件结构的简单直观的路由系统。这大大简化了应用程序中路由的创建和管理。'
- en: The ability to create comprehensive full-stack applications, thanks to API routes
    that allow you to implement server-side REST API endpoints.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过API路由实现创建全面的全栈应用程序的能力，这些API路由允许你实现服务器端REST API端点。
- en: The optimization of images, fonts, and scripts, enhancing the performance of
    projects.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像、字体和脚本的优化，提高项目的性能。
- en: Another important feature of the framework is its close collaboration with the
    React Core team on implementing new React features. As a result, Next.js currently
    supports two types of application implementations, known as the **Pages Router**
    and the **App Router**. The former implements the main functionality we discussed
    earlier, while the latter is a newer approach designed for working with React
    Server Components. We will examine the new approach later in this chapter, but
    for now, let’s start with the Pages Router.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的另一个重要特性是与React Core团队紧密合作以实现新的React特性。因此，Next.js目前支持两种应用程序实现类型，称为**Pages
    Router**和**App Router**。前者实现了我们之前讨论的主要功能，而后者是一种为与React Server Components一起工作而设计的新方法。我们将在本章的后面部分检查这种方法，但现在，让我们从Pages
    Router开始。
- en: 'To start working with Next.js, you only need to execute a single command that
    will set everything up for you:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Next.js，你只需要执行一个命令，这个命令会为你设置一切：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This CLI command will ask you a few questions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CLI命令会问你几个问题：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For our current example, you should answer `Yes` to all questions except for
    the one about using the App Router. Also, you can access the ready-made example
    that we’ll discuss further at the provided link: [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter13/using-nextjs](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter13/using-nextjs).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们当前的示例，你应该对所有问题回答“是”，除了关于使用App Router的问题。此外，你可以访问提供的链接中我们将进一步讨论的现成示例：[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter13/using-nextjs](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter13/using-nextjs)。
- en: 'In the example, we will create a small website with multiple pages, each using
    different server rendering approaches. In Next.js, each page of the website should
    be placed in separate files with names that correspond to the URL path. In our
    project example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们将创建一个包含多个页面的小型网站，每个页面使用不同的服务器渲染方法。在Next.js中，网站的每一页都应该放置在具有与URL路径对应的名称的单独文件中。在我们的项目示例中：
- en: The main page of the website, accessible at the root path `domain.com/`, will
    be located in the `index.tsx` file in the `pages` folder. For the understanding
    of the following examples, the path to this file, in the case of the main page,
    will be `pages/index.tsx`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站的主页，可通过根路径`domain.com/`访问，将位于`pages`文件夹中的`index.tsx`文件。为了理解以下示例，主页面文件的路径将是`pages/index.tsx`。
- en: The `/about` page will be located in the `pages/about.tsx` file.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/about`页面将位于`pages/about.tsx`文件中。'
- en: Next, we will create a `/posts` page at the path `pages/posts/index.tsx`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将在路径`pages/posts/index.tsx`创建一个`/posts`页面。
- en: Each individual post page will be located in a file using the path `pages/posts/[post].tsx`.
    Files with names in square brackets indicate to Next.js that this will be a dynamic
    page, with the post variable as a parameter. This means that pages like `/posts/1`
    and `/posts/2` will use this file as the page component.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单独的帖子页面将位于一个使用路径`pages/posts/[post].tsx`的文件中。带有方括号名称的文件指示Next.js这将是一个动态页面，其中帖子变量作为参数。这意味着像`/posts/1`和`/posts/2`这样的页面将使用此文件作为页面组件。
- en: This is how the file routing works. The main directory of the project is the
    `pages` folder, where we can nest files that will be used to generate website
    pages based on the structure and names of files and folders.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是文件路由的工作方式。项目的主要目录是`pages`文件夹，我们可以嵌套文件，这些文件将用于根据文件和文件夹的结构和名称生成网站页面。
- en: 'In the `pages` folder, there are also two service files that are not actual
    pages but are used by the framework to prepare pages:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pages`文件夹中，还有两个服务文件，它们不是实际的页面，但被框架用于准备页面：
- en: The `_document.tsx` file is necessary for preparing the HTML markup. In this
    file, we have access to the `<html>` and `<body>` tags. This file is always rendered
    on the server.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_document.tsx`文件对于准备HTML标记是必要的。在这个文件中，我们可以访问`<html>`和`<body>`标签。这个文件始终在服务器上渲染。'
- en: The `_app.tsx` file is used to initialize the page. You can use this component
    to connect scripts or for the root layout of pages that will be reused between
    routes.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_app.tsx`文件用于初始化页面。你可以使用这个组件来连接脚本或用于在路由之间重复使用的页面的根布局。'
- en: 'Let’s add a header to our website in the `App` component. Here’s how the `_app.tsx`
    file looks:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`App`组件中给我们的网站添加一个标题。下面是`_app.tsx`文件的样子：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `App` component returns markup that will be used on every page of our project,
    which means we will see this header on any of our pages. Additionally, we can
    use the component control where the rest of the dynamic part of the project will
    be located.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件返回的标记将被用于我们项目的每个页面，这意味着我们将在任何页面上看到这个标题。此外，我们还可以使用组件控制，其中将放置项目的其余动态部分。'
- en: 'Now, let’s take a look at how the main page of our project will look:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们项目的首页将是什么样子：
- en: '![](img/B19636_13_04.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4：主页](img/B19636_13_04.png)'
- en: 'Figure 13.4: Home Page'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：主页
- en: 'On this page, we can see the website header with links and the title, which
    was taken from the `pages/index.tsx` file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，我们可以看到带有链接和标题的网站标题，这些内容是从`pages/index.tsx`文件中取出的：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `pages/index.tsx` file exports only one component with a title inside. It’s
    important to note that this page doesn’t have any additional functions or parameters
    and will be automatically rendered during the project build process. This means
    that when we visit this page, we get ready-made HTML that the browser can render
    immediately.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`pages/index.tsx`文件只导出一个包含标题的组件。重要的是要注意，这个页面没有其他函数或参数，将在项目构建过程中自动渲染。这意味着当我们访问这个页面时，我们会得到浏览器可以立即渲染的预制的HTML。'
- en: We can confirm that by visiting `localhost:3000/`, we receive the prepared markup.
    To do this, we just need to open the browser’s developer tools and inspect what
    is returned for this request.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问`localhost:3000/`，我们可以确认我们收到了准备好的标记。为此，我们只需要打开浏览器开发者工具，检查这个请求返回的内容。
- en: '![](img/B19636_13_05.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5：About组件](img/B19636_13_05.png)'
- en: 'Figure 13.5: Home page response in Chrome DevTools'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：Chrome DevTools中的主页响应
- en: We can see how Next.js has taken content from the `App` and `Home` components
    and assembled HTML from it. All of this was done on the server side, not in the
    browser.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Next.js如何从`App`和`Home`组件中提取内容，并从它组装HTML。所有这些都是在服务器端完成的，而不是在浏览器中。
- en: Next, let’s take a look at the `/about` page. On this page, we will implement
    SSR, which means that instead of generating HTML during the build, the page will
    be rendered on every request. For this purpose, Next.js provides the `getServerSideProps`
    function, which runs at the time of the page request and returns props used by
    the component for rendering.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`/about`页面。在这个页面上，我们将实现SSR，这意味着页面不是在构建过程中生成HTML，而是在每次请求时渲染。为此，Next.js提供了`getServerSideProps`函数，它在页面请求时运行，并返回组件用于渲染的props。
- en: 'For our example, I’ve taken some logic from *Chapter 11*, *Fetching Data from
    a Server*, where we fetched user data from GitHub. Let’s see what the `about.tsx`
    file will look like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我从第11章*从服务器获取数据*中取了一些逻辑，其中我们从GitHub获取了用户数据。让我们看看`about.tsx`文件将是什么样子：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `getServerSideProps` function, we request user data using the **Fetch
    API**. The data we receive is stored in the `user` variable, which is then returned
    in the `props` object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getServerSideProps`函数中，我们使用**Fetch API**请求用户数据。我们接收到的数据存储在`user`变量中，然后作为`props`对象返回。
- en: It’s important to understand that this function is part of the Node.js environment,
    where we can use server-side APIs. This means we can read files, access databases,
    and more. This provides significant capabilities for implementing complex full-stack
    projects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解这个函数是Node.js环境的一部分，在那里我们可以使用服务器端API。这意味着我们可以读取文件、访问数据库等。这为实施复杂的全栈项目提供了显著的能力。
- en: 'Next, in the same `about.tsx` file, we have the `About` component:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在同一个`about.tsx`文件中，我们有`About`组件：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `About` component, we use the `user` variable that we returned from the
    `getServerSideProps` function to create the page’s markup. With just this one
    function, we’ve implemented SSR.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`About`组件中，我们使用从`getServerSideProps`函数返回的`user`变量来创建页面的标记。仅通过这个一个函数，我们就实现了SSR（服务器端渲染）。
- en: 'Next, let’s create the `/posts` and `/posts/[post]` pages where we will implement
    SSG and ISR. For this, Next.js provides two functions: `getStaticProps` and `getStaticPaths`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`/posts`和`/posts/[post]`页面，在这些页面中我们将实现SSG（静态生成）和ISR（增量静态化）。为此，Next.js提供了两个函数：`getStaticProps`和`getStaticPaths`：
- en: '`getStaticProps`: This function serves a similar purpose as `getServerSideProps`
    but is called during the project build process.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getStaticProps`：这个函数与`getServerSideProps`具有类似的作用，但在项目构建过程中被调用。'
- en: '`getStaticPaths`: This is used on dynamic pages where the path contains parameters
    (such as `[post].tsx`). This function determines which paths should be pre-generated
    during the build.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getStaticPaths`：这个函数用于动态页面，其中路径包含参数（如`[post].tsx`）。这个函数确定在构建过程中应该预生成哪些路径。'
- en: 'Let’s take a look at how the `Posts` page component is implemented:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Posts` 页面组件是如何实现的：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `getStaticProps` function in this example doesn’t request any data but simply
    returns three pages. However, just like in `getServerSideProps`, you can use `getStaticProps`
    to fetch data or work with the filesystem. The `Posts` component then receives
    posts as `props` and uses them to display a list of links to posts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`getStaticProps` 函数没有请求任何数据，只是简单地返回三个页面。然而，就像在 `getServerSideProps` 中一样，您可以使用
    `getStaticProps` 来获取数据或与文件系统交互。然后，`Posts` 组件接收帖子作为 `props` 并使用它们来显示帖子链接列表。
- en: 'Here’s what the **Posts** page will look like:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 **Posts** 页面的外观：
- en: '![](img/B19636_13_06.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_13_06.png)'
- en: 'Figure 13.6: Posts page'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6：帖子页面
- en: 'When opening any post, the component from the `[post].tsx` file will be loaded.
    Here’s how it looks:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开任何帖子时，来自 `[post].tsx` 文件的组件将被加载。以下是它的外观：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function informs the builder that only three pages need to be rendered
    during the build process. In this function, we can also make network requests.
    The `"fallback"` parameter we returned indicates that, theoretically, there may
    be more post pages than the ones we returned. For example, if we access the `/posts/4`
    `page`, it will be rendered in SSR mode and saved as the build result:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通知构建器在构建过程中只需要渲染三个页面。在此函数中，我们还可以进行网络请求。我们返回的 `"fallback"` 参数表明，理论上可能存在比我们返回的更多帖子页面。例如，如果我们访问
    `/posts/4` 页面，它将以 SSR 模式渲染并保存为构建结果：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `getStaticProps` function, we can now read the page parameter from the
    `context` argument. The value of `revalidate` that we returned from the function
    enables ISR and tells the server to rebuild this page on the next request, after
    `3600` from the previous build. Here’s how the `Post` page will look:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getStaticProps` 函数中，我们现在可以从 `context` 参数中读取页面参数。我们从函数中返回的 `revalidate` 值启用了ISR，并告诉服务器在从上次构建后的
    `3600` 秒后，在下一个请求中重建此页面。以下是 `Post` 页面的外观：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we open any post using the link, we will see the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过链接打开任何帖子时，我们将看到以下内容：
- en: '![](img/B19636_13_07.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_13_07.png)'
- en: 'Figure 13.7: Post page'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7：帖子页面
- en: In this example, we’ve created a website where pages use different server rendering
    approaches, which is useful and convenient for building large and complex projects.
    However, Next.js has more capabilities beyond this. Next, we will explore a new
    approach to building websites using the App Router.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个网站，其中页面使用不同的服务器端渲染方法，这对于构建大型和复杂的项目非常有用且方便。然而，Next.js 的功能远不止于此。接下来，我们将探讨使用
    App Router 构建网站的新方法。
- en: React Server Components
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 服务器组件
- en: React Server Components represent a new paradigm for working with components
    in Next.js that eliminates isomorphic JavaScript. The code of such components
    runs only on a server and can be cached as a result. In this concept, you can
    directly read the server’s filesystem or access the database from the components.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: React 服务器组件代表了在 Next.js 中处理组件的新范式，它消除了同构JavaScript。此类组件的代码仅在服务器上运行，并且可以作为结果进行缓存。在这个概念中，您可以直接从组件中读取服务器的文件系统或访问数据库。
- en: 'In Next.js, React Server Components allow you to categorize components into
    two types: **server-side** and **client-side**. Server-side components are processed
    on a server and sent to the client as static HTML, reducing the load on the browser.
    Client-side components still have all the capabilities of browser JavaScript but
    with one requirement: you need to use the `use client` directive at the beginning
    of the file.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Next.js 中，React 服务器组件允许您将组件分为两种类型：**服务器端**和**客户端**。服务器端组件在服务器上处理，并以静态HTML的形式发送到客户端，从而减少浏览器的负载。客户端组件仍然具有浏览器JavaScript的所有功能，但有一个要求：您需要在文件开头使用
    `use client` 指令。
- en: 'To use server-side components in Next.js, you will need to create a new project.
    For routing, you still use files, but now, the main folder for the project is
    the `app` folder, and route names are based solely on folder names. Inside each
    route (folder), there should be files with names specified by the framework. Here
    are some of the key files:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Next.js 中使用服务器端组件，您需要创建一个新的项目。对于路由，您仍然使用文件，但现在，项目的主要文件夹是 `app` 文件夹，并且路由名称仅基于文件夹名称。在每一个路由（文件夹）内部，应该有框架指定的文件。以下是一些关键文件：
- en: '`page.tsx`: This file and its component will be used to display the page.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page.tsx`: 此文件及其组件将用于显示页面。'
- en: '`loading.tsx`: The component of this file will be sent to the client as a loading
    state while the component from the `page.tsx` file is executed and loaded.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading.tsx`：这个文件的组件将在`page.tsx`文件中的组件执行和加载时作为加载状态发送到客户端。'
- en: '`layout.tsx`: This is equivalent to the `_app.tsx` file, but in this case,
    we can have multiple layouts that can be nested within each other in nested routes.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout.tsx`：这相当于`_app.tsx`文件，但在这个情况下，我们可以有多个布局，它们可以在嵌套路由中相互嵌套。'
- en: '`route.tsx`: This file is used to implement an API endpoint.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route.tsx`：这个文件用于实现API端点。'
- en: 'Now, let’s refactor our website with posts using the new architecture based
    on the **App Router**. Let’s start with the home page. Since our website didn’t
    have any interactive elements, I suggest adding one. Let’s create the simplest
    button with a counter and place it on the home page. Here’s the code for such
    a button:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用基于**App Router**的新架构重构我们的带有帖子的网站。让我们从主页开始。由于我们的网站没有交互元素，我建议添加一个。让我们创建一个最简单的带有计数器的按钮并将其放置在主页上。下面是这个按钮的代码：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This component renders a button with a counter inside. By clicking the button,
    we update the counter. To make this component work with App Router, we need to
    add the “`use client`" directive, which tells Next.js to include this component’s
    code in the bundle and send it to the browser upon request.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件渲染了一个带有计数器的按钮。通过点击按钮，我们更新计数器。为了让这个组件与App Router一起工作，我们需要添加“`use client`"指令，这告诉Next.js在请求时将这个组件的代码包含在包中并发送到浏览器。
- en: 'Now, let’s add this button to the home page, and here’s what its code will
    look like:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把这个按钮添加到主页上，下面是这个按钮的代码示例：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since the page is simple, it doesn’t differ from what we saw in the Pages Router,
    except for the new button. Although, by default, the App Router considers all
    components as server ones, in this case, the page will be rendered during the
    build process and saved as a static page.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于页面很简单，它与我们之前在Pages Router中看到的不同之处仅在于新按钮。尽管如此，默认情况下，App Router将所有组件视为服务器端组件，在这种情况下，页面将在构建过程中渲染并保存为静态页面。
- en: 'Now, let’s move on to the `About` page. To create this page, we need to create
    a folder named `about` and create a file inside it named `page.tsx`, where we’ll
    place the component. Here’s the code for it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到“关于”页面。为了创建这个页面，我们需要创建一个名为“about”的文件夹，并在其中创建一个名为“page.tsx”的文件，我们将在这里放置组件。下面是这个文件的代码：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the code for this page has become simpler compared to using
    the Pages Router. The `About` component has become asynchronous, allowing us to
    make a network request and wait for the result. Since, in our example, we wanted
    to use SSR and render the page on the server for each request, we needed to export
    the “dynamic” variable from the file with the `force-dynamic` value. This parameter
    explicitly tells Next.js that we want to generate a new page for each request.
    Otherwise, Next.js would have generated the page during the project build and
    saved the result as a static page (by using SSG).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，与使用Pages Router相比，这个页面的代码变得更加简单。`About`组件已经变为异步的，这允许我们进行网络请求并等待结果。由于在我们的例子中，我们想要使用SSR并在每个请求时在服务器上渲染页面，我们需要从文件中导出带有`force-dynamic`值的“dynamic”变量。这个参数明确告诉Next.js我们希望为每个请求生成一个新的页面。否则，Next.js会在项目构建期间生成页面并将结果保存为静态页面（通过使用SSG）。
- en: However, it would be strange if the App Router simply repeated the previous
    functionality without offering anything new. If we create a `loading.tsx` file
    inside the `about` folder, when opening the `About` page, instead of waiting for
    the server to request information from GitHub and prepare the page, it will instantly
    serve the page with content from the `loading` file as a fallback. And as soon
    as the component from the `page.tsx` file is ready, the server will send it to
    the client to replace the `loading` component. This provides a significant performance
    advantage and improves the user experience.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果App Router只是重复之前的功能而不提供任何新功能，那就很奇怪了。如果我们创建一个位于“about”文件夹中的`loading.tsx`文件，当打开“关于”页面时，它将立即使用来自`loading`文件的内容作为后备来提供页面，而不是等待服务器从GitHub请求信息并准备页面。一旦`page.tsx`文件中的组件准备好，服务器就会将其发送到客户端以替换`loading`组件。这提供了显著的性能优势并改善了用户体验。
- en: 'Now, let’s move on to the `Posts` page. Create a `posts` folder and a `page.tsx`
    file inside it. Here’s how the updated code for the `/posts` page will look:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到“帖子”页面。在它里面创建一个“posts”文件夹和一个“page.tsx”文件。下面是更新后的“/posts”页面的代码示例：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once again, the code has become very clean. Everything we needed to fetch before
    rendering the page can be obtained and created directly inside the component.
    In our example, we have hardcoded three pages that will be rendered as links.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，代码已经变得非常简洁。在渲染页面之前，我们需要获取的所有内容都可以直接在组件内部获取和创建。在我们的例子中，我们硬编码了三个将被渲染为链接的页面。
- en: 'To implement a `Post` page, inside the `posts` folder, you need to create a
    folder with the name `[post]` and create the `page.tsx` file inside it. Here’s
    the code, which is now much cleaner and more readable:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个“帖子”页面，在“posts”文件夹内，你需要创建一个名为 `[post]` 的文件夹，并在其中创建 `page.tsx` 文件。以下是代码，现在它更加简洁和易读：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Instead of using `getStaticPaths`, we provide Next.js with information about
    the list of static pages to generate during the project build using the `generateStaticParams`
    function. Then, we use props inside the component to display the page’s content:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用 `getStaticPaths`，而是通过 `generateStaticParams` 函数向 Next.js 提供有关在项目构建期间生成静态页面的列表信息。然后，我们使用组件内部的
    props 来显示页面内容：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The content remains mostly unchanged. To activate ISR, all we need to do is
    export the `revalidate` variable from the file with the revalidation value in
    seconds.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 内容基本保持不变。要激活 ISR，我们只需要从包含重新验证值的文件中导出 `revalidate` 变量。
- en: 'In this example, we covered the fundamental approaches to building an application
    using React Server Components and the App Router in Next.js. The Page Router and
    App Router examples provided in this chapter do not cover all the possibilities
    of Next.js. For a deeper understanding of this framework, I recommend checking
    out the excellent documentation on its website: [https://nextjs.org/docs](https://nextjs.org/docs).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们介绍了使用 React Server Components 和 Next.js 的 App Router 构建应用程序的基本方法。本章提供的
    Page Router 和 App Router 示例并没有涵盖 Next.js 的所有可能性。为了更深入地了解这个框架，我建议查看其网站上的优秀文档：[https://nextjs.org/docs](https://nextjs.org/docs)。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored SSR in the context of React applications. We discussed
    approaches such as SSR, SSG, and ISR, learning the advantages and disadvantages
    of each approach.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在 React 应用程序上下文中使用 SSR。我们讨论了如 SSR、SSG 和 ISR 等方法，学习了每种方法的优缺点。
- en: Then, we learned how to apply these approaches in an application using Next.js
    and the Pages Router. Finally, we introduced a new technology called React Server
    Components and the updated Next.js architecture called the App Router.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何在 Next.js 和 Pages Router 的应用中应用这些方法。最后，我们介绍了一种名为 React Server Components
    的新技术，以及 Next.js 的更新版架构，称为 App Router。
- en: In the next chapter, we will learn how to test our components and applications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何测试我们的组件和应用。
