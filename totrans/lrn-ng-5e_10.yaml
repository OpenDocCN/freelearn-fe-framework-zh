- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collecting User Data with Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications use forms to collect input data from users. Use cases vary,
    from allowing users to log in, fill in payment information, book a flight, or
    even perform a search. Form data can later be persisted on local storage or be
    sent to a server using a backend API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics about forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing web forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building template-driven forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reactive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a form builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating input in forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating form state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The chapter contains various code samples to walk you through creating and
    managing forms in Angular. You can find the related source code in the `ch10`
    folder of the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition
    )'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing web forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A form usually has the following characteristics that enhance the user experience
    of a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: Defines different kinds of input fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets up different kinds of validations and displays validation errors to the
    user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports different strategies for handling data if the form is in an error state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Angular framework provides two approaches to handling forms: **template-driven**
    and **reactive** . Neither approach is considered better; you must choose the
    one that best suits your scenario. The main difference between the two approaches
    is how they manage data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Template-driven forms** : These are easy to set up and add to an Angular
    application. They operate solely on the component template to create elements
    and configure validation rules; thus, they are not easy to test. They also depend
    on the change detection mechanism of the framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactive forms** : These are more robust when scaling and testing. They operate
    in the component class to manage input controls and set validation rules. They
    also manipulate data using an intermediate form model, maintaining their immutable
    nature. This technique is for you if you use reactive programming techniques extensively
    or if your Angular application comprises many forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A form in a web application consists of a `<form>` HTML element that contains
    HTML elements for entering data, such as `<input>` and `<select>` elements, and
    `<button>` elements for interacting with the data. The form can retrieve and save
    data locally or send it to a server for further manipulation. The following is
    an example of a simple form that is used for logging a user into a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding form has two `<input>` elements: one for entering the username
    and another for entering the password. The type of the `password` field is set
    to `password` so that the content of the input control is not visible while typing.
    The type of the `<button>` element is set to `submit` so that the form can collect
    data by a user clicking on the button or pressing *Enter* on any input control.'
  prefs: []
  type: TYPE_NORMAL
- en: We could add another button with the `reset` type if we wanted to reset form
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that an HTML element must reside inside the `<form>` element to be part
    of it. The following screenshot shows what the form looks like when rendered on
    a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21418_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Login form'
  prefs: []
  type: TYPE_NORMAL
- en: Web applications can significantly enhance the user experience by using forms
    that provide features such as autocomplete in input controls or prompting the
    user to save sensitive data. Now that we have understood what a web form looks
    like, let’s learn how all that fits into the Angular framework.
  prefs: []
  type: TYPE_NORMAL
- en: Building template-driven forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template-driven forms are one of two different ways of integrating forms with
    Angular. These can be powerful in cases where we want to create small and simple
    forms for our Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about data binding in *Chapter 3* , *Structuring User Interfaces
    with Components* , and how we can use different types to read data from an Angular
    component and write data to it. In that case, binding is either one way or another,
    called **one-way binding** . In template-driven forms, we can combine both ways
    and create a **two-way binding** that can read and write data simultaneously.
    Template-driven forms provide the `ngModel` directive, which we can use in our
    components to get this behavior. To learn more about template-driven forms, we
    will convert the change price functionality of our product detail component to
    work with Angular forms.
  prefs: []
  type: TYPE_NORMAL
- en: You will need the source code of the Angular application we created in *Chapter
    9* , *Navigating through Applications with Routing* , to follow along with the
    rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-detail.component.ts` file and add the following `import`
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add template-driven forms to an Angular application using the `FormsModule`
    class from the `@angular/forms` npm package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `FormsModule` in the `imports` array of the `@Component` decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-detail.component.html` file and modify the `<input>` element
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we bind the `price` property of the `product` template
    variable to the `ngModel` directive of the `<input>` element. The `name` attribute
    is required so that Angular can internally create a unique form control to distinguish
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the `ngModel` directive is known as a *banana in a box* , and
    we create it in two steps. First, we make the *banana* by surrounding `ngModel`
    in parentheses `()` . Then, we put it *in a box* by surrounding it with square
    brackets `[()]` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `<button>` element as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we remove the `click` event from the `<button>` element
    because submitting the form will update the price. We also add the `submit` type
    to indicate that the form submission can happen by a user clicking the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Surround the `<input>` and `<button>` elements with the following `<form>`
    element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we bind the `changePrice` method to the `ngSubmit`
    event of the form. The binding will trigger the method execution if we press *Enter*
    inside the input box or click the button. The `ngSubmit` event is part of the
    Angular `FormsModule` and hooks on the native `submit` event of an HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-detail.component.ts` file and modify the `changePrice` method
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application using the `ng serve` command and select a product from the
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will notice that the current product price is already displayed inside
    the input box. Try to change the price, and you will notice that the current price
    of the product is also changing while you type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![img](img/B21418_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Two-way binding'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of our application depicted in the preceding image is the magic
    behind two-way binding and `ngModel` .
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding was the biggest selling point when AngularJS came out in 2010.
    It was complex to achieve that behavior in those days with vanilla JavaScript
    and jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: While we type inside the input box, the `ngModel` directive updates the value
    of the product price. The new price is directly reflected in the template because
    we use Angular interpolation syntax to display its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, updating the current product price while entering a new one is
    a bad user experience. The user should be able to view the current price of the
    product at all times. We will modify the product detail component so that the
    price is displayed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-detail.component.ts` file and create a `price` property inside
    the `ProductDetailComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `changePrice` method to use the `price` component property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-detail.component.html` file and replace the binding in the
    `<input>` element to use the new component property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we run the application and try to enter a new price inside the **New price**
    input box, we will notice that the current price displayed does not change. The
    functionality of changing the price also works correctly as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen how template-driven forms can be useful when creating small and
    simple forms. In the next section, we dive deeper into the alternative approach
    offered by the Angular framework: reactive forms.'
  prefs: []
  type: TYPE_NORMAL
- en: Building reactive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive forms, as the name implies, reactively provide access to web forms.
    They are built with reactivity in mind, where input controls and their values
    can be manipulated using observable streams. They also maintain an immutable state
    of form data, making them easier to test because we can be sure that the form
    state can be modified explicitly and consistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactive forms have a programmatic approach to creating form elements and setting
    up validation rules by setting everything up in the component class. The Angular
    key classes involved in this approach are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FormControl` : Represents an individual form control, such as an `<input>`
    element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormGroup` : Represents a collection of form controls. The `<form>` element
    is the topmost `FormGroup` in the hierarchy of a reactive form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormArray` : Represents a collection of form controls, just like `FormGroup`
    , but can be modified at runtime. For example, we can add or remove `FormControl`
    objects dynamically as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding classes are available from the `@angular/forms` npm package and
    contain properties that can be used in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: To render the UI differently according to the status of a form or control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check if we have interacted with a form or control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore each form class through an example in our Angular application.
    In the following section, we will introduce reactive forms in our application
    using the product create component.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with reactive forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Angular application we have built contains a component to add new products.
    The component uses template reference variables to collect input data. We will
    use the Angular forms API to accomplish the same task using reactive forms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-create.component.ts` file and add the following `import`
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `ReactiveFormsModule` class in the `imports` array of the `@Component`
    decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Angular forms library provides the `ReactiveFormsModule` class to create
    reactive forms in an Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the following `productForm` property in the `ProductCreateComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `FormGroup` constructor accepts an object that contains key-value pairs
    of form controls. The key is a unique control name, and the value is a `FormControl`
    instance. The `FormControl` constructor accepts the default value of the control
    in the first parameter. For the `title` and the `category` controls, we pass an
    empty string so that we do not set any value initially. For the `price` control,
    which should accept numbers as values, we set it initially to `undefined` . The
    second parameter passed in the `FormControl` is an object that sets the `nonNullable`
    property to indicate that the control does not accept null values.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have created the form group and its controls, we need to associate
    them with the respective HTML elements in the template. Open the `product-create.component.html`
    file and surround the `<input>` , `<select>` , and `<button>` HTML elements with
    the following `<form>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding template, we use the `formGroup` directive, exported from the
    `ReactiveFormsModule` class, to connect a `FormGroup` instance to a `<form>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ReactiveFormsModule` class also exports the `formControlName` directive,
    which we use to connect a `FormControl` instance to an HTML element. Modify the
    form HTML elements as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we set the value of the `formControlName` directive
    to the name of the respective `FormControl` instance. We also remove the template
    reference variables because we can get their values directly from the `FormGroup`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `createProduct` method in the `product-create.component.ts` file
    accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we use the `value` property of the `FormGroup` class
    to get the form value.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `value` property does not include values from disabled fields
    of a form. Instead, we can use the `getRawValue` method to return values from
    all fields.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can use the form value because the form model is identical
    to the `Product` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it was different, we could use the `controls` property of the `FormGroup`
    class to get form control values individually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `FormControl` class contains a `value` property that returns the value of
    a form control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `<form>` element in the `product-create.component.html` file so
    that we create a new product upon form submission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the global `styles.css` file and add the following CSS style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want the preceding styles to be available globally because we will use them
    in the cart component later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `product-create.component.css` file and remove the style for the `<label>`
    tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we run the application, we will see that the functionality of adding a new
    product still works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that the `FormGroup` class groups a collection of form controls.
    A form control can be a single form control or another form group, as we will
    see in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating nesting form hierarchies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The product create component consists of a single form group with three form
    controls. Some use cases in enterprise applications require more advanced forms
    that involve creating nested hierarchies of form groups. Consider the following
    form, which is used to add a new product along with additional details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: New product form with additional information'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding form may look like a single form group, but if we take a deeper
    look at the component class, we will see that the `productForm` consists of two
    `FormGroup` instances, one nested inside the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `productForm` property is the parent form group, while `extra` is its child.
    A parent form group can have as many children form groups as it needs. If we take
    a look at the component template, we will see that the child form group is defined
    differently from the parent one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding HTML template, we use the `formGroupName` directive to bind
    the inner form element to the `extra` property.
  prefs: []
  type: TYPE_NORMAL
- en: You may have expected to bind it directly to the `productForm.extra` property,
    but Angular is pretty smart because it understands that `extra` is a child form
    group of `productForm` . It can deduce this information because the form element
    related to `extra` is inside the form element that binds to the `productForm`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: The value of a child form group is shared with its parent in a nested form hierarchy.
    In our case, the value of the `extra` form group will be included in the `productForm`
    group, thereby maintaining a consistent form model.
  prefs: []
  type: TYPE_NORMAL
- en: We have already covered the `FormGroup` and `FormControl` classes. In the following
    section, we will learn how to use the `FormArray` class to interact with dynamic
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying forms dynamically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the scenario where we have added some products to the shopping cart
    of our e-shop application and want to update their quantities before checking
    out the order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, our application does not have any functionality for a shopping cart,
    so we will now add one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a `Cart` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `cart.ts` file and modify the `Cart` interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, the `products` property will contain the product IDs
    that belong to the current cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new service to manage the shopping cart by running the following Angular
    CLI command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `cart.service.ts` file and modify the `import` statements as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following properties in the `CartService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `cartUrl` property is used for the cart endpoint of the Fake Store API and
    the `cart` property to keep a local cache of the user cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inject the `HttpClient` service in the `constructor` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method to add a product to the cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we use a new RxJS operator called `defer` . The `defer`
    operator works as an if/else statement for observables.
  prefs: []
  type: TYPE_NORMAL
- en: If the `cart` property has not been initialized, which means that our cart is
    currently empty, we initiate a POST request to the API passing the `cartProduct`
    variable as a parameter. Otherwise, we initiate a PATCH request passing the `cartProduct`
    along with the existing products from the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have completed the setup of our service so that it can communicate with
    the Fake Store API. Now, we need to connect the service with the respective component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-detail.component.ts` file and add the following `import`
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject `CartService` in the `ProductDetailComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `addToCart` method so that it calls the `addProduct` method of the
    `CartService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, open the `product-detail.component.html` file and modify the `click`
    event of the `Add to cart` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have implemented the basic functionality for storing the selected products
    that users want to buy. Now, we must modify the cart component to display the
    cart items:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `cart.component.ts` file and modify the `import` statements as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `ReactiveFormsModule` class in the `imports` array of the `@Component`
    decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `OnInit` interface to the list of implemented interfaces of the `CartComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following properties in the TypeScript class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we created a `FormGroup` object containing a `products`
    property. We set the value of the `products` property to an instance of the `FormArray`
    class. The constructor of the `FormArray` class accepts a list of `FormControl`
    instances with the type `number` as a parameter. The list is empty for now since
    the cart has no products. The `products` property outside the `FormGroup` instance
    will be used for lookup reasons to display the title of each product in the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `constructor` to inject the following services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following method to get products from the cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we initially subscribe to the `getProducts` method
    of the `ProductsService` class to get the available products. Then, for each product
    in the cart, we extract the `productId` property and check if it exists inside
    the cart. If the product is found, we add it to the `products` component property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another method to build our form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we iterate over the `products` property and add a `FormControl`
    instance for each one inside the `products` form array. We set the value of each
    form control to `1` to indicate that the cart contains one item of each product
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `ngOnInit` method that combines both methods from *steps
    6* and *7* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `cart.component.html` file and replace its HTML template with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding template, we use a `@for` block to iterate over the `controls`
    property of the `products` form array and create an `<input>` element for each
    one. We use the `$index` keyword of the `@for` block to give a dynamically created
    name to each form control using the `formControlName` binding. We have also added
    a `<label>` tag that displays the product title from the `products` component
    property. The product title is fetched using the `$index` of the current product
    in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, open the `cart.component.css` files and add the following CSS styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To see the cart component in action, run the application using the `ng serve`
    command and add some products to the cart.
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to log in first because the functionality that adds a product
    to the cart is available only to authenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding some products to the cart, click the **My Cart** link to view
    your shopping cart. It should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, διάγραμμα  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Shopping cart'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have established the business logic for managing a shopping cart,
    we can also update the checkout guard we created in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `checkout.guard.ts` file and add the following `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject the `CartService` class in the `checkoutGuard` function using the following
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the remaining body of the `checkoutGuard` arrow function so that we
    display the confirmation dialog only when the cart is not empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `FormArray` , we have completed our exploration of the most basic building
    blocks of an Angular form. We learned how to use Angular forms classes to create
    structured web forms and collect user input. In the following section, we will
    learn how to build Angular forms using the `FormBuilder` service.
  prefs: []
  type: TYPE_NORMAL
- en: Using a form builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using form classes to build Angular forms can become repetitive and tedious
    for complex scenarios. The Angular framework provides `FormBuilder` , a built-in
    service to Angular forms that contains helper methods for building forms. Let’s
    see how we could use it to build a form for creating new products:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-create.component.ts` file and import the `OnInit` and `FormBuilder`
    artifacts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `OnInit` to the list of implemented interfaces in the `ProductCreateComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject the `FormBuilder` class in the `constructor` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `productForm` property as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we define only the structure of the form because it
    will now be created using the `FormBuilder` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following method to build the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we use the `nonNullable` property of the `FormBuilder`
    class to create a form group that cannot be null. The `group` method is used to
    group form controls. The `title` and `category` form controls are created using
    an empty string as the default value. The `price` form control follows a different
    approach from the rest because we cannot assign a default value of `undefined`
    due to TypeScript language limitations. In this case, we use the `control` method
    of the `nonNullable` property to define the form control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ngOnInit` lifecycle hook to execute the `buildForm` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the non-null assertion operator when accessing the `productForm` property
    in the `createProduct` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-create.component.html` file and add the non-null assertion
    operator in the `<form>` HTML element also:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the `FormBuilder` service to create Angular forms, we don’t have to deal
    with the `FormGroup` and `FormControl` data types explicitly, although that is
    what is being created under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application using the `ng serve` command and verify that the new product
    creation process works correctly. Try to click the **Create** button without entering
    any values in the form controls and observe what happens in the product list.
    The application creates a product with an empty title. It is a situation that
    we should avoid in a real-world scenario. We should be aware of the status of
    a form control and take action accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The example code in the rest of the chapter does not use the `FormBuilder` service
    when working with reactive forms.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we’ll investigate different properties that we can
    check to get form status and provide feedback to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Validating input in forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Angular form should validate input and provide visual feedback to enhance
    UX and guide users to complete the form successfully. We will investigate the
    following ways to validate forms in Angular applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Global validation with CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation in the component class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation in the component template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building custom validators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we will learn how to apply validation rules globally
    in an Angular application using CSS styles.
  prefs: []
  type: TYPE_NORMAL
- en: Global validation with CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Angular framework sets the following CSS classes automatically in a form,
    template-driven or reactive, that we can use to provide user feedback:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ng-untouched` : Indicates that we have not interacted with a form yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-touched` : Indicates that we have interacted with a form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-dirty` : Indicates that we have set a value to a form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-pristine` : Indicates that we have not modified a form yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Furthermore, Angular adds the following classes on the HTML element of a form
    control:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ng-valid` : Indicates that the value of a form is valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-invalid` : Indicates that the value of a form is not valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular sets the preceding CSS classes in the form and its controls according
    to their status. The form status is evaluated according to the status of its controls.
    For example, if at least one form control is invalid, Angular will set the `ng-invalid`
    CSS class to the form and the corresponding control.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of nested form hierarchies, the status of a child form group is
    bubbled up to the hierarchy and shared with its parent form.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the built-in CSS classes and style Angular forms using CSS only.
    For example, to display a light blue highlighted border in an input control when
    interacting with that control for the first time, we should add the following
    style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also combine CSS classes according to the needs of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the global `styles.css` file and modify the `input.valid` style as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding style will display a green border when an input control has a
    valid value entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `input.invalid` style accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding style will display a red border when an input control has an invalid
    value entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-create.component.html` file and add the `required` attribute
    in the `<input>` form controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application using the `ng serve` command and navigate to `http://localhost:4200/products/new`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter some text into the **Title** field and click outside of the input control.
    Notice that it has a green border.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the text from the **Title** field and click outside of the input control.
    The border should now turn red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We learned how to define validation rules in the template using CSS styles.
    In the following section, we will learn how to define them in template-driven
    forms and give visual feedback using appropriate messages.
  prefs: []
  type: TYPE_NORMAL
- en: Validation in template-driven forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding section, we learned that Angular adds a collection of built-in
    CSS classes while validating Angular forms. Each class has a corresponding boolean
    property in the respective form model, both in template-drive and reactive forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`untouched` : Indicates that we have not interacted with a form yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touched` : Indicates that we have interacted with a form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dirty` : Indicates that we have set a value to a form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pristine` : Indicates that we have not modified a form yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid` : Indicates that the value of a form is valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalid` : Indicates that the value of a form is not valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can leverage the preceding classes and inform the user about the current
    form status. First, let’s investigate the behavior of the change price process
    in the product details component:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `ng serve` command to start the application and navigate to `http://localhost:4200`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a product from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a value of `0` into the **New price** input box and click the **Change**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the same product from the list and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Product details'
  prefs: []
  type: TYPE_NORMAL
- en: The presentation logic of the component fails to detect that the user can enter
    `0` for the product price. A product should always have a price.
  prefs: []
  type: TYPE_NORMAL
- en: The product details component needs to validate the input of the price value,
    and if the input is found to be invalid, disable the **Change** button, and display
    an informational message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Handling validation is a matter of personal preference or business specification.
    In this scenario, we decided to showcase a common validation approach by disabling
    the button and displaying an appropriate message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template-driven validation is performed in the component template. Open the
    `product-detail.component.html` file and execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `priceCtrl` template reference variable and bind it to the `ngModel`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ngModel` property gives us access to the underlying form control model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `required` and `min` validation attributes to the HTML element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `min` validation attribute can be used only with `<input>` HTML elements
    of the `number` type. It is used to define the minimum value when using the arrows
    of the numeric control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `<span>` HTML element underneath the `<button>` element of
    the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding HTML element will be displayed when we enter a price value and
    then either leave it blank or enter a zero. We use the `hasError` method of the
    form control model to check if the `min` validation throws an error.
  prefs: []
  type: TYPE_NORMAL
- en: All validation attributes can be checked using the `hasError` method. The validity
    status of a control is evaluated based on the status of all validation attributes
    we attach to the HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `priceForm` template reference variable in the `<form>` HTML element
    and bind it to the `ngForm` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ngForm` property gives us access to the underlying form model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bind the `disabled` property of the `<button>` HTML element to the `invalid`
    status of the form model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding template, we could bind directly to the `priceCtrl.invalid`
    status since the form has only one control. We choose the form instead for demonstration
    purposes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `styles.css` file and add the following CSS styles for the `<span>`
    tag and the `disabled` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify that the validation works as intended, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `ng serve` command to start the application and select a product from
    the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `0` in the **New price** input box and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Validation error'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a valid value and verify that the error message is gone and the **Change**
    button is enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the **New price** input box blank and verify that the error message is
    displayed again and the **Change** button is disabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have learned how to accomplish validation in template-driven forms,
    let’s see how to validate input data in reactive ones.
  prefs: []
  type: TYPE_NORMAL
- en: Validation in reactive forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Template-driven forms rely solely on the component template to perform validations.
    In reactive forms, the source of truth is our form model that resides in the TypeScript
    class of the component. We define validation rules in reactive forms when building
    the `FormGroup` instance programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate validation in reactive forms, we will add validation rules in
    the product create component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-create.component.ts` file and import the `Validators` class
    from the `@angular/forms` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the declaration of the `productForm` property so that the `title` and
    `price` form controls pass a `validators` property in the `FormControl` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Validators` class contains a static field for each validation rule available.
    It contains almost the same validator rules that are available for template-driven
    forms. We can combine multiple validators by adding them to an array, as indicated
    by the `validators` property in the `price` form control.
  prefs: []
  type: TYPE_NORMAL
- en: When we add a validator using the `FormControl` class, we can remove the respective
    HTML attribute from the HTML template. However, it is recommended to keep it for
    accessibility purposes so that screen-reader applications can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-create.component.html` file and use the `invalid` property
    of the `productForm` property to disable the `Create` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `<span>` HTML element in each `<input>` form control to display an error
    message when the control has been touched, and the `required` validation throws
    an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we use the `controls` property of the `productForm`
    property to get access to the individual form control models and get their statuses.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be nice to display different messages depending on the validation
    rule. We could display a more specific message when the `min` validation of the
    `price` control throws an error, for example. We can use the `hasError` method
    that we saw in the preceding section to display such a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Angular framework provides a set of built-in validators that we learned
    to use in our forms. In the following section, we will learn how to create a custom
    validator for template-driven and reactive forms to satisfy particular business
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Building custom validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Built-in validators won’t cover all the scenarios we might encounter in an Angular
    application; however, writing a custom validator and using it in an Angular form
    is easy. In our case, we will build a validator to check that the price of a product
    cannot exceed a specified threshold.
  prefs: []
  type: TYPE_NORMAL
- en: We could use the built-in `max` validator to accomplish the same task. However,
    we will be building the validator function for learning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validators are used when we want to validate a form or a control with
    custom code. For example, to communicate with an API for validating a value, or
    to perform a complex calculation for validating a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `price-maximum.validator.ts` in the `src\app` folder and
    add the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A form validator is a function that returns a `ValidationErrors` object with
    the error specified or a `null` value. It accepts the form control to which it
    will be applied as a parameter. In the preceding snippet, if the control value
    is larger than a specific threshold passed in the `price` parameter of the exported
    function, it returns a validation error object. Otherwise, it returns `null` .
  prefs: []
  type: TYPE_NORMAL
- en: The key of the validation error object specifies a descriptive name for the
    validator error. It is a name we can later check with the `hasError` method of
    the control to find out if it has any errors. The value of the validation error
    object can be any arbitrary value that we can pass in the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-create.component.ts` file and add the following `import`
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the validator in the `validators` array of the `price` form control and
    set the threshold to `1000` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new `<span>` HTML element for the price form control in the `product-create.component.html`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `ng` `serve` command to start the application and navigate to `http://localhost:4200/products/new`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter a value of `1200` in the **Price** field, click outside the input box,
    and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Validation in reactive forms'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the price maximum validator in a template-driven form, we must follow
    a different approach that involves creating an Angular directive:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create an Angular directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding directive will act as a wrapper over the `priceMaximumValidator`
    function we have already created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `price-maximum.directive.ts` file and modify the `import` statements
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `NG_VALIDATORS` provider in the `@Directive` decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `NG_VALIDATORS` token is a built-in token of Angular forms that helps us
    register an Angular directive as a form validator. In the preceding snippet, we
    use the `multi` property in the provider configuration because we can register
    multiple directives with the `NG_VALIDATORS` token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Validator` interface in the implemented interfaces of the `PriceMaximumDirective`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following input property that will be used to pass a value for the
    maximum threshold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding property, we pass a configuration object with two properties
    as a parameter in the `input` function. The `alias` property defines the name
    of the input property that we will use for binding. The `transform` property is
    used to convert the value of the input property to a different type. The `numberAttribute`
    is a built-in function of the Angular framework that converts the input property
    value to a number.
  prefs: []
  type: TYPE_NORMAL
- en: Angular also contains the `booleanAttribute` function, which parses an input
    property value as a boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `validate` method of the `Validator` interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The signature of the `validate` method is the same as the function returned
    from the `priceMaximumValidator` function. It checks the `appPriceMaximum` input
    property and accordingly delegates its value to the `priceMaximumValidator` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the new directive we created in the product detail component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-detail.component.ts` file and add the following `import`
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `PriceMaximumDirective` class in the `imports` array of the `@Component`
    decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-detail.component.html` file and add the new validator in
    the `<input>` HTML element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new `<span>` HTML element to display a different message when the validator
    throws an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `ng serve` command to start the application and select a product from
    the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the value `600` in the **New price** input box and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Validation in template-driven forms'
  prefs: []
  type: TYPE_NORMAL
- en: Angular custom validations can work synchronously or asynchronously. In this
    section, we learned how to work with the former. Asynchronous validations are
    an advanced topic that we will not cover in this book. However, you can learn
    more at [https://angular.dev/guide/forms/form-validation#creating-asynchronous-validators](https://angular.dev/guide/forms/form-validation#creating-asynchronous-validators)
    .
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will explore manipulating the state of an Angular
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating form state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The state of an Angular form differs between template-driven and reactive forms.
    In the former, the state is a plain object, whereas in the latter, it is kept
    in the form model. In this section, we will learn about the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Updating form state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reacting to state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by exploring how we can change the form state.
  prefs: []
  type: TYPE_NORMAL
- en: Updating form state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with the form state in template-driven forms is relatively easy. We
    must interact with the component property bound to the `ngModel` directive of
    a form control.
  prefs: []
  type: TYPE_NORMAL
- en: 'In reactive forms, we can use the `value` property of a `FormControl` instance
    or the following methods of the `FormGroup` class to change values in the whole
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setValue` : Replaces values in all controls of the form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patchValue` : Updates values in specific controls of the form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `setValue` method accepts an object as a parameter that contains key-value
    pairs for all form controls. If we want to fill in the details of a product in
    the product create component programmatically, the following snippet serves as
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, each key of the object passed in the `setValue` method
    must match the name of each form control. If we omit one, Angular will throw an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to fill in some of the details of a product, we can use the `patchValue`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `setValue` and `patchValue` methods of the `FormGroup` class help us set
    data in a form.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting aspect of forms is that we can be notified when these values
    change, as we will see in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Reacting to state changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common scenario when working with Angular forms is that we want to trigger
    a side effect when the value of a form control changes. A side effect can be any
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To alter the value of a form control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To initiate an HTTP request to filter the value of a form control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To enable/disable certain parts of the component template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In template-driven forms, we can use an extended version of the `ngModel` directive
    to get notified when its value changes. The `ngModel` directive contains the following
    bindable properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngModel` : An input property for passing values to the control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngModelChange` : An output property for getting notified when the control
    value changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can write the `ngModel` binding in the `<input>` HTML element of the product
    detail component in the following alternate way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we set the value of the `ngModel` input property using
    property binding and the value of the `price` component property using event binding.
    Angular triggers the `ngModelChange` event automatically and includes the new
    value of the `<input>` HTML element in the `$event` property. We can use the `ngModelChange`
    event for any side effects in our component when the value of the price form control
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: In reactive forms, we use an observable-based API to react to state changes.
    The `FormGroup` and `FormControl` classes contain the `valueChanges` observable,
    which we can use to subscribe and get notified when the value of the form or control
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use it to reset the value of the `price` form control in the product
    create component when the category changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-create.component.ts` file and import the `OnInit` artifact
    from the `@angular/core` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `OnInit` interface to the list of the `ProductCreateComponent` class
    implemented interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following `ngOnInit` method to subscribe to the `valueChanges` property
    of the `category` form control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we reset the value of the `price` form control by using
    the `reset` method of the `FormControl` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `valueChanges` property of the `FormControl` class is a standard observable
    stream. Do not forget to unsubscribe when the component is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is more that we can do with the `valueChanges` observable;
    for example, we could check if the product title is already reserved by sending
    it to a backend API. Hopefully, however, the preceding examples have conveyed
    how you can take advantage of the reactive nature of forms and respond accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that Angular provides two different flavors for
    creating forms – template-driven and reactive – and neither approach is better
    than the other. We explored how to build each form type and perform validations
    on input data, and covered custom validations for implementing additional validation
    scenarios. We also learned how to update the state of a form and how to react
    when the values in the state change.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will explore various ways of handling application
    errors. Error handling is a very important feature of an Angular application and
    can have different sources and reasons, as we will see.
  prefs: []
  type: TYPE_NORMAL
