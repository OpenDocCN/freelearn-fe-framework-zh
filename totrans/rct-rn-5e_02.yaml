- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Why React?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择React？
- en: If you’re reading this book, you probably are already familiar with **React**.
    But if you’re not, don’t worry. I’ll do my best to keep philosophical definitions
    to a minimum. However, this is a long book with a lot of content, so I feel that
    setting the tone is an appropriate first step. Our goal is to learn React and
    **React Native**, but it’s also to build a scalable and adaptive architecture
    that can handle everything we want to build with React today and in the future.
    In other words, we want to create a foundation around React, with a set of additional
    tools and approaches that can withstand the test of time. This book will guide
    you through the process of using tools like routing, TypeScript typing, testing,
    and many more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，你可能已经熟悉**React**了。但如果你不熟悉，不要担心。我会尽力将哲学定义保持到最小。然而，这是一本内容丰富的长书，所以我感觉设定基调是一个合适的第一步。我们的目标是学习React和**React
    Native**，但也是构建一个可扩展和适应性强的架构，可以处理我们今天和未来想要用React构建的一切。换句话说，我们想要围绕React建立一个基础，并配备一套额外的工具和方法，这些工具和方法能够经受时间的考验。本书将指导你使用诸如路由、TypeScript类型、测试等工具的过程。
- en: This chapter starts with a brief explanation of why React exists. Then, we’ll
    think about the simplicity of React and how it is able to handle many of the typical
    performance issues faced by web developers. Next, we’ll go over the declarative
    philosophy of React and the level of abstraction that React programmers can expect
    to work with. Then, we’ll touch on some of the major features of React. And finally,
    we will explore how we can set up a project to start to work with React.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先简要解释了React存在的理由。然后，我们将思考React的简洁性以及它如何能够处理许多网络开发者面临的典型性能问题。接下来，我们将探讨React的声明式哲学以及React程序员可以期望与之一起工作的抽象级别。然后，我们将简要介绍React的一些主要功能。最后，我们将探讨如何设置一个项目以开始使用React。
- en: 'Once you have a conceptual understanding of React and how it solves problems
    with UI development, you’ll be better equipped to tackle the remainder of the
    book. This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对React及其如何解决UI开发问题有了概念性的理解，你将更有能力应对本书的其余部分。本章将涵盖以下主题：
- en: What is React?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是React？
- en: What’s new in React?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React的新功能有哪些？
- en: Setting up a new React project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置新的React项目
- en: What is React?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是React？
- en: 'I think the one-line description of React on its home page ([https://react.dev/](https://react.dev/))
    is concise and accurate:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为React在其主页上的一行描述([https://react.dev/](https://react.dev/))简洁且准确：
- en: ”A JavaScript library for building user interfaces.”
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “一个用于构建用户界面的JavaScript库。”
- en: This is perfect because, as it turns out, this is all we want most of the time.
    I think the best part about this description is everything that it leaves out.
    It’s not a mega-framework. It’s not a full-stack solution that’s going to handle
    everything, from the database to real-time updates over **WebSocket** connections.
    We might not actually want most of these prepackaged solutions. If React isn’t
    a framework, then what is it exactly?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常完美，因为事实证明，这是我们大多数时候想要的全部。我认为这个描述最好的部分就是它省略了所有内容。它不是一个大型框架。它不是一个全栈解决方案，将处理从数据库到通过**WebSocket**连接的实时更新的所有事情。我们可能实际上并不需要大多数这些预包装的解决方案。如果React不是一个框架，那么它究竟是什么呢？
- en: React is just the view layer
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React只是视图层
- en: 'React is generally thought of as the *view layer* in an application. Applications
    are typically divided into different layers, such as the view layer, the logic
    layer, and the data layer. React, in this context, primarily handles the view
    layer, which involves rendering and updating the UI based on changes in data and
    application state. React components change what the user sees. The following diagram
    illustrates where React fits in our frontend code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常认为React是应用程序中的*视图层*。应用程序通常分为不同的层，如视图层、逻辑层和数据层。在这个背景下，React主要处理视图层，这涉及到根据数据和应用状态的变化来渲染和更新UI。React组件改变用户看到的内容。以下图表说明了React在我们前端代码中的位置：
- en: '![](img/B19636_01_01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_01_01.png)'
- en: 'Figure 1.1: The layers of a React application'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：React应用程序的层级
- en: 'This is all there is to React – the core concept. Of course, there will be
    subtle variations to this theme as we make our way through the book, but the flow
    is more or less the same:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是React的全部内容——核心概念。当然，随着我们阅读本书，这个主题可能会有细微的变化，但流程大致相同：
- en: '**Application logic**: Start with some application logic that generates data.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用逻辑**：从一些生成数据的应用逻辑开始'
- en: '**Rendering data to the UI**: The next step is to render this data to the UI.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将数据渲染到UI上**：下一步是将这些数据渲染到UI上。'
- en: '**React component**: To accomplish this, you pass the data to a React component.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**React组件**：为了实现这一点，您将数据传递给React组件。'
- en: '**Component’s role**: The React component takes on the responsibility of getting
    the HTML onto the page.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**组件的角色**：React组件承担将HTML放入页面的责任。'
- en: You may wonder what the big deal is; React appears to be yet another rendering
    technology. We’ll touch on some of the key areas where React can simplify application
    development in the remaining sections of the chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想这有什么大不了的；React看起来只是另一种渲染技术。在章节的剩余部分，我们将讨论React在哪些关键领域可以简化应用程序开发。
- en: Simplicity is good
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单是好的
- en: 'React doesn’t have many moving parts to learn about and understand. While React
    boasts a relatively simple API, it’s important to note that beneath the surface,
    React operates with a degree of complexity. Throughout this book, we will delve
    into these internal workings, exploring various aspects of React’s architecture
    and mechanisms to provide you with a comprehensive understanding. The advantage
    of having a small API to work with is that you can spend more time familiarizing
    yourself with it, experimenting with it, and so on. The opposite is true of large
    frameworks, where all of your time is devoted to figuring out how everything works.
    The following diagram gives you a rough idea of the APIs that we have to think
    about when programming with React:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: React没有太多需要学习和理解的部分。虽然React吹嘘有一个相对简单的API，但重要的是要注意，在表面之下，React以一定程度的复杂性运行。在这本书的整个过程中，我们将深入研究这些内部工作原理，探索React架构和机制的各个方面，以提供给您一个全面的理解。使用小型API的优势在于，您可以花更多的时间熟悉它，实验它，等等。相反，大型框架则不同，您所有的时间都用于弄清楚一切是如何工作的。以下图表为您提供了一个大致的概念，当使用React编程时，我们需要考虑哪些API：
- en: '![](img/B19636_01_02.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_01_02.png)'
- en: 'Figure 1.2: The simplicity of the React API'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：React API的简单性
- en: 'React is divided into two major APIs:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: React分为两个主要API：
- en: '**The React Component API**: These are the parts of the page that are rendered
    by the **React DOM**.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React组件API**：这些是页面由**React DOM**渲染的部分。'
- en: '**React DOM**: This is the API that’s used to perform the rendering on a web
    page.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React DOM**：这是用于在网页上执行渲染的API。'
- en: 'Within a React component, we have the following areas to think about:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在React组件中，我们有以下区域需要考虑：
- en: '**Data**: This is data that comes from somewhere (the component doesn’t care
    where) and is rendered by the component.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：这是来自某处（组件并不关心它来自哪里）的数据，并由组件渲染。'
- en: '**Lifecycle**: For example, one phase of the lifecycle is when the component
    is about to be rendered. Within a React component, methods or hooks respond to
    the component’s entering and exiting phases of the React rendering process as
    they happen over time.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期**：例如，生命周期的一个阶段是组件即将被渲染的时候。在React组件中，方法或钩子会响应组件在React渲染过程中的进入和退出阶段，这些阶段随着时间的推移而发生。'
- en: '**Events**: These are the code that we write to respond to user interactions.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：这是我们编写的响应用户交互的代码。'
- en: '**JSX**: This is the syntax commonly used for describing UI structures in React
    components. Even though JSX is closely associated with React, it can also be used
    alongside other **JavaScript** frameworks and libraries.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSX**：这是在React组件中描述UI结构的常用语法。尽管JSX与React紧密相关，但它也可以与其他**JavaScript**框架和库一起使用。'
- en: Don’t fixate on what these different areas of the React API represent just yet.
    The takeaway here is that React, by nature, is simple. Just look at how little
    there is to figure out! This means that we don’t have to spend a ton of time going
    through API details here. Instead, once you pick up on the basics, we can spend
    more time on nuanced React usage patterns that fit in nicely with declarative
    UI structures.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不要一开始就专注于这些不同的React API区域代表什么。这里的要点是，React本质上很简单。只需看看有多少东西需要弄清楚！这意味着我们不必花很多时间在这里详细研究API。相反，一旦掌握了基础知识，我们就可以花更多的时间在符合声明式UI结构的细微React使用模式上。
- en: Declarative UI structures
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式UI结构
- en: React newcomers have a hard time getting to grips with the idea that components
    mix in markup with their JavaScript in order to declare UI structures. If you’ve
    looked at React examples and had the same adverse reaction, don’t worry. Initially,
    we can be skeptical of this approach, and I think the reason is that we’ve been
    conditioned for decades by the *separation of concerns* principle. This principle
    states that different concerns, such as logic and presentation, should be separate
    from one another. Now, whenever we see things combined, we automatically assume
    that this is bad and shouldn’t happen.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: React 新手往往难以理解组件如何将标记与 JavaScript 混合以声明 UI 结构。如果你看过 React 示例并产生了相同的负面反应，请不要担心。起初，我们可能会对这个方法持怀疑态度，我认为原因是我们几十年来一直被“关注点分离”原则所影响。这个原则指出，不同的关注点，如逻辑和展示，应该彼此分离。现在，每当我们看到事物结合在一起时，我们就会自动假设这是不好的，不应该发生。
- en: The syntax used by React components is called **JSX** (short for **JavaScript
    XML**, also known as **JavaScript Syntax Extension**). A component renders content
    by returning some JSX. The JSX itself is usually HTML markup, mixed with custom
    tags for React components. The specifics don’t matter at this point; we’ll go
    into detail in the coming chapters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件使用的语法称为 **JSX**（即 **JavaScript XML**，也称为 **JavaScript 语法扩展**）。组件通过返回一些
    JSX 来渲染内容。JSX 本身通常是 HTML 标记，混合了 React 组件的自定义标签。具体细节在此处并不重要；我们将在接下来的章节中详细介绍。
- en: What’s groundbreaking about the declarative JSX approach is that we don’t have
    to manually perform intricate operations to change the content of a component.
    Instead, we describe how the UI should look in different states, and React efficiently
    updates the actual DOM to match. As a result, React UIs become easier and more
    efficient to work with, resulting in better performance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式 JSX 方法令人耳目一新的地方在于，我们不必手动执行复杂的操作来更改组件的内容。相反，我们描述 UI 在不同状态下的外观，React 高效地更新实际的
    DOM 以匹配。因此，React UI 变得更容易和更高效地处理，从而带来更好的性能。
- en: 'For example, think about using something such as jQuery to build your application.
    You have a page with some content on it, and you want to add a class to a paragraph
    when a button is clicked:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想想使用 jQuery 来构建你的应用程序。你有一个页面，上面有一些内容，你想要在按钮点击时给一个段落添加一个类：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Performing these steps is easy enough. This is called imperative programming,
    and it’s problematic for UI development. The problem with imperative programming
    in UI development is that it can lead to code that is difficult to maintain and
    modify. This is because imperative code is often tightly coupled, meaning that
    changes to one part of the code can have unintended consequences elsewhere. Additionally,
    imperative code can be difficult to reason about, as it can be hard to understand
    the flow of control and the state of an application at any given time. While this
    example of changing the class of an element is simple, real applications tend
    to involve more than three or four steps to make something happen.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些步骤足够简单。这被称为命令式编程，对于 UI 开发来说是有问题的。命令式编程在 UI 开发中的问题在于，它可能导致难以维护和修改的代码。这是因为命令式代码通常紧密耦合，意味着对代码某一部分的更改可能会在别处产生意外的后果。此外，命令式代码可能难以推理，因为它可能很难理解控制流的流动和应用程序在任何给定时间的状态。虽然这个更改元素类的例子很简单，但真实的应用程序往往需要超过三四个步骤才能实现某个功能。
- en: React components don’t require you to execute steps in an imperative way. This
    is why JSX is central to React components. The XML-style syntax makes it easy
    to describe what the UI should look like – that is, what are the HTML elements
    that component is going to render?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件不需要你以命令式的方式执行步骤。这就是 JSX 成为 React 组件核心的原因。XML 风格的语法使得描述 UI 应该是什么样子变得容易——也就是说，组件将要渲染哪些
    HTML 元素？
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we’re not just writing the imperative procedure that the browser
    should execute. This is more like an instruction, where we say how the UI should
    look and what user interaction should happen on it. This is called declarative
    programming and is very well suited for UI development. Once you’ve declared your
    UI structure, you need to specify how it changes over time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不仅仅是编写浏览器应该执行的命令式程序。这更像是一条指令，我们说明 UI 应该是什么样子，以及用户应该如何与之交互。这被称为声明式编程，非常适合
    UI 开发。一旦你声明了你的 UI 结构，你需要指定它如何随时间变化。
- en: Data changes over time
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据会随时间变化
- en: 'Another area that’s difficult for React newcomers to grasp is the idea that
    JSX is like a static string, representing a chunk of rendered output. This is
    where data and the passage of time come into play. React components rely on data
    being passed into them. This data represents the dynamic parts of the UI – for
    example, a UI element that’s rendered based on a Boolean value could change the
    next time the component is rendered. Here’s a diagram illustrating the idea:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个对React新手来说难以掌握的领域是JSX就像一个静态字符串，代表了一块渲染输出的片段。这就是数据和时间的流逝发挥作用的地方。React组件依赖于传入它们的数据。这些数据代表了UI的动态部分——例如，基于布尔值的渲染UI元素可能会在组件下一次渲染时发生变化。以下是一个说明这个概念的图示：
- en: '![](img/B19636_01_03.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_01_03.png)'
- en: 'Figure 1.3: React components changing over time'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：React组件随时间变化
- en: Each time the React component is rendered, it’s like taking a snapshot of the
    JSX at that exact moment in time. As your application moves forward through time,
    you have an ordered collection of rendered UI components. In addition to declaratively
    describing what a UI should be, re-rendering the same JSX content makes things
    much easier for developers. The challenge is making sure that React can handle
    the performance demands of this approach.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每次React组件渲染时，就像在那个确切时刻对JSX进行快照。随着你的应用程序随时间推移，你将有一个有序的渲染UI组件集合。除了声明性地描述UI应该是什么样子之外，重新渲染相同的JSX内容使开发者的工作变得更加容易。挑战在于确保React可以处理这种方法的性能需求。
- en: Performance matters
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能很重要
- en: Using React to build UIs means that we can declare the structure of the UI with
    JSX. This is less error-prone than the imperative approach of assembling the UI
    piece by piece. However, the declarative approach does present a challenge with
    performance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React构建UI意味着我们可以用JSX声明UI的结构。这比逐个组装UI的命令式方法更不容易出错。然而，声明式方法在性能上确实提出了挑战。
- en: For example, having a declarative UI structure is fine for the initial rendering
    because there’s nothing on the page yet. So the React renderer can look at the
    structure declared in JSX and render it in the DOM browser.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于初始渲染来说，具有声明性UI结构是可行的，因为页面上还没有任何内容。所以React渲染器可以查看JSX中声明的结构，并在DOM浏览器中渲染它。
- en: '**The Document Object Model** (**DOM**) represents HTML in the browser after
    it has been rendered. The DOM API is how JavaScript is able to change content
    on a page.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档对象模型**（**DOM**）代表浏览器中渲染后的HTML。DOM API是JavaScript如何更改页面内容的方式。'
- en: 'This concept is illustrated in the following diagram:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了这个概念：
- en: '![](img/B19636_01_04.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_01_04.png)'
- en: 'Figure 1.4: How JSX syntax translates to HTML in the browser DOM'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：JSX语法在浏览器DOM中如何转换为HTML
- en: On the initial render, React components and their JSX are no different from
    other template libraries. For instance, there is a templating library called **Handlebars**
    used for server-side rendering, which will render a template to HTML markup as
    a string that is then inserted into the browser DOM. Where React is different
    from libraries such as Handlebars is that React can accommodate when data changes
    and we need to re-render the component, whereas Handlebars will just rebuild the
    entire HTML string, the same way it did on the initial render. Since this is problematic
    for performance, we often end up implementing imperative workarounds that manually
    update tiny bits of the DOM. We end up with a tangled mess of declarative templates
    and imperative code to handle the dynamic aspects of the UI.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始渲染时，React组件及其JSX与其他模板库没有区别。例如，有一个名为**Handlebars**的模板库用于服务器端渲染，它将模板渲染为HTML标记字符串，然后将其插入到浏览器DOM中。React与Handlebars等库的不同之处在于，React可以在数据发生变化并且我们需要重新渲染组件时进行适应，而Handlebars将仅仅重新构建整个HTML字符串，就像它在初始渲染时做的那样。由于这对性能来说是个问题，我们通常最终会实现命令式的工作区，手动更新DOM的一小部分。我们最终会得到一个声明性模板和命令式代码的混乱组合，用于处理UI的动态方面。
- en: We don’t do this in React. This is what sets React apart from other view libraries.
    Components are declarative for the initial render, and they stay this way even
    as they’re re-rendered. It’s what React does under the hood that makes re-rendering
    declarative UI structures possible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在React中不这样做。这就是React与其他视图库不同的地方。组件在初始渲染时是声明性的，即使在它们重新渲染时也是如此。这就是React在底层如何使声明性UI结构的重新渲染成为可能。
- en: 'In React, however, when we create a component, we describe what it should look
    like clearly and straightforwardly. Even as we update our components, React handles
    the changes smoothly behind the scenes. In other words, components are declarative
    for the initial render, and they stay this way even as they’re re-rendered. This
    is possible because React employs the virtual DOM, which is used to keep a representation
    of the real DOM elements in memory. It does this so that each time we re-render
    a component, it can compare the new content to the content that’s already displayed
    on the page. Based on the difference, the virtual DOM can execute the imperative
    steps necessary to make the changes. So not only do we get to keep our declarative
    code when we need to update the UI but React will also make sure that it’s done
    in a performant way. Here’s what this process looks like:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 React 中，当我们创建一个组件时，我们清楚地描述了它应该看起来是什么样子。即使我们更新我们的组件，React 也会在幕后平滑地处理这些变化。换句话说，组件在初始渲染时是声明式的，即使在重新渲染时也是如此。这是可能的，因为
    React 使用虚拟 DOM，它用于在内存中保持真实 DOM 元素的表示。它这样做是为了每次我们重新渲染一个组件时，它都可以将新内容与页面上已显示的内容进行比较。根据差异，虚拟
    DOM 可以执行必要的命令步骤来做出更改。因此，当我们需要更新 UI 时，我们不仅保留了我们的声明式代码，React 还会确保它是高效完成的。以下是这个过程的样子：
- en: '![](img/B19636_01_05.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_01_05.png)'
- en: 'Figure 1.5: React transpiles JSX syntax into imperative DOM API calls'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：React 将 JSX 语法转换为命令式 DOM API 调用
- en: When you read about React, you’ll often see words such as **diffing** and **patching**.
    Diffing means comparing *old content* (the previous state of the UI) with *new
    content* (the updated state) to identify the differences, much like comparing
    two versions of a document to see what’s changed. Patching means executing the
    necessary DOM operations to render the new content, ensuring that only the specific
    changes are made, which is crucial for performance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读有关 React 的内容时，您经常会看到诸如 **diffing** 和 **patching** 这样的词汇。Diffing 意味着比较 *旧内容*（UI
    的先前状态）与 *新内容*（更新的状态）以识别差异，就像比较文档的两个版本以查看发生了什么变化一样。Patching 意味着执行必要的 DOM 操作以渲染新内容，确保只做出特定的更改，这对于性能至关重要。
- en: As with any other JavaScript library, React is constrained by the *run-to-completion*
    nature of the main thread. For example, if the React virtual DOM logic is busy
    diffing content and patching the real DOM, the browser can’t respond to user input
    such as clicks or interactions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他 JavaScript 库一样，React 受限于主线程的 *运行至完成* 特性。例如，如果 React 虚拟 DOM 逻辑正忙于比较内容并修补真实
    DOM，浏览器就无法响应用户输入，如点击或交互。
- en: As you’ll see in the next section of this chapter, changes were made to the
    internal rendering algorithms in React to mitigate these performance pitfalls.
    With performance concerns addressed, we need to make sure that we’re confident
    that React is flexible enough to adapt to the different platforms that we might
    want to deploy our apps to in the future.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节中，您将看到对 React 内部渲染算法进行了修改，以减轻这些性能陷阱。在解决了性能问题后，我们需要确保 React 足够灵活，能够适应我们未来可能希望部署应用程序的不同平台。
- en: The right level of abstraction
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确的抽象层次
- en: Another topic I want to cover at a high level before we dive into React code
    is **abstraction**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究 React 代码之前，我想在较高层次上讨论另一个主题，那就是 **抽象**。
- en: In the preceding section, you saw how JSX syntax translates to low-level operations
    that update our UI. A better way to look at how React translates our declarative
    UI components is via the fact that we don’t necessarily care what the render target
    is. The render target happens to be the browser DOM with React, but, as we will
    see, it isn’t restricted to the browser DOM.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您看到了 JSX 语法如何转换为低级操作来更新我们的 UI。React 将我们的声明式 UI 组件转换为更好的方式是，我们并不一定关心渲染目标是什么。在
    React 中，渲染目标恰好是浏览器 DOM，但正如我们将要看到的，它并不局限于浏览器 DOM。
- en: React has the potential to be used for any UI we want to create, on any conceivable
    device. We’re only just starting to see this with React Native, but the possibilities
    are endless. I would not be surprised if *React Toast*, which is totally not a
    thing, suddenly becomes relevant, where React targets toasters that can singe
    the rendered output of JSX onto bread. React’s abstraction level strikes a balance
    that allows for versatility and adaptability while maintaining a practical and
    efficient approach to UI development.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: React有潜力用于我们想要创建的任何UI，在任何可想象设备上。我们只是刚开始看到React Native，但可能性是无限的。我不会对*React Toast*（这根本不是一回事）突然变得相关而感到惊讶，其中React针对的是可以将JSX渲染输出烧焦到面包上的烤面包机。React的抽象级别在多功能性和适应性之间取得了平衡，同时保持了实际和高效的用户界面开发方法。
- en: 'The following diagram gives you an idea of how React can target more than just
    the browser:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了React如何针对不仅仅是浏览器：
- en: '![](img/B19636_01_06.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_01_06.png)'
- en: 'Figure 1.6: React abstracts the target rendering environment from the components
    that we implement'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：React将目标渲染环境从我们实现的组件中抽象出来
- en: 'From left to right, we have **React DOM**, **React Native**, **React PDF**,
    and **React Unity**. All of these React Renderer libraries accept the React component
    and return a platform-specific result. As you can see, to target something new,
    the same pattern applies:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，我们有**React DOM**、**React Native**、**React PDF**和**React Unity**。所有这些React渲染器库都接受React组件并返回特定平台的输出。正如你所见，要针对新事物，相同的模式适用：
- en: Implement components specific to the target.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现特定于目标组件。
- en: Implement a React renderer that can perform the platform-specific operations
    under the hood.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个React渲染器，使其能够在底层执行特定平台的操作。
- en: This is, obviously, an oversimplification of what’s actually implemented for
    any given React environment. But the details aren’t so important to us. What’s
    important is that we can use our React knowledge to focus on describing the structure
    of our UI on any platform.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是对任何给定React环境中实际实现内容的过度简化。但对于我们来说，细节并不那么重要。重要的是，我们可以利用我们的React知识来专注于描述我们任何平台上的UI结构。
- en: Now that you understand the role of abstractions in React, let’s see what’s
    new in React.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了React中抽象的作用，让我们看看React的新特性。
- en: What’s new in React?
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React的新特性是什么？
- en: React is a continuously evolving library in the ever-changing web development
    landscape. As you embark on your journey to learn and master React, it’s important
    to understand the evolution of the library and its updates over time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个在不断变化的Web开发领域中持续演进的库。当你开始学习并掌握React的旅程时，了解库的演变及其随时间的变化是很重要的。
- en: 'One of the advantages of React is that its core API has remained relatively
    stable in recent years. This provides a sense of continuity and allows developers
    to leverage their knowledge from previous versions. The conceptual foundation
    of React has remained intact, meaning that the skills acquired three or five years
    ago can still be applied today. Let’s take a step back and trace the history of
    React from its early versions to the recent ones. From **React 0.x** to **React
    18**, numerous pivotal changes and enhancements have been made as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: React的一个优点是，其核心API在近年来相对稳定。这提供了一种连续性，并允许开发者利用他们从先前版本中获得的知识。React的概念基础保持完整，这意味着三五年前获得的技能今天仍然适用。让我们回顾一下，从React的早期版本到最近的版本，React的历史。从**React
    0.x**到**React 18**，已经进行了许多关键的变化和增强，如下所示：
- en: '**React 0.14**: In this version, the introduction of functional components
    allowed developers to utilize functions as components, simplifying the creation
    of basic UI elements. At that time, no one knew that now we would write only functional
    components and almost completely abandon class-based components.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React 0.14**：在这个版本中，函数组件的引入允许开发者将函数用作组件，简化了基本UI元素的创建。当时，没有人知道现在我们只会编写函数组件，几乎完全放弃基于类的组件。'
- en: '**React 15**: With a new versioning scheme, the next update of React 15 brought
    a complete overhaul of the internal architecture, resulting in improved performance
    and stability.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React 15**：采用新的版本方案，React 15的下一个更新对内部架构进行了全面的重构，从而提高了性能和稳定性。'
- en: '**React 16**: This version, however, stands as one of the most notable releases
    in React’s history. It introduced hooks, a revolutionary concept that enables
    developers to use state and other React features without the need for class components.
    Hooks make code simpler and more readable, transforming the way developers write
    components. We will explore a lot of hooks in this book. Additionally, React 16
    introduced **Fiber**, a new reconciliation mechanism that significantly improved
    performance, especially when dealing with animations and complex UI structures.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React 16**：然而，这个版本是 React 历史上最引人注目的发布之一。它引入了 hooks，这是一个革命性的概念，使开发者能够在不使用类组件的情况下使用状态和其他
    React 功能。Hooks 使代码更简单、更易读，改变了开发者编写组件的方式。本书将探讨许多 hooks。此外，React 16 还引入了 **Fiber**，这是一种新的协调机制，显著提高了性能，尤其是在处理动画和复杂
    UI 结构时。'
- en: '**React 17**: This version focused on updating and maintaining compatibility
    with previous versions. It introduced a new JSX transform system.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React 17**：这个版本专注于更新和维护与先前版本的兼容性。它引入了一个新的 JSX 转换系统。'
- en: '**React 18**: This release continues the trajectory of improvement and emphasizes
    performance enhancements and additional features, such as the automatic batching
    of renders, state transitions, server components, and streaming server-side rendering.
    Most of the important updates related to performance will be explored in *Chapter
    12*, *High-Performance State Updates*. More details about server rendering will
    be covered in *Chapter 14*, *Server Rendering and Static Site Generation with
    React Frameworks*.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React 18**：这次发布继续了改进的轨迹，强调了性能提升和新增功能，例如渲染的自动批处理、状态转换、服务器组件和流式服务器端渲染。与性能相关的大部分重要更新将在**第12章**，**高性能状态更新**中进行探讨。关于服务器端渲染的更多细节将在**第14章**，**使用
    React 框架进行服务器端渲染和静态站点生成**中介绍。'
- en: '**React 19**: Introduces several major features and improvements. The **React
    Compiler** is a new compiler that enables automatic memoization and optimizes
    re-rendering, eliminating the need for manual `useMemo`, `useCallback`, and memo
    optimizations. Enhanced **Hooks** like `use`(promise) for data fetching, `useFormStatus()`
    and `useFormState()` for form handling, and `useOptimistic()` for optimistic UI
    simplify common tasks. React 19 also brings simplified APIs, such as ref becoming
    a regular prop, React.lazy being replaced, and Context.Provider becoming just
    Context. Asynchronous rendering allows fetching data asynchronously during rendering
    without blocking the UI, while error handling improvements provide better mechanisms
    to diagnose and fix issues in applications.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React 19**：引入了几个主要功能和改进。**React 编译器**是一个新的编译器，它能够实现自动记忆化并优化重新渲染，消除了手动 `useMemo`、`useCallback`
    和记忆优化。增强的 **Hooks**，如用于数据获取的 `use`(promise)、用于表单处理的 `useFormStatus()` 和 `useFormState()`、以及用于乐观
    UI 的 `useOptimistic()` 简化了常见任务。React 19 还带来了简化的 API，例如 ref 成为常规属性、React.lazy 被取代，以及
    Context.Provider 变为 Context。异步渲染允许在渲染过程中异步获取数据，而不会阻塞 UI，而错误处理改进提供了更好的机制来诊断和修复应用程序中的问题。'
- en: React’s stability and compatibility make it a reliable library for long-term
    use, while the continuous updates ensure that it remains at the forefront of web
    and mobile development. Throughout this book, all examples will utilize the latest
    React API, ensuring that they remain functional and relevant in future versions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: React 的稳定性和兼容性使其成为长期使用的可靠库，而持续的更新确保它始终处于网络和移动开发的前沿。在这本书中，所有示例都将使用最新的 React API，确保它们在未来版本中仍然功能性和相关性。
- en: Now that we have explored the evolution and updates in React, we can delve deeper
    into React and examine how to get set up with the new React project.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了 React 的演变和更新，我们可以更深入地了解 React，并检查如何设置新的 React 项目。
- en: Setting up a new React project
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新的 React 项目
- en: 'There are several ways to create a React project when you are getting started.
    In this section, we will explore three common approaches:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始创建 React 项目时，有几种方法可以创建 React 项目。在本节中，我们将探讨三种常见的方法：
- en: Using web bundlers
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网络打包器
- en: Using frameworks
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用框架
- en: Using online code editors
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在线代码编辑器
- en: To start developing and previewing your React applications, you will first need
    to have **Node.js** installed on your computer. Node.js is a runtime environment
    for executing JavaScript code.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要开始开发和预览您的 React 应用程序，您首先需要在您的计算机上安装 **Node.js**。Node.js 是执行 JavaScript 代码的运行环境。
- en: Let’s dive into each approach in the following subsections.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来在以下子节中深入了解每种方法。
- en: Using web bundlers
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网络打包器
- en: Using a web bundler is an efficient way to create React projects, especially
    if you are building a **single-page application** (**SPA**). For all of the examples
    in this book, we will use **Vite** as our web bundler. Vite is known for its remarkable
    speed and ease of setup and use.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络打包器是创建 React 项目的有效方法，尤其是如果你正在构建一个**单页应用程序**（**SPA**）。在这本书的所有示例中，我们将使用**Vite**作为我们的网络打包器。Vite
    以其卓越的速度和易于设置及使用而闻名。
- en: 'To set up your project using Vite, you will need to take the following steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Vite 设置你的项目，你需要采取以下步骤：
- en: Ensure that you have Node.js installed on your computer by visiting the official
    *Node.js* website ([https://nodejs.org/](https://nodejs.org/)) and downloading
    the appropriate version for your operating system.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请确保你的计算机上已安装 Node.js，你可以通过访问官方 *Node.js* 网站 ([https://nodejs.org/](https://nodejs.org/))
    并下载适合你操作系统的相应版本来做到这一点。
- en: 'Open your terminal or command prompt and navigate to the directory where you
    want to create your project:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的终端或命令提示符，导航到你想要创建项目的目录：
- en: '[PRE2]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the following command to create a new React project with Vite:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以使用 Vite 创建一个新的 React 项目：
- en: '[PRE3]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command creates a new directory called `my-react-app` and sets up a React
    project using the Vite template.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令创建一个名为 `my-react-app` 的新目录，并使用 Vite 模板设置一个 React 项目。
- en: 'Once the project is created, your terminal should look like this:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，你的终端应该如下所示：
- en: '[PRE4]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Navigate into the project directory and install dependencies. The result in
    the terminal should look like:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目目录并安装依赖项。终端的结果应该如下所示：
- en: '[PRE5]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, start the development server by running the following command: `npm
    run dev`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过运行以下命令启动开发服务器：`npm run dev`
- en: This command launches the development server, and you can view your React application
    by opening your browser and visiting `http://localhost:3000`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令启动开发服务器，你可以通过打开浏览器并访问 `http://localhost:3000` 来查看你的 React 应用程序。
- en: By now, you will have successfully set up your React project using Vite as the
    web bundler. For more information about Vite and its possible configurations,
    visit the official website at [https://vitejs.dev/](https://vitejs.dev/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经成功使用 Vite 作为网络打包器设置了你的 React 项目。有关 Vite 及其可能的配置的更多信息，请访问官方网站 [https://vitejs.dev/](https://vitejs.dev/)。
- en: Using frameworks
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用框架
- en: For real-world and commercial projects, it is recommended to use frameworks
    built on top of React. These frameworks provide additional features out of the
    box, such as routing and asset management (images, SVG files, fonts, etc.). They
    also guide you in organizing your project structure effectively, as frameworks
    often enforce specific file organization rules. Some popular React frameworks
    include **Next.js**, **Gatsby**, and **Remix**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现实世界和商业项目，建议使用构建在 React 之上的框架。这些框架提供了额外的功能，例如路由和资产管理（图像、SVG 文件、字体等）。它们还指导你有效地组织项目结构，因为框架通常强制执行特定的文件组织规则。一些流行的
    React 框架包括**Next.js**、**Gatsby**和**Remix**。
- en: In *Chapter 13*, *Server-Side Rendering*, we will explore setting up Next.js
    and some differences between that and using a plain web bundler.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第 13 章**，**服务器端渲染**中，我们将探讨设置 Next.js 以及它与使用普通网络打包器之间的差异。
- en: Online code editors
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在线代码编辑器
- en: Online code editors combine the advantages of web bundlers and frameworks but
    allow you to set up your React development environment in the cloud or right inside
    of the browser. This eliminates the need to install anything on your machine and
    lets you write and explore React code directly in your browser.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在线代码编辑器结合了网络打包器和框架的优点，但允许你在云端或直接在浏览器中设置你的 React 开发环境。这消除了在你的机器上安装任何东西的需要，并让你可以直接在浏览器中编写和探索
    React 代码。
- en: While there are various online code editors available, some of the most popular
    options include **CodeSandbox**, **StackBlitz**, and **Replit**. These platforms
    provide a user-friendly interface and allow you to create, share, and collaborate
    on React projects without any local setup.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有各种在线代码编辑器可供选择，其中一些最受欢迎的选项包括**CodeSandbox**、**StackBlitz**和**Replit**。这些平台提供了一个用户友好的界面，并允许你创建、分享和协作
    React 项目，而无需任何本地设置。
- en: 'To get started with an online code editor, you don’t even need an account.
    Simply follow this link on your browser: [https://react.new](https://react.new).
    In a few seconds, you will see that CodeSandbox is ready to work with a template
    project, and a live preview of the editor is available directly in the browser
    tab. If you want to save your changes, then you need to create an account.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用在线代码编辑器，您甚至不需要账户。只需在浏览器上遵循此链接：[https://react.new](https://react.new)。几秒钟后，您将看到CodeSandbox已经准备好使用模板项目进行工作，并且编辑器的实时预览可以直接在浏览器标签中查看。如果您想保存更改，则需要创建账户。
- en: Using online code editors is a convenient way to learn and experiment with React,
    especially if you prefer a browser-based development environment.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在线代码编辑器是学习和实验React的便捷方式，尤其是如果您更喜欢基于浏览器的开发环境。
- en: In this section, we explored different methods to set up your React project.
    Whether you choose web bundlers, frameworks, or online code editors, each approach
    offers its unique advantages. Select the method that you prefer and suits your
    project requirements. Now, we are ready to dive into the world of React development!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了不同的方法来设置您的React项目。无论您选择Web打包器、框架还是在线代码编辑器，每种方法都提供了其独特的优势。选择您喜欢且适合您项目需求的方法。现在，我们准备好进入React开发的领域了！
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were introduced to React comprehensively so that you have
    an idea of what it is and the necessary aspects of it, setting the tone for the
    rest of the book. React is a library with a small API used to build UIs. Then,
    you were introduced to some of the key concepts of React. We discussed the fact
    that React is simple because it doesn’t have a lot of moving parts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们全面介绍了React，以便您对其有一个大致的了解以及其必要的方面，为本书的其余部分定下基调。React是一个具有小型API的库，用于构建UI。然后，我们向您介绍了React的一些关键概念。我们讨论了React之所以简单，是因为它没有很多可移动部件。
- en: Afterward, we explored the declarative nature of React components and JSX. Following
    that, you learned that React enables effective performance by writing declarative
    code that can be re-rendered repeatedly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们探讨了React组件和JSX的声明性本质。在此之后，您了解到React通过编写可重复渲染的声明性代码来实现有效的性能。
- en: You also gained insight into the idea of render targets and how React can easily
    become the UI tool of choice for various platforms. We then provided you with
    a brief overview of React’s history and introduced the latest developments. Finally,
    we delved into how to set up a new React project and initiate the learning process.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您还深入了解了渲染目标的概念以及React如何轻松成为各种平台的首选UI工具。然后，我们为您提供了React历史的简要概述并介绍了最新进展。最后，我们深入探讨了如何设置新的React项目并启动学习过程。
- en: That’s sufficient introductory and conceptual content for now. As we progress
    through the book’s journey, we’ll revisit these concepts. Next, let’s take a step
    back and nail down the basics, starting with rendering with JSX in the next chapter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这些就足够作为入门和概念性内容了。随着我们继续阅读本书，我们将重新审视这些概念。接下来，让我们退后一步，牢固掌握基础知识，从下一章使用JSX进行渲染开始。
- en: Join us on Discord!
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord吧！
- en: Read this book alongside other users and the authors themselves. Ask questions,
    provide solutions to other readers, chat with the authors, and more. Scan the
    QR code or visit the link to join the community.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户和作者一起阅读本书。提出问题，为其他读者提供解决方案，与作者聊天等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/ReactAndReactNative5e](https://packt.link/ReactAndReactNative5e)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/ReactAndReactNative5e](https://packt.link/ReactAndReactNative5e)'
- en: '![](img/QR_Code196803360665486921.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code196803360665486921.png)'
