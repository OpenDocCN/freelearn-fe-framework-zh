<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer037">
<h1 class="ch pter-number" id="_idParaDest-126"><a id="_idTextAnchor297"/>9</h1>
<h1 id="_idParaDest-127"><a id="_idTextAnchor298"/>What Changes in React Query v5?</h1>
<p>At the time of writing, version 5.0.0-alpha.1 of @tanstack/react-query has just been released. While it might take a couple of weeks for the stable version to be released, when this book is published, it might already be the version that installs by default every time you add React Query to <span class="No-Break">your project.</span></p>
<p>To make sure you understand the changes that the content of this book may undergo after v5 is released, this bonus chapter <span class="No-Break">was added.</span></p>
<p>This chapter might also serve as a helper to guide you when migrating from v4 <span class="No-Break">to v5.</span></p>
<p>Once again, as a disclaimer, <em class="it lic">the snippets of this chapter were tested on version 5.0.0-alpha.1 of @tanstack/react-query. Some of these things might still change, or some new ones might show up</em>. Either way, the snippets will be kept updated online in the next couple of months until a stable version is released. You can find them on the GitHub repository mentioned in the <em class="it lic">Technical </em><span class="No-Break"><em class="it lic">requirements</em></span><span class="No-Break"> section.</span></p>
<p>By the end of this chapter, you will be aware of all the changes in React Query v5 that will have an impact on some of the things in <span class="No-Break">this book.</span></p>
<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
<ul>
<li>What are the <span class="No-Break">support changes?</span></li>
<li>Using only the <span class="No-Break">object format</span></li>
<li>Removing <span class="No-Break">the logger</span></li>
<li>Renaming <strong class="source-inline">loading</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">pending</strong></span></li>
<li>Renaming <strong class="source-inline">cacheTime</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">gcTime</strong></span></li>
<li>Renaming <strong class="source-inline">Hydrate</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">HydrationBoundary</strong></span></li>
<li>Removing <strong class="source-inline">keepPreviousData</strong> and <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">placeholderData</strong></span></li>
<li>Introducing a new way to do <span class="No-Break">optimistic updates</span></li>
<li>Introducing <strong class="source-inline">maxPages</strong> to <span class="No-Break">infinite queries</span></li>
</ul>
<h1 id="_idParaDest-128"><a id="_idTextAnchor299"/>Technical requirements</h1>
<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_9"><span class="No-Break">https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_9</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor300"/>What are the support changes?</h1>
<p>The <a id="_idIndexMarker474"/>first thing to be aware of here is that the browser support has changed. From v5, your browser needs to be compatible with the <span class="No-Break">following configurations:</span></p>
<ul>
<li>The Google Chrome version needs to be at least <span class="No-Break">version 84</span></li>
<li>The Mozilla Firefox version needs to be at least <span class="No-Break">version 90</span></li>
<li>The Microsoft Edge version needs to be at least <span class="No-Break">version 84</span></li>
<li>The Safari version needs to be at least <span class="No-Break">version 15</span></li>
<li>The Opera version needs to be at least <span class="No-Break">version 70</span></li>
</ul>
<p>Now that we know the support changes, let's see what features changed from v4 to v5, starting with the object format for custom hooks <span class="No-Break">and functions.</span><a id="_idTextAnchor301"/></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor302"/>Using only the object format</h1>
<p>In <a id="_idIndexMarker475"/>v4 of React Query, most custom hooks and functions were overloaded to support previous patterns. This means that in your code, both of the <strong class="source-inline">useQuery</strong> hooks in the following snippet would be the <span class="No-Break">same thing:</span></p>
<pre class="source-code">
const { data } = useQuery({
    queryKey: ["api"]
    queryFn: fetchData,
});
const { data } = useQuery(["api"], fetchData);</pre>
<p>As you can see from the preceding snippet, we create a query with <strong class="source-inline">queryKey</strong> <strong class="source-inline">["api"]</strong> and <strong class="source-inline">queryFn</strong> <strong class="source-inline">fetchData</strong> twice. This is because the second and first examples are just instances of the same hook that has <span class="No-Break">been overloaded.</span></p>
<p>With the introduction of v5, the second example shown in the preceding snippet is no longer supported; therefore, you can only use your hooks by passing them a single object with the needed options. Here is the syntax that you need to follow from <span class="No-Break">now on:</span></p>
<pre class="source-code">
useQuery({ queryKey, queryFn, ...options })
useMutation({ mutationFn, ...options })
useInfiniteQuery({ queryKey, queryFn, ...options })</pre>
<p>As you can <a id="_idIndexMarker476"/>see from the preceding snippet, we have three React Query hooks, and each one of them receives a couple <span class="No-Break">of things:</span></p>
<ul>
<li>The <strong class="source-inline">useQuery</strong> and <strong class="source-inline">useInfiniteQuery</strong> hooks need to receive <strong class="source-inline">queryKey</strong> and <strong class="source-inline">queryFn</strong> as required parameters. These hooks allow you to pass them some of the options you should already know from the <span class="No-Break">previous chapters.</span></li>
<li>The <strong class="source-inline">useMutation</strong> hook needs to receive <strong class="source-inline">mutationFn</strong> as a required parameter. It also allows you to pass it some of the options we learned about in <a href="B18501_06.xhtml#_idTextAnchor159"><span class="No-Break"><em class="it lic">Chapter 6</em></span></a> when we saw what options our <strong class="source-inline">useMutation</strong> <span class="No-Break">hook receives.</span></li>
</ul>
<p>Luckily, throughout the book, we followed the object approach right from the beginning, so you should have followed the right approach from the start and won’t suffer much from <span class="No-Break">the change.</span></p>
<p>Another thing to be aware of is that this change applies to the <strong class="source-inline">queryClient</strong> functions. Functions such as <strong class="source-inline">invalidateQueries</strong>, <strong class="source-inline">refetchQueries</strong>, and <strong class="source-inline">prefetchQuery</strong> must <a id="_idIndexMarker477"/>also receive the <span class="No-Break">expected object.</span></p>
<p>Now that you know about the single object format, we can look at one thing that was removed in v5 – <span class="No-Break"><strong class="source-inline">logg<a id="_idTextAnchor303"/>er</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor304"/>Removing the logger</h1>
<p>Previously, React Query<a id="_idIndexMarker478"/> logged failed queries to the console in the production environment. This quickly became an issue because our application users could see implementation detail errors that they shouldn’t be aware of. To deal with this issue, the ability to create a custom logger was added, where you could override what React Query used <span class="No-Break">for logging.</span></p>
<p>Recently, React Query removed all logging in production and improved their development logs. Given this scenario, in v5, <strong class="source-inline">logger</strong> was no longer needed and <span class="No-Break">was removed.</span></p>
<p>From now on, <strong class="source-inline">console</strong> will be used as the <span class="No-Break">default logger.</span></p>
<p>Now that you know this change, let's see the first renaming of v5 – <strong class="source-inline">loading</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">pend<a id="_idTextAnchor305"/><a id="_idTextAnchor306"/>ing</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor307"/>Renaming loading to pending</h1>
<p>The <strong class="source-inline">loading</strong> status has caused some confusion. This is because most people associate <a id="_idIndexMarker479"/>it with data loading; secondly, if your query is disabled due to having the <strong class="source-inline">enabled</strong> option as <strong class="source-inline">false</strong>, it will show up as <strong class="source-inline">loading</strong>. To avoid more confusion and have a clearer name, the <strong class="source-inline">loading</strong> status has <span class="No-Break">been renamed.</span></p>
<p>Here are the changes that have <span class="No-Break">been applied:</span></p>
<ul>
<li>The <strong class="source-inline">loading</strong> status has been <span class="No-Break">renamed </span><span class="No-Break"><strong class="source-inline">pending</strong></span></li>
<li>The derived <strong class="source-inline">isLoading</strong> status has been <span class="No-Break">renamed </span><span class="No-Break"><strong class="source-inline">isPending</strong></span></li>
<li>A new derived <strong class="source-inline">isLoading</strong> flag has been added, which basically translates as the <strong class="source-inline">isPending &amp;&amp; </strong><span class="No-Break"><strong class="source-inline">isFetching</strong></span><span class="No-Break"> expression</span></li>
<li>Considering that there was already a flag doing the same thing called <strong class="source-inline">isInitialLoading</strong>, the <strong class="source-inline">isInitialLoading</strong> flag has <span class="No-Break">been deprecated</span></li>
</ul>
<p>Let us now review <strong class="source-inline">ComponentA</strong>, which we saw in <a href="B18501_04.xhtml#_idTextAnchor091"><span class="No-Break"><em class="it lic">Chapter 4</em></span></a>, and apply <span class="No-Break">these changes:</span></p>
<pre class="source-code">
const ComponentA = () =&gt; {
  const { data, error, <strong class="bold">isPending</strong>, isError, isFetching } =
    useQuery({
    queryKey: [{ queryIdentifier: "api", apiName: apiA }],
    queryFn: fetchData,
  });
  if (<strong class="bold">isPending</strong>) return &lt;div&gt; Loading data... &lt;/div&gt;;
  ...
};</pre>
<p>As you can see from the preceding snippet, all we have to do is rename <span class="No-Break"><strong class="source-inline">isLoading</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">isPending</strong></span><span class="No-Break">.</span></p>
<p>As for the behavior, it is also the same. What we have to be aware of here is that after the first query mounts when we don’t have data, our <strong class="source-inline">status</strong> query will be <strong class="source-inline">pending</strong> instead <a id="_idIndexMarker480"/>of <strong class="source-inline">loading</strong>, as it <span class="No-Break">was previously.</span></p>
<p>With this in mind, we can move to the next renaming of v5 – <strong class="source-inline">cacheTime</strong> is <span class="No-Break">now </span><span class="No-Break"><strong class="source-inline">g<a id="_idTextAnchor308"/>cTime</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor309"/>Renaming cacheTime to gcTime</h1>
<p>This<a id="_idIndexMarker481"/> was one of the changes I’m most personally happy about because it is probably the most misunderstood option in React Query. Most often, it is assumed that <strong class="source-inline">cacheTime</strong> means the length of time that data will be cached instead of what it really means, which is the time that inactive data in the cache will remain <span class="No-Break">in memory.</span></p>
<p>To stop this misconception, the <strong class="source-inline">cacheTime</strong> option has been renamed <strong class="source-inline">gcTime</strong>. This is because <strong class="source-inline">gc</strong> is often a shortened way to refer to the garbage collector. Therefore, from now on, we explicitly declare the time until our data <span class="No-Break">is garbage-collected.</span></p>
<p>To use it, all you need to do is add the <strong class="source-inline">gcTime</strong> option to your <strong class="source-inline">useQuery</strong>/<strong class="source-inline">useMutation</strong> hook, <span class="No-Break">like this:</span></p>
<pre class="source-code">
useQuery({
<strong class="bold">    gcTime: 60000</strong>
});</pre>
<p>In the<a id="_idIndexMarker482"/> snippet, we define that after our query is inactive for one minute, the data will <span class="No-Break">be garbage-collected.</span></p>
<p>To wrap up the renaming spree, let us see how our <strong class="source-inline">Hydrate</strong> <span class="No-Break">component <a id="_idTextAnchor310"/>changed.</span></p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor311"/>Renaming Hydrate to HydrationBoundary</h1>
<p>When using the <a id="_idIndexMarker483"/>hydrate pattern in SSR, the <strong class="source-inline">Hydrate</strong> component was not fully descriptive about what it meant. To make it more concise and match other boundaries defined in TanStack Query, it was renamed <strong class="source-inline">HydrationBoundary</strong>. Due to this, you now have to rename it in your Next.js or <span class="No-Break">Remix code.</span></p>
<p>Let us now see how the <span class="No-Break">snippets change.</span></p>
<h2 id="_idParaDest-135">Next.js hydrate pattern<a id="_idTextAnchor312"/><a id="_idTextAnchor313"/> renaming</h2>
<p>This is what our <a id="_idIndexMarker484"/>Next.js <strong class="source-inline">_app</strong> component will look <span class="No-Break">like now:</span></p>
<pre class="source-code">
import { useState } from "react";
import {
<strong class="bold">  HydrationBoundary,</strong>
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
export default function App({ Component, pageProps }) {
  const [queryClient] = useState(() =&gt; new QueryClient());
  return (
  &lt;QueryClientProvider client={queryClient}&gt;
<strong class="bold">    &lt;HydrationBoundary state={pageProps.</strong>
<strong class="bold">          dehydratedState}&gt;</strong>
      &lt;Component {...pageProps} /&gt;
<strong class="bold">    &lt;/HydrationBoundary&gt;</strong>
  &lt;/QueryClientProvider&gt;
  );
}</pre>
<p>As you can see from the <a id="_idIndexMarker485"/>preceding snippet, all we have to do is rename <strong class="source-inline">Hydrate</strong> to <strong class="source-inline">HydrationBoundary</strong>. Everything else remains <span class="No-Break">the same.</span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor314"/>Remix hydrate pattern changes</h2>
<p>This is what our<a id="_idIndexMarker486"/> Remix root component will look <span class="No-Break">like now:</span></p>
<pre class="source-code">
import {
  ...
  Outlet,
} from "@remix-run/react";
import { useState } from "react";
import {
  <strong class="bold">HydrationBoundary</strong>,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
import { useDehydratedState } from "use-dehydrated-state";
export default function App() {
  const [queryClient] = useState(() =&gt; new QueryClient());
  const dehydratedState = useDehydratedState();
  return (
  ...
     &lt;QueryClientProvider client={queryClient}&gt;
<strong class="bold">       &lt;HydrationBoundary state={dehydratedState}&gt;</strong>
         &lt;Outlet /&gt;
<strong class="bold">       &lt;/HydrationBoundary&gt;</strong>
     &lt;/QueryClientProvider&gt;
   ...
  );
}</pre>
<p>As you can see<a id="_idIndexMarker487"/> from the preceding snippet, and just as we saw in the Next.js example, all we have to do is rename <strong class="source-inline">Hydrate</strong> to <strong class="source-inline">HydrationBoundary</strong>. Everything else remains <span class="No-Break">the same.</span></p>
<p>Now that you know this change, let us look at something that impacted how we do <span class="No-Break">pagin<a id="_idTextAnchor315"/>ated queries.</span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor316"/>Removing keepPreviousData and using placeholderData</h1>
<p>The <strong class="source-inline">keepPreviousData</strong> option <a id="_idIndexMarker488"/>and the <strong class="source-inline">isPreviousData</strong> flags have been removed. This is because they did almost the same task as the <strong class="source-inline">placeholderData</strong> option and the <span class="No-Break"><strong class="source-inline">isPlaceholderData</strong></span><span class="No-Break"> flag.</span></p>
<p>So that <strong class="source-inline">placeholderData</strong> can <a id="_idIndexMarker489"/>fully do exactly the same thing as <strong class="source-inline">keepPreviousData</strong>, the previous query data was added as an <a id="_idIndexMarker490"/>argument to the <strong class="source-inline">placeholderData</strong> function. This now means that by leveraging the <strong class="source-inline">keepPreviousData</strong> custom function from React Query, <strong class="source-inline">useQuery</strong> will allow <strong class="source-inline">placeholderData</strong> to work the same way as <strong class="source-inline">keepPreviousData</strong> <span class="No-Break">did previously.</span></p>
<p>Let us see how our <strong class="source-inline">PaginatedQuery</strong> code changes <span class="No-Break">in v5:</span></p>
<pre class="source-code">
import { useQuery, <strong class="bold">keepPreviousData</strong> } from "@tanstack/react-query";
...
const PaginatedQuery = () =&gt; {
  ...
  const { isPending, isError, error, data, isFetching,
    isPlaceholderData } =
    useQuery({
      queryKey: userKeys.paginated(page),
      queryFn: fetchData,
<strong class="bold">      placeholderData: keepPreviousData,</strong>
    });
  if (isPending) {
    return &lt;h2&gt;Loading initial data...&lt;/h2&gt;;
  }
  ...
  return (
    &lt;&gt;
     ...
        &lt;button
          disabled={<strong class="bold">isPlaceholderData</strong>}
          onClick={() =&gt; setPage((old) =&gt; old + 1)}
        &gt;
          Next Page
        &lt;/button&gt;
...
    &lt;/&gt;
  );
};
export default PaginatedQuery;</pre>
<p>In the <a id="_idIndexMarker491"/>preceding snippet, we <a id="_idIndexMarker492"/>changed our <strong class="source-inline">PaginatedQuery</strong> component to adapt to the changes necessary due to the removal of the <strong class="source-inline">keepPreviousData</strong> option. This is what <span class="No-Break">we do:</span></p>
<ol>
<li>We import our <strong class="source-inline">keepPreviousData</strong> helper from <span class="No-Break">React Query.</span></li>
<li>Since we need to refactor the component, we rename <strong class="source-inline">isLoading</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">isPending</strong></span><span class="No-Break">.</span></li>
<li>We rename <strong class="source-inline">isPreviousData</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">isPlaceholderData</strong></span><span class="No-Break">.</span></li>
<li>We rename the <strong class="source-inline">keepPreviousData</strong> option to <strong class="source-inline">placeholderData</strong> and pass it the <span class="No-Break"><strong class="source-inline">keepPreviousData</strong></span><span class="No-Break"> helper.</span></li>
</ol>
<p>Now, v5 did not only remove and rename things. It also added some new things, including a new way to perform <span class="No-Break">o<a id="_idTextAnchor317"/>ptimistic updates.</span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor318"/>Introducing a new way to perform optimistic updates</h1>
<p>When<a id="_idIndexMarker493"/> performing optimistic updates, you must always be careful about the changes you make to your cache. One typo or mistake might accidentally impact other queries outside of the one you want to <span class="No-Break">change initially.</span></p>
<p>Fortunately, with v5, TanStack Query has introduced a way to perform optimistic updates where you can fully rely on your UI and stop changing <span class="No-Break">your cache.</span></p>
<p>Let us <span class="No-Break">see how:</span></p>
<pre class="source-code">
export const NewOptimisticMutation = () =&gt; {
  const [name, setName] = useState("");
  const [age, setAge] = useState(0);
  const queryClient = useQueryClient();
  const { data } = useQuery({
    queryKey: userKeys.all(),
    queryFn: fetchAllData,
    retry: 0,
  });
 <strong class="bold"> const mutation = useMutation({</strong>
<strong class="bold">    mutationFn: createUser,</strong>
<strong class="bold">    onSettled: () =&gt;</strong>
<strong class="bold">      queryClient.invalidateQueries({ queryKey: userKeys.</strong>
<strong class="bold">        all() }),</strong>
<strong class="bold">  });</strong>
  return (
    &lt;div&gt;
      {data?.map((user, index) =&gt; (
        &lt;div key={user.userID + index}&gt;
          Name: {user.name} Age: {user.age}
        &lt;/div&gt;
      ))}
      <strong class="bold">{mutation.isPending &amp;&amp; (</strong>
<strong class="bold">        &lt;div key={String(mutation.submittedAt)}&gt;</strong>
<strong class="bold">          Name: {mutation.variables.name} Age:</strong>
<strong class="bold">            {mutation.variables.age}</strong>
<strong class="bold">        &lt;/div&gt;</strong>
<strong class="bold">      )}</strong>
      &lt;form&gt;
        &lt;input
          name="name"
          type={"text"}
          onChange={(e) =&gt; setName(e.target.value)}
          value={name}
        /&gt;
        &lt;input
          name="number"
          type={"number"}
          onChange={(e) =&gt; setAge(Number(e.target.value))}
          value={age}
        /&gt;
        &lt;button
          disabled={mutation.isPaused ||
            mutation.isPending}
          type="button"
          onClick={(e) =&gt; {
            e.preventDefault();
            mutation.mutate({ name, age });
          }}
        &gt;
          Add
        &lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};</pre>
<p>In the<a id="_idIndexMarker494"/> preceding snippet, we can see the new way React Query allows us to perform optimistic updates. This is what <span class="No-Break">we do:</span></p>
<ol>
<li>Create state variables and respective setters for the name and <span class="No-Break">age inputs.</span></li>
<li>Get access<a id="_idTextAnchor319"/> to <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">queryClient</strong></span><span class="No-Break">.</span></li>
<li>Create our query, using the query factory <strong class="source-inline">all</strong> function to give us the query key and <strong class="source-inline">fetchAllData</strong> as the <span class="No-Break"><strong class="source-inline">query</strong></span><span class="No-Break"> function.</span></li>
<li>Create our mutation, using <strong class="source-inline">createUser</strong> as the mutation function. Inside this mutation, we leverage the <strong class="source-inline">onSettled</strong> callback to i<a id="_idTextAnchor320"/>nvalidate <span class="No-Break">our query.</span></li>
<li>In our component return, we create <strong class="source-inline">div</strong> with <span class="No-Break">the following:</span><ol><li>We use <strong class="source-inline">data</strong> from our query to display our <span class="No-Break">users’ data.</span></li><li>We use our mutation <strong class="source-inline">isPending</strong> flag to let us know whether we have any mutation currently being performed. If this flag is <strong class="source-inline">true</strong>, we can access and render our <strong class="source-inline">mutation</strong> variables on <span class="No-Break">the DOM.</span></li><li>We create our controlled form with our name and <span class="No-Break">age inputs.</span></li><li>We also create a button that, upon <strong class="source-inline">onClick</strong>, will trigger our mutation with our <a id="_idIndexMarker495"/>name and <span class="No-Break">age values.</span></li></ol></li>
</ol>
<p>As you can see now, we can perform mutations without changing our query cache data. This is super powerful and can save you a lot of unintentional headaches caused by messing up <span class="No-Break">your cache.</span></p>
<p>By checking the code of the preceding snippet, one thing you might wonder is whether the mutation lives on the same component as the query. Does this mean that if you have a mutation that lives outside of the same place of your query, you won’t be able to perform optimistic updates this way? It <span class="No-Break">does not.</span></p>
<p>If you have a mutation performing somewhere else and want to perform an optimistic update, you can leverage the <strong class="source-inline">useMutationState</strong> <span class="No-Break">custom hook.</span></p>
<p>Here<a id="_idTextAnchor321"/> <span class="No-Break">is how:</span></p>
<pre class="source-code">
export const NewOptimisticMutationV2 = () =&gt; {
  const { data } = useQuery({
    queryKey: userKeys.all(),
    queryFn: fetchAllData,
    retry: 0,
  });
<a id="_idTextAnchor322"/>
  <strong class="bold">const [mutation] = useMutationState({</strong>
<strong class="bold">    fi<a id="_idTextAnchor323"/>lters: { mutationKey: userKeys.userMutation(),</strong>
<strong class="bold">      status: "pending" },</strong>
<strong class="bold">    select: (mutation) =&gt; ({</strong>
<strong class="bold">      ...mutation.state.variables,</strong>
<strong class="bold">      submittedAt: mutation.state.submittedAt,</strong>
<strong class="bold">    }),</strong>
<strong class="bold">  });</strong>
  return (
    &lt;div&gt;
      {data?.map((user, index) =&gt; (
        &lt;div key={user.userID + index}&gt;
          Name: {user.name} Age: {user.age}
        &lt;/div&gt;
      ))}
      <strong class="bold">{mutation &amp;&amp; (</strong>
<strong class="bold">        &lt;div key={String(mutation.submittedAt)}&gt;</strong>
<strong class="bold">          Name: {mutation.name} Age: {mutation.age}</strong>
<strong class="bold">        &lt;/div&gt;</strong>
<strong class="bold">      )}</strong>
      &lt;MutationForm /&gt;
    &lt;/div&gt;
  );
};</pre>
<p>In the preceding <a id="_idIndexMarker496"/>snippet, we have the <strong class="source-inline">NewOptimisticMutationV2</strong> component. In this component, we perform an optimistic update outside the component where your mutation lives. In this component, we render our query data and have the component where our mutation happens, called <strong class="source-inline">MutationForm</strong>, rendered as a <span class="No-Break">child component.</span></p>
<p>Here is what we do in the <span class="No-Break"><strong class="source-inline">NewOptimisticMutationV2</strong></span><span class="No-Break"> component:</span></p>
<ol>
<li>Create our query, using our query factory <strong class="source-inline">all</strong> function to give us the query key and <strong class="source-inline">fetchAllData</strong> as the <span class="No-Break"><strong class="source-inline">query</strong></span><span class="No-Break"> function.</span></li>
<li>Get access to our mutation by using the <span class="No-Break"><strong class="source-inline">useMutationState</strong></span><span class="No-Break"> hook.</span></li>
<li>With this hook, we access a mutation currently with the pending status and the <strong class="source-inline">mutationKey</strong> <strong class="source-inline">userKeys.userMutation()</strong> that comes from our <span class="No-Break">query factory.</span></li>
<li>Then, leverage the <strong class="source-inline">select</strong> option from the <strong class="source-inline">useMutationState</strong> hook to get the <strong class="source-inline">mutation</strong> variables and the <span class="No-Break"><strong class="source-inline">submittedAt</strong></span><span class="No-Break"> property.</span></li>
<li>In our component return, we create a <strong class="source-inline">div</strong> with <span class="No-Break">the following:</span><ol><li>We use <strong class="source-inline">data</strong> from our query to display our <span class="No-Break">users’ data.</span></li><li>If we have any mutation currently being performed, we can access and render our <strong class="source-inline">mutation</strong> variables on <span class="No-Break">the DOM.</span></li></ol></li>
</ol>
<p>I mentioned in the previous description that the mutation needs to have <strong class="source-inline">mutationKey</strong> to be able to be found. This is how to add it to <span class="No-Break">your mutation:</span></p>
<pre class="source-code">
const mutation = useMutation({
    mutationFn: create<a id="_idTextAnchor324"/>User,
<strong class="bold">    mutationKey: userKeys.userMutation(),</strong>
  });</pre>
<p>As you can see <a id="_idIndexMarker497"/>from the preceding snippet, we added the <strong class="source-inline">userKeys.userMutation()</strong> key from our query factory and added it to our <strong class="source-inline">useMutation</strong> hook’s <span class="No-Break"><strong class="source-inline">mutationKey</strong></span><span class="No-Break"> property.</span></p>
<p>Now that you know about the new way to perform optimistic updates, let us see what changed i<a id="_idTextAnchor325"/>n our <span class="No-Break">infinite queries.</span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor326"/>Introducing maxPages to infinite queries</h1>
<p>Infinite queries <a id="_idIndexMarker498"/>is an<a id="_idIndexMarker499"/> amazing pattern that helps you build infinite lists. However, there is one issue with it before v5 – all the fetched pages are cached in memory; therefore, the more pages you see, the more memory <span class="No-Break">you consume.</span></p>
<p>To prevent this from happening and improve your user experience, the <strong class="source-inline">maxPages</strong> option was added to the <strong class="source-inline">useInfiniteQuery</strong> hook. This option limits the number of pages that will be stored in the <span class="No-Break">query cache.</span></p>
<p>This is what our infinite query example, seen in <a href="B18501_05.xhtml#_idTextAnchor140"><span class="No-Break"><em class="it lic">Chapter 5</em></span></a>, would look <span class="No-Break">like now:</span></p>
<pre class="source-code">
const {
    isPending,
    isError,
    error,
    data,
    fetchNextPage,
    isFetchingNextPage,
    hasNextPage,
  } = useInfiniteQuery({
    queryKey: userKeys.api(),
    queryFn: getInfiniteData,
    <strong class="bold">defaultPageParam: 0,</strong>
<strong class="bold">    maxPages: 5,</strong>
<strong class="bold">    getNextPageParam: (lastPage, pages) =&gt; {</strong>
<strong class="bold">      return lastPage?.i<a id="_idTextAnchor327"/>nfo?.nextPage;</strong>
<strong class="bold">    },</strong>
<strong class="bold">    getPreviousPageParam: (firstPage, pages) =&gt; {</strong>
<strong class="bold">      return </strong><strong class="bold">firstPage?.info?.prevPage</strong>
<strong class="bold">    }</strong>
  });
  if (isPending) {
    return &lt;h2&gt;Loading initial data...&lt;/h2&gt;;
  }
  ...</pre>
<p>In the preceding snippet, we can see our infinite query code refactor after v5 and leverage <a id="_idIndexMarker500"/>the <strong class="source-inline">maxPages</strong> option. Here is <span class="No-Break">what changed:</span></p>
<ol>
<li>We use <strong class="source-inline">isPending</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">isLoading</strong></span></li>
<li>The <strong class="source-inline">defaultPageParam</strong> option indicates which is the default page that React Query will use to fetch the first page. This option is now required, so it <span class="No-Break">was added.</span></li>
<li>We add <strong class="source-inline">5</strong> as our <strong class="source-inline">maxPages</strong> option. This means that only five pages will be stored in memory. Since we use this option, the <strong class="source-inline">getPreviousPageParam</strong> option is <a id="_idIndexMarker501"/>now required so that React Query can fetch pages in both directions <span class="No-Break">if needed.</span></li>
</ol>
<p>With this, we have now wrapped up all the relevant changes in React Query v5 that might impact <span class="No-Break">this book.</span></p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor328"/>Summary</h1>
<p>In this chapter, we learned about all the changes v5 might bring to React Query. By now, you should know about the support changes you will need to be aware of in your browser and understand why we’ve always followed the object format throughout <span class="No-Break">the book.</span></p>
<p>You’ve seen why <strong class="source-inline">logger</strong> was removed and understand why renaming <strong class="source-inline">loading</strong>  to <strong class="source-inline">pending</strong> makes <span class="No-Break">more sense.</span></p>
<p>Speaking of renaming, you won’t be confused again because <strong class="source-inline">gcTime</strong> is a more accurate word than <strong class="source-inline">cacheTime</strong>, and <strong class="source-inline">HydrationBoundary</strong> represents better what it does <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">Hydrate</strong></span><span class="No-Break">.</span></p>
<p>You’ve learned that for paginated queries, the <strong class="source-inline">placeholderData</strong> option is the way to go and that <strong class="source-inline">keepPreviousData</strong> <span class="No-Break">was removed.</span></p>
<p>Finally, you were introduced to a new way to perform optimistic updates without updating your cache and found a way to save memory in your infinite queries, by leveraging the <span class="No-Break"><strong class="source-inline">maxPages</strong></span><span class="No-Break"> option.</span></p>
<p>As you may recall from what I said previously, this was tested in an alpha version of React Query, so some of these things might <span class="No-Break">still change.</span></p>
<p>It is exciting to see some of these changes, as they progressively improve <span class="No-Break">the library.</span></p>
<p>Personally, I can’t wait to see what comes next to TanStack Query. With every new version, it always finds a new way to make my life easier when dealing with server state. Hopefully, it will do the same for you from <span class="No-Break">now on.</span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer038">
</div>
</div>
</div></body></html>