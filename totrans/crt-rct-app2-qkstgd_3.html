<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Create React App and Babel</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you come from a background where maybe you haven't worked with JavaScript for a long time, or maybe you're new to JavaScript and Create React App is your conduit for using it, you may see a lot of syntax throughout this book and while exploring other people's projects and find that the code is hard to read without a thorough understanding of what's going on. This chapter aims to bridge that gap for people who are new to Babel and describe what it brings to the table with our Create React App project.</p>
<p class="mce-root">The other goal of this chapter is for people who are already comfortable with JavaScript, but are curious about what features Babel introduces and has turned on by default in a Create React App project, so that you can take advantage of all of the quality-of-life improvements and cleaner syntax rules in your project and really put that finishing touch on your project. The goal is to teach you production-ready code so that you're able to contribute at the highest level on your React projects.</p>
<p>As we work through this chapter, you can expect to get caught up on the following topics:</p>
<ul>
<li>Const variables</li>
<li>New arrow function syntax</li>
<li>Array and object destructuring</li>
<li>Array and object spread operators</li>
<li>React Fragments</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Babel and the latest JavaScript syntax</h1>
                </header>
            
            <article>
                
<p class="mce-root">We've been building up this application to act as our base and in the process we've introduced a lot of syntax that may not be the same JavaScript that you're used to writing! For example, we've written a few functions with this sort of syntax:</p>
<pre class="mce-root">const foo = () =&gt; {<br/>  doSomething();<br/>  doSomethingElse();<br/>}</pre>
<p class="mce-root">The syntax here is not particularly tricky and you can probably figure out what's going on, but maybe you don't fully understand how all of that ends up as a function when all is said and done. You may be more used to writing functions in a similar pattern to the following:</p>
<pre class="mce-root">var foo = function() {<br/>  doSomething();<br/>  doSomethingElse();<br/>}</pre>
<p class="mce-root">Or maybe something more like a function declaration without the variable, such as the following function:</p>
<pre class="mce-root">function foo() {<br/>  doSomething();<br/>  doSomethingElse();<br/>}</pre>
<p class="mce-root">The reality is that as JavaScript progresses, there are new and more efficient methods of writing a large variety of different language constructs. Some offer helpful shortcuts, or maybe they provide a nice quality-of-life improvement for developers. Since Create React App runs on Node.js, we get some syntax improvements here and there, but generally speaking, Node integrates those new features and syntax into its standard library at a much slower pace.</p>
<p>Over the course of this chapter, we'll dive deeper into how to write, incorporate, and, most importantly, <em>understand</em> modern JavaScript code in our Create React App projects. We'll take a look at what features are currently supported in Create React App and learn how to take full advantage of each and every one of them!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is Babel?</h1>
                </header>
            
            <article>
                
<p class="mce-root">Babel is designed to bridge the gap between <em>the features JavaScript will have</em> and <em>the features Node.js supports right now</em>, and turn that resulting code into something that Node.js can understand. That means that even if Node chooses not to support something (or maybe can't support due to incompatibilities with an existing system) you're still covered!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding the history</h1>
                </header>
            
            <article>
                
<p>To understand why Babel is incorporated by default into Create React App projects, you need to understand a little bit of its history (similar to why it's helpful to understand the history of why Create React App was turned into a tool). Back before this handy little CLI tool, a lot of the configuration was manual, and, typically, these projects would be either built against vanilla Node.js or on browsers directly. Whatever JavaScript you wanted to do was limited to the minimum number of features that would be supported against either every version of Node that could run your code or every browser you chose to support with your application.</p>
<p>As a result, you ended up with basically no support for anything fun or quality of life either. Think of it like the following table:</p>
<table style="border-collapse: collapse;width: 804px;height: 269px" border="1">
<tbody>
<tr>
<td><strong>Browser</strong></td>
<td><strong>Feature A</strong></td>
<td><strong>Feature B</strong></td>
<td><strong>Feature C</strong></td>
<td><strong>Feature D</strong></td>
</tr>
<tr>
<td>Internet Explorer</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Firefox</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Chrome</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Safari</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>What my code can support</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Using the previous table as an example, we get to support <em>Feature B</em> in our project and absolutely nothing else! There's nothing more demoralizing than knowing you could potentially support some insanely great feature in your programming language but not being able to use it because some users would have negative or completely broken experiences.</p>
<p>Maybe you and your company decide that you want to pare down the number of browsers you officially support so that you can get some of these new features. Now you need to make a decision about sacrificing your user base and alienating old and new users so that you can use newer language features. Maybe it makes for a better experience for your other users and that ends up being worth the cost, but then those decisions need to be made carefully and against what percentage of your users is using what. For example, if you decided you'd only support Safari, you'd alienate every single Windows user, not just every single Internet Explorer user.</p>
<p>These decisions are heavy and have longstanding impacts to the health of your application. Alienating a user base at the start of your project's life could mean that it never recovers from that in the first place!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Where does Babel fit into the puzzle?</h1>
                </header>
            
            <article>
                
<p>Babel comes to the rescue here by saying, <em>Hey, we'll give you those language f</em><em>eatures you want to use, but that not enough browsers support</em>. This becomes a massive relief as you start to use a larger and larger code base and run around some of the worst ways you used to have to architect larger JavaScript applications! Now if you want to use imports and new syntax and anything else, you can just do so!</p>
<p>Babel acts as a <strong>transpiler</strong>, which is a very fancy way of saying that it takes your JavaScript code that everything may not be able to be understood and turns it into JavaScript code that will be able to be understood! Babel will, based on different configurations, settings, and something called <strong>stages</strong>, allow you to opt in to all kinds of new syntax and language features and ensure that your code will run on most modern browsers! Granted, nothing is ever bulletproof and you will, of course, find different scenarios that aren't supported by some particular browser. You can't win them all, unfortunately!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Exploring modern JavaScript with Babel</h1>
                </header>
            
            <article>
                
<p>Over the course of this section, we're going to explore the different modern JavaScript tricks and techniques that Babel allows us to use as a major part of our code. We'll take a look at the different ways that we can implement all kinds of different code and patterns, exploring the differences between the JavaScript standard ways to do certain tricks and the shorthand syntax that Babel will allow us to use. The first, especially if you haven't written any modern JavaScript in a long time, is the addition of different variable declarations, such as <kbd>const</kbd> and <kbd>let</kbd>.</p>
<p>The <kbd>let</kbd> variable allows us to declare a variable with very specific scoping rules. While <kbd>var</kbd> is scoped to the nearest function block and gets used as a result of that, <kbd>let</kbd> is instead scoped to the nearest block in general, and can't be used before it's declared. You also can't redeclare variables with the same name with <kbd>let</kbd>.</p>
<p>The <kbd>const</kbd> variable allows us to declare a constant with the same scoping rules as <kbd>let</kbd>, overall. The best practice is to use both of these far more than using <kbd>var</kbd>. In fact, I personally never use <kbd>var</kbd> if I'm working with code that I know supports const and let instead.</p>
<p>Now, let's move on to the first more complex thing we've run into as part of our application code: JSX!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">JSX</h1>
                </header>
            
            <article>
                
<p>Let's look at a very simple example of JSX code; something very similar to the code we've already written. It's easier for us to start off simple and build it up a little bit so you can see how JSX actually helps us write our code a little faster and smarter.</p>
<p>First off, this is just a simple <kbd>HelloWorld div</kbd> in React:</p>
<pre>const HelloWorld = () =&gt; (&lt;div&gt;Hello World&lt;/div&gt;);</pre>
<p>Like I said, nothing particularly fancy or difficult yet. Let's take a look at the plain JavaScript version of this instead:</p>
<pre>function HelloWorld() {<br/>  return React.createElement('div', null, 'Hello World');<br/>}</pre>
<p>It does the same thing at the end of the day: it creates an <kbd>HelloWorld</kbd> React component, and then that component itself contains a single <kbd>div</kbd> with an <kbd>HelloWorld</kbd> body as the text. Where this starts to get more complicated is when you have to start including child components as well. Using our previous an <kbd>HelloWorld</kbd> component, let's expand it and make the person we're greeting configurable:</p>
<pre>const HelloWorld = props =&gt; (&lt;div&gt;Hello {props.name}&lt;/div&gt;);</pre>
<p>The analog in regular JavaScript would be the following:</p>
<pre>function HelloWorld(props) {<br/>  return React.createElement("div", null, `Hello ${props.name}!`);<br/>}</pre>
<p>Let's open up our project and experiment with changing some of the syntax in our existing project to use the non-JSX method of creating React components and elements. Our goal is that we should get to a point where we've added a little divider in between each of the <kbd>Todo</kbd> items in our <kbd>TodoList</kbd> component. We shouldn't have to modify too much to make this work, but we're going to use the non-JSX method to build out the <kbd>Divider</kbd> component. We'll start off by creating <kbd>src/Divider.js</kbd> and <kbd>src/Divider.css</kbd>, and then we'll start off by writing <kbd>src/Divider.js</kbd> first:</p>
<pre>import React from "react";<br/>import "./Divider.css";<br/><br/>function Divider() {<br/> return React.createElement(<br/> "div",<br/> { className: "Divider" },<br/> React.createElement("hr")<br/> );<br/>}<br/><br/>export default Divider;</pre>
<p>There's not a whole lot extra that we're doing here; we're creating a <kbd>div</kbd> container with a class of <kbd>Divider</kbd> (you can see here why <kbd>class</kbd> isn't available for you to use in React JSX; it would not make sense, since <kbd>class</kbd> is what we use to declare classes, such as for our class-based stateful components). In our function, which doesn't take in any additional properties, we return the results of the <kbd>React.createElement()</kbd> function. <kbd>React.createElement()</kbd> takes three arguments to its call: the main element we're creating (either an HTML tag, such as <kbd>div</kbd> or <kbd>hr</kbd>, or the fully-qualified name of the function or variable, such as <kbd>Todo</kbd>), followed by an object with the properties that you're passing on to this element, and finally the array of children that should live inside that component.</p>
<p>Next, we'll populate our <kbd>src/Divider.css</kbd> with some fancy CSS to make our <kbd>hr</kbd> into nice gradient-based dividing lines:</p>
<pre>hr {<br/>  border: 0;<br/>  height: 1px;<br/>  background-image: linear-gradient(<br/>    to right,<br/>    rgba(0, 0, 0, 0),<br/>    rgba(0, 0, 0, 0.8),<br/>    rgba(0, 0, 0, 0)<br/>  );<br/>}</pre>
<p>Next, go into <kbd>src/TodoList.js</kbd>, where we'll <kbd>import</kbd> our new <kbd>Divider</kbd> and modify a little bit of code to include the new divider. First, we'll start off with <kbd>import</kbd> at the top:</p>
<pre>import Divider from "./Divider";</pre>
<p>Then we'll actually place the <kbd>Divider</kbd> inside of the code. We'll need to go down to the <kbd>renderItems()</kbd> function and change the body to wrap <kbd>Todo</kbd> inside of a <kbd>div</kbd> container (we can get around this by using React Fragments, but we'll talk about this more a little bit later), and then include the <kbd>Divider</kbd> component at the bottom of that. Also, note that for each of the key properties in the following JSX code, we're prefixing the "description" with a little description of the component we're building to avoid collisions:</p>
<pre>  renderItems() {<br/>    return this.state.items.map(description =&gt; (<br/>      &lt;div key={"div-" + description}&gt;<br/>        &lt;Todo<br/>          key={description}<br/>          description={description}<br/>          removeTodo={this.removeTodo}<br/>        /&gt;<br/>        &lt;Divider key={"divide-" + description}/&gt;<br/>      &lt;/div&gt;<br/>    ));<br/>  }</pre>
<p>Save and reload, and we should have some new dividers breaking up our <kbd>Todo</kbd> items:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-285 image-border" src="Images/55cd75f0-c009-40d2-b326-cabdd15d0f89.png" style="width:86.17em;height:59.92em;" width="1034" height="719"/></p>
<p>And there we are, a new <kbd>Divider</kbd> written entirely in vanilla JavaScript!</p>
<div class="packt_infobox">The next code snippet is just provided as an example of what a full, more complicated function would look like written without any JSX. You don't actually need to do any of this work!</div>
<p>Just for fun, let's take a look at what our two <kbd>render()</kbd> function calls in <kbd>TodoList</kbd> would look like without JSX:</p>
<pre>  renderItems() {<br/>    return this.state.items.map(description =&gt;<br/>      React.createElement("div", { key: "div-" + description }, [<br/>        React.createElement(Todo, {<br/>          key: description,<br/>          description: description,<br/>          removeTodo: this.removeTodo<br/>        }),<br/>        React.createElement(Divider, { key: "divider-" + description })<br/>      ])<br/>    );<br/>  }<br/>  render() {<br/>    return React.createElement("div", { className: "TodoList" }, [<br/>      React.createElement(NewTodo, { addTodo: this.addTodo }),<br/>      this.renderItems()<br/>    ]);<br/>  }</pre>
<p>Everything will still function exactly the same, so if this was something you wanted to pursue and you preferred this syntax to JSX, that remains an option for you.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function syntax</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's also spend a little bit of time talking about the different ways to write functions that we can take advantage of when using Babel paired with Create React App. In the code we wrote previously, we already talked a bit about this and showed a few examples of alternate function syntax, but we're going to dive more deeply into everything now.</p>
<p>Ultimately, there are a few standard ways in JavaScript, without any frills, to declare a function. We can either choose the method of declaring a function with the <kbd>function</kbd> keyword, or we could declare it as a variable. Let's look at a few examples:</p>
<pre>function sayHello(name) {<br/>  console.log(`Hello ${name}!`);<br/>}</pre>
<p>We could also write this, without using any frills from Babel, via the following code:</p>
<pre>var sayHello = function(name) {<br/>  console.log(`Hello ${name}!`);<br/>}</pre>
<p>And the way that we'd invoke that function after having built it is just simply via the following:</p>
<pre>sayHello('Mason');</pre>
<p>So now, think back to some of the other functions that we've written over the previous two chapters. We've frequently defined functions using a <kbd>const</kbd> statement, which would turn the <kbd>function</kbd> we've written previously into the following instead:</p>
<pre>const sayHello = name =&gt; {<br/> console.log(`Hello ${name}!`);<br/>};</pre>
<p>While this is practically identical to the variable method of declaring functions in old JavaScript, there's a minor difference in terms of the syntax that's worth pointing out, and that's in the way that the function signature is declared in the code.</p>
<p>Previously, after our variable declaration, we'd write the function and then parentheses with the arguments in it. In modern JavaScript, we can use something called <strong>arrow functions</strong>. Arrow functions are a shorthand syntax shortcut with an extra benefit in terms of how <kbd>this</kbd> gets bound. Specifically, the context of <kbd>this</kbd> when the function is declared is the context of <kbd>this</kbd> when the function is declared. Instead of the function taking and defining its own context for <kbd>this</kbd>, it instead uses <kbd>this</kbd> in the current scope.</p>
<p>The rules for declaring arrow functions are pretty simple:</p>
<ul>
<li>If you have no arguments, you must declare the function with parentheses and then the fat arrow (<kbd>=&gt;</kbd>):</li>
</ul>
<pre style="padding-left: 60px">const foo = () =&gt; { return "Hi!"; }</pre>
<ul>
<li>If you have one argument, you can optionally include the parentheses:</li>
</ul>
<pre style="padding-left: 60px">const foo = name =&gt; { return `Hi ${name}!` };</pre>
<ul>
<li>If you have two or more arguments, you must include the parentheses:</li>
</ul>
<pre style="padding-left: 60px">const foo = (greeting, name) =&gt; { return `${greeting} ${name}!`; } </pre>
<ul>
<li>If you're returning something as a single-line function, you don't need to use curly brackets or a <kbd>return</kbd> statement:</li>
</ul>
<pre style="padding-left: 60px">const foo = (greeting, name) =&gt; `${greeting} ${name}`;</pre>
<ul>
<li>If you're returning something as a multi-line function, you must use curly brackets and a <kbd>return</kbd> statement:</li>
</ul>
<pre style="padding-left: 60px">const foo = (greeting, name) =&gt; {<br/>    const message = greeting + " " + name + "!";<br/>    return message;<br/>};</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Destructuring</h1>
                </header>
            
            <article>
                
<p class="mce-root">Modern JavaScript also gives us better access to destructuring. Destructuring is a way of matching the patterns in data structures (for example, in arrays or objects) and being able to turn those into individual variables in function arguments or in variable declarations. Let's mess around with a few different examples to get a good feel for how destructuring works and how we can better take advantage of it. Open up <kbd>src/App.js</kbd>, where we'll use destructuring a few times. Before we make our change, the <kbd>App</kbd> function should look like the following code:</p>
<pre>const App = () =&gt; (<br/>  &lt;div className="App"&gt;<br/>    &lt;h2&gt;Todoifier&lt;/h2&gt;<br/>    &lt;br /&gt;<br/>    &lt;TodoList /&gt;<br/>  &lt;/div&gt;<br/>);</pre>
<p>Nothing exciting yet, so let's make this code exciting! We'll start off by allowing you to rename your app, since maybe you don't feel that <kbd>Todoifier</kbd> is a great name for an app! We'll start off by adding a simple data structure above our code:</p>
<pre>const details = {<br/>  header: "Todoifier",<br/>  headerColor: "red"<br/>};</pre>
<p>Next, we'll destructure this data structure into a single variable name. We'll add the following line right after we declare our <kbd>details</kbd> data structure:</p>
<pre>const { header } = details;</pre>
<p>What we're doing here is rewriting the structure of the data structure we created in the <kbd>details</kbd> variable and then saying that we want it to take the value in the <kbd>header</kbd> key of the <kbd>details</kbd> variable and ignore everything else, and then throw it into the <kbd>header</kbd> variable. The end result is that we should expect to see <kbd>Todoifier</kbd> in the <kbd>header</kbd> variable. Just to make sure, let's throw a <kbd>console.log</kbd> statement and verify the results:</p>
<div>
<pre><span>console</span><span>.</span><span>log</span><span>(</span><span>"appName is "</span><span> </span><span>+</span><span> </span><span>appName</span><span>);</span></pre></div>
<p>We should see it show up in our JavaScript console in the browser if all went well:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-286 image-border" src="Images/f2c19437-7a71-4369-983e-8c41f5fd9ba7.png" style="width:49.67em;height:19.83em;" width="596" height="238"/></p>
<p>There we are! Now that we know this works, let's hop back over to the <kbd>App</kbd> component and add in a reference to the <kbd>header</kbd> variable:</p>
<pre>const App = () =&gt; (<br/>  &lt;div className="App"&gt;<br/>    &lt;h2&gt;{appName}&lt;/h2&gt;<br/>    &lt;br /&gt;<br/>    &lt;TodoList /&gt;<br/>  &lt;/div&gt;<br/>);</pre>
<p>When our page refreshes, we should see whatever value you threw in the <kbd>header</kbd> value in the <kbd>details</kbd> variable! Let's make it a little cleaner and a little bit closer to what you'd normally expect to see in production code, because right now the code we've written is a bit redundant. Delete the reference to <kbd>appName</kbd> and the <kbd>console.log</kbd> statement and we'll write a new function to use in our component:</p>
<pre>const headerDisplay = ({ header: title, headerColor: color }) =&gt; (<br/>  &lt;h2 style={{ color: color }}&gt;{title}&lt;/h2&gt;<br/>);</pre>
<p>We're actually using a few separate tricks here! We're using the new function declaration syntax and simple function <kbd>return</kbd> syntax, and we're using destructuring to make our code super simple and clean! We destructure a passed-in argument to pull the <kbd>title</kbd> and <kbd>headerColor</kbd> out and store those in the title and <kbd>color</kbd> variables, respectively!</p>
<p>We then pass those into the <kbd>h2</kbd> tag to set the CSS <kbd>color</kbd> style and the displayed <kbd>title</kbd> of the application! The final step is that we need to hook up this component to use the new <kbd>header</kbd> function we just defined:</p>
<pre>const App = () =&gt; (<br/>  &lt;div className="App"&gt;<br/>    {headerDisplay(details)}<br/>    &lt;br /&gt;<br/>    &lt;TodoList /&gt;<br/>  &lt;/div&gt;<br/>);</pre>
<p>And there we are! With this code in place, we should see a red header with the name <span class="packt_screen">Todoifier</span>! Let's take a look:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-287 image-border" src="Images/1d9b2a48-88cd-4dc7-8500-82dcaef778fe.png" style="width:63.00em;height:49.25em;" width="756" height="591"/></p>
<p>We can actually destructure arrays as well! For example, let's say we have a few unique options we want to start off our list with. We can capture those as named variables through array-destructuring, and we can also take advantage of some other syntax tricks we'll learn later, such as array spreads! Let's take a look at <kbd>src/TodoList.js</kbd> and change our constructor to use array-destructuring:</p>
<pre>const [item1, item2, ...rest] = [<br/>  "Write some code",<br/>  "Change the world",<br/>  "Take a nap",<br/>  "Eat a cookie"<br/>];<br/>this.state = {<br/>  items: [item1, item2, rest.join(" and ")]<br/>};</pre>
<p>Array-destructuring is just based on position; the only new trick here is that after matching <kbd>item1</kbd> and <kbd>item2</kbd>, we're just going to throw the remainder of the array onto a variable called <kbd>rest</kbd>, which we'll join with some spaces and the word <kbd>"and"</kbd>. Let's see the result:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-288 image-border" src="Images/995f2163-34f3-4bbf-959f-5577a3b0cbeb.png" style="width:50.83em;height:39.92em;" width="917" height="720"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Optional arguments</h1>
                </header>
            
            <article>
                
<p class="mce-root">Setting optional arguments for functions is thankfully a pretty simple endeavor! If you want to make a <kbd>function</kbd> argument optional, all you need to do is add an equals sign after the name of the parameter and give it a default value. For example, let's revisit the <kbd>sayHello</kbd> function we wrote a little bit earlier in this chapter:</p>
<pre>const sayHello = name =&gt; {<br/>  console.log(`Hello ${name}!`);<br/>};</pre>
<p>Now, let's modify that so that if someone doesn't specify a <kbd>name</kbd>, the function call will not just fail out or throw an error for the developer:</p>
<pre>const sayHello = (name = "Unknown") =&gt; {<br/>  console.log(`Hello ${name}!`);<br/>};</pre>
<p>Note that since we're using an optional variable for the argument list, we need to enclose it in parentheses again! Now, if someone were to call that function without specifying any parameters, we'd expect to see in our console <span class="packt_screen">Hello Unknown!</span>, something similar to the following:</p>
<pre>sayHello();</pre>
<p>With that, let's write this into our previous <kbd>headerDisplay</kbd> function. It will be a little messy, sure, but it's great to know how to use this effectively, since it's a great way to implement defensive programming in your projects:</p>
<pre>const headerDisplay = ({<br/>  header: title = "Todo List",<br/>  headerColor: color = "blue"<br/>}) =&gt; &lt;h2 style={{ color: color }}&gt;{title}&lt;/h2&gt;;</pre>
<p>Now, if we were to go back and change our App component's call to the <kbd>header()</kbd> function to just pass in a blank object, we would expect the header to instead say <kbd>TodoList</kbd> with a blue header:</p>
<pre>const App = () =&gt; (<br/>  &lt;div className="App"&gt;<br/>    {headerDisplay({})}<br/>    &lt;br /&gt;<br/>    &lt;TodoList /&gt;<br/>  &lt;/div&gt;<br/>);</pre>
<p class="mce-root">Let's see the results before we revert the change to our <kbd>header</kbd> function and change it back into passing in the <kbd>details</kbd> variable:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-289 image-border" src="Images/5e050b12-bb6d-4ef8-bc80-7edeb79ac47d.png" style="width:67.25em;height:40.25em;" width="807" height="483"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The spread operator</h1>
                </header>
            
            <article>
                
<p class="mce-root">Remember a little bit earlier in the chapter, when we wrote an ellipse and then a variable name? Any time you do that, you're telling JavaScript to stuff the rest of the unmatched stuff into here and join it to the current data structure:</p>
<pre>    const [item1, item2, ...rest] = [<br/>      "Write some code",<br/>      "Change the world",<br/>      "Take a nap",<br/>      "Eat a cookie"<br/>    ];</pre>
<p>This line of code tells JavaScript that the item in the first spot goes into the <kbd>item1</kbd> variable, the item in the second spot goes into the <kbd>item2</kbd> variable, and then everything else after that goes into the <kbd>rest</kbd> variable. We can take advantage of this as well when we want to add items onto an array in a non-destructive way. Remember the <kbd>addTodo()</kbd> function that lives in <kbd>src/TodoList.js</kbd>? Let's take a look at that in greater detail to see how we can use array spreads elsewhere:</p>
<pre>  addTodo(item) {<br/>    this.setState({ items: [...this.state.items, item] });<br/>  }</pre>
<p>This line of code is telling JavaScript to set the <kbd>items</kbd> key in the component's <kbd>state</kbd> to be equal to the current value of <kbd>this.state.items</kbd>, and then concatenate <kbd>item</kbd> onto the end of that list. The code is identical to this:</p>
<pre>this.setState({ items: this.state.items.concat(item) });</pre>
<p>You can also do this with objects in JavaScript code with Babel's most recent update in Create React App, which is great for <kbd>state</kbd> modification, since <kbd>state</kbd> modification is just changing objects around! Let's head back to <kbd>src/App.js</kbd> and write a sample bit of code that also sets a background color for our <kbd>header</kbd>. We'll start off with our object spread and set a new variable called <kbd>moreDetails</kbd>:</p>
<pre>const moreDetails = {<br/>  ...details,<br/>  header: "Best Todoifier",<br/>  background: "black"<br/>};</pre>
<p>We're just taking the <kbd>details</kbd> data structure, and then on top of that, we're either adding new keys or replacing values for existing keys. Next, we'll need to modify the <kbd>headerDisplay</kbd> function to be able to work with a background color being passed in:</p>
<pre>const headerDisplay = ({<br/>  header: title = "Todo List",<br/>  headerColor: color = "blue",<br/>  background: background = "none"<br/>}) =&gt; &lt;h2 style={{ color: color, background: background }}&gt;{title}&lt;/h2&gt;;</pre>
<p>The final step of this is to change the call in the <kbd>App</kbd> component to pass in <kbd>moreDetails</kbd> to the <kbd>header</kbd> instead of <kbd>details</kbd> or a blank object:</p>
<pre>const App = () =&gt; (<br/>  &lt;div className="App"&gt;<br/>    {headerDisplay(moreDetails)}<br/>    &lt;br /&gt;<br/>    &lt;TodoList /&gt;<br/>  &lt;/div&gt;<br/>);</pre>
<p>After you save and reload, you should see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-290 image-border" src="Images/bb93503b-6a75-414b-8867-e91cb332aab0.png" style="width:87.50em;height:59.75em;" width="1050" height="717"/></p>
<p>The line of code for the <kbd>Object</kbd> spread is the equivalent of us writing the following:</p>
<pre>const moreDetails = Object.assign({}, details, {<br/>  header: "Best Todoifier",<br/>  background: "black"<br/>});</pre>
<p>It's just a little more concise and easier to read, so it's great that the Create React App team and the Babel team made this supported in the most recent version!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">React Fragments</h1>
                </header>
            
            <article>
                
<p class="mce-root">The final thing we're going to talk about in this chapter is the new support for React Fragments! React Fragments are a brand-new, but important, feature. Previously, if you wanted to include multiple components at the same level, you <em>always</em> had to have a root component, even for things such as multiple table rows, which never really made sense; you'd have to nest <kbd>&lt;td&gt;</kbd> tags inside of <kbd>&lt;div&gt;</kbd>, which is just weird.</p>
<p>It ends up with you having to choose between writing what's technically invalid HTML or writing compliant React code, which tends to just end up as awkward or bad code to get around the limitation. Now, instead, we can write code encased in special Fragment tags (<kbd>&lt;Fragment&gt;</kbd> and <kbd>&lt;/Fragment&gt;</kbd>) to denote the start and end of a fragment, respectively. We can reference these as <kbd>&lt;React.Fragment&gt;</kbd>, <kbd>&lt;Fragment&gt;</kbd> (if we choose to <kbd>import Fragment</kbd> where we <kbd>import Component</kbd>, such as in the following line of code), or as <kbd>&lt;&gt;</kbd> for a shortcut:</p>
<pre>import React, { Fragment, Component } from "react";</pre>
<div class="packt_infobox">A quick warning about using the shortcut syntax of <kbd>&lt;&gt;</kbd> and <kbd>&lt;/&gt;</kbd>: if you're using Fragments inside of code that's building a list of Fragments, you can't use the shortcut syntax and still specify a <kbd>key</kbd> property; you will have to use either <kbd>React.Fragment</kbd> or <kbd>Fragment</kbd>.</div>
<p>If we go back to <kbd>src/TodoList.js</kbd>, in our <kbd>renderItems()</kbd> function, we can see the perfect place to replace an extraneous <kbd>&lt;div&gt;</kbd> with a <kbd>Fragment</kbd> instead:</p>
<pre> renderItems() {<br/> return this.state.items.map(description =&gt; (<br/> &lt;Fragment key={"item-" + description}&gt;<br/>  &lt;Todo<br/>   key={description}<br/>   description={description}<br/>   removeTodo={this.removeTodo}<br/>  /&gt;<br/> &lt;Divider key={"divide-" + description} /&gt;<br/>  &lt;/Fragment&gt;<br/> ));<br/> }</pre>
<p>At the top of the function, where we <kbd>import Component</kbd> as a named <kbd>import</kbd> from <kbd>React</kbd>, we'll also need to include <kbd>Fragment</kbd>, similar to the line of code a little bit higher up in this section.</p>
<p>The end result is otherwise identical; the major difference is that instead of placing each of the Todos and Dividers inside of extra <kbd>div</kbd> for no reason, they can all sit next to each other in the DOM tree and keep your code significantly cleaner, especially in the case of working with HTML tables, where introducing an extra <kbd>div</kbd> will actually just break your code!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A quick recap</h1>
                </header>
            
            <article>
                
<p>Before we end this chapter, let's look at the final state of all of the code that we've written. Our <kbd>src/TodoList.js</kbd> has expanded and includes a lot of new tricks:</p>
<pre>import React, { Fragment, Component } from "react";<br/>import Todo from "./Todo";<br/>import "./TodoList.css";<br/><br/>import NewTodo from "./NewTodo";<br/>import Divider from "./Divider";<br/><br/>class TodoList extends Component {<br/>  constructor(props) {<br/>    super(props);<br/>    const [item1, item2, ...rest] = [<br/>      "Write some code",<br/>      "Change the world",<br/>      "Take a nap",<br/>      "Eat a cookie"<br/>    ];<br/>    this.state = {<br/>      items: [item1, item2, rest.join(" and ")]<br/>    };<br/><br/>    this.addTodo = this.addTodo.bind(this);<br/>    this.removeTodo = this.removeTodo.bind(this);<br/>  }<br/>  addTodo(item) {<br/>    this.setState({ items: [...this.state.items, item] });<br/>  }<br/>  removeTodo(removeItem) {<br/>    const filteredItems = this.state.items.filter(description =&gt; {<br/>      return description !== removeItem;<br/>    });<br/>    this.setState({ items: filteredItems });<br/>  }<br/>  renderItems() {<br/>    return this.state.items.map(description =&gt; (<br/>      &lt;Fragment key={"item-" + description}&gt;<br/>        &lt;Todo<br/>          key={description}<br/>          description={description}<br/>          removeTodo={this.removeTodo}<br/>        /&gt;<br/>        &lt;Divider key={"divide-" + description} /&gt;<br/>      &lt;/Fragment&gt;<br/>    ));<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;div className="TodoList"&gt;<br/>        &lt;NewTodo addTodo={this.addTodo} /&gt;<br/>        {this.renderItems()}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}<br/><br/>export default TodoList;</pre>
<p>Our <kbd>src/App.js</kbd> component has expanded significantly as well:</p>
<pre>import React from "react";<br/>import "./App.css";<br/><br/>import TodoList from "./TodoList";<br/><br/>const details = {<br/> header: "Todoifier",<br/> headerColor: "red"<br/>};<br/><br/>const moreDetails = {<br/> ...details,<br/> header: "Best Todoifier",<br/> background: "black"<br/>};<br/><br/>const App = () =&gt; (<br/> &lt;div className="App"&gt;<br/> {header(moreDetails)}<br/> &lt;br /&gt;<br/> &lt;TodoList /&gt;<br/> &lt;/div&gt;<br/>);<br/><br/>const header = ({<br/> header: title = "Todo List",<br/> headerColor: color = "blue",<br/> background: background = "none"<br/>}) =&gt; &lt;h2 style={{ color: color, background: background }}&gt;{title}&lt;/h2&gt;;<br/><br/>export default App;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">We covered a lot, but were pretty productive! We talked a lot about how to take full advantage of the better and cleaner syntax that Babel offers us in a Create React App 2 project!</p>
<p>Even this is really just scratching the surface of what you can do in modern JavaScript, but it covers a lot of the common patterns and tricks that you'll see throughout this book. We hope this guide will give you everything you need to be able to execute projects and to understand and contribute at the highest levels!</p>
<p>We'll be exploring a lot of these code techniques in future chapters, so make sure you have a firm grasp of everything we discussed in this chapter before you forge ahead!</p>


            </article>

            
        </section>
    </div>



  </body></html>