- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Performing Bulk Operations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行批量操作
- en: '**Bulk operations** are tasks performed on a large scale, such as uploading
    many files at once, deleting or inserting many items in one shot, or applying
    a transformation or computation to multiple elements of a list simultaneously.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**批量操作**是在大规模上执行的任务，例如一次性上传多个文件、一次性删除或插入多个项目，或者同时对列表中的多个元素应用转换或计算。'
- en: These operations are designed to handle multiple updates in a single operation,
    often resulting in improved efficiency and performance compared to when each item
    is processed separately. Tracking the progress of bulk operations is crucial to
    provide feedback to users, monitor the health of the operation, and identify potential
    issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作旨在处理单个操作中的多个更新，通常与单独处理每个项目相比，效率更高，性能更好。跟踪批量操作的进度对于向用户提供反馈、监控操作的健康状况以及识别潜在问题至关重要。
- en: In this chapter, we will start by explaining the bulk operation requirement
    and the type of bulk operation that we will consider. After that, we will walk
    you through the different steps to implement the reactive pattern for implementing
    bulk operations. Finally, we will learn the reactive pattern for tracking the
    bulk operation’s progress.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先解释批量操作需求以及我们将考虑的批量操作类型。然后，我们将向您介绍实现批量操作的响应式模式的各个步骤。最后，我们将学习用于跟踪批量操作进度的响应式模式。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Defining the bulk operation requirements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义批量操作需求
- en: Learning the reactive pattern for bulk operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习用于批量操作的响应式模式
- en: Learning the reactive pattern for tracking the bulk operation’s progress
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习用于跟踪批量操作进度的响应式模式
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have a basic understanding of RxJS.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您对RxJS有基本的了解。
- en: The source code of this chapter is available at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap11](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap11).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在[https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap11](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap11)找到。
- en: Defining the bulk operation requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义批量操作需求
- en: 'In web applications, a bulk operation is represented by one action or event;
    however, in the background, there are two possible behaviors:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，批量操作由一个动作或事件表示；然而，在后台，有两种可能的行为：
- en: Running one network request for all the tasks
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有任务运行一个网络请求
- en: Running parallel network requests for every task
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个任务运行并行网络请求
- en: 'In this chapter, we will be using the second behavior. We want to allow the
    user to upload the recipe images at once, track the progress of the upload operation,
    and display a progress bar to the user. We can see what this will look like here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用第二种行为。我们希望允许用户一次性上传菜谱图片，跟踪上传操作的进度，并向用户显示进度条。我们可以在这里看到它将是什么样子：
- en: '![Figure 11.1 – Uploading the recipe’s images](img/B21180_11_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 上传菜谱的图片](img/B21180_11_1.jpg)'
- en: Figure 11.1 – Uploading the recipe’s images
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 上传菜谱的图片
- en: In the `RecipeCreation` interface, we will be changing the layout of the **ImageUrl**
    field to the **File Upload** layout available in our library of components, PrimeNG,
    as shown in the screenshot. The **File Upload** layout allows the user to choose
    multiple files, clear the selection, and upload the files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RecipeCreation`接口中，我们将更改**ImageUrl**字段的布局，将其更改为我们组件库PrimeNG中可用的**文件上传**布局，如图所示。**文件上传**布局允许用户选择多个文件、清除选择并上传文件。
- en: The upload will be done on the server, and we have a specific service for the
    upload that takes both the file to be uploaded and the identifier of the associated
    recipe as input. Since the backend upload API supports only one file at a time,
    we will be running *N* network requests in parallel to upload *N* files (i.e.,
    if we upload two files, two requests will be sent). This is the bulk change use
    case that we will consider in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上传将在服务器上完成，我们有一个专门的上传服务，该服务接受要上传的文件和关联菜谱的标识符作为输入。由于后端上传API一次只支持一个文件，我们将并行运行*N*个网络请求来上传*N*个文件（即，如果我们上传两个文件，将发送两个请求）。这是我们将在本章中考虑的大规模更改用例。
- en: 'In the UI, we will have one event that will trigger multiple requests at the
    same time. The following diagram provides a graphical representation of the bulk
    operation:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UI 中，我们将有一个事件，该事件将同时触发多个请求。以下图表提供了批量操作的图形表示：
- en: '![Figure 11.2 – A bulk operation visualization](img/B21180_11_2.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 批量操作可视化](img/B21180_11_2.jpg)'
- en: Figure 11.2 – A bulk operation visualization
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 批量操作可视化
- en: 'So, to sum up, we want to do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，我们想要做以下事情：
- en: Allow the user to upload many files after clicking only once on the **Upload**
    button
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户在点击一次 **上传** 按钮后上传多个文件
- en: Display the progress of this bulk operation
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示此批量操作的进度
- en: Now that we have defined the requirement, let’s see how we can implement it
    in a reactive way.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了需求，让我们看看我们如何以响应式的方式实现它。
- en: Learning the reactive pattern for bulk operations
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习批量操作的响应式模式
- en: As usual, we have to consider our tasks as streams. As the task that we are
    going to perform is uploading the recipe image in the backend, let’s imagine a
    stream called `uploadRecipeImage$` that will take the file and the recipe identifier
    as input and perform an HTTP request. If we have *N* files to be uploaded, then
    we will create *N* streams.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们必须将我们的任务视为流。由于我们即将执行的任务是在后端上传食谱图片，让我们想象一个名为 `uploadRecipeImage$` 的流，它将文件和食谱标识符作为输入并执行
    HTTP 请求。如果我们有 *N* 个文件需要上传，那么我们将创建 *N* 个流。
- en: We want to subscribe to all those streams together, but we are not interested
    in the values emitted from each stream through the process. Instead, we only care
    about the final result (the last emission) – whether the file is uploaded successfully,
    or something wrong happens and the upload fails.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望一起订阅所有这些流，但我们对每个流在过程中发射的值不感兴趣。相反，我们只关心最终结果（最后一次发射）——文件是否成功上传，或者发生错误导致上传失败。
- en: 'Is there an RxJS operator that gathers a list of Observables together to get
    a cumulative result? Thankfully, yes: we have the `forkJoin` operator.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有 RxJS 操作符可以收集一组可观察对象以获得累积结果？幸运的是，是的：我们有 `forkJoin` 操作符。
- en: The forkJoin operator
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`forkJoin` 操作符'
- en: 'The `forkJoin` operator falls under the category of combination operators.
    If we look at the official documentation, we find this definition:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`forkJoin` 操作符属于组合操作符类别。如果我们查看官方文档，我们会找到以下定义：'
- en: '*“Accepts an Array of ObservableInput or a dictionary Object of ObservableInput
    and returns an Observable that emits either an array of values in the exact same
    order as the passed array, or a dictionary of values in the same shape as the*
    *passed dictionary.”*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*“接受一个 ObservableInput 的数组或一个包含 ObservableInput 的字典对象，并返回一个 Observable，该 Observable
    会以与传入数组相同的顺序发射值数组，或者以与传入字典相同形状的值字典。”*'
- en: In other words, `forkJoin` takes a list of Observables as input, waits for the
    Observables to complete, and then combines the last values they emitted in one
    array and returns it. The order of the values in the resulting array is the same
    as the order of the input Observables.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`forkJoin` 接受一个可观察对象的列表作为输入，等待可观察对象完成，然后将它们最后发射的值合并到一个数组中并返回。结果数组中值的顺序与输入可观察对象的顺序相同。
- en: 'Let’s consider the following marble diagram to better understand this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下大理石图来更好地理解这一点：
- en: '![Figure 11.3 – A forkJoin marble diagram](img/B21180_11_3.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 一个 forkJoin 大理石图](img/B21180_11_3.jpg)'
- en: Figure 11.3 – A forkJoin marble diagram
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 一个 forkJoin 大理石图
- en: Here, `forkJoin` has three input Observables (represented by the three timelines
    before the operator box).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`forkJoin` 有三个输入可观察对象（由操作符框之前的三个时间线表示）。
- en: The first Observable emitted the `forkJoin` does not emit anything (look at
    the last timeline after the operator box, which represented the returned result
    by `forkJoin`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个可观察对象发射的 `forkJoin` 不发射任何内容（查看操作符框之后的最后一个时间线，它代表了 `forkJoin` 返回的结果）。
- en: Then, the third Observable emitted `forkJoin`. Why? Because, as we said in the
    definition, `forkJoin` will emit only once when all the Observables are complete.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第三个可观察对象发射了 `forkJoin`。为什么？因为，正如我们在定义中所说的，当所有可观察对象都完成时，`forkJoin` 才会发射一次。
- en: 'So, as illustrated in the marble diagram, `forkJoin` emitted only once when
    the last Observable (the second one) completed. Let’s break this down:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如图中大理石图所示，当最后一个可观察对象（第二个）完成时，`forkJoin` 只发射了一次。让我们来分析一下：
- en: The third Observable (represented by the third timeline) completed first, and
    the last value emitted was **4**.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个可观察对象（由第三个时间线表示）首先完成，最后发射的值是 **4**。
- en: Then, the first Observable (represented by the first timeline) completed, and
    the last value emitted was `forkJoin` did not emit any value because there was
    still an Observable running.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，第一个可观察对象（由第一个时间线表示）完成，最后一个发出的值是`forkJoin`没有发出任何值，因为还有一个可观察对象正在运行。
- en: Finally, the last Observable (represented by the second timeline) completed,
    and the last value emitted was `forkJoin` returns an array containing the results
    of each stream in the order of the input Observables (**e**, **j**, and **4**).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，最后一个可观察对象（由第二个时间线表示）完成，最后一个发出的值是`forkJoin`返回一个包含每个输入可观察对象结果的数组，顺序与输入可观察对象（**e**、**j**和**4**）的顺序相同。
- en: The order of completion is not considered; otherwise, we would have had `[4,e,j]`.
    Even though the third Observable was completed before the first and second one,
    `forkJoin` respected the order of the input Observables and returned the **e**
    value before the **4** and **j** values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 完成顺序不考虑；否则，我们会有`[4,e,j]`。即使第三个可观察对象在第一个和第二个可观察对象之前完成，`forkJoin`也尊重输入可观察对象的顺序，并在**4**和**j**值之前返回**e**值。
- en: So, keep in mind that `forkJoin` emits once when all the input Observables are
    complete and preserves the order of the input Observables.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请记住，当所有输入可观察对象都完成时，`forkJoin`会发出一次，并保留输入可观察对象的顺序。
- en: This fits our requirements well! `forkJoin` is best used when you have a list
    of Observables and only care about the final emitted value of each. That’s what
    we want to do. In our case, we will issue multiple upload requests, and we only
    want to take action when a response is received from all the input streams.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地符合了我们的要求！`forkJoin`在您有一系列可观察对象且只关心每个可观察对象的最终发出值时使用最佳。这正是我们想要做的。在我们的情况下，我们将发出多个上传请求，并且我们只想在收到所有输入流的响应时采取行动。
- en: Let’s now see the bulk operation reactive pattern in action.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看批量操作响应式模式在实际中的应用。
- en: The bulk operation reactive pattern
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量操作响应式模式
- en: 'To utilize the pattern in our recipe app, first, we need to create a new service
    called `UploadRecipesPreviewService` under `src/app/core/services`, which is responsible
    for uploading the files. Here is the service’s code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的菜谱应用中利用此模式，首先，我们需要在`src/app/core/services`下创建一个名为`UploadRecipesPreviewService`的新服务，该服务负责上传文件。以下是该服务的代码：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `upload` method issues the HTTP upload request and returns the upload status
    (whether having succeeded or failed). This method takes two parameters as input:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`upload`方法发出HTTP上传请求并返回上传状态（是否成功或失败）。此方法接受两个参数作为输入：'
- en: '`recipeId`: The identifier of the recipe'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recipeId`：菜谱的标识符'
- en: '`fileToUpload`: The file to be uploaded'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileToUpload`：要上传的文件'
- en: Then we used `FormData` to send the file to the server. `FormData` is an object
    in JavaScript that allows you to easily build a set of key-value pairs representing
    form fields and their values respectively.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`FormData`将文件发送到服务器。`FormData`是JavaScript中的一个对象，它允许您轻松构建一组键值对，分别代表表单字段及其值。
- en: 'Now we need to implement the behavior of the `RecipeCreationComponent` template,
    we need to specify the method that will be called when clicking on the `onUpload`
    method in our case – and put it as a value to the callback – `uploadHandler` –
    provided by the component library we are using to get triggered when the user
    uploads the files. Here’s the HTML template snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现`RecipeCreationComponent`模板的行为，我们需要指定当点击我们的`onUpload`方法时将被调用的方法——并将其作为值放入由我们使用的组件库提供的回调——`uploadHandler`——以在用户上传文件时触发。以下是HTML模板片段：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the code in the template has been removed here for brevity. You can
    find the full template code in the book’s GitHub repository, the link for which
    can be found in the *Technical* *requirements* section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，这里已经从模板中删除了一些代码。您可以在书籍的GitHub仓库中找到完整的模板代码，该链接可以在*技术要求*部分找到。
- en: 'Next, we need to implement the `onUpload` method and define our reactive streams
    in `RecipeCreationComponent`. So, we will define the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现`onUpload`方法并在`RecipeCreationComponent`中定义我们的响应式流。因此，我们将定义以下内容：
- en: 'A `BehaviorSubject` that will always emit the last value of the uploaded files,
    called `uploadedFilesSubject$`, and initialize it with an empty array:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`BehaviorSubject`，它将始终发出上传文件的最后一个值，称为`uploadedFilesSubject$`，并用空数组初始化它：
- en: '[PRE2]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `onUpload (files: File[])` method, which is called when clicking on the
    `uploadedFilesSubject$` with the last array of uploaded files as follows:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onUpload (files: File[])`方法，当点击`uploadedFilesSubject$`时调用，并带有最后一个上传文件的数组如下：'
- en: '[PRE3]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A stream called `uploadRecipeImages$` that is responsible for doing the bulk
    upload as follows:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `uploadRecipeImages$` 的流，负责执行批量上传，如下所示：
- en: '[PRE4]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s break down what’s going on in the code here, piece by piece.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们逐个分析这里代码中正在发生的事情。
- en: Every time we click on the `uploadedFilesSubject$` will emit the files to be
    uploaded. We need to listen to `uploadedFilesSubject$` emissions, and then use
    `switchMap` (which we learned about in [*Chapter 6*](B21180_06.xhtml#_idTextAnchor097),
    *Transforming Streams*) to transform every value emitted by `uploadedFilesSubject$`
    to the Observable that will be built using `forkJoin`.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次我们点击 `uploadedFilesSubject$` 时，都会发射要上传的文件。我们需要监听 `uploadedFilesSubject$` 的发射，然后使用
    `switchMap`（我们在 [*第 6 章*](B21180_06.xhtml#_idTextAnchor097)，*转换流*) 将 `uploadedFilesSubject$`
    发射的每个值转换为我们将使用 `forkJoin` 构建的 Observable。
- en: To `forkJoin`, we pass an array of the Observables responsible for uploading
    each file. We built the array of Observables by mapping every file in the `uploadedFiles`
    array to the stream, resulting from calling the `upload` method available in `UploadRecipesPreviewService`
    that takes the `id` property of the recipe (which we retrieved from `recipeForm`)
    and the file as input.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 `forkJoin`，我们传递一个数组，其中包含负责上传每个文件的 Observables。我们通过将 `uploadedFiles` 数组中的每个文件映射到由调用
    `UploadRecipesPreviewService` 中的 `upload` 方法生成的流来构建 Observables 数组，该方法接受来自 `recipeForm`
    的菜谱的 `id` 属性（我们从中检索）和文件作为输入。
- en: 'Now that we’ve established our upload logic and defined the upload stream,
    it’s time to subscribe to the `uploadRecipeImages$` stream. We need to inject
    `UploadRecipesPreviewService` into the constructor and subscribe to `uploadRecipeImages$`
    in the template, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了上传逻辑并定义了上传流，是时候订阅 `uploadRecipeImages$` 流了。我们需要在构造函数中注入 `UploadRecipesPreviewService`
    并在模板中订阅 `uploadRecipeImages$`，如下所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let’s suppose one of the inner streams errors out. The `forkJoin` operator
    will no longer emit any values for us. This is another important thing to be aware
    of when using this operator. You will lose the value of any other stream that
    would have already been completed if you do not catch the error correctly on the
    inner Observable. Therefore, catching the error in this case is crucial!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设其中一个内部流出现错误。`forkJoin` 操作符将不再为我们发射任何值。这是在使用此操作符时需要注意的另一个重要事项。如果你没有正确捕获内部
    Observable 上的错误，你将丢失任何其他已经完成的流的值。因此，在这种情况下捕获错误是至关重要的！
- en: 'This is how we handle it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们处理它的方式：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we called `catchError` on the inner stream returned by the `upload` method.
    Then, we wrapped the error inside another Observable and returned it. This way,
    the `forkJoin` stream will stay alive and emit values.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `upload` 方法返回的内部流上调用 `catchError`。然后，我们将错误包装在另一个 Observable 中并返回它。这样，`forkJoin`
    流将保持活跃并发射值。
- en: It makes a lot of sense to catch the errors in order to display something significant
    to the user – for example, in our case, if one of the uploads fails because the
    maximum image file size was reached or the extension of the image is not allowed,
    then the system should display such an exception to the user to help them fix
    the file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获错误以向用户显示一些有意义的内容是非常有意义的 - 例如，在我们的案例中，如果上传失败是因为达到了最大图像文件大小或图像扩展名不被允许，那么系统应该向用户显示这样的异常，帮助他们修复文件。
- en: Benefits of the forkJoin operator
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: forkJoin 操作符的优点
- en: 'To sum up, `forkJoin` has the following benefits:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`forkJoin` 有以下优点：
- en: It is very useful when you are interested in combining results and getting a
    value only once
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你对组合结果并只获取一次值感兴趣时，它非常有用
- en: It only emits *once*, when all the Observables complete
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只发射一次，当所有 Observables 完成时
- en: It preserves the order of the input Observables in the emission
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它保留了输入 Observables 在发射中的顺序
- en: It will complete when one of the streams errors out, so make sure you handle
    the error
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其中一个流出现错误时，它将完成，所以请确保你处理了错误
- en: Now, at this point, our code works nicely. But what if we need to know some
    information during the process, such as how many files were already uploaded?
    What is the progress of the operation? How much time do we still need to wait?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这个阶段，我们的代码运行得很好。但如果我们需要在过程中了解某些信息，比如已经上传了多少文件？操作进度如何？我们还需要等待多长时间？
- en: With the current `forkJoin` implementation, it is not possible, but let’s see
    how we can do it in the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的 `forkJoin` 实现中，这是不可能的，但让我们看看在下一节中我们如何做到这一点。
- en: Learning the reactive pattern for tracking the bulk operation’s progress
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习反应式模式以跟踪批量操作进度
- en: Tracking the progress of bulk operations is very important, as it provides feedback
    to the user and can identify potential issues. When it comes to approaches for
    tracking progress, there are different strategies and techniques depending on
    the nature of the bulk operation and the technology stack you’re using. For example,
    you can use an increment counter to show when each operation is processed, use
    a percentage to track the progress of the operations, or even log the progress
    to a file or database.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪大量操作的进度非常重要，因为它为用户提供反馈并可以识别潜在问题。当涉及到跟踪进度的方法时，根据大量操作的性质和所使用的技术堆栈，有不同的策略和技术。例如，你可以使用递增计数器来显示每次操作的处理情况，使用百分比来跟踪操作的进度，或者甚至将进度记录到文件或数据库中。
- en: In the case of our recipe app, in order to track the progress of the bulk upload,
    we will use the percentage of completion strategy. To implement this strategy,
    we will use a very useful operator called `finalize`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的食谱应用中，为了跟踪大量上传的进度，我们将使用完成百分比策略。为了实现此策略，我们将使用一个非常有用的运算符，称为`finalize`。
- en: The `finalize` operator allows you to call a function when the Observable completes
    or errors out. The idea is to call this operator and execute a function that will
    calculate the progress. This way, every time an Observable completes, the progress
    will get updated.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`finalize`运算符允许你在Observable完成或出错时调用一个函数。想法是调用此运算符并执行一个计算进度的函数。这样，每次Observable完成时，进度都会得到更新。'
- en: 'This is what the code will look like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的样子：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `finalize` operator calls the `calculateProgressPercentage` private function
    that takes the following parameters:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`finalize`运算符调用`calculateProgressPercentage`私有函数，该函数接受以下参数：'
- en: '*The number of completed requests*: We just declare a `counter` property that
    we will increment every time the Observable completes'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完成的请求数量*：我们只声明一个`counter`属性，每次Observable完成时我们将增加它'
- en: '*The total number of requests*: This number is retrieved from the array of
    `uploadedFiles`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*请求总数*：此数字是从`uploadedFiles`数组中检索的'
- en: Inside the `calculateProgressPercentage` function, we perform a simple computation
    to identify the completion percentage and store the result in an `uploadProgress`
    property. When the user clicks on `uploadProgress` and `counter` properties should
    be reset to `0`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`calculateProgressPercentage`函数内部，我们执行一个简单的计算来识别完成百分比并将结果存储在`uploadProgress`属性中。当用户点击`uploadProgress`和`counter`属性时，应将它们重置为`0`。
- en: 'Then, you can map the value of this property to any `ProgressBar` component
    in the UI. In our case, we used the PrimeNG `p-progressBar` component as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将此属性的值映射到UI中的任何`ProgressBar`组件。在我们的例子中，我们使用了PrimeNG的`p-progressBar`组件，如下所示：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we only display `p-progressBar` when the upload is in progress (`uploadProgress>0`)
    and we pass the `uploadProgress` value as input to the progress component. This
    way, you will be able to display the progress to the user.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只在上传过程中显示`p-progressBar`（当`uploadProgress>0`时）并将`uploadProgress`值作为输入传递给进度组件。这样，你就能向用户显示进度。
- en: 'Here is the result in our app:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，这是结果：
- en: '![Figure 11.4 – The file upload progress bar](img/B21180_11_4.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 文件上传进度条](img/B21180_11_4.jpg)'
- en: Figure 11.4 – The file upload progress bar
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 文件上传进度条
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained the concept of bulk operation and learned how
    to implement a real-world example of a bulk task in a reactive way. We learned
    the behavior and a use case of the `forkJoin` operator and went through the different
    steps to implement a bulk upload. Finally, we went through a reactive technique
    to implement the tracking progress functionality using the `finalize` operator.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了大量操作的概念，并学习了如何以响应式的方式实现一个实际的大量任务示例。我们学习了`forkJoin`运算符的行为和用例，并了解了实现大量上传的不同步骤。最后，我们通过使用`finalize`运算符实现跟踪进度功能的方法进行了响应式技术介绍。
- en: In the next chapter, we will explore the pattern of real-time updates and the
    different techniques available in RxJS to implement them at the lowest cost.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨实时更新模式以及RxJS中可用的不同技术，以最低的成本实现它们。
