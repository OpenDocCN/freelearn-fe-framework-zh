- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracking Application State with Signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular empowers developers to use built-in reactivity in their applications
    using **signals** . Angular signals are a synchronous approach to reactive programming
    that efficiently improves application performance and manages application state.
  prefs: []
  type: TYPE_NORMAL
- en: We met signals in previous chapters where we used the `input` method to exchange
    data between components and the `viewChild` method to query child components.
    The Signals API can be used in different parts of an Angular application, thus,
    its usage is scattered throughout the chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computed signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cooperating with RxJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The chapter contains various code samples to walk you through the concept of
    Angular signals. You can find the related source code in the `ch07` folder of
    the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in *Chapter 3* , *Structuring User Interfaces with Components*
    , **Zone.js** plays a significant role in the performance of an Angular application.
    It triggers the Angular change detection mechanism when particular events occur
    inside the application. The framework checks every application component in each
    detection cycle and evaluates its bindings, degrading application performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rationale of change detection with Zone.js is based on the fact that Angular
    cannot know when or where a change has happened inside the application. Inevitably,
    Angular developers try to limit change detection cycles using the following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring components with the `OnPush` change detection strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting manually with the change detection mechanism using the `ChangeDetectorRef`
    service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signals improve how developers interact with the Angular change detection mechanism
    by simplifying and enhancing the preceding techniques according to application
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Angular signals provide more robust and ergonomic management of the change detection
    cycle based on reactivity. They watch how the application state changes and allow
    the framework to react by triggering change detection only in parts affected by
    the change.
  prefs: []
  type: TYPE_NORMAL
- en: Signals are an innovative feature of the Angular framework that will enable
    further improvements in the application’s performance by introducing **zone-less
    applications** and **signal-based components** in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Signals also act as containers for values, which the change detection mechanism
    must check. When a value changes, signals notify the framework about that change.
    The framework is responsible for triggering change detection and updating any
    signal consumers. A signal value can change either directly using **writable**
    signals or indirectly using read-only or **computed** signals.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn how writable signals work.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A writable signal is indicated by the `signal` type from the `@angular/core`
    npm package.
  prefs: []
  type: TYPE_NORMAL
- en: You will need the source code of the Angular application we created in *Chapter
    6* , *Reactive Patterns in Angular* , to follow along with the rest of the chapter.
    After you get the code, we suggest you remove the `key-logger` folder for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started and learn how we can write a value in a signal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.ts` file and import the `signal` artifact from the
    `@angular/core` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the following property in the `AppComponent` class as a `signal` and
    initialize it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `timestamp` variable in the `setTitle` property with the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we use the `set` method to write a new value in the
    signal. The method notifies the Angular framework that the value has changed,
    and it must run the change detection mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `title` property to use the value of the `currentDate` signal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we call the `currentDate` getter method to read the
    value of the signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signals are a great choice in cases where the speed and performance of an application
    matters, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: A dashboard page with widgets and live data that must be updated regularly,
    such as a stock exchange application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A component that needs to display properties from a large or complex object,
    such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this case, we can extract the object properties we want in a signal without
    involving the whole object in the change detection cycle, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar method of signals that also triggers change detection is the `update`
    method. It is used when we want to set a new value on a signal based on its current
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will get the value of the `currentDate` signal in the
    `d` variable and use it to return a new `Date` object.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will explore how computed signals behave in an
    Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: Computed signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A computed or read-only signal depends on other signals, writable or computed.
    The value of a computed signal cannot change directly using the `set` or the `update`
    method, it can only change indirectly when the value of any of the other signals
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.ts` file and import the `computed` and `Signal` artifacts
    from the `@angular/core` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the type of the `title` component property to `Signal` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Signal` type indicates that the signal is a computed one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `title` assignment from the `setTitle` method and add it inside
    the `constructor` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we use the `computed` function to set the value of
    the `title` signal. The value of the `title` signal depends on the `currentDate`
    signal. It is updated every 2 seconds when the value of the `currentDate` signal
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.html` file and modify the `<header>` HTML element as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application using `ng serve` and verify that the title is updated correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Computed signals have great performance when it comes to more complicated calculations
    than the preceding one due to the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The computed function executes when the signal value is first read on the template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new signal value is calculated only when the derived signals change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computed signals use a cache mechanism to memoize values and return them without
    recalculating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although signals are a modern reactive approach for Angular, they are relatively
    new to the Angular ecosystem compared to RxJS. In the following section, we will
    learn how they can cooperate with RxJS in an Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: Cooperating with RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Signals and RxJS empower Angular applications with reactive capabilities. These
    libraries can complement each other to provide reactivity while using the benefits
    of the Angular framework. Signals was not built to replace RxJS but to provide
    an alternate reactive approach to developers with the following additional characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fine-grained reactivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imperative programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved usage of the change detection mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there are core parts in the Angular framework that still use RxJS and
    observables, such as the HTTP client and the router. Additionally, many developers
    prefer the declarative approach that the RxJS library provides out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the Angular team is currently investigating and experimenting
    to make RxJS *optional* for Angular applications in the foreseeable future. They
    are also working to convert built-in APIs such as the HTTP client and router into
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular Signals provides a built-in API to cooperate with RxJS and observables.
    The signals API provides a function that can convert an observable into a signal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.ts` file and import the `inject` and `toSignal`
    artifacts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `@angular/core/rxjs-interop` npm package includes all the utility methods
    for handling signal and observable cooperation. The `toSignal` function can convert
    an observable into a signal.
  prefs: []
  type: TYPE_NORMAL
- en: The `rxjs-interop` package also contains utility methods for converting a signal
    to an observable. You can read more in *Reactive Patterns with RxJS and Angular
    Signals* by Lamis Chebbi (Packt Publishing).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following signal in the `ProductListComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We pass two parameters in the `toSignal` function: the observable we want to
    convert and an initial value optionally. In this case, we pass the `getProducts`
    method of the `ProductService` class that returns an observable, and we also set
    the initial value of the signal to an empty array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.html` file and modify its contents as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding template, we removed the top `@if` block and converted the
    `products` property into a signal. We do not need the `async` pipe because signals
    subscribe automatically to an observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further clean up our component, we can remove any code that is related to
    the `async` pipe and observables since it is no longer needed. The resulting `product-list.component.ts`
    file should be the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application using `ng serve` and observe that the application output
    displays the product list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding snippet looks much simpler. Angular signals improve the developer
    experience and ergonomics in addition to the performance of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored signals, which is a new reactive pattern in Angular
    that is used for managing application state. We learned their rationale and how
    they compare with Zone.js. We explored examples of how to read and write values
    into signals. We also learned how to create computed signals that depend on values
    from other signals.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use the Angular HTTP client and consume
    data from a remote endpoint.
  prefs: []
  type: TYPE_NORMAL
