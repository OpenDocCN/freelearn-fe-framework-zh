["```js\nexport async function GET() {\n```", "```js\n    $ cp -R ch17 ch18\n    ```", "```js\n    import { initDatabase } from '@/db/init'\n    import { listAllPosts } from '@/data/posts'\n    ```", "```js\n    export async function GET() {\n    ```", "```js\n      await initDatabase()\n      const posts = await listAllPosts()\n    ```", "```js\n      return Response.json({ posts })\n    }\n    ```", "```js\n    $ npm run dev\n    ```", "```js\n      return Response.json({ posts, currentTime: Date.now() })\n    ```", "```js\n    $ npm run build\n    $ npm start\n    ```", "```js\n    export const dynamic = 'force-dynamic'\n    ```", "```js\n    $ npm run build\n    $ npm start\n    ```", "```js\n    import { unstable_cache as cache } from 'next/cache'\n    ```", "```js\n    export const listAllPosts = cache(\n      async function listAllPosts() {\n        return await Post.find({})\n          .sort({ createdAt: 'descending' })\n          .populate('author', 'username')\n          .lean()\n      },\n      ['posts', 'listAllPosts'],\n      { tags: ['posts'] },\n    posts) and the function name (listAllPosts) to uniquely identify the function in our data layer. Additionally, we added a posts tag, which we are going to use later to revalidate the cache when new posts are created.\n    ```", "```js\n    export const getPostById = cache(\n      async function getPostById(postId) {\n        return await Post.findById(postId).populate('author', 'username').lean()\n      },\n      ['posts', 'getPostById'],\n    )\n    ```", "```js\n    Post.propTypes = {\n      _id: PropTypes.string.isRequired,\n    ```", "```js\n    import { unstable_cache as cache } from 'next/cache'\n    ```", "```js\n    export const getUserInfoById = cache(\n      async function getUserInfoById(userId) {\n        const user = await User.findById(userId)\n        if (!user) throw new Error('user not found!')\n        return { username: user.username }\n      },\n      ['users', 'getUserInfoById'],\n    )\n    ```", "```js\n    $ npm run build\n    $ npm start\n    ```", "```js\n    $ npm run dev\n    ```", "```js\n    import { revalidateTag } from 'next/cache'\n    ```", "```js\n      async function createPostAction(formData) {\n        'use server'\n        const userId = getUserIdByToken(token?.value)\n        await initDatabase()\n        const post = await createPost(userId, {\n          title: formData.get('title'),\n          contents: formData.get('contents'),\n        })\n        revalidateTag('posts')\n        redirect(`/posts/${post._id}`)\n      }\n    ```", "```js\n    export default async function TimePage() {\n    ```", "```js\n      const timeRequest = await fetch('https://worldtimeapi.org/api/timezone/UTC')\n      const time = await timeRequest.json()\n    ```", "```js\n      return <div>Current timestamp: {time?.datetime}</div>\n    }\n    ```", "```js\n    import { revalidatePath } from 'next/cache'\n    ```", "```js\n    export async function GET() {\n      revalidatePath('/time')\n      return Response.json({ ok: true })\n    }\n    export const dynamic = 'force-dynamic'\n    ```", "```js\n      const timeRequest = await fetch('https://worldtimeapi.org/api/timezone/UTC', {\n        next: { revalidate: 10 },\n      })\n    ```", "```js\nfetch('<URL>', export const dynamic = 'force-dynamic' to opt out of the full route cache (the data may still be cached though!).\nNow that we’ve learned how to use the cache in Next.js to optimize our app, let’s learn about SEO with Next.js.\nSEO with Next.js\nIn [*Chapter 8*](B19385_08.xhtml#_idTextAnchor162), we learned about SEO in full-stack apps. Next.js provides functionality for SEO out of the box. Let’s explore this functionality now, starting with adding dynamic titles and meta tags.\nAdding dynamic titles and meta tags\nIn Next.js, we can statically define metadata by exporting a metadata object from a `page.js` file, or we can dynamically define metadata by exporting a `generateMetadata` function. We have already added static metadata to the root layout, as can be seen in `src/app/layout.js`:\n\n```", "```js\n\n Now, let’s dynamically generate metadata for our post pages:\n\n1.  Edit **src/app/posts/[id]/page.js** and define the following function outside of the page component:\n\n    ```", "```js\n\n     2.  Fetch the post; if it does not exist, call **notFound()**:\n\n    ```", "```js\n\n     3.  Otherwise, return a title and description:\n\n    ```", "```js\n\nThat’s all there is to it! Next.js will set the title and meta tags appropriately for us.\nNote\nMetadata is inherited from layouts. So, it is possible to define defaults for metadata in the layout and then selectively override it for specific pages.\nNow that we have successfully added a dynamic title and meta tags, let’s continue by creating a `robots.txt` file so that search engines know they are allowed to index our blog app.\nCreating a robots.txt file\nNext.js has two ways of creating a `robots.txt` file:\n\n*   Creating a static **robots.txt** file in **src/app/robots.txt**\n*   Creating a dynamic **robots.txt** file by creating a **src/app/robots.js** script, which returns a special object that is turned into a **robots.txt** file by Next.js\n\nNote\nIf you need a refresher on what a **robots.txt** file is and how search engines work, please check out [*Chapter 8*](B19385_08.xhtml#_idTextAnchor162).\nWe are only going to create a static `robots.txt` file as there is no need for a dynamic file for now. Follow these steps to get started:\n\n1.  Create a new **src/app/robots.txt** file.\n2.  Edit **src/app/robots.txt** and add the following contents to allow all crawlers to index all pages:\n\n    ```", "```js\n\nNow that we have created a `robots.txt` file, let’s create meaningful URLs.\nCreating meaningful URLs (slugs)\nNow, we are going to create slugs for our blog posts, similar to what we did in [*Chapter 8*](B19385_08.xhtml#_idTextAnchor162). Let’s get started:\n\n1.  Rename the **src/app/posts/[id]/** folder to **src/app/posts/[...path]/**. This turns it into a catch-all route, matching everything that comes after **/posts**.\n2.  Edit **src/app/posts/[...path]/page.js** and adjust the code to get the first part of the URL (the **id** value) from the **path** param:\n\n    ```", "```js\n\n     3.  Also, adjust the code for the **generateMetadata** function:\n\n    ```", "```js\n\n    With that, our router has been set up to accept an optional slug in the URL.\n\n     4.  Install the **slug** npm package:\n\n    ```", "```js\n\n     5.  Edit **src/components/Post.jsx** and import the **slug** function:\n\n    ```", "```js\n\n     6.  Adjust the link to the blog post by adding the slug, as follows:\n\n    ```", "```js\n\n     7.  Open a link from the post list; you will see that the URL now contains the slug.\n\nNow that we’ve made sure our URLs are meaningful, we’ll wrap up this section by creating a sitemap for our blog app.\nCreating a sitemap\nAs we learned in [*Chapter 8*](B19385_08.xhtml#_idTextAnchor162), a sitemap contains a list of URLs that are part of an app so that crawlers can easily detect new content and crawl the app more efficiently, making sure that all content on our blog is found.\nFollow these steps to set up a dynamic sitemap in Next.js:\n\n1.  First, define a **BASE_URL** for our app as an environment variable. Edit **.env** and add the following line:\n\n    ```", "```js\n\n     2.  Create a new **src/app/sitemap.js** file, where we import the **initDatabase**, **listAllPosts**, and **slug** functions:\n\n    ```", "```js\n\n     3.  Define and export a new asynchronous function that will generate the sitemap:\n\n    ```", "```js\n\n     4.  First, we list all the static pages:\n\n    ```", "```js\n\n     5.  Then, we get all the posts from the database:\n\n    ```", "```js\n\n     6.  Generate an entry for each post by building the URL and adding a **lastModified** timestamp:\n\n    ```", "```js\n\n     7.  Finally, return **staticPages** and **postsPages** in an array:\n\n    ```", "```js\n\n     8.  Go to **http://localhost:3000/sitemap.xml** in your browser; you will see that Next.js generated the XML for us from the array of objects!\n\nNote\nIt is best practice to add the sitemap to the **robots.txt** file, but we would need to turn it into a dynamic **robots.js** file so that we can provide the full URL to the sitemap (using the **BASE_URL** environment variable). Doing this is left as an exercise for you.\nNow that we’ve optimized our blog app for search engines, let’s learn about optimized image and font loading in Next.js.\nOptimized image and font loading in Next.js\nLoading images and fonts in an optimized way can be tedious, but Next.js makes it very simple by providing the `Font` and `Image` components.\nThe Font component\nOften, you’ll want to use a specific font for your page to make it unique and stand out. If your font is on Google Fonts, you can have Next.js automatically self-host it for you. No requests will be sent to Google by your browser if you use this feature. Additionally, the fonts will be loaded optimally with zero layout shift.\nLet’s find out how Google Fonts can be self-hosted with Next.js:\n\n1.  We are going to load the **Inter** font by importing it from **next/font/google**. Edit **src/app/layout.js** and add the following import:\n\n    ```", "```js\n\n     2.  Now, load the font, as follows:\n\n    ```", "```js\n\n    `Inter` is a variable font, so we don’t need to specify the weight that we want to load. If the font isn’t a variable font, don’t forget to specify the weight. The `display: 'swap'` property means that the font gets an extremely small block period to be loaded. If it does not load by then, a fallback font will be used. Once the font has been loaded, it will be swapped in.\n\n     3.  Specify the font in the **<html>** tag, as follows:\n\n    ```", "```js\n\n     4.  Go to **http://localhost:3000/** in your browser; you will see that our blog app is now using the **Inter** font! See the following screenshot for reference:\n\n![Figure 18.3 – Our blog app rendered with the Inter font](img/B19385_18_3.jpg)\n\nFigure 18.3 – Our blog app rendered with the Inter font\nAs you can see, it’s very simple to use self-hosted Google Fonts with Next.js!\nNote\nIf you want to use a font that is not on Google Fonts, use the **localFont** function from **next/font/local**. This allows you to load a font from a file in your project. For more information on the **Font** component, check out the Next.js docs: [https://nextjs.org/docs/app/building-your-application/optimizing/fonts](https://nextjs.org/docs/app/building-your-application/optimizing/fonts).\nNext, we are going to learn about the `Image` component, which allows us to easily load images in an optimized way.\nThe Image component\nImages make up a large portion of the download size of your web application, and can thus have a big impact on the `Image` component, which extends the `<img>` element by doing the following:\n\n*   Automatically serving resized images for each device and resolution\n*   Automatically preventing layout shift when images are loading\n*   Only loading images when they enter the viewport (“lazy loading”), with optional blurred placeholder images\n*   Offering on-demand resizing for images, even if they are stored remotely\n\nUsing the `Image` component is simple – just import it and load your images as you would with the `<img>` element. Let’s try it out now:\n\n1.  Get an image to be used as a logo for your blog. Any image can be used, but make sure it is a non-vector format (such as PNG). For vector formats, resizing is not necessary, so you will not see any effect.\n2.  Save the image as a **src/app/logo.png** file.\n3.  Edit **src/app/layout.js** and import the **Image** component and the logo:\n\n    ```", "```js\n\n     4.  Above the **<nav>** element, render the **<Image>** component, as follows:\n\n    ```", "```js\n\n    It is important to specify the width and height of the image so that Next.js can infer the correct aspect ratio and prevent layout shift when the image loads in.\n\n     5.  Go to **http://localhost:3000/** in your browser; you will see the logo being displayed properly! See the following screenshot for reference:\n\n![Figure 18.4 – Using the Image component to display a logo for our blog](img/B19385_18_4.jpg)\n\nFigure 18.4 – Using the Image component to display a logo for our blog\nIf you inspect the image in the browser, you will see that it has the `srcset` property with different sizes provided so that the browser can choose which one to load depending on the screen resolution.\nNote\nIn this example, we loaded a local image, but the **Image** component also supports loading images from a remote server, and it will still resize them properly! To use external URLs, allow the remote server by using the **images.remotePatterns** setting in the **next.config.js** file, then simply pass a URL instead of a local file to the **Image** component.\nSummary\nIn this chapter, we learned how to define API routes in Next.js. Then, we learned about caching, how to revalidate the cache, and how to opt out of the cache. Next, we learned about SEO in Next.js by adding metadata to our pages, creating meaningful URLs, defining a `robots.txt` file, and generating a sitemap. Finally, we learned about the `Font` and `Image` components, which allowed us to load fonts and images easily and optimally in our app.\nThere are still many more features that Next.js offers that we have not covered yet in this book, such as the following:\n\n*   **Internationalization**: Allows us to configure the process of routing and rendering content for multiple languages\n*   **Middleware**: Allows us to run code before requests are completed, similar to how middleware works in Express\n*   **Serverless Node.js and Edge runtimes**: Allow us to scale our apps even more by not running a full Node.js server\n*   **Advanced routing**: Allows us to model complex routing scenarios, such as parallel routes (displaying two pages at once)\n\nIn the next chapter, [*Chapter 19*](B19385_19.xhtml#_idTextAnchor343), *Deploying a Next.js App*, we are going to learn how to deploy a Next.js app using Vercel and a custom deployment setup.\n\n```"]