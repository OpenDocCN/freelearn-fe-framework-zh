- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Monorepos versus Polyrepos for Microfrontends
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微前端的单仓库与多仓库对比
- en: Since the time engineers at Google and Facebook mentioned they have a single
    monorepo in their organization, the developer community – especially the frontend
    community – has been actively participating in debates and discussions on monorepos
    versus polyrepos.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自从谷歌和Facebook的工程师提到他们在组织中有一个单仓库以来，开发者社区——尤其是前端社区——一直在积极参与关于单仓库与多仓库的辩论和讨论。
- en: We are seeing more and more teams leaning more toward monorepos for maintaining
    their frontend code. However, which should you choose between a polyrepo and a
    monorepo based on what the community thinks?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到越来越多的团队倾向于使用单仓库来维护他们的前端代码。然而，根据社区的看法，您应该在多仓库和单仓库之间做出选择？
- en: As we will learn in this chapter, the decision to go with a monorepo or a polyrepo
    is far deeper than just fancy technology or hype. We will see that, in fact, it
    is more to do with teams, and the culture we would like to establish within teams.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章中学习的那样，选择单仓库或多仓库的决定远不止是花哨的技术或炒作。我们将看到，实际上，这更多与团队以及我们希望在团队内部建立的文化有关。
- en: In this chapter, we start by understanding what polyrepos and monorepos are.
    We will see how each of them impacts how teams work and collaborate, then we will
    see why monorepos are more suited for microfrontends. Finally, we will set up
    our monorepo base application with the necessary permissions to work in teams.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先了解多仓库和单仓库是什么。我们将看到它们如何影响团队的工作和协作，然后我们将看到为什么单仓库更适合微前端。最后，我们将设置我们的单仓库基础应用程序，并分配必要的权限以便团队工作。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Repo types and their nuances
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库类型及其细微差别
- en: Why Monorepos for Microfrontends?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么单仓库适合微前端？
- en: Setting up our Monorepo with Team permissions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的单仓库并分配团队权限
- en: By the end of this chapter, you will have a deep understanding of the differences
    between and implications of choosing a polyrepo versus a monorepo.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对选择多仓库与单仓库之间的差异及其影响有深入的理解。
- en: We will also have our monorepo set up and ready for vertically sliced domain-driven
    teams to get started with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将设置好单仓库并使其准备好，以便垂直切片的领域驱动型团队可以开始使用它。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As we go through the code examples in this chapter, we will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们浏览本章中的代码示例时，我们需要以下内容：
- en: A PC, Mac, or Linux desktop or laptop with at least 8 GB of RAM (16 GB preferred)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少8 GB RAM的PC、Mac或Linux台式机或笔记本电脑（16 GB更佳）
- en: An Intel chipset i5+, AMD, or Mac M1 + chipset
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英特尔芯片组i5+、AMD或Mac M1+芯片组
- en: At least 256 GB of free hard disk storage
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少256 GB的空闲硬盘存储空间
- en: 'You will also need the following software installed on your computer:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在您的计算机上安装以下软件：
- en: Node.js version 16+ (use **nvm** to manage different versions of Node.js if
    you have to)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js版本16+（如果需要管理不同版本的Node.js，请使用**nvm**）
- en: 'Terminal: iTerm2 with Oh My Zsh (you will thank me later)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端：iTerm2与Oh My Zsh（您会感谢我的）
- en: 'IDE: We strongly recommend VS Code as we will be making use of some of the
    plugins that come with VS Code for an improved developer experience'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成开发环境（IDE）：我们强烈推荐VS Code，因为我们将会使用一些VS Code附带的插件来提升开发者体验
- en: npm, yarn, or pnpm – we recommend pnpm because it’s fast and storage-efficient
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm、yarn或pnpm——我们推荐pnpm，因为它速度快且存储效率高
- en: 'Browser: Chrome, Microsoft Edge, Brave, or Firefox (I use Firefox)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器：Chrome、Microsoft Edge、Brave或Firefox（我使用Firefox）
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Building-Micro-Frontends-with-React](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React)
- en: We also assume you have a basic working knowledge of Git, such as branching,
    committing code, and raising pull requests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设您对Git有基本的操作知识，例如分支、提交代码和发起拉取请求。
- en: Repo types and their nuances
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库类型及其细微差别
- en: In this section, we will learn exactly what a polyrepo and a monorepo are.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将确切了解多仓库和单仓库是什么。
- en: As most of you will already know by now, repo is short for repository and refers
    to storage for all the files for your project. It also keeps track of all the
    changes to those files. This means, at any time, we can easily go and see what
    lines of code were changed, by whom, and when. In most cases, we use Git for version
    control. Some teams may use other systems, such as Mercurial or some other distributed
    version control system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你们大多数人现在可能已经知道的那样，repo是repository的简称，指的是存储你项目所有文件的地方。它还会跟踪这些文件的所有更改。这意味着，在任何时候，我们都可以轻松地查看哪些代码行被更改了，由谁更改，以及何时更改。在大多数情况下，我们使用Git进行版本控制。有些团队可能使用其他系统，例如Mercurial或一些其他分布式版本控制系统。
- en: There are two strategies that teams most commonly use for managing repos. They
    are commonly known as monorepos and polyrepos. There are other patterns, such
    as Git submodules or Git subtrees, but these are beyond the scope of this chapter.
    We will focus on monorepos and polyrepos.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 团队最常用的两种管理仓库的策略是monorepos和polyrepos。还有其他模式，如Git子模块或Git子树，但这些超出了本章的范围。我们将专注于monorepos和polyrepos。
- en: Monorepos
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Monorepos
- en: 'As the name suggests, mono means single and so the source code is managed in
    a single Git repo. This means that all team members work on a common single repository,
    and in most cases, the monorepo will consist of multiple applications. The following
    figure shows a monorepo setup:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，mono意味着单一，因此源代码是在单个Git repo中管理的。这意味着所有团队成员都在一个共同的单一仓库上工作，在大多数情况下，monorepo将包含多个应用程序。以下图显示了monorepo的设置：
- en: '![Figure 3.1 – Monorepo setup](img/Figure_3.01_B18987.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – Monorepo设置](img/Figure_3.01_B18987.jpg)'
- en: Figure 3.1 – Monorepo setup
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Monorepo设置
- en: As you can see in the preceding diagram, we have a single repo that consists
    of multiple apps within it. All the apps use a shared set of tools for CI and
    CD and linting and a shared component library that is usually built from source
    each time an application is built. You will also notice that all the teams have
    access to all the items within the repo.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的图中所见，我们有一个包含多个应用程序的单个仓库。所有应用程序都使用共享的工具集进行CI/CD、代码审查和构建共享组件库，该库通常在构建应用程序时从源代码构建。您还会注意到，所有团队都可以访问仓库中的所有项目。
- en: Polyrepos
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Polyrepos
- en: Polyrepos are where each app has its own repository. Teams generally work on
    multiple repos, switching repos as they work on different apps.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Polyrepos是指每个应用程序都有自己的仓库。团队通常在多个仓库上工作，当他们处理不同的应用程序时，会切换仓库。
- en: 'Most teams prefer going down the polyrepos route as they are a lot easier to
    manage and each team can define its own branching strategies and repo permissions.
    The following figure shows a polyrepo setup:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数团队更喜欢选择polyrepos路线，因为它们更容易管理，每个团队都可以定义自己的分支策略和仓库权限。以下图显示了polyrepo的设置：
- en: '![Figure 3.2 – Polyrepo setup](img/Figure_3.02_B18987.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – Polyrepo设置](img/Figure_3.02_B18987.jpg)'
- en: Figure 3.2 – Polyrepo setup
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – Polyrepo设置
- en: In the polyrepo setup, you will notice multiple repositories, denoted by the
    dotted-line boxes. Each app generally has its own repository, and we have another
    repository for shared components and libraries. The shared components need to
    first be published to an artifact repository such as `npm` or Nexus before they
    can be consumed by the other repositories. We also notice that each repository
    has its own team, and generally, teams don’t have access to another team’s repository
    (unless you are an admin or a senior developer that looks after multiple applications).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在polyrepo设置中，您会注意到多个仓库，由虚线框表示。每个应用程序通常都有自己的仓库，我们还有一个用于共享组件和库的仓库。共享组件需要首先发布到如npm或Nexus这样的工件仓库，然后其他仓库才能使用它们。我们还注意到，每个仓库都有自己的团队，通常，团队没有访问其他团队的仓库（除非你是管理员或负责多个应用程序的高级开发者）。
- en: Differences between Polyrepos and Monorepos
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Polyrepos和Monorepos之间的区别
- en: As mentioned earlier, choosing between a polyrepo or a monorepo is not just
    about how code is organized but goes a lot deeper and has a huge impact on how
    teams collaborate, the culture within the teams, how your build tools are set
    up, and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，选择polyrepo或monorepo不仅仅关乎代码的组织方式，它的影响要深远得多，对团队的协作方式、团队文化、构建工具的设置等方面都有巨大的影响。
- en: In this section, let us go a bit deeper into understanding the nuances of monorepos
    and polyrepos.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们更深入地了解monorepos和polyrepos的细微差别。
- en: Team Collaboration
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 团队协作
- en: With polyrepos, teams create their own individual repositories and decide and
    define their own rules and guidelines on how the code is maintained. Obviously,
    this is the easiest and fastest way to get started, and teams become productive
    quite quickly. However, this pattern also has a few drawbacks. With polyrepos,
    teams tend to become more siloed as each team is just focused on its repo and
    doesn’t really have a lot of visibility of what other teams are doing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在多仓库中，团队创建自己的独立仓库，并决定和定义自己的规则和指南来维护代码。显然，这是开始的最简单和最快的方式，团队可以很快地变得高效。然而，这种模式也有一些缺点。在多仓库中，团队往往会变得更加封闭，因为每个团队只关注自己的仓库，并没有真正看到其他团队在做什么。
- en: Another drawback with polyrepos is the effort required to set up and maintain
    all the build pipelines, and precommit hooks and so on are duplicated for each
    repo.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 多仓库的另一个缺点是设置和维护所有构建管道、预提交钩子等所需的工作量，并且每个仓库都会重复。
- en: With monorepos, teams are forced to collaborate as they need to agree on a common
    way for how the code will be maintained. In a monorepo setup, since everybody
    is able to see everybody else’s code, the chances of them working in silos are
    greatly reduced. Teams are naturally encouraged to collaborate by providing feedback
    on code and it also provides an opportunity for teams to replicate good code patterns
    that other teams may have implemented.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在单仓库（monorepo）中，团队被迫进行协作，因为他们需要就代码维护的通用方式达成一致。在单仓库设置中，由于每个人都能看到其他人的代码，他们各自为政的可能性大大降低。团队通过提供代码反馈自然地被鼓励进行协作，这也为团队复制其他团队可能已实施的优秀代码模式提供了机会。
- en: Build tools and Quality gates
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建工具和质量门
- en: With polyrepos, each team needs to implement its own build systems and quality
    gates such as precommit hooks. This results in duplication of effort and leads
    to higher maintenance costs. It also boils down to the engineering maturity of
    each team. Teams with strong leads will obviously have optimized build tools,
    while junior teams will struggle with not-very-optimized build tools and quality
    gates and will need intervention from other teams.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多仓库（polyrepos）时，每个团队都需要实现自己的构建系统和质量门，例如预提交钩子。这导致了工作重复，并导致维护成本增加。这也反映出了每个团队的工程成熟度。有强大领导的团队显然会有优化的构建工具，而初级团队可能会在不太优化的构建工具和质量门上遇到困难，并需要其他团队的帮助。
- en: With a monorepo, all the build tools and quality gates can be centrally managed,
    reducing duplication of effort. In most cases, this is usually set up by the experts
    within one of the teams. This allows leveraging strengths and skillsets across
    all teams and teams immediately benefit from the knowledge within the wider organization.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在单仓库中，所有构建工具和质量门都可以集中管理，从而减少工作重复。在大多数情况下，这通常由一个团队中的专家设置。这允许利用所有团队的优势和技能集，并且团队可以立即从整个组织内的知识中受益。
- en: Code Ownership
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码所有权
- en: In a polyrepo, the permissions are set at a repo level in terms of who has permission
    to view the code in a repo or make changes to it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在多仓库中，权限是在仓库级别设置的，即谁有权限查看仓库中的代码或对其进行更改。
- en: In a monorepo, all team members have access to view and edit all the files in
    the code. The permissions and control in a monorepo are maintained via a `CODEOWNERS`
    file later in this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在单仓库中，所有团队成员都有权查看和编辑代码中的所有文件。在本章后面的内容中，单仓库中的权限和控制通过`CODEOWNERS`文件来维护。
- en: The mental model with monorepos is everybody in the team can make changes to
    a file and raise a request to merge their changes; however, only the rightful
    owner defined in the `CODEOWNERS` file has the permission to accept or reject
    the changes being made by a team member.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 单仓库的心理模型是团队中的每个人都可以更改文件并提交合并请求；然而，只有`CODEOWNERS`文件中定义的合法所有者才有权接受或拒绝团队成员所做的更改。
- en: Flexibility
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 灵活性
- en: As may be obvious by now, polyrepos provide the highest level of flexibility,
    in terms of how the code within each team is managed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如此明显的，多仓库在如何管理每个团队内部的代码方面提供了最高级别的灵活性。
- en: In a monorepo, this flexibility is intentionally restricted to ensure that all
    team members benefit from the best coding practices and tooling setup that the
    team can offer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在单仓库中，这种灵活性有意被限制，以确保所有团队成员都能从团队可以提供的最佳编码实践和工具设置中受益。
- en: Refactoring Code
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码重构
- en: With polyrepos, refactoring code across multiple repos can be time-consuming
    as one will need to check out all the different repos and individually raise a
    merge request or pull request for each repository.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多仓库时，跨多个仓库重构代码可能会很耗时，因为需要检出所有不同的仓库，并为每个仓库分别提交合并请求或拉取请求。
- en: With monorepos, doing such large-scale refactoring is quite easy by making atomic
    commits where a single merge request can contain the necessary changes for all
    the apps.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单仓库，通过创建原子提交，可以轻松地进行大规模的重构，其中单个合并请求可以包含所有应用程序所需的必要更改。
- en: Ownership of Upgrades
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级所有权
- en: When the time comes to upgrade libraries or tooling is when the most interesting
    differences between a polyrepo and monorepo setup come into play.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要升级库或工具时，多仓库和单仓库设置之间最有趣的不同之处就会显现出来。
- en: In a polyrepo, the onus of upgrading shared libraries or tools lies with each
    of the teams, and the teams can choose to defer an upgrade if they have other
    priorities. This can be both good and bad. While it allows teams to upgrade at
    their own pace, there is always a risk that some teams may get far behind in upgrading
    their libraries. This becomes a serious issue if an outdated library has a serious
    security vulnerability, and teams have ignored upgrading it. Since each team is
    responsible for upgrading libraries, they are also responsible for fixing breaking
    changes, and this is often the primary trigger to defer upgrades.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在多仓库中，升级共享库或工具的责任落在每个团队身上，并且如果团队有其他优先事项，可以选择推迟升级。这既有好的一面也有不好的一面。虽然这允许团队根据自己的节奏进行升级，但总有一些团队可能会在升级库方面落后很远。如果过时的库存在严重的安全漏洞，而团队忽略了升级它，这就会成为一个严重的问题。由于每个团队负责升级库，因此他们也有责任修复破坏性变更，而这通常是推迟升级的主要触发因素。
- en: With monorepos, if a shared library or tool is being upgraded, it is easy to
    make atomic commits across all the apps within the monorepo, which means all teams
    directly get the benefit of the latest versions. What’s interesting with monorepos
    (*that have the right build tools and quality gates in place*) is the ownership
    of fixing any breaking changes lies with the library owner or the person doing
    the upgrade, as the build pipelines will not allow you to merge the code unless
    it passes all the build steps and quality gates.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单仓库，如果正在升级共享库或工具，则可以轻松地在单仓库内的所有应用程序中进行原子提交，这意味着所有团队都可以直接获得最新版本的益处。有趣的是，对于单仓库（*拥有适当的构建工具和质量门控机制*）来说，修复任何破坏性变更的责任在于库所有者或进行升级的人员，因为构建管道不会允许你合并代码，除非它通过了所有构建步骤和质量门控。
- en: Code base Size
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码库大小
- en: With polyrepos, your code base gradually increases over time; however, with
    a monorepo, you are dealing with a large code base right from day one, and the
    monorepo tends to grow exponentially as the application grows.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多仓库时，代码库会随着时间的推移逐渐增加；然而，使用单仓库，你从第一天开始就要处理大型代码库，并且随着应用程序的增长，单仓库往往会呈指数级增长。
- en: A large code base has a negative impact on productivity. Not only does checking
    out code take time but also, all the other activities, such as running build steps
    or running unit tests, take longer both on the local developer PC and also on
    the CI and CD pipelines.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大型代码库对生产力有负面影响。不仅检出代码需要时间，而且所有其他活动，如运行构建步骤或运行单元测试，在本地开发者的PC上以及CI/CD管道上都需要更长的时间。
- en: Unless one makes use of features such as caching and building and testing only
    what has changed, monorepos can become very slow to work with.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除非使用缓存和仅构建和测试已更改的内容等特性，否则单仓库可能会变得非常慢。
- en: As we reach the end of this section, we have learned about the differences between
    polyrepos and monorepos and have gone into the details of how they differ when
    it comes to things such as code refactoring and ownership, tooling team culture,
    collaboration, and so on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达本节的结尾时，我们已经了解了多仓库和单仓库之间的区别，并深入探讨了它们在代码重构、所有权、工具团队文化、协作等方面如何不同。
- en: In the next section, we will see which of the two is more suited for building
    microfrontends.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到哪一种更适合构建微前端。
- en: Choosing Monorepos for Microfrontends
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为微前端选择单仓库
- en: After going through the pros and cons of polyrepos and monorepos, which one
    would you choose to use for your project? Well, you can choose either one of them
    and build microfrontends. Like all things in programming, there are trade-offs
    for every decision you make, and you need to be clear about what trade-offs you
    are comfortable with.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在经过多仓库和单仓库的优缺点分析后，你会选择哪一个用于你的项目？嗯，你可以选择其中的任何一个来构建微前端。就像编程中的所有事情一样，每个决策都有权衡，你需要清楚你愿意接受哪些权衡。
- en: 'For the rest of this book, we will choose to go with the monorepo setup for
    the following reasons:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将选择使用单仓库设置，以下是一些原因：
- en: With monorepos, team members are naturally encouraged to collaborate by learning
    and reviewing each other’s code.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单仓库，团队成员自然会通过学习和审查彼此的代码来鼓励协作。
- en: It allows all teams to easily use a shared library of components. This ensures
    that each micro-app built as part of the overall app has the same look and feel
    and the overall user experience is consistent as the user interacts with the different
    micro-apps.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许所有团队轻松使用共享的组件库。这确保了作为整体应用一部分构建的每个微应用都具有相同的视觉和感觉，并且整体用户体验在用户与不同微应用交互时保持一致。
- en: It also makes it easy for central platform teams, such as the DevOps team or
    admin team, to easily refactor code across all the micro-apps.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还使得中央平台团队，如DevOps团队或管理员团队，能够轻松地对所有微应用进行代码重构。
- en: Some of the drawbacks of monorepos, such as the slower execution of quality
    gates on pipelines, can be overcome by making use of caching techniques, many
    of which are the default with most monorepo tools.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单仓库的一些缺点，如管道上质量门执行速度较慢，可以通过使用缓存技术来克服，其中许多是大多数单仓库工具的默认设置。
- en: As your overall app grows, and new features get added, new micro-apps will keep
    getting added to your app. Now, if you have a polyrepo setup with each micro-app
    in its own repo, it will become quite difficult to manage the large number of
    repos.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着整体应用的成长和新功能的添加，新的微应用将不断添加到你的应用中。现在，如果你有一个每个微应用都有自己的仓库的多仓库设置，管理大量仓库将变得相当困难。
- en: In a microfrontend setup, most of the time, you would work on your individual
    micro-app; however, at times you would need to run all the micro-apps together
    to test out your app locally. This would be quite difficult to achieve if your
    micro apps are set up in a polyrepo.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微前端设置中，大多数时候，你会专注于你的单个微应用；然而，有时你需要一起运行所有微应用来在本地测试你的应用。如果你的微应用是在多仓库中设置的，这将相当难以实现。
- en: In the following section, we will have a look at some of the popular open source
    monorepo tools out there, which will help you decide which would be the most suitable
    for you.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些流行的开源单仓库工具，这将帮助你决定哪一个最适合你。
- en: Popular Monorepo tools
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流行的单仓库工具
- en: This section covers some of the most popular open source monorepo tools that
    you can choose when building your microfrontends.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了在构建微前端时可以选择的一些最受欢迎的开源单仓库工具。
- en: Lerna
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lerna
- en: Lerna was probably the first and most widely used monorepo tool. It follows
    what is called the packages-based monorepo style. What this basically means is
    each app sits under the `packages` folder and has its own `package.json` file,
    so every app has its own set of dependencies and there is nothing common between
    these apps.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Lerna可能是第一个也是最广泛使用的单仓库工具。它遵循所谓的基于包的单仓库风格。这基本上意味着每个应用都位于`packages`文件夹下，并有自己的`package.json`文件，因此每个应用都有自己的依赖项集合，这些应用之间没有共同点。
- en: Lerna was recently adopted by the nrwl team who originally built the Nx monorepo.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Lerna最近被nrwl团队采用，该团队最初构建了Nx单仓库。
- en: Nx
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nx
- en: Nx was the next monorepo to become very popular and is probably the most mature
    and feature-rich of all the monorepo tools out there. Nx started off as an integrated
    monorepo. What that means is, in Nx, there is a single `package.json` file on
    the root and all apps use the same version of the packages. Nx has now evolved
    to also support the package-based style of monorepos.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Nx是下一个变得非常流行的单仓库，可能是所有单仓库工具中最成熟和功能丰富的。Nx最初是一个集成单仓库。这意味着在Nx中，根目录下有一个单一的`package.json`文件，所有应用都使用相同版本的包。Nx现在已经发展到也支持基于包的单仓库风格。
- en: It comes with advanced local and distributed caching solutions and is ideal
    for managing large monorepo code bases.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它配备了先进的本地和分布式缓存解决方案，非常适合管理大型单仓库代码库。
- en: Turborepo
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Turborepo
- en: Turborepo is the newest entrant in the monorepos war. It follows a package-based
    style and is very similar to how Lerna works. The main advantage of Turborepo
    is it supports a local and distributed caching system and is tightly integrated
    with Vercel’s product suite, including Next.js and Vercel cloud hosting.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Turborepo 是单仓库竞赛中的最新参与者。它遵循基于包的样式，并且与 Lerna 的工作方式非常相似。Turborepo 的主要优势是它支持本地和分布式缓存系统，并且与
    Vercel 的产品套件紧密集成，包括 Next.js 和 Vercel 云托管。
- en: As we come to the end of this section, we have learned about the pros and cons
    of polyorepos versus monorepos. We saw some of the reasons why we choose to use
    monorepos for microfrontends and we also learned about some of the popular monorepo
    tools that teams use. In the next section, we will get our hands dirty setting
    up our monorepo.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入本节的尾声时，我们已经了解了多仓库与单仓库的优缺点。我们看到了选择使用单仓库进行微前端的一些原因，我们还了解了一些团队使用的流行单仓库工具。在下一节中，我们将着手设置我们的
    monorepo。
- en: Setting up our Monorepo
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的 Monorepo
- en: In this section, we are going to set up our monorepo, which will act as a base
    for our microfrontend apps. We will learn how to set up the right permissions
    and the necessary quality gates. Along the way, we will also learn about a couple
    of productivity tricks and plugins that improve the developer experience.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置我们的 monorepo，它将作为我们的微前端应用程序的基础。我们将学习如何设置正确的权限和必要的质量门。在这个过程中，我们还将了解一些提高开发者体验的生产力技巧和插件。
- en: For this example and the rest of the chapters, we will use Nx as the monorepo
    to build our microfrontends as it allows you to build both a package-setup-style
    and an integrated-style monorepo. You can equally choose either Lerna or Turborepo
    to build your microfrontends.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本例和本章的其余部分，我们将使用 Nx 作为 monorepo 来构建我们的微前端，因为它允许你构建包设置样式和集成样式 monorepo。你也可以选择
    Lerna 或 Turborepo 来构建你的微前端。
- en: 'Follow along with the step-by-step guide to set up an Nx monorepo:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下分步指南设置 Nx monorepo：
- en: 'Open up the terminal, **cd** into the folder where you generally keep your
    projects, and run the following command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，**cd** 到你通常存放项目的文件夹，并运行以下命令：
- en: '[PRE0]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, it will prompt you to select what kind of apps you would like to create.
    We will choose **react**:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它将提示你选择你想要创建的应用类型。我们将选择 **react**：
- en: '![Figure 3.3 – Select a workspace with a single React application](img/Figure_3.03_B18987.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 选择一个包含单个 React 应用的工作区](img/Figure_3.03_B18987.jpg)'
- en: Figure 3.3 – Select a workspace with a single React application
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 选择一个包含单个 React 应用的工作区
- en: When prompted for the application name, enter **catalog**, as this will be the
    catalog app within our microfrontend.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示输入应用程序名称时，输入 **catalog**，因为这将是我们的微前端中的目录应用程序。
- en: When prompted to select the stylesheet format, you can select the default, **CSS**,
    or any other format you prefer.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示选择样式表格式时，你可以选择默认的 **CSS** 或任何你喜欢的其他格式。
- en: Next, it will prompt you to enable distributed caching. For this exercise, we
    will say **No**.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它将提示你启用分布式缓存。对于这个练习，我们将说 **No**。
- en: Important note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can find complete details of setting up NX here: [https://nx.dev/getting-started/intro](https://nx.dev/getting-started/intro)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://nx.dev/getting-started/intro](https://nx.dev/getting-started/intro)
    找到设置 NX 的完整细节。
- en: 'It will then go on to install all the dependencies and, once successfully completed,
    you should have a folder structure similar to *Figure 3**.4*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将继续安装所有依赖项，一旦成功完成，你应该有一个类似于 *图 3.4* 的文件夹结构：
- en: '![Figure 3.4 – Folder structure for our monorepo](img/Figure_3.04_B18987.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 我们 monorepo 的文件夹结构](img/Figure_3.04_B18987.jpg)'
- en: Figure 3.4 – Folder structure for our monorepo
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 我们 monorepo 的文件夹结构
- en: You will notice it will have created a monorepo called `my-mfe` and an app called
    `catalog` within the `apps` folder.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到它已经创建了一个名为 `my-mfe` 的 monorepo 和 `apps` 文件夹中的一个名为 `catalog` 的应用程序。
- en: Go ahead and open up this folder in Visual Studio Code and, once you do that,
    you will get a prompt to install recommended plugins. Go ahead and install the
    recommended plugins.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勇敢地打开这个文件夹在 Visual Studio Code 中，一旦你这样做，你将得到一个提示来安装推荐的插件。请继续安装推荐的插件。
- en: 'Once all the plugins have been installed, you will notice a new icon on the
    VS Code pane, as highlighted here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有插件都已安装，你将在 VS Code 面板中注意到一个新的图标，如这里所示：
- en: '![Figure 3.5 – Nx Console installed on VS Code](img/Figure_3.05_B18987.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – VS Code 上安装的 Nx Console](img/Figure_3.05_B18987.jpg)'
- en: Figure 3.5 – Nx Console installed on VS Code
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – VS Code 上安装的 Nx Console
- en: Nx Console is one of the coolest features of using Nx and we will be extensively
    using it for the rest of this book.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Nx Console 是使用 Nx 的最酷特性之一，我们将在本书的剩余部分广泛使用它。
- en: For those curious about how this popup to install recommended plugins came up,
    the answer lies in the `my-mfe/.vscode/extensions.json` file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些好奇如何出现安装推荐插件的弹出窗口的人来说，答案在于 `my-mfe/.vscode/extensions.json` 文件。
- en: 'This is a VS Code feature and you can read about it here: [https://code.visualstudio.com/docs/editor/extension-marketplace#_workspace-recommended-extensions](https://code.visualstudio.com/docs/editor/extension-marketplace#_workspace-recommended-extensions)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 VS Code 功能，你可以在这里了解它：[https://code.visualstudio.com/docs/editor/extension-marketplace#_workspace-recommended-extensions](https://code.visualstudio.com/docs/editor/extension-marketplace#_workspace-recommended-extensions)
- en: You can use this file to add your own list of recommended plugins that you would
    like your team members to use.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用此文件添加你希望团队成员使用的推荐插件列表。
- en: This is an easy way for teams to standardize plugins and help junior developers
    get productive faster without them having to learn things the hard way.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种让团队标准化插件并帮助初级开发者更快地提高生产力的简单方法，而无需他们通过艰难的方式学习。
- en: You will also notice that Nx has also created a few other files, such as `eslintrc.json`,
    `.prettierrc`, `.editorconfig`, and so on. All of these files help lay a good
    foundation for writing good code and ensuring consistency in how that code is
    written with regard to things such as indentation, the use of single versus double
    quotes, and so on.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到 Nx 还创建了一些其他文件，例如 `eslintrc.json`、`.prettierrc`、`.editorconfig` 等等。所有这些文件都有助于为编写良好的代码打下良好的基础，并确保代码在缩进、单引号与双引号的使用等方面的一致性。
- en: Running the app locally
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地运行应用
- en: To run the app locally, we could always run the terminal commands, but for a
    better developer experience, we will use the newly auto-added Nx Console extension
    we talked about earlier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地运行应用，我们始终可以运行终端命令，但为了更好的开发者体验，我们将使用我们之前提到的自动添加的 Nx Console 扩展。
- en: Click on the Nx Console icon and then, under **GENERATE & RUN TARGET**, select
    **serve** and then, from the dropdown at the top, select the **catalog** app,
    then select **Execute:nx** **run catalog:serve**
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 Nx Console 图标，然后，在 **生成 & 运行目标** 下选择 **serve**，然后从顶部下拉菜单中选择 **catalog** 应用，然后选择
    **执行:nx run catalog:serve**
- en: '![Figure 3.6 – Serving the catalog app using Nx Console](img/Figure_3.06_B18987.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 使用 Nx Console 提供目录应用](img/Figure_3.06_B18987.jpg)'
- en: Figure 3.6 – Serving the catalog app using Nx Console
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 使用 Nx Console 提供目录应用
- en: You will notice that it actually runs `pnpm exec nx serve catalog` in the terminal
    and, after a few seconds, you will have the catalog app running at `http://localhost:4200`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现它实际上在终端中运行了 `pnpm exec nx serve catalog`，几秒钟后，你将在 `http://localhost:4200`
    上运行 catalog 应用。
- en: 'Open the link in the browser and get a feel for the newly created catalog app:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开链接，感受一下新创建的目录应用：
- en: '![Figure 3.7 – Catalog app running on port 4200](img/Figure_3.07_B18987.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 目录应用在端口 4200 上运行](img/Figure_3.07_B18987.jpg)'
- en: Figure 3.7 – Catalog app running on port 4200
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 目录应用在端口 4200 上运行
- en: Creating a new app with Nx Console
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Nx Console 创建新应用
- en: 'Next, let us create another new app. Follow these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建另一个新应用。按照以下步骤操作：
- en: Go to Nx Console and from **GENERATE & RUN TARGET**, select the **generate**
    command. Then, from the dropdown, select **Create React application**. On the
    following screen, where it asks for the name of the application, enter **checkout**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 Nx Console，从 **生成 & 运行目标** 中选择 **生成** 命令。然后，从下拉菜单中选择 **创建 React 应用程序**。在接下来的屏幕上，当询问应用程序名称时，输入
    **checkout**。
- en: As you scroll down the form for the section that says **e2eTestRunner**, select
    none. This will ensure the **checkout-e2e** folder is not created.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你向下滚动到 **e2eTestRunner** 部分的表单时，选择无。这将确保不会创建 **checkout-e2e** 文件夹。
- en: Important note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice as you fill in the form fields that Nx is actually doing a dry run on
    the terminal to show what the output would look like.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你填写表单字段时，Nx 实际上在终端中进行了干运行，以显示输出将是什么样子。
- en: Go ahead and click on the `apps` folder of the monorepo.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往并点击 monorepo 中的 `apps` 文件夹。
- en: Using Nx Console, go ahead and serve the checkout app. On the nx serve checkout
    screen, scroll down a bit and select **port** and type 4201 then select **Execute:nx
    run checkout:serve –port=4201** to run the checkout app on port 4201.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Nx Console，继续提供 checkout 应用。在 nx serve checkout 屏幕上，向下滚动一点，选择 **端口** 并输入
    4201，然后选择 **执行:nx run checkout:serve –port=4201** 以在端口 4201 上运行 checkout 应用。
- en: 'We can follow the same steps to create additional apps. Nx comes with a whole
    set of core and community plugins, which allows you to create apps in different
    frameworks, such as Angular, Next.js, Vue, and so on. You can view the full list
    of plugins available here: [https://nx.dev/community](https://nx.dev/community).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遵循相同的步骤来创建额外的应用程序。Nx附带了一套核心和社区插件，这允许您使用不同的框架创建应用程序，例如Angular、Next.js、Vue等。您可以在以下位置查看可用的插件完整列表：[https://nx.dev/community](https://nx.dev/community)。
- en: Setting permissions in your Monorepo
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的单一代码仓库中设置权限
- en: Now that we have multiple apps within the monorepo and we assume there are independent
    teams working on each of these apps, the next thing that arises is how we ensure
    the right permissions to ensure that teams don’t accidentally make changes to
    another team’s code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们单一代码仓库中有多个应用程序，并且假设每个应用程序都有独立团队在开发，接下来出现的问题是如何确保正确的权限，以确保团队不会意外更改其他团队的代码。
- en: As we saw earlier, the general thought process with monorepos is that everybody
    with access to the repo has access to all the apps and folders within the monorepo
    but they can’t merge code changes in apps they don’t own.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，单一代码仓库的一般思路是，所有有权访问仓库的人员都有权访问单一代码仓库中的所有应用程序和文件夹，但他们不能合并他们不拥有的应用程序的代码更改。
- en: 'In monorepos, the permissions are set at a folder level and by making use of
    the `CODEOWNERS` file. You can read in detail about `CODEOWNERS` here: [https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在单一代码仓库中，权限是在文件夹级别设置的，并且通过使用`CODEOWNERS`文件来实现。您可以在以下位置详细了解`CODEOWNERS`：[https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners)。
- en: Important note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The **CODEOWNERS** file works with GitHub and GitLab. If you are using Azure
    DevOps, this feature is implemented via the required approvers feature: [https://learn.microsoft.com/en-gb/azure/devops/repos/git/branch-policies?view=azure-devops&tabs=browser#automatically-include-code-reviewers](https://learn.microsoft.com/en-gb/azure/devops/repos/git/branch-policies?view=azure-devops&tabs=browser#automatically-include-code-reviewers).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`CODEOWNERS`文件与GitHub和GitLab兼容。如果您使用Azure DevOps，此功能通过所需的审批者功能实现：[https://learn.microsoft.com/en-gb/azure/devops/repos/git/branch-policies?view=azure-devops&tabs=browser#automatically-include-code-reviewers](https://learn.microsoft.com/en-gb/azure/devops/repos/git/branch-policies?view=azure-devops&tabs=browser#automatically-include-code-reviewers)。'
- en: In short, the `CODEOWNERS` file allows us to ensure that an individual or a
    team is explicitly involved in the code review and approval of changes to files
    they own.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`CODEOWNERS`文件允许我们确保个人或团队明确参与他们拥有的文件代码审查和变更批准。
- en: 'We can assign files in two ways: all files within a given folder or all files
    of a certain type.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式分配文件：给定文件夹内的所有文件或特定类型的所有文件。
- en: Let’s see this in action.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际操作。
- en: 'In the root of our monorepo, let’s create a file called `CODEOWNERS`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单一代码仓库根目录下，创建一个名为`CODEOWNERS`的文件：
- en: '[PRE1]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What this means is if any of the pull requests contain modifications to files
    within the `apps/catalog` folder, it will automatically add people from the catalog
    team as reviewers to the pull request, and without approval from that team, the
    pull request cannot be merged.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果任何拉取请求包含对`apps/catalog`文件夹内文件的修改，它将自动将目录团队的人员添加为拉取请求的审阅者，并且没有该团队的批准，拉取请求无法合并。
- en: The same holds true for pull requests with modifications to files in the `checkout`
    folder. In this case, it will require an explicit approval from members of the
    checkout team.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于修改`checkout`文件夹内文件的拉取请求，同样适用。在这种情况下，它将需要checkout团队成员的明确批准。
- en: 'We can also assign an individual in the `CODEOWNERS` file. Let’s say we want
    to ensure that any changes to files in the `tools` folder need approval from GitHub
    user `@msadmin`. Let’s also assume we have a CSS expert on our team and would
    like that person to review all CSS changes in the entire repo. We can add the
    following two rules to enable this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`CODEOWNERS`文件中指定个人。假设我们想要确保对`tools`文件夹内文件的任何更改都需要GitHub用户`@msadmin`的批准。假设我们团队中有一位CSS专家，我们希望此人审查整个仓库中的所有CSS更改。我们可以添加以下两条规则来启用此功能：
- en: '[PRE2]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This way, we can ensure a fine-grained approval process for pull requests, ensuring
    that the right stakeholders are involved in the approval of all changes being
    made to the files they are responsible for. As you can see, this also allows you
    to set rules so that an individual’s expertise on a certain subject can be leveraged
    for the overall benefit of the whole team.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以确保对拉取请求进行精细的审批流程，确保所有更改的正确利益相关者都参与了他们负责的文件更改的审批。如您所见，这也允许您设置规则，以便个人在某个特定主题上的专业知识可以为整个团队的利益做出贡献。
- en: 'The following are a few points to keep in mind as you create entries in the
    `CODEOWNERS` file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `CODEOWNERS` 文件条目时，以下是一些需要注意的要点：
- en: File paths in the file are case-sensitive
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件路径在文件中是区分大小写的
- en: The priority of the rules is from the bottom to the top of the **CODEOWNERS**
    file; for example, if there are multiple matching rules, the bottom-most row gets
    the highest priority
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则的优先级是从 `CODEOWNERS` 文件的底部到顶部；例如，如果有多个匹配规则，则最底部的行具有最高优先级
- en: If a row has a syntax error, it will be skipped, and GitHub will simply move
    on to the next row
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果某一行有语法错误，它将被跳过，GitHub 将简单地移动到下一行
- en: To test this, push the code to GitHub with the entries in the `CODEOWNERS` file,
    make changes to the file, and raise a pull request to see the `CODEOWNERS` file
    come into action.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，请将带有 `CODEOWNERS` 文件条目的代码推送到 GitHub，修改该文件，并提交一个拉取请求以查看 `CODEOWNERS`
    文件的实际应用。
- en: Having come to the end of this section, we have learned how to initialize a
    monorepo using Nx, how to create apps within our monorepo, and how to run them
    individually using NX Console. We also had a quick look at some of the tooling
    advantages we get with Nx, which offers a really good developer experience for
    beginners and also ensures a strong foundation for your application by automatically
    setting up some of the quality gates for your repo. Finally, we looked at the
    various way we can set up permissions on our repo to allow open collaboration
    and also leverage individual team members’ strengths for the benefit of the whole
    team.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到达本节末尾，我们学习了如何使用 Nx 初始化单仓库，如何在单仓库中创建应用，以及如何使用 NX Console 单独运行它们。我们还快速浏览了一些 Nx
    提供的工具优势，它为初学者提供了非常好的开发者体验，同时也通过自动设置一些质量门为您的仓库提供了坚实的基础。最后，我们探讨了我们可以设置的各种权限，以允许开放协作并利用个别团队成员的优势，以整个团队的利益为出发点。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this, we come to the end of this chapter, where we unpacked quite a bit.
    We saw how teams today are choosing between a monorepo and a polyrepo approach
    to version control their code bases.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就到了这一章的结尾，我们详细探讨了相当多的内容。我们看到了今天团队在版本控制代码库时，是如何在单仓库和多仓库方法之间进行选择的。
- en: We then went into the details of how the choice of a polyrepo or a monorepo
    impacts how your teams operate, how easy or difficult it is to refactor code,
    and who owns the responsibility of fixing breaking changes in the repo.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们详细探讨了选择多仓库或单仓库如何影响团队的操作方式，代码重构的难易程度，以及谁负责修复仓库中的破坏性更改。
- en: We then saw why choosing monorepos for microfrontends has more benefits, such
    as the ease of managing all the micro-apps within a single repo, especially when
    it comes to running multiple apps locally and managing the tooling centrally for
    all the apps within the monorepo.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了为什么选择单仓库用于微前端有更多好处，例如，在单个仓库中管理所有微应用，尤其是在本地运行多个应用并集中管理单仓库中所有应用的工具时。
- en: Finally, we went about setting up our monorepo, where we saw the benefits of
    using a tool such as Nx, which provides us with prebaked quality gates such as
    ESLint and Prettier to ensure consistency and code quality. We also saw how to
    use Nx Console to easily create new micro-apps and run existing micro-apps. We
    then saw how to set up the `CODEOWNERS` file to ensure granular control over who
    can approve code changes for a given micro-app.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们着手设置了我们的单仓库，我们看到了使用像 Nx 这样的工具的好处，它为我们提供了预配置的质量门，如 ESLint 和 Prettier，以确保一致性和代码质量。我们还看到了如何使用
    Nx Console轻松创建新的微应用并运行现有的微应用。然后我们看到如何设置 `CODEOWNERS` 文件以确保对特定微应用的代码更改审批有细粒度控制。
- en: In the next chapter, we will take our current setup and go about creating a
    full-fledged multi-SPA pattern microfrontend.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将基于当前设置，着手创建一个完整的、多-SPA 模式微前端。
