- en: Manipulating Streams and Their Values
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操纵流及其值
- en: Operators are functions we can call on our streams to perform manipulation in
    many different ways. Operators are immutable, which makes the stream easy to reason
    about and will also make it quite easy to test. As you will see throughout this
    chapter, we will seldom deal with just one stream, but many streams, and it is
    understanding how to forge and control these streams that allow you to go from
    thinking it's *dark magic* to actually being able to apply RxJS when and where
    you need it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符是我们可以在流上调用的函数，以多种不同的方式执行操作。操作符是不可变的，这使得流易于推理，并且也很容易测试。正如你将在本章中看到的，我们很少处理一个流，而是处理许多流，理解如何塑造和控制这些流，让你能够从认为这是*黑魔法*转变为在需要时真正应用
    RxJS。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: How to use basic operators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用基本操作符
- en: Debugging streams with operators as well as with existing tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用操作符以及现有工具调试流
- en: Digging deeper into different operator categories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解不同的操作符类别
- en: Developing the mindset to solve a problem the Rx way
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 Rx 的方式培养解决问题的思维方式
- en: Starting out
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始阶段
- en: You almost always start out coding with RxJS by creating a stream of static
    values. Why static values? Well, there is no need to make it unnecessarily complex,
    and all you really need to start reasoning is an `Observable`. As you gradually
    progress in your problem solving, you might replace the static values with a more
    appropriate call to an AJAX call, or from another asynchronous source that your
    values originate from.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎总是从创建一组静态值的 RxJS 开始编码。为什么要使用静态值？嗯，没有必要使它过于复杂，你真正需要开始推理的只是一个`Observable`。
- en: You then start thinking about what you want to achieve. This leads you to consider
    which operators you might need and in which order you need to apply them. You
    might also think about how to divide your problem up; this usually means creating
    more than one stream, where each stream solves a specific problem that connects
    to the larger problem you are trying to solve.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你开始考虑你想达到什么目标。这让你考虑到你可能需要哪些操作符，以及你需要以哪种顺序应用它们。你可能还会思考如何划分你的问题；这通常意味着创建多个流，每个流解决一个与你尝试解决的更大问题相关的特定问题。
- en: Let's start with stream creation and see how we can take our first steps working
    with streams.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从流创建开始，看看我们如何开始使用流的第一步。
- en: 'The following code creates a stream of static values:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建一组静态值的流：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That is a very basic example of how we can create a stream. We use the `of()` creation
    operator, which takes any number of arguments. All the arguments are emitted,
    one by one, as soon as there is a subscriber. In the preceding code, we also subscribe
    to `staticValuesStream$` by calling the `subscribe()` method and passing a function
    that takes the emitted value as a parameter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的示例，展示了我们如何创建一个流。我们使用了 `of()` 创建操作符，它接受任意数量的参数。只要有订阅者，所有参数都会一个接一个地被发射出来。在上述代码中，我们还通过调用`subscribe()`方法并传递一个以发射的值作为参数的函数来订阅`staticValuesStream$`。
- en: Let's introduce an operator, `map()`, which acts like a projection and allows
    you to change what is being emitted. The `map()` operator gets called on each
    value in the stream before it is emitted.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一个操作符，`map()`，它像一个投影，允许你改变正在发射的值。在发射之前，`map()`操作符针对流中的每个值都会被调用。
- en: 'You use the `map()` operator by supplying it with a function and carrying out
    a projection, like so:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供一个函数并进行投影来使用`map()`操作符：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, we have appended the `map()` operator to `staticValuesStream$` and
    we apply it to each value before emitting it and incrementing it by one. The resulting
    data is therefore changed. This is how you append operators to a stream: simply
    create the stream, or take an existing one, and append the operators one by one.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们已将`map()`操作符追加到`staticValuesStream$`上，并在发射每个值之前应用它，并将其递增一个。因此，生成的数据已经发生改变。这就是如何将操作符追加到流中的：简单地创建流，或者获取现有的流，并逐个追加操作符。
- en: Let's add another operator, `filter()`, to ensure that we really understand
    how to work with operators. What does `filter()` do. Well, just like the `map()` operator,
    it is applied to each value, but instead of creating a projection, it decides
    which values will be emitted. `filter()` takes a Boolean. Any expression evaluated
    to `true` means the value will be emitted; if `false`, the expression will not
    be emitted.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加另一个运算符 `filter()`，以确保我们真正理解如何使用运算符。`filter()` 做什么？嗯，就像 `map()` 运算符一样，它被应用于每个值，但不是创建一个投影，而是决定哪些值将被发出。
    `filter()` 接受一个布尔值。任何评估为 `true` 的表达式意味着该值将被发出；如果为 `false`，该表达式将不会被发出。
- en: 'You use the `filter()` operator in the following way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以如下使用 `filter()` 运算符：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We add the `filter()` operator by chaining it to the existing `map()` operator.
    The condition we give our `filter()` operator says to only return `true` for values
    that are divisible by `2`, that's what the modulus operator does. We know from
    before that the `map()`   operator alone ensures that the values `2`, `3` , `4`,
    and `5` are emitted. These are the values that are now being evaluated by the
    `filter()` operator. Out of those four values, only `2` and `4` fulfill the condition
    set out by the `filter()` operator.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `filter()` 运算符添加到现有的 `map()` 运算符中。我们给 `filter()` 运算符的条件是只返回能被 `2` 整除的 `true`
    值，这就是模运算符的功能。我们知道，仅有 `map()` 运算符本身可以确保值 `2`、`3`、`4` 和 `5` 被发出。这些值现在正在被 `filter()`
    运算符评估。在这四个值中，只有 `2` 和 `4` 符合 `filter()` 运算符设定的条件。
- en: 'Of course, when working on a stream and applying operators, things might not
    always be as simple as the preceding code. It might not be possible to anticipate
    exactly what gets emitted. For those occasions, we have a few tricks we can use.
    One such trick is to use the `do()` operator, which will allow us to inspect each
    value without changing it. This gives us ample opportunity to use it for debugging
    purposes. Depending on where we are in the stream, the `do()` operator will output
    different values. Let''s look at different situations where it matters where the `do()` operator
    is applied:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当在流上工作并应用运算符时，事情可能并不总是像前面的代码那样简单。也许无法准确预测哪些内容被发出。针对这些场合，我们有一些可以使用的技巧。其中之一是使用
    `do()` 运算符，它将允许我们检查每个值而不更改它。这为我们提供了充分的机会将其用于调试目的。根据我们在流中所处的位置，`do()` 运算符将输出不同的值。让我们看看应用
    `do()` 运算符的地方很重要的不同情况：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, just by using the `do()` operator, we have a nice way to debug
    our streams, which becomes necessary as our streams grow in complexity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `do()` 运算符，您可以看到，当我们的流变得越来越复杂时，我们有一种很好的方式来调试我们的流。
- en: Understanding operators
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解运算符
- en: So far, we have shown how to create a stream and use some very basic operators
    on it to change what values get emitted. We also introduced how to inspect your
    stream without changing it by using the `do()` operator. Not all operators are
    as easy to understand as the `map()`, `filter()`, and `do()` operators. There
    are different tactics you can use to try to understand what each operator does
    so you know when to use them. Using the `do()` operator is one way, but there
    is a graphical approach you can take. This approach is known as a marble diagram.
    It consists of an arrow that represents time passing from left to right. There
    are circles, or marbles, on this arrow that represent emitted values. The marbles
    have a value in them, but the distance between the marbles might also describe
    what is happening over time. A marble diagram usually consists of at least two
    arrows with marbles on them, as well as an operator. The idea is to represent
    what happens to a stream when an operator is applied. The second arrow usually
    represents the resulting stream.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们展示了如何创建一个流并在其上使用一些非常基本的运算符来更改发出的值。我们还介绍了如何使用 `do()` 运算符来检查您的流而不更改它。并不是所有运算符都像
    `map()`、`filter()` 和 `do()` 运算符那样容易理解。有不同的策略可以尝试理解每个运算符的功能，以便知道何时使用它们。使用 `do()`
    运算符是一种方法，但您还可以采取图形方法。这种方法被称为大理石图。它由表示时间从左向右流逝的箭头组成。在这个箭头上有圆圈或大理石，代表已发出的值。大理石上有一个值，但大理石之间的距离也可以描述随时间发生的情况。大理石图通常由至少两个带有大理石的箭头组成，以及一个运算符。其目的是表示在应用运算符时流发生了什么。第二个箭头通常代表产生的流。
- en: 'Here''s an example of a marble diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例的大理石图：
- en: '![](img/2dd33126-5938-4564-886a-9e438aff2bd5.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2dd33126-5938-4564-886a-9e438aff2bd5.png)'
- en: 'Most operators in RxJS are depicted by a marble diagram on the site RxMarbles: [http://rxmarbles.com/](http://rxmarbles.com/).
    This is a truly great resource to quickly gain an understanding of what operators
    do. However, to truly understand RxJS you need to code; there is no getting around
    it. There are different ways of doing that of course. You can easily set up your
    own project and install RxJS from NPM, refer to it through a CDN link, or you
    can use a page such as JS Bin ([www.jsbin.com](http://www.jsbin.com)), which gives
    you the ability to easily add RxJS as a library and allows you to start coding
    straight away. It looks something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS中的大多数操作符都在RxMarbles网站上通过弹图表进行描述：[http://rxmarbles.com/](http://rxmarbles.com/)。这是一个快速理解操作符作用的绝妙资源。然而，要真正理解RxJS，你需要编写代码；这个绕不过去。当然可以用不同的方法。你可以轻松地搭建自己的项目，并从NPM安装RxJS，通过CDN链接引用它，或者使用类似JS
    Bin（[www.jsbin.com](http://www.jsbin.com)）这样的页面，可以方便地将RxJS作为库添加，并立即开始编写代码。效果看起来有点像这样：
- en: '![](img/8e925f0d-1dd4-4302-8c65-5b5cda1a65ff.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e925f0d-1dd4-4302-8c65-5b5cda1a65ff.png)'
- en: 'JS Bin makes it easy to start, but wouldn''t it be great if we could combine
    marble diagrams and JS Bin, and get a graphical representation of what you code,
    when you code? You can get just that with RxFiddle: [http://rxfiddle.net/](http://rxfiddle.net/).
    You can enter your code, click Run, and you are shown a marble diagram of what
    you just coded, which will look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JS Bin让启动变得容易，但如果我们可以将拱形图表和JS Bin结合起来，当你编写代码时得到代码的图形表示这岂不是很棒？通过RxFiddle，你可以做到这一点：[http://rxfiddle.net/](http://rxfiddle.net/)。你可以输入代码，点击运行，就会显示你刚刚编写的拱形图表，看起来是这样的：
- en: '![](img/66aadd7c-2b3c-4255-9a7a-13f5a6bc64d6.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66aadd7c-2b3c-4255-9a7a-13f5a6bc64d6.png)'
- en: Stream in a stream
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流中的流
- en: 'We have been looking at different operators that change the values being emitted.
    There is another different aspect to streams: what if you need to create a new
    stream from an existing stream? Another good question is: when does such a situation
    usually occur?  There are plenty of situations, such as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在研究改变被发出的值的不同操作符。流的另一个不同方面是：如果你需要从现有流中创建新流怎么办？这种情况通常会发生在什么时候？有很多情况，比如：
- en: Based on a stream of keyUp events, do an AJAX call.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于一个键盘按键弹起事件的流，进行AJAX调用。
- en: Count the number of clicks and determine whether the user single, double, or
    triple-clicked.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计点击次数，并确定用户是否单击、双击或三击。
- en: You get the idea; we are starting with one type of stream that needs to turn
    into another type of stream.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你明白了吧；我们开始于一种类型的流，需要转换成另一种类型的流。
- en: 'Let''s first have a look at creating a stream and see what happens when we
    try to create a stream as the result of using an operator:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看看创建一个流，并观察使用操作符创建流的结果时会发生什么：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point, every value that passes through the `map()` operator produces
    a new `Observable`. When you subscribe to `stream$`, each value that is emitted
    will be a stream. Your first instinct might be to attach a `subscribe()` to each
    of those values, like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，通过`map()`操作符传递的每个值都会产生一个新的`Observable`。当你订阅`stream$`时，每个发出的值都将是一个流。你的第一反应可能是对每个值附加一个`subscribe()`，像这样：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Fight this urge. This will only create code that is hard to maintain. What you
    want to do is merge all these streams into one so, that you just need one `subscribe()`.
    There is an operator just for that, called `flatMap()`. What `flatMap()` does
    is to take your array of streams and turn them into one stream, a metastream.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 抵制这种冲动。这样只会创建难以维护的代码。你想要的是将所有这些流合并成一个，这样你只需要一个`subscribe()`。这里有一个专门用于此目的的操作符，叫做`flatMap()`。`flatMap()`的作用是将你的一系列流转换成一个流，一个元流。
- en: 'It is used in the following way:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用方式如下：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OK, we get it, we don''t want a stream of Observables, but rather a stream
    of values. This operator seems really great. We still aren''t quite certain when
    to use though. Let''s make this a bit more realistic. Imagine you have a UI that
    consists of an input field. The user enters characters into that input field.
    Imagine that you want to react to one or more characters being entered and, for
    example, perform an AJAX request as the result of characters being entered. We
    focus on two things here: how to collect characters being entered and how to perform
    an AJAX request.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们明白了，我们不想要一系列的Observables，而是要一系列的值。这个操作符看起来确实很棒。但我们仍不太确定何时使用。让我们使这更具体一点。想象一下，你有一个界面由一个输入字段组成。用户在那个输入字段中输入字符。假设你想要对输入一个或多个字符做出反应，并且，例如，根据输入的字符执行一个AJAX请求的结果。我们在这里关注两件事：如何收集输入的字符，以及如何执行AJAX请求。
- en: 'Let'' start with the first thing, capturing characters entered into an input
    field. For this, we need an HTML page and a JavaScript page. Let''s start with
    the HTML page:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一件事开始，捕捉输入字段中输入的字符。为此，我们需要一个HTML页面和一个JavaScript页面。让我们从HTML页面开始：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This depicts our input element and a script reference to RxJS, as well as a
    reference to the `app.js` file. Then we have `app.js` file, where we get a reference
    to the input element and start listening to keystrokes as soon as they are entered:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了我们的输入元素和对RxJS的脚本引用，以及对`app.js`文件的引用。然后我们有`app.js`文件，在这里我们获取输入元素的引用，并开始监听一旦它们输入的按键：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Worth highlighting is the fact that we start listening to `keyup` events being
    emitted by calling the `fromEvent()` creation operator. Thereafter, we apply the `map()` operator
    to dig out the character value store on `ev.key`.  Lastly, we subscribe to the
    stream. As expected, running this code will lead to characters being typed in
    the console as soon as you input values in the HTML page.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，我们开始监听通过调用`fromEvent()`创建操作符发出的`keyup`事件。然后，我们应用`map()`操作符来提取存储在`ev.key`上的字符值。最后，我们订阅这个流。预期地，运行这段代码将导致字符在HTML页面输入值后立即在控制台中键入。
- en: Let's make this more tangible by doing an AJAX request based on what we type.
    For this, we will be using the `fetch()` API and an online API called swapi (swapi.com),
    which contains a collection of APIs containing information on the Star Wars movies.
    Let's first define our AJAX call and then see how it fits into our existing stream
    of keys.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过所输入的内容来做一个基于AJAX请求更具体些。为此，我们将使用`fetch()`API和名为swapi（swapi.com）的在线API，其中包含了有关星球大战电影信息的一系列API。首先定义我们的AJAX调用，然后看看它如何适应我们现有的按键流。
- en: 'We said we would use `fetch()`. It lets us formulate a GET request as simple
    as this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说我们将使用`fetch()`。它让我们可以简单地构建一个GET请求如下所示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Of course, we want to turn this request into an `Observable` so that it can
    play well with our `keyStream$`. Fortunately for us, this is easily accomplished
    through the use of the `from()` operator. Let''s, however, first rewrite our `fetch()` call
    into a method that''s easy to work with. The result of the rewrite looks like
    this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望将这个请求转换成一个`Observable`，这样它就可以很好地与我们的`keyStream$`配合使用。幸运的是，通过使用`from()`操作符，我们很容易就可以做到这一点。然而，首先让我们将我们的`fetch()`调用重写成一个更容易使用的方法。重写的结果如下：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code allows us to provide an argument used to construct a URL which we
    use to fetch some data with AJAX. At this point, we are ready to connect our function
    to our existing stream. We do that by typing the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码允许我们提供一个用于构建URL的参数，然后我们可以使用它来进行AJAX请求获取一些数据。在这一点上，我们准备将我们的函数连接到我们现有的流。我们通过输入以下内容来做到这一点：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We highlight the usage of the `flatmap()` operator in bold using our `from()`
    conversion operator. The operator mentioned last takes our `getStarwarsCharacterStream()` function as
    a parameter. The `from()` operator converts said function into a stream.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用粗体突出了`flatmap()`操作符的使用，使用了我们的`from()`转换操作符。最后提到的操作符将我们的`getStarwarsCharacterStream()`函数作为参数。`from()`操作符将该函数转换为一个流。
- en: 'Here, we have learned how to connect two different streams, but also how to
    convert a `Promise` into a stream. As good as this approach seems on paper, using `flatMap()` has
    its limitations and it is important to understand what they are. For that reason,
    let''s talk about the `switchMap()` operator next. The benefits of using a `switchMap()` operator
    will become clearer when we execute long-running tasks. For argument''s sake,
    let''s define such a task, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们学会了如何连接两个不同的流，同时也学会了如何将`Promise`转换成一个流。尽管这种方法在纸上看起来很不错，但使用`flatMap()`是有局限性的，重要的是要理解它们是什么。因此，让我们讨论下一个`switchMap()`操作符。当我们执行长时间运行的任务时，使用`switchMap()`操作符的好处将变得更加明显。为了论证起见，让我们定义这样一个任务，如下所示：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this code, we have a function that takes 5 seconds to execute; enough time
    to show the point we are trying to make. Next, let''s show what the effect is
    if we keep using the `flatMap()` operator in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们有一个需要 5 秒才能执行完的函数；足够长的时间来展示我们想要说明的问题。接下来，让我们看看在以下代码中继续使用`flatMap()`操作符会有什么影响：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code works in the following way: every time we hit a key, it
    generates an event. However, we have a `.filter()` operator in place that ensures
    an event is only generated when at least four keys are entered,   `filter(key
    => elem.value.length >3)`. Let''s talk about the user''s expectation at this point.
    If a user enters keys in an input control, they most likely expect a request to
    be made when they are done typing. A user defines being done as entering a few
    characters and also that they should be able to remove characters if they were
    mistyped. So, therefore, we can assume the following input sequence:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码工作方式是：每次敲击键盘都会生成一个事件。然而，我们放置了一个`.filter()`操作符来确保只有在输入至少四个键后才会生成一个事件，`filter(key
    => elem.value.length >3)`。现在让我们来谈谈用户此时的期望。如果用户在输入控件中输入字符，他们很可能希望在输入完成时进行请求。用户将“完成”定义为输入一些字符，并且应该能够在输入错误时删除字符。因此，我们可以假设以下输入序列：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, they have entered characters and, within a reasonable amount
    of time, edited their answer. The user expects to receive an answer based on `abcd`.
    Using the `flatMap()` operator, however, means the user will get two answers back
    because, in reality, they typed `abcde` and `abcd`. Imagine we get a results list
    based on these two inputs; it would most likely be two lists that looked somewhat
    different. The response based on our code would look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，他们已经输入了字符，并且，在一个合理的时间内，编辑了他们的答案。用户期望基于`abcd`接收到一个答案。然而使用`flatMap()`操作符意味着用户将会收到两个答案，因为实际上他们输入了`abcde`和`abcd`。想象一下根据这两个输入得到一个结果列表；很可能会是两个看起来有些不同的列表。根据我们的代码得到的响应如下：
- en: '![](img/3938298b-e064-4bb3-8144-209f7a6a3ca8.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3938298b-e064-4bb3-8144-209f7a6a3ca8.png)'
- en: 'Our code most likely would be able to handle the situation  described by rerendering
    the results list as soon as a new response arrives. There are two problems with
    this though: firstly, we do an unnecessary network request for `abcde`, and secondly,
    if the backend is fast enough in responding, we will see a flickering in the UI
    as the result list is rendered once and then, shortly after, is rendered again,
    based on the second response. This is not good, and we want to have a situation
    where the first request will be abandoned if we keep on typing. This is where
    the `switchMap()` operator comes in. It does exactly that. Let''s therefore alter
    the preceding code to the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码很可能能够处理描述的情况，即在新响应到达时立即重新渲染结果列表。但是这样做有两个问题：首先，我们对`abcde`进行了不必要的网络请求；其次，如果后端响应速度足够快，我们将在
    UI 中看到闪烁，因为结果列表首先被渲染一次，然后不久之后基于第二个响应再次被渲染。这并不好，我们希望出现这样的情况：一直输入时第一个请求将被放弃。这就是`switchMap()`操作符的用处，它确实可以做到这一点。因此，让我们修改前面的代码如下：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this code, we simply switched our `flatMap()` to a `switchMap()`. When we
    now execute the code in the exact same way, that is, the user firstly typing `12345` and
    shortly altering that to `1234`, the end result is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们简单地将我们的`flatMap()`切换到了`switchMap()`。当我们以完全相同的方式执行代码，也就是，用户首先输入`12345`，然后很快将其改为`1234`时，最终结果是：
- en: '![](img/b72340e6-3015-478b-9f37-7b674949fcb8.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b72340e6-3015-478b-9f37-7b674949fcb8.png)'
- en: As we can see, we get one request only. The reason for this is that the previous
    event is aborted when a new event happens—`switchMap()` is doing its magic. The
    user is happy and we are happy.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们只收到了一个请求。原因是当新事件发生时，前一个事件被中止了——`switchMap()`发挥了它的魔力。用户很高兴，我们也很满意。
- en: AJAX
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX
- en: 'We have already touched upon the topic of making AJAX requests. There are many
    ways to make AJAX requests; the two most common approaches are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提及了如何进行AJAX请求的话题。有许多方式可以进行AJAX请求；最常见的两种方法是：
- en: Using the fetch API; the fetch API is a web standard and is thus built into
    most browsers
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fetch API；fetch API是Web标准，因此内置在大多数浏览器中
- en: Using the `ajax()` method, nowadays built into the RxJS library; it used to
    exist in a library called Rx.Dom
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ajax()`方法，现在内置到RxJS库中；它曾经存在于一个名为Rx.Dom的库中
- en: fetch()
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fetch()
- en: The `fetch()` API is a web standard. You can find the official documentation
    at the following link: [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
    The `fetch()` API is `Promise`-based, which means we need to convert it to an
    `Observable` before use. The API exposes a `fetch()` method, which takes a mandatory
    URL parameter as the first argument, with the second argument being an optional
    object that allows you to control which body to send, if any, which HTTP verb
    to use, and so on.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()`API是一种Web标准。你可以在以下链接找到官方文档：[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)。`fetch()`API是基于`Promise`的，这意味着我们需要在使用之前将其转换为`Observable`。该API公开了一个`fetch()`方法，该方法将URL作为第一个参数传入，第二个参数是一个可选对象，允许您控制要发送什么主体，如果有的话，要使用哪个HTTP动词等等。'
- en: 'We have already mentioned how to best deal with it in the context of RxJS.
    It is worth repeating though. It is not as simple as just taking our fetch and
    sticking it into the `from()` operator though. Let''s write some code and see
    why:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了如何在RxJS的上下文中最好地处理它。但值得再次重申一下。然而，把我们的fetch放入`from()`操作符并不像简单。让我们写一些代码看看为什么：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We get our data right? Sorry, no, we get a `Response` object back. But that''s
    easy, just call a `json()` method in the `map()` operator and surely then we have
    our data? Again, sorry no, the `json()` method returns a `Promise` when you type
    the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们的数据对吧？抱歉，不对，我们得到了一个`Response`对象。但这很简单，只需在`map()`操作符中调用`json()`方法，那么我们就有了我们的数据？再次抱歉，不对，当你键入以下内容时，`json()`方法会返回一个`Promise`：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have already shown a possible solution to this in the previous section,
    and that is the following construct:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们已经展示了一种可能的解决方案，即以下结构：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What we did in this code was to simply take care of digging out our data before
    handing it over to the `from()` operator. It doesn''t feel quite RxJS to play
    around with Promises. There is a more stream-based approach you can take; we were
    almost there before, we just needed to make a minor adjustment:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们只是简单地处理了将数据从`from()`操作符传递出来之前挖掘出来的工作。用Promise玩耍并不太像RxJS。你可以采取更多基于流的方法；我们几乎就快到达目的地了，我们只需要做一个小调整：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And there it is: our `fetch()` call is now providing us data like a stream.
    So what did we do? Well, we changed our `map()` call to a `flatMap()` call. The
    reason for that was that when we called `r.json()`, we got a `Promise`. We fixed
    that by wrapping it in a `from()` call, `Rx.Observable.from(r.json())`. That would
    make the stream emit a `PromiseObservable` unless we changed from `map()` to `flatMap()`.
    As we learned in the previous section, if we risk creating a stream within a stream,
    we need `flatMap()` to come to our rescue, which it did.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：我们的`fetch()`调用现在提供了像流一样的数据。那我们做了什么呢？我们将我们的`map()`调用更改为`flatMap()`调用。原因是当我们调用`r.json()`时，我们得到了一个`Promise`。我们通过将其包装在`from()`调用中`Rx.Observable.from(r.json())`解决了这个问题。这将使流发出一个`PromiseObservable`，除非我们从`map()`改为`flatMap()`。正如我们在前一节中学到的，如果我们冒着在流内部创建一个流的风险，我们需要`flatMap()`来拯救我们，而它也确实做到了。
- en: ajax() operator
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ajax()操作符
- en: 'Unlike the `fetch()` API, which is `Promise`-based, the `ajax()` method is
    actually `Observable`-based, which makes our job a little easier. Using it is
    quite straightforward, like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于`Promise`的`fetch()`API不同，`ajax()`方法实际上是基于`Observable`的，这让我们的工作变得有点更容易。使用它非常简单，就像这样：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, the preceding code calls the `ajax()` operator with a URL as
    an argument. The second thing worthy of mentioning is the call to the `map()` operator,
    which digs out our data from the `response` property. Because it is an `Observable`,
    we just have to subscribe to it as usual by calling the `subscribe()` method and
    providing it with a listener function as an argument.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的代码调用`ajax()`操作符，并将URL作为参数。值得一提的是调用`map()`操作符，它从`response`属性中挖出我们的数据。因为它是一个`Observable`，我们只需像往常一样调用`subscribe()`方法并提供监听函数作为参数来订阅它。
- en: 'This covers a simple case when you want to fetch data using the HTTP verb `GET`.
    Fortunately for us, it is quite easy to create, update, or delete by using an
    overloaded version of the `ajax()` operator which takes an `AjaxRequest` object
    instance which has the following fields:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖的是在你想要使用HTTP动词`GET`获取数据的简单情况。幸运的是，我们可以很容易地通过使用`ajax()`的重载版本来创建、更新或删除数据，这个版本接受一个`AjaxRequest`对象实例，其中包括以下字段：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see from this object specification, all the fields are optional and
    there are also quite a few things we can configure with our request, such as `headers`, `timeout`,
    `user`, `crossDomain`, and so on; pretty much what we would expect from a nice
    AJAX wrapping functionality. Except for the overload of the `ajax()` operator,
    a few shorthand options also exist:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象规范中所列的所有字段都是可选的，并且我们可以通过请求配置相当多的内容，比如`headers`、`timeout`、`user`、`crossDomain`，等等；基本上，这就是我们对一个很好的AJAX包装功能所期望的。
    除了重载的`ajax()`操作符外，还存在一些简化选项：
- en: '`get()`: Fetches data using the `GET` verb'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 使用`GET`动词获取数据'
- en: '`put()`: Updates data using the `PUT` verb'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put()`: 使用`PUT`动词更新数据'
- en: '`post()`: Creates data using the `POST` verb'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post()`: 使用`POST`动词创建数据'
- en: '`patch()`: The idea with using the `PATCH` verb is to update a partial resource'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch()`: 使用`PATCH`动词的想法是更新一个部分资源'
- en: '`delete()`: Removes data using the `DELETE` verb'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete()`: 使用`DELETE`动词删除数据'
- en: '`getJSON()`: Fetches data using the `GET` verb and sets the response type to
    `application/json`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getJSON()`: 使用`GET`动词获取数据，并将响应类型设置为`application/json`'
- en: Cascading calls
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级联调用
- en: So far, we have covered the two main ways you will use AJAX to send or receive
    data. When it comes to receiving data, it's usually not as simple as fetching
    the data and rendering it. In fact, you will most likely have a dependency on
    when you can fetch which data. A typical example of this is needing to perform
    a login call before you can fetch the remaining data. In some cases, it might
    be that you need to first log in, then fetch the data of the logged in user, and
    once you have that you can fetch messages, orders, or whichever kind of data you
    need that might be specific to a certain user. This whole phenomenon of fetching
    data in this way is called cascading calls.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经覆盖了你将使用AJAX发送或接收数据的两种主要方法。当涉及到接收数据时，通常是不能简单地获取数据并渲染它的。事实上，你很可能需要在何时获取哪些数据上有依赖。
    典型的例子是需要在获取剩余数据之前执行登录调用。在某些情况下，可能需要首先登录，然后获取已登录用户的数据，一旦你获得了这些数据，你就可以获取消息、订单或任何特定于某个用户的数据。这种以这种方式获取数据的整个现象被称为级联调用。
- en: Let's have a look at how we use cascading calls with Promises and gradually
    learn how to do the same with RxJS. We are taking this little detour as we assume
    that most of you reading this book are familiar with Promises.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用promise进行级联调用，并逐渐学习如何在RxJS中做同样的事情。我们会做这个小的跳跃，因为我们假设大部分正在读这本书的人都对promise很熟悉。
- en: 'Let''s look at the dependent case we first mentioned, where we need to perform
    the following steps in this order:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下我们之前提到的依赖情况，我们需要按照这个顺序执行以下步骤：
- en: The user first logs in to the system
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户首先登录到系统
- en: Then we fetch information about the user
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们获取用户的信息
- en: Then we fetch information about the user's orders
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们获取用户订单的信息
- en: 'Using promises, it would look something like this in code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用promise，代码看起来应该像这样：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code describes how we first log in to the system, using the `login()` method,
    and obtain a token. We use this token in any future calls to ensure we make authenticated
    calls. We also see how we perform the `getUser()` call and obtain a user instance.
    We use that same user instance to perform our last call, `getOrders()`, whereby
    the user ID is used as a routing parameter: ``/orders/user/${user.id}``.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码描述了我们如何首先调用`login()`方法登录系统，并获得一个token。我们在未来的任何调用中都使用这个token来确保我们进行了经过身份验证的调用。然后我们看到我们如何执行`getUser()`调用并获得一个用户实例。我们使用相同的用户实例来执行我们的最后一个调用，`getOrders()`，其中用户ID被用作路由参数：``/orders/user/${user.id}``。
- en: 'We have shown how to perform cascading calls using promises; we did this to
    establish a common ground for the problem we are trying to solve. The RxJS approach
    is very similar: we have shown that the `ajax()` operator exists and makes our
    lives easier when dealing with AJAX calls. To achieve the cascading calls effect
    with RxJS, we simply need to use the `switchMap()` operator. This will lead to our
    code looking like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用promises执行级联调用；我们这样做是为了建立我们正在尝试解决的问题的一个共同基础。RxJS的方法非常相似：我们已经展示了`ajax()`操作符的存在，并且在处理AJAX调用时让我们的生活更轻松。要使用RxJS实现级联调用效果，我们只需要使用`switchMap()`操作符。这将使我们的代码看起来像这样：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have highlighted the parts that need changing in the preceding code. In
    short, the changes are:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上述代码中需要更改的部分已用高亮标出。简而言之，更改如下：
- en: '`fetch()` is replaced by the `ajax()` operator'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch()`被`ajax()`操作符替换'
- en: We call `.map(r => r.response)` instead of `.then(r => r.json())`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`.map(r => r.response)`而不是`.then(r => r.json())`
- en: We do `.switchMap()` calls for each cascading call instead of `.then(getOrders)`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个级联调用，我们使用`.switchMap()`而不是`.then(getOrders)`
- en: 'There is one more interesting aspect that we need to cover, namely that of
    parallel calls. When we fetched the user and the order, we waited for a previous
    call to fully complete before we initiated the next call. In a lot of cases, this
    might not be strictly necessary. Imagine that we have a similar case to the previous
    one, but there is a lot of interesting information surrounding the user that we
    want to fetch. Instead of just fetching orders, the user might have a friends
    collection or a collection of messages. The precondition for fetching that data
    is only that we fetched the user, so we know which collection of friends we should
    query for and which collection of messages we need. In the world of promises,
    we would use the `Promise.all()` construct to achieve parallelization. With that
    in mind, we update our `Promise` code to look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个有趣的方面需要我们来讨论，即并行调用。当我们获取用户和订单时，我们在启动下一个调用之前等待前一个调用完全完成。在许多情况下，这可能并不是严格必需的。想象一下，我们有一个与前一个类似的情况，但是围绕用户有很多有趣的信息我们想要获取。除了仅仅获取订单之外，用户可能有一系列朋友或消息。获取这些数据的前提条件只是我们获取了用户，因此我们知道应该查询哪些朋友和我们需要哪些消息。在Promise世界中，我们会使用`Promise.all()`构造来实现并行化。有了这个想法，我们更新我们的`Promise`代码如下：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see from the preceding code, we introduce the new `getUsersData()` method, which
    fetches orders, messages, and friends collections in parallel, making our app
    responsive sooner, as the data will arrive sooner than if we just fetched it one
    after another.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从上面代码中看到的，我们引入了新的`getUsersData()`方法，它并行获取订单、消息和朋友集合，这样可以使我们的应用程序更早地响应，因为数据将会比我们依次获取它们时更早到达。
- en: 'We can easily achieve the same thing with RxJS by introducing the `forkJoin()` operator.
    It takes a list of streams and fetches everything in parallel. We therefore update
    our RxJS code to look like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入`forkJoin()`操作符，我们可以很容易地在RxJS中实现相同的效果。它接受一个流的列表，并并行获取所有内容。因此，我们更新我们的RxJS代码如下：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A deeper look
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解
- en: 'So far, we have had a look at some operators that will let you create streams
    or change streams with the `map()` and `filter()` operators, we have learned how
    to manage different AJAX scenarios, and so on. The basics are there, but we haven''t
    really approached the topic of operators in a structured way. What do we mean
    by that? Well, operators can be thought of as belonging to different categories.
    The number of operators at our disposal is a staggering 60 plus. It''s going to
    take us time to learn all that, if we ever do. Here is the thing though: we just
    need to know which different types of operators exist so that we can apply them
    where appropriate. This reduces our cognitive load and our memory. Once we know
    which categories we have, we just have to drill down, and most likely we will
    end up knowing 10-15 operators in total and the rest we can just look up when
    we need them.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过了一些操作符，让你可以创建流或者用`map()`和`filter()`操作符改变流，我们已经学会了如何管理不同的AJAX场景等等。基础知识都在这里，但我们还没有以一种结构化的方式来接触操作符这个主题。我们的意思是什么？嗯，操作符可以被认为属于不同的类别。我们可以使用的操作符数量令人震惊地超过60个。如果我们有幸可以学会所有这些操作符，这将需要时间。不过这里有个问题：我们只需要知道存在哪些不同类型的操作符，以便我们可以在适当的地方应用它们。这样可以减少我们的认知负担和我们的记忆负担。一旦我们知道我们有哪些类别，我们只需要深入研究，很可能我们最终只会知道总共10-15个操作符，其余的我们需要它们时再查阅即可。
- en: 'Currently, we have the following categories:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有以下几种类别：
- en: '**Creation operators**: These operators help us create streams in the first
    place. Almost anything can be converted into a stream with the help of these operators.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建操作符**：这些操作符帮助我们首先创建流。几乎任何东西都可以通过这些操作符转换为一个流。'
- en: '**Combination operators**: These operators help us combine values as well as
    streams.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合操作符**：这些操作符帮助我们结合值和流。'
- en: '**Mathematical operators**: These operators perform mathematical evaluations
    on the values being emitted.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数学操作符**：这些操作符对发出的值进行数学计算。'
- en: '**Time-based operators**: These operators change at which speed values are
    emitted.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于时间的操作符**：这些操作符改变值发出的速度。'
- en: '**Grouping operators**: The idea with these operators is to operate on a group
    of values rather than individual ones.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分组操作符**：这些操作符的概念是对一组值进行操作，而不是单个值。'
- en: Creation operators
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建操作符
- en: 'We use creation operators to create the streams themselves, because let''s
    face it: what we need to turn into a stream isn''t always going to be a stream,
    but by making it into a stream, it will have to play nicely with other streams
    and, best of all, will get to leverage the full power of using operators.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用创建操作符来创建流本身，因为让我们面对现实：我们需要转换为流的东西并不总是流，但通过将其转换为流，它将不得不与其他流友好相处，并且最重要的是，将能够充分利用使用操作符的全部功能来发挥其全部潜力。
- en: So, what do these other non-streams consist of? Well, it could be anything asynchronous
    or synchronous. The important thing is that it is data that needs to be emitted
    at some point. Therefore, a range of creation operators exist. In the coming subsections,
    we will present a subset of all those that exist, enough for you to realize the
    power of turning anything into a stream.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些其他非流由什么组成呢？嗯，它们可以是任何异步或同步的东西。重要的是它是需要在某个时刻发出的数据。因此，存在一系列的创建操作符。在接下来的子章节中，我们将介绍其中的一部分，足够让您意识到将任何东西转换为流的强大功能。
- en: of() operator
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: of() 操作符
- en: 'We have already had the chance to use this operator a few times. It takes an
    unknown number of comma-separated arguments, which can be integers, strings, or
    objects. This is an operator you want to use if you just want to emit a limited
    set of values. To use it, simply type:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有几次使用了这个操作符。它接受未知数量的逗号分隔参数，可以是整数、字符串或对象。如果您只想发出一组有限的值，那么这是一个您想要使用的操作符。要使用它，只需键入：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As can be seen from the code, it really doesn't matter what we place in our `of()` operator,
    it is able to emit it anyway.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，我们在`of()`操作符中放置了什么并不重要，它总是能够发出它。
- en: from() operator
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: from() 操作符
- en: 'This operator can take arrays or a `Promise` as input and turn them into a
    stream. To use it, simply call it like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作符可以接受数组或`Promise`作为输入，并将它们转换为流。要使用它，只需像这样调用它：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This saves us a lot of headache by not having to deal with different types of
    asynchronous calls.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们就不必处理不同类型的异步调用，从而省去了很多麻烦。
- en: range() operator
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: range() 操作符
- en: 'This operator lets you specify a range, a number to start from and a number
    to end on. This is a nice shorthand that quickly lets you create a stream with
    a range of numbers. To use it, simply type:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作符允许您指定一个范围，一个起始数和一个结束数。这是一个快捷方式，可以快速让您创建一个具有一定范围的数值流。要使用它，只需键入：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: fromEvent() operator
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fromEvent() 操作符
- en: Now it gets really interesting. The `fromEvent()` operator allows us to mix
    a UI event such as a `click` or a `scroll` event and turn it into a stream. So
    far, we have operated under the assumption that asynchronous calls is something
    that only has to do with AJAX calls. This is far from true. The fact that we can
    mix UI events with any type of asynchronous calls creates a really interesting
    situation that allows us to compose really powerful, expressive code. We will
    touch on this topic further in the coming section, *Thinking in streams*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变得非常有趣了。`fromEvent()`操作符允许我们混合UI事件，比如`click`或`scroll`事件，并将其转换为一个流。到目前为止，我们认为异步调用只与AJAX调用有关。这个想法完全不正确。我们可以将UI事件与任何类型的异步调用混合，这创造了一个非常有趣的情况，使我们能够编写非常强大、表现力强的代码。我们将在接下来的章节中进一步讨论这个话题，*以流思考*。
- en: 'To use this operator, you need to provide it with two arguments: a DOM element
    and the name of an event, like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此操作符，您需要为它提供两个参数：一个DOM元素和事件的名称，如下所示：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Combination
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: Combination operators are about combining values from different streams. We
    have a few operators at our disposal that can help us out. This kind of operator
    makes sense when we, for some reason, don't have all the data in one place but
    need to acquire it from more than one place. Combining data structures from different
    sources could be tedious and error-prone work if it weren't for the powerful operators
    we are about to describe.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 组合操作符是用于组合来自不同流的值。我们有几个可供使用的操作符可以帮助我们。当我们因某种原因没有所有数据在一个地方，但需要从多个地方获取时，这种类型的操作符是有意义的。如果不是因为即将描述的强大操作符，从不同来源组合数据结构可能是费时且容易出错的工作。
- en: merge() operator
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: merge()操作符
- en: 'The `merge()` operator takes data from different streams and combines it. Here
    is the thing though: these streams can be of any kind as long as they are of type `Observable`.
    This means we can combine data from a timing operation, a promise, static data
    from an `of()` operator, and so on. What merging does is to interleave the emitted
    data. This means that it will emit from both streams at the same time in the following
    example. Using the operator comes in two flavors, as a static method but also
    as an instance method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge()`操作符从不同的流中获取数据并将其组合。然而，这些流可以是任何类型的，只要它们是`Observable`类型。这意味着我们可以从定时操作、Promise、`of()`操作符中获取的静态数据等结合数据。合并的作用是交替发出数据。这意味着它将在以下示例中同时从两个流中发出。该操作符有两种用法，作为静态方法，也可以作为实例方法：'
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The takeaway here is that if you just need to combine one stream with another,
    then use the instance method version of this operator, but if you have several
    streams, then use the static version. Furthermore, the order in which the streams
    are specified matters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是，如果你只需要将一个流与另一个流结合，那么使用此操作符的实例方法版本，但如果你有多个流，则使用静态版本。此外，指定流的顺序是重要的。
- en: combineLatest()
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: combineLatest()
- en: 'Imagine you have a situation where you have set up connections with several
    endpoints that serve you with data. What you care about is the latest data that
    was emitted from each endpoint. You might be in a situation where one or several
    endpoints stop sending data after a while and you want to know what the last thing
    that happened was. In this situation, we want the ability to combine all the latest
    values from all of the involved endpoints. That''s where the `combineLatest()` operator comes
    in. You use it in the following way:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你面临的情况是，你已经与几个端点建立了连接，并且这些端点为你提供了数据。你关心的是每个端点最新发出的数据。也许有一个或多个端点在一段时间后停止发送数据，而你想知道最后发生的事情是什么。在这种情况下，我们希望能够结合所有相关端点的最新值的能力。这就是`combineLatest()`操作符发挥作用的地方。你可以在以下方式使用它：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What we can see here is that `firstStream$` stops emitting values after a while thanks
    to the `take()` operator, which limits the number of items. However, the `combineLatest()` operator
    ensures we are still given the very last value `firstStream$` emitted.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是`firstStream$`在一段时间后因为`take()`操作符的限制发出的值停止了。然而，`combineLatest()`操作符确保我们仍然获得了`firstStream$`发出的最后一个值。
- en: zip()
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: zip()
- en: 'The point of this operator is to stitch as many values together as possible.
    We may be dealing with continuous streams, but also with streams that have a limit
    to the number of values they emit. You use this operator in the following way:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符的作用是尽可能多地将值拼接在一起。我们可能会处理连续的流，但也可能会处理具有发射值限制的流。你可以在以下方式使用该操作符：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see, here, we stitch values together vertically, and by the least
    common denominator, `thirdStream$` is the shortest, calculating the number of
    emitted values. This means we will take values from left to right and zip them
    together. As `thirdStream$` only has two values, we end up with only two emits.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所看到的，这里我们在垂直方向上将值拼接在一起，并且取最少发射值的`thirdStream$`是最短的，计算发出的值的数量。这意味着我们将从左到右取值并将它们合并在一起。由于`thirdStream$`只有两个值，我们最终只得到了两个发射。
- en: concat()
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: concat()
- en: 'At first look, the `concat()` operator looks like another `merge()` operator,
    but this is not entirely true. The difference is that a `concat()` waits for other
    streams to be completed first before emitting a stream from the next stream in
    order. How you arrange your stream in your call to `concat()` matters. The operator
    is used in the following way:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，`concat()`操作符看起来像是另一个`merge()`操作符，但这并不完全正确。区别在于`concat()`会等待其他流完成后才从顺序中的下一个流中发出流。你如何安排你的流在调用`concat()`中很重要。该操作符的使用方式如下：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Mathematical
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学
- en: Mathematical operators are simply operators that carry out mathematical operations
    on values, such as finding the largest or smallest value, summarizing all values,
    and so on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 数学操作符只是在值上执行数学操作的操作符，比如找到最大或最小值，汇总所有值等。
- en: max
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大值
- en: 'The `max()` operator finds the largest value. This comes in two flavors: we
    either just call the `max()` operator with no arguments, or we give it a `compare`
    function. The `compare` function then decides whether something is larger than,
    smaller than, or equal to an emitted value. Let''s have a look at the two different
    versions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()` 操作符用于找到最大值。它有两种用法：一种是直接调用`max()` 操作符，不带参数；另一种是给它传递一个`compare`函数。`compare`函数决定某个值是大于、小于还是等于被发出的值。让我们看看这两种不同的版本：'
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can see in the preceding code that we get one result back and it is the largest
    one.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上面的代码中所见，我们得到了一个结果，它是最大的一个。
- en: min
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小值
- en: 'The `min()` operator is pretty much the opposite of the `max()` operator; it
    comes in two flavors: with parameter and without parameter. Its task is to find
    the smallest value. To use it, type:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`min()` 操作符与 `max()` 操作符基本相反；也有两种用法：带参数和不带参数。它的任务是找到最小值。使用方法如下：'
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: sum
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总和
- en: 'There used to be an operator called `sum()`, but it hasn''t existed for several
    versions. What there is instead is `.reduce()`. With the `reduce()` operator,
    we can easily achieve the same thing. The following is how you would write a `sum()` operator
    using `reduce()`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以前有一个叫做 `sum()` 的操作符，但已经在多个版本中删除了。现在用的是 `.reduce()` 。使用 `reduce()` 操作符，我们可以很容易地实现相同的功能。下面是使用 `reduce()` 编写
    `sum()` 操作符的方式：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'What this does is to loop through all the emitted values and sum up the results.
    So, in essence, it sums up everything. Of course, this kind of operator can not
    only be applied to numbers, but to objects as well. The difference lies in how
    you carry out the `reduce()` operation. The following example covers such a scenario:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作是遍历所有的发出值并将结果相加。所以，本质上，它将所有值相加。当然，这种操作符不仅可以应用于数字，还可以应用于对象。不同之处在于如何执行 `reduce()` 操作。下面的例子涵盖了这样的场景：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see from the preceding code, the `reduce()` operator ensures that
    all the object's properties get merged together into one object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从前面的代码中所见，`reduce()` 操作符确保所有对象的属性都被合并到一个对象中。
- en: Time
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间
- en: Time is a very important concept when talking about streams. Imagine you have
    multiple streams that have different bandwidths, or one stream is just faster
    than the other, or you have a scenario where you want to retry an AJAX call within
    a certain time interval. In all of these situations, we need to control how fast
    the data is being emitted, and time plays an important role in all these scenarios.
    At our disposal, we have a ton of operators that, like a magician, enable us to
    craft and control our values as we see fit.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 时间在讨论流时是一个非常重要的概念。想象一下，你有多个有不同带宽的流，或者一个流比另一个流快，或者你有想在特定时间间隔内重试一个AJAX调用的场景。在所有这些情况下，我们需要控制数据发出的速度，时间在所有这些情况下都起着重要的作用。我们有一大堆的操作符，像魔术师一样，让我们能够随心所欲地制定和控制我们的值。
- en: interval() operator
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间间隔（interval()）操作符
- en: 'In JavaScript, there is a `setInterval()` function that enables you to execute
    code at regular intervals, up until the point that you choose to stop it. RxJS
    has an operator that behaves just like that, the `interval()` operator. It takes
    one parameter: normally, the number of milliseconds between emitted values. You
    use it in the following way:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，有一个 `setInterval()` 函数，它可以让你以固定的时间间隔执行代码，直到你选择停止它。RxJS有一个行为类似的操作符，就是 `interval()` 操作符。它需要一个参数：通常是发出值之间的毫秒数。使用方法如下：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A word of caution is that this operator will continue emitting until you stop
    it. The best way to stop it is to combine it with a `take()` operator. A `take()` operator
    takes a parameter that specifies how many emitted values it wants before stopping.
    The updated code looks like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，该操作符将一直发出值，直到你停止它。最好的方法是将其与 `take()` 操作符组合使用。 `take()` 操作符需要一个参数，指定在停止之前它要发出多少个值。更新后的代码如下：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: timer() operator
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器（timer()）操作符
- en: 'The `timer()` operator has the job of emitting values after a certain amount
    of time. It comes in two flavors: you either emit just one value after a number
    of milliseconds, or you keep on emitting values with a certain amount of delay
    between them. Let''s look at the two different flavors available:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`timer()` 操作符的工作是在一定时间后发出值。它有两种形式：一种是在一定毫秒数后发出一个值，另一种是在它们之间有一定延迟的情况下继续发出值。让我们看看有哪两种不同的形式可用：'
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: delay() operator
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: delay() 操作符
- en: 'The `delay()` operator delays all the values being emitted and is used in the
    following way:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay()` 操作符延迟所有被发出的值，并且使用以下方式：'
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: sampleTime() operator
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sampleTime() 操作符
- en: 'The `sampleTime()` operator is used to only emit values after the sample period
    has passed. A good use case for this is when you want to have a *cooldown* functionality.
    Imagine you have users that press a Save button way too often. It might be that
    saving takes a few seconds to complete. A way to approach this is to disable the
    Save button while saving. Another valid approach is to simply ignore any presses
    of the button until the operation has had the chance to complete. The following
    code does just that:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampleTime()` 操作符用于在样本期过去后只发出值。这样做的一个很好的用例是当你想要有冷却功能时。想象一下，你有用户太频繁地按下保存按钮。保存可能需要几秒钟的时间才能完成。一种方法是在保存时禁用保存按钮。另一种有效的方法是简单地忽略按钮的任何按下，直到操作有机会完成。以下代码就是这样做的：'
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: debounceTime() operator
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: debounceTime() 操作符
- en: 'The `sampleTime()` operator was able to ignore the user for a certain period
    of time, but the `debounceTime()` operator takes a different approach. Debounce
    as a concept means that we wait for things to calm down before emitting a value.
    Imagine an input element that the user types into. The user will stop typing eventually.
    We want to make sure the user has actually stopped, so we wait for a while before
    we actually do something. This is what the `debounceTime()` operator does for
    us. The following example shows how we can listen to the user typing into an input
    element, wait for the user to stop typing, and lastly, perform an AJAX call:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampleTime()` 操作符能够在一定时间内忽略用户，但 `debounceTime()` 操作符采取了不同的方式。数据防抖是一个概念，意味着我们在发出值之前等待事情平静下来。想象一下，用户输入的输入元素。用户最终会停止输入。我们想要确保用户实际上已经停止了，所以我们在实际执行操作前等待一段时间。这就是
    `debounceTime()` 操作符为我们所做的。以下示例显示了我们如何监听用户在输入元素中输入，等待用户停止输入，最后执行 AJAX 调用：'
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When the user then types a number in the text box, the keyup event will be triggered
    after 2 seconds of inactivity. After that, an AJAX call will be carried out using
    our text box input.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入数字后，在文本框中输入不活动2秒后，将进行一个AJAX呼叫，使用我们的文本框输入。
- en: Grouping
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组
- en: Grouping operators allow us to operate on a group of collected events rather
    than one emitted event at a time.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 分组操作符允许我们对收集到的一组事件进行操作，而不是一次发出一个事件。
- en: buffer() operator
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: buffer() 操作符
- en: 'The idea with the `buffer()` operator is that we can collect a bunch of events
    without them being emitted straight away. The operator itself takes an argument,
    an `Observable` that defines when we should stop collecting events. At that point
    in time, we can choose what to do with those events. Here is how you can use this
    operator:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer()` 操作符的想法是我们可以收集一堆事件，而不会立即发出。操作符本身接受一个参数，一个定义何时停止收集事件的 `Observable`。在那个时刻，我们可以选择如何处理这些事件。以下是你可以使用这个操作符的方法：'
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What this does is to collect events until there has been 2 seconds of inactivity.
    At that point, we release all the key events we have buffered up. When we release
    all those events, we can, for example, send them somewhere via AJAX. This is a
    typical scenario in a chat application. Using the preceding code, we can always
    send the latest character that has been typed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的作用是收集事件，直到出现了2秒的非活动时间。在那时，我们释放了所有缓冲的按键事件。当我们释放所有这些事件时，我们可以，例如，通过 AJAX 发送它们到某个地方。这在聊天应用程序中是一个典型的场景。使用上述代码，我们可以始终发送最新输入的字符。
- en: bufferTime() operator
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: bufferTime() 操作符
- en: A very similar operator to `buffer()` is `bufferTime()`. This one lets us specify
    how long we would like to buffer events for. It is a bit less flexible than `buffer()`,
    but can still be quite useful.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `buffer()` 非常相似的一个操作符是 `bufferTime()`。这个操作符让我们指定要缓冲事件的时间长度。它比 `buffer()` 稍微不那么灵活，但仍然非常有用。
- en: Thinking in streams
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考流
- en: 'So far, we have gone through a bunch of scenarios that have shown us which
    operators are at our disposal and how they can be chained. We have also seen how
    operators such as `flatMap()` and `switchMap()` can really change things as we
    move from one type of observable to another. So, which approach should you take
    when working with Observables? Obviously, we need to express an algorithm using
    operators, but where do we start? The first thing we need to do is to think of
    the start and the end. Which types of events do we want to capture and what should
    the end result look like? That already gives us a hint as to the number of transformations
    we need to carry out to get there. If we want to transform the data only, then
    we can probably make do with a `map()` operator and a `filter()` operator. If
    we want to transform from one `Observable` to the next, then we need a `flatMap()` or
    a `switchMap()`. Do we have a specific behavior, such as waiting for the user
    to stop typing? If so, then we need to look at `debounceTime()` or similar. It''s
    really the same as all problems: break it down, see which parts you have, divide,
    and conquer. Let''s try to break this down into a list of steps though:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经经历了一堆场景，向我们展示了我们可以支配哪些操作符，以及它们如何可以被连接。我们也看到了像 `flatMap()` 和 `switchMap()` 这样的操作符，在从一个类型的
    Observable 到另一个类型时是如何改变事情的。那么，当使用 Observables 时，应该采取哪种方法？显然，我们需要使用操作符来表达算法，但我们应该从哪里开始呢？我们需要做的第一件事就是思考起点和终点。我们想要捕获哪些类型的事件，最终结果应该是什么样的？这已经给了我们一个提示，要进行多少次转换才能达到那个目标。如果我们只想要转换数据，那么我们可能只需要一个 `map()` 操作符和一个 `filter()` 操作符。如果我们想要从一个
    `Observable` 转换到另一个 `Observable`，那么我们就需要一个 `flatMap()` 或 `switchMap()`。我们是否有特定的行为，比如等待用户停止输入？如果有的话，那么我们需要查看 `debounceTime()` 或类似的操作符。这和所有问题其实是一样的：把它分解，看看你有哪些部分，然后征服。不过，让我们尝试将这件事分解成一系列步骤：
- en: What are the inputs? UI events or something else?
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入是什么？UI 事件还是其他东西？
- en: What are the outputs? The end result?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出是什么？最终结果是什么？
- en: Given the second bullet, which transformations do I need to get there?
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鉴于第二条，我需要哪些转换才能达到目标？
- en: Do I deal with more than one stream?
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否需要处理多个流？
- en: Do I need to handle errors, and if so, how?
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要处理错误吗，如果需要，如何处理？
- en: This has hopefully introduced you to how to think about streams. Remember, start
    small and work your way toward your goal.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这让您了解如何思考流。记住，从小处开始，朝着目标努力。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We set out to learn more about basic operators. In doing so, we encountered
    the `map()` and `filter()` operators, which allowed us to control what was being
    emitted. Knowledge of the `do()` operator gave us a way to debug our streams.
    Furthermore, we learned about the existence of sandboxed environments, such as
    JS Bin and RxFiddle, and how they can help us to quickly get started with RxJS.
    AJAX was the next topic that we delved into, and we built an understanding of
    the different scenarios that might occur. Moving on deeper into RxJS, we looked
    at different operator categories. We barely scratched the surface on that one,
    but it offered us a way to approach how to learn which types of operators are
    in the library. Finally, we finished off this chapter by looking at how to change
    and develop our mindset to thinking about streams.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始学习更多关于基本操作符的知识。在这样做的过程中，我们遇到了 `map()` 和 `filter()` 操作符，它们让我们能够控制发出的内容。了解 `do()` 操作符让我们有办法调试我们的流。此外，我们还了解了像
    JS Bin 和 RxFiddle 这样的沙盒环境的存在，以及它们如何帮助我们快速开始使用 RxJS。AJAX 是我们之后深入了解的一个主题，并且我们建立了对可能发生的不同场景的理解。深入了解
    RxJS，我们看了不同的操作符类别。虽然我们对其中的内容只是浅尚的涉猎，但这给了我们一个方法去学习库中有哪些类型的操作符。最后，我们通过思考流的方式来改变和发展我们的思维方式，来结束这一章。
- en: It is with all this acquired knowledge that we are now ready to venture into
    more advanced Rx topics in the next chapter. We know our basics, now the time
    has come to master them.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些所获得的知识使我们现在已经准备好进入下一章中更高级的 Rx 主题。我们知道了基础知识，现在是时候将它们掌握了。
