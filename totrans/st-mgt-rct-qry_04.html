<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer021">
<h1 class="ch pter-number" id="_idParaDest-60"><a id="_idTextAnchor091"/>4</h1>
<h1 id="_idParaDest-61"><a id="_idTextAnchor092"/>Fetching Data with React Query</h1>
<p>React Query allows you to fetch, cache, and handle your server state by leveraging one of its custom hooks called <strong class="source-inline">useQuery</strong>. For your data to be cached, React Query has a concept called a query key. In combination with the query keys and a couple of strict defaults, React Query takes your server state management to the <span class="No-Break">next level.</span></p>
<p>In this chapter, you will be introduced to the <strong class="source-inline">useQuery</strong> hook and understand how React Query allows you to fetch and cache your data. During this process, you will get to know all the defaults that are used in all of your queries. You will also be introduced to some options you can use to make your <strong class="source-inline">useQuery</strong> experience <span class="No-Break">even better.</span></p>
<p>After becoming familiar with <strong class="source-inline">useQuery</strong>, you can start using it to refetch your queries in certain scenarios. You will also be able to leverage some extra properties of <strong class="source-inline">useQuery</strong> to fetch queries that depend on <span class="No-Break">each other.</span></p>
<p>At the end of this chapter, we’ll review a code file to review what we learned in <span class="No-Break">this chapter.</span></p>
<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
<ul>
<li>What is <strong class="source-inline">useQuery</strong> and how does <span class="No-Break">it work?</span></li>
<li><a id="_idTextAnchor093"/>Refetching data <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">useQuery</strong></span></li>
<li><a id="_idTextAnchor094"/><a id="_idTextAnchor095"/>Fetching dependent queries <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">useQuery</strong></span></li>
</ul>
<h1 id="_idParaDest-62"><a id="_idTextAnchor096"/>Technical requirements</h1>
<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_4"><span class="No-Break">https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_4</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor097"/>What is useQuery and how does it work?</h1>
<p>As you learned in the previous chapter, a query is a request you send to an asynchronous source to <span class="No-Break">fetch data.</span></p>
<p>In the React Query documentation, queries are <a id="_idIndexMarker135"/>also defined in the <span class="No-Break">following way:</span><a id="_idTextAnchor098"/></p>
<p class="uthor-quote">A query is a declarative dependency on an asynchronous source of data that is tied to a unique key.</p>
<p>(<a href="https://tanstack.com/query/v4/docs/guides/queries"><span class="No-Break">https://tanstack.com/query/v4/docs/guides/queries</span></a><span class="No-Break">)</span></p>
<p>With that concept under <a id="_idIndexMarker136"/>your belt, you are now ready to understand how React Query leverages its custom hook, called <strong class="source-inline">useQuery</strong>, to enable you to subscribe to <span class="No-Break">a query.</span></p>
<p>To use the <strong class="source-inline">useQuery</strong> custom hook, you have to import it <span class="No-Break">like this:</span></p>
<pre class="source-code">
import { useQuery } from "@tanstack/react-query";</pre>
<p>Here is the <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> syntax:</span></p>
<pre class="source-code">
const values = useQuery({
   queryKey: &lt;insertQueryKey&gt;,
   queryFn: &lt;insertQueryFunction&gt;,
 });</pre>
<p>As you can see, the <strong class="source-inline">useQuery</strong> hook only needs two parameters for it <span class="No-Break">to work:</span></p>
<ul>
<li><strong class="bold">A query key</strong>: A unique <a id="_idIndexMarker137"/>key used to identify <span class="No-Break">your query</span></li>
<li><strong class="bold">A query function</strong>: A function <a id="_idIndexMarker138"/>that returns <span class="No-Break">a promise</span></li>
</ul>
<h2 id="_idParaDest-64"><a id="_idTextAnchor099"/>What is a query key?</h2>
<p>The query key is a unique <a id="_idIndexMarker139"/>value used by React Query to identify your queries. It is <a id="_idIndexMarker140"/>also by using the query key that React Query caches your data in <strong class="source-inline">QueryCache</strong>. The query key also allows you to manually interact with the <span class="No-Break">query cache.</span></p>
<p>The query key needs to be an array that can contain just one string or a bunch of other values, such as objects. All that matters is that the values inside this query key array <span class="No-Break">are serializable.</span></p>
<p>Before React Query v4, the query key didn’t necessarily need to be an array. It could just be a single string <a id="_idIndexMarker141"/>because React Query would convert it internally into an <a id="_idIndexMarker142"/>array. So, don’t find it weird if you find some examples online that don’t use an array as a <span class="No-Break">query key.</span></p>
<p>Here are some valid examples of <span class="No-Break">query keys:</span></p>
<pre class="source-code">
useQuery({ queryKey: ['users']  })
useQuery({ queryKey: ['users', 10] })
useQuery({ queryKey: ['users', 10, { isVisible: true }] })
useQuery({ queryKey: ['users', page, filters] })</pre>
<p>As you can see, so long as it is an array, the query key will <span class="No-Break">be valid.</span></p>
<p>As good practice and to make your query key more distinct and easier to identify while reading through multiple <strong class="source-inline">useQuery</strong> hooks, you should add all the dependencies of your query as part of the query key. Think of it as the same model of the dependency array you have on your <strong class="source-inline">useEffect</strong> hook. This is helpful for reading purposes as well as because the query key also allows React Query to refetch queries automatically when a dependency of the <span class="No-Break">query changes.</span></p>
<p>One thing to keep in mind is that the query key is hashed deterministically. This means that the order of the items inside the <span class="No-Break">array matters.</span></p>
<p>Here are some queries whose query keys, when hashed deterministically, are the <span class="No-Break">same query:</span></p>
<pre class="source-code">
useQuery({ queryKey: ['users', 10, { page, filters }] })
useQuery({ queryKey: ['users', 10, { filters, page }] })
useQuery({ queryKey: ['users', 10, { page, random:
  undefined, filters }] })</pre>
<p>All these examples are the same query – the order of the array in the query key is kept the same throughout the <span class="No-Break">three examples.</span></p>
<p>Now, you might be wondering how is that possible, considering that the inside of the object page and filters changed place every time, and in the last example, there was a third property called <strong class="source-inline">random</strong>. This is true, but they are still inside an object and that object doesn’t change its position inside the query key array. Also, the <strong class="source-inline">random</strong> property is undefined, so when hashing the object, it <a id="_idIndexMarker143"/><span class="No-Break">is excluded.</span></p>
<p>Now, let’s look at some queries whose query keys, when hashed deterministically, are not the <span class="No-Break">same query:</span></p>
<pre class="source-code">
useQuery({ queryKey: ['users', 10, undefined, { page,
  filters }] })
useQuery({ queryKey: ['users', { page, filters }, 10] })
useQuery({ queryKey: ['users', 10, { page, filters }] })</pre>
<p>All these examples represent different queries because when the query key is hashed deterministically, these <a id="_idIndexMarker144"/>examples end up being completely different queries. You might <a id="_idIndexMarker145"/>be wondering why the first example is not the same as the last one. Shouldn’t the <strong class="source-inline">undefined</strong> value disappear as it did from the <strong class="source-inline">{ queryKey: ['users', 10, { page, random: undefined, filters }] })</strong> <span class="No-Break">object?</span></p>
<p>No, because in this scenario, it’s not inside an object, and the order matters. When it’s hashed, this undefined value will be transformed into a null value inside the <span class="No-Break">hashed key.</span></p>
<p>Now that you are familiar with query keys, you can learn more about <span class="No-Break">query functions.</span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor100"/>What is a query function?</h2>
<p>A query function is a <a id="_idIndexMarker146"/>function that returns a promise. This returned promise <a id="_idIndexMarker147"/>will either resolve and return the data or throw <span class="No-Break">an error.</span></p>
<p>As the query function just needs to return a promise, it makes React Query even more powerful because the query function can support any client capable of performing asynchronous <a id="_idIndexMarker148"/>data fetching. This <a id="_idIndexMarker149"/>means that both <strong class="bold">REST</strong> and <strong class="bold">GraphQL</strong> are supported, so you can have both options at the same time if <span class="No-Break">you wish.</span></p>
<p>Now, let’s look at an example of a query function that uses GraphQL and another that <span class="No-Break">uses REST:</span></p>
<p class="Paragraph-Style-1" lang="en-US" xml:lang="en-US">GraphQL</p>
<pre class="source-code">
import { useQuery } from "@tanstack/react-query";
import { request, gql } from "graphql-request";
const customQuery = gql`
  query {
    posts {
      data {
        id
        title
      }
    }
  }
`;
const fetchGQL = async () =&gt; {
  const endpoint = &lt;add_endpoint_here&gt;
  const {
    posts: { data },
  } = await request(endpoint, customQuery);
  return data;
};
 …
useQuery({
queryKey: ["posts"],
queryFn: fetchGQL
});</pre>
<p>In the preceding <a id="_idIndexMarker150"/>snippet, we can see an example of using React Query with GraphQL. This is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We start by creating our GraphQL query and assigning it to our <span class="No-Break"><strong class="source-inline">customQuery</strong></span><span class="No-Break"> variable.</span></li>
<li>Then, we create the <strong class="source-inline">fetchGQL</strong> function, which will be our <span class="No-Break">query function.</span></li>
<li>In our <strong class="source-inline">useQuery</strong> hook, we pass the respective query key to the hook and our <strong class="source-inline">fetchGQL</strong> function as the <span class="No-Break">query function.</span></li>
</ol>
<p>Now, let’s see how to do this <span class="No-Break">using REST:</span></p>
<p class="Paragraph-Style-1" lang="en-US" xml:lang="en-US">REST</p>
<pre class="source-code">
import axios from "axios";
const fetchData = async () =&gt; {
  const { data } = await axios.get(
    `https://danieljcafonso.builtwithdark.com/
      react-query-api`
  );
  return data;
};
…
useQuery({
    queryKey: ["api"],
    queryFn: fetchData,
  });</pre>
<p>In the preceding snippet, we can see an example of using React Query with REST. This is what we <a id="_idIndexMarker151"/><span class="No-Break">are doing:</span></p>
<ol>
<li>We start by creating the <strong class="source-inline">fetchData</strong> function, which will be our <span class="No-Break">query function.</span></li>
<li>In our <strong class="source-inline">useQuery</strong> hook, we pass the respective query key to the hook and our <strong class="source-inline">fetchData</strong> function as the <span class="No-Break">query function.</span></li>
</ol>
<p>These examples make React Query shine even more because so long as you have a client that can perform <a id="_idIndexMarker152"/>asynchronous data fetching, the client can be used <a id="_idIndexMarker153"/>in your query function. As mentioned previously, just so that React Query can handle your error scenarios properly, one thing that we need to check when using these clients is if they automatically throw an error when your request fails. If they do not throw an error, you must throw the <span class="No-Break">error yourself.</span></p>
<p>This is how you can do this in a query function that <span class="No-Break">uses </span><span class="No-Break"><strong class="source-inline">fetch</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const fetchDataWithFetch = async () =&gt; {
  const response = await fetch('https://danieljcafonso.
    builtwithdark.com/react-query-api')
  if (!response.ok) throw new Error('Something failed in
    your request')
  return response.json()
}</pre>
<p>In the preceding snippet, after performing a request using <strong class="source-inline">fetch</strong>, we check if our response is valid. If it is not, we throw an error. If everything is OK, we return the <span class="No-Break">response data.</span></p>
<p>One thing that will eventually pass through your mind as you keep creating queries and building your query <a id="_idIndexMarker154"/>functions is that it would be helpful to pass your query key to your <a id="_idIndexMarker155"/>query function. After all, if query keys represent the dependencies of your query, then it makes sense that you might need them in your <span class="No-Break">query function.</span></p>
<p>You can do this, and there are two patterns to <span class="No-Break">do so:</span></p>
<ul>
<li><span class="No-Break"><strong class="bold">Inline function</strong></span></li>
<li><span class="No-Break"><strong class="bold">QueryFunctionContext</strong></span></li>
</ul>
<h3>Inline function</h3>
<p>When you don’t have <a id="_idIndexMarker156"/>many parameters in your query key that need to be <a id="_idIndexMarker157"/>passed to your query function, you can leverage this pattern. By writing an inline function, you can provide access to the variables in the current scope and pass them to your <span class="No-Break">query function.</span></p>
<p>Here is an example of <span class="No-Break">this pattern:</span></p>
<pre class="source-code">
const fetchData = async (someVariable) =&gt; {
 const { data } = await axios.get(
   `https://danieljcafonso.builtwithdark.com/
     react-query-api/${someVariable}`
 );
 return data;
};
…
useQuery({
   queryKey: ["api", someVariable],
   queryFn: <strong class="bold">() =&gt; fetchData(someVariable),</strong>
 });</pre>
<p>In the preceding snippet, we start by creating a <strong class="source-inline">fetchData</strong> function that will receive a parameter called <strong class="source-inline">someVariable</strong>. This parameter is then used to complement the URL used to fetch the data. When we get to our <strong class="source-inline">useQuery</strong> declaration, since we need our <strong class="source-inline">someVariable</strong> variable to be used as a dependency of our query, we include it in the query key. Finally, in the query function, we create an inline function that will call <strong class="source-inline">fetchData</strong> with our <span class="No-Break"><strong class="source-inline">someVariable</strong></span><span class="No-Break"> value.</span></p>
<p>As you can see, this pattern is <a id="_idIndexMarker158"/>great whenever we don’t have many <a id="_idIndexMarker159"/>parameters. Now, think about the use case where your query key ended up with 12 parameters, and all of them were needed inside of the query function. It’s not a bad practice, but it will impact your code readability a bit. To avoid these cases, you can resort to the <span class="No-Break"><strong class="source-inline">QueryFunctionContext</strong></span><span class="No-Break"> object.</span></p>
<h3>QueryFunctionContext</h3>
<p>Every time the <a id="_idIndexMarker160"/>query function is called, React Query will take <a id="_idIndexMarker161"/>care of automatically passing your query key to the query function as the <span class="No-Break"><strong class="source-inline">QueryFunctionContext</strong></span><span class="No-Break"> object.</span></p>
<p>Here is an example of using the <span class="No-Break"><strong class="source-inline">QueryFunctionContext</strong></span><span class="No-Break"> pattern:</span></p>
<pre class="source-code">
const fetchData = async <strong class="bold">({ queryKey })</strong> =&gt; {
 <strong class="bold">const [_queryKeyIdentifier, someVariable] = queryKey;</strong>
 const { data } = await axios.get(
   `https://danieljcafonso.builtwithdark.com/
     react-query-api/${someVariable}`
 );
 return data;
};
useQuery({
   queryKey: ["api", someVariable],
   queryFn: fetchData,
 });</pre>
<p>In the preceding snippet, we start by creating our <strong class="source-inline">fetchData</strong> function. This function will be receiving <strong class="source-inline">QueryFunctionContext</strong> as a parameter, so from this object, we can immediately destructure <strong class="source-inline">queryKey</strong>. As you know from the <em class="it lic">What is a query key?</em> section, the query key is an array, so the order in which we passed the parameters we need in our function to our query key matters. In this example, we need the <strong class="source-inline">someVariable</strong> variable, which was passed as the second element of our array, so we destructure our array to get the second element. We then use <strong class="source-inline">someVariable</strong> to complement the URL used to fetch the data. When we get to our <strong class="source-inline">useQuery</strong> declaration, since we need our <strong class="source-inline">someVariable</strong> variable to be used as a dependency of our query, we include it in the query key. As it is included in the query key, it will automatically be sent to our <span class="No-Break">query function.</span></p>
<p>This pattern reduces the need to create an inline function and enforces the need to add all the dependencies <a id="_idIndexMarker162"/>of your query to the query key. The one <a id="_idIndexMarker163"/>downside this pattern might have is that with so many parameters, you will have to remember the order you added them to the query key to use them in the query function. One way to fix this issue is by sending an object with all the parameters you need in your query function. This way, you remove the need to remember the order of the elements of <span class="No-Break">your array.</span></p>
<p>This is how you can <span class="No-Break">do this:</span></p>
<pre class="source-code">
useQuery({
   queryKey: [{queryIdentifier: "api", someVariable}],
   queryFn: fetchData,
 });</pre>
<p>By passing an object as your query key, the object will be sent as the <strong class="source-inline">QueryFunctionContext</strong> object to your <span class="No-Break">query function.</span></p>
<p>Then, in your function, you only need to <span class="No-Break">do this:</span></p>
<pre class="source-code">
const fetchData = async ({ queryKey }) =&gt; {
  const { someVariable } = queryKey[0];
…
};</pre>
<p>In the preceding <a id="_idIndexMarker164"/>snippet, we destructure our <strong class="source-inline">queryKey</strong> from <a id="_idIndexMarker165"/>our <strong class="source-inline">QueryFunctionContext</strong> object. Then, since our object will be in the first position of the query key, we can destructure the value we need from our <span class="No-Break">object there.</span></p>
<p>Now that you understand the two required options of every <strong class="source-inline">useQuery</strong> hook, we can start looking at what <span class="No-Break">it returns.</span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor101"/>What does useQuery return?</h2>
<p>When using the <strong class="source-inline">useQuery</strong> hook, it returns a couple of values. To access these values, you can just assign the return of the hook to a variable or destructure the values from the return of <span class="No-Break">the hook.</span></p>
<p>You can do this in the <span class="No-Break">following way:</span></p>
<pre class="source-code">
const values = useQuery(...);
const { data, error, status, fetchStatus }= useQuery(...);</pre>
<p>In this snippet, we can see the two different ways to access the return values of the <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook.</span></p>
<p>In this section, we’ll review the following returns of the <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">data</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">error</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">status</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">fetchStatus</strong></span></li>
</ul>
<h3>data</h3>
<p>This variable is the last <a id="_idIndexMarker166"/>successfully resolved data <a id="_idIndexMarker167"/>returned from your <span class="No-Break">query function.</span></p>
<p>This is how you can use the <span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break"> variable:</span></p>
<pre class="source-code">
const App = () =&gt; {
  const { data } = useQuery({
    queryKey: ["api"],
    queryFn: fetchData,
  });
  return (
    &lt;div&gt;
       {data ? data.hello : null}
    &lt;/div&gt;
  );
};</pre>
<p>In this snippet, we <a id="_idIndexMarker168"/>do <span class="No-Break">the following:</span></p>
<ol>
<li>We destructure our <strong class="source-inline">data</strong> variable <a id="_idIndexMarker169"/>from our <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook.</span></li>
<li>On our return, we check if we already have data from our query. When we do, we <span class="No-Break">render it.</span></li>
</ol>
<p>When the query executes initially, this data will be undefined. Once it finishes executing and the query function successfully resolves your data, we will have access to the data. If, for some reason, our query function promise rejects, then we can use the next <span class="No-Break">variable: </span><span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break">.</span></p>
<h3>error</h3>
<p>The <strong class="source-inline">error</strong> variable lets <a id="_idIndexMarker170"/>you access the error object returned from your query function <a id="_idIndexMarker171"/><span class="No-Break">after failing.</span></p>
<p>This is how you can use the <span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break"> variable:</span></p>
<pre class="source-code">
const App = () =&gt; {
  const { error } = useQuery({
    queryKey: ["api"],
    queryFn: fetchData,
  });
  return (
    &lt;div&gt;
       {error ? error.message : null}
    &lt;/div&gt;
  );
};</pre>
<p>In the preceding snippet, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We destructure our <strong class="source-inline">error</strong> variable from our <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook.</span></li>
<li>On our return, we check if we have any errors. If we do, we render the <span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break"> message.</span></li>
</ol>
<p>When the query <a id="_idIndexMarker172"/>executes initially, the <strong class="source-inline">error</strong> value will be null. If, for some reason, the <a id="_idIndexMarker173"/>query function rejects and throws an error, then this error will be assigned to our <span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break"> variable.</span></p>
<p>In both the <strong class="source-inline">data</strong> and <strong class="source-inline">error</strong> examples, we checked if they were defined so that we could let our application users know the current status of our query. To make this easier and help you craft a better user experience for your application, the <strong class="source-inline">status</strong> variable <span class="No-Break">was added.</span></p>
<h3>status</h3>
<p>When performing <a id="_idIndexMarker174"/>a query, the query can go through <a id="_idIndexMarker175"/>several states. These states help you give more feedback to your user. For you to know what the current state of your query is, the <strong class="source-inline">status</strong> variable <span class="No-Break">was created.</span></p>
<p>Here are the states tha<a id="_idTextAnchor102"/>t the <strong class="source-inline">status</strong> variable <span class="No-Break">can have:</span></p>
<ul>
<li><strong class="source-inline">loading</strong>: No query attempt has finished and there is still no cached <span class="No-Break">data yet.</span></li>
<li><strong class="source-inline">error</strong>: There was an error while performing a query. Whenever this is the status, the <strong class="source-inline">error</strong> property will receive the error returned from the <span class="No-Break">query function.</span></li>
<li><strong class="source-inline">success</strong>: Your query <a id="_idIndexMarker176"/>was successful and it has <a id="_idIndexMarker177"/>returned data. Whenever this is the status, the <strong class="source-inline">data</strong> property will receive the successful data from the <span class="No-Break">query function.</span></li>
</ul>
<p>This is how you can use the <span class="No-Break"><strong class="source-inline">status</strong></span><span class="No-Break"> variable:</span></p>
<pre class="source-code">
const App = () =&gt; {
  const { <strong class="bold">status</strong>, error, data } = useQuery({
    queryKey: ["api"],
    queryFn: fetchData,
  });
  if(<strong class="bold">status === "loading"</strong>) {
    return &lt;div&gt;Loading...&lt;/div&gt;
  }
  if(<strong class="bold">status === "error"</strong>) {
    return &lt;div&gt;There was an unexpected error:
      {error.message}&lt;/div&gt;
  }
  return (
    &lt;div&gt;
       {data.hello}
    &lt;/div&gt;
  );
};</pre>
<p>In the preceding snippet, we are leveraging the <strong class="source-inline">status</strong> variable to create a better user experience for our users. This is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We start by destructuring the <strong class="source-inline">status</strong> variable from the <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook.</span></li>
<li>We check if <strong class="source-inline">status</strong> is loading. This means that we still don’t have any data and our query has finished. If this is the case, we render a <span class="No-Break">loading indicator.</span></li>
<li>If our <strong class="source-inline">status</strong> is not loading, we check if there was any error during our query. If our <strong class="source-inline">status</strong> equals <strong class="source-inline">error</strong>, then we need to destructure our <strong class="source-inline">error</strong> variable and display the <span class="No-Break">error message.</span></li>
<li>Finally, if our <strong class="source-inline">status</strong> is also not an error, then we can safely assume that our <strong class="source-inline">status</strong> equals success; therefore, we should have our <strong class="source-inline">data</strong> variable with the data our query function returned and we can display it to <span class="No-Break">our user.</span></li>
</ol>
<p>Now, you know <a id="_idIndexMarker178"/>how to use the <strong class="source-inline">status</strong> variable. For convenience, React <a id="_idIndexMarker179"/>Query also introduced some Boolean variants to help us identify each state. They are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">isLoading</strong>: Your <strong class="source-inline">status</strong> variable is in the <span class="No-Break">loading state</span></li>
<li><strong class="source-inline">isError</strong>:  Your <strong class="source-inline">status</strong> variable is in the <span class="No-Break">error state</span></li>
<li><strong class="source-inline">isSuccess</strong>: Your <strong class="source-inline">status</strong> variable is in the <span class="No-Break">success state</span></li>
</ul>
<p>Let’s rewrite our previous snippet leveraging our <strong class="source-inline">status</strong> <span class="No-Break">Boolean variants:</span></p>
<pre class="source-code">
const App = () =&gt; {
  const {  <strong class="bold">isLoading, isError</strong>, error, data } = useQuery({
    queryKey: ["api"],
    queryFn: fetchData,
  });
  if(<strong class="bold">isLoading</strong>) {
    return &lt;div&gt;Loading...&lt;/div&gt;
  }
  if(<strong class="bold">isError</strong>) {
    return &lt;div&gt;There was an unexpected error:
      {error.message}&lt;/div&gt;
  }
  return (
    &lt;div&gt;
       {data.hello}
    &lt;/div&gt;
  );
};</pre>
<p>As you can see, the <a id="_idIndexMarker180"/>code is similar. All we had to do was replace <a id="_idIndexMarker181"/>our <strong class="source-inline">status</strong> variable with <strong class="source-inline">isLoading</strong> and <strong class="source-inline">isError</strong> in the destructuring and then use the <strong class="source-inline">isLoading</strong> and <strong class="source-inline">isError</strong> variables in the respective <span class="No-Break">status check.</span></p>
<p>Now, the <strong class="source-inline">status</strong> variable gives you information about your query data. However, this is not the only status variable that React Query has. In the next section, you will be introduced <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">fetchStatus</strong></span><span class="No-Break">.</span></p>
<h3>fetchStatus</h3>
<p>With React Query v3, they <a id="_idIndexMarker182"/>found that there was an issue when handling <a id="_idIndexMarker183"/>scenarios where the user would go offline. If the user triggered a query but for some reason lost connection during the request, the <strong class="source-inline">status</strong> variable would stay pending in the loading state until the user got the connection back and the query was <span class="No-Break">automatically retried.</span></p>
<p>To deal with this type of issue, in React Query v4, they introduced a new property called <strong class="source-inline">networkMode</strong>. This property can have three states, but by default, it will use the online one. The good thing is that this mode enables you to use the <span class="No-Break"><strong class="source-inline">fetchStatus</strong></span><span class="No-Break"> variable.</span></p>
<p>The <strong class="source-inline">fetchStatus</strong> variable gives you information about your <span class="No-Break">query function.</span></p>
<p>Here are the states this variable <span class="No-Break">can have:</span></p>
<ul>
<li><strong class="source-inline">fetching</strong>: Your query function is currently executing. This means that it’s <span class="No-Break">currently fetching.</span></li>
<li><strong class="source-inline">paused</strong>: Your query <a id="_idIndexMarker184"/>wanted to fetch but due to a lost connection, it has <a id="_idIndexMarker185"/>now stopped executing. This means that it’s <span class="No-Break">currently paused.</span></li>
<li><strong class="source-inline">idle</strong>: The query is not doing anything at the moment. This means that it’s <span class="No-Break">currently idle.</span></li>
</ul>
<p>Now, let’s learn how to use the <span class="No-Break"><strong class="source-inline">fetchStatus</strong></span><span class="No-Break"> variable:</span></p>
<pre class="source-code">
const App = () =&gt; {
  const {  <strong class="bold">fetchStatus</strong>, data } = useQuery({
    queryKey: ["api"],
    queryFn: fetchData,
  });
  if(<strong class="bold">fetchStatus === "paused"</strong>) {
    return &lt;div&gt;Waiting for your connection to return…
      &lt;/div&gt;
  }
  if(<strong class="bold">fetchStatus === "fetching"</strong>) {
    return &lt;div&gt;Fetching…&lt;/div&gt;
  }
  return (
    &lt;div&gt;
       {data.hello}
    &lt;/div&gt;
  );
};</pre>
<p>In the preceding snippet, we are leveraging the <strong class="source-inline">fetchStatus</strong> variable to create a better user experience for our users. This is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We start by destructuring the <strong class="source-inline">fetchStatus</strong> variable from the return of our <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook.</span></li>
<li>We then check if the current state of our <strong class="source-inline">fetchStatus</strong> is paused. If this is <strong class="source-inline">true</strong>, then right now, there is no network connection, so we let our <span class="No-Break">user know.</span></li>
<li>If the previous <strong class="source-inline">If check</strong> is <strong class="source-inline">false</strong>, then we can validate if the current state of our <strong class="source-inline">fetchStatus</strong> is fetching. If the previous <strong class="source-inline">If check</strong> is <strong class="source-inline">true</strong>, then right now, the query function is running, so we let our <span class="No-Break">user know.</span></li>
<li>If we are not fetching, then we can assume our query function’s <strong class="source-inline">fetchStatus</strong> is idle; therefore, it has already finished fetching, so we should have the <span class="No-Break">returned data.</span></li>
</ol>
<p>Now, you know <a id="_idIndexMarker186"/>how to use the <strong class="source-inline">fetchStatus</strong> variable. Just like for <a id="_idIndexMarker187"/>the <strong class="source-inline">status</strong> variable, React Query also introduced some Boolean variants to help identify two of these statuses. They are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">isFetching</strong>: Your <strong class="source-inline">fetchStatus</strong> variable is in the <span class="No-Break">fetching state</span></li>
<li><strong class="source-inline">isPaused</strong>: Your <strong class="source-inline">fetchStatus</strong> variable is in the <span class="No-Break">paused state</span></li>
</ul>
<p>Let’s rewrite <a id="_idIndexMarker188"/>our previous snippet leveraging our <strong class="source-inline">fetchStatus</strong> <span class="No-Break">Boolean </span><span class="No-Break"><a id="_idIndexMarker189"/></span><span class="No-Break">variants:</span></p>
<pre class="source-code">
const App = () =&gt; {
  const { <strong class="bold">isFetching, isPaused</strong>, data } = useQuery({
    queryKey" [""pi"],
    queryFn: fetchData,
  });
  if(<strong class="bold">isPaused</strong>) {
    return &lt;div&gt;Waiting for your connection to return...
      &lt;/div&gt;
  }
  if(<strong class="bold">isFetching</strong>) {
    return &lt;div&gt;Fetching...&lt;/div&gt;
  }
  return (
    &lt;div&gt;
       {data.hello}
    &lt;/div&gt;
  );
};</pre>
<p>As you can see from the <a id="_idIndexMarker190"/>snippet, the code is quite similar. All we had to do was <a id="_idIndexMarker191"/>replace our <strong class="source-inline">fetchStatus</strong> variable with <strong class="source-inline">isFetching</strong> and <strong class="source-inline">isPaused</strong> in the destructuring and then use these <strong class="source-inline">isFetching</strong> and<a id="_idTextAnchor103"/> <strong class="source-inline">isPaused</strong> variables in the respective <span class="No-Break"><strong class="source-inline">fetchStatus</strong></span><span class="No-Break"> check.</span></p>
<p>Now that we are aware of the values our <strong class="source-inline">useQuery</strong> hook returns, let’s see how we can customize the same hook with the use of <span class="No-Break">some options.</span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor104"/>Commonly used options explained</h2>
<p>When using the <strong class="source-inline">useQuery</strong> hook, more options can be passed into it than the query key and query function. These options help you craft a better developer experience, as well as a better <span class="No-Break">user experience.</span></p>
<p>In this section, we’ll look at some options that are more common and very important for you to be <span class="No-Break">aware of.</span></p>
<p>Here are the options <span class="No-Break">we’ll cover:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">staleTime</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">cacheTime</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">retry</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">retryDelay</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">enabled</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">onSuccess</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">onError</strong></span></li>
</ul>
<h3>staleTime</h3>
<p>The <strong class="source-inline">staleTime</strong> option is the <a id="_idIndexMarker192"/>duration in milliseconds <a id="_idIndexMarker193"/>until query data is no longer considered <em class="it lic">fresh</em>. When the <a id="_idIndexMarker194"/>set time elapses, a query is <span class="No-Break">called </span><span class="No-Break"><em class="it lic">stale</em></span><span class="No-Break">.</span></p>
<p>While the query is <em class="it lic">fresh</em>, it will be pulled from the cache without triggering a new request to update the cache. When the query is marked as <em class="it lic">stale</em>, data will still be pulled from the cache but an automatic refetch <a id="_idTextAnchor105"/>of the query can <span class="No-Break">be triggered.</span></p>
<p>By default, all <a id="_idIndexMarker195"/>queries use <strong class="source-inline">staleTime</strong> set to <strong class="source-inline">0</strong>. This <a id="_idIndexMarker196"/>me<a id="_idTextAnchor106"/>ans that all cached data will be considered <em class="it lic">stale</em> <span class="No-Break">by default.</span></p>
<p>This is how we can <span class="No-Break">configure </span><span class="No-Break"><strong class="source-inline">staleTime</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
useQuery({
  staleTime: 60000,
});</pre>
<p>In this snippet, we define that the query data of this hook will be considered <em class="it lic">fresh</em> for <span class="No-Break">one minute.</span></p>
<h3>cacheTime</h3>
<p>The <strong class="source-inline">cacheTime</strong> option is <a id="_idIndexMarker197"/>the duration in milliseconds that the data in your cache <a id="_idIndexMarker198"/>that is inactive remains in memory. Once this time passes, the data will be <span class="No-Break">garbage collected.</span></p>
<p>By default, queries are marked as inactive when they have no active instance of a <strong class="source-inline">useQuery</strong> hook. When this happens, this query data will be held in the cache for 5 minutes. After these 5 minutes, this data will be <span class="No-Break">garbage collected.</span></p>
<p>This is how to use the <span class="No-Break"><strong class="source-inline">cacheTime</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useQuery({
  cacheTime: 60000,
});</pre>
<p>In the snippet, we define that after our query is inactive for 1 minute, the data will be <span class="No-Break">garbage collected.</span></p>
<h3>retry</h3>
<p>The <strong class="source-inline">retry</strong> option is a value <a id="_idIndexMarker199"/>that indicates whether your query will <a id="_idIndexMarker200"/>retry or not when it fails. When <strong class="source-inline">true</strong>, it will retry until it succeeds. When <strong class="source-inline">false</strong>, it <span class="No-Break">won’t retry.</span></p>
<p>This property can also be a number. When it is a number, the query will retry that specified number <span class="No-Break">of times.</span></p>
<p>By default, all queries that are failing will be retried <span class="No-Break">three times.</span></p>
<p>This is how to use the <span class="No-Break"><strong class="source-inline">retry</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useQuery({
  retry: false,
});</pre>
<p>In this snippet, we set the <strong class="source-inline">retry</strong> option as <strong class="source-inline">false</strong>. This means that when failing to fetch a query, this hook won’t retry to fetch <span class="No-Break">the data.</span></p>
<p>We can also configure the <strong class="source-inline">retry</strong> option <span class="No-Break">this way:</span></p>
<pre class="source-code">
useQuery({
  retry: 1,
});</pre>
<p>In this snippet, we set the <strong class="source-inline">retry</strong> option with the number <strong class="source-inline">1</strong>. This means that if this hook fails to fetch a query, then it will only retry the <span class="No-Break">request once.</span></p>
<h3>retryDelay</h3>
<p><strong class="source-inline">retryDelay</strong> option is the <a id="_idIndexMarker201"/>delay to apply before the next retry <a id="_idIndexMarker202"/>attempt <span class="No-Break">in milliseconds.</span></p>
<p>By default, React Query uses an exponential backoff delay algorithm to define the retry timing <span class="No-Break">between retries.</span></p>
<p>This is how to use the <span class="No-Break"><strong class="source-inline">retryDela<a id="_idTextAnchor107"/><a id="_idTextAnchor108"/>y</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useQuery({
  retryDelay: (attempt) =&gt; attempt * 2000,
});</pre>
<p>In the snippet, we define a linear backoff function as our <strong class="source-inline">retryDelay</strong> option. Every time there is a retry, this <a id="_idIndexMarker203"/>function receives the attempt number and multiplies <a id="_idIndexMarker204"/>it by <strong class="source-inline">2000</strong>. This means that the time between every retry will be 2 <span class="No-Break">seconds longer.</span></p>
<h3>enabled</h3>
<p>The <strong class="source-inline">enabled</strong> option is <a id="_idIndexMarker205"/>a Boolean value that indicates <a id="_idIndexMarker206"/>when your query can run <span class="No-Break">or not.</span></p>
<p>By default, this value is <strong class="source-inline">true</strong>, so all queries <span class="No-Break">are enabled.</span></p>
<p>This is how we can use <a id="_idTextAnchor109"/>the <span class="No-Break"><strong class="source-inline">enabled</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useQuery({
  enabled: arrayVariable.length &gt; 0
});</pre>
<p>In this snippet, we assign the return of the expression evaluation to the <strong class="source-inline">enabled</strong> option. This means that whenever the length of <strong class="source-inline">arrayVariable</strong> is greater than 0, this query <span class="No-Break">will execute.</span></p>
<h3>onSuccess</h3>
<p>The <strong class="source-inline">onSuccess</strong> option is <a id="_idIndexMarker207"/>a funct<a id="_idTextAnchor110"/>ion that will be triggered when your query is <a id="_idIndexMarker208"/>successful <span class="No-Break">while fetching.</span></p>
<p>This is how we can use the <span class="No-Break"><strong class="source-inline">onSuccess</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useQuery({
  onSuccess: (data) =&gt; console.log("query was successful",
    data),
});</pre>
<p>In this snippet, we pass an arrow function to our <strong class="source-inline">onSuccess</strong> option. When our query fetches successfully, this function will be called with our <strong class="source-inline">data</strong>. We then use this <strong class="source-inline">data</strong> to log to <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">console</strong></span><span class="No-Break">.</span></p>
<h3>onError</h3>
<p>The <strong class="source-inline">onError</strong> option is a <a id="_idIndexMarker209"/>function that will be triggered when <a id="_idIndexMarker210"/>your query fails <span class="No-Break">while fetching.</span></p>
<p>This is how we can use the <span class="No-Break"><strong class="source-inline">onError</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useQuery({
  onError: (error) =&gt; console.log("query was unsuccessful",
    error.message),
});</pre>
<p>In this snippet, we pass an arrow  function to our <strong class="source-inline">onError</strong> option. When the query fails, this function will be called with the <strong class="source-inline">thrown</strong> error. We then log the error in <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">console</strong></span><span class="No-Break">.</span></p>
<p>As you can see, the <strong class="source-inline">useQuery</strong> hook supports a lot of options and the ones that were presented were only the tip of the iceberg. In the upcoming sections and chapters, you’ll be introduced to more, so <span class="No-Break">prepare yourself!</span></p>
<p>You are now familiar with the <strong class="source-inline">useQuery</strong> hook and should be able to use it to start fetching your server state data. Now, let’s see some patterns and ways we can use this hook to deal with some common server <span class="No-Break">state challenges.</span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor111"/>Refetching data with useQuery</h1>
<p>Refetching is an important part <a id="_idIndexMarker211"/>of managing our server state. Sometimes, you <a id="_idIndexMarker212"/>need your data to be updated because <a id="_idIndexMarker213"/>your data has become stale or just because you haven’t interacted with your page in <span class="No-Break">a while.</span></p>
<p>Manually or automatically, React Query supports and allows you to refetch <span class="No-Break">your data.</span></p>
<p>In this section, we’ll see how it works and what automatic and manual ways you can leverage to refetch <span class="No-Break">your data.</span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor112"/>Automatic refetching</h2>
<p>React Query has <a id="_idIndexMarker214"/>baked in a couple of options to make your life easier and keep your server state fresh. To do this, it automatically takes care of data refetching in <span class="No-Break">certain cases.</span></p>
<p>Let’s look at the things that allow React Query to perform data <span class="No-Break">refetching automatically.</span></p>
<h3>Query keys</h3>
<p>Query keys are used <a id="_idIndexMarker215"/>to identify <span class="No-Break">your query.</span></p>
<p>When talking <a id="_idIndexMarker216"/>about query keys previously, I mentioned several times that we should include all of our query function dependencies as part of our query key. Why did I <span class="No-Break">say that?</span></p>
<p>Because whenever some of those dependencies change, so will your query key, and when your query key changes, <a id="_idTextAnchor113"/>your qu<a id="_idTextAnchor114"/>ery with be <span class="No-Break">automatically refetched.</span></p>
<p>Let’s look at the <span class="No-Break">following example:</span></p>
<pre class="source-code">
const [someVariable, setSomeVariable] = useState(0)
useQuery({
    queryKey: ["api", someVariable],
    queryFn: fetchData,
  });
return &lt;button onClick={() =&gt; setSomeVariable
  (someVariable + 1)}&gt; Click me &lt;/button&gt;</pre>
<p>In the preceding snippet, we define a <strong class="source-inline">useQuery</strong> hook that has <strong class="source-inline">someVariable</strong> as part of its query key. This query will be fetched on the initial render like usual, but when we click on our button, the <strong class="source-inline">someVariable</strong> value will change. The query key will also change, which will trigger a query refetch for you to get your <span class="No-Break">new data.</span></p>
<h3>Refetching options</h3>
<p>There are a couple <a id="_idIndexMarker217"/>of options I did not share in the <em class="it lic">Commonly used options explained</em> section. This is because they are enabled by default, and it is often better to leave them on unless they don’t suit your <span class="No-Break">use case.</span></p>
<p>Here are the options related to data refetching that <strong class="source-inline">useQuery</strong> has enabled <span class="No-Break">by default:</span></p>
<ul>
<li><strong class="source-inline">refetchOnWindowFocus</strong>: Whenever you focus on your current window, this option triggers a refetch. For example, if you change tabs when you return to your application, React Query will trigger a refetch of <span class="No-Break">your data.</span></li>
<li><strong class="source-inline">refetchOnMount</strong>: Whenever your hook mounts, this option triggers a refetch. For example, when a new component that uses your hook mounts, React Query will trigger a refetch of <span class="No-Break">your data.</span></li>
<li><strong class="source-inline">refetchOnReconnect</strong>: Whenever you lose your internet connection, this option will trigger <span class="No-Break">a refetch.</span></li>
</ul>
<p>One thing that is important to note is that these options will only refetch your data by default if your data is marked as stale. This refetching of data even if its stale can be configured since all these options, excluding the Boolean value, also support receiving a string with a value of <strong class="source-inline">always</strong>. When the value of these options is <strong class="source-inline">always</strong>, it will always retrigger a refetch, even if the data is <span class="No-Break">not stale.</span></p>
<p>This is how to <span class="No-Break">configure them:</span></p>
<pre class="source-code">
useQuery({
    refetchOnMount: "always",
    refetchOnReconnect: true,
    refetchOnWindowFocus: false
  });</pre>
<p>In the preceding snippet, we are doing <span class="No-Break">the following:</span></p>
<ul>
<li>For the <strong class="source-inline">refetchOnMount</strong> option, we always want our hook to refetch our data whenever any component using it mounts, even if the cached data is <span class="No-Break">not stale</span></li>
<li>For <strong class="source-inline">refetchOnReconnect</strong>, we want our hook to refetch our data whenever we regain connection after being offline, but only if our data <span class="No-Break">is stale</span></li>
<li>For <strong class="source-inline">refetchOnWindowFocus</strong>, we never want our hook to refetch our data on <span class="No-Break">window focus</span></li>
</ul>
<p>Now, one thing that might cross your mind is if there is any way to force our hook to refetch our data every couple of seconds, even if our data is not stale. Well, even if you didn’t think about it, React Query allows you to <span class="No-Break">do it.</span></p>
<p>React Query adds another refetch-related option called <strong class="source-inline">refetchInterval</strong>. This option allows you <a id="_idIndexMarker218"/>to specify a frequency in milliseconds for your query to <span class="No-Break">refetch data.</span></p>
<p>This is how we can <span class="No-Break">use it:</span></p>
<pre class="source-code">
useQuery({
    refetchInterval: 2000,
    refetchIntervalInBackground: true
  });</pre>
<p>In this snippet, we configure our hook to always refetch every 2 seconds. We also add another option called <strong class="source-inline">refetchIntervalInBackground</strong> with <strong class="source-inline">true</strong> as its value. This option will allow your query to keep refetching, even if your window or tab is in <span class="No-Break">the background.</span></p>
<p>This wraps up automatic refetching. Now, let’s see how we can trigger manual refetches in <span class="No-Break">our code.</span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor115"/>Manual refetching</h2>
<p>There are two <a id="_idIndexMarker219"/>ways to manually trigger a query refetch. You could use <strong class="source-inline">QueryClient</strong> or get the <strong class="source-inline">refetch</strong> function from <span class="No-Break">the hook.</span></p>
<h3>Using QueryClient</h3>
<p>As you may recall from <a id="_idIndexMarker220"/>the previous chapter, <strong class="source-inline">QueryClient</strong> allows <a id="_idIndexMarker221"/>you to have an interface between the developer and the query cache. This allows you to leverage <strong class="source-inline">QueryClient</strong> to force a data refetch <span class="No-Break">when needed.</span></p>
<p>This is how you can trigger a data refetch <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Que<a id="_idTextAnchor116"/>ryClient</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const queryClient = useQueryClient();
queryClient.refetchQueries({ queryKey: ["api"] })</pre>
<p>In the preceding <a id="_idIndexMarker222"/>snippet, we are doing <span class="No-Break">the following:</span></p>
<ul>
<li>Using <a id="_idIndexMarker223"/>the <strong class="source-inline">useQueryClient</strong> hook to get access to <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">QueryClient</strong></span><span class="No-Break">.</span></li>
<li>Using <strong class="source-inline">QueryClient</strong>, we are calling one of the functions it exposes, called <strong class="source-inline">refetchQueries</strong>. This function allows you to trigger a refetch of all the queries that match the given query key. In this snippet, we are triggering a request for all queries that have the <strong class="source-inline">["api"]</strong> <span class="No-Break">query key.</span></li>
</ul>
<h3>Using the refetch function</h3>
<p>Every <strong class="source-inline">useQuery</strong> hook <a id="_idIndexMarker224"/>exposes a <strong class="source-inline">refetch</strong> function for convenience. This <a id="_idIndexMarker225"/>function will allow yo<a id="_idTextAnchor117"/>u to trigger a refetch for just <span class="No-Break">that query.</span></p>
<p>This is how you can <span class="No-Break">do it:</span></p>
<pre class="source-code">
const { refetch } = useQuery({
    queryKey: ["api"],
    queryFn: fetchData,
  });
refetch()</pre>
<p>In this snippet, we are destructuring the <strong class="source-inline">refetch</strong> function from our <strong class="source-inline">useQuery</strong> hook. Then, we can call that function whenever we want to force that query <span class="No-Break">to refetch.</span></p>
<p>Now that you know how React Query enables you to manually and automatically refetch your data, let’s see how we can create queries that depend on <span class="No-Break">other queries.</span></p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor118"/>Fetching dependent queries with useQuery</h1>
<p>Sometimes, during <a id="_idIndexMarker226"/>our development process, we need <a id="_idIndexMarker227"/>to have values that are returned from one query that we can use in another query or have a que<a id="_idTextAnchor119"/>ry execution depend on a previous <a id="_idIndexMarker228"/>query. When this happens, we need to have what is called a <span class="No-Break">dependent query.</span></p>
<p>React Query allows you to make a query depend on others via the <span class="No-Break"><strong class="source-inline">enabled</strong></span><span class="No-Break"> option.</span></p>
<p>This is how you can <span class="No-Break">do it:</span></p>
<pre class="source-code">
const App = () =&gt; {
  const { data: firstQueryData } = useQuery({
    queryKey: ["api"],
    queryFn: fetchData,
  });
  const canThisDependentQueryFetch = firstQueryData?.hello
    !== undefined;
  const { data: dependentData } = useQuery({
    queryKey: ["dependentApi", firstQueryData?.hello],
    queryFn: fetchDependentData,
    enabled: canThisDependentQueryFetch,
  });
…</pre>
<p>In the preceding snippet, we are doing <span class="No-Break">the following:</span></p>
<ol>
<li>We are creating a query that will have <strong class="source-inline">["api"]</strong> as the query key and the <strong class="source-inline">fetchData</strong> function as the <span class="No-Break">query function.</span></li>
<li>Next, we are creating a Boolean variable called <strong class="source-inline">canThisDependentQueryFetch</strong> that will check if our previous query has the data we need. This Boolean variable will help us decide if our next query <span class="No-Break">can fetch.</span></li>
<li>Then, we are creating our second query with <strong class="source-inline">["dependentAPI", firstQuery<a id="_idTextAnchor120"/>Data?.hello]</strong> as the query key, the <strong class="source-inline">fetchDependentData</strong> function as the query function, and our <strong class="source-inline">canThisDependentQueryFetch</strong> as our <strong class="source-inline">Boolean</strong> variable for the <span class="No-Break"><strong class="source-inline">enabled</strong></span><span class="No-Break"> option.</span></li>
</ol>
<p>When the previous <a id="_idIndexMarker229"/>query finishes fetching the <a id="_idIndexMarker230"/>data, the <strong class="source-inline">canThisDependentQueryFetch</strong> Boolean will be set to <strong class="source-inline">true</strong> and enable this dependent query <span class="No-Break">to run.</span></p>
<p>As you can see, you only need the <strong class="source-inline">enabled</strong> option to make a query depend on anothe<a id="_idTextAnchor121"/>r one. Now, before wrapping up this chapter, let’s put all your earned knowledge <span class="No-Break">into practice.</span></p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor122"/>Putting it all into practice</h1>
<p>At this point, you <a id="_idIndexMarker231"/>should be able to start handling some use cases for data fetching using the <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook.</span></p>
<p>In this section, we will look at a file with three components called <strong class="source-inline">ComponentA</strong>, <strong class="source-inline">ComponentB</strong>, and <strong class="source-inline">ComponentC</strong> that are doing some data fetching. We will use this file to review the concepts we have learned abou<a id="_idTextAnchor123"/>t and see if we fully understood how <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> works.</span></p>
<p>Let’s start with the beginning of <span class="No-Break">the file:</span></p>
<pre class="source-code">
import { useQuery, useQueryClient } from "@tanstack/react-query";
const fetchData = async ({ queryKey }) =&gt; {
  const { apiName } = queryKey[0];
  const response = await fetch(
    `https://danieljcafonso.builtwithdark.com/${apiName}`
  );
  if (!response.ok) throw new Error("Something failed in
    your request");
  return response.json();
};
const apiA = "react-query-api";
const apiB = "react-query-api-two";</pre>
<p>This is what we are doing in the <span class="No-Break">preceding snippet:</span></p>
<ol>
<li>We import our <strong class="source-inline">useQuery</strong> and <strong class="source-inline">useQueryClient</strong> custom hooks from the React Query package to use in our components that will be defined in the next <span class="No-Break">few snippets.</span></li>
<li>We create a <strong class="source-inline">fetchData</strong> function that will receive our <strong class="source-inline">QueryFunctionContext</strong>. We then destructure our <strong class="source-inline">queryKey</strong> from it. Inside this function, we do <span class="No-Break">the following:</span><ol><li>We will be using <a id="_idIndexMarker232"/>an object as our query key in these examples so that we know that the first position of the array will have our query key properties, so we destructure our <strong class="source-inline">apiName</strong> <span class="No-Break">from it.</span></li><li>We use <strong class="source-inline">fetch</strong> to trigger a <strong class="source-inline">GET</strong> request to our URL and use <strong class="source-inline">apiName</strong> to help define <span class="No-Break">the route.</span></li><li>Because we are using <strong class="source-inline">fetch</strong> and not <strong class="source-inline">axios</strong>, we need to manually handle the scenario where our request failed. If our response is not OK, then we need to throw an error so that <strong class="source-inline">useQuery</strong> will be able to handle <span class="No-Break">error scenarios.</span></li><li>If our response is valid, then we can return our <span class="No-Break">response data.</span></li></ol></li>
<li>We then create <a id="_idIndexMarker233"/>two API constant values called <strong class="source-inline">apiA</strong> and <strong class="source-inline">apiB</strong> that define the route our components <span class="No-Break">will use.</span></li>
</ol>
<p>Now, let’s continue with our file and look at our first component, <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">ComponentA</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const ComponentA = () =&gt; {
  const { data, error, isLoading, isError, isFetching } =
    useQuery({
    queryKey: [{ queryIdentifier: "api", apiName: apiA }],
    queryFn: fetchData,
    retry: 1,
  });
  if (isLoading) return &lt;div&gt; Loading data... &lt;/div&gt;;
  if (isError)
    return (
      &lt;div&gt; Something went wrong... Here is the error:
        {error.message}&lt;/div&gt;
    );
  return (
    &lt;div&gt;
      &lt;p&gt;{isFetching ? "Fetching Component<a id="_idTextAnchor124"/> A..." :
        data.hello} &lt;/p&gt;
      &lt;ComponentB/&gt;
    &lt;/div&gt;
  );
};</pre>
<p>Let’s <span class="No-Break">review </span><span class="No-Break"><strong class="source-inline">ComponentA</strong></span><span class="No-Break">:</span></p>
<ol>
<li>We start by creating our query by using the <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook:</span><ol><li>This query is identified with an object as the query key. This object has <strong class="source-inline">api</strong> as the <strong class="source-inline">queryIdentifier</strong> property and <strong class="source-inline">apiA</strong> as the <span class="No-Break"><strong class="source-inline">apiName</strong></span><span class="No-Break"> property.</span></li><li>This query has the <strong class="source-inline">fetchData</strong> function as the <span class="No-Break">query function.</span></li><li>By using the <strong class="source-inline">retry</strong> option, we also specify that if this query fails to fetch, then the hook will only retry the request <span class="No-Break">one time.</span></li><li>We also destructure <strong class="source-inline">data</strong>, <strong class="source-inline">isLoading</strong>, <strong class="source-inline">isError</strong>, and <strong class="source-inline">isFetching</strong> from <span class="No-Break">the hook.</span></li></ol></li>
<li>If no query attempt has finished and there is still no cached data, we want to render to the user <a id="_idIndexMarker234"/>that we are loading data. We use <strong class="source-inline">isLoading</strong> with an <strong class="source-inline">If</strong> check to <span class="No-Break">do this.</span></li>
<li>If there was an error, we want to display it. We use <strong class="source-inline">isError</strong> to check if there was any error. If so, we render <span class="No-Break">that error.</span></li>
<li>If our query is not load<a id="_idTextAnchor125"/>ing or has an error, then we can assume it was successful. We then render a <strong class="source-inline">div</strong> with <span class="No-Break">the following:</span><ul><li>A <strong class="source-inline">p tag</strong> that will check if our hook <strong class="source-inline">isFetching</strong>. If it is fetching, it will display <strong class="source-inline">Fetching Component A</strong>. If not, it will display the <span class="No-Break">fetched data.</span></li><li><span class="No-Break">Our </span><span class="No-Break"><strong class="source-inline">ComponentB</strong></span><span class="No-Break">.</span></li></ul></li>
</ol>
<p>Now, let’s look <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">ComponentB</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const ComponentB = () =&gt; {
  const { data } = useQuery({
    queryKey: [{ queryIdentifier: "api", apiName: apiB }],
    queryFn: fetchData,
    onSuccess: (data) =&gt; console.log("Component B fetched
      data", data),
  });
  return (
    &lt;div&gt;
      &lt;span&gt;{data?.hello}&lt;/span&gt;<a id="_idTextAnchor126"/>
      &lt;ComponentC parentData={data} /&gt;
    &lt;/div&gt;
  );
};</pre>
<p>This is what <a id="_idIndexMarker235"/>we are doing <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ComponentB</strong></span><span class="No-Break">:</span></p>
<ol>
<li>We start by creating our query by using the <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook:</span><ol><li>This query is identified with an object as the query key. This object has <strong class="source-inline">api</strong> as the <strong class="source-inline">queryIdentifier</strong> property and <strong class="source-inline">apiB</strong> as the <span class="No-Break"><strong class="source-inline">apiName</strong></span><span class="No-Break"> property.</span></li><li>This query has the <strong class="source-inline">fetchData</strong> function as the <span class="No-Break">query function.</span></li><li>We use the <strong class="source-inline">onSuccess</strong> option and pass it a function that will receive our <strong class="source-inline">data</strong> and log it on our <strong class="source-inline">console</strong>, as well as an indication that this component has fetched <span class="No-Break">the data.</span></li><li>We also destructure <strong class="source-inline">data</strong> from <span class="No-Break">the hook.</span></li></ol></li>
<li>We then return a <strong class="source-inline">div</strong> to be rendered with <span class="No-Break">the following:</span><ul><li>Our <strong class="source-inline">hello</strong> property from our fetched data. One thing that you might see is that we used the <strong class="source-inline">?.</strong> operator. We leverage optional chaining here to make sure there is no error, and we only render our <strong class="source-inline">hello</strong> property when our data <span class="No-Break">is defined.</span></li><li>Our <strong class="source-inline">ComponentC</strong>. This component will receive our <strong class="source-inline">ComponentB</strong> data as its <span class="No-Break"><strong class="source-inline">parentData</strong></span><span class="No-Break"> prop.</span></li></ul></li>
</ol>
<p>Let’s wrap <a id="_idIndexMarker236"/>up our file revi<a id="_idTextAnchor127"/>ew by looking <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">ComponentC</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const ComponentC = ({ parentData }) =&gt; {
  const { data, isFetching } = useQuery({
    queryKey: [{ queryIdentifier: "api", apiName: apiA }],
    queryFn: fetchData,
    enabled: parentData !== undefined,
  });
  const queryClient = useQueryClient();
  return (
    &lt;div&gt;
      &lt;p&gt;{isFetching ? "Fetching Component C..." :
        data.hello} &lt;/p&gt;
      &lt;button
        onClick={() =&gt;
          queryClient.refetchQueries({
            queryKey: [{ queryIdentifier: "api",
              apiName: apiA }],
          })
        }
      &gt;
        Refetch Parent Data
      &lt;/button&gt;
    &lt;/div&gt;
  );
};
export default ComponentA;</pre>
<p>So, this is what is happening <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ComponentC</strong></span><span class="No-Break">:</span></p>
<ol>
<li>We start by creating our query <a id="_idTextAnchor128"/>by using the <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook:</span><ol><li>This query is identified with an object as the query key. This object has <strong class="source-inline">api</strong> as the <strong class="source-inline">queryIdentifier</strong> property and <strong class="source-inline">apiA</strong> as the <span class="No-Break"><strong class="source-inline">apiName</strong></span><span class="No-Break"> property.</span></li><li>This query has the <strong class="source-inline">fetchData</strong> function as the <span class="No-Break">query function.</span></li><li>We use the <strong class="source-inline">enabled</strong> option to make this query depend on <strong class="source-inline">parentData</strong>; therefore, this query will only run after the query in <strong class="source-inline">ComponentB</strong> finishes and <span class="No-Break">resolves data.</span></li><li>We destructure <strong class="source-inline">data</strong> and <strong class="source-inline">isFetching</strong> from <span class="No-Break">the hook.</span></li></ol></li>
<li>We use the <strong class="source-inline">useQueryClient</strong> hook to get access to <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">QueryClient</strong></span><span class="No-Break">.</span></li>
<li>Finally, we return a <strong class="source-inline">div</strong> that <a id="_idIndexMarker237"/>will be rendered with <span class="No-Break">the following:</span><ul><li>A <strong class="source-inline">p tag</strong> that will check if our hook <strong class="source-inline">isFetching</strong>. If it is fetching, it displays <strong class="source-inline">Fetching Component C</strong>. If not, it displays the <span class="No-Break">fetched data.</span></li><li>A button that, when clicked, will use <strong class="source-inline">queryClient</strong> to refetch the query whose query key has <strong class="source-inline">api</strong> as the <strong class="source-inline">queryIdentifier</strong> property and <strong class="source-inline">apiA</strong> as the <strong class="source-inline">apiName</strong> property. This means that on this button click, both <strong class="source-inline">useQuery</strong> in <strong class="source-inline">ComponentA</strong> and <strong class="source-inline">useQuery</strong> in <strong class="source-inline">ComponentC</strong> will refetch <span class="No-Break">some data.</span></li></ul></li>
</ol>
<p>Also, in the preceding snippet, we do a default export of our <strong class="source-inline">ComponentA</strong>, so it is the entry point in <span class="No-Break">this file.</span></p>
<p>Now that we’ve <a id="_idIndexMarker238"/>seen the code file, let’s review the life cycle of the h<a id="_idTextAnchor129"/><a id="_idTextAnchor130"/>ooks and understand what is happe<a id="_idTextAnchor131"/>ning in <span class="No-Break">the background:</span></p>
<ul>
<li>When <strong class="source-inline">ComponentA</strong> renders, the <span class="No-Break">following<a id="_idTextAnchor132"/> occurs:</span><ul><li>An instance of <strong class="source-inline">useQuery</strong> with the <strong class="source-inline">[{ queryIdentifier: "api", apiName: apiA }]</strong> query <span class="No-Break">key mounts:</span><ul><li>Since this is the first mount, there is no cache nor previous requests, so our query will start fetching o<a id="_idTextAnchor133"/>ur data, and its <strong class="source-inline">status</strong> will be loading. Also, our query fu<a id="_idTextAnchor134"/>nction will receive our query key as part <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">QueryFunctionContext</strong></span><span class="No-Break">.</span></li><li>When our data fetching succeeds, the data will be cached under the <strong class="source-inline">[{ queryIdentifier: "api", apiName: apiA }]</strong> <span class="No-Break">query key.</span></li><li>Since we are assuming the default <strong class="source-inline">staleTime</strong>, which is <strong class="source-inline">0</strong>, the hook will mark its data <span class="No-Break">as stale.</span></li></ul></li></ul></li>
<li>When <strong class="source-inline">ComponentA</strong> renders <strong class="source-inline">ComponentB</strong>, the <span class="No-Break">following occurs:</span><ul><li>An instance of <strong class="source-inline">useQuery</strong> with the <strong class="source-inline">[{ queryIdentifier: "api", apiName: apiB }]</strong> query <span class="No-Break">key mounts:</span><ul><li>Since this is the first mount, there is no cache nor previous requests, so our query will start fetching our data, and its <strong class="source-inline">status</strong> will be loading. Also, our query function will receive our query key as part <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">QueryFunctionContext</strong></span><span class="No-Break">.</span></li><li>When our data fetching succeeds, the data will be cached under the <strong class="source-inline">[{ queryIdentifier: "api", apiName: apiB }]</strong> query key and the hook will call the <span class="No-Break"><strong class="source-inline">onSuccess</strong></span><span class="No-Break"> function.</span></li><li>Since we are assuming the default <strong class="source-inline">staleTime</strong>, which is <strong class="source-inline">0</strong>, the hook will mark its da<a id="_idTextAnchor135"/>ta <span class="No-Break">as stale.</span></li></ul></li></ul></li>
<li>When <strong class="source-inline">ComponentB</strong> renders <strong class="source-inline">ComponentC</strong>, the <span class="No-Break">following occurs:</span><ul><li>An instance of <strong class="source-inline">useQuery</strong> with the <strong class="source-inline">[{ queryIdentifier: "api", apiName: apiA }]</strong> query <span class="No-Break">key mounts:</span><ul><li>As this hook has the same query key as the hook in <strong class="source-inline">ComponentA</strong>, the hook will already have cached data under it, so the data is <span class="No-Break">immediately accessible.</span></li><li>Since this query was marked as stale after the previous fetch, this hook needs to refetch it, but it needs to wait for the query to be enabled first since this query depends on us having the data of <span class="No-Break"><strong class="source-inline">ComponentB</strong></span><span class="No-Break"> first.</span></li><li>Once it’s been enabled, the query will trigger a refetch. This makes <strong class="source-inline">isFetching</strong> on both <strong class="source-inline">ComponentA</strong> and <strong class="source-inline">ComponentC</strong> to <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></li><li>Once the fetch request succeeds, the data will be cached under the <strong class="source-inline">[{ queryIdentifier: "api", apiName: apiA }]</strong> query key, and the query is marked as <span class="No-Break">stale <a id="_idTextAnchor136"/>again.</span></li></ul></li></ul></li>
<li>Now, considering it is <a id="_idIndexMarker239"/>the parent component, let’s picture a scenario where <span class="No-Break"><strong class="source-inline">ComponentA</strong></span><span class="No-Break"> unmounts:</span><ul><li>Since there is no longer any instance of the query with the <strong class="source-inline">[{ <a id="_idTextAnchor137"/>queryIdentifier: "api", apiName: apiA }]</strong> query key active, the default cache timeout of 5 minutes <span class="No-Break">is set</span></li><li>Once 5 minutes pass, the data under this query is deleted and <span class="No-Break">garbage collected</span></li><li>Since there is no longer any instance of the query with the <strong class="source-inline">[{ queryIdentifier: "api", apiName: apiB }]</strong> query key active, the default cache timeout of 5 minutes <span class="No-Break">is set</span></li><li>Once 5 minutes pass, the data under this query is deleted and <span class="No-Break">garbage collected</span></li></ul></li>
</ul>
<p>If you managed to keep track of this previous process and the life cycle of your queries during their usage, then congratulations: you understand how <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> works!</span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor138"/>Summary</h1>
<p>In this chapter, we learned about the <strong class="source-inline">useQuery</strong> custom hook and how it allows you to fetch and cache your data by using its required options, called query key and query function. You learned how to define your query key and how your query function allows you to use any data-fetching client such as GraphQL or REST, so long it returns a promise or throws <span class="No-Break">an error.</span></p>
<p>You also learned about some of the things that the <strong class="source-inline">useQuery</strong> hook returns, such as the query’s <strong class="source-inline">data</strong> and <strong class="source-inline">error</strong>. For you to craft a better user experience, you were also introduced to <strong class="source-inline">status</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">fetchStatus</strong></span><span class="No-Break">.</span></p>
<p>For you to customize your developer experience and take it to the next level, you learned about some commonly used options you can use to customize your <strong class="source-inline">useQuery</strong> hook and make it behave as you want it to. For your convenience, here are the compiled defaults to be <span class="No-Break">aware of:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">staleTime</strong></span><span class="No-Break">: 0</span></li>
<li><strong class="source-inline">cacheTime</strong>: 5 * 60 * 1,000 (<span class="No-Break">5 minutes)</span></li>
<li><span class="No-Break"><strong class="source-inline">retry</strong></span><span class="No-Break">: 3</span></li>
<li><strong class="source-inline">retryDelay</strong>: Exponential backoff <span class="No-Break">delay algorithm</span></li>
<li><span class="No-Break"><strong class="source-inline">enabled</strong></span><span class="No-Break">: True</span></li>
</ul>
<p>Before wrapping up, you learned about some patterns for dealing with server state challenges such as refetching and <span class="No-Break">dependent queries.</span></p>
<p>Finally, you put everything you learned into practice and reviewed an example that showed you how to leverage all this knowledge and how the <strong class="source-inline">useQuery</strong> hook works internally when <span class="No-Break">you do.</span></p>
<p>In <a href="B18501_05.xhtml#_idTextAnchor140"><span class="No-Break"><em class="it lic">Chapter 5</em></span></a>, <em class="it lic">More Data-Fetching Challenges</em>, you will continue to learn how you can use the <strong class="source-inline">useQuery</strong> hook to solve some more common server state challenges, such as data prefetching, paginated requests, and infinite queries. You will also put the DevTools to use to help you debug <span class="No-Break">your queries.</span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer022">
</div>
</div>
</div></body></html>