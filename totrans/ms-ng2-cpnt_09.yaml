- en: Chapter 9. Spaceship Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I was a child, I loved to play spaceship pilot. I piled up old carton boxes
    and decorated the interior to look like a spaceship cockpit. With a marker, I
    drew a spaceship dashboard on the inside of the boxes, and I remember playing
    in there for hours.
  prefs: []
  type: TYPE_NORMAL
- en: The thing that's special about the design of cockpits and spaceship dashboards
    is that they need to provide an overview and control over the whole spaceship
    on very limited space. I think the same also applies to application dashboards.
    A dashboard should provide the user with an overview and a sense for the overall
    status of what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will create such a dashboard for our task management application.
    We will make use of the open source charting library Chartist to create good looking
    responsive charts and provide an overview over open tasks and project status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spaceship Dashboard](img/image00340.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A preview of the tasks chart that we will build during the course of this chapter
  prefs: []
  type: TYPE_NORMAL
- en: 'On a higher level, we will create the following components in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project summary**: This is the project summary that will provide a quick
    insight into the overall project status. By aggregating all efforts of containing
    tasks, we can provide a nice overall efforts status, for which we have created
    the components in the previous chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project activity chart**: Without any labels or scales, this bar chart will
    just give a quick sense for the activity on projects in the last 24 hours.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project tasks chart**: This chart provides an overview of the task progress
    on projects. Using a line chart, we will display the count of open tasks over
    a certain time period. Using our Toggle component that we created in [Chapter
    2](part0020.xhtml#aid-J2B81 "Chapter 2. Ready, Set, Go!"), *Ready, Set, Go!*,
    of this book, we''ll provide an easy way for the user to switch the displayed
    timeframe on the chart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Chartist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create some components in this chapter that will render charts, and
    we should look for some help in rendering them. Of course, we can follow a similar
    approach as we did in [Chapter 6](part0044.xhtml#aid-19UOO1 "Chapter 6. Keeping
    Up with Activities"), *Keeping Up with Activities*, when we drew our activity
    timeline. However, when it comes to more complex data visualization, it's better
    to rely on a library to do the heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: It shouldn't be a surprise that we'll use Chartist to fill this gap because
    I've spent almost two years writing it. As the author of Chartist, I feel very
    lucky that we've found a perfect spot in this book to make use of it.
  prefs: []
  type: TYPE_NORMAL
- en: I'd like to take the opportunity to introduce you to Chartist briefly before
    we dive into the implementation of the components for our dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: The claim of Chartist is simple responsive charts, and this is luckily still
    the case after three years of existence. I can tell you that probably the hardest
    job of maintaining this library was to protect it from feature bloating. There
    are so many great movements, technologies, and ideas in the open source community
    and to resist and always stay focused on the initial claim wasn't easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me show you a very basic example of how you can create a simple line chart
    once you''ve included the Chartist scripts on your website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding HTML markup that is required for this example looks as simple
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows you the resulting chart that is rendered by Chartist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to Chartist](img/image00341.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A simple line chart rendered with Chartist
  prefs: []
  type: TYPE_NORMAL
- en: I believe that by saying that we've been sticking to our claim to stay simple,
    we've not promised too much.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the second core concern of Chartist, which is to be perfectly
    responsive. Well, let's start with one of my most appreciated principles in web
    development, which is the separation of concerns in the frontend. Chartist tries
    to stick to this separation wherever possible, which means that it uses CSS for
    its appearance, SVG for the basic graphical structure, and JavaScript for any
    behavior. Simply by following this principle, we've already enabled a lot of responsiveness.
    We can use CSS media queries to apply different styles to our charts on different
    media.
  prefs: []
  type: TYPE_NORMAL
- en: While CSS is great for visual styles, there are plenty of elements in the process
    of rendering charts, which can't be controlled simply by styling. After all, this
    is the reason why we use a JavaScript library to render charts.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we control how Chartist renders our charts on different media if
    we haven't got control over this in CSS? Well, Chartist provides something called
    responsive configuration overrides. Using the browsers `matchMedia` API, Chartist
    is able to provide a configuration mechanism that allows you to specify options
    that you want overridden on certain media.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look into a simple example of how we can easily implement responsive
    behavior using a mobile-first approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, the second parameter to the `Chartist.Line` constructor sets the initial
    options; we can provide overriding options annotated with media queries in an
    array as the third parameter of the constructor. In this example, we'll override
    the `showPoint` option for any media larger than 400 px in width. Media larger
    than 800 px in width will receive both the `showPoint` override as well as the
    `lineSmooth` override.
  prefs: []
  type: TYPE_NORMAL
- en: Not only can we specify real media queries to trigger setting changes, but we
    can also use an overriding mechanism that is very similar to CSS. This way, we
    can implement various approaches, such as ranged or exclusive media queries, mobile-first,
    or desktop-first. This responsive options mechanism can be used for all options
    available in Chartist.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to Chartist](img/image00342.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying the previous chart on three different media left to right, starting
    from a media with less than 400 px (A), less than 800 px (B), and more than 800
    px (C).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, implementing complex responsive behavior is a breeze with Chartist.
    Although our task management application was never meant to be a responsive web
    application, we can still benefit from this feature in order to optimize our content.
  prefs: []
  type: TYPE_NORMAL
- en: If I've tickled your fantasy with Chartist, I recommend that you check out the
    project's website at [http://gionkunz.github.io/chartist-js](http://gionkunz.github.io/chartist-js).
    On the website, you can also visit the live example page at [http://gionkunz.github.io/chartist-js/examples.html](http://gionkunz.github.io/chartist-js/examples.html),
    where you can hack some charts directly in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Projects dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll create a projects dashboard, which will consist of
    the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tasks chart**: This is where we''ll provide a visual overview on open tasks
    over time. All projects will be represented in a line chart that displays the
    progress of open tasks. We''ll also provide some user interaction so that the
    user can choose between different timeframes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Activity chart**: This component visualizes activities in a bar chart over
    a timeframe of 24 hours. This will help our users quickly identify overall and
    peak project activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project summary**: This is where we''ll display a summary of each project
    where we outline the most important facts. Our project summary component will
    also include an activity chart component that visualizes project activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Projects dashboard**: This component is just a composition of the previous
    two components. This is our main component in the dashboard. It represents our
    dashboard page and is directly exposed to the router.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the projects dashboard component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll create our main dashboard component. The `ProjectsDashboard`
    component has only two responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining project data, which is used to create the dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing the main dashboard layout by including our dashboard subcomponents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s jump right in and create a new component class on the path, `lib/projects-dashboard/projects-dashboard.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our `dashboard` component, we'll use the change observable of `ProjectService`
    directly. This is different to the usual way that we deal with observables. Usually,
    we'd subscribe to the observable in our component and then update our component
    whenever data streams through. However, in our projects dashboard, we're directly
    storing the change observable of `ProjectService` on our component.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use one of Angular's async core pipes in order to subscribe to the
    observable directly in our view.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing observables directly into the view and using the `async` pipe to subscribe
    to the observable comes with a main advantage.
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to deal with subscribing and unsubscribing in our component, as
    the `async` pipe will do that for us directly in the view.
  prefs: []
  type: TYPE_NORMAL
- en: When a new value is emitted within the observable, the `async` pipe will cause
    the underlying binding to be updated. Also, if the view gets destroyed because
    of any reason, the `async` pipe will automatically unsubscribe from the observable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By chaining RxJS operators together, we can bring an observable stream into
    the required shape without performing any subscription. Using the `async` pipe,
    we can then leave it up to the view to subscribe and unsubscribe from the transformed
    observable stream. This encourages us to write pure and stateless components,
    and when used correctly, this is a great practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the view of our component created in the `projects-dashboard.html`
    file in the same directory as the `Component` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the template that we use the `async` pipe to subscribe to the
    projects observable of our `Component` class. The `async` pipe will initially
    return `null`, but on any change in the observable, this will return the resolved
    value from the subscription. This means that we don't need to worry about subscribing
    to our project list observable. We can simply make use of the `async` pipe to
    subscribe and resolve directly in our view.
  prefs: []
  type: TYPE_NORMAL
- en: For the moment, we only displayed the project title and description, but in
    the next section, we will create a new project summary component that will deal
    with some more complex rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Project summary component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll create a `project-summary` component that will provide
    some overview information for projects. Besides the title and description, this
    will also include an overview over the total efforts on the project tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first build the component and make the necessary preparations so that
    we can display the total effort of the underlying tasks of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the Component class on the `lib/projects-dashboard/project-summary/project-summary.js`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you've probably already guessed, we reused the `EffortsTimeline` component
    that we created in the previous chapter. As our project summary will also include
    an efforts timeline, based on the same semantics as our total effort, there's
    no need to create a new component for this.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do, though, is to accumulate all task efforts into an overall
    effort. Using the `Array.prototype.reduce` function, we can accumulate all task
    efforts relatively easy.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting object from the reduce call needs to keep up with the format that
    is expected of an `efforts` object. As an initial value, we'll provide an `efforts`
    object with an estimated and effective time of zero. Then, the reduce callback
    will add any task effort values that are found in the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look into the template to see how we''re going to use this total efforts
    data to display our `EffortsTimeline` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After displaying the title and description of the project, we included the `EffortsTimeline`
    component, which we bind to the `totalEfforts` member that we just constructed.
    This timeline will now display the total aggregated amount of efforts logged on
    the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the timeline, we also rendered a formatted efforts text, such
    as the one that we already rendered in the `Efforts` component of the previous
    chapter. For this, we used the `FormatEffortsPipe` pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what's still left to do is to integrate our `ProjectSummary` component
    into the `ProjectsDashboard` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the template modification in the `projects-dashboard.html` component
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we bind the `project` local view variable, which was created
    by the `NgFor` directive in conjunction with the `async` pipe, to the `project`
    input property of our `ProjectSummary` component.
  prefs: []
  type: TYPE_NORMAL
- en: We also used the `RouterLink` directive to establish the navigation onto the
    `ProjectDetails` view if the user clicks on one of the summary tiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modifications in the `ProjectsDashboard` component class are negligible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The only modification that we applied to the `Component` class was to add the
    `ProjectSummary` component and the `ROUTER_DIRECTIVES` constant to the directives
    list of the component. The `ROUTER_DIRECTIVES` constant includes the `RouterOutlet`
    and `RouterLink` directives, and we use the latter in our template.
  prefs: []
  type: TYPE_NORMAL
- en: '![Project summary component](img/image00343.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A projects dashboard displaying two project summary components with the aggregated
    total effort
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so far so good. We created two new components and reused our `EffortsTimeline`
    component to create an aggregated view on the tasks efforts. In the next section,
    we will enrich our `ProjectSummary` component with a nice Chartist chart.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create our first chart using Chartist to provide a
    project activity overview over the past 24 hours. This bar chart will only provide
    some visual clues about the project activity, and our goal is not to make it provide
    detailed information. For this reason, we will configure it to hide any labels,
    scales, and grid lines. The only visible part should be the bars of the bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start creating the activity chart itself, we need to look at how we
    need to transform and prepare our data for the charts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at what data we already have in our system. As far as the activities
    go, they all have a timestamp on them stored in the `time` field. However, for
    our chart, we want something else displayed. What we're looking for is a chart
    that displays one bar for each hour of the past 24 hours. Each bar should represent
    the count of activities in that timeframe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustration shows our source data, which is basically a time
    stream of activity events. On the lower arrow, we see the data that we need to
    end up with for our chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first chart](img/image00344.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An illustration displaying activities as a time stream where the dots represent
    activities. The lower arrow is showing a rasterized count by hour for the last
    24 hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a function that does the transformation outlined in this image.
    We''ll add this function to our `time-utilities` module on the `lib/utilities/time-utilities.js`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the input parameters of our newly-created function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timeData`: This parameter is expected to be an array of objects that contains
    a `time` property that is set to the timestamp of the event that should be counted.
    The objects should also contain a `weight` property, which is used to count. Using
    this property, we can count one event as two or even count minus values to decrease
    the count in a raster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeFrame`: This parameter specifies the time span of each raster in milliseconds.
    If we want to have 24 rasterized frames, each consisting of one hour this parameter
    needs to be set to 3,600,000 (1 h = 60 min = 3,600 s = 3,600,000 ms).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quantity`: This parameter sets the amount of rasterized frames that should
    be present in the output array. In the case of 24 frames of one hour, this parameter
    should be set to 24.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`now`: This is when our function is rasterizing time, starting at a given point
    in time backwards. The `now` parameter sets this point in time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fill`: This is how we can specify how we''d like our rasterized output array
    to be initialized. In the case of our activity counts, we want this to be set
    to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function that we just created is necessary to create the activity chart.
    The transformation helps us prepare project activities for the input data of the
    chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to create our first chart component! Let''s start with a new template
    created on the `lib/projects-dashboard/project-summary/activity-chart/activity-chart.html`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we leave all the rendering up to Chartist, this is actually already all that
    we need. Chartist needs an element as a container to create the chart in. We set
    a `chartContainer` local view reference so that we can reference it from our component,
    and then pass it to Chartist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on with the chart creation, and flesh out the activity chart component
    by creating the `Component` class in `activity-chart.js` in the same directory
    as the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chartist is available for almost all package managers, and it also comes bundled
    in the **UMD** module format (**Universal Module Format**), which, in fact, is
    a wrapper to enable **AMD** (**Asynchronous Module Definition**), CommonJS module
    format, and global export.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using JSPM, we can simply install Chartist by executing the following command
    on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After installing Chartist, we can directly import it using ES6 module syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We also import the rasterize function that we created so that we can use it
    later to convert our activities into the expected input format for our chart.
  prefs: []
  type: TYPE_NORMAL
- en: As we rely on a view child as a container element to create our chart, we need
    to wait for the `AfterViewInit` lifecycle hook in order to construct the chart.
    At the same time, we need to rerender the chart if the input `activities` change.
    Using the `OnChanges` lifecycle hook, we can react on input changes and update
    our chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the `createOrUpdateChart` function, which does exactly what
    its name already implies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look into the code in more detail and walk through it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: As we get called both from the `AfterViewInit` and `OnChanges` lifecycle, we
    need to make sure that both the `chartContainer` and `activities` inputs are ready
    before we continue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it's time to convert the activity data that we receive as input into the
    rasterized form that is required for the chart that we'd like to create. We use
    `Array.prototype.map` to transform our activities into the `timeData` objects
    that are required by the `rasterize` function. We also pass the necessary parameters
    so that the function will rasterize into 24 frames, each consisting of one hour.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `chart` member is already set to a chart that was previously created,
    we can use the `update` function on the Chartist chart object to only update with
    the new data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there's no chart object already, we need to create a new chart. As a first
    parameter to the `Chartist.Bar` constructor, we'll pass the DOM element reference
    of our container view child. Chartist will create our chart in this container
    element. The second argument is our data, which we fill with the series that was
    just generated. In the chart options, we'll set everything to achieve a very plain-looking
    chart without any detailed information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is great! We created our first chart component using Chartist! Now, we
    can go back to our `ProjectSummary` component and integrate the activity chart
    there to provide an activity overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first change here is to include the `ActivityService` so that we can extract
    the required project activities to pass them to the `ActivityChart` component.
    We also need to import the `ActivityChart` component and declare it as a directive
    on the component.
  prefs: []
  type: TYPE_NORMAL
- en: As our component relies on the project to be provided as input, which is subject
    to change, we need to implement the logic to extract activities in the `OnChanges`
    lifecycle hook of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Before we pass on the observable activities stream, we need to filter the activities
    that come through the stream so that we only get activities that are relevant
    to the current project. Again, we will use the `async` pipe in order to subscribe
    to the activities so that there's no need to use a subscribe form within the component.
    The `activities` property will be directly set to a filtered `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the changes in the view of the `ProjectSummary` component in
    order to enable our chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We add our `ActivityChart` component at the bottom of the already existing template.
    We also create the necessary binding to pass our activities into the component.
    Using the `async` pipe, we can resolve the observable stream and pass the filtered
    activities list into the `chart` component.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our `ProjectSummary` component looks great and immediately provides
    a project insight by displaying the aggregated efforts timeline and a nice activity
    chart. In the next section, we'll dive a bit deeper into the charting capabilities
    of Chartist, and we will also provide some interactivity using Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing open tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create a chart component using Chartist, which will
    display the open task progress of projects over time. To do this, we'll use a
    line chart with a specific interpolation that provides quantized steps rather
    than lines with directly connected points.
  prefs: []
  type: TYPE_NORMAL
- en: We are also providing some interactivity in that the user will be able to switch
    the displayed time frame using a toggle button. This allows us to reuse the `Toggle`
    component that we created in [Chapter 2](part0020.xhtml#aid-J2B81 "Chapter 2. Ready,
    Set, Go!"), *Ready, Set, Go!,* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first look at the data that we have in our system and how we can transform
    it into the data needed by Chartist.
  prefs: []
  type: TYPE_NORMAL
- en: We can rely on two data attributes of our tasks in order to draw them onto a
    timeline. The `created` attribute is set to the timestamp at the moment when the
    task was created. If a task is marked as done, the `done` attribute is set to
    the timestamp at that time.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''re only interested in the amount of open tasks at any given time, we
    can safely presume a model where we put all tasks onto a single timeline and where
    we are only concerned about the `created` and `done` timestamps as events. Let''s
    look at the following illustration to get a better understanding of the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing open tasks](img/image00345.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An illustration that shows how we can represent all task timelines on a single
    timeline using the created and done events. The created events count as a +1,
    while the done events count as -1.
  prefs: []
  type: TYPE_NORMAL
- en: The lower arrow is a representation of all tasks of the `created` and `done`
    events on a timeline. We can now use this information as input to our `rasterize`
    function in order to get the data that we need for our chart. As the `timeData`
    objects that are used as input for the rasterization also support a `weight` property,
    we can use this to represent the `created (+1)` or `done (-1)` events.
  prefs: []
  type: TYPE_NORMAL
- en: We need to make a slight modification to our rasterize function. So far, the
    rasterize function only counts events together in frames. However, for the open
    task counts, we look into an accumulation over time. If the task count changes,
    we need to keep the value until it changes again. In transformation of activities
    in the previous topic, we didn't use this same logic. There, we only counted events
    inside frames, but there was no accumulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following illustration to see the difference as compared
    to the rasterization that we applied while processing activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing open tasks](img/image00346.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An illustration that shows how we can accumulate the open tasks count over time
  prefs: []
  type: TYPE_NORMAL
- en: We can count each `weight` property of the `timeData` objects (events) together
    over time. Only if there's a change of the accumulated value, we will write the
    current accumulated value into the rasterized output array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open our `time-utilities` module and apply the changes to the `rasterize`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s walk through the changes that we applied to the `rasterize` function
    to allow accumulation of frames:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we added a new parameter to our function with the name `accumulate`.
    We used the ES6 default parameters to set the parameter to `false` if no value
    was passed into the function when called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now define a new `accumulatedValue` variable, which we initialize with `0`.
    This variable will be used to keep track of the sum of all `weight` values over
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next bit of code is very important. If we want to accumulate the sum of
    all `weight` values over time, we need to make sure that these values come in
    sequence. In order to ensure this, we sort the `timeData` list by its items `time`
    attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `reduce` callback, we increase the `accumulatedValue` variable by the
    `weight` value of the current `timeData` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `timeData` object falls into a rasterized frame, we do not increase this
    frame's count like we did before. In accumulation mode, we set the frames count
    to the current value in `accumulatedValue`. This will result in all changed accumulated
    values being reflected in the rasterized output array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is all the preparation that we need to process the date in order to render
    our open tasks chart. Let's move on and create the `Component` class of our new
    `chart` component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an open tasks chart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following component, we will utilize the refactored `rasterize` function
    of the previous topic. Using the new accumulate function, we can now track open
    task counts over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `Component` class in a new `lib/projects-dashboard/tasks-chart/tasks-chart.js`
    file to implement our `Component` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So far, this looks exactly like our first `chart` component where we visualized
    project activities. We also imported Chartist as we will use it to render our
    chart in the `createOrUpdateChart` function that we'll create shortly. The chart
    that we will create will contain much more detailed information. We will render
    both axis labels and some scales. In order to format our labels that basically
    contain timestamps, we use the Moment.js library once again.
  prefs: []
  type: TYPE_NORMAL
- en: We also use the `projects` input data and transform it with the amended `rasterize`
    utility function in order to prepare all the data for our line chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on and flesh out the `createOrUpdateChart` method of our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, that''s quite a bit of code here. Let''s walk through it step by step
    to gain a better understanding of what''s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create our transformed series data by mapping the projects
    list. The series array should include one data array for each project. Each data
    array will contain the open project tasks over time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the `rasterize` function expects a list of `timeData` objects, we first need
    to transform the projects task list into this format. By reducing the task list,
    we create a single list of the `timeData` objects. The `reduce` function callback
    will generate one `timeData` object with a `weight` of 1 for each task. Additionally,
    it will generate a `timeData` object for each task marked as one with the `weight`
    value -1\. This will result in the desired `rimeData` array, which we can use
    to accumulate and rasterize.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After preparing the `timeData` list, we can call the `rasterize` function in
    order to create a list of open tasks over a certain amount of timeframes. We use
    a 10 minute timeframe (600000ms) and rasterize this with 144 frames. This makes
    a total of 24 hours.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Besides the series data, we will also need labels for our chart. We create a
    new array and initialize this with 144 timestamps, all of which are set to the
    start of the 144 rasterized frames that we display on the chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have the series data and the labels ready, and all that's left to do
    is to render our chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `lineSmooth` configuration, we can specify a special kind of interpolation
    for our line chart. The step interpolation will not connect each point in our
    line chart directly, but rather it will move in discrete steps to move from point
    to point. This is exactly what we're looking for to render the open task counts
    over time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting the `fillHoles` option to `true` in the step interpolation is very important.
    Using this setting, we can actually tell Chartist that it should close any gaps
    within the data (actually null values) and connect the line to the next valid
    value. Without this setting, we'd see gaps on the chart between the task count
    changes in our data arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One last important thing in our code is the `labelInterpolationFnc` option that
    we set on the *x* axis configuration. This function can not only be used to format
    a label or interpolate any expression that may come along with the label, but
    it also allows us to return null instead. Returning null from this function will
    cause Chartist to skip the given label and the corresponding grid line. This is
    very useful if we'd like to skip certain labels by their value or by the index
    of the label. In our code, we ensure that we only render four labels of all 144
    generated labels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the rather simple template of our component in the `tasks-chart.html`
    file in the same folder as our `Component` class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The same as with the `ActivityChart` component, we only create a simple chart
    container element, which we already reference in our `Component` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is basically all that we needed to do in order to create an open tasks
    chart using Chartist. However, there''s still some room for improvement here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an open tasks chart](img/image00347.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Open tasks visualized with our tasks chart component using Chartist's step interpolation
  prefs: []
  type: TYPE_NORMAL
- en: Creating a chart legend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, there's no way to tell exactly which of the lines represents what
    project. We see one colored line for each project, but we can't associate these
    colors. What we need is a simple legend that helps our users to associate line
    chart colors to projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the required code changes to implement legends on our chart.
    In the `Component` class of our `TasksChart` component, we need to perform the
    following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the `OnChanges` lifecycle hook, we map the projects input to a list of objects
    that contain a `name` and `class` property, which will support us in rendering
    a simple legend. The template `` `tasks-chart__series--series-${index + 1}` ``
    string will generate the necessary class name to render the right color into our
    legend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this legend information, we can now go ahead and implement the necessary
    template changes to render the legend in our `chart` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that was a piece of cake, right? However, the result speaks for itself.
    We created a nice legend for the chart in just a couple of minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a chart legend](img/image00348.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Open tasks chart with our added legend
  prefs: []
  type: TYPE_NORMAL
- en: Making tasks chart interactive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, we hardcoded the timeframe of our open task chart to be 144 frames,
    each of 10 minutes, making a total of 24 hours displayed to the user. However,
    maybe our users would want to change this view.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will create a simple input control using our `Toggle` component,
    which allows our users to change the timeframe settings of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will provide the following views as options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day:** This view will rasterize 144 frames, each consisting of 10 minutes,
    which makes a total of 24 hours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Week:** This view will rasterize 168 frames, each consisting of one hour,
    which makes a total of seven days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Year:** This view will rasterize 360 frames, each representing a full day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the implementation of our timeframe switch by modifying the
    `Component` class code of the `TasksChart` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through these changes briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we added a constructor to our `Component` class in which we initialized
    three new members. The `timeFrames` member is set to an array of timeframe description
    objects. They contain the `name`, `timeFrame`, and `amount` properties, which
    are later used for the calculations. The `timeFrameNames` member contains a list
    of timeframe names, which is directly derived from the `timeFrames` list. Finally,
    we have a `selectedTimeFrame` member, which simply points to the first available
    timeframe object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `createOrUpdateChart` function, we no longer rely on hardcoded values
    for the task count rasterization, but we refer to the data in the `selectedTimeFrame`
    object. By changing this object reference and calling the `createOrUpdateChart`
    function again, we can now switch the view on the underlying data dynamically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we added a new `onSelectedTimeFrameChange` method, which acts as a
    binding to the `Toggle` component, and this will be called whenever the user selects
    a different timeframe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at the necessary template changes to enable switching of timeframes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: From the bindings to the `Toggle` component, you can already tell that we rely
    on the `timeFrameNames` member on our component to represent all selectable timeframes.
    We also bind to the `selectedButton` input property of the `Toggle` component
    using the `selectedTimeFrame.name` property. On changes of the selected button
    in the `Toggle` component, we call the `onSelectedTimeFrameChange` function, where
    the timeframe is switched and the chart is updated.
  prefs: []
  type: TYPE_NORMAL
- en: This is all that we need to enable switching the timeframe on our chart. The
    user can now choose between the year, week, and day views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `TasksChart` component is now ready to be integrated into our dashboard.
    We can achieve this with some small changes to the template of our `ProjectsDashboard`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is basically all that we need to make, and after this change, our dashboard
    contains our nice chart displaying open task counts over time.
  prefs: []
  type: TYPE_NORMAL
- en: In the binding of the `TasksChart` projects input property, we use the `async`
    pipe once again to resolve the observable stream of projects directly in the view.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Chartist and how to use it in conjunction
    with Angular to create good looking and functional charts. We can leverage the
    power of both worlds, and create reusable chart components that are nicely encapsulated.
  prefs: []
  type: TYPE_NORMAL
- en: Just like in most real cases, we always have a lot of data, but the one that
    we need in a particular case. We learned how we can transform existing data into
    a form that is optimized for visual representation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at building a plugin system in our application.
    This will allow us to develop portable functionality that is packaged into plugins.
    Our plugin system will load new plugins dynamically, and we will use it to develop
    a simple agile estimation plugin.
  prefs: []
  type: TYPE_NORMAL
