- en: '*Chapter 12*: Managing Authentication and User Sessions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：管理认证和用户会话'
- en: In the previous chapters, we've seen how to work with some of the fundamental
    Next.js features. We learned how to choose between rendering strategies and how
    those can influence SEO and performance. We also learned how to style our application
    using built-in and external styling methods and libraries, managing the application
    state, integrating with external APIs, and many other valuable things.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用一些基本的Next.js功能。我们学习了如何在渲染策略之间进行选择以及这些策略如何影响SEO和性能。我们还学习了如何使用内置和外部样式方法和库来设计我们的应用，管理应用状态，集成外部API，以及许多其他有价值的内容。
- en: Starting with this chapter, we will begin to learn and develop real-world applications
    by combining the lessons learned in the past sections with industry-standard strategies
    to keep our applications secure, performant, and highly optimized in every aspect.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将通过结合之前学到的课程和行业标准策略，开始学习和开发实际应用，以保持我们的应用在各个方面都安全、高效和高度优化。
- en: In this chapter, we will see how to manage user session and authentication,
    an essential part of every highly dynamic web application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何管理用户会话和认证，这是每个高度动态的Web应用的一个基本部分。
- en: 'We will cover the following topics in detail:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细介绍以下主题：
- en: How to integrate our application with a custom authentication service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将我们的应用与自定义认证服务集成
- en: How to use industry-standard service providers such as Auth0, NextAuth.js, and
    Firebase
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用行业标准的服务提供商，如Auth0、NextAuth.js和Firebase
- en: How to keep sessions between page changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在页面变化之间保持会话
- en: How to keep user data secure and private
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保用户数据的安全和隐私
- en: By the end of this chapter, you will be able to authenticate users and manage
    their sessions on any Next.js app, be aware of the differences between different
    authentication strategies, and even adopt a custom one.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够对Next.js应用中的用户进行认证和管理他们的会话，了解不同认证策略之间的差异，甚至采用一个自定义的认证策略。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine. If you prefer, you can use an online IDE
    such as [https://repl.it](https://repl.it) or [https://codesandbox.io](https://codesandbox.io);
    they both support Next.js, and you don''t need to install any dependency on your
    computer. As for the other chapters, you can find the code base for this chapter
    on GitHub: [https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，您需要在您的本地机器上安装Node.js和npm。如果您愿意，可以使用在线IDE，例如[https://repl.it](https://repl.it)或[https://codesandbox.io](https://codesandbox.io)；它们都支持Next.js，您不需要在您的计算机上安装任何依赖项。至于其他章节，您可以在GitHub上找到本章的代码库：[https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js)。
- en: A brief introduction to user sessions and authentication
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户会话和认证的简要介绍
- en: When talking about user authentication, we refer to that process that identifies
    a specific user, letting them read, write, update, or delete any protected content,
    depending on their authorization level.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到用户认证时，我们指的是识别特定用户的过程，根据他们的授权级别，让他们读取、写入、更新或删除任何受保护的内容。
- en: 'A typical example could be a simple blogging system: we can publish, edit,
    or even delete content only after authenticating ourselves.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子可能是一个简单的博客系统：我们只能在验证身份后发布、编辑甚至删除内容。
- en: 'There are many different authentication strategies, but the most common are:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的认证策略，但最常见的是：
- en: '**Credentials-based authentication**: This method allows us to log in to a
    system using personal credentials, commonly, an email address and a password.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于凭证的认证**：这种方法允许我们使用个人凭证登录系统，通常是一个电子邮件地址和密码。'
- en: '**Social login**: We can log in to a system using our social accounts (Facebook,
    Twitter, LinkedIn, and so on).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社交登录**：我们可以使用我们的社交账户（Facebook、Twitter、LinkedIn等）登录系统。'
- en: '**Passwordless login**: Over recent years, this has become a pretty popular
    authentication method. Platforms such as Medium and Slack will send you what''s
    called a "magic link" to your email address, letting you enter your account without
    typing any password.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无密码登录**：近年来，这种方法已经成为一种相当流行的认证方式。例如Medium和Slack这样的平台会向您发送所谓的“魔法链接”到您的电子邮件地址，让您无需输入任何密码即可登录您的账户。'
- en: '**Single sign-on (SSO)**: If you''ve worked in a big company, you may have
    experienced this. Services such as Okta provide a way of using unique credentials
    for many different services, centralizing user authentication over their own service.
    Once you log in to an SSO system, it will redirect you to the desired website,
    granting your identity.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单点登录（SSO）**：如果你在大公司工作过，你可能经历过这种情况。例如，Okta等服务提供了一种使用唯一凭证访问许多不同服务的方法，通过它们自己的服务集中用户认证。一旦你登录到SSO系统，它将把你重定向到所需的网站，并授予你的身份。'
- en: But once we log in to a system, we want it to remember us, so we don't have
    to authenticate ourselves on every page change during our navigation. This is
    where session management kicks in.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但一旦我们登录到系统，我们希望它记住我们，这样我们就不必在导航过程中每次页面变化时都进行认证。这就是会话管理介入的地方。
- en: 'Again, there are many ways to manage user sessions. If you''re familiar with
    PHP, you may know that it provides a built-in method for controlling the user
    session. Let''s look at the following code snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，管理用户会话有许多方法。如果你熟悉PHP，你可能知道它提供了一个内置方法来控制用户会话。让我们看看下面的代码片段：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a typical example of server-side session management.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的服务器端会话管理示例。
- en: It creates a session cookie and keeps track of all the properties linked to
    that session. So, for example, we could associate a logged-in user email or username
    with that session, and every time we render a page, we can do it depending on
    the authenticated user data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了一个会话cookie，并跟踪与该会话相关联的所有属性。例如，我们可以将登录用户的电子邮件或用户名与该会话关联，每次我们渲染页面时，我们都可以根据认证用户的数据来完成。
- en: We can refer to this strategy as a *stateful session* as the user state is kept
    on the server side and linked to the client via a specific session cookie.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种策略称为*状态化会话*，因为用户状态保存在服务器端，并通过特定的会话cookie与客户端关联。
- en: While managing stateful sessions is relatively easy during the prototyping phase,
    things tend to get a bit more complex once you begin to scale in production.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在原型设计阶段管理状态化会话相对容易，但一旦你开始在生产中进行扩展，事情往往会变得复杂一些。
- en: In the previous chapter, we talked about deploying our application to Vercel,
    AWS, or any other managed hosting platform. Let's take Vercel as an example, as
    it is the most straightforward (yet optimized) one for hosting our Next.js web
    app. We've seen how every API and SSR page gets rendered on a serverless function,
    right? Now imagine, in that scenario, how is it possible to keep a server-side
    stateful session when we don't even have a server to manage?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了将我们的应用程序部署到Vercel、AWS或其他任何托管平台。以Vercel为例，因为它是最直接（但也是优化过的）用于托管我们的Next.js
    Web应用程序的平台。我们已经看到了每个API和SSR页面是如何在无服务器函数上渲染的，对吧？现在想象一下，在这种情况下，当我们甚至没有服务器来管理时，如何保持服务器端的状态化会话？
- en: Let's pretend we're rendering a welcome page for our users after they sign in.
    We can set a session cookie, but every instance of server-side stateful data will
    be canceled after the Lambda function terminates its execution. So how do we keep
    the session? What will happen once the users exit this page? The server-side session
    will be lost, and they will need to re-authenticate again.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们在用户登录后为他们渲染一个欢迎页面。我们可以设置一个会话cookie，但每当Lambda函数终止其执行时，每个服务器端状态化数据实例都将被取消。那么我们如何保持会话？一旦用户离开这个页面会发生什么？服务器端会话将会丢失，他们需要重新进行认证。
- en: This is where the concept of *stateless sessions* can really help.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是*无状态会话*概念真正发挥作用的地方。
- en: Instead of setting a session cookie that links a server-side session to the
    frontend, we want to release some information that identifies the user on every
    new request. Every time the authenticated user sends a request to the backend,
    they must follow an authorization mechanism, such as passing a specific cookie
    or an HTTP header. On every new request, the server will take this information,
    validate it, recognize the user (if the passed cookie or header is valid), and
    then serve the desired content.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想设置一个将服务器端会话与前端关联的会话cookie，我们希望释放一些信息，以识别每个新请求中的用户。每当认证用户向后端发送请求时，他们必须遵循一个授权机制，例如传递特定的cookie或HTTP头。在每次新请求中，服务器将获取这些信息，验证它们，识别用户（如果传递的cookie或头是有效的），然后提供所需的内容。
- en: An industry-standard approach that follows this pattern is *JWT-based* authentication,
    but we will discuss this in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一种遵循此模式的行业标准方法是*JWT（JSON Web Tokens）基于的*认证，但我们将在这个下一节中讨论。
- en: Understanding JSON web tokens
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JSON Web Tokens
- en: As written on the [https://jwt.io](https://jwt.io) website, a **JWT** (short
    for **JSON Web Token**) is an open, industry-standard *RFC 7519* method for representing
    claims securely between two parties.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如[https://jwt.io](https://jwt.io)网站所述，**JWT**（即**JSON Web Token**）是一种开放、行业标准的*RFC
    7519*方法，用于在双方之间安全地表示声明。
- en: To keep it simple, we can think of JWTs as three distinct base64-encoded JSON
    chunks of data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们可以将JWT视为三个不同的base64编码的JSON数据块。
- en: 'Let''s take the following JWT as an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下面的JWT为例：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we pay enough attention, we can see three different chunks of data separated
    by periods.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们足够注意，我们可以看到由句点分隔的三个不同的数据块。
- en: 'The first part represents the JWT header. It contains two essential pieces
    of information: the token type and the algorithm used for signing it (we will
    talk more about that in just a second).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分代表JWT头。它包含两个基本信息：令牌类型和用于签名的算法（我们将在下一秒讨论更多关于这一点的内容）。
- en: The second part is the payload. Here is where we put all the non-sensitive data
    that can help us identify our users. *Never store data such as passwords and bank
    details inside a JWT payload*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是有效负载。在这里，我们放置所有可以帮助我们识别用户的不敏感数据。*永远不要在JWT有效负载中存储如密码和银行详情等数据*。
- en: The third and last part of a JWT token is its signature. This is what makes
    JWTs secure, and we will talk about that in detail later in this section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JWT令牌的第三部分和最后一部分是其签名。这就是JWT令牌之所以安全的原因，我们将在本节稍后详细讨论。
- en: 'If we decode our JWT token with any client library or a dedicated website such
    as [https://jwt.io](https://jwt.io), we will see the following JSON data:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用任何客户端库或专门的网站（如[https://jwt.io](https://jwt.io)）解码我们的JWT令牌，我们将看到以下JSON数据：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first chunk tells us that the given token is a JWT signed using the HS256
    algorithm.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分告诉我们，给定的令牌是使用HS256算法签名的JWT。
- en: The second chunk gives us some helpful information about the user, such as the
    JWT subject (typically the user ID), the username, and the timestamp of when we
    issued the token.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数据块为我们提供了有关用户的一些有用信息，例如JWT主题（通常是用户ID）、用户名以及我们签发令牌的时间戳。
- en: JWT Payload Best Practices
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JWT有效负载最佳实践
- en: The official *RFC7519* specifies some optional payload properties, such as `"sub"`
    (subject), `"aud"` (audience), `"exp"` (expiration time), and more. Even though
    they are optional, it is best practice to implement them in accordance with the
    official RFC specification, which can be found at [https://datatracker.ietf.org/doc/html/rfc7519#section-4](https://datatracker.ietf.org/doc/html/rfc7519#section-4).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的*RFC7519*指定了一些可选的有效负载属性，例如`"sub"`（主题）、`"aud"`（受众）、`"exp"`（过期时间）等。尽管它们是可选的，但最佳实践是根据官方RFC规范实现它们，该规范可在[https://datatracker.ietf.org/doc/html/rfc7519#section-4](https://datatracker.ietf.org/doc/html/rfc7519#section-4)找到。
- en: Once we need personal user data, we can set this JWT as a cookie or use it as
    a bearer token inside an HTTP authorization header. Once the server gets this
    data, it will verify the token, and here is where the third token section becomes
    essential.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们需要个人用户数据，我们可以将JWT作为cookie设置，或者将其用作HTTP授权头中的bearer令牌。一旦服务器获取这些数据，它将验证令牌，这就是第三令牌部分变得至关重要的地方。
- en: As we have already seen, the third part of any JWT is its signature. Let's keep
    things easy again and make an elementary example of why (and how) we want to sign
    our JWT tokens.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，任何JWT的第三部分是其签名。让我们再次保持简单，并举例说明为什么（以及如何）我们想要对JWT令牌进行签名。
- en: 'It is pretty easy for anyone to decode a JWT token; it is just a base64-encoded
    JSON, so we can use JavaScript built-in functions to decode it, manipulate it
    (by adding an `"admin": true` property, for example), and then encode it again
    in the required format.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '对任何人来说，解码JWT令牌都非常简单；它只是一个base64编码的JSON，因此我们可以使用JavaScript内置函数来解码它，对其进行操作（例如添加`"admin":
    true`属性），然后再以所需的格式重新编码它。'
- en: 'It would be tremendous if it were so easy to hack a JWT token, right? The good
    news is: decoding, manipulating, and then encoding the token again is not enough.
    We also need to sign it using the same secret code used on the server that issued
    the JWT.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JWT令牌如此容易被破解，那会非常糟糕，对吧？好消息是：解码、操作然后再次编码令牌是不够的。我们还需要使用在签发JWT的服务器上使用的相同密钥对其进行签名。
- en: 'For instance, we could use the `jsonwebtoken` library to generate a token for
    our user as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`jsonwebtoken`库为我们用户生成令牌，如下所示：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We would end up with the following JWT token:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终会得到以下JWT令牌：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now want to verify it, just to make sure that it works as expected:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要验证它，只是为了确保它按预期工作：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In that library, the `jwt.verify` method returns the decoded payload once the
    signature has been verified. If the verification fails, it will throw an error.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个库中，`jwt.verify`方法在签名验证成功后返回解码后的有效载荷。如果验证失败，它将抛出一个错误。
- en: 'We can test this by copying and pasting the preceding JWT on the [https://jwt.io](https://jwt.io)
    home page. It will allow us to edit it freely, so we can try to set the `"admin":
    true` claim to our JWT:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以通过复制并粘贴前面的JWT到[https://jwt.io](https://jwt.io)首页来测试这一点。它将允许我们自由编辑，因此我们可以尝试将`"admin":
    true`声明设置到我们的JWT中：'
- en: '![Figure 12.1 – Editing the JWT token on https://jwt.io'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – 在 https://jwt.io 上编辑JWT令牌'
- en: '](img/Figure_12.01_B16985.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.01_B16985.jpg)'
- en: Figure 12.1 – Editing the JWT token on https://jwt.io
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 在 https://jwt.io 上编辑JWT令牌
- en: 'As you may notice, the web app will update the JWT token as soon as we type
    something in the header or payload section. Once we''re done with our edits, we
    can finally test it with our script:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，Web应用将立即在我们在头部或有效载荷部分输入内容时更新JWT令牌。一旦我们完成编辑，我们就可以用我们的脚本最终测试它：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we try to verify this token, we will see the following error to be thrown
    in the console:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们尝试验证这个令牌，我们将在控制台看到以下错误：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And that''s what makes a JWT secure: everyone could potentially read and manipulate
    it. But once you do it, you''re not able to sign it using a valid signature as
    it remains secret and hidden on the server side.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这一点使得JWT安全：每个人都可以潜在地读取和操作它。但一旦你这样做，你就无法使用有效的签名来签名它，因为它在服务器端保持秘密和隐藏。
- en: In the next section, we will see a practical example of integrating JWT authentication
    into a Next.js app.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到一个将JWT认证集成到Next.js应用中的实际示例。
- en: Custom authentication – the good, the bad, and the ugly
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义认证 – 好的、坏的和不那么好的
- en: 'Let''s make this clear from the outset: when possible, we should avoid implementing
    custom authentication strategies. There are several great providers (including
    Auth0, Firebase, AWS Cognito, and Magic.link, just to name a few) that are putting
    a lot of effort into making authentication secure, reliable, and optimized for
    many different situations. When investigating authentication strategies for a
    web app, I''d highly recommend looking into a well-established service provider
    as this is possibly one of the most critical aspects of a dynamic web application.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一开始就明确这一点：在可能的情况下，我们应该避免实现自定义认证策略。有多个优秀的提供商（包括Auth0、Firebase、AWS Cognito和Magic.link等，仅举几个例子）正在投入大量精力使认证安全、可靠，并针对许多不同情况进行优化。在调查Web应用的认证策略时，我强烈建议考虑一个成熟的供应商，因为这可能是动态Web应用最关键的部分之一。
- en: 'In this section, we''re looking into creating a custom authentication mechanism
    for a simple reason: we just want to understand at a high level how authentication
    works, how to make it as secure as possible, and what the critical factors of
    a custom auth system are.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们正在探讨为简单原因创建自定义认证机制：我们只是想从高层次上了解认证是如何工作的，如何使其尽可能安全，以及自定义认证系统的关键因素是什么。
- en: As we'll find out during this section, there will be several limitations when
    implementing custom authentication mechanisms. For instance, I'd highly discourage
    implementing client-side authentication on statically generated websites as it
    forces us to authenticate users on the client side exclusively, possibly exposing
    sensitive data to the network.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本节中发现的那样，在实现自定义认证机制时将存在一些限制。例如，我强烈反对在静态生成的网站上实现客户端认证，因为它迫使我们仅在客户端进行用户认证，可能将敏感数据暴露给网络。
- en: For that reason, we will create a new Next.js web application that will use
    the API routes for communicating with a data source (typically a database) and
    retrieving the user data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建一个新的Next.js Web应用，该应用将使用API路由与数据源（通常是数据库）进行通信并检索用户数据。
- en: 'So, let''s start by creating a new, empty Next.js app:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先创建一个新的、空的Next.js应用：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once the boilerplate code is ready, we can start writing the login API. Please
    keep in mind that the following code is not meant to go to production; we're just
    taking a simplified, high-level overview of how authentication works.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备好样板代码，我们就可以开始编写登录API。请注意，以下代码并不打算用于生产；我们只是在简化、高层次地概述认证的工作原理。
- en: 'Let''s start by creating a `/pages/api/login.js` file by exporting the following
    function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个`/pages/api/login.js`文件开始，该文件通过导出以下函数：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is where we will handle the user input and authenticate it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们处理用户输入并进行验证的地方。
- en: 'The first thing we can do is to take the user input and filter the request
    method to accept POST requests only:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一件事是获取用户输入并过滤请求方法，只接受POST请求：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Why Do We Need to Filter POST Requests?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么需要过滤POST请求？
- en: By default, all the Next.js API routes accept any HTTP method. By the way, it
    is best practice to allow only specific methods on certain routes, for example,
    enabling `POST` requests when creating new content, `GET` when reading data, `PUT`
    when modifying something, or `DELETE` for deleting data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有Next.js API路由都接受任何HTTP方法。顺便说一句，在特定路由上只允许特定方法是最佳实践，例如，在创建新内容时启用`POST`请求，在读取数据时启用`GET`，在修改内容时启用`PUT`，或在删除数据时启用`DELETE`。
- en: We can now validate the user input. When validating an email and password, for
    example, we could check that the passed email is in a valid format and that the
    password is following a particular policy. That way, if any of the given data
    is not valid, we can just reply with a `401` status code (unauthorized) as we
    won't find any occurrence in the database for that email and password combination.
    That would also help us to avoid useless database calls.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以验证用户输入。例如，在验证电子邮件和密码时，我们可以检查传递的电子邮件是否在有效格式中，以及密码是否遵循特定的策略。这样，如果任何给定的数据无效，我们只需回复一个`401`状态码（未授权），因为我们不会在数据库中找到该电子邮件和密码组合的任何记录。这也有助于我们避免无用的数据库调用。
- en: 'Right now, we don''t have a database, and we will rely on hardcoded values
    as we only want to understand authentication at a high level. That said, we will
    only check whether the request body contains an email and a password, so we can
    keep it simple:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们没有数据库，我们将依赖于硬编码的值，因为我们只想从高层次上理解认证。话虽如此，我们只会检查请求体中是否包含电子邮件和密码，因此我们可以保持简单：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the email or password doesn't exist in the request body, we will return a
    `400` status code (bad request) with an error message explaining why the request
    failed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求体中不存在电子邮件或密码，我们将返回一个`400`状态码（错误请求）并附带一个错误信息，解释请求失败的原因。
- en: If the request is sent using the HTTP POST method and provides both an email
    and password, we can process them using any authentication mechanism. For example,
    we could look up a user with that specific email in the database, retrieve their
    password, and then verify it on the server side or ask for an external authentication
    service to do that for us.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求使用HTTP POST方法发送并提供电子邮件和密码，我们可以使用任何认证机制来处理它们。例如，我们可以在数据库中查找具有该特定电子邮件的用户，检索他们的密码，然后在服务器端验证它或请求外部认证服务为我们完成这项工作。
- en: Right now, given that we're just taking an overview of custom authentication
    strategies, we will use an elementary function that checks the combination of
    email and password against two fixed strings. Again, this is not meant for production
    usage.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，鉴于我们只是在概述自定义认证策略，我们将使用一个基础的函数来检查电子邮件和密码的组合是否与两个固定的字符串匹配。再次强调，这并不是为了生产使用。
- en: 'Inside the same `pages/api/login.js` file, we can create a very elementary
    function that can do that for us:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个`pages/api/login.js`文件中，我们可以创建一个非常基础的函数来为我们完成这项工作：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In a production environment, we will never use such an authentication function.
    Instead, we will communicate with a database or external service to dynamically
    retrieve the user data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，我们永远不会使用这样的认证函数。相反，我们将与数据库或外部服务通信，以动态检索用户数据。
- en: 'We can finally combine the preceding function with our API handler. If the
    passed data is correct, we will get some user data back and send it to the client.
    Otherwise, we''ll just send a `401` status code (unauthorized) with an error explaining
    that the passed data is incorrect:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于可以将前面的函数与我们的API处理器结合起来。如果传递的数据是正确的，我们将获取一些用户数据并将其发送给客户端。否则，我们只需发送一个`401`状态码（未授权）并附带一个错误信息，解释传递的数据是不正确的：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, we could start analyzing the risks of this approach. Let's pretend
    for a moment that we will log in from the frontend, the server will reply with
    such information, and we will store it in a cookie. Once we need to get more data
    about (let's say) our user, we could just submit a request to the server, which
    will read the cookie, get the current user ID, and then query the database for
    their data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以开始分析这种方法的潜在风险。让我们假设一下，我们将从前端登录，服务器将回复这样的信息，我们将将其存储在cookie中。一旦我们需要获取更多关于（比如说）我们的用户的数据，我们只需向服务器提交一个请求，服务器将读取cookie，获取当前用户ID，然后查询数据库以获取他们的数据。
- en: Can you see the point of failure of such a solution?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出这种解决方案的失败点吗？
- en: Everyone could potentially edit their cookies by just using the developer tools
    built into every modern web browser. This means that everyone could just read
    the cookie, change it, and impersonate another user without even logging in.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都可能通过使用每个现代网络浏览器内置的开发者工具来编辑他们的Cookies。这意味着每个人都可以简单地读取Cookie，更改它，并且可以冒充另一个用户，甚至不需要登录。
- en: Why Are We Talking about Cookies?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要讨论Cookies？
- en: Cookies are a good solution for storing session data. We could use different
    browser features, such as `localStorage`, `sessionStorage`, or even `indexedDB`.
    The problem is, everyone could steal this data by just injecting a malicious script
    into your web page. When dealing with cookies, we can (and we should) set an `httpOnly`
    flag to `true` to make cookies available on the server side only. That adds an
    extra layer of security when storing this data. Even though we should be aware
    that every user can have access to cookies by inspecting them using the dev tools
    provided by modern browsers, we should never share sensitive information there.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies是存储会话数据的好方法。我们可以使用不同的浏览器功能，如`localStorage`、`sessionStorage`，甚至`indexedDB`。问题是，任何人都可以通过在你的网页中注入恶意脚本来窃取这些数据。在处理Cookies时，我们可以（并且我们应该）将`httpOnly`标志设置为`true`，以便仅在服务器端提供Cookies。这为存储这些数据添加了一个额外的安全层。尽管我们应该意识到，每个用户都可以通过使用现代浏览器提供的开发者工具来检查Cookies，但我们绝不应该在那里共享敏感信息。
- en: This is where JWTs can help. We can simply edit our login handler to make it
    a bit more secure by setting a cookie containing a JWT before returning any data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是JWT可以发挥作用的地方。我们可以简单地编辑我们的登录处理程序，通过在返回任何数据之前设置包含JWT的Cookie来使其更加安全。
- en: 'Let''s start by installing the `jsonwebtoken` npm package:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装`jsonwebtoken`npm包开始：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s create a new file, `lib/jwt.js`, and add the following content:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新文件，`lib/jwt.js`，并添加以下内容：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, going back to our `pages/api/login.js` file, we can edit it by encoding
    the user payload into a JWT:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的`pages/api/login.js`文件，我们可以通过将用户有效负载编码成JWT来编辑它：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'One last thing: we said we wanted to set a cookie containing the JWT we just
    created. We can install a handy library that can help us achieve that:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：我们说过我们想要设置一个包含我们刚刚创建的JWT的Cookie。我们可以安装一个方便的库来帮助我们实现这一点：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once installed, we can edit our `pages/api/login.js` file by setting the session
    cookie:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以通过设置会话Cookie来编辑我们的`pages/api/login.js`文件：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we're creating a cookie named `my_auth`, which will contain
    the user JWT. We won't pass the JWT to the client directly as we want to keep
    it hidden from any potential malicious script running on the client side.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在创建一个名为`my_auth`的Cookie，它将包含用户JWT。我们不会直接将JWT传递给客户端，因为我们希望将其隐藏在客户端上可能运行的任何潜在恶意脚本之外。
- en: 'We can inspect whether the procedure is working as expected by testing it with
    useful HTTP clients such as Postman or Insomnia (you can download Insomnia for
    free here: [https://insomnia.rest](https://insomnia.rest)):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用Postman或Insomnia等有用的HTTP客户端来测试该过程是否按预期工作（你可以免费下载Insomnia：[https://insomnia.rest](https://insomnia.rest)）：
- en: '![Figure 12.2 – The login API response in Insomnia'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – Insomnia中的登录API响应'
- en: '](img/Figure_12.02_B16985.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.02_B16985.jpg)'
- en: Figure 12.2 – The login API response in Insomnia
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – Insomnia中的登录API响应
- en: 'If we move to the **Cookie** tab in the response section of our tool of choice
    (in my case, Insomnia), we can eventually see the authentication cookie:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换到我们选择工具（在我的情况下，是Insomnia）的响应部分的**Cookie**标签页，我们最终可以看到认证Cookie：
- en: '![Figure 12.3 – The authentication cookie in Insomnia'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 – Insomnia中的认证Cookie'
- en: '](img/Figure_12.03_B16985.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.03_B16985.jpg)'
- en: Figure 12.3 – The authentication cookie in Insomnia
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – Insomnia中的认证Cookie
- en: 'It''s finally time to manage the authentication on the client side by creating
    a login form and a protected route, only visible after the login. So, let''s start
    from there: let''s create a new `/pages/protected-route.js` file with the following
    content:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在客户端通过创建登录表单和受保护的路由来管理认证了，只有登录后才能看到这些路由。所以，让我们从这里开始：让我们创建一个包含以下内容的新的`/pages/protected-route.js`文件：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can tell by looking at the `ProtectedRoute` function, we're not preventing
    anonymous users from browsing that page; we'll get there in a moment, right after
    creating the login page.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`ProtectedRoute`函数，你可以看出我们并没有阻止匿名用户浏览该页面；我们将在创建登录页面后立即做到这一点。
- en: 'Let''s also create the `/styles/app.module.css` file, where we''ll put all
    the styling for our app; we''re not aiming to make an award-winning UI, so we''ll
    just create a couple of simple styles there:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一个 `/styles/app.module.css` 文件，我们将在这里放置我们应用程序的所有样式；我们并不旨在制作一个获奖的UI，所以我们只需在那里创建几个简单的样式：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can start concentrating on the login. Let''s create a new page, `/pages/login.js`,
    and start writing the login UI:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始专注于登录。让我们创建一个新的页面，`/pages/login.js`，并开始编写登录UI：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before creating the missing `handleSubmit` function, let''s add a couple of
    styles to the `styles/app.module.css` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建缺少的 `handleSubmit` 函数之前，让我们向 `styles/app.module.css` 文件添加一些样式：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now write the `handleSubmit` function. Here, we will catch the form
    submit event, prevent the browser''s default behavior (to submit a request to
    a remote API), and handle the two possible cases for our login: success and failure.
    If the login succeeds, we will redirect the user to our protected page. If it
    fails, we''ll set an error inside our `loginError` state:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写 `handleSubmit` 函数。在这里，我们将捕获表单提交事件，阻止浏览器默认行为（向远程API提交请求），并处理我们登录的两个可能情况：成功和失败。如果登录成功，我们将重定向用户到我们的受保护页面。如果失败，我们将在
    `loginError` 状态中设置一个错误：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''re now missing one last function, the one that is responsible for making
    the login API request. We can create it outside the `Home` component since, during
    the testing phase, we may want to test it individually:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在缺少最后一个函数，即负责发起登录API请求的函数。由于在测试阶段，我们可能想单独测试它，所以我们可以将其创建在 `Home` 组件外部：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can finally test our login page and see whether it's working correctly! If
    it does, we should get redirected to our private route; otherwise, we should see
    a friendly error message displayed under the form submit button.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以最终测试我们的登录页面，看看它是否工作正常！如果它确实工作，我们应该被重定向到我们的私有路由；否则，我们应该在表单提交按钮下方看到一个友好的错误消息。
- en: 'Now it''s time to protect our private page. If we aren''t logged in, we shouldn''t
    be able to see it. A similar thing should apply to the login page: once we''re
    logged in, we shouldn''t be able to see it.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候保护我们的私有页面了。如果我们没有登录，就不应该能看到它。类似的事情也应该适用于登录页面：一旦我们登录，就不应该能看到它。
- en: Before proceeding any further with the implementation, we should decide how
    to implement authentication in our app.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续实施之前，我们应该决定如何在我们的应用程序中实现认证。
- en: We could render our pages on the server side to check the cookies on each request
    (remember? We don't want to access auth cookies on the client side!), or we could
    just render a loader on the frontend and wait for a hook to check whether we're
    logged in before rendering the actual page content.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在服务器端渲染我们的页面来检查每个请求的cookie（记得吗？我们不想在客户端访问认证cookie！），或者我们可以在前端简单地渲染一个加载器，并在渲染实际页面内容之前等待钩子检查我们是否已登录。
- en: What should we consider before making such a choice?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这样的选择之前，我们应该考虑什么？
- en: There are several scenarios where this choice could have an impact. For example,
    let's think of SEO; if we're building a blog where only logged-in users can (for
    example) post comments, that's not a big deal. We can send a statically generated
    page and wait for a hook to tell us whether the user is authenticated. Meanwhile,
    we could just render the public content (such as the article body, author, and
    tags), so the SEO wouldn't be impacted. The user will be able to comment as soon
    as the client knows that they're logged in.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种情况可能会影响这个选择。例如，让我们考虑SEO；如果我们正在构建一个只有登录用户可以（例如）发表评论的博客，那不是什么大问题。我们可以发送一个静态生成的页面，并等待钩子告诉我们用户是否已认证。同时，我们可以渲染公共内容（如文章正文、作者和标签），这样SEO就不会受到影响。用户一旦客户端知道他们已登录，就可以立即发表评论。
- en: Also, the performances would be great, as we could serve a statically generated
    page with dynamic data rendered on the client side exclusively.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，性能将非常出色，因为我们可以用静态生成的页面来提供，动态数据将在客户端独立渲染。
- en: As an alternative, we could simply get the user cookie on the server side, validate
    the JWT, and then render the page depending on the user authentication status;
    that might be a bit easier to implement (we can do that inside the `getServerSideProps`
    built-in function), but will undoubtedly add some delay, and will force us to
    render all the pages on the server side.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，我们可以在服务器端简单地获取用户cookie，验证JWT，然后根据用户的认证状态渲染页面；这可能更容易实现（我们可以在内置的 `getServerSideProps`
    函数内部做这个），但无疑会增加一些延迟，并迫使我们必须在服务器端渲染所有页面。
- en: We will implement the first solution, where we'll need to create a custom hook
    to determine whether the user is logged in.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实施第一个解决方案，其中我们需要创建一个自定义钩子来决定用户是否已登录。
- en: 'To do that, we''ll first need to implement an API that parses our cookies and
    replies with the bare minimum information about our session. Let''s do that by
    creating a `pages/api/get-session.js` file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们首先需要实现一个API，该API解析我们的cookie并回复关于我们会话的最基本信息。让我们通过创建一个`pages/api/get-session.js`文件来实现这一点：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now log in using the form we just created and then call the API over
    `http://localhost:3000/api/get-session`. We will see a result similar to the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们刚刚创建的表单进行登录，然后通过`http://localhost:3000/api/get-session`调用API。我们将看到以下类似的结果：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we call the same API within an incognito session, we would only get a `{
    "loggedIn": false }` response.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们在隐身会话中调用相同的API，我们只会得到一个`{ "loggedIn": false }`的响应。'
- en: 'We can use this API to determine whether the user is logged in by creating
    a custom hook. Let''s do that by creating a `lib/hooks/auth.js` file with the
    following content:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个自定义钩子来使用这个API来确定用户是否已登录。让我们通过创建一个包含以下内容的`lib/hooks/auth.js`文件来实现这一点：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The hook itself is pretty simple. As soon as it's loaded (so, when the `useEffect`
    React hook is triggered), it will make an HTTP call to our `/api/get-session`
    API. Once the API succeeds (or fails), it will return the user status, errors
    (if any), and set the `loading` status to `false`, so we will know that it's time
    to re-render the UI.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子本身很简单。一旦它加载（也就是说，当`useEffect` React钩子被触发时），它将向我们的`/api/get-session` API发起HTTP调用。一旦API成功（或失败），它将返回用户状态、错误（如果有），并将`loading`状态设置为`false`，这样我们就会知道是时候重新渲染UI了。
- en: 'We can finally implement this hook in our protected page by just importing
    it and displaying the private content depending on the authentication status:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过导入它并根据认证状态显示私有内容来在我们的受保护页面上实现这个钩子：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can now try to reach our private page and see whether it is working correctly
    once logged in! First, there should be a little moment where we can spot the "loading"
    text; then, we should see the protected route content.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试访问我们的私有页面，看看登录后是否工作正常！首先，应该有一个短暂的“加载”文本出现；然后，我们应该看到受保护的路由内容。
- en: 'We could adopt a similar approach for hiding the login page from a logged-in
    user; let''s open the `pages/login.js` file and edit it as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用类似的方法来隐藏登录页面，不让已登录的用户看到；让我们打开`pages/login.js`文件并按照以下方式编辑它：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once we import the `useAuth` hook, we can start writing the component logic.
    We won''t render the login form until we know whether the user is logged in:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入`useAuth`钩子，我们就可以开始编写组件逻辑。在我们知道用户是否已登录之前，我们不会渲染登录表单：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we're telling our login page to behave the other way around when compared
    to the protected route page. We will wait for the hook to complete the loading
    phase, and when it ends, we will check whether the user is logged in. If they're
    logged in, we will simply redirect them to the protect page using the Next.js
    `useRouter` hook.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉我们的登录页面与受保护的路由页面相反。我们将等待钩子完成加载阶段，当它结束时，我们将检查用户是否已登录。如果他们已登录，我们将简单地使用Next.js的`useRouter`钩子将他们重定向到受保护页面。
- en: We successfully implemented a very simple (and not ready for production, by
    any means) login strategy for our web page, but what did we miss? What are the
    problems that come next? Should we pursue writing custom authentication strategies?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功实现了一个非常简单（但无论如何都不适合生产环境）的登录策略，但我们错过了什么？接下来会出现什么问题？我们应该追求编写自定义认证策略吗？
- en: Well, I think it is not worth it unless we're working in a big and expert team.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我认为除非我们在一个大型的专家团队中工作，否则这并不值得。
- en: 'This section of the book is entitled *Custom authentication – the good, the
    bad, and the ugly*, so let''s divide some considerations into those three categories:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的这一部分标题为*自定义认证 – 优点、缺点和丑陋之处*，所以让我们将一些考虑因素分为这三个类别：
- en: '*The good*: We may all appreciate writing a custom authentication system because
    it teaches us a lot about security and gives us complete control over the whole
    authentication workflow.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*：我们可能都会欣赏编写自定义认证系统，因为它让我们对安全有了很多了解，并让我们完全控制整个认证流程。'
- en: '*The bad*: We would take a considerable risk. Writing robust authentication
    mechanisms is not easy, and companies invest a lot in providing secure authentication
    strategies. It''s hard for a company working outside this business to meet the
    same security levels as Auth0, Okta, Google, or Amazon AWS.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*The bad*: 我们将承担相当大的风险。编写健壮的认证机制并不容易，公司投入大量资金以提供安全的认证策略。对于在这个行业外工作的公司来说，达到Auth0、Okta、Google或Amazon
    AWS相同的保安级别是很困难的。'
- en: '*The ugly*: Even if we could create a robust authentication system, we would
    have to implement many custom processes manually – resetting the password and
    user registration workflows, two-factor authentication, and transactional emails,
    just to name a few. It would require a lot of extra jobs and will lead to replicating
    an existing service without meeting the same level of security and reliability,
    as it is tough to match Auth0, Google, or AWS standards.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*The ugly*: 即使我们可以创建一个健壮的认证系统，我们也必须手动实现许多自定义流程——重置密码和用户注册工作流程、双因素认证和交易性电子邮件，仅举几例。这将需要大量的额外工作，并且会导致复制现有服务，而无法达到相同的保安和可靠性水平，因为要与Auth0、Google或AWS标准相匹配是困难的。'
- en: 'In the next section, we will see how to implement authentication for any Next.js
    app using an industry-standard, well-known authentication provider: Auth0.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用一个行业标准、广为人知的认证提供商——Auth0——为任何Next.js应用实现认证。
- en: Implementing authentication using Auth0
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Auth0实现认证
- en: 'In the previous section, we''ve seen how to implement an elementary and straightforward
    authentication method. I won''t repeat this enough: what we saw was just a high-level
    overview and shouldn''t be used for any production-ready product.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何实现一个基本且直接的认证方法。我不会重复得太多：我们所看到的是一个高级概述，不应用于任何生产就绪的产品。
- en: When building production-ready web apps, we're likely to adopt external authentication
    methods, which are secure and reliable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建生产就绪的Web应用时，我们可能会采用外部认证方法，这些方法是安全和可靠的。
- en: 'There are many different auth providers (AWS Cognito, Firebase, Magic.link,
    and so on), and I believe they''re all doing a fantastic job protecting their
    users. In this chapter, we will be using a popular, secure, and affordable authentication
    provider, taking advantage of its generous free plan: Auth0.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的认证提供商（AWS Cognito、Firebase、Magic.link等等），我相信它们都在出色地保护他们的用户。在本章中，我们将使用一个流行、安全且经济的认证提供商，利用其慷慨的免费计划：Auth0。
- en: If you want to follow along with this chapter, you can create a free account
    on [https://auth0.com](https://auth0.com) (no credit card is required for free
    plan users).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟随本章内容，你可以在[https://auth0.com](https://auth0.com)（免费计划用户无需信用卡）创建一个免费账户。
- en: Auth0 will manage the most complex steps of any authentication strategy and
    will give us some friendly APIs to play with.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Auth0将管理任何认证策略中最复杂的步骤，并将提供一些友好的API供我们使用。
- en: 'Thanks to this authentication provider, we don''t have to worry about any of
    the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个认证提供商，我们不必担心以下任何一点：
- en: User registration
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户注册
- en: User login
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户登录
- en: Email verification
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件验证
- en: Forgot password flow
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记密码流程
- en: Reset password flow
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置密码流程
- en: Nor will we have to worry about many other critical parts of any authentication
    strategy.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不必担心任何认证策略的其他许多关键部分。
- en: 'So, let''s start by creating a new Next.js app:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们先创建一个新的Next.js应用：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, log in to Auth0 and create a new application:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，登录Auth0并创建一个新的应用：
- en: '![Figure 12.4 – Creating a new Auth0 application'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 – 创建新的Auth0应用'
- en: '](img/Figure_12.04_B16985.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.04_B16985.jpg)'
- en: Figure 12.4 – Creating a new Auth0 application
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 创建新的Auth0应用
- en: Once we create our application, Auth0 will ask us which technology are we going
    to use. We can select **Next.js** and Auth0 will redirect us to an excellent tutorial
    on how to adopt their authentication mechanism in this framework.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了我们的应用程序，Auth0将询问我们将使用哪种技术。我们可以选择**Next.js**，Auth0将带我们到一个关于如何在框架中采用其认证机制的优秀教程。
- en: If we go to **Settings**, we will be able to set up our callback URLs. Those
    URLs represent the pages to which our users will be redirected once they complete
    specific actions, such as login, logout, and registration.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进入**设置**，我们将能够设置我们的回调URL。这些URL代表用户完成特定操作（如登录、登出和注册）后将被重定向到的页面。
- en: At this point, we need to set the *Allowed Callback URLs* by adding http://localhost:3000/api/auth/callback,
    and the *Allowed Logout URLs* by setting `http://localhost:3000/`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要通过添加 http://localhost:3000/api/auth/callback 来设置**允许的回调 URL**，并通过设置
    `http://localhost:3000/` 来设置**允许的注销 URL**。
- en: This will authorize us to adopt Auth0 for local development after every Auth0-related
    operation (such as login, registration, and password reset), as Auth0 will redirect
    us to the URL where the action originated.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将授权我们在每次 Auth0 相关操作（如登录、注册和密码重置）之后采用 Auth0 进行本地开发，因为 Auth0 将将我们重定向到操作起源的 URL。
- en: So, for example, if we want to log in on [https://example.com](https://example.com),
    after the login action, Auth0 will automatically redirect us to [https://example.com/api/auth/callback](https://example.com/api/auth/callback),
    which needs to be authorized in the section we just saw.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，如果我们想登录到 [https://example.com](https://example.com)，在登录操作之后，Auth0 将自动将我们重定向到
    [https://example.com/api/auth/callback](https://example.com/api/auth/callback)，这需要在刚刚看到的章节中进行授权。
- en: Given that our local development URL is likely to be http://localhost:3000 (which
    is the default for Next.js), we may need to authorize other staging or production
    URLs inside the *Allowed Callback URLs* and *Allowed Logout URLs* sections. Of
    course, we can always do that by adding more URLs and separating them with a comma.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的本地开发 URL 很可能是 http://localhost:3000（这是 Next.js 的默认设置），我们可能需要在**允许的回调 URL**和**允许的注销
    URL**部分授权其他预发布或生产 URL。当然，我们总是可以通过添加更多 URL 并用逗号分隔它们来实现这一点。
- en: Once we're done setting up the redirect URLs, we can start setting up our local
    environment.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置好了重定向 URL，我们就可以开始设置我们的本地环境。
- en: 'First of all, we will need to create an environment file for the local environment.
    So, let''s create it and name it `.env.local`, and then add the following content:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为本地环境创建一个环境文件。所以，让我们创建它，并将其命名为 `.env.local`，然后添加以下内容：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Remember that we should never commit the environment file as it contains sensitive
    data that could compromise our application's security.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们绝不应该提交环境文件，因为它包含可能危害我们应用程序安全性的敏感数据。
- en: 'As you can see, we''re setting five essential environment variables:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在设置五个基本的环境变量：
- en: '`AUTH0_SECRET`: A randomly generated string used by Auth0 as a secret key to
    encrypt the session cookie. You can generate a new, secure, random secret by running
    `openssl rand -hex 32` in the terminal.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTH0_SECRET`：Auth0 用来加密会话 cookie 的随机生成的字符串。您可以在终端中运行 `openssl rand -hex 32`
    来生成一个新的、安全的随机密钥。'
- en: '`AUTH0_BASE_URL`: The base URL of our application. For the local development
    environment, it will be `http://localhost:3000`. If you want to start the application
    on a different port, make sure to update the `.env.local` file to reflect this
    change.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTH0_BASE_URL`：我们应用程序的基本 URL。对于本地开发环境，它将是 `http://localhost:3000`。如果您想在不同的端口上启动应用程序，请确保更新
    `.env.local` 文件以反映此更改。'
- en: '`AUTH0_ISSUER_BASE_URL`: The URL of your Auth0 app. You can find it at the
    beginning of the **Settings** section we just visited for setting the callback
    URLs (labeled as **domain** in the Auth0 dashboard).'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTH0_ISSUER_BASE_URL`：您的 Auth0 应用程序的 URL。您可以在我们刚刚访问的**设置**部分的开始处找到它，用于设置回调
    URL（在 Auth0 控制台中标记为**域名**）。'
- en: '`AUTH0_CLIENT_ID`: The client ID for the Auth0 application. You can find yours
    right under the **Domain** setting.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTH0_CLIENT_ID`：Auth0 应用程序的客户端 ID。您可以在**域名**设置下方找到它。'
- en: '`AUTH0_CLIENT_SECRET`: The client secret for the Auth0 application. You can
    find it under the **client ID** setting in the Auth0 dashboard.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTH0_CLIENT_SECRET`：Auth0 应用程序的客户端密钥。您可以在 Auth0 控制台中的**客户端 ID**设置下找到它。'
- en: Once we've set all those environment variables, we can create an API route for
    Auth0 in our Next.js application. Remember when we talked about how many things
    we should implement when writing down a custom authentication strategy? Login,
    logout, password reset, user registration... Auth0 handles everything for us,
    and it does it by asking us to create just a straightforward API route under `/pages/api/auth/[...auth0].js`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了所有这些环境变量，我们就可以在我们的 Next.js 应用程序中为 Auth0 创建一个 API 路由。记得我们之前讨论过在编写自定义身份验证策略时应该实现多少事情吗？登录、注销、密码重置、用户注册...
    Auth0 为我们处理一切，它通过要求我们在 `/pages/api/auth/[...auth0].js` 下创建一个简单的 API 路由来实现这一点。
- en: 'Once we have created this page, we can add the following content to it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了此页面，我们就可以向其中添加以下内容：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you haven''t already done so, you can install the official Auth0 Next.js
    SDK by running the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，您可以通过运行以下命令来安装官方的 Auth0 Next.js SDK：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once we start our Next.js server, the `handleAuth()` method will create the
    following routes for us:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动Next.js服务器，`handleAuth()`方法将为我们创建以下路由：
- en: '`/api/auth/login`, the route that will allow us to log in to our application'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/auth/login`，这是允许我们登录到我们应用的路径'
- en: '`/api/auth/callback`, the callback URL where Auth0 will redirect us right after
    logging in successfully'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/auth/callback`，这是Auth0在登录成功后立即重定向我们的回调URL'
- en: '`/api/auth/logout`, where we can log out from our web application'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/auth/logout`，我们可以从这里注销我们的Web应用'
- en: '`/api/auth/me`, an endpoint where we can fetch our own information in JSON
    format once we log in'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/auth/me`，这是一个端点，一旦我们登录，我们可以从中以JSON格式获取我们自己的信息'
- en: 'To make our session persistent among all the web application pages, we can
    wrap our components in the official Auth0 `UserProvider` context. We can do that
    by opening our `pages/_app.js` file and adding the following content:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的会话在所有Web应用页面之间持久化，我们可以将我们的组件包裹在官方Auth0 `UserProvider`上下文中。我们可以通过打开我们的`pages/_app.js`文件并添加以下内容来实现这一点：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can now try to visit our application login page by browsing http://localhost:3000/api/auth/login.
    We should eventually see the following page:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过浏览http://localhost:3000/api/auth/login来尝试访问我们的应用登录页面。我们最终应该看到以下页面：
- en: '![Figure 12.5 – The default Auth0 login page'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – 默认Auth0登录页面'
- en: '](img/Figure_12.05_B16985.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.05_B16985.jpg)'
- en: Figure 12.5 – The default Auth0 login page
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 默认Auth0登录页面
- en: We don't have an account yet, as this is the first time we access the login
    page. We can click on **Sign up** and create a new account.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有账户，因为这是我们第一次访问登录页面。我们可以点击**注册**来创建一个新账户。
- en: Once we create it, we will get redirected to the application home page and receive
    an email to confirm our mail address.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，我们将被重定向到应用主页，并收到一封确认邮件。
- en: Now that we're logged in, we can display some helpful information on our frontend
    depending on the logged-in user; let's start from something straightforward and
    just show a greeting message.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经登录，我们可以在前端显示一些根据登录用户显示的有用信息；让我们从一个简单的事情开始，只显示一个问候消息。
- en: 'We can do that by opening the `/pages/index.js` file and adding the following
    content:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打开`/pages/index.js`文件并添加以下内容来实现这一点：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, this pattern is quite similar to the one we used while implementing
    our custom authentication mechanism. We statically generate the page, then wait
    for the client to fetch the user information, and once we have it, we print the
    private content on screen.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个模式与我们实现自定义认证机制时使用的模式非常相似。我们静态生成页面，然后等待客户端获取用户信息，一旦我们得到它，我们就在屏幕上打印私有内容。
- en: You can now try to log in and out from the application to test that it's working
    correctly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以尝试登录和注销应用以测试它是否正常工作。
- en: 'Once we log in and out, we might wonder: how can we customize the authentication
    form? What if we want to keep the data on our own database? We''ll discuss this
    in the next section.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录和注销，我们可能会想知道：我们如何自定义认证表单？如果我们想将数据保留在我们自己的数据库中怎么办？我们将在下一节讨论这个问题。
- en: Customizing Auth0
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制Auth0
- en: 'So far, we have built a straightforward authentication mechanism using Auth0\.
    However, when compared to the custom one, it is clear how many advantages it could
    bring: secure authentication flow, fully featured auth management, and suchlike,
    to name just a few.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用Auth0构建了一个简单的认证机制。然而，与自定义认证机制相比，它带来的优势是显而易见的：安全的认证流程，功能齐全的认证管理，等等，仅举几例。
- en: One thing that we might be missing is how much control we had when building
    the custom authentication strategy; we could control every authentication step,
    the look and feel of the form, and the required data needed to create a new account...
    how can we do that with Auth0?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能遗漏的一件事是在构建自定义认证策略时我们有多少控制权；我们可以控制每个认证步骤，表单的外观和感觉，以及创建新账户所需的数据...我们如何使用Auth0来做这些？
- en: 'Talking about the login/registration form aspect, we can customize it by navigating
    to the **Branding** section in our Auth0 dashboard:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到登录/注册表单方面，我们可以通过导航到Auth0仪表板中的**品牌**部分来自定义它：
- en: '![Figure 12.6 – The Auth0 branding section'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6 – Auth0品牌部分'
- en: '](img/Figure_12.06_B16985.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.06_B16985.jpg)'
- en: Figure 12.6 – The Auth0 branding section
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – Auth0品牌部分
- en: Here, we can edit the HTML form directly to follow our application style. We
    can also customize the email templates to be consistent with our web application
    look and feel.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以直接编辑HTML表单以符合我们的应用风格。我们还可以自定义电子邮件模板，使其与我们的Web应用外观和感觉保持一致。
- en: Another important topic is how Auth0 stores the user data. By default, it keeps
    all the login data on their own databases, but once inside the Auth0 dashboard,
    we can go to the authentication/database/custom database page and set up some
    custom scripts to grant access to an external database, where we have complete
    control over data ownership.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的话题是Auth0如何存储用户数据。默认情况下，它将所有登录数据保存在自己的数据库中，但一旦进入Auth0仪表板，我们可以前往认证/数据库/自定义数据库页面，并设置一些自定义脚本来授予访问外部数据库的权限，在那里我们对数据所有权拥有完全的控制。
- en: We could also set up a series of webhooks so that every time a new user registers,
    logs in, deletes their account, and so on, an external REST API (managed by us)
    gets notified, and we can replicate the data changes on external services and
    databases.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以设置一系列webhooks，以便每次有新用户注册、登录、删除账户等操作时，一个由我们管理的外部REST API（得到通知），我们可以在外部服务和数据库上复制数据变化。
- en: Auth0 gives us a lot of possibilities to customize the whole authentication
    experience, and it's one of the most complete providers out there. It also grants
    a generous free plan, where we can test a lot of its features for free before
    deciding whether it fits all our needs. So, if you're willing to build a production-ready
    app, I'd highly recommend looking into Auth0 for managing authentication safely.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Auth0为我们提供了很多定制整个认证体验的可能性，它是市场上最完整的提供商之一。它还提供了一项慷慨的免费计划，我们可以免费测试其许多功能，在决定它是否满足所有需求之前。因此，如果你愿意构建一个生产就绪的应用程序，我强烈建议考虑使用Auth0来安全地管理认证。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've seen how using a third-party authentication provider
    can save us from many issues when dealing with complex and sensitive topics such
    as private data management and user sessions.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了使用第三方认证提供商如何在我们处理复杂且敏感的话题，如私人数据管理和用户会话时，避免许多问题。
- en: 'So, the final question could be: when does it make sense to implement a custom
    authentication strategy? In my humble opinion, we should avoid writing custom
    authentication mechanisms in almost any scenario, unless we''re working with an
    expert team capable of detecting security flaws and identifying vulnerabilities
    in the whole authentication flow.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终的问题可能是：在什么情况下实施自定义认证策略是有意义的？根据我谦逊的观点，我们应该尽量避免在几乎所有场景下编写自定义认证机制，除非我们与一个能够检测安全漏洞并识别整个认证流程中漏洞的专家团队合作。
- en: There are many good alternatives to Auth0 (NextAuth.js, Firebase, AWS Cognito,
    and so on), and it is just too risky to replicate their battle-tested features.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多好的Auth0替代品（NextAuth.js、Firebase、AWS Cognito等），复制它们经过实战检验的功能风险太大。
- en: If you're not comfortable working with external providers, you can also use
    any web framework and its built-in authentication strategies. For example, suppose
    you feel comfortable using Ruby on Rails, Laravel, or Spring Boot. In that case,
    these are all excellent alternatives over external authentication providers. They
    will also give you all the flexibility and security you may need with a lot of
    support from the community and constant security releases and fixes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢与外部供应商合作，你也可以使用任何Web框架及其内置的认证策略。例如，假设你习惯使用Ruby on Rails、Laravel或Spring
    Boot。在这种情况下，这些都是在外部认证供应商之上的优秀替代品。它们也会为你提供你可能需要的所有灵活性和安全性，同时得到社区的大量支持和持续的安全发布和修复。
- en: Another option could be to use a headless CMS for managing users and their data;
    open source CMSs such as Strapi, for example, handle authentication natively and
    allow us to take advantage of their own authentication mechanisms supported by
    the community and the company that is developing the CMS.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择可能是使用无头CMS来管理用户及其数据；例如，开源CMS如Strapi，它原生支持认证，并允许我们利用社区和开发CMS的公司支持的认证机制。
- en: In any case, implementing custom authentication is a very instructive task as
    it teaches you a lot about how security mechanisms work and how you should protect
    against malicious users. For example, in the next chapter, we will be building
    an e-commerce website using GraphCMS; imagine that we're implementing a custom
    authentication mechanism here, letting malicious users exploit a vulnerability
    and access users' private data. Would it be worth the risk?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，实施自定义认证是一项非常有教育意义的任务，因为它教会你很多关于安全机制如何工作以及如何保护自己免受恶意用户侵害的知识。例如，在下一章中，我们将构建一个使用GraphCMS的电子商务网站；想象一下，如果我们在这里实施一个自定义认证机制，让恶意用户利用漏洞并访问用户的私人数据，这会值得冒险吗？
