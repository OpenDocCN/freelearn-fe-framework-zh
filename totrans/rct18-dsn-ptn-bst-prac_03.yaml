- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Cleaning Up Your Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理您的代码
- en: This chapter assumes that you have prior experience with **JSX** (**JavaScript
    XML**) and are interested in improving your skills to use it effectively. To use
    JSX/TSX without any issues or unexpected behavior, it’s crucial to understand
    how it works under the hood and the reasons why it’s a useful tool for building
    UIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经具备 **JSX**（**JavaScript XML**）的相关经验，并且有兴趣提高您使用它的技能以有效利用它。为了在使用 JSX/TSX
    时不出现任何问题或意外行为，了解其底层工作原理及其作为构建 UI 的有用工具的原因至关重要。
- en: Our objective is to write clean JSX/TSX code, maintain it, and have a good understanding
    of its inner workings, including how it’s translated to JavaScript and the features
    it provides.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是编写干净的 JSX/TSX 代码，维护它，并对其内部工作原理有良好的理解，包括它如何转换为 JavaScript 以及它提供的功能。
- en: By understanding the intricacies of JSX/TSX, you can leverage its full potential
    to build efficient and scalable UIs. We will explore various tips and techniques
    to help you write better code and avoid common mistakes. By the end of this chapter,
    you will have a solid grasp of how JSX/TSX works and how to use it effectively
    in your React applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解 JSX/TSX 的复杂性，您可以充分利用其全部潜力来构建高效且可扩展的 UI。我们将探讨各种技巧和技术，帮助您编写更好的代码并避免常见的错误。到本章结束时，您将牢固掌握
    JSX/TSX 的工作原理以及如何在您的 React 应用程序中有效地使用它。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is JSX and why should we use it?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 是什么，为什么我们应该使用它？
- en: What is Babel and how can we use it to write modern JavaScript code?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel 是什么，以及我们如何使用它来编写现代 JavaScript 代码？
- en: The main features of JSX and the differences between HTML and JSX.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 的主要特性和 HTML 与 JSX 之间的区别。
- en: Best practices to write JSX in an elegant and maintainable way.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写优雅且可维护的 JSX 的最佳实践。
- en: How linting, and ESLint in particular, can make our JavaScript code consistent
    across applications and teams.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过 linting（特别是 ESLint）使我们的 JavaScript 代码在应用程序和团队之间保持一致性。
- en: The basics of functional programming and why following a functional paradigm
    will make us write better React components.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程的基础以及遵循函数式范式将如何帮助我们编写更好的 React 组件。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您需要以下内容：
- en: Node.js 19+
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 19+
- en: Visual Studio Code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Using JSX
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSX
- en: In *Chapter 1*, we saw how React changes the concept of separation of concerns,
    moving the boundaries inside components. We also learned how React uses the elements
    returned by the components to display the UI on the screen.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第一章* 中，我们看到了 React 如何改变关注点分离的概念，将边界移动到组件内部。我们还学习了 React 如何使用组件返回的元素在屏幕上显示
    UI。
- en: Let’s now look at how we can declare elements inside our components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何在组件内部声明元素。
- en: 'React provides two ways to define elements. The first one is by using JavaScript
    functions, and the second one is by using JSX, an optional XML-like syntax. The
    following is a screenshot of the new official documentation of React.js ([https://react.dev](https://react.dev)):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了两种定义元素的方法。第一种是通过使用 JavaScript 函数，第二种是通过使用 JSX，这是一种可选的类似 XML 的语法。以下是新官方
    React.js 文档的截图（[https://react.dev](https://react.dev)）：
- en: '![Graphical user interface, website  Description automatically generated](img/B18414_03_01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，网站描述自动生成](img/B18414_03_01.png)'
- en: 'Figure 3.1: New official documentation site of React.js'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：React.js 的新官方文档网站
- en: To begin with, JSX is one of the main reasons why people fail to approach React,
    because looking at the examples on the home page and seeing JavaScript mixed with
    HTML for the first time can seem strange to most of us.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，JSX 是人们未能接近 React 的主要原因之一，因为第一次看到主页上的示例，看到 JavaScript 与 HTML 混合在一起，对我们大多数人来说可能看起来很奇怪。
- en: As soon as we get used to it, we realize that it is very convenient, precisely
    because it is similar to HTML and looks very familiar to anyone who has already
    created UIs on the web. The opening and closing tags make it easier to represent
    nested trees of elements, something that would have been unreadable and hard to
    maintain using plain JavaScript.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们习惯了它，我们就会意识到它非常方便，正是因为它与 HTML 类似，对已经在网络上创建过 UI 的人来说看起来非常熟悉。开闭标签使得表示嵌套元素树变得更加容易，这在使用纯
    JavaScript 时将是难以阅读和难以维护的。
- en: Let’s take a look at JSX in more detail in the following sub-sections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解以下子节中的 JSX。
- en: Babel
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Babel
- en: Babel is a popular JavaScript compiler widely used in the React community. It
    allows developers to write code using the latest language features, such as JSX
    and ES6, that may not yet be supported in all browsers. By transpiling the code
    into the more widely supported ES5, Babel ensures that your application runs smoothly
    across different browsers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 是一个流行的 JavaScript 编译器，在 React 社区中得到广泛使用。它允许开发者使用最新的语言特性编写代码，如 JSX 和 ES6，这些特性可能尚未在所有浏览器中得到支持。通过将代码转换成更广泛支持的
    ES5，Babel 确保你的应用程序在不同浏览器上平稳运行。
- en: 'To use Babel, you’ll first need to install the necessary packages. In older
    versions (Babel 6.x), you would install the `babel-cli` package, which included
    **babel-node** and **babel-core**. However, in more recent versions, these packages
    have been separated into individual modules: `@babel/core`, `@babel/cli`, `@babel/node`,
    and so on.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Babel，你首先需要安装必要的包。在旧版本（Babel 6.x）中，你会安装 `babel-cli` 包，它包含了 **babel-node**
    和 **babel-core**。然而，在较新版本中，这些包已经被分离成单独的模块：`@babel/core`、`@babel/cli`、`@babel/node`
    等等。
- en: 'To install Babel, follow these steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Babel，请按照以下步骤操作：
- en: 'Install the required packages globally (although local installations are generally
    preferred):'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在全局范围内安装所需的包（尽管通常更喜欢本地安装）：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To compile a JavaScript file using Babel, run:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 Babel 编译 JavaScript 文件，请运行：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Babel is highly configurable, and you can customize it using presets. To install
    the most common presets, run:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Babel 可以高度配置，你可以使用预设来自定义它。要安装最常用的预设，请运行：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a `.babelrc` configuration file in your project’s root directory and
    add the following content to tell Babel to use the installed presets:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目根目录中创建一个 `.babelrc` 配置文件，并添加以下内容以告诉 Babel 使用已安装的预设：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, you can write ES6 and JSX in your source files, and Babel will transpile
    them into browser-compatible ES5 JavaScript code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在源文件中编写 ES6 和 JSX，Babel 会将它们转换成浏览器兼容的 ES5 JavaScript 代码。
- en: Creating our first element
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建第一个元素
- en: 'Now that our environment supports JSX, let’s explore a basic example: creating
    a `div` element. Using the `_jsx` function, we can write:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们支持 JSX 的环境，让我们探索一个基本示例：创建一个 `div` 元素。使用 `_jsx` 函数，我们可以编写：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, using JSX, we can simply write:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 JSX，我们可以简单地编写：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This appears similar to regular HTML, but the crucial difference is that we’re
    writing markup within a `.js` file. Keep in mind that JSX is only syntactic sugar
    and gets transpiled into JavaScript before being executed in the browser.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与常规 HTML 类似，但关键的区别在于我们正在 `.js` 文件中编写标记。请注意，JSX 只是一种语法糖，在浏览器中执行之前会被转换成 JavaScript。
- en: When we run Babel, our `<div />` element is translated into `_jsx('div', {})`.
    Remember this when crafting templates.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 Babel 时，我们的 `<div />` 元素被转换成 `_jsx('div', {})`。在构建模板时请记住这一点。
- en: Starting from **React 17**, `React.createElement('div')` has been deprecated,
    and the library now uses `react/jsx-runtime` internally to render JSX. This means
    that you no longer need to import the React object to write JSX code. Instead,
    you can write JSX directly, as shown in the previous example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从 **React 17** 开始，`React.createElement('div')` 已被弃用，库现在内部使用 `react/jsx-runtime`
    来渲染 JSX。这意味着你不再需要导入 React 对象来编写 JSX 代码。相反，你可以像上一个示例中那样直接编写 JSX。
- en: DOM elements and React components
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM 元素和 React 组件
- en: JSX allows us to create both HTML elements and React components, with the only
    difference being whether or not they start with a capital letter. For instance,
    to render an HTML button, we use `<button />`, while to render the `Button` component,
    we use `<Button />`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 允许我们创建 HTML 元素和 React 组件，唯一的区别在于它们是否以大写字母开头。例如，要渲染 HTML 按钮，我们使用 `<button
    />`，而要渲染 `Button` 组件，我们使用 `<Button />`。
- en: 'The first button is transpiled into the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个按钮被转换成以下形式：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second one is transpiled into the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个被转换成以下形式：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The key difference is that in the first call, we pass the type of the DOM element
    as a string, while in the second call, we pass the component itself. As a result,
    the component should exist in the scope for it to work properly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关键区别在于第一次调用时，我们传递 DOM 元素的类型作为字符串，而在第二次调用中，我们传递组件本身。因此，组件必须在作用域中存在才能正常工作。
- en: JSX also supports self-closing tags, which are useful for keeping the code concise
    and avoiding unnecessary tag repetition.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 还支持自闭合标签，这对于保持代码简洁和避免不必要的标签重复很有用。
- en: Props
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'JSX is very convenient when your DOM elements or React components have props.
    Using XML is pretty easy to set attributes on elements:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的 DOM 元素或 React 组件有 props 时，JSX 非常方便。使用 XML 在元素上设置属性相当简单：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The equivalent in JavaScript would be as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，这将是以下内容：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is far less readable, and even with only a couple of attributes, it is
    harder to read without a bit of reasoning.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这要难读得多，即使只有几个属性，没有一点推理也难以阅读。
- en: Children
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子元素
- en: 'JSX allows you to define children to describe the tree of elements and compose
    complex UIs. A basic example is a link with text inside it, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 允许你定义子元素来描述元素的树形结构并组合复杂的 UI。一个基本的例子是在其中包含文本的链接，如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This would be transpiled into the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被转换成以下内容：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our link can be enclosed inside a `div` element for some layout requirements,
    and the JSX snippet to achieve that is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的链接可以包含在一个 `div` 元素中，以满足某些布局要求，实现这一点的 JSX 片段如下所示：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The JavaScript equivalent is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的等效代码如下：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It should now be clear how the *XML-like* syntax of JSX makes everything more
    readable and maintainable, but it is always important to know the JavaScript parallel
    to our JSX has control over the creation of elements. The good part is that we
    are not limited to having elements as children of elements, but we can use JavaScript
    expressions, such as functions or variables.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很清楚 JSX 的 *XML-like* 语法是如何使一切更加可读和可维护的，但了解与我们的 JSX 并行的 JavaScript 如何控制元素的创建始终很重要。好处是，我们不仅限于将元素作为元素的子元素，我们还可以使用
    JavaScript 表达式，例如函数或变量。
- en: 'To do this, we have to enclose the expression within curly braces:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须将表达式包裹在花括号内：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The same applies to non-string attributes, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于非字符串属性，如下所示：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you see, any variable or function should be enclosed in curly braces.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，任何变量或函数都应该被包裹在花括号内。
- en: Differences with HTML
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 HTML 的区别
- en: So far, we have looked at the similarities between JSX and HTML. Let’s now look
    at the little differences between them and the reasons they exist.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了 JSX 和 HTML 之间的相似之处。现在让我们看看它们之间的一些细微差别以及它们存在的原因。
- en: Attributes
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: We must always keep in mind that JSX is not a standard language and that it
    gets transpiled into JavaScript. Because of this, some attributes cannot be used.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须始终记住 JSX 不是一个标准语言，并且它会被转换成 JavaScript。因此，一些属性不能使用。
- en: 'For example, instead of `class`, we have to use `className`, and instead of
    `for`, we have to use `htmlFor`, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们不得不使用 `className` 而不是 `class`，以及使用 `htmlFor` 而不是 `for`，如下所示：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The reason for this is that `class` and `for` are reserved words in JavaScript.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 `class` 和 `for` 是 JavaScript 的保留字。
- en: Style
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式
- en: A pretty significant difference is the way the `style` attribute works. We will
    look at how to use it in more detail in *Chapter 6*, *Making Your Components Look
    Beautiful*, but now we will focus on the way it works.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当显著的区别是 `style` 属性的工作方式。我们将在 *第 6 章*，*让你的组件看起来更美观* 中更详细地探讨如何使用它，但现在我们将关注它的工作方式。
- en: 'The `style` attribute does not accept a CSS string as the HTML parallel does,
    but it expects a JavaScript object where the style names are *camelCased*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`style` 属性不接受 CSS 字符串，就像 HTML 那样，而是期望一个 JavaScript 对象，其中样式名称是 *camelCased*：'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, you can pass an object to the `style` prop, meaning you can
    even have your styles in a separate variable if you want:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以向 `style` prop 传递一个对象，这意味着如果你愿意，你的样式甚至可以放在一个单独的变量中：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the best way to have better control of your inline styles.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更好地控制你的内联样式的方法。
- en: Root
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根
- en: One important difference with HTML worth mentioning is that since JSX elements
    get translated into JavaScript functions, and you cannot return two functions
    in JavaScript, whenever you have multiple elements at the same level, you are
    forced to wrap them in a parent.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，与 HTML 相比的一个重要区别是，由于 JSX 元素被转换成 JavaScript 函数，而在 JavaScript 中你不能返回两个函数，所以当你有多个同一级别的元素时，你被迫将它们包裹在一个父元素中。
- en: 'Let’s look at a simple example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This gives us the following error:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给我们以下错误：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On the other hand, the following works:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下是可以工作的：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before, React forced you to return an element wrapped with an `<div>` element
    or any other tag; since **React 16.2.0**, it is possible to return an array directly
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，React 强制你返回一个被 `<div>` 元素或其他标签包裹的元素；自 **React 16.2.0** 以来，可以直接返回一个数组，如下所示：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or you can even return a string directly, as shown in the following code block:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你甚至可以直接返回一个字符串，如下面的代码块所示：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Also, React now has a new feature called `Fragment` that also works as a special
    wrapper for elements. It can be specified with `React.Fragment`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，React现在有一个名为`Fragment`的新特性，它也可以作为一个特殊的元素包装器。它可以指定为`React.Fragment`：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or you can use empty tags (`<></>`):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用空标签（`<></>`）：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`Fragment` won’t render anything visible on the DOM; it is just a helper tag
    to wrap your React elements or components.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fragment`不会在DOM上渲染任何可见的内容；它只是一个用于包裹你的React元素或组件的辅助标签。'
- en: Spaces
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空格
- en: There’s one thing that could be a little bit tricky in the beginning and, again,
    it concerns the fact that we should always keep in mind that JSX is not HTML,
    even if it has XML-like syntax. JSX handles the spaces between text and elements
    differently from HTML, in a way that’s counter-intuitive.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时可能会有一点小麻烦，再次强调，这涉及到我们应该始终记住JSX不是HTML，即使它有类似XML的语法。JSX处理文本和元素之间的空格的方式与HTML不同，这种方式可能不符合直观。
- en: 'Consider the following snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In a browser that interprets HTML, this code would give you `My name is Carlos`,
    which is exactly what we expect.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个解析HTML的浏览器中，这段代码会显示`My name is Carlos`，这正是我们预期的结果。
- en: 'In JSX, the same code would be rendered as `MynameisCarlos`, which is because
    the three nested lines get transpiled as individual children of the `div` element,
    without taking the spaces into account. A common solution to get the same output
    is putting a space explicitly between the elements, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSX中，相同的代码会被渲染为`MynameisCarlos`，这是因为三个嵌套的行被转换成了`div`元素的单独子元素，没有考虑到空格。一个常见的解决方案是在元素之间显式地放置一个空格，如下所示：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you may have noticed, we are using an empty string wrapped inside a JavaScript
    expression to force the compiler to apply a space between the elements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经注意到的，我们正在使用一个包裹在JavaScript表达式中的空字符串来强制编译器在元素之间应用空格。
- en: Boolean attributes
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔属性
- en: A couple more things are worth mentioning before really starting regarding the
    way you define Boolean attributes in JSX.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正开始之前，还有一些关于你在JSX中定义布尔属性的方式值得提及。
- en: If you set an attribute without a value, JSX assumes that its value is `true`,
    following the same behavior as the HTML `disabled` attribute, for example.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设置了一个没有值的属性，JSX会假设它的值是`true`，这与HTML中的`disabled`属性的行为相同，例如。
- en: 'This means that if we want to set an attribute to `false`, we have to declare
    it explicitly as `false`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们想将属性设置为`false`，我们必须明确地声明为`false`：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is another example of the Boolean attribute:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是布尔属性的另一个例子：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This can be confusing in the beginning, because we may think that omitting an
    attribute would mean `false`, but it is not like that. With React, we should always
    be explicit to avoid confusion.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时这可能会让人困惑，因为我们可能会认为省略属性意味着`false`，但事实并非如此。在使用React时，我们应该始终明确以避免混淆。
- en: Spread attributes
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展开属性
- en: An important feature is the `spread attribute` operator (`...`), which comes
    from the rest/spread properties for ECMAScript “proposal” and is very convenient
    whenever we want to pass all the attributes of a JavaScript object to an element.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的特性是`展开属性`操作符（`...`），它来自ECMAScript“提案”中的rest/spread属性，并且在我们想要将JavaScript对象的全部属性传递给元素时非常方便。
- en: A common practice that leads to fewer bugs is not to pass entire JavaScript
    objects down to children by reference, but to use their primitive values, which
    can be easily validated, making components more robust and error-proof.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的做法可以减少错误，那就是不要通过引用传递整个JavaScript对象给子组件，而是使用它们的原始值，这些值可以轻松验证，使组件更加健壮和防错。
- en: 'Let’s see how it works:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code gets transpiled into the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码会被转换成以下形式：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Template literals
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板字面量
- en: '`Template`literals are string literals that allow for embedded expressions,
    multiline strings, and string interpolation. They are enclosed by the backtick
    (``) character instead of single or double quotes.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`模板字面量`是允许嵌入表达式、多行字符串和字符串插值的字符串字面量。它们由反引号（``）字符包围，而不是单引号或双引号。'
- en: 'One of the most useful features of template literals is the ability to include
    placeholders using the dollar sign and curly braces `(${expression}`). This allows
    us to easily interpolate variables or complex expressions into our string templates.
    Here’s an example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字面量最有用的特性之一是能够使用美元符号和花括号`(${expression})`包含占位符。这允许我们轻松地将变量或复杂的表达式插入到字符串模板中。以下是一个例子：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will log the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In addition to string interpolation, template literals also support multiline
    strings, making it easier to write and read complex strings without needing to
    concatenate multiple strings with the plus (`+`) operator.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串插值外，模板字符串还支持多行字符串，这使得在不使用加号（`+`）运算符连接多个字符串的情况下编写和阅读复杂的字符串变得更加容易。
- en: Common patterns
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见模式
- en: Now that we know how JSX works and can master it, we are ready to see how to
    use it in the right way following some useful conventions and techniques.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 JSX 的工作原理并能熟练掌握它，我们就准备好按照一些有用的约定和技术来正确地使用它了。
- en: Multiline
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多行
- en: Let’s start with a very simple one. As stated previously, one of the main reasons
    we should prefer JSX over React’s `_jsx` function is because of its XML-like syntax,
    and because balanced opening and closing tags are perfect to represent a tree
    of nodes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的例子开始。正如之前所述，我们应该优先选择 JSX 而不是 React 的 `_jsx` 函数的主要原因之一是因为其类似 XML 的语法，以及平衡的开启和关闭标签非常适合表示节点树。
- en: 'Therefore, we should try to use it in the right way and get the most out of
    it. One example is as follows; whenever we have nested elements, we should always
    go multiline:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该尝试以正确的方式使用它并最大限度地发挥其作用。以下是一个例子；每当有嵌套元素时，我们总是应该使用多行：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is preferable to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这比以下情况更可取：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The exception is if the children are not elements such as text or variables.
    In that case, it makes sense to remain on the same line and avoid adding noise
    to the markup, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例外情况是如果子元素不是文本或变量等元素。在这种情况下，保持在同一行上并避免向标记中添加噪音是有意义的，如下所示：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Always remember to wrap your elements inside parentheses when you write them
    on multiple lines. JSX always gets replaced by functions, and functions written
    on a new line can give you an unexpected result because of automatic semicolon
    insertion. Suppose, for example, that you are returning JSX from your render method,
    which is how you create UIs in React.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记得在多行编写元素时将它们包裹在括号内。JSX 总是被替换为函数，而写在新的行上的函数可能会因为自动分号插入而导致意外结果。例如，假设你从渲染方法中返回
    JSX，这是你在 React 中创建 UI 的方式。
- en: 'The following example works fine because the `div` element is on the same line
    as the `return`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例工作正常，因为 `div` 元素与 `return` 在同一行上：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following, however, is not right:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下是不正确的：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The reason for this is that you would then have the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，这样你会有以下情况：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is why you have to wrap the statement in parentheses, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么你必须将语句包裹在括号中的原因，如下所示：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Multi-properties
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多属性
- en: A common problem in writing JSX comes when an element has multiple attributes.
    One solution is to write all the attributes on the same line, but this would lead
    to very long lines that we do not want in our code (see the following section
    for how to enforce coding style guides).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 JSX 时，一个常见的问题是一个元素具有多个属性。一个解决方案是将所有属性都写在同一行上，但这会导致代码行非常长，而我们不希望代码中出现这种情况（参见下一节了解如何强制执行编码风格指南）。
- en: 'A common solution is to write each attribute on a new line, with one level
    of indentation, and then align the closing bracket with the opening tag:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的解决方案是将每个属性都写在新的行上，缩进一级，然后将关闭括号与开启标签对齐：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Conditionals
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件语句
- en: Things get more interesting when we start working with `conditionals`, for example,
    if we want to render some components only when certain conditions are matched.
    The fact that we can use JavaScript in our conditions is a big plus, but there
    are many ways to express conditions in JSX, and it is important to understand
    the benefits and problems of each one of these to write code that is both readable
    and maintainable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始处理 `条件语句` 时，事情会变得更有趣，例如，如果我们只想在满足某些条件时渲染某些组件。我们可以在条件中使用 JavaScript 是一个很大的优点，但在
    JSX 中有许多表达条件的方式，理解每种方式的优点和问题对于编写既可读又可维护的代码非常重要。
- en: Suppose we want to show a logout button only if the user is currently logged
    in to our application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想在用户当前登录到我们的应用程序时显示注销按钮。
- en: 'A simple snippet to start with is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的示例片段如下：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This works, but it is not very readable, especially if there are multiple components
    and multiple conditions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实可行，但可读性并不高，尤其是当有多个组件和多个条件时。
- en: 'In JSX, we can use an inline condition:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSX 中，我们可以使用内联条件：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This works because if the condition is `false`, nothing gets rendered, but if
    the condition is `true`, the `createElement` function of `LoginButton` gets called,
    and the element is returned to compose the resulting tree.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为如果条件是`false`，则不会渲染任何内容，但如果条件是`true`，则`LoginButton`的`createElement`函数会被调用，并将元素返回以组成结果树。
- en: 'If the condition has an alternative (the classic `if...else` statement) and
    we want, for example, to show a logout button if the user is logged in and a login
    button otherwise, we can use JavaScript’s `if...else` statement as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件有备选方案（经典的`if...else`语句），并且我们想要，例如，当用户登录时显示注销按钮，否则显示登录按钮，我们可以如下使用JavaScript的`if...else`语句：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Alternatively, and better still, we can use a ternary condition that makes
    the code more compact:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更好的是，我们可以使用一个使代码更紧凑的三元条件：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can find the ternary condition used in popular repositories, such as the
    Redux real-world example ([https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28](https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28)),
    where the ternary is used to show a `Loading` label if the component is fetching
    the data or `Load More` inside a button depending on the value of the `isFetching`
    variable:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在流行的仓库中找到使用的三元条件，例如Redux现实世界的例子([https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28](https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28))，其中三元条件用于在组件正在获取数据时显示`Loading`标签，或者根据`isFetching`变量的值在按钮内部显示`Load
    More`：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let’s now look at the best solution for when things get more complicated and,
    for example, we have to check more than one variable to determine whether to render
    a component or not:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看当事情变得更加复杂时最好的解决方案，例如，我们必须检查多个变量以确定是否渲染组件：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this case, it is clear that using the inline condition is a good solution,
    but the readability is strongly impacted. Instead, we can create a helper function
    inside our component and use it in JSX to verify the condition:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，很明显使用内联条件是一个好的解决方案，但可读性受到了严重影响。相反，我们可以在组件内部创建一个辅助函数并在JSX中使用它来验证条件：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, this change makes the code more readable and the condition more
    explicit. If you look at this code in 6 months, you will still find it clear just
    by reading the name of the function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个更改使代码更易于阅读，条件更明确。如果你在6个月后查看这段代码，仅通过阅读函数名你仍然可以找到它很清晰。
- en: 'The same applies to computed properties. Suppose you have two single properties
    for currency and value. Instead of creating the price string inside `render`,
    you can create a function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于计算属性。假设你有两个单独的属性用于货币和价值。你可以在`render`内部创建一个价格字符串，而不是这样做，你可以创建一个函数：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is better because it is isolated, and you can easily test it if it contains
    logic.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这更好，因为它被隔离了，如果你想要测试它是否包含逻辑，你可以轻松地进行测试。
- en: 'Going back to conditional statements, we can create a custom component and
    call it `RenderIf` to render our components conditionally:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 回到条件语句，我们可以创建一个自定义组件并命名为`RenderIf`来条件性地渲染我们的组件：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can then easily use it in our projects, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地在我们的项目中使用它，如下所示：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Loops
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环
- en: A very common operation in UI development is to display lists of items. When
    it comes to showing lists, using JavaScript as a template language is a very good
    idea.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI开发中，显示项目列表是一个非常常见的操作。当涉及到显示列表时，使用JavaScript作为模板语言是一个非常不错的选择。
- en: If we write a function that returns an array inside our JSX template, each element
    of the array gets compiled into an element.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在JSX模板中编写一个返回数组的函数，数组中的每个元素都会被编译成一个元素。
- en: As we have seen before, we can use any JavaScript expressions inside curly braces,
    and the most common way to generate an array of elements, given an array of objects,
    is to use `map`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，我们可以在大括号内使用任何JavaScript表达式，并且给定一个对象数组，生成元素数组最常见的方式是使用`map`。
- en: Let’s dive into a real-world example. Suppose you have a list of users, each
    one with a `name` property attached to it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入一个现实世界的例子。假设你有一个用户列表，每个用户都有一个附加的`name`属性。
- en: 'To create an unordered list to show the users, you can do the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个无序列表来显示用户，你可以这样做：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This snippet is incredibly simple and incredibly powerful at the same time,
    where the power of HTML and JavaScript converge.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段既简单又强大，因为HTML和JavaScript的力量在这里汇聚。
- en: Sub-rendering
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子渲染
- en: It is worth stressing that we always want to keep our components very small
    and our render methods very clean and simple.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，我们总是希望保持我们的组件非常小，我们的渲染方法非常干净和简单。
- en: However, that is not an easy goal, especially when you are creating an application
    iteratively, and in the first iteration, you are not sure exactly how to split
    the components into smaller ones. So, what should we be doing when the `render`
    method becomes too big to maintain? One solution is to split it into smaller functions
    in a way that lets us keep all the logic in the same component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是一个容易实现的目标，尤其是在您迭代创建应用程序时，在第一次迭代中，您不确定如何将组件拆分成更小的部分。那么，当`渲染`方法变得太大难以维护时，我们应该怎么做？一个解决方案是以一种让我们能够保持所有逻辑在同一个组件中的方式将其拆分成更小的函数。
- en: 'Let’s look at an example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is not always considered best practice because it seems more obvious to
    split the component into smaller ones. However, sometimes it helps to keep the
    render method cleaner. For example, in the Redux real-world examples, a sub-render
    method is used to render the *load more* button.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不总是被认为是最佳实践，因为这看起来更明显地应该将组件拆分成更小的部分。然而，有时保持渲染方法更干净是有帮助的。例如，在Redux的实际应用示例中，使用子渲染方法来渲染*加载更多*按钮。
- en: Now that we are JSX power users, it is time to move on and see how to follow
    a style guide within our code to make it consistent.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经是JSX的高级用户了，是时候继续前进，看看如何在我们的代码中遵循样式指南，以使其保持一致。
- en: Styling code
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码样式
- en: In this section, you will learn how to implement **EditorConfig** and **ESLint**
    to improve your code quality by validating your code style. It is important to
    have a standard code style in your team and avoid using different code styles.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何通过验证代码风格来实施**EditorConfig**和**ESLint**，从而提高您的代码质量。在您的团队中拥有标准的代码风格并避免使用不同的代码风格非常重要。
- en: EditorConfig
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EditorConfig
- en: '**EditorConfig** helps developers to maintain consistent coding styles between
    different IDEs.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**EditorConfig**帮助开发者在不同IDE之间保持一致的编码风格。'
- en: EditorConfig is supported by a lot of editors. You can check whether your editor
    is supported or not on the official website, [https://www.editorconfig.org](https://www.editorconfig.org).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: EditorConfig被许多编辑器支持。您可以在官方网站上检查您的编辑器是否受支持，[https://www.editorconfig.org](https://www.editorconfig.org)。
- en: 'You need to create a file called `.editorconfig` in your `root` directory –
    the configuration I use is this one:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的`root`目录中创建一个名为`.editorconfig`的文件——我使用的配置如下：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can affect all the files with `[*]`, and specific files with `[.extension]`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`[*]`影响所有文件，以及使用`[.extension]`影响特定文件。
- en: Prettier
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prettier
- en: '**Prettier** is an opinionated code formatter, supported by many languages,
    that can be integrated with most editors. This plugin is really useful because
    you can format the code on saving and you don’t need to discuss the code style
    in code reviews, which will save you a lot of time and energy.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**Prettier**是一个有偏见的代码格式化工具，支持多种语言，可以与大多数编辑器集成。这个插件非常有用，因为您可以在保存时格式化代码，您不需要在代码审查中讨论代码风格，这将为您节省大量时间和精力。'
- en: 'If you work with Visual Studio Code, you have to install the Prettier extension
    first:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Visual Studio Code，您必须首先安装Prettier扩展：
- en: '![Text, website  Description automatically generated](img/B18414_03_02.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![文本，网站描述自动生成](img/B18414_03_02.png)'
- en: 'Figure 3.2: Prettier – Code formatter'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：Prettier – 代码格式化工具
- en: 'Then, if you want to configure the option to format when you save a file, you
    need to go to **Settings**, search for `Format` `on` `Save`, and check that option:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您想在保存文件时配置格式化选项，您需要前往**设置**，搜索`在保存时格式化`，并确认该选项：
- en: '![Text  Description automatically generated](img/B18414_03_03.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_03_03.png)'
- en: 'Figure 3.3: Configuring option to format when saving a file'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：配置保存文件时的格式化选项
- en: 'This will affect all your projects because it is a global setting. If you want
    to apply this option just in a specific project, you have to create a `.vscode`
    folder inside your project and a `settings.json` file with the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将影响您所有的项目，因为它是一个全局设置。如果您只想在特定项目中应用此选项，您必须在您的项目内部创建一个`.vscode`文件夹和一个`settings.json`文件，其中包含以下代码：
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then you can configure the options you want in your `.prettierrc` file – this
    is the configuration I normally use:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在您的`.prettierrc`文件中配置您想要的选项——这是我通常使用的配置：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This will help you or your team to standardize the code style.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助您或您的团队标准化代码风格。
- en: ESLint
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ESLint
- en: Writing high-quality code is always our goal, but errors can still occur, and
    spending hours hunting down a bug caused by a simple typo can be incredibly frustrating.
    Thankfully, there are tools that can help us catch these errors as soon as we
    type them, allowing us to avoid simple syntactical mistakes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高质量的代码始终是我们的目标，但错误仍然可能发生，花费数小时追踪由简单的打字错误引起的错误可能会非常令人沮丧。幸运的是，有一些工具可以帮助我们在键入时就捕获这些错误，从而避免简单的语法错误。
- en: If you’re coming from a statically typed language like C#, you may be used to
    getting warnings inside your IDE. In the JavaScript world, the popular tool for
    linting code is ESLint. ESLint is an open-source project released in 2013 that
    is highly configurable and extensible.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自像C#这样的静态类型语言，你可能已经习惯了在IDE中得到警告。在JavaScript世界中，用于代码检查的流行工具是ESLint。ESLint是一个于2013年发布的开源项目，它高度可配置和可扩展。
- en: In the fast-paced JavaScript ecosystem, where libraries and techniques change
    frequently, it’s crucial to have a tool that can be easily extended with plugins
    and rules that can be enabled or disabled as needed. Additionally, with transpilers
    like Babel and experimental language features that aren’t yet part of the standard
    JavaScript version, we need to be able to tell our linter which rules we’re following
    in our source files. A linter not only helps us catch errors sooner, but it also
    enforces common coding style guides, which is particularly important in large
    teams where consistency is key.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速发展的JavaScript生态系统中，库和技术经常变化，因此拥有一个可以轻松扩展插件和规则的工具至关重要，这些规则可以根据需要启用或禁用。此外，由于像Babel这样的转换器和尚未成为标准JavaScript版本一部分的实验性语言功能，我们需要能够告诉我们的代码检查器我们在源文件中遵循哪些规则。代码检查器不仅帮助我们更快地捕获错误，而且还强制执行常见的编码风格指南，这对于大型团队尤为重要，因为一致性是关键。
- en: In the following sections, we’ll take a closer look at ESLint and how it can
    help us write better, more consistent code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地探讨ESLint以及它是如何帮助我们编写更好、更一致的代码的。
- en: Installation
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: 'First of all, we have to install ESLint and some plugins as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须安装ESLint和一些插件，如下所示：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once the executable is installed, we can run it with the following command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了可执行文件，我们就可以使用以下命令运行它：
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The output will tell us if there are errors within the file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将告诉我们文件中是否有错误。
- en: When we install and run it for the first time, we do not see any errors because
    it is completely configurable, and it does not come with any default rules.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次安装和运行它时，我们没有看到任何错误，因为它完全可配置，并且它没有自带任何默认规则。
- en: Configuration
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置
- en: 'Let’s start configuring ESLint. It can be configured using a `.eslintrc` file
    that lives in the root folder of the project. To add some rules, let’s create
    a `.eslintrc` file configured for TypeScript and add one basic rule:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始配置ESLint。它可以通过位于项目根目录的`.eslintrc`文件进行配置。为了添加一些规则，让我们创建一个`.eslintrc`文件，配置为TypeScript，并添加一条基本规则：
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This configuration file needs a bit of explanation: `"semi"` is the name of
    the rule and `[2, "never"]` is the value. It is not very intuitive the first time
    you see it.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件需要一些解释：“`semi`”是规则的名称，而`[2, "never"]`是值。第一次看到它时可能不太直观。
- en: 'ESLint rules have three levels that determine the severity of the problem:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint规则有三个级别，用于确定问题的严重性：
- en: '`off` (or `0`): The rule is disabled.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`off`（或`0`）：规则被禁用。'
- en: '`warn` (or `1`): The rule is a warning.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`warn`（或`1`）：规则是一个警告。'
- en: '`error` (or `2`): The rule throws an error.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`error`（或`2`）：规则会抛出一个错误。'
- en: We are using the value `2` because we want ESLint to throw an error every time
    our code does not follow the rule. The second parameter tells ESLint that we want
    the semicolon to never be used (the opposite is *always*). ESLint and its plugins
    are very well documented, and for any single rule, you can find the description
    of the rule and some examples of when it passes and when it fails.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用值`2`是因为我们希望ESLint在代码不遵循规则时每次都抛出错误。第二个参数告诉ESLint我们希望分号永远不被使用（相反是*总是*）。ESLint及其插件都有很好的文档，对于任何单个规则，你都可以找到规则的描述和一些示例，说明它在何时通过以及在何时失败。
- en: 'Now create an `index.ts` file with the following content:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个`index.ts`文件，内容如下：
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If we run `eslint index.js`, we get the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`eslint index.js`，我们会得到以下结果：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is great; we set up the linter and it is helping us follow our first rule.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好；我们设置了代码检查器，它正在帮助我们遵循第一条规则。
- en: 'Here are other rules that I prefer to turn off or change:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我更喜欢关闭或更改的规则：
- en: '[PRE62]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Git Hooks
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git钩子
- en: To avoid having unlinted code in our repository, what we can do is add ESLint
    at one point of our process using Git Hooks. For example, we can use `husky` to
    run our linter in a Git Hook called `pre-commit`, and it is also useful to run
    our unit tests on the Hook called `pre-push`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在我们的仓库中有未检查的代码，我们可以通过Git钩子在我们流程的某个点上添加ESLint。例如，我们可以使用`husky`在名为`pre-commit`的Git钩子中运行我们的代码检查器，并且运行名为`pre-push`的钩子来运行我们的单元测试也是很有用的。
- en: 'To install `husky`, you need to run the following command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`husky`，你需要运行以下命令：
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Then, in our `package.json` file, we can add this node to configure the tasks
    we want to run in the Git Hooks.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`package.json`文件中，我们可以添加这个节点来配置我们想要在Git钩子中运行的任务。
- en: 'Edit the `package.json >` `prepare` script and run it once:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`package.json >` `prepare`脚本并运行一次：
- en: '[PRE64]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add a hook:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个钩子：
- en: '[PRE65]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Make a commit:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 提交一个版本：
- en: '[PRE66]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There is a special option (flag) for the ESlint command called `--fix` – with
    this option, ESLint will try to fix all our linter errors automatically (not all
    of them). Be careful with this option because sometimes it can affect a little
    bit of our code style. Another useful flag is `--ext` to specify the extensions
    of the files we want to validate – in this case, just the `.tsx` and `.ts` files.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint命令有一个特殊的选项（标志）叫做`--fix` – 使用这个选项，ESLint将尝试自动修复我们所有的代码检查错误（不是所有的）。注意这个选项，因为有时它可能会稍微影响我们的代码风格。另一个有用的标志是`--ext`，用于指定我们想要验证的文件扩展名
    – 在这种情况下，只验证`.tsx`和`.ts`文件。
- en: In the next section, you will learn about how **functional programming** (**FP**)
    works and topics such as first-class objects, purity, immutability, currying,
    and composition.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解**函数式编程**（**FP**）是如何工作的，以及诸如首类对象、纯净性、不可变性、柯里化和组合等主题。
- en: Functional programming
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: In addition to following best practices and using a linter to catch errors and
    enforce consistency, another way to clean up our code is to adopt an **FP** style.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了遵循最佳实践和使用代码检查器来捕获错误和强制一致性之外，另一种清理我们代码的方法是采用**FP**风格。
- en: As we discussed in *Chapter 1,* *Taking Your First Steps with React*, React’s
    declarative programming approach makes our code more readable. FP is a declarative
    paradigm as well, where side effects are avoided, and data is considered immutable
    to make the code easier to maintain and reason about.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第一章*，*React入门*中讨论的那样，React的声明式编程方法使我们的代码更易读。FP也是一种声明式范式，其中避免了副作用，并且数据被视为不可变，这使得代码更容易维护和推理。
- en: While we won’t cover FP in depth in this section, we’ll introduce some concepts
    commonly used in React that you should be aware of.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会在本节深入探讨FP，但我们会介绍一些在React中常用且你应该了解的概念。
- en: FP principles, such as immutability, pure functions, and higher-order functions,
    can help us write more maintainable and testable code. By treating our data as
    immutable, we can avoid side effects and make it easier to reason about the flow
    of our application. Pure functions, which always return the same output for the
    same input, help us avoid unintended side effects and make our code easier to
    test. Higher-order functions, which take functions as arguments and/or return
    functions as output, can help us create more modular and reusable code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: FP原则，如不可变性、纯净函数和高阶函数，可以帮助我们编写更易于维护和测试的代码。通过将我们的数据视为不可变，我们可以避免副作用，并使我们的应用程序流程更容易推理。总是对相同的输入返回相同输出的纯净函数帮助我们避免意外的副作用，并使我们的代码更容易测试。接受函数作为参数并/或返回函数作为输出的高阶函数可以帮助我们创建更模块化和可重用的代码。
- en: By adopting an FP style, we can write more declarative and less imperative code,
    making our components easier to read and reason about.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用FP风格，我们可以编写更多声明式代码和更少的命令式代码，使我们的组件更容易阅读和推理。
- en: First-class functions
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首类函数
- en: JavaScript has first-class functions because they are treated like any other
    variable, meaning you can pass a function as a parameter to other functions, or
    it can be returned by another function and be assigned as a value to a variable.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有首类函数，因为它们被当作任何其他变量一样对待，这意味着你可以将一个函数作为参数传递给其他函数，或者它可以被另一个函数返回并赋值给一个变量。
- en: This allows us to introduce the concept of **Higher-Order Functions** (**HoFs**).
    HoFs are functions that take a function as a parameter, and optionally some other
    parameters, and return a function. The returned function is usually enhanced with
    some special behaviors.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们引入**高阶函数**（**HoFs**）的概念。HoFs是接受一个函数作为参数（可选地还有其他参数），并返回一个函数的函数。返回的函数通常具有一些特殊的行为。
- en: 'Let’s look at an example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE67]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, a function is adding two numbers that enhance a function that logs all
    the parameters and then executes the original function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，一个函数正在添加两个数字，它增强了一个记录所有参数并执行原始函数的函数。
- en: This concept is pretty important to understand because, in the React world,
    a common pattern is to use Higher-Order Components to treat our components as
    functions, and to enhance them with common behaviors. We will see HOCs and other
    patterns in *Chapter 4,* *Exploring Popular Composition Patterns*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念非常重要，因为，在React世界中，一个常见的模式是使用高阶组件将我们的组件视为函数，并用共同的行为来增强它们。我们将在*第4章*，*探索流行的组合模式*中看到HOC和其他模式。
- en: Purity
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯度
- en: An important aspect of FP is to write pure functions. You will encounter this
    concept very often in the React ecosystem, especially if you look into libraries
    such as Redux.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的一个重要方面是编写纯函数。你将在React生态系统中经常遇到这个概念，特别是如果你查看像Redux这样的库。
- en: What does it mean for a function to be pure?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 函数要成为纯函数意味着什么？
- en: A function is pure when there are no side effects, which means that the function
    does not change anything that is not local to the function itself.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数是纯的，当且仅当没有副作用，这意味着函数不会改变任何不是函数本身局部的东西。
- en: For example, a function that changes the state of an application, or modifies
    variables defined in the upper scope, or a function that touches external entities,
    such as the **Document Object Model** (**DOM**), is considered impure. Impure
    functions are harder to debug, and most of the time it is not possible to apply
    them multiple times and expect to get the same result.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个改变应用程序状态的函数，或修改在更高作用域中定义的变量，或者一个接触外部实体（如**文档对象模型**（**DOM**））的函数，被认为是非纯函数。非纯函数更难调试，而且大多数时候不可能多次应用并期望得到相同的结果。
- en: 'For example, the following function is pure:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下函数是纯函数：
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It can be run multiple times, always getting the same result, because nothing
    is stored anywhere, and nothing gets modified.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以运行多次，总是得到相同的结果，因为没有任何东西被存储在任何地方，也没有任何东西被修改。
- en: 'The following function is not pure:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数不是纯函数：
- en: '[PRE69]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Running `add(1)` twice, we get two different results. The first time we get
    `1`, but the second time we get `2`, even if we call the same function with the
    same parameter. The reason we get that behavior is that the global state gets
    modified after every execution.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`add(1)`两次，我们得到两个不同的结果。第一次我们得到`1`，但第二次我们得到`2`，即使我们用相同的参数调用相同的函数。我们得到这种行为的原因是全局状态在每次执行后都会被修改。
- en: Immutability
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: We have seen how to write pure functions that don’t mutate the state, but what
    if we need to change the value of a variable? In FP, a function, instead of changing
    the value of a variable, creates a new variable with a new value and returns it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何编写不改变状态的纯函数，但如果我们需要改变变量的值怎么办？在函数式编程（FP）中，一个函数不是改变变量的值，而是创建一个新的变量并返回它，这个变量具有新的值。
- en: This way of working with data is called **immutability**.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种处理数据的方式被称为**不可变性**。
- en: An immutable value is a value that cannot be changed.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不可变值是一个不能被改变的值。
- en: 'Let’s look at an example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE70]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The preceding function doesn’t follow immutability because it changes the value
    of the given array. Again, if we call the same function twice, we get different
    results.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数不遵循不可变性，因为它改变了给定数组的价值。再次强调，如果我们两次调用相同的函数，我们会得到不同的结果。
- en: 'We can change the preceding function to make it immutable using `concat`, which
    returns a new array without modifying the given one:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`concat`将前面的函数改为不可变，它返回一个新数组而不修改给定的数组：
- en: '[PRE71]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: After we have run the function twice, `myArr` still has its original value.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行函数两次后，`myArr`仍然保持其原始值。
- en: Currying
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化
- en: A common technique in FP is currying. `Currying` is the process of converting
    a function that takes multiple arguments into a function one argument at a time
    and returning another function. Let’s look at an example to clarify the concept.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中的一个常见技术是柯里化。`柯里化`是将接受多个参数的函数转换为一次接受一个参数并返回另一个函数的过程。让我们通过一个例子来澄清这个概念。
- en: Let’s start with the `add` function we have seen before and transform it into
    a curried function.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从之前见过的`add`函数开始，将其转换为一个柯里化函数。
- en: 'Say we have the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下代码：
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can instead define the function as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义函数如下：
- en: '[PRE73]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We use it in the following way:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以以下方式使用它：
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This is a pretty convenient way of writing functions because, since the first
    value is stored after the application of the first parameter, we can reuse the
    second function multiple times.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相当方便的编写函数的方法，因为第一个值在应用第一个参数后存储，我们可以多次重用第二个函数。
- en: Composition
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: Finally, an important concept in FP that can be applied to React is **composition**.
    Functions (and components) can be combined to produce new functions with more
    advanced features and properties.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个在函数式编程中非常重要且可以应用于React的概念是**组合**。函数（和组件）可以组合在一起，产生具有更高级功能和属性的新函数。
- en: 'Consider the following functions:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数：
- en: '[PRE75]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'These functions can be composed together to create a new function that adds
    two numbers and then doubles the result:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以组合在一起，创建一个新的函数，该函数先加两个数字，然后将结果加倍：
- en: '[PRE76]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Following this paradigm, we end up with small, simple, testable pure functions
    that can be composed together.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种范式，我们最终得到的是小型、简单、可测试的纯函数，它们可以组合在一起。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered the fundamentals of JSX, including its syntax
    and features. We have also learned how to configure Prettier and ESLint to maintain
    consistency and catch errors early on in our codebase. Additionally, we have explored
    some essential concepts of functional programming, which can help us write more
    maintainable and testable code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了JSX的基础知识，包括其语法和功能。我们还学习了如何配置Prettier和ESLint以保持代码库的一致性，并在代码早期阶段捕获错误。此外，我们还探讨了函数式编程的一些基本概念，这些概念可以帮助我们编写更易于维护和测试的代码。
- en: With our code now clean and well-organized, we are ready to dive deeper into
    React and learn how to write truly reusable components in the next chapter. By
    following best practices and adopting good coding habits, we can create React
    applications that are easier to maintain, scale, and test.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将代码整理得干净、有序，我们准备深入探索React，并在下一章学习如何编写真正可重用的组件。通过遵循最佳实践和养成良好的编码习惯，我们可以创建易于维护、扩展和测试的React应用程序。
- en: Join our community on Discord
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/React18DesignPatterns4e](https://packt.link/React18DesignPatterns4e)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/React18DesignPatterns4e](https://packt.link/React18DesignPatterns4e)'
- en: '![](img/QR_Code2450023176943770109.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code2450023176943770109.png)'
