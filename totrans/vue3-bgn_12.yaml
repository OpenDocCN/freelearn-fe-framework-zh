- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Achieving Client-Side Validation with VeeValidate
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 VeeValidate 实现客户端验证
- en: A website is not complete until it has a form of some sort. Contact Us, feedback,
    and comment forms are just a few examples that we may be required to develop and
    validate in our Vue.js application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网站在拥有某种形式的表单之前是不完整的。联系我们、反馈和评论表单只是我们可能需要在 Vue.js 应用程序中开发和验证的几个例子。
- en: In this chapter, we will explain what makes a semantically correct form, introduce
    the available fields, and talk through its accessibility needs. We will then update
    our `CreatePost` component and learn how to handle form fields and manage two-way
    binding using `v-model`. Next, we will move on to creating a new form called `contactUs`.
    This will be used to introduce a new package called **VeeValidate**. Finally,
    we will learn how to develop custom validation rules and how to simplify our validation
    by using VeeValidate preset rules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释什么构成了语义正确的表单，介绍可用的字段，并讨论其无障碍需求。然后，我们将更新我们的 `CreatePost` 组件，学习如何处理表单字段和管理使用
    `v-model` 的双向绑定。接下来，我们将继续创建一个新的表单，称为 `contactUs`。这将用于介绍一个新的包，称为 **VeeValidate**。最后，我们将学习如何开发自定义验证规则，以及如何通过使用
    VeeValidate 预设规则简化我们的验证。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Understanding forms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解表单
- en: Two-way binding with `v-model`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `v-model` 进行双向绑定
- en: Controlling your form using VeeValidate
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 VeeValidate 控制你的表单
- en: Defining your form validation with VeeValidate
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 VeeValidate 定义你的表单验证
- en: By the end of the chapter, you should have gained a good understanding of forms
    and how to handle them in Vue.js. You will be able to define well-structured and
    accessible forms, handle user input with `v-model`, and define complex forms with
    validation using VeeValidate.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对表单及其在 Vue.js 中的处理有了很好的理解。你将能够定义结构良好且无障碍的表单，使用 `v-model` 处理用户输入，并使用
    VeeValidate 定义具有验证的复杂表单。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, the branch is called `CH12`. To pull this branch, run the
    following command or use your GUI of choice to support you in this operation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，分支被命名为 `CH12`。要拉取此分支，请运行以下命令或使用你选择的 GUI 来支持此操作：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners)
    找到。
- en: Understanding forms
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解表单
- en: Whether you are new to development or you already have some experience, it is
    important to spend a bit of time looking at what makes a good form and how to
    best define forms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是开发新手还是有经验，花点时间了解什么构成了一个好的表单以及如何最佳地定义表单都是很重要的。
- en: I started to learn forms over 10 years ago but still, for me, there was something
    new to learn while I completed my research for this chapter. HTML5 enhancement
    and accessibility requirements have modified the way we define forms. In this
    section, we are going to understand what makes a good form, and then, in later
    sections, we will use this knowledge to define some forms in our Companion App.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 10 年前开始学习表单，但即便如此，在我完成本章研究的过程中，我仍然发现了一些新的东西可以学习。HTML5 的增强和无障碍要求已经改变了我们定义表单的方式。在本节中，我们将了解什么构成了一个好的表单，然后在后面的章节中，我们将利用这些知识在我们的伴侣应用中定义一些表单。
- en: In most static sites, such as brochure sites or blogs, forms are the only time
    in which a user interacts with your site, and as such, they need to offer a great
    user experience (UX) and be as accessible as possible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数静态网站中，例如宣传册网站或博客，表单是用户与你的网站互动的唯一时刻，因此它们需要提供出色的用户体验（UX）并尽可能的无障碍。
- en: 'A good form includes three different aspects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的表单包括三个不同的方面：
- en: It is semantically correct
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有语义正确性
- en: It is accessible
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是无障碍的
- en: It is validated
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它经过了验证
- en: By the end of this chapter, we will have covered all three aspects, and you
    will be able to create great forms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将涵盖所有三个方面，你将能够创建出色的表单。
- en: Let’s start with the first point and see what makes a good HTML structure. Using
    the correct HTML is not only going to improve our UX but it is also going to set
    the foundation for the accessibility work that will be covered later in the section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个要点开始，看看什么构成了一个好的 HTML 结构。使用正确的 HTML 不仅会提升我们的用户体验，也会为稍后本节中将要讨论的无障碍工作打下基础。
- en: Please note that this book is not about basic HTML and JavaScript but it focuses
    on Vue.js. For this reason, this section is just going to be a very quick introduction
    to forms; we will not spend too much time going into the details but will cover
    the main topics so that you can follow the rest of the chapter at ease and ensure
    that your form is well structured.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这本书不是关于基本的HTML和JavaScript，而是专注于Vue.js。因此，本节将只是一个非常快速的对表单的介绍；我们不会花太多时间深入细节，但会涵盖主要主题，这样你可以轻松地跟随本章的其余部分，并确保你的表单结构良好。
- en: Wrapping your form within the <form> element
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将你的表单包裹在<form>元素中
- en: Let’s start with the basics that are often overlooked. All forms need to be
    wrapped within a `<form>` element. This is not just something nice to do but it
    also has some very important meaning behind it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从经常被忽视的基本知识开始。所有表单都需要被包裹在`<form>`元素中。这不仅仅是一件好事，它背后还有一些非常重要的意义。
- en: Using the `<form>` element has three benefits. First, it informs the browser
    about the presence of a form (important for browser extension). Second, it improves
    the UX for visually impaired users who use a screen reader (software that reads
    the page for users) by supporting **Form** mode (a specific mode used by screen
    readers to complete forms on websites). Next, it helps to handle validation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<form>`元素有三个好处。首先，它通知浏览器存在表单（对浏览器扩展很重要）。其次，它通过支持**表单**模式（屏幕阅读器用于在网站上完成表单的特定模式）来提高使用屏幕阅读器的视觉障碍用户的用户体验。接下来，它有助于处理验证。
- en: You may be asking yourself how the use of the `<form>` element improves UX.
    Well, have you ever wondered why, sometimes, a form can be submitted by pressing
    the *Enter* key and sometimes it can’t? Well, this is driven by the `<form>` element.
    When a form is wrapped in a `<form>` element, if the user clicks the *Enter* key
    while completing it, the form will trigger its `submit` method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道使用`<form>`元素如何提高用户体验。好吧，你有没有想过为什么有时可以通过按*Enter*键提交表单，而有时却不能？好吧，这是由`<form>`元素驱动的。当一个表单被包裹在`<form>`元素中时，如果用户在完成表单时按下*Enter*键，表单将触发其`submit`方法。
- en: Do not forget labels
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要忘记标签
- en: The topic of the `<label>` element holds a special place in my heart. Many developers
    and designers miss the importance of this element and either remove it from the
    UI or misuse it. There was a trend a few years ago to develop compact form designs
    in which the placeholder replaced the label. These forms seemed very clear and
    started to be used everywhere, but they were a big failure from a UX perspective.
    Even if they look great, they can be hard to use because the placeholder disappears
    as soon as the user (or the browser) types something in the field and cannot be
    seen again until the user removes the entry.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`<label>`元素的主题在我心中占有特殊的位置。许多开发者和设计师忽略了这一元素的重要性，要么将其从UI中移除，要么误用它。几年前，有一种趋势是开发紧凑的表单设计，其中占位符取代了标签。这些表单看起来非常清晰，开始被到处使用，但从用户体验的角度来看，它们是一个巨大的失败。即使它们看起来很棒，它们也可能很难使用，因为占位符在用户（或浏览器）在字段中输入内容后就会消失，并且无法再次看到，直到用户删除输入。'
- en: Another problem with labels is the fact that they are essential from an accessibility
    perspective. In fact, without them, a visually impaired user would not be able
    to know what the field is about and, therefore, would be unable to fill in the
    form completely.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 标签的另一个问题是它们在可访问性方面是必不可少的。事实上，没有它们，视觉障碍用户将无法知道字段的内容，因此将无法完全填写表单。
- en: 'A label can be used in two different ways. It can either be used as a standalone
    element, using the ID to link it to an input field, or it can wrap the input field
    to which it belongs:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 标签可以用两种不同的方式使用。它既可以作为一个独立的元素使用，使用ID将其链接到输入字段，也可以将其包裹在它所属的输入字段中：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both methods are semantically correct, and their use is usually driven by the
    design that you may need to achieve.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在语义上都是正确的，它们的使用通常是由你可能需要实现的设计驱动的。
- en: There is more than just type=”text”
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不仅仅是type="text"
- en: As I mentioned before, I started using forms a long time ago, and one thing
    that has progressed over time is the different types of input available nowadays
    and supported in all major browsers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，我很早就开始使用表单了，随着时间的推移，有一件事是进步的，那就是现在所有主流浏览器都支持的输入类型的不同。
- en: 'This is the list of all available input types:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有可用输入类型的列表：
- en: '`button`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按钮`'
- en: '`checkbox`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`复选框`'
- en: '`color`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`颜色`'
- en: '`date`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`日期`'
- en: '`datetime-local`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`日期时间`'
- en: '`email`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`电子邮件`'
- en: '`file`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文件`'
- en: '`hidden`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`隐藏`'
- en: '`image`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图片`'
- en: '`month`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`月份`'
- en: '`number`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数字`'
- en: '`password`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`密码`'
- en: '`radio`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`单选按钮`'
- en: '`range`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range`'
- en: '`reset`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset`'
- en: '`search`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search`'
- en: '`submit`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit`'
- en: '`tel`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tel`'
- en: '`text`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`'
- en: '`time`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`'
- en: '`url`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`'
- en: '`week`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`week`'
- en: Browsers offer fields for telephone numbers, dates, and even for email. But
    what would be the benefit of using them? Why not just use a simple `text` field?
    Well, the difference may not be in the way the field looks but, rather, in the
    way the field works.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器提供了电话号码、日期甚至电子邮件的字段。但使用它们的益处是什么？为什么不用一个简单的`text`字段呢？好吧，区别可能不在于字段的外观，而在于字段的工作方式。
- en: Different fields may trigger different UIs. For example, a `date` field will
    open a calendar when clicked, a `number` field might show little toggles, and
    so on. This improvement in UX is even more noticeable on mobile phones where handsets
    can provide well-defined native components to support users in completing their
    forms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的字段可能会触发不同的UI。例如，点击日期字段会打开日历，数字字段可能会显示小开关，等等。这种UX的改进在手机上尤为明显，因为手机可以提供定义良好的原生组件来支持用户完成表单。
- en: Setting your form to be autocompleted
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置表单以自动填充
- en: Who doesn’t love a form that is completely autocompleted by the browser? Luckily
    for us, browsers are working very hard to complete as much of the form as possible
    out of the box. There are a couple of things that we can do to help browsers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 谁不喜欢一个完全由浏览器自动填充的表单呢？幸运的是，浏览器正在非常努力地工作，以便尽可能多地自动填充表单。我们可以做几件事情来帮助浏览器。
- en: 'First and foremost, we need to inform the browser that we would like the form
    to be autocompleted. This is not done automatically but requires the `<form>`
    element to receive an `autocomplete` attribute:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通知浏览器我们希望表单能够自动填充。这不是自动完成的，而是需要`<form>`元素接收一个`autocomplete`属性：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next is ensuring that we describe the field with the correct name, as browsers
    can read the name and assign the correct field. So, if a field is an address,
    you should give it the proper name of `address` and not use shorthand such as
    `addr` or something else that the browser cannot understand.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是确保我们用正确的名称描述字段，因为浏览器可以读取名称并分配正确的字段。所以，如果一个字段是地址，你应该给它正确的`address`名称，而不是使用像`addr`或其他浏览器无法理解的缩写。
- en: 'Last but not least is defining the correct value to assign to the autocomplete
    attribute. Setting `autocomplete` on the main form may not be all that is needed.
    Sometimes, as in the case of browser extension used to autocomplete your passwords,
    the browser requires further information, and this can be passed using the `autocomplete`
    attribute directly on the field. `autocomplete` can accept different values depending
    on the role of the input. Here are some examples:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，定义正确的值来分配给自动完成属性。在主表单上设置`autocomplete`可能并不足够。有时，例如在用于自动填充密码的浏览器扩展程序的情况下，浏览器需要更多信息，这可以通过在字段上直接使用`autocomplete`属性来传递。`autocomplete`可以接受不同的值，具体取决于输入的角色。以下是一些示例：
- en: 'For a username:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于用户名：
- en: '[PRE3]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For a sign-up form:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于注册表单：
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For signing in:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于登录：
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown by the username example, the type and name of the input do not have
    to match their `autocomplete` value. In fact, in the case of the username, even
    if the browser sees and uses the field as an email, a password tool would fill
    the field with the username.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如用户名示例所示，输入的类型和名称不必与它们的`autocomplete`值匹配。实际上，在用户名的情况下，即使浏览器看到并使用该字段作为电子邮件，密码工具也会用用户名填充该字段。
- en: In this section, we have learned how to define a good form. Wrapping the form
    in `<form>`, setting `autocomplete`, defining the correct labels for each field,
    and using the correct input type are just a few steps that we can take to ensure
    that our users have a great experience in filling out our form.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何定义一个好的表单。将表单包裹在`<form>`中，设置`autocomplete`，为每个字段定义正确的标签，以及使用正确的输入类型，这些都是我们可以采取的几个步骤，以确保我们的用户在填写我们的表单时拥有良好的体验。
- en: In the next section, we will learn how to define and use forms in Vue.js and
    how the framework can help us improve the UX further.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何定义和使用Vue.js中的表单，以及框架如何帮助我们进一步改进UX。
- en: Two-way binding with v-model
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用v-model的双向绑定
- en: In the previous section, we learned how our form should be defined, and it is
    now time to put this learning into practice by enhancing our Companion App with
    a couple of forms. In this section, we will learn how to use `v-model` to enable
    our input field to accomplish two-way binding, which is a term used to describe
    when a field can emit change events and update values simultaneously (hence two-way).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个部分，我们学习了我们的表单应该如何定义，现在是时候通过在我们的伴侣应用中添加几个表单来将我们的学习付诸实践了。在本节中，我们将学习如何使用`v-model`使我们的输入字段实现双向绑定，这是一个术语，用来描述当字段可以同时发出更改事件和更新值时（因此是双向的）。
- en: In the previous chapter, we mentioned that the solution used to manage the value
    in the `CreatePost` component was suboptimal, and it is now time to align it to
    use the best industry standards.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们提到用来在`CreatePost`组件中管理值的解决方案是次优的，现在是时候将其调整为使用最佳行业标准了。
- en: Let’s start by rephrasing what two-way binding really achieves. Let’s consider
    an input field, for example. Until now, we have learned how to set the value of
    this field using `ref`. The use of `ref` allows us to set the value of a specific
    input field at load, but this is not very useful when it comes to forms, as we
    want the value to be set by the visitor’s input. In the previous chapter, we learned
    how to use events to emit change, so in the case of an input field, we could emit
    a change event that changes the R`ef` variable and, in turn, updates the value
    of the field.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先重新阐述双向绑定真正实现的内容。让我们以一个输入字段为例。到目前为止，我们已经学习了如何使用`ref`设置该字段的值。`ref`的使用允许我们在加载时设置特定输入字段的值，但当我们想要通过访客的输入来设置值时，这并不很有用。在前一章中，我们学习了如何使用事件来发出更改，因此，在输入字段的案例中，我们可以发出一个更改事件，该事件会改变`Ref`变量，进而更新字段的值。
- en: 'This would look something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能像这样：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Even if the preceding code does achieve two-way binding, it does not really
    look clean, and adding this all over our forms would make the HTML very hard to
    read.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 即使前面的代码确实实现了双向绑定，它看起来并不整洁，而且在我们所有的表单中添加这些代码会使HTML非常难以阅读。
- en: Luckily for us, the Vue.js framework has a nice shortcut that will make our
    HTML clean, called `v-model`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Vue.js框架有一个很好的快捷方式可以使我们的HTML更简洁，称为`v-model`。
- en: 'Changing the preceding to use `v-model` would result in the following syntax:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码改为使用`v-model`将导致以下语法：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Behind the scenes, `v-model` and the `event`/`value` syntax produce the same
    code, but due to the clean and concise code of `v-model`, it is the suggested
    option to achieve two-way binding when possible (there may be cases in which we
    would need to handle events manually to handle specific side effects; in these
    scenarios, the `event`/`value` syntax may be preferred).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 幕后，`v-model`和`event`/`value`语法生成相同的代码，但由于`v-model`的代码简洁，当可能时，它是建议的选项来实现双向绑定（可能存在我们需要手动处理事件以处理特定副作用的情况；在这些场景中，`event`/`value`语法可能更受欢迎）。
- en: 'Now that we have learned about the syntax and how to define the form, let’s
    go back and apply our learning to the `CreatePost` component:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了语法以及如何定义表单，让我们回到`CreatePost`组件并应用我们的学习：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s break down all the changes we applied to our form. First, we removed the
    R`ef` initialization of `createPostForm`. This reference was made to hold the
    value of the HTML form, but this is no longer needed after the refactor. Next,
    we created a reference called `postText` that will hold the value of our input
    field. We then added `v-model` within our input field, assigning it to the newly
    created `postText`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们对表单所做的所有更改。首先，我们移除了`createPostForm`的`Ref`初始化。这个引用是为了保存HTML表单的值，但在重构之后不再需要。接下来，我们创建了一个名为`postText`的引用，它将保存我们输入字段的值。然后我们在输入字段中添加了`v-model`，将其分配给新创建的`postText`。
- en: At the first load, the input field is going to be an empty string (`const postText
    = ref("");)`, but this value is going to be automatically updated by `v-model`
    as the user types into the input field. Behind the scenes, `v-model` assigns the
    value on the first load and then automatically updates it every time the input
    field emits a change event.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次加载时，输入字段将是一个空字符串（`const postText = ref("");`），但这个值将由`v-model`在用户输入到输入字段时自动更新。幕后，`v-model`在首次加载时分配值，然后每次输入字段发出更改事件时自动更新它。
- en: While refactoring the form, we also introduced a small enhancement by adding
    a `.prevent` modifier to the `@submit` event. Doing so automatically calls `event.preventDefault()`
    when submitting our form.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构表单时，我们还通过向`@submit`事件添加`.prevent`修饰符引入了一个小的增强。这样做会在提交表单时自动调用`event.preventDefault()`。
- en: The last change is in the payload of the `addPost` method. This method is now
    using `postText.value` instead of using the input reference to get the value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改是在`addPost`方法的负载中。现在该方法使用`postText.value`而不是使用输入引用来获取值。
- en: Quick reminder
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 快速提醒
- en: Just a quick reminder that using Template Ref to get an input value was just
    used for teaching purposes and should not be used in real life. Using Template
    R`ef` to access the HTML object should just be used for methods and actions that
    cannot be achieved with basic Vue.js features such as directives, computed properties,
    and events.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，使用模板引用（Template Ref）来获取输入值仅用于教学目的，不应在实际生活中使用。使用模板引用（R`ef`）来访问HTML对象仅应用于无法通过基本Vue.js功能（如指令、计算属性和事件）实现的方法和动作。
- en: At this stage, the form is fully working using Vue.js two-way binding supported
    by `v-model`. If we try to use the form, this will work as expected and either
    create a post or show the browser native validation on incorrect input, as shown
    in *Figure 12**.1*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，表单完全使用Vue.js支持的双向绑定和`v-model`功能正常工作。如果我们尝试使用表单，这将按预期工作，要么创建一个帖子，要么在输入错误时显示浏览器原生的验证，如图*图12**.1*所示。
- en: '![Figure 12.1: Native validation message shown in the Create a Post form](img/B21130_12_01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：在创建帖子表单中显示的原生验证消息](img/B21130_12_01.jpg)'
- en: 'Figure 12.1: Native validation message shown in the Create a Post form'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：在创建帖子表单中显示的原生验证消息
- en: With the knowledge you have gained in this section, you will be able to create
    forms and handle user input within your application. In many scenarios, the validation
    offered by the native browser is either not “pretty” enough or does not fulfill
    the validation requirement of the form.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在本节中获得的知识，你将能够创建表单并在你的应用程序中处理用户输入。在许多情况下，原生浏览器的验证要么不够“美观”，或者不能满足表单的验证要求。
- en: For this reason, in the next section, we are going to learn how to use an external
    package called VeeValidate to control the validation of our forms.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在下一节中，我们将学习如何使用名为VeeValidate的外部包来控制我们表单的验证。
- en: Controlling your form using VeeValidate
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VeeValidate控制你的表单
- en: In the previous section, we learned how to handle user input such as form fields
    using `v-model`, but in real life, handling forms is a little more complicated
    than just setting two-way binding.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用`v-model`处理用户输入，如表单字段，但在现实生活中，处理表单比仅仅设置双向绑定要复杂得多。
- en: In fact, a complete form will include complex validation and error handling,
    just to name a couple. Even if we could achieve this feature manually using Vue.js,
    we would probably end up investing a lot of time and effort in something that
    is well handled by an external package. For this reason, in this section, we are
    going to introduce **VeeValidate**, which is a package aimed at making form development
    easy.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一个完整的表单将包括复杂的验证和错误处理，仅举两个例子。即使我们能够手动使用Vue.js实现这些功能，我们也可能花费大量时间和精力在由外部包很好地处理的事情上。因此，在本节中，我们将介绍**VeeValidate**，这是一个旨在使表单开发变得简单的包。
- en: 'On the official website ([https://vee-validate.logaretm.com/](https://vee-validate.logaretm.com/)),
    VeeValidate is described as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方网站([https://vee-validate.logaretm.com/](https://vee-validate.logaretm.com/))上，VeeValidate被描述如下：
- en: “VeeValidate is the most popular Vue.js form library. It takes care of value
    tracking, validation, errors, submissions and more.”
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: “VeeValidate是最受欢迎的Vue.js表单库。它负责值跟踪、验证、错误、提交等。”
- en: Using an external package is not required for every single form you will ever
    write, but it is useful if you want to create a well-written form, as the package
    provides you with a consistent way to define and handle logic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个你将要编写的表单都需要使用外部包，但如果你想创建一个高质量的表单，这个包会为你提供一个一致的方式来定义和处理逻辑。
- en: 'The first step when dealing with a Node package is its installation. To install
    VeeValidate, we will have to open the terminal at the root of our project and
    run the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 处理Node包的第一步是安装它。要安装VeeValidate，我们需要打开项目根目录下的终端并运行以下命令：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command will add the package to our repository for us to import and use.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将包添加到我们的存储库中，以便我们可以导入和使用。
- en: In the next step, we will create a form and learn how to use this package to
    make form development easy and consistent. We could have reused the **Create a
    Post** form, but we will create a new one so that you have both examples to look
    at in the future within your code base.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将创建一个表单，并学习如何使用这个包使表单开发变得简单且一致。我们本可以使用“创建帖子”表单，但我们将创建一个新的，这样你就可以在将来的代码库中查看两个示例。
- en: Some of the scaffolding for this new form is already in place. We have a new
    button on the sidebar with the label `router` object, and a Vue.js component called
    `ContactView.vue` that uses the static template we defined in a previous chapter.
    Last but not least, we also have a basic page scaffolding with a component called
    `ContactUs` that is going to be our playground for the creation of this new form.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新表单的一些基本框架已经就位。我们在侧边栏上有一个新的按钮，标签为`router`对象，还有一个名为`ContactView.vue`的Vue.js组件，它使用我们在前一章中定义的静态模板。最后但同样重要的是，我们还有一个基本的页面框架，其中包含一个名为`ContactUs`的组件，它将成为我们创建这个新表单的游乐场。
- en: 'To better understand VeeValidate, we are going to build our form in steps,
    starting from the basic form creation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解VeeValidate，我们将分步骤构建我们的表单，从基本的表单创建开始：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We created a `<form>` element with a `submit` event attached to a method called
    `handleSubmit`. We then defined two labels, one for `email` and the other for
    `message`, and finally, a button that will be used to submit the form.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个带有`submit`事件绑定到名为`handleSubmit`的方法的`<form>`元素。然后我们定义了两个标签，一个用于`email`，另一个用于`message`，最后是一个用于提交表单的按钮。
- en: You may have noticed that we do not have any input fields yet. These were omitted
    on purpose because they are going to use built-in components offered by VeeValidate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们还没有任何输入字段。这些是有意被省略的，因为它们将使用VeeValidate提供的内置组件。
- en: Using VeeValidate will take full control of the form, including its state, meaning
    that we will not have to define or manage the individual values as we did in the
    previous example with `v-model`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用VeeValidate将完全控制表单，包括其状态，这意味着我们不需要像在之前的例子中使用`v-model`那样定义或管理单个值。
- en: The way in which VeeValidate can make this happen is with the use of built-in
    components that are purposely built to handle and manage the form for us.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: VeeValidate能够实现这一点的途径是使用专门构建来为我们处理和管理表单的内置组件。
- en: 'In this section, we are going to look at three components: `Form`, `Field`,
    and `ErrorMessage`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看三个组件：`Form`、`Field`和`ErrorMessage`。
- en: The `Form` component is going to replace the native <form> element available
    in HTML. `Field` is going to take the place of the `<input>` field, and finally,
    `ErrorMessage` is going to be used to display a custom message if the field enters
    an `error` state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form`组件将取代HTML中可用的原生`<form>`元素。`Field`将取代`<input>`字段，最后，`ErrorMessage`将用于在字段进入`error`状态时显示自定义消息。'
- en: 'Let’s go back to our form and update it to use the new built-in components
    and then talk through how they got used:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的表单，并更新它以使用新的内置组件，然后讨论它们是如何被使用的：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our form is now updated to use VeeValidate. The first change may not be very
    noticeable, but it includes the change of the `<form>` element to the VeeValidate
    custom element, `<Form>`. The custom `<Form>` element is used by VeeValidate to
    handle the form values’ state.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将表单更新为使用VeeValidate。第一个变化可能不太明显，但它包括将`<form>`元素更改为VeeValidate自定义元素`<Form>`。自定义`<Form>`元素由VeeValidate用于处理表单值的状态。
- en: Next, we accompanied each label with a `Field` component. This component is
    imported from the `vee-validate` package.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为每个标签配对了一个`Field`组件。这个组件是从`vee-validate`包中导入的。
- en: The `Field` component is very similar to native form elements such as `<input>`
    and `<radio>` and accepts most of the attributes that you would use in a native
    input, such as placeholder and name type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Field`组件与原生的表单元素（如`<input>`和`<radio>`）非常相似，并接受大多数你会在原生输入中使用的属性，例如占位符和名称类型。'
- en: 'We created two fields. The first field is used for the email and has three
    attributes: `id`, `type` (which is `email`), and `name`, which is going to be
    used to connect the field with its error messages.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个字段。第一个字段用于电子邮件，有三个属性：`id`、`type`（它是`email`）和`name`，它将被用来将字段与其错误消息连接起来。
- en: The second field is associated with `message`; it is similar to the previous
    field used for the email, with the only difference being an extra attribute called
    `as`. This property is used to specify which form element the field should be
    rendered as. When using the `Field` component without using the `as` property,
    it defaults to an `<input>` element. In fact, for our message, we want the field
    to be a text area, and we achieved this by using the `as` property and assigning
    it a value of `textarea`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字段与`message`相关联；它与用于电子邮件的前一个字段类似，唯一的区别是有一个额外的属性称为`as`。这个属性用于指定字段应该渲染为哪个表单元素。当使用不带`as`属性的`Field`组件时，它默认为`<input>`元素。实际上，对于我们的消息，我们希望字段是一个文本区域，我们通过使用`as`属性并将其赋值为`textarea`来实现这一点。
- en: 'At this stage, the form has the HTML and the logic required to function. If
    we open our application at `http://localhost:5173/contact` and fill in the form,
    we will be able to see the form being submitted in the console:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，表单已经有了使其功能所需的HTML和逻辑。如果我们打开我们的应用程序在`http://localhost:5173/contact`并填写表单，我们将在控制台看到表单正在提交：
- en: '![Figure 12.2: Console message triggered by the Contact Us form](img/B21130_12_02.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2：由“联系我们”表单触发的控制台消息](img/B21130_12_02.jpg)'
- en: 'Figure 12.2: Console message triggered by the Contact Us form'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：由“联系我们”表单触发的控制台消息
- en: Even if we have not finished yet with VeeValidate, you should be able to see
    the benefits that it brings. You may have realized that we never had to declare
    any references for the email and message or define any two-way binding with `v-model`.
    All of this is handled behind the scenes by the package with the `Form` and `Field`
    custom fields.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们对VeeValidate还没有完成，你也应该能够看到它带来的好处。你可能已经意识到，我们从未需要为电子邮件和消息声明任何引用或使用`v-model`定义任何双向绑定。所有这些都在后台由带有`Form`和`Field`自定义字段的包处理。
- en: In this section, we have added VeeValidate to our form and learned what benefits
    this will bring to our application. We then refactored our `Field` and `Form`
    components.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经将VeeValidate添加到我们的表单中，并学习了这将给我们的应用程序带来哪些好处。然后我们重构了我们的`Field`和`Form`组件。
- en: 'We have just one more modification to apply to our form before we can complete
    this chapter: validation. The preceding example shows that I was able to submit
    a form with incorrect values such as a fake email and a very short message. In
    the next section, we are going to learn how to use form validation with VeeValidate.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章之前，我们只需要对我们的表单进行最后一次修改：验证。前面的例子显示，我能够提交一个包含错误值（如伪造的电子邮件和非常简短的消息）的表单。在下一节中，我们将学习如何使用VeeValidate进行表单验证。
- en: Defining your form validation with VeeValidate
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VeeValidate定义您的表单验证
- en: A form is never complete until there is some sort of validation. The values
    of the form are sent to our servers, and we want to make sure that our forms can
    help the user with immediate feedback if any of the field values are incorrect.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表单只有在某种形式的验证之后才算完整。表单的值会发送到我们的服务器，我们希望确保我们的表单可以在任何字段值不正确时为用户提供即时反馈。
- en: In our case, the form we used in *Figure 12**.2* would have failed backend validation
    as the email was not in the correct format. In this section, we are going to learn
    how to create custom validation and introduce another supporting package offered
    by VeeValidate that includes a preset group of validation rules to speed up our
    development.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们在*图12.2*中使用的表单将无法通过后端验证，因为电子邮件格式不正确。在本节中，我们将学习如何创建自定义验证，并介绍VeeValidate提供的另一个支持包，该包包含一组预置的验证规则，以加快我们的开发速度。
- en: Frontend validation is not enough
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前端验证是不够的
- en: Remember that frontend validation like the one performed by VeeValidate is just
    going to improve the UX but it is not secure enough as it can easily be bypassed.
    When working with forms, you should also define validation on the backend. Using
    validation schemas that work on both the frontend and backend, such as Zod, can
    help.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，像VeeValidate执行的前端验证只能提高用户体验，但它的安全性不足，因为它很容易被绕过。当与表单一起工作时，您还应该在后端定义验证。使用同时在前端和后端工作的验证模式，例如Zod，可以帮助。
- en: VeeValidate offers the possibility to define its rules using either a declarative
    approach or by using composition functions (a set of composable functions offered
    by VeeValidate that can used to create your own form components). For the scope
    of this book, we are going to use the declarative method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: VeeValidate提供了使用声明式方法或使用组合函数（VeeValidate提供的一组可组合函数，可用于创建自己的表单组件）来定义其规则的可能性。对于本书的范围，我们将使用声明式方法。
- en: To validate our input fields, we need to define some validation rules. These
    rules are going to be methods that run a specific condition on one or more input
    fields. An example could be a `required` validation that would check whether the
    value of an input is defined, or a *minimum characters* rule that would check
    whether the number of characters is equal to or greater than the limit set.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们的输入字段，我们需要定义一些验证规则。这些规则将是运行在单个或多个输入字段上的特定条件的方法。一个例子可能是一个`required`验证，它会检查输入值是否已定义，或者一个`最小字符数`规则，它会检查字符数是否等于或大于设置的极限。
- en: 'The first rule we are going to define is a simple `required` rule. To define
    a rule, we use a VeeValidate method called `defineRule`. This method accepts two
    arguments. The first is the name of the rule and the second is the function that
    will run to assess the validation. We can add the following code within the `ContactUs.vue`
    file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要定义的第一个规则是一个简单的`required`规则。为了定义一个规则，我们使用一个名为`defineRule`的VeeValidate方法。此方法接受两个参数。第一个是规则名称，第二个是执行验证的函数。我们可以在`ContactUs.vue`文件中添加以下代码：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Declaring a rule validation is not any different from a method that you would
    have defined natively in Vue. In the case of our required rule, we are checking
    whether the value is set and whether it has at least one character by using `!value`
    and `value.length`, respectively. Then, we are either returning `true` (if the
    validation passes successfully) or we are returning a string as an error message.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个规则验证与在Vue中本地定义的方法没有区别。在我们的`required`规则的情况下，我们使用`!value`和`value.length`分别检查值是否设置以及它是否至少有一个字符。然后，我们返回`true`（如果验证成功通过）或者返回一个字符串作为错误信息。
- en: After declaring the rule, all that is left is to use it within a form field.
    Validation rules can be assigned to the `<Field>` element that we used before.
    The `Field` component expects a property called `rules`. This property can either
    accept a string or an object. I prefer the string notation as it is like the native
    validation in HTML but also because it has a shorter syntax that helps keep the
    `<template>` section clear and readable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明规则后，剩下的就是在表单字段中使用它。验证规则可以分配给之前使用的`<Field>`元素。`Field`组件期望一个名为`rules`的属性。此属性可以接受一个字符串或一个对象。我更喜欢字符串表示法，因为它类似于HTML的本地验证，而且因为它有更短的语法，有助于保持`<template>`部分清晰易读。
- en: 'Applying the `required` rule to our `email` field would produce the following
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将`required`规则应用于我们的`email`字段将生成以下代码：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this stage, our form will not be submitted anymore unless the validation
    passes successfully. In fact, VeeValidate will just trigger our `submit` method
    if all fields in the form are valid. The next step required is to display an error
    message to the user when the form is invalid. This can be achieved with another
    component offered by VeeValidate, called `ErrorMessage`. The error message itself
    has already been defined in our validation rule, and VeeValidate is going to take
    care of the logic required to display and hide the message.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，除非验证成功通过，否则我们的表单将不再提交。实际上，如果表单中的所有字段都有效，VeeValidate将仅触发我们的`submit`方法。下一步需要做的是在表单无效时向用户显示错误信息。这可以通过VeeValidate提供的另一个组件实现，称为`ErrorMessage`。错误信息本身已经在我们的验证规则中定义，VeeValidate将负责显示和隐藏信息的逻辑。
- en: 'The `ErrorMessage` component accepts a property of `name` that is used to connect
    it with a specific input field. So, in our case, it is going to be `name="email"`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorMessage`组件接受一个名为`name`的属性，用于将其与特定的输入字段连接。因此，在我们的情况下，它将是`name="email"`：'
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When trying to submit the form, we will now be presented with an error message,
    as shown in *Figure 12**.3*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试提交表单时，现在我们将看到一个错误信息，如图*图12**.3*所示。
- en: '![Figure 12.3: Form displaying a validation error](img/B21130_12_03.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3：显示验证错误的表单](img/B21130_12_03.jpg)'
- en: 'Figure 12.3: Form displaying a validation error'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：显示验证错误的表单
- en: Even if our error is displayed successfully, it does not really stand out as
    it uses the same color as the rest of the text on the page. This is happening
    because the `ErrorMessage` component provided by VeeValidate is just a utility
    component, meaning that it does not actually provide any HTML markup but it is
    used to provide some additional functionality such as handling the error placement
    and visibility.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的错误信息显示成功，它也没有真正突出，因为它使用了与页面上的其余文本相同的颜色。这是因为 VeeValidate 提供的 `ErrorMessage`
    组件只是一个实用组件，这意味着它实际上并不提供任何 HTML 标记，但它用于提供一些额外的功能，例如处理错误位置和可见性。
- en: 'To improve our UI, we can use the `as` property to define an HTML element that
    will be used to wrap the error message, just like we did with `textarea`, we can
    use the attribute "as" to define what HTML field the component should be rendered
    as and add some classes. The code base already has some styles for a class named
    `error`. So, let’s go and modify our `ErrorMessage` component to use this class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进我们的 UI，我们可以使用 `as` 属性来定义一个将用于包装错误信息的 HTML 元素，就像我们处理 `textarea` 一样，我们可以使用
    "as" 属性来定义组件应该渲染为哪个 HTML 字段，并添加一些类。代码库已经为名为 `error` 的类提供了一些样式。所以，让我们去修改我们的 `ErrorMessage`
    组件以使用这个类：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After adding the `as` property and `class` attribute, our component is now going
    to be more prominent on the screen.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加 `as` 属性和 `class` 属性后，我们的组件现在将在屏幕上更加突出。
- en: '![Figure 12.4: Form showing a red error message](img/B21130_12_04.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4：显示红色错误信息的表单](img/B21130_12_04.jpg)'
- en: 'Figure 12.4: Form showing a red error message'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：显示红色错误信息的表单
- en: The form is starting to take shape. The form fields and labels are set, the
    `submit` handler is in place (even if just a dummy one), and the validation rules
    are defined and working.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 表单开始成形。表单字段和标签已设置，`submit` 处理器已就位（即使只是一个占位符），验证规则已定义并正在工作。
- en: In the next and last section of this chapter, we are going to learn about preset
    validation rules offered by VeeValidate. Declaring a simple rule such as `required`
    is simple, but this is not always the case.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节和最后一节中，我们将了解 VeeValidate 提供的预设验证规则。声明一个简单的规则，如 `required`，很简单，但情况并不总是如此。
- en: I personally love to use preset rules as they help me keep components small
    and readable while still being able to provide complex validation rules.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人非常喜欢使用预设规则，因为它们帮助我保持组件小巧且易于阅读，同时仍然能够提供复杂的验证规则。
- en: Using VeeValidate rules
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 VeeValidate 规则
- en: So far, we have just applied a simple validation to the `email` field that checks
    whether it is set, but this would still break as the field is currently going
    to pass validation with just a single character.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是对 `email` 字段应用了一个简单的验证，检查它是否已设置，但即使字段目前只需一个字符就能通过验证，这仍然会导致问题。
- en: In this section, we are going to validate the email (to ensure it is written
    in a valid format) and the message text area (to ensure that we receive a message
    that is at least 100 characters).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将验证电子邮件（以确保其格式有效）和消息文本区域（以确保我们收到的消息至少有 100 个字符）。
- en: Instead of declaring the validation manually by defining its rules, we are going
    to use the `@vee-validate/rules` package and use two of its preset rules to achieve
    our validation requirements.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是通过定义其规则来手动声明验证，而是将使用 `@vee-validate/rules` 包，并使用其两个预设规则来实现我们的验证需求。
- en: VeeValidate offers over 25 rules ([https://vee-validate.logaretm.com/v4/guide/global-validators#vee-validaterules](https://vee-validate.logaretm.com/v4/guide/global-validators#vee-validaterules)),
    including simple rules such as `required`, `numeric`, and `emails`, as well as
    complex ones such as `one_of`, `not_one_of`, and `regex`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: VeeValidate 提供了超过 25 条规则([https://vee-validate.logaretm.com/v4/guide/global-validators#vee-validaterules](https://vee-validate.logaretm.com/v4/guide/global-validators#vee-validaterules))，包括简单的规则，如
    `required`、`numeric` 和 `emails`，以及复杂的规则，如 `one_of`、`not_one_of` 和 `regex`。
- en: 'Before learning the syntax required to use these rules, we need to install
    the package in our application. We can do this by running the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习使用这些规则所需的语法之前，我们需要在我们的应用程序中安装该包。我们可以通过运行以下命令来完成此操作：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The power of VeeValidate and its validation is that it allows us to use more
    than one validation for a single field, allowing us to define complex rules, such
    as the one defined by `password` fields, without the need to write a single line
    of code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: VeeValidate 和其验证的强大之处在于，它允许我们对单个字段使用多个验证，允许我们定义复杂的规则，例如 `password` 字段定义的规则，而无需编写任何代码。
- en: 'To achieve our validation needs, we are going to use the `email` and `min`
    rules:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的验证需求，我们将使用`email`和`min`规则：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let’s analyze our latest code snippets and see how to use validation rules from
    VeeValidate.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析我们最新的代码片段，看看如何使用VeeValidate的验证规则。
- en: First, we manually imported the validation from the `@vee-validate/rules`package.
    We could have imported all rules globally, but I prefer to do it within each component.
    This not only helps me understand the validation used within the component’s scope
    but also helps keep the built size small by ensuring we import the rules that
    we use within the code base.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们手动从`@vee-validate/rules`包中导入验证。我们本来可以全局导入所有规则，但我更喜欢在每个组件内部进行。这不仅帮助我理解组件范围内使用的验证，还能通过确保我们只导入代码库中使用的规则来保持构建大小小。
- en: Then, we removed the `required` rule that we defined previously and replaced
    it with the ones offered by VeeValidate. We then declared two new rules called
    `email` and `min`. We did so using the `defineRule` method with the imported rules
    from `@vee-validate/rules`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们移除了之前定义的`required`规则，并用VeeValidate提供的规则替换了它。我们声明了两个新规则，分别称为`email`和`min`。我们使用从`@vee-validate/rules`导入的规则通过`defineRule`方法做到了这一点。
- en: Next, we have added our validation within the `<template>` section of our component.
    The `rules` property can accept multiple entries separated by the character `|`.
    In the case of `email`, the rules are `"required|email"`, but for `textarea`,
    they are `"required|min:100"`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在组件的`<template>`部分添加了我们的验证。`rules`属性可以接受由字符`|`分隔的多个条目。在`email`的情况下，规则是`"required|email"`，但对于`textarea`，它们是`"required|min:100"`。
- en: Lastly, we added `ErrorMessage` to our message text area.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在消息文本区域添加了`ErrorMessage`。
- en: You may have noticed that the rules used in the `message` field are a little
    different from the ones used in `email`. This is because the `min` rule requires
    an argument that is equal to the number of characters required before the field
    can be marked as valid. To set a specified parameter for a rule, we add a colon
    (`:`) followed by one or more values separated by a comma. For example, to define
    a `max` rule of `164` characters, we would write `rules="max:164"`, while to define
    a rule that allows a number between `10` and `20`, we would write `rules="between:10,20"`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`message`字段中使用的规则与`email`中使用的规则略有不同。这是因为`min`规则需要一个等于字段在标记为有效之前所需字符数的参数。为了为规则设置指定的参数，我们添加一个冒号（`:`）后跟一个或多个用逗号分隔的值。例如，为了定义一个`max`规则为`164`个字符，我们会写`rules="max:164"`，而为了定义一个允许在`10`到`20`之间的数字的规则，我们会写`rules="between:10,20"`。
- en: Rules can be defined as an object
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 规则可以被定义为对象
- en: 'As I mentioned before, the `rules` property can be defined as an object. What
    you choose is personal preference and there is no right or wrong. If we wanted
    to replace the `message` field rule to be an object, we would write `rules="{
    required: true,` `min: 100}"`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '如我之前提到的，`rules`属性可以被定义为对象。你的选择是个人喜好，没有对错之分。如果我们想将`message`字段规则替换为对象，我们会写`rules="{
    required: true, min: 100}"`。'
- en: In this section, we have learned how to validate our form. We first learned
    how to define and use validation rules by creating a simple `required` validation,
    and then we introduced the preset validation rules and used them to fully validate
    our form.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何验证我们的表单。我们首先通过创建一个简单的`required`验证来定义和使用验证规则，然后介绍了预设的验证规则，并使用它们来完全验证我们的表单。
- en: Your turn
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你的回合
- en: Continue to work on the `handleSubmit` method to send a `fetch` request (to
    a fake endpoint) with the form input.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 继续工作在`handleSubmit`方法上，以发送一个`fetch`请求（到一个假端点）并带上表单输入。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to handle user interaction by introducing two-way
    binding using `v-model` and form validation and handling using VeeValidate. During
    the chapter, we redefined what makes a semantically correct form, learned how
    to use the `v-model` syntax to define two-way binding, and then moved into the
    form territory by introducing VeeValidate and saw how it can be used to define,
    handle, and validate our forms.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过引入使用`v-model`的双向绑定和VeeValidate进行表单验证及处理来学习如何处理用户交互。在章节中，我们重新定义了语义正确表单的构成要素，学习了如何使用`v-model`语法来定义双向绑定，然后通过引入VeeValidate进入表单领域，并看到了它如何被用来定义、处理和验证我们的表单。
- en: In the next chapter, we will take a step back from coding and learn how to investigate
    and solve issues by introducing debugging techniques and using the exquisite Vue
    debugger browser extension.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从编码中退一步，通过介绍调试技术和使用精美的 Vue 调试器浏览器扩展来学习如何调查和解决问题。
- en: 'Part 4: Conclusion and Further Resources'
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：结论和进一步资源
- en: In this final part of the book, we are going to explore reading materials, resources,
    and topics that will take your knowledge of the Vue.js framework further. In this
    part, we are also going to learn how to debug our application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一部分，我们将探索阅读材料、资源和主题，这些将使你对 Vue.js 框架的知识更进一步。在这一部分，我们还将学习如何调试我们的应用程序。
- en: 'This part contains the following chapters:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 13*](B21130_13.xhtml#_idTextAnchor177)*, Unveiling Application Issues
    with the Vue Devtools*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B21130_13.xhtml#_idTextAnchor177)*，使用 Vue Devtools 揭示应用问题*'
- en: '[*Chapter 14*](B21130_14.xhtml#_idTextAnchor187)*, Advanced Resources for Future
    Reading*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B21130_14.xhtml#_idTextAnchor187)*，未来阅读的高级资源*'
