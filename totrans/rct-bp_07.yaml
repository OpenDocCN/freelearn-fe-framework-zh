- en: Chapter 7. Reactagram
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll apply the skills we've developed in the previous chapters
    and assemble a social web app based around photos. The app will be usable on desktop
    browsers as well as native phones and tablets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We'll explore an alternative to the Flux architecture in this chapter by connecting
    to a real-time database solution called **Firebase**. We'll create a higher order
    function that we'll implement as a singleton wrapped around our routes. This setup
    will enable us to provide our users with real-time streaming as well as the *like*
    functionality in our app while still adhering to the principle of *one-way data
    flow*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We'll also explore another cloud-based service called **Cloudinary**. It's a
    cloud service for uploading and hosting images. It's a pay service, but has a
    generous free tier that will suffice our needs. We'll make an upload service in
    our Express server that will handle image uploading, and we'll also explore image
    manipulation in canvas.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics that we''ll cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Using the web camera API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing photo input to an HTML5 canvas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying an image filter by manipulating canvas pixels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to Firebase and uploading images to the cloud
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing a stream of all the submitted photos in real time
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time comments and likes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by using the Webpack scaffold we developed in [Chapter 6](ch06.html
    "Chapter 6. Advanced React"), *Advanced React*. These are the dependencies we
    need to install from `npm`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We'll use the same setup as in the previous chapter, but we'll make some minor
    changes to `server.js`, add a few lines to `index.html`, and add some content
    to our CSS file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the tree structure in our original Webpack scaffold:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It's worth making sure that your structure is identical to this one.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to make a few modifications to our `server.js` file. We're going
    to set up an upload service that we will access from our app, so it needs support
    for Cross-Origin Resource Sharing (CORS) and a POST route in addition to our normal
    GET routes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `server.js` and replace the content with this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our app needs the `body-parser` package in order to access the request data
    in our POST route. We''re going to be sending images to our route, so we also
    need to make sure that the data limit is higher than the default value. Refer
    to the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This `POST` call will handle image uploads in our app. It will send the image
    to Cloudinary and store it for later retrieval in our image stream. You will have
    to create an account at [http://cloudinary.com/](http://cloudinary.com/) and replace
    the API credentials we just saw with the real credentials in your user administration
    section. The following is the major change we''re making:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This makes sure that any request to any file that''s not part of the static
    `asset` folder will be routed to `index.html`. This is important because it will
    allow us to access dynamic routes using the history API instead of using hashed
    routes, let''s take a look at the following code snippet:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了对任何不属于静态 `asset` 文件夹的文件的请求都将路由到 `index.html`。这很重要，因为它将允许我们使用历史 API 而不是使用哈希路由来访问动态路由，让我们看一下以下代码片段：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, open `assets/index.html` and replace the contents with this code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `assets/index.html` 并将内容替换为以下代码：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We're going to rely on Bootstrap for our grid layout, so we need to add the
    Bootstrap CSS files. We're also going to add the free Bitter font family as our
    main font for the app.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依赖于 Bootstrap 来实现网格布局，所以我们需要添加 Bootstrap CSS 文件。我们还将添加免费的 Bitter 字体家族作为应用的主要字体。
- en: The last thing we'll change is `app.css`. We'll add a set of styles that'll
    make sure the app we're building is functional on the Web as well as on tablets
    and smartphones.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要更改的最后一件事是 `app.css`。我们将添加一组样式，确保我们构建的应用在 Web、平板电脑和智能手机上都能正常工作。
- en: 'Open `app.css` and replace the content with this styling:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `app.css` 并将内容替换为以下样式：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This applies the `Bitter` font as the main font for our app and adds a top
    margin for our navigation header:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `Bitter` 字体设置为应用的主要字体，并为导航标题添加顶部边距：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `hidden` class will be applied to all the elements that should stay hidden
    and out of sight. Now check out the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`hidden` 类将被应用于所有应该保持隐藏且不可见的元素。现在查看以下内容：'
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is our only `media` query. It will make sure the canvas stays in a centered
    and fixed position on small smartphones. The height and width of `imageCanvas`
    will be overwritten when the user uploads images, so these values are only defaults:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们唯一的 `media` 查询。它将确保画布在小智能手机上保持居中和固定位置。当用户上传图片时，`imageCanvas` 的高度和宽度将被覆盖，因此这些值仅是默认值：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the code to set the left and right menu buttons in our header.
    They''ll be our navigation elements:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将左侧和右侧菜单按钮设置到我们标题中的代码。它们将成为我们的导航元素：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Check out the following lines of code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码行：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is about the **Filter** buttons. They will be displayed after the images
    have been captured but before they are sent to the app, let''s take a look at
    the following code snippet:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这关于 **过滤器** 按钮。它们将在捕获图片后、发送到应用之前显示，让我们看一下以下代码片段：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''re going to reuse the `spinner` from the earlier chapters. This will be
    displayed while the user is uploading images:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用前面章节中的 `spinner`。这将在用户上传图片时显示：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The basic setup of our app is now complete, and you can run it by issuing this
    command in your terminal:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用基本设置现在已经完成，你可以通过在终端中运行以下命令来运行它：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should see Webpack compile your app, and when ready, log this information
    in your terminal window (with a different hash and millisecond count of course):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到 Webpack 编译你的应用，当准备就绪时，在终端窗口中记录此信息（当然，带有不同的哈希值和毫秒计数）：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You'll also need to register accounts at Firebase and Cloudinary. Both services
    are free for development use. You can register an account with Firebase by visiting
    [https://www.firebase.com/](https://www.firebase.com/) and registering a database
    name to use when developing this app.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在 Firebase 和 Cloudinary 上注册账户。这两个服务都适用于开发使用。你可以通过访问 [https://www.firebase.com/](https://www.firebase.com/)
    并注册一个用于开发此应用的数据库名称来在 Firebase 上注册一个账户。
- en: 'The following screenshot shows how the app will look on an iPhone once we''re
    done writing the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了完成代码后应用在 iPhone 上的外观：
- en: '![Getting started](img/B04943_07_05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![入门](img/B04943_07_05.jpg)'
- en: Setting up the routes
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置路由
- en: Let's start this app by setting up the router configuration in the root of our
    app.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置应用根目录的路由配置开始这个应用。
- en: 'Open `index.jsx` and replace the contents with this code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `index.jsx` 并将内容替换为以下代码：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You'll notice that we reference two files that we haven't created yet, so let's
    go ahead and add them to our app.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们引用了两个我们尚未创建的文件，所以让我们继续将它们添加到我们的应用中。
- en: 'Create `config.js` in the root of the `source` folder and then add this code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `source` 文件夹的根目录下创建 `config.js` 文件，然后添加以下代码：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Replace `YOURAPP` with the name of your registered Firebase app, let''s take
    a look at the following code snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `YOURAPP` 替换为你注册的 Firebase 应用的名称，让我们看一下以下代码片段：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, create `routes.jsx` and add this code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建 `routes.jsx` 并添加以下代码：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we''re importing a number of components that we haven''t created yet.
    We''ll proceed by creating the components one by one, starting with `FBConnect`.
    This component is special because it''s a higher order component that will make
    sure that the components it wraps will be provided with a correct state. It works
    much in the same way as Redux, which we explored in [Chapter 6](ch06.html "Chapter 6. Advanced
    React"), *Advanced React*. Now add this code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在导入一些尚未创建的组件。我们将逐个创建这些组件，从`FBConnect`开始。这个组件很特殊，因为它是一个高阶组件，它将确保被它包裹的组件能够获得正确的状态。它的工作方式与我们在[第6章](ch06.html
    "第6章。高级React")中探讨的Redux非常相似，即*高级React*。现在添加以下代码：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After you've added this code, Webpack will throw a number of errors and the
    app will show a red error screen in the browser. We'll need to add all of the
    components we'll use before the app is usable again, and as you add them, you'll
    see that the error log will gradually diminish until the app is ready to be displayed
    properly again.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加此代码后，Webpack将抛出许多错误，并在浏览器中显示一个红色的错误屏幕。我们需要在应用再次可用之前添加所有我们将使用的组件，并且随着它们的添加，您将看到错误日志逐渐减少，直到应用可以正确显示为止。
- en: Creating a higher order function
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个高阶函数
- en: A higher order function is a function that takes one or more functions as arguments
    and returns a function as its result. All other functions are first-order functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是一个接受一个或多个函数作为参数并返回一个函数作为结果的函数。所有其他函数都是一阶函数。
- en: Using higher order functions is a brilliant way to extend your composition-making
    skills and an easy way to make complex apps easier. It complements the use of
    mixins, which is another way of providing inheritance in your components.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高阶函数是扩展你的组合技能的绝佳方式，也是使复杂应用更容易的简单方法。它与mixins的使用相辅相成，mixins是另一种在组件中提供继承的方式。
- en: The function we'll create is a higher order component with mixins. It will connect
    to Firebase by using the configuration we provide in `config.js` and make sure
    the stateful data we rely on is kept in sync in real time. That's a tall order,
    but by using Firebase, we'll unload much of the heavy lifting needed to provide
    this functionality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的是一个带有mixins的高阶组件。它将通过我们在`config.js`中提供的配置连接到Firebase，并确保我们依赖的有状态数据能够实时同步。这是一个很高的要求，但通过使用Firebase，我们将卸载提供此功能所需的大部分繁重工作。
- en: As you've seen earlier, we'll use this function to wrap our routed components
    and provide them with a state in the form of props.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，我们将使用此函数来包裹我们的路由组件，并为他们提供以props形式的状态。
- en: 'Create `fbconnect.jsx` in the root of your `source` folder and add this code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`source`文件夹根目录下创建`fbconnect.jsx`文件，并添加以下代码：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will fetch the contents of your image stream and store them in `this.state.imageStream`.
    The state will be available to all wrapped components in `this.props.imageStream`.
    We''ll be setting it so that it''s ordered by the timestamp value. Refer to the
    following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取你的图像流内容并将其存储在`this.state.imageStream`中。状态将可用于所有包裹组件的`this.props.imageStream`。我们将设置它，使其按时间戳值排序。请参考以下代码：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we return the component passed to this function along with the state
    from Firebase and a set of stateful functions in `FBFunc`, such as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们返回传递给此函数的组件以及从Firebase获取的状态和`FBFunc`中的一组有状态函数，如下所示：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Sorting with Firebase**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Firebase排序**'
- en: Firebase will always return data in ascending order, which means that newer
    pictures will be inserted at the bottom. If you want to sort by descending order,
    replace the `bindAsArray` function with a custom loop and then reverse the array
    before you store it with `setState()`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase将始终以升序返回数据，这意味着新图片将被插入到底部。如果你想按降序排序，请将`bindAsArray`函数替换为自定义循环，然后在将数组存储到`setState()`之前将其反转。
- en: 'You will also need to create a file that will hold the functions you''ll use
    to add content to the image stream. Create a file called `fbfunc.js` in the root
    of your project and enter this code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要创建一个文件来保存你将用于向图像流添加内容的函数。在你的项目根目录下创建一个名为`fbfunc.js`的文件，并输入以下代码：
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This function will store new images with an image URL to Cloudinary, the username,
    a timestamp, and zero likes. The following is our `like` functionality:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将使用图像URL、用户名、时间戳和零个赞数将新图像存储到Cloudinary。以下是我们`like`功能：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, every press on like will add a `+1` like(s) to the image it''s
    attached to. You could extend the functionality to prevent the current user from
    voting on their own images and also prevent them from voting more than once. Now
    refer to the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `comment` functionality will be visible in `item.jsx`, which is a page
    displaying a single photo. This function will store a new comment, along with
    the username of the submitter along with a timestamp. Now we move on to the two
    `helper` functions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These functions will let you either remove a single item or clear the entire
    database. The latter one is especially useful for debugging but very dangerous
    to keep around if you go live with the app.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Creating a random username
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to separate the different images coming in, you need to give the users
    a name. We'll do this in a very simple manner, so please refer to [Chapter 6](ch06.html
    "Chapter 6. Advanced React"), *Advanced React*, for details on how to implement
    a more secure login solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The way we're going to do this is by simply picking one word from a list of
    adjectives and another from a list of nouns and composing a username from both.
    We'll store the names in `localStorage` and generate a new one if we are unable
    to find an existing one.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Local storage**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: All of the major browsers now support `localStorage`, but if you're planning
    on supporting older browsers, especially Internet Explorer, it might be wise to
    look into polyfills. A good discussion on polyfilling `localStorage` can be found
    at [https://gist.github.com/juliocesar/926500](https://gist.github.com/juliocesar/926500).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `username` function. Create a file called `username.js` and
    put it in the `tools` folder. Add this code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The number of adjectives and nouns has been cut for brevity, but go ahead and
    add more words to add a touch of variety to your usernames.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting usernames will be a variation of the following: *autumn-breeze*,
    *misty-dawn*, and *empty-smoke*.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to explore name and sentence generation in more depth, I urge you
    to take a look at [https://www.npmjs.com/package/rantjs](https://www.npmjs.com/package/rantjs).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need the file that actually implements this functionality and sets
    the desired username. This is `userinfo.js`, which is referenced in `fbconnect.js`.
    Add the file to your `root` folder and then add the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This file is a mixin and will extend `getInitialState` and `componentDidMount`
    in `fbconnect` with a username state variable, and it will create a username and
    store it in `localStorage` if none exist.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Creating a welcome screen
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create an app header and a welcome screen. We'll do this in two different
    files, `app.jsx` and `welcome.jsx`, which we'll place in the `components` folder.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `components/app.jsx` and then add this code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `goBack()` function will send you back to the correct page depending on
    your current location. If you''re viewing a single item, you''ll be taken back
    to the stream if you press **Go Back**. If you''re on the stream, you''ll be taken
    to the front page, let''s take a look at the following code snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`goBack()` 函数会根据您的当前位置将您带回到正确的页面。如果您正在查看单个项目，按下**返回**按钮后，您将被带回到流中。如果您正在流中，您将被带到首页，让我们看一下下面的代码片段：'
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'These two styles will prevent the links from being displayed when there''s
    no need for them to be visible. The **Back** button will only be visible when
    you''re not on the front page, and the the photo button will be hidden if you''re
    on the photo page. Refer to the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种样式将防止在不需要显示链接时显示链接。**返回**按钮仅在您不在首页时可见，如果您在照片页面上，照片按钮将被隐藏。请参考以下代码：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this section, we add a Bootstrap grid with a fixed navigation bar. This makes
    sure that the navigation bar is always present. The code block `{ this.props.children
    }` makes sure that any React.js components are rendered within the grid.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们添加了一个带有固定导航栏的 Bootstrap 网格。这确保了导航栏始终存在。代码块 `{ this.props.children }`
    确保任何 React.js 组件都在网格内渲染。
- en: 'Next, create `components/welcome.jsx` and add this code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建 `components/welcome.jsx` 并添加以下代码：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We'll use the built-in `push` functionality in `react-router` to transition
    our users to the desired location. The URL will be `http://localhost:8080/stream`
    or `http://localhost:8080/camera`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `react-router` 内置的 `push` 功能将用户过渡到所需的位置。URL 将是 `http://localhost:8080/stream`
    或 `http://localhost:8080/camera`。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the routes are non-hashed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些路由是非哈希的。
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的代码片段：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We bind the route argument to the `historyPush` function as a handy way to
    transition our users on click. The first argument is the context, but since we
    don''t need it, we assign it to `null`. The second is the route we want the user
    to be transitioned to. Let''s take a look at the following code snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将路由参数绑定到 `historyPush` 函数，作为方便用户点击进行过渡的一种方式。第一个参数是上下文，但由于我们不需要它，我们将其赋值为 `null`。第二个是我们希望用户过渡到的路由。让我们看一下以下代码片段：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is how the application will look in the browser after you''ve added the
    preceding code. Note that the links won''t work at this point because we haven''t
    made the components yet. We''ll get to them shortly:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了前面的代码后，应用程序在浏览器中的外观将是这样。请注意，此时链接将无法工作，因为我们还没有创建组件。我们很快就会做到这一点：
- en: '![Creating a welcome screen](img/B04943_07_01.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![创建欢迎屏幕](img/B04943_07_01.jpg)'
- en: Taking a picture
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拍照
- en: We'll be using the camera API to take pictures for our image app. Through this
    interface, it is possible to take pictures with a native camera device as well
    as select pictures to upload them through a web page.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相机 API 为我们的图像应用程序拍照。通过此接口，可以使用原生相机设备拍照，也可以选择图片通过网页上传。
- en: The API is set up by adding an input element with `type="file"` and an `accept`
    attribute to declare to our component that it accepts images.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个具有 `type="file"` 和 `accept` 属性的输入元素来设置 API，以通知我们的组件它接受图片。
- en: 'The ReactJS JSX looks like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS JSX 看起来像这样：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When a user activates the element, they are presented with an option to choose
    a file or take a picture with the built-in camera (if available). The user must
    accept the picture before it's sent to the `<input type="file">` element, and
    its `onchange` event is triggered.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户激活元素时，他们会看到一个选项，可以选择文件或使用内置相机（如果可用）拍照。在图片发送到 `<input type="file">` 元素并触发其
    `onchange` 事件之前，用户必须接受该图片。
- en: Once you have a reference to the picture, you can render it to an image element
    or a canvas element. We'll do the latter, as rendering to canvas opens up a lot
    of possibilities for manipulating an image.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了图片的引用，您就可以将其渲染到图像元素或画布元素中。我们将后者作为渲染到画布，因为它为图像处理打开了大量的可能性。
- en: 'Create a new file called `camera.jsx` and put it in the `components` folder.
    Add this code to it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `camera.jsx` 的新文件，并将其放入 `components` 文件夹中。将以下代码添加到其中：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Leave this commented out until we add the code for this function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加此函数的代码之前，先将其注释掉：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `ImageToCanvas` module contains a lot of code that was originally written
    for this chapter, but since it consists of a lot of camera- and canvas-specific
    code, it was a bit too niche to include. Take a look at the code in the GitHub
    repository if you want to delve more into the canvas code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageToCanvas`模块包含大量最初为这一章节编写的代码，但由于它包含大量针对相机和画布的特定代码，所以有点过于狭窄，不适合包含。如果你想深入了解画布代码，请查看GitHub仓库中的代码：'
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''ll use this state variable to switch between showing the input field or
    the captured image. When an image is captured, this state is set to `true`. Consider
    the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个状态变量在显示输入字段或捕获的图片之间切换。当捕获到图片时，这个状态被设置为`true`。考虑以下代码：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As illustrated in the code, we''ll hide the canvas until we''ve got some content
    to show. The spinner should only be visible while the user is uploading an image.
    Refer to the helper functions in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，我们将隐藏画布，直到我们有内容可以显示。旋转器应该在用户上传图片时才可见。参考以下代码中的辅助函数：
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'These functions will be useful when rendering the final image to the user.
    Now check this out:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在将最终图像渲染给用户时将非常有用。现在看看这个：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This function takes care of all the canvas-handling logic that we'll need to
    display an image with proper ratios. Our default is 4:3 (portrait pictures), and
    we'll scale the images down to approximately 400 pixels in height and 300 pixels
    in width. The reduced image size will result in quality degradation, but it will
    make image processing faster and reduce the file size, resulting in a faster upload
    speed and better user experience.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数负责处理所有必要的画布处理逻辑，以便以正确的比例显示图像。我们的默认比例是4:3（竖幅图片），并将图像的高度和宽度缩放到大约400像素和300像素。减小图像大小会导致质量下降，但会使图像处理更快，并减小文件大小，从而提高上传速度和改善用户体验。
- en: 'This does mean that square pictures or photos in landscape mode will appear
    squished. This function could thus be extended to look for horizontally placed
    square or rectangular photos so that they could be scaled properly, let''s take
    a look at the following code snippet:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实意味着方形图片或横幅模式的照片将显得挤压。因此，这个函数可以被扩展以查找水平放置的方形或矩形照片，以便它们可以正确缩放，让我们看一下以下代码片段：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Cameras on native devices will take pictures with different orientations. Unless
    we adjust this, we''ll end up with images rotated left, right, or upside down,
    let''s take a look at the following code snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 原生设备上的相机将以不同的方向拍照。除非我们调整它，否则我们最终会得到左转、右转或颠倒的图片，让我们看一下以下代码片段：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we can''t get the `exif` information, we''ll default the orientation to
    `1`, meaning no transformation is needed, let''s take a look at the following
    code snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法获取`exif`信息，我们将默认将方向设置为`1`，这意味着不需要转换，让我们看一下以下代码片段：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We''ll set up three different filters: `grayscale`, `threshold`, and `brightness`.
    We''ll go more into the filters when we add `filters.js`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置三个不同的过滤器：`grayscale`、`threshold`和`brightness`。当我们添加`filters.js`时，我们将更详细地介绍过滤器：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When the user saves an image, we''ll turn down the opacity of the entire page
    and display the loading spinner, as illustrated in the last part of the preceding
    code, let''s take a look at the following code snippet:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户保存图片时，我们将降低整个页面的不透明度，并显示加载旋转器，如前一段代码的最后部分所示，让我们看一下以下代码片段：
- en: '[PRE48]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When the image is uploaded to **Cloudinary**, we''ll store the result in Firebase
    using the `uploadImage` function from `fbfunc.js`. Consider the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当图片上传到**Cloudinary**后，我们将使用`fbfunc.js`中的`uploadImage`函数将结果存储在Firebase中。请考虑以下代码：
- en: '[PRE49]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, the `classNames` function provides an easy interface to toggle classes
    on our HTML nodes, let''s take a look at the following code snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`classNames`函数提供了一个简单的接口来切换我们HTML节点上的类，让我们看一下以下代码片段：
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You should now be able to click on the camera button and take a picture with
    your camera phone or select an image from your hard drive if you''re working on
    a desktop computer. The following screenshot shows an image from the desktop selected
    with the file browser using the camera button:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够点击相机按钮，使用你的相机手机拍照，或者如果你在台式电脑上工作，从你的硬盘上选择一张图片。以下截图显示了使用文件浏览器和相机按钮选择的桌面图片：
- en: '![Taking a picture](img/B04943_07_02.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![拍照](img/B04943_07_02.jpg)'
- en: The filters won't work yet, but we're going to add them now. Once we've done
    this, remove the comments from the `import` function in `camera.jsx`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Adding filters
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've set up a few filter buttons for manipulating the image after it's been
    captured from the image uploader, but we're yet to set up the actual filter functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: You apply filters to the images by reading the canvas pixels, modifying them,
    and then writing them back to the canvas.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by fetching the image pixels. This is how you do it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In `camera.jsx`, we''ll pass the results of `getImageData` as an argument to
    the `filter` function, like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that you have the pixels, you can loop through them and apply your modifications.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the complete grayscale filter. Add a file called `filters.js`
    and put it in the `tools` folder. Add this code to it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We fetch the values for `red`, `green`, and `blue` separately and then apply
    the RGB to the Luma conversion formula, which is a set of weights that will deemphasize
    color information and produce a grayscale image:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We then replace the original color value with the new, monochromatic color
    value, let''s take a look at the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This filter makes the pixels brighter by simply increasing the RGB values.
    It''s similar to setting the color values of a font in CSS to `#eeeeee (R: 238
    G: 238 B: 238)` from `#999 (R: 153 G: 153 B: 153)`. Now we move on to threshold:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As you can see, threshold is applied by comparing the grayscale value of a
    pixel with the threshold value. Once this is done, set the color to either black
    or white, let''s take a look at the following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is a very basic set of filters, and you can easily create more by tuning
    the values. You can also check out [https://github.com/kig/canvasfilters](https://github.com/kig/canvasfilters)
    for a good set of filters to add, including blur, sobel, blend, luminance, and
    invert.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a picture with brightness and threshold applied:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding filters](img/B04943_07_03.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: Adding the stream
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now time to add the `stream` functionality. It's very simple because the
    data stream is already available through `fbconnect.js`, so all we have to do
    is map through the stream data and render the HTML.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `stream.jsx` in your `components` folder and add this
    code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A user can click on like as many times as they want, and the counter will be
    updated every time. The like counter is transaction-based, so if two or more users
    click on the like button at the same time, the operation will be queued until
    all likes have been counted, let''s take a look at the following code snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `try…catch` block will prevent blank sections from appearing (or the app
    from throwing an error), in case a user has unwittingly uploaded a broken image
    (or due to some error, the image upload failed). If an error is caught, this will
    be logged to the console and the image will simply not be displayed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: One of the many benefits of using a service like Cloudinary is that you can
    request a different version of your image file and have it delivered without having
    to do any work on our end.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Cloudinary 这样的服务的好处之一是，您可以请求您图像文件的不同版本，并且无需在我们的端进行任何工作即可将其交付。
- en: Here, we request a cropped image with a height of 300, weighted at the center.
    This makes sure that the images we return on this page are uniform in height,
    though the width may vary by a few pixels.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们请求一个高度为 300、以中心为权重的裁剪图像。这确保了我们返回此页面的图像在高度上是一致的，尽管宽度可能变化几像素。
- en: 'Cloudinary has a wealth of options, and you could conceivably use it for filtering
    the images instead of doing it in JavaScript. You can make changes to the app
    such that whenever the user captures an image, you could send it to Cloudinary
    before further processing. All filters could then be applied by adding filters
    to the image URL provided by Cloudinary, let''s take a look at the following code
    snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Cloudinary 提供了丰富的选项，您实际上可以用它来过滤图像而不是在 JavaScript 中进行。您可以修改应用，以便每当用户捕获图像时，您可以在进一步处理之前将其发送到
    Cloudinary。所有过滤器都可以通过向 Cloudinary 提供的图像 URL 添加过滤器来应用，让我们看看以下代码片段：
- en: '[PRE60]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If images are added, or the like count is updated, the changes will immediately
    be visible in the stream. Try opening the app on a device and a browser window
    or two browser windows at the same time, and you'll notice that any changes made
    will be synchronized in real time.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加了图像，或者点赞数已更新，更改将立即在流中可见。尝试同时在一个设备上打开应用和一个浏览器窗口，或者两个浏览器窗口，您会注意到所做的任何更改都将实时同步。
- en: Creating an item page and adding comments
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目页面并添加评论
- en: If you click on any of the pictures in the stream, you'll be taken to the item
    page. We don't need to set up a new query for this because we already have everything
    we need to display it. We'll get the item key from the router and apply a filter
    to the image stream, and we'll end up with a single item.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击流中的任何图片，您将被带到项目页面。我们不需要为此设置新的查询，因为我们已经拥有了显示所需的所有内容。我们将从路由中获取项目键，并应用一个过滤器到图像流中，最终我们将得到一个单一的项目。
- en: 'In the following screenshot, notice that the comment section has been added
    and that two random users have added some comments:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图 中，请注意已添加评论部分，并且有两个随机用户添加了一些评论：
- en: '![Creating an item page and adding comments](img/B04943_07_04.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目页面并添加评论](img/B04943_07_04.jpg)'
- en: 'Create a new file called `item.jsx` in the `components` folder and add this
    code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `components` 文件夹中创建一个名为 `item.jsx` 的新文件，并添加以下代码：
- en: '[PRE61]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `renderStream()` function is almost identical to the one we created for
    `stream.jsx`, except that we''ve removed the link here and added a way to display
    and add comments. Refer to the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderStream()` 函数几乎与我们为 `stream.jsx` 创建的函数相同，除了我们在这里移除了链接并添加了显示和添加评论的方式。请参考以下代码：'
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: First we grab the comment identifiers by using `Object.keys()`, which returns
    an array of keys. Then, we map through this array to find and render each individual
    comment to HTML.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `Object.keys()` 获取评论标识符，它返回一个键的数组。然后，我们遍历这个数组以找到并渲染每个单独的评论到 HTML 中。
- en: 'We also take the timestamp and convert it to a human-readable date by using
    the international date formatter. Further, we used the en-US locale in this example,
    but you can easily swap it with any locale. Have a look at the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还获取时间戳并将其转换为可读日期，使用的是国际日期格式化器。此外，在这个例子中，我们使用了 en-US 区域设置，但您可以轻松地将其与任何区域设置交换。请查看以下代码：
- en: '[PRE63]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, we render an input field and a submit button with an `onclick` handler
    to the `addComment()` function in `fbfunc.js`. Finally, we return to the `render()`
    function:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `onclick` 处理器将输入字段和提交按钮渲染到 `fbfunc.js` 中的 `addComment()` 函数。最后，我们返回到
    `render()` 函数：
- en: '[PRE64]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As illustrated, we get the key from the router parameters and apply a filter
    to the image stream so that we're left with an array containing just the single
    item we want from the stream data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，我们从路由参数中获取键，并应用一个过滤器到图像流中，这样我们就只剩下一个包含我们想要从流数据中获取的单个项目的数组。
- en: We then apply a `map` function to the array, fetch the image, and call the `renderStream()`
    function.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对数组应用一个 `map` 函数，获取图像，并调用 `renderStream()` 函数。
- en: 'You need to add the `padding` file we imported at the top of `item.jsx`, so
    create a file called `pad.js` in the `tools` folder and add this code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要添加我们在 `item.jsx` 顶部导入的 `padding` 文件，因此请在 `tools` 文件夹中创建一个名为 `pad.js` 的文件并添加以下代码：
- en: '[PRE65]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: It will transform 1 to 01 and so on, but will not do anything with 10, 11, or
    12\. So it's safe to use whenever you want to add left padding to a string.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your social-photo-sharing app is now ready for action. It should now compile
    fully and work without problems on desktop browsers and native smartphones and
    tablets.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Working with images and canvas can be a bit tricky when it comes to native devices.
    The file size of a photo often becomes a problem because many smartphones have
    very little memory to work with, so you may often run into problems rendering
    canvas images.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the reasons we're working with downscaled images in this app.
    The other is of course to make it faster when transmitting photos to the cloud.
    Both of these problems are very real but can more or less be classified as corner
    cases, so I'm leaving this up to you, should you go ahead and develop the app
    further.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the app deployed on an iPad:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrapping up](img/B04943_07_06.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'This is the final file structure of the app:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It's a very concise file structure for an app that already is quite capable.
    You could argue that the `config` files and the Firebase files could be put in
    a folder of their own, and you wouldn't find me disagreeing.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the way you organize your files is often down to personal preference.
    Some may like having all JavaScript files in a single folder, while others prefer
    to sort them by functionality.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The finished project can be viewed online at [http://reactjsblueprints-chapter7.herokuapp.com](http://reactjsblueprints-chapter7.herokuapp.com).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the camera/filereader API using the
    HTML5 canvas and how to manipulate images by modifying the pixels. You connected
    to Firebase and Cloudinary, both popular cloud-based tools that help you as a
    developer to work on your apps rather than your infrastructure.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: You also experienced that by using a tool such as Firebase, you can completely
    avoid using Flux. It's not a common architecture, but it's worth knowing that
    it's at least possible to go down this route.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In the end, you made a real-time social photo app that you can easily extend
    further and mark with your brand.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at how you could develop isomorphic apps with
    ReactJS. An isomorphic app means an app that is pre-rendered on the server, so
    we'll look at techniques to serve up your ReactJS apps even to users who don't
    have JavaScript enabled in their respective browsers.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
