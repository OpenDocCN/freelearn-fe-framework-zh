<html><head></head><body>
<div id="_idContainer069">
<h1 class="chapter-number" id="_idParaDest-140"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-141"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.2.1">Demystifying Multicasting</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Multicasting</span></strong><span class="koboSpan" id="kobo.4.1"> refers to sharing the same Observable execution among multiple subscribers. </span><span class="koboSpan" id="kobo.4.2">This concept can be challenging to grasp initially, especially for those unfamiliar with reactive programming paradigms. </span><span class="koboSpan" id="kobo.4.3">However, it’s very useful and solves many problems in </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">In this chapter, I will demystify this concept, explaining when and where to use it, how RxJS subjects are involved, and </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">its advantages.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">So, in this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Explaining multicasting </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">versus unicasting</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Exploring </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">RxJS subjects</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Highlighting the advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">of multicasting</span></span></li>
</ul>
<h1 id="_idParaDest-142"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.16.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.17.1">This chapter assumes that you have a basic understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">of RxJS.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">All the source code in this chapter is used for demonstration purposes, so you don’t need access to this book’s </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">GitHub repository.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.21.1">Explaining multicasting versus unicasting</span></h1>
<p><span class="koboSpan" id="kobo.22.1">Before we get into explaining </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.23.1">multicasting versus unicasting, let’s start by </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.24.1">explaining another key concept, known as a producer, which we will be using a lot in </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">producer</span></strong><span class="koboSpan" id="kobo.28.1"> is the</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.29.1"> source that produces the Observable values – for example, DOM events, WebSockets, and HTTP requests are considered producers. </span><span class="koboSpan" id="kobo.29.2">It is any data source that’s used to </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">get values.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">Observables fall into </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">two types:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.33.1">Cold, or </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">unicast, Observables</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Hot, or </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">multicast, Observables</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.37.1">Let’s understand the difference </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">between them.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.39.1">Unicasting and cold Observables</span></h2>
<p><span class="koboSpan" id="kobo.40.1">A cold Observable</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.41.1"> in RxJS is like a personal storytelling</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.42.1"> session. </span><span class="koboSpan" id="kobo.42.2">Imagine you’re sharing a story with a friend. </span><span class="koboSpan" id="kobo.42.3">You narrate the story right there with them, and it’s unique to your interaction. </span><span class="koboSpan" id="kobo.42.4">Each time you share the story with a different friend, it’s like starting a new session with a </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">fresh narrative.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">In RxJS terms, this means that the Observable itself generates the data it emits. </span><span class="koboSpan" id="kobo.44.2">Each time someone subscribes to the Observable, they get a private storytelling session. </span><span class="koboSpan" id="kobo.44.3">The story (or data) isn’t shared between different listeners – it’s a one-on-one experience. </span><span class="koboSpan" id="kobo.44.4">This is why we call cold Observables “unicast” – each emitted value is observed by only </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">one subscriber:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.46.1"><img alt="Figure 9.1 – Unicast cold Observable" src="image/B21180_09_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.47.1">Figure 9.1 – Unicast cold Observable</span></p>
<p><span class="koboSpan" id="kobo.48.1">So, by default, Observables in RxJS are cold – they create and deliver data to each subscriber individually, just like your personalized </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">storytelling sessions.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Here’s an example of a </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">cold Observable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.52.1">
import { Observable} from 'rxjs';
const coldObservable$ = new Observable(observer =&gt; {
  observer.next(Math.random());
  observer.next(Math.random());
  observer.complete();
});
/** First subscriber */
coldObservable$.subscribe(data =&gt; {
  console.log(`The first Observer : ${data}`);
});
/** Second subscriber */
coldObservable$.subscribe(data =&gt; {
  console.log(`The second Observer : ${data}`);
});
//console output
The first Observer: 0.043246216289945405
The first Observer: 0.7836505017199451
The second Observer: 0.18013755537578624
The second Observer: 0.23196314531696882</span></pre> <p><span class="koboSpan" id="kobo.53.1">Let’s break </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.54.1">down</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.55.1"> what’s happening in </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">this code.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">Math.random()</span></strong><span class="koboSpan" id="kobo.59.1"> is our producer – it is called inside the Observable. </span><span class="koboSpan" id="kobo.59.2">So, data is produced by the </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">Observable itself.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">The first ubscriber will get two random values after the subscription, and the second subscriber will get two different values after the subscription. </span><span class="koboSpan" id="kobo.61.2">Every subscriber starts a new execution, leading to a new invocation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">Math.random()</span></strong><span class="koboSpan" id="kobo.63.1">, which results in </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">distinct values.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">Each subscriber gets its own unique set of items. </span><span class="koboSpan" id="kobo.65.2">It begins to emit items only after the observer subscribes to it. </span><span class="koboSpan" id="kobo.65.3">Since there are two different executions, every Observable will receive a different value. </span><span class="koboSpan" id="kobo.65.4">This means that data is unicast and not shared among </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">the subscribers.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">Briefly looking at a real-world example, when a user logs into an application, their personal profile or dashboard information is fetched and displayed. </span><span class="koboSpan" id="kobo.67.2">This data is unique to each user and </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.68.1">should </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.69.1">not be shared across multiple users. </span><span class="koboSpan" id="kobo.69.2">Using a cold Observable ensures that each user receives personalized data upon logging in, maintaining privacy and security. </span><span class="koboSpan" id="kobo.69.3">So, to summarize, for cold Observables, the </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">following applies:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.71.1"> The Observable itself generates the data </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">it emits</span></span></li>
<li><span class="koboSpan" id="kobo.73.1">It starts to emit data only after the observer subscribes </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">to it</span></span></li>
<li><span class="koboSpan" id="kobo.75.1">Each observer (or subscriber) gets its own unique set </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">of items</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.77.1">Now, let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">hot Observables.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.79.1">Multicasting and hot Observables</span></h2>
<p><span class="koboSpan" id="kobo.80.1">Multicasting</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.81.1"> in RxJS is like hosting a live</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.82.1"> radio show. </span><span class="koboSpan" id="kobo.82.2">Imagine you’re broadcasting a show from a studio, and listeners can tune in at any time to hear the same content. </span><span class="koboSpan" id="kobo.82.3">Once you start broadcasting, anyone who tunes in can hear the same music, interviews, </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">or discussions.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">In RxJS terms, a hot or multicast Observable is an Observable whose emitted values are shared among subscribers. </span><span class="koboSpan" id="kobo.84.2">There’s a single source of data, just like the radio station broadcasting content. </span><span class="koboSpan" id="kobo.84.3">When you subscribe to a multicasting Observable, you’re joining the “broadcast,” and you’ll receive the same data as anyone else who’s </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">tuned in:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.86.1"><img alt="Figure 9.2 – Multicast hot Observable" src="image/B21180_09_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.87.1">Figure 9.2 – Multicast hot Observable</span></p>
<p><span class="koboSpan" id="kobo.88.1">Unlike cold Observables, where each subscriber gets a private session, multicasting allows </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.89.1">multiple </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.90.1">subscribers to listen to the same stream of </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">data simultaneously.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">Here’s an example of a </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">hot Observable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
import { Observable, fromEvent } from 'rxjs';
// Hot Observable
const hotObservable$ = fromEvent(document, 'click');
hotObservable$.subscribe(({ x, y }: MouseEvent) =&gt; {
  console.log(`The first subscriber: [${x}, ${y}]`);
});
hotObservable$.subscribe(({ x, y }: MouseEvent)=&gt; {
  console.log(`The second subscriber: [${x}, ${y}]`);
});
//console output
The first subscriber: [108, 104]
The second subscriber: [108, 104]</span></pre> <p><span class="koboSpan" id="kobo.95.1">Let’s break down what’s happening in </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">this code.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">We created an Observable using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">fromEvent</span></strong><span class="koboSpan" id="kobo.99.1"> function of RxJS. </span><span class="koboSpan" id="kobo.99.2">This Observable will emit clicks happening on the DOM document when </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">subscribing to.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.101.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.102.1">For more details about </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">fromEvent</span></strong><span class="koboSpan" id="kobo.104.1">, please refer </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">to </span></span><a href="https://rxjs.dev/api/index/function/fromEvent"><span class="No-Break"><span class="koboSpan" id="kobo.106.1">https://rxjs.dev/api/index/function/fromEvent</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.107.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">In this case, the data is emitted outside the Observable and, as you may have guessed, both subscribers will get the same data. </span><span class="koboSpan" id="kobo.108.2">This means that the subscribers share the same instance of the DOM click event. </span><span class="koboSpan" id="kobo.108.3">So, the hot Observable shares data between multiple subscribers. </span><span class="koboSpan" id="kobo.108.4">We call this behavior multicasting. </span><span class="koboSpan" id="kobo.108.5">In other words, the Observable multicasts to </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">all subscribers.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">Looking at </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.111.1">another </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.112.1">real-world scenario, consider a chat application where you might have a global chat service that exposes a hot Observable representing the stream of incoming messages from all users in the chat room. </span><span class="koboSpan" id="kobo.112.2">Multiple components, such as message feeds and notifications, can subscribe to this hot Observable to display new messages in real-time without needing to create separate Observables for </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">each component.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">So, to summarize, for hot Observables, the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">following applies:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.116.1">Data is produced outside </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">the Observable</span></span></li>
<li><span class="koboSpan" id="kobo.118.1">It may begin emitting items as soon as it </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">is created</span></span></li>
<li><span class="koboSpan" id="kobo.120.1">The </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.121.1">emitted </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.122.1">items are shared between the </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">subscribers (multicasting)</span></span></li>
</ul>
<h2 id="_idParaDest-146"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.124.1">Transforming cold Observables into hot Observables</span></h2>
<p><span class="koboSpan" id="kobo.125.1">If we want to </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.126.1">transform the cold Observable </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.127.1">into a hot one, we have to move the producer outside the Observable – this way, our subscribers will receive the </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">same data.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">Let’s revisit our example with the cold Observable. </span><span class="koboSpan" id="kobo.129.2">Instead of generating values within the Observable, we’ll pre-calculate the value by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">Math.random()</span></strong><span class="koboSpan" id="kobo.131.1"> outside the Observable, </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.133.1">
const value = Math.random();
const coldObservable$ = new Observable(observer =&gt; {
  observer.next(value);
  observer.next(value);
  observer.complete();
});
/** first subscriber */
coldObservable$.subscribe(data =&gt; {
  console.log(`The first subscriber: ${data}`);
});
/** second subscriber */
coldObservable$.subscribe(data =&gt; {
  console.log(`The second subscriber: ${data}`);
});
//console output
The first subscriber: 0.6642828154026537
The first subscriber: 0.6642828154026537
The second subscriber: 0.6642828154026537
The second subscriber: 0.6642828154026537</span></pre> <p><span class="koboSpan" id="kobo.134.1">As you may have noticed, after executing this code, all subscribers receive the same </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">pre-calculated value.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">Now, before we wrap up this section, let’s just quickly summarize unicasting </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">and multicasting:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.138.1">You should use </span><em class="italic"><span class="koboSpan" id="kobo.139.1">unicasting</span></em><span class="koboSpan" id="kobo.140.1"> when you want each subscriber to own independent executions and separate data streams for </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">each subscriber.</span></span></li>
<li><span class="koboSpan" id="kobo.142.1">On the other hand, you should use </span><em class="italic"><span class="koboSpan" id="kobo.143.1">multicasting</span></em><span class="koboSpan" id="kobo.144.1"> when you want to make sure multiple</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.145.1"> subscribers </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.146.1">share the same execution and results, particularly in scenarios involving hot Observables, broadcasting, or </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">caching results.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.148.1">Multicasting also helps optimize and improve performance when executing data is expensive. </span><span class="koboSpan" id="kobo.148.2">As a quick final example, suppose that the Observable’s execution is issuing a network request. </span><span class="koboSpan" id="kobo.148.3">If we choose a cold Observable (or unicasting), then a network request will be raised for every subscriber. </span><span class="koboSpan" id="kobo.148.4">Instead, multicasting is a better fit for this particular scenario as it will share the execution of the network requests among subscribers and consequently avoid redundant </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">request calls.</span></span></p></li>
</ul>
<p><span class="koboSpan" id="kobo.150.1">Now that we understand multicasting and hot Observables, let’s explore the most </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.151.1">popular ways to multicast values to observers in RxJS, namely </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">RxJS subjects.</span></span></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.153.1">Exploring RxJS subjects</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.154.1">Subjects</span></strong><span class="koboSpan" id="kobo.155.1"> are special </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.156.1">types of Observables. </span><span class="koboSpan" id="kobo.156.2">While plain Observables are</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.157.1"> unicast, subjects are multicast, allowing values to be broadcast to </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">all subscribers.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">You can consider subjects as observers and Observables at the </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">same time:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.161.1">You can subscribe to subjects to get values emitted by the producer (that’s why they act </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">as Observables):</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.163.1"><img alt="Figure 9.3 – An RxJS subject" src="image/B21180_09_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.164.1">Figure 9.3 – An RxJS subject</span></p>
<ul>
<li><span class="koboSpan" id="kobo.165.1">You can send values, errors, and completes by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">next</span></strong><span class="koboSpan" id="kobo.167.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">error</span></strong><span class="koboSpan" id="kobo.169.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">complete</span></strong><span class="koboSpan" id="kobo.171.1"> methods that are available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">Observer</span></strong><span class="koboSpan" id="kobo.173.1"> interface (that’s why they act </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">as observers):</span></span><pre class="source-code">
<a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.175.1">const observer = {
  next: x =&gt; console.log('Observer got a next value: '
                         + x),
  error: err =&gt; console.error('Observer got an error:
                              '+err),
  complete: () =&gt; console.log('Observer got a
                              completion'),
};</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.176.1">In short, a subject maintains a list of subscribers and notifies them when a new value is emitted. </span><span class="koboSpan" id="kobo.176.2">But to go a bit </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.177.1">deeper, there are multiple types of subjects in RxJS. </span><span class="koboSpan" id="kobo.177.2">Let’s explore the most </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">used ones.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.179.1">A plain subject</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">plainSubject</span></strong><span class="koboSpan" id="kobo.181.1"> is the parent </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.182.1">type of all subjects. </span><span class="koboSpan" id="kobo.182.2">Let’s see a</span><a id="_idIndexMarker419"/> <span class="No-Break"><span class="koboSpan" id="kobo.183.1">quick example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
const plainSubject$ = new Subject();
plainSubject$.next(10);
plainSubject$.next(20);
plainSubject$.subscribe({
    next: (message) =&gt; console.log(message),
    error: (error) =&gt; console.log(error),
    complete: () =&gt; console.log('Stream Completed'),
  });
plainSubject$.subscribe({
    next: (message) =&gt; console.log(message),
    error: (error) =&gt; console.log(error),
    complete: () =&gt; console.log('Stream Completed'),
  });
plainSubject$.next(30);
//console output
30
30</span></pre> <p><span class="koboSpan" id="kobo.185.1">In the preceding code, we created </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">plainSubject$</span></strong><span class="koboSpan" id="kobo.187.1">, which emitted </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">10</span></strong><span class="koboSpan" id="kobo.189.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">20</span></strong><span class="koboSpan" id="kobo.191.1"> as values. </span><span class="koboSpan" id="kobo.191.2">Afterward, we created two subscribers that logged the incoming values, the errors, and the completion of the stream. </span><span class="koboSpan" id="kobo.191.3">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">plainSubject$</span></strong><span class="koboSpan" id="kobo.193.1"> emitted a value </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">30</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">After executing this code, notice that only </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">30</span></strong><span class="koboSpan" id="kobo.199.1"> is traced twice in the console. </span><span class="koboSpan" id="kobo.199.2">This means that the subscribers only received </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">30</span></strong><span class="koboSpan" id="kobo.201.1">. </span><span class="koboSpan" id="kobo.201.2">Why have they not received </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">10</span></strong><span class="koboSpan" id="kobo.203.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">20</span></strong><span class="koboSpan" id="kobo.205.1">? </span><span class="koboSpan" id="kobo.205.2">Because those values were emitted before the subscription to </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">plainSubject$</span></strong><span class="koboSpan" id="kobo.207.1"> and every emission that occurs before the subscription will get lost. </span><span class="koboSpan" id="kobo.207.2">This is how a regular subject </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">multicasts values.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">And that’s how plain subjects behave and </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">emit values.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">You can use subjects as a communication hub in your web application to share data between different Angular components, as we explored in </span><a href="B21180_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.212.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.213.1">, </span><em class="italic"><span class="koboSpan" id="kobo.214.1">Sharing Data between </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.215.1">Angular Components</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Moreover, subjects can be used to manage the authentication state in a web application. </span><span class="koboSpan" id="kobo.217.2">For instance, you can use a subject to emit a value whenever the user logs in or logs out. </span><span class="koboSpan" id="kobo.217.3">This emitted value can then be used to conditionally display certain components or trigger specific behaviors based on the user’s </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">authentication status.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">If you want to keep </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.220.1">a buffer of previous values emitted to subscribers</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.221.1"> coming late to the game, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">ReplaySubject</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.223.1">can help!</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.224.1">replaySubject</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">replaySubject</span></strong><span class="koboSpan" id="kobo.226.1"> is a </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.227.1">subject variant, similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">plainSubject</span></strong><span class="koboSpan" id="kobo.229.1">, but </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.230.1">with an in-memory feature: they remember and replay previous messages to new subscribers. </span><span class="koboSpan" id="kobo.230.2">Replay subjects have </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">a memory.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">Let’s explain how it works by exploring the </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
const replaySubject$ = new ReplaySubject();
replaySubject$.next(10);
replaySubject$.next(20);
replaySubject$.next(50);
replaySubject$.subscribe({
  next: (message) =&gt; console.log(message),
  error: (error) =&gt; console.log(error),
  complete: () =&gt; console.log('Stream Completed'),
});
replaySubject$.subscribe({
  next: (message) =&gt; console.log(message),
  error: (error) =&gt; console.log(error),
  complete: () =&gt; console.log('Stream Completed'),
});
replaySubject$.next(30);
//console output
10
20
50
10
20
50
30
30</span></pre> <p><span class="koboSpan" id="kobo.235.1">As you can see, all </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.236.1">the </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.237.1">values were replayed to the new subscribers. </span><span class="koboSpan" id="kobo.237.2">Now, to control the buffer size (the number of values you want the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">Replay</span></strong><span class="koboSpan" id="kobo.239.1"> subject to store), you can pass it as a parameter when creating </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.241.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.243.1">
const  replaySubject$ = new ReplaySubject(2);</span></pre> <p><span class="koboSpan" id="kobo.244.1">This will only replay the last two values. </span><span class="koboSpan" id="kobo.244.2">The console output will be </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.246.1">
20
50
20
50
30
30</span></pre> <p><span class="koboSpan" id="kobo.247.1">As a real-world use case, let’s consider a chat application where a user joins the chat room late. </span><span class="koboSpan" id="kobo.247.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.249.1">, they can still see previous messages that were sent before they joined. </span><span class="koboSpan" id="kobo.249.2">This is useful for providing a complete chat history to </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">new users.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">With that, let’s </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.252.1">move on to </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.253.1">the other variant of </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">Subject</span></strong><span class="koboSpan" id="kobo.255.1"> – </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">BehaviorSubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.258.1">BehaviorSubject</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.260.1"> is</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.261.1"> just </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.263.1"> with a buffer size equal to </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.264.1">one, so it can only replay only previous item. </span><span class="koboSpan" id="kobo.264.2">We used </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.266.1"> in </span><a href="B21180_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.267.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.268.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.269.1">Combining Streams</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.272.1"> requires an initial value and always retains the last value so that it can emit it to new subscribers. </span><span class="koboSpan" id="kobo.272.2">In other words, if you have any subscribers coming late to the game, they will get the previous value that was emitted by the stream. </span><span class="koboSpan" id="kobo.272.3">This will always give you value when </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">you subscribe.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.276.1">
const behaviourSubject$ = new BehaviorSubject(1);
behaviourSubject$.next(10);
behaviourSubject$.next(20);
behaviourSubject$.next(50);
behaviourSubject$.subscribe({
  next: (message) =&gt; console.log(message),
  error: (error) =&gt; console.log(error),
  complete: () =&gt; console.log('Stream Completed'),
});
behaviourSubject$.subscribe({
  next: (message) =&gt; console.log(message),
  error: (error) =&gt; console.log(error),
  complete: () =&gt; console.log('Stream Completed'),
});
behaviourSubject$.next(30);
//console output
50
50
30
30</span></pre> <p><span class="koboSpan" id="kobo.277.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">behaviourSubject$</span></strong><span class="koboSpan" id="kobo.279.1"> is created and has an initial value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">1</span></strong><span class="koboSpan" id="kobo.281.1">. </span><span class="koboSpan" id="kobo.281.2">Then,</span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1"> behaviourSubject</span></strong><span class="koboSpan" id="kobo.283.1"> emitted </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">10</span></strong><span class="koboSpan" id="kobo.285.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">20</span></strong><span class="koboSpan" id="kobo.287.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">50</span></strong><span class="koboSpan" id="kobo.289.1">, respectively. </span><span class="koboSpan" id="kobo.289.2">Right after we subscribed two times to </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">behaviourSubject$</span></strong><span class="koboSpan" id="kobo.291.1">, both subscribers will immediately receive the last value </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.292.1">emitted</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.293.1"> by </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">behaviourSubject$</span></strong><span class="koboSpan" id="kobo.295.1">, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">50</span></strong><span class="koboSpan" id="kobo.297.1"> – that’s why </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">50</span></strong><span class="koboSpan" id="kobo.299.1"> is traced two times in the console. </span><span class="koboSpan" id="kobo.299.2">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">behaviourSubject$</span></strong><span class="koboSpan" id="kobo.301.1"> emitted </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">30</span></strong><span class="koboSpan" id="kobo.303.1">; consequently, the subscribers will receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">30</span></strong><span class="koboSpan" id="kobo.305.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">trace it.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">If no values were emitted before the subscription, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">behaviourSubject$</span></strong><span class="koboSpan" id="kobo.309.1"> will emit the initial value, which </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.313.1">
const behaviourSubject$ = new BehaviorSubject(1);
behaviourSubject$.subscribe({
  next: (message) =&gt; console.log(message),
  error: (error) =&gt; console.log(error),
  complete: () =&gt; console.log('Stream Completed'),
});
behaviourSubject$.subscribe({
  next: (message) =&gt; console.log(message),
  error: (error) =&gt; console.log(error),
  complete: () =&gt; console.log('Stream Completed'),
});
behaviourSubject$.next(30);
//console output
1
1
30
30</span></pre> <p><span class="koboSpan" id="kobo.314.1">As another example, imagine that you’re building a weather app that displays the current temperature. </span><span class="koboSpan" id="kobo.314.2">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.316.1"> to represent the temperature data. </span><span class="koboSpan" id="kobo.316.2">Whenever the temperature changes, you update </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.318.1"> with the new value. </span><span class="koboSpan" id="kobo.318.2">Subscribers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.320.1"> will always receive the latest temperature, even if they start using the app after the temperature has changed </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">multiple times.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">To summarize, </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">PlainSubject</span></strong><span class="koboSpan" id="kobo.324.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.326.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.328.1"> are the most used </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.329.1">subjects</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.330.1"> in RxJS, which is why we discussed them here. </span><span class="koboSpan" id="kobo.330.2">However, there are other types of subjects, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.332.1">, which are used much less (though we will explore that one more in </span><a href="B21180_12.xhtml#_idTextAnchor180"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.333.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.334.1">, </span><em class="italic"><span class="koboSpan" id="kobo.335.1">Processing Real-Time Updates</span></em><span class="koboSpan" id="kobo.336.1">). </span><span class="koboSpan" id="kobo.336.2">For details about the other types, refer </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">to </span></span><a href="https://rxjs.dev/guide/subject"><span class="No-Break"><span class="koboSpan" id="kobo.338.1">https://rxjs.dev/guide/subject</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.339.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.340.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.341.1">There are also many useful RxJS operators for multicasting (or sharing values/executions) in RxJS 6, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">multicast</span></strong><span class="koboSpan" id="kobo.343.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">publish</span></strong><span class="koboSpan" id="kobo.345.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">share</span></strong><span class="koboSpan" id="kobo.347.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">shareReplay</span></strong><span class="koboSpan" id="kobo.349.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">publishReplay</span></strong><span class="koboSpan" id="kobo.351.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">publishLast</span></strong><span class="koboSpan" id="kobo.353.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">refcount</span></strong><span class="koboSpan" id="kobo.355.1">. </span><span class="koboSpan" id="kobo.355.2">For more details about these operators, you can check the official </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">docs: </span></span><a href="https://rxjs.dev/api/operators"><span class="No-Break"><span class="koboSpan" id="kobo.357.1">https://rxjs.dev/api/operators</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.358.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.359.1">In version 7, multicasting operators were consolidated to </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">share</span></strong><span class="koboSpan" id="kobo.361.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">connectable</span></strong><span class="koboSpan" id="kobo.363.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">connect</span></strong><span class="koboSpan" id="kobo.365.1">. </span><span class="koboSpan" id="kobo.365.2">The other multicasting APIs are now deprecated and will be deleted in RxJS 8. </span><span class="koboSpan" id="kobo.365.3">The only operator that wasn’t deprecated is </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">shareReplay</span></strong><span class="koboSpan" id="kobo.367.1"> because it is very popular. </span><span class="koboSpan" id="kobo.367.2">It is now a wrapper around the highly configurable </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">share</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1"> operator.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.370.1">Since we are using RxJS 7 in this book, I think it is useless to go through all the deprecated operators. </span><span class="koboSpan" id="kobo.370.2">Instead, we focus on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">share</span></strong><span class="koboSpan" id="kobo.372.1"> operator as it satisfies most cases. </span><span class="koboSpan" id="kobo.372.2">We will learn the behavior of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">share</span></strong><span class="koboSpan" id="kobo.374.1"> operator by considering a real-world use case in the next chapter, </span><a href="B21180_10.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.375.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.376.1">, </span><em class="italic"><span class="koboSpan" id="kobo.377.1">Boosting Performance with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.378.1">Reactive Caching</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.380.1">For details </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.381.1">about RxJS 7 multicasting operators, refer </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">to </span></span><a href="https://rxjs.dev/deprecations/multicasting"><span class="No-Break"><span class="koboSpan" id="kobo.383.1">https://rxjs.dev/deprecations/multicasting</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.384.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">Now that you have a</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.386.1"> good understanding of multicasting and the</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.387.1"> different ways of implementation provided by RxJS, let’s explore the main advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">of multicasting.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.389.1">Highlighting the advantages of multicasting</span></h1>
<p><span class="koboSpan" id="kobo.390.1">Multicasting in RxJS or having the ability to share the same Observable execution among multiple subscribers has many advantages. </span><span class="koboSpan" id="kobo.390.2">Here are some </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">key ones:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.392.1">Optimizing resources</span></em><span class="koboSpan" id="kobo.393.1">: Multicasting helps optimize resources by avoiding redundant treatments. </span><span class="koboSpan" id="kobo.393.2">When dealing with expensive operations such as raising HTTP networks or performing complex computations, multicasting helps you do the work once and share the results among </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">all subscribers.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.395.1">Consistent data and results</span></em><span class="koboSpan" id="kobo.396.1">: Multicasting ensures that all subscribers receive the same set of values emitted by the Observable. </span><span class="koboSpan" id="kobo.396.2">This can be crucial in scenarios where consistency in data is essential, and you want all subscribers to observe the same </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">data sequence.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.398.1">Broadcasting</span></em><span class="koboSpan" id="kobo.399.1">: Multicasting gives you the possibility to send, once and for all, the same set of values to multiple subscribers at the same time. </span><span class="koboSpan" id="kobo.399.2">This is what we call broadcast, and it is beneficial when you have a complex application with multiple components that need to react to the same set </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">of values.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.401.1">Late subscribers</span></em><span class="koboSpan" id="kobo.402.1">: Multicasting allows late subscribers to receive the same values as subscribers who joined earlier. </span><span class="koboSpan" id="kobo.402.2">This is achieved by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.404.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.406.1">, plus some multicast RxJS operators such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">shareReplay</span></strong><span class="koboSpan" id="kobo.408.1"> operator, something we will explain in </span><a href="B21180_10.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.409.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.410.1">, </span><em class="italic"><span class="koboSpan" id="kobo.411.1">Boosting Performance with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.412.1">Reactive Caching</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.414.1">When designing applications with RxJS, multicasting is a powerful mechanism that should be put on the table because it enhances performance, efficiency, consistency, and interaction between the different parts of your app. </span><span class="koboSpan" id="kobo.414.2">However, it’s essential to use multicasting carefully and be aware of potential pitfalls, depending on your specific use case. </span><span class="koboSpan" id="kobo.414.3">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">some examples:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.416.1">Data alteration</span></em><span class="koboSpan" id="kobo.417.1">: Multicasting inherently shares the same data stream across all subscribers. </span><span class="koboSpan" id="kobo.417.2">If a subscriber modifies the data within its subscription logic (for example, using operators such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">map</span></strong><span class="koboSpan" id="kobo.419.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">filter</span></strong><span class="koboSpan" id="kobo.421.1">), this modification can unintentionally affect what other subscribers receive. </span><span class="koboSpan" id="kobo.421.2">This can lead to unexpected behavior and </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">debugging challenges.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.423.1">For example, imagine a multicast Observable emitting a list of products. </span><span class="koboSpan" id="kobo.423.2">A component subscribes and filters the list to only show products with discounts. </span><span class="koboSpan" id="kobo.423.3">However, this filtering modifies the original data stream. </span><span class="koboSpan" id="kobo.423.4">If another component later subscribes, expecting the complete product list, it will only receive the discounted products due to the unintended modification in the first subscription. </span><span class="koboSpan" id="kobo.423.5">That’s why keeping the subject private and exposing only the read-only part of the data through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">asObservable()</span></strong><span class="koboSpan" id="kobo.425.1"> method is a common and effective practice. </span><span class="koboSpan" id="kobo.425.2">This ensures that external components or consumers cannot directly modify the internal state of the subject. </span><span class="koboSpan" id="kobo.425.3">Instead, they can only observe the emitted values without interfering with the </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">data stream.</span></span></p></li>
<li><em class="italic"><span class="koboSpan" id="kobo.427.1">Memory leaks</span></em><span class="koboSpan" id="kobo.428.1">: Unlike unicast Observables, which complete after a single subscriber unsubscribes, multicasting continues emitting data so long as at least one subscriber remains. </span><span class="koboSpan" id="kobo.428.2">This can lead to memory leaks if you’re not careful about managing subscriptions, especially when dealing with infinite or </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">long-lived Observables.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.430.1">For example, imagine a multicast Observable that emits real-time stock prices. </span><span class="koboSpan" id="kobo.430.2">If components subscribe to this Observable but don’t unsubscribe when they are no longer needed, the Observable will continue emitting, potentially causing memory leaks as references to the Observable and its internal </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">state accumulate.</span></span></p></li>
</ul>
<p><span class="koboSpan" id="kobo.432.1">We will explore other multicasting pitfalls and best practices in the </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">next chapters.</span></span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.434.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.435.1">In this chapter, I walked you through the most important concepts and vocabulary to understand multicasting. </span><span class="koboSpan" id="kobo.435.2">We started by explaining the role of a producer, after which we learned the difference between cold and hot Observables, leading us to the definition of multicasting and unicasting. </span><span class="koboSpan" id="kobo.435.3">Then, we explored RxJS subjects, the different types of subjects, and the use cases of each before introducing multicasting operators </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">in RxJS.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">In the next chapter, we’ll practice all of this in a real-world use case. </span><span class="koboSpan" id="kobo.437.2">We will learn how to put an efficient mechanism of caching in place in our Recipe app by using multicasting in RxJS and, more specifically, by combining multicasting operators </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">and subjects.</span></span></p>
</div>
</body></html>