<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Tooling and Development Experience</h1>
                </header>
            
            <article>
                
<p>You are already familiar with all the core concepts of Angular. You know how to develop a component-based user interface, taking advantage of all the building blocks that the framework provides—directives, components, dependency injections, pipes, forms, and the brand new router.</p>
<p>This chapter goes one step further, describing how to do the following:</p>
<ul>
<li>Using web workers for performance-sensitive applications</li>
<li>Building SEO-friendly applications with server-side rendering</li>
<li>Bootstrapping a project as quickly as possible</li>
<li>Enhancing our experience as developers</li>
<li>Understanding what is <strong>ahead-of-time</strong> (<strong>AOT</strong>) compilation and how to use it</li>
</ul>
<p>So, let's begin!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running an application in a web worker</h1>
                </header>
            
            <article>
                
<p>When talking about performance in the context of frontend web development, we can either mean network, computational, or rendering performance. In this section, we'll concentrate on rendering and computational performance, which are very tightly related.</p>
<p>First, let's draw parallels between a web application and a video file, and between a browser and a video player. The biggest difference between the web application running in the browser and the video file playing in the video player is that the web page needs to be generated dynamically, in contrast to the video which has been recorded, encoded, and distributed. However, in both cases, the user of the application sees a sequence of frames; the core difference is in how these frames are generated. In the world of video processing, when we play a video, we have it already recorded; it is the responsibility of the video decoder to extract the individual frames based on the used compression algorithm. In contrast to this, on the web, JavaScript, HTML, and CSS are in charge of producing frames that are rendered later by the rendering engine of the browser.</p>
<p>In the context of the browser, we can think of each frame as a snapshot of the web page at a given moment. The different frames are rendered fast, one after the other; so, in practice, the end user of the application should see them smoothly incorporated together, just like a video played in a video player.</p>
<p>On the web, we try to reach 60 <strong>frames per second</strong> (<strong>fps</strong>), which means that each frame has about 16 milliseconds to be computed and rendered on the screen. This duration includes the time required by the browser to make all the necessary calculations for the layout and the rendering of the page (the browser's internal computations), and the time that our JavaScript needs to execute.</p>
<p>In the end, we have less than 16 <span>milliseconds</span> (because of the browser's internal computations) for our JavaScript to finish its execution. If it doesn't fit in this duration, the frame rate will drop by half. Since JavaScript is a single-threaded language, all the calculations need to happen in the main UI thread, which can lead to a very poor user experience because of the frame drop.</p>
<p>HTML5 introduced an API called <strong>web workers</strong>, which allows the execution of client-side code into multiple threads. For the sake of simplicity, the standard doesn't allow shared memory between individual threads, but instead uses communication with message passing. The messages exchanged between web workers and the main UI thread must be strings, which often require the serialization and deserialization of JSON strings.</p>
<div class="packt_infobox">At the time of writing, TC39 is working on a specification for shared memory between independent computational units. For further information you can visit <a href="https://github.com/tc39/ecmascript_sharedmem">https://github.com/tc39/ecmascript_sharedmem</a>.</div>
<p>The lack of shared memory between the individual workers, and the workers and the main UI thread brings a couple of limitations, including the following:</p>
<ul>
<li>Disabled access to the DOM by the worker threads</li>
<li>Global variables cannot be shared among the individual computational units (that is, worker threads and main UI threads and vice versa)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Web workers and Angular</h1>
                </header>
            
            <article>
                
<p>On account of the platform agnostic design of Angular, the core team decided to take advantage of this API; during the summer of 2015, Google embedded web workers support into the framework. This feature allows most of the Angular applications to be run on a separate thread, making the main UI thread responsible only for rendering. This helps us achieve the goal of 60 fps much more easily than running the entire application in a single thread.</p>
<p>Web workers support is not enabled by default. When enabling it, we need to keep something in mind—in a web worker–ready application, the components will not be run in the main UI thread, which does not allow us to directly manipulate the DOM. In this case, we need to use APIs on a higher-level of abstraction, provided by Angular, for establishing data binding or manipulating the elements properties.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bootstrapping an application running in a web worker</h1>
                </header>
            
            <article>
                
<p>Let's make the to-do application that we developed in <a href="1b60c28e-5f34-493d-8371-c69968f09020.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Getting Started with Angular Components and Directives</em>, work in a web worker. You can find the example that we'll explore at <kbd>ch9/todo_webworkers/</kbd>.</p>
<div class="packt_infobox">Note that the web worker module is not finalized yet, so its API may change in future versions of Angular, or even be deprecated. The conceptual idea and the architecture are mature enough, so most likely there will not be any fundamental differences.</div>
<p>First of all, let's discuss the changes that we will need to make. Take a look at <kbd>ch5/inputs-outputs/app.ts</kbd>. Note that inside <kbd>app.ts</kbd>, we include the <kbd>platformBrowserDynamic</kbd> function from the <kbd>@angular/platform-browser-dynamic</kbd> module. This is the first thing we need to modify. The bootstrap process of an application running in a web worker is different.</p>
<p>Before refactoring our code, let's take a look at a diagram that illustrates the bootstrap process of a typical Angular application running in web workers:</p>
<div class="CDPAlignCenter CDPAlign"><img height="457" width="631" src="assets/4518011a-9a73-4dce-a726-e1f03ca94b19.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1</div>
<p>This diagram has two parts: <strong>UI</strong> and <strong>web worker</strong>. <strong>UI</strong> shows the actions performed during initialization in the main UI thread; the <strong>web worker</strong> part of the diagram shows how the application is bootstrapped in the background thread. Now, let's explain the bootstrap process step by step.</p>
<p>First, the user opens the <kbd>index.html</kbd> page, which triggers the download of the following two files:</p>
<ul>
<li>The UI bundle of Angular used for applications running in a web worker</li>
<li>The <kbd>system.js</kbd> bundle (we talked about the global object <kbd>System</kbd> in <a href="c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>TypeScript Crash Course</em>. We can think of the <kbd>system.js</kbd> bundle as a polyfill for the module loader.)</li>
</ul>
<p>Using <kbd>system.js</kbd>, we download the script used for the initialization of the part of the application running in the main UI thread (<kbd>bootstrap.js</kbd>). This script starts <kbd>loader.js</kbd> in a web worker. This is the first script that runs in a background thread. Once the worker is started, <kbd>loader.js</kbd> will download <kbd>system.js</kbd> and the bundle of Angular, which is meant to be run in the background thread. The first request will usually hit the cache because <kbd>system.js</kbd> is already requested by the main thread. Using the module loader, we download the script that is responsible for bootstrapping the background app, <kbd>background_bootstrap.js</kbd>, which will finally start the functionality of our application in a web worker.</p>
<p>From now on, the entire application that we built will be run in a web worker and will exchange messages with the main UI thread to respond to user events and render instructions.</p>
<p>Now that we are aware of the basic flow of events during initialization when using workers, let's refactor our to-do application to take advantage of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Migrating an application to web workers</h1>
                </header>
            
            <article>
                
<p>Let's show how we can make an application compatible with web workers. This way, we can reduce the frame drop in computationally intensive apps, since we'll free the main UI thread and let it be responsible only for rendering.</p>
<p>Inside <kbd>index.html</kbd>, we will need to add the following scripts:</p>
<pre>  &lt;!-- ch9/todo_webworkers/index.html --&gt; 
  ... 
  &lt;script src="/node_modules/systemjs/dist/system.src.js"&gt; 
  &lt;/script&gt; 
  &lt;script src="/node_modules/reflect-metadata/Reflect.js"&gt;&lt;/script&gt; 
  &lt;script src="/node_modules/zone.js/dist/zone.js"&gt; 
  &lt;/script&gt; 
  &lt;!- 
    Contains some basic SystemJS configuration in order to 
    allow us to load Angular 
  --&gt; 
  &lt;script src="./config.js"&gt;&lt;/script&gt; 
  &lt;script&gt; 
  System.import('./bootstrap.js') 
    .catch(function () { 
      console.log('Report this error to https://github.com/mgechev/switching-to-angular/issues', e); 
    }); 
  &lt;/script&gt; 
  ... </pre>
<p>In the preceding snippet, we've included references to <kbd>system.js</kbd>, <kbd>zone.js</kbd>, and <kbd>reflect-metadata</kbd>. <kbd>zone.js</kbd> is a polyfill for the zones that Angular exclusively uses, which we mentioned earlier in the book. Also, <kbd>reflect-metadata</kbd> contains another polyfill for the Metadata Reflection API, which at the moment of writing is not yet available in browsers.</p>
<p>For the next step, we will explicitly import the <kbd>bootstrap.js</kbd> file, which contains the logic used to start the <kbd>loader.js</kbd> script in a web worker.</p>
<p>Let's explore <kbd>bootstrap.ts</kbd>, which is the original TypeScript version of the transpiled <kbd>bootstrap.js</kbd> file:</p>
<pre>// ch9/todo_webworkers/bootstrap.ts 

// main entry point
import {bootstrapWorkerUi} from '@angular/platform-webworker';

bootstrapWorkerUi('loader.js');</pre>
<p>Here, we pass <kbd>'loader.js'</kbd> to the invocation of <kbd>bootstrapWorkerUi</kbd>. This way, Angular knows that <kbd>loader.js</kbd> will run in a background thread. The script is located in the application's root.</p>
<p>Now, we can move to the right-hand side of the diagram shown in the <em>Bootstrapping an application running in a web worker</em> section. The logic in <kbd>loader.ts</kbd> (the original TypeScript version of <kbd>loader.js</kbd>) is quite simple:</p>
<pre>// ch9/todo_webworkers/loader.ts
 
importScripts('/node_modules/systemjs/dist/system.src.js', 
      '/node_modules/reflect-metadata/Reflect.js', 
      '/node_modules/zone.js/dist/zone.js', 
      './config.js'); 
 
System.import('./background_app.js') 
.then(() =&gt; console.log('The application has started successfully'), 
  error =&gt; console.error('error loading background', error)); </pre>
<p>As the first step, we import <kbd>SystemJS</kbd>, the <kbd>ReflectMetadata</kbd> polyfils, <kbd>zone.js</kbd>, and the configuration for <kbd>SystemJS</kbd>. As this script is already run in a web worker, we have the <kbd>importScripts</kbd> function, which allows us to load the listed files synchronously. As the last step, with <kbd>System</kbd>, we import the script that contains our application.</p>
<p>Now, let's explore how we bootstrap the application inside of the web worker:</p>
<pre>// ch9/todo_webworkers/background_app.ts

import {platformWorkerAppDynamic} from '@angular/platform-webworker-dynamic';

// Logic for the application... 

platformWorkerAppDynamic().bootstrapModule(AppModule)
  .catch(err =&gt; console.error(err));</pre>
<p>The process is quite similar to what we do when bootstrapping an Angular application running in the main UI thread. We import the <kbd>platformWorkerAppDynamic</kbd> function and invoke the <kbd>bootstrapModule</kbd> method of the result of its invocation. To <kbd>bootstrapModule</kbd>, we pass the root module of the application as an argument.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making an application compatible with web workers</h1>
                </header>
            
            <article>
                
<p>As we said, the code that runs in the context of web workers does not have access to the DOM. Let's see what changes we need to make in order to address this limitation.</p>
<p>This is the original implementation of the <kbd>InputBox</kbd> component:</p>
<pre>// ch5/inputs-outputs/app.ts
 
@Component({ 
  selector: 'input-box', 
  template: ` 
    &lt;input #todoInput [placeholder]="inputPlaceholder"&gt; 
    &lt;button (click)="emitText(todoInput.value); todoInput.value = '';"&gt; 
      {{buttonLabel}} 
    &lt;/button&gt; 
  ` 
}) 
class InputBox { 
  @Input() inputPlaceholder: string; 
  @Input() buttonLabel: string; 
  @Output() inputText = new EventEmitter&lt;string&gt;();
 
  emitText(text: string) { 
    this.inputText.emit(text); 
  } 
} </pre>
<p>Notice that, inside the template, we reference the input element with the <kbd>todoInput</kbd> <span>identifier </span><span>and use the reference within the expression set as the handler of the click event. This code will not be able to run in a web worker, since we directly access a DOM element inside the template. In order to take care of this, we will need to refactor the snippet, so it uses Angular data binding instead of directly touching any element. We can either use Angular inputs when a single direction binding makes sense or</span> <kbd>NgModel</kbd> <span>to achieve two-way data binding, which is a bit more computationally intensive.</span></p>
<p>Let's use <kbd>NgModel</kbd>:</p>
<pre>// ch9/todo_webworkers/background_app.ts 
import {NgModel} from '@angular/common'; 

@Component({ 
  selector: 'input-box', 
  template: ` 
    &lt;input [placeholder]="inputPlaceholder" [(ngModel)]="input"&gt; 
    &lt;button (click)="emitText()"&gt; 
      {{buttonLabel}} 
    &lt;/button&gt; 
  ` 
}) 
class InputBox { 
  @Input() inputPlaceholder: string; 
  @Input() buttonLabel: string; 
  @Output() inputText = new EventEmitter&lt;string&gt;(); 
  input: string;
 
  emitText() { 
    this.inputText.emit(this.input); 
    this.input = ''; 
  } 
} </pre>
<p>In this version of the <kbd>InputBox</kbd> component, we create a two-way data binding between the input element and the <kbd>input</kbd> property of the <kbd>InputBox</kbd> component. Once the user clicks on the button, the <kbd>emitText</kbd> method will be invoked, which will trigger a new event emitted by <kbd>inputText</kbd>, which is an instance of <kbd>EventEmitter</kbd>. In order to reset the value of the input element, we take advantage of the two-way data binding mechanism of Angular and set the value of the <kbd>input</kbd> property to the empty string; this will automatically update the UI.</p>
<div class="packt_infobox"><span>Moving the entire logic from the templates of the components to their controllers brings a lot of benefits, such as improved testability, maintainability, code reuse, and clarity.</span></div>
<p>The preceding code is compatible with the web worker environment, as the <kbd>NgModel</kbd> directive is based on an abstraction that does not manipulate the DOM directly. Instead, it delegates this responsibility to another abstraction called <kbd>Renderer</kbd>, whose web worker implementation exchanges messages asynchronously with the main UI thread.</p>
<p>To recap, we can say that, while running applications in the context of a web worker, we need to keep the following two things in mind:</p>
<ul>
<li>We need to use a different bootstrap process</li>
<li>We should not access the DOM directly</li>
</ul>
<p>Typical scenarios that violate the second point are the following:</p>
<ul>
<li>Changing the DOM of the page by selecting an element and manipulating it directly with the browser's native APIs or with a third-party library</li>
<li>Accessing native elements injected using <kbd>ElementRef</kbd></li>
<li>Creating a reference to an element in the template and passing it as an argument to methods</li>
<li>Directly manipulating an element referenced within the template</li>
</ul>
<p>In all these scenarios, we would need to use the higher-level APIs provided by Angular. If we build our applications according to this practice, we will benefit not only from being able to run them in web workers, but also from increasing the code reuse in case we want to use them across different platforms.</p>
<p>Keeping this in mind and following best practices will also allow us to take advantage of server-side rendering.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initial load of a single-page application</h1>
                </header>
            
            <article>
                
<p>In this section, we will explore what the concept of server-side rendering is, why we need it in our applications, and how we can use it with Angular.</p>
<p>For our purpose, we'll explain the typical flow of events when a user opens a single-page application implemented in Angular. First, we'll trace the events with the server-side rendering disabled, and after that, we'll see how we can benefit from this feature by enabling it. Our example will be illustrated in the context of HTTP 1.1:</p>
<div class="CDPAlignCenter CDPAlign"><img height="313" width="803" src="assets/e4db1d7c-244f-4e85-af97-561018757759.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2</div>
<p><em>Figure 2</em> shows the first request by the browser and the<span> </span><span>response of the</span><span> corresponding server when loading a typical SPA. The result that the client will see initially is the content of the HTML page without any rendered components.</span></p>
<p>Let's suppose that we deploy the to-do application we built in <a href="7bc2aa38-2853-468a-8e03-c25387eb03aa.xhtml"/><a href="1b60c28e-5f34-493d-8371-c69968f09020.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Getting Started with Angular Components and Directives</em>, to a web server that has the <kbd>example.com</kbd> domain associated with it.</p>
<p>Once the user navigates to <kbd>https://example.com/</kbd>, the browser will initiate a new HTTP GET request, fetching the root resource (<kbd>/</kbd>). When the server receives the request, it will respond with an HTML file that, in our case, will look something like this:</p>
<pre>&lt;!DOCTYPE html&gt; 
&lt;html lang="en"&gt; 
&lt;head&gt; 
  &lt;title&gt;...&lt;/title&gt; 
  &lt;link rel="stylesheet" href="bootstrap.min.css"&gt; 
&lt;/head&gt; 
&lt;body&gt; 
  &lt;app&gt;Loading...&lt;/app&gt; 
  &lt;script src="es6-shim.min.js"&gt;&lt;/script&gt; 
  &lt;script src="Reflect.js"&gt;&lt;/script&gt; 
  &lt;script src="system.src.js"&gt;&lt;/script&gt; 
  &lt;script src="angular-polyfills.js"&gt;&lt;/script&gt; 
  &lt;script src="Rx.min.js"&gt;&lt;/script&gt; 
  &lt;script src="angular.js"&gt;&lt;/script&gt; 
  &lt;script&gt;...&lt;/script&gt; 
&lt;/body&gt; 
&lt;/html&gt; </pre>
<p>The browser will receive this content as the body of the response. When the markup is rendered onto the screen, all that the user will see is the <span class="packt_screen">Loading...</span> label.</p>
<p>In the next step, the browser will find all the references in the HTML file's external resources, such as styles and scripts, and start to download them. In our case, some of them are <kbd>bootstrap.css</kbd>, <kbd>es6-shim.min.js</kbd>, <kbd>Reflect.js</kbd>, <kbd>system.src.js</kbd>, and <kbd>angular-polyfills.js</kbd>.</p>
<p>Once all the referenced resources are available, there still won't be any significant visual progress for the user (except if the styles from the downloaded CSS file are applied to the page). This won't change until the JavaScript virtual machine processes all the referenced scripts related to the application's implementation. At this point, Angular will know which component needs to be rendered based on the current URL and configuration.</p>
<p>If the component associated with the page is defined in a separate file outside of our main application bundle, the framework will need to download it together with its entire dependency graph.</p>
<p>If we're using JIT compilation, in case the template and the styles of the component are externalized, Angular will need to download them as well before it is able to render the requested page. Right after this, the framework will be able to compile the template associated with the target component and render the page.</p>
<p>In this scenario, these are the two main pitfalls:</p>
<ul>
<li>In case of large applications and/or slow internet connection, the user experience will be poor</li>
<li>Search engines are not that good at indexing dynamic content generated by JavaScript; this means that the SEO of our SPA will suffer</li>
</ul>
<p>In the past, we solved the SEO issue in the applications built with AngularJS with different workarounds, such as using a headless browser for rendering the requested page, caching it onto the disk, and later providing it to search engines. However, there's a more elegant solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initial load of a single-page application with server-side rendering</h1>
                </header>
            
            <article>
                
<p>A couple of years ago, libraries such as <em>Rendr</em>, <em>Derby</em>, and <em>Meteor</em> introduced the concept of <strong>isomorphic</strong> JavaScript applications, which were later renamed <strong>universal</strong>. In essence, universal applications could be run both on the client and on the server. Such portability is only possible in the case of low coupling between the SPA and the browser's APIs. Great benefits of this paradigm are code reuse and being able to render the application on the server before sending it to the client.</p>
<p>Universal applications are not framework specific; we can take advantage of them in any framework that can be run outside of the environment of the browser. Conceptually, the practice of server-side rendering is very similar across platforms and libraries; only its implementation details may differ. For instance, the Angular Universal module, which implements server-side rendering, supports node.js as well as ASP.NET.</p>
<div class="CDPAlignCenter CDPAlign"><img height="317" width="812" src="assets/21b7cd39-9982-4f5e-bcb2-1db45acff684.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 3</div>
<p><em>Figure 3</em> shows the response by the server to the initial browser GET request. This time, in contrast to the typical scenario of loading a SPA, the browser will receive the HTML of the rendered page.</p>
<p>Let's trace the flow of the events in the same application with the server-side rendering feature enabled. In this case, once the server receives the HTTP GET request by the browser, it will run the SPA on the server in the environment of node.js. All the DOM calls will be redirected to a server-side DOM implementation and executed in the context of the used platform. Similarly, all the AJAX calls with the Angular HTTP module will be handled by the server-side implementation of the module. This way, the application will not make any difference, whether it is running in the context of the browser or the server.</p>
<p>Once the rendered version of the SPA is available, it can be serialized to HTML and sent to the browser. This time, during the application's initialization, instead of the <span class="packt_screen">Loading...</span> label, the user will see the page they requested right away.</p>
<p>Note that, at this point, the client will have the rendered version of the application, but all the referenced external resources, such as scripts and styles, still need to be available. This means that, initially, none of the CSS styles declared in the external files will be applied and the application will not be responsive to any user-related interactions, such as the mouse and keyboard events.</p>
<div class="packt_infobox"><span>In case the scripts are inlined on the server-side rendered page, the application will be responsive to user events. However, inlining big chunks of JavaScript is generally considered a bad practice, as it will increase the page's size dramatically and prevent the scripts from caching, which will impact the network performance.</span></div>
<p>When the JavaScript virtual machine processes the JavaScript associated with the page, our SPA will be ready to use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Server-side rendering with Angular</h1>
                </header>
            
            <article>
                
<p>During the first half of 2015, members of the Angular community announced that they had started the development of the module, <strong>Universal</strong>. Universal is a library that allows us to build universal (also called isomorphic) JavaScript applications with Angular; in other words, it provides server-side rendering support. Later, the project was moved to Angular core's repository, and currently, it's maintained by Google.</p>
<p>Applications using Angular Universal and rendered on the server will not be responsive to user interaction until all the JavaScript belonging to the requested page has been processed. This is a drawback that we already mentioned, which is valid for all server-side rendered applications. To handle this problem, Angular Universal introduced <strong>preboot.js</strong>, which is a lightweight library that will be inlined on the page rendered by the server and be available in the initial response.</p>
<p>Preboot.js has several strategies for the management of the received client events before the application is completely initialized; they are as follows:</p>
<ul>
<li>Recording and playing back events</li>
<li>Responding immediately to events</li>
<li>Maintaining focus when a page is re-rendered</li>
<li>Buffering client-side re-rendering for smoother transition</li>
<li>Freezing a page until the bootstrap is complete</li>
</ul>
<p>At the time of writing this book, the Universal module was still being actively developed. You can give it a try using the Angular Universal Starter at <a href="https://github.com/angular/universal-starter"><span class="URLPACKT">https://github.com/angular/universal-starter</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhancing our development experience</h1>
                </header>
            
            <article>
                
<p>Our experience as developers can be enhanced in terms of productivity or by making our development experience more enjoyable. This can be achieved with all the tools, IDEs, text editors, and more, which we use on a daily basis. In this section, we'll take a brief look at popular IDEs and text editors that take advantage of the statically analyzable syntax that Angular provides. We'll also mention the language service that the Angular team developed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Text editors and IDEs</h1>
                </header>
            
            <article>
                
<p>As we have already said at the beginning of the book, the core team put a lot of effort into enhancing the tooling support in Angular. First of all, the framework is built with TypeScript, which naturally allows us to use static typing during our development process. Some of the text editors and IDEs that have great TypeScript support are as follows:</p>
<ul>
<li><strong>IntelliJ Idea</strong>: A general purpose IDE by JetBrains</li>
<li><strong>WebStorm</strong>: An IDE specialized for web development by JetBrains</li>
<li><strong>VSCode</strong>: A cross platform text editor written in TypeScript and developed by Microsoft</li>
<li><strong>Sublime Text</strong>: A cross platform text editor</li>
<li><strong>Atom</strong>: A cross platform text editor written in JavaScript, based on Electron</li>
</ul>
<p>Although not all the mentioned IDEs and text editors have Angular-specific features at the time of writing this book, the framework comes with tooling in mind. It allows the development of software that performs advanced static code analysis on the application's code, which can provide sophisticated refactoring and productivity features. A tool which empowers this feature of Angular and provides a generic interface to IDE and text editor developers is the language service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular language service</h1>
                </header>
            
            <article>
                
<p>Taking advantage of the analyzable nature of Angular, Google developed a <strong>language service</strong> for the framework. We can think of this service as a server, which indexes our project and provides autocompletion suggestions, type checking in templates, and other features, based on requests from a client. This client can be a plugin for our text editor or IDE.</p>
<p>The language service can keep track of the context of the given component that is in focus in the text editor and provide context-specific suggestions. For instance, it can provide autocompletion suggestions for directive selectors based on the available set of directives at the given part of the component tree.</p>
<p>The best thing about the language service is that it is not coupled to any specific text editor or IDE, which means that, with a thin plugin, it can be reused in any development environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bootstrapping a project with angular-cli</h1>
                </header>
            
            <article>
                
<p>During AngularConnect 2015, Brad Green and Igor Minar, part of the Angular team, announced <kbd>angular-cli</kbd>—a <strong>CLI</strong> (<strong>Command-Line Interface</strong>) tool to ease starting and managing Angular applications. For those who have used Ruby on Rails, the idea behind the CLI tool might be familiar. The basic purpose of the tool is to allow the quick setup of new projects and scaffolding of new directives, components, pipes, and services.</p>
<p>At the time of writing, the tool is based on webpack. Let's demonstrate its basic usage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using angular-cli</h1>
                </header>
            
            <article>
                
<p>In order to install the CLI tool, run the following command in your terminal:</p>
<pre><strong>$ npm install -g angular-cli</strong></pre>
<p>Right after this, the <kbd>ng</kbd> command will appear as global executable in your system. For creating a new Angular project, use the following commands:</p>
<pre><strong># May take a while, depending on your internet connection 
$ ng new angular-cli-project 
$ cd angular-cli-project 
$ ng serve</strong> </pre>
<p>The preceding commands will perform the following:</p>
<ul>
<li>Create a new Angular project and install all of its <kbd>npm</kbd> dependencies</li>
<li>Enter the project's directory</li>
<li>Start a development web server which will observe the project's directory for changes and send the refresh command to the browser when we change any of the files there</li>
</ul>
<p>For further reading, take a look at the project's repository, located at <a href="https://github.com/angular/angular-cli"><span class="URLPACKT">https://github.com/angular/angular-cli</span></a>.</p>
<p>Angular CLI provides a highly encapsulated build, so by default, it doesn't expose any of the tooling used underneath. For more advanced cases, when we want to introduce custom logic in the build, we can eject the CLI project using this:<br/></p>
<pre><strong>$ ng eject</strong></pre>
<p>This command will export the internal webpack configuration and allow us to update it manually.</p>
<div class="packt_infobox">Using Angular CLI for new projects<span> is </span><span>a good idea</span><span> unless there are restrictions set by the organization or we have different preferences</span><span>. Although the build that Angular CLI provides can be considered as a black box which is not trivial to modify, often changes are not necessary since it covers most of the use cases for small and medium projects.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular quick starters</h1>
                </header>
            
            <article>
                
<p>If you prefer a less encapsulated build, there are a lot of starter projects developed by the community that can provide a good starting point for your next Angular project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular seed</h1>
                </header>
            
            <article>
                
<p>If you enjoy static typing, you can give the <strong>Angular Seed</strong> project<span> </span><span>a try</span><span>. It is</span> hosted <span>on GitHub at </span><a href="https://github.com/mgechev/angular-seed"><span class="URLPACKT">https://github.com/mgechev/angular-seed</span></a><span>.</span></p>
<p>Angular Seed provides the following key features:</p>
<ul>
<li>Easy for extend, modular, and statically typed build systems</li>
<li>AOT compilation support</li>
<li>Support for multiple Angular applications with a shared code base in a single instance of the seed</li>
<li>Production and development builds</li>
<li>Sample unit tests with Jasmine and Karma</li>
<li>End-to-end tests with Protractor</li>
<li>A development server with LiveReload</li>
<li>Uses codelyzer for static code analysis, which verifies that the project follows practices from the Angular style guide</li>
<li>Follows best practices for the applications and files organization</li>
<li>Provides full Docker support for both development and production environment</li>
</ul>
<p>The code distributed with the book is based on this seed project.</p>
<p>For Angular Seed, you will need to have <kbd>node.js</kbd>, <kbd>npm</kbd>, and <kbd>git</kbd> installed on your computer. In order to get the starter project, run the following list of commands:</p>
<pre><strong>$ git clone --depth 1 https://github.com/mgechev/angular-seed.git 
$ cd angular-seed 
$ npm install 
$ npm start</strong> </pre>
<p>Once the execution of the commands is completed, your browser will automatically open the home page of the seed. Upon the change of any of the files in your project, the application will be automatically rebuilt, and your browser will be refreshed.</p>
<p>By default, the production build produces a single bundle that contains a minified version of the application and all the referenced libraries. Angular Seed also supports AOT compilation and extensible build systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular webpack starter</h1>
                </header>
            
            <article>
                
<p>If you prefer webpack, you can use <em>angular-starter</em>. It is a starter project developed by <em>AngularClass</em> and hosted on GitHub. You can find it at <a href="https://github.com/AngularClass/angular-starter"><span class="URLPACKT">https://github.com/AngularClass/angular-starter</span></a>.</p>
<p>This starter provides the following features:</p>
<ul>
<li>Best practices in file and application organization for Angular</li>
<li>Ready-to-go build system using webpack for working with TypeScript</li>
<li>Testing Angular code with Jasmine and Karma</li>
<li>Coverage with Istanbul and Karma</li>
<li>End-to-end Angular code using Protractor</li>
</ul>
<p>In order to give it a try, you will need to have <kbd>node.js</kbd>, <kbd>npm</kbd>, and <kbd>git</kbd> installed and run the following commands:</p>
<pre><strong>$ git clone --depth 1 https://github.com/angularclass/angular-starter.git 
$ cd angular-starter <br/># WINDOWS only. In terminal as administrator<br/>$ npm install -g node-pre-gyp
$ npm install 
$ npm start</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ahead-of-time compilation in Angular</h1>
                </header>
            
            <article>
                
<p>In this section, <span>without going into deep technical details</span>, we'll briefly explain what AOT compilation is in the context of Angular and what implication it may have on our projects. </p>
<p>The key focus in Angular is its extremely fast change detection mechanism. After exploring different options for detecting changes in the view model, the Angular team discovered that the change detection mechanism used in AngularJS can be improved dramatically using <strong>code generation</strong>. It turned out that it is possible to generate well-optimized code for the JavaScript virtual machine, which performs change detection and efficient rendering. After a lot of benchmarks, Google found out that this strategy is much more performant compared to the traditional (also known as dynamic) change detection mechanism.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How code generation works</h1>
                </header>
            
            <article>
                
<p>The Angular code generator is known as the Angular compiler. It compiles the templates of the Angular components to JavaScript or TypeScript (depending on the compilation target). When we compile the templates to TypeScript, we allow the TypeScript compiler to perform type checking, not only within the imperative logic of our components, directives, services, and pipes, but also in the components' templates! Performing type checking in the templates helps us find even more potential issues in our application.</p>
<p>On top of code generation for templates, the Angular compiler also generates code for the injectors in our application. This improves the performance of the dependency injection mechanism even further.</p>
<p>Based on the static analysis of the bindings in the templates, the generated code for the templates performs the most efficient change detection and most optimal update of the DOM tree, depending on the changed values. On top of that, the produced code takes advantage of the inline caching mechanism of JavaScript virtual machines, which brings an additional performance boost.</p>
<div class="packt_infobox">For further reading about inline caching, take a look at this article: <em>Explaining JavaScript VMs in JavaScript - Inline Caches</em>, located at <a href="http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html">http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html</a>.</div>
<p>The code generation could be either performed at runtime, known as <strong>just-in-time</strong> (<strong>JIT</strong>) compilation or build time, known as AOT compilation. Since the JIT compilation involves the evaluation of code at runtime, it is recommended that you use AOT in environments with strict <strong>Content Security Policy</strong> (<strong>CSP</strong>), where <kbd>eval</kbd> is not available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the concept of ahead-of-time compilation</h1>
                </header>
            
            <article>
                
<p>From AOT, we get a couple of improvements. First, if we compile our Angular application as part of the build process, we don't need to compile it at runtime. This means that we don't get the runtime performance hit that we get when using JIT. This way, AOT offers faster initial rendering of the application because Angular has to do less work during initialization.</p>
<p>On top of this, since we don't have to perform compilation at runtime anymore, we can drop the entire <kbd>@angular/compiler</kbd> module out of the final application bundle and decrease the bundle size.</p>
<p>Finally, we can perform much more efficient dead code elimination in terms of <strong>tree-shaking</strong>. Tree-shaking means dropping unused exports, which is one of the great properties of the static nature of the ES2015 modules. When relaying on JIT compilation, we can reference different components by their selectors inside the templates. However, the templates are in a HTML-like format, which the modern minifiers (such as UglifyJS and Google Closure Compiler) don't understand. This means that they cannot eliminate all the unused exports (for instance, unused components), since they are not sure what exactly is used within the templates. Once at build time, the Angular compiler translates the templates to TypeScript or JavaScript; with static ES2015 imports, bundlers can apply traditional dead-code elimination techniques, and so reduce the bundle size even further!</p>
<div class="packt_infobox">If you're interested in further reading, you can take a look at the article <em>Ahead-of-Time Compilation in Angular</em> at <a href="https://goo.gl/eXieJl">https://goo.gl/eXieJl</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constraints of the ahead-of-time compilation</h1>
                </header>
            
            <article>
                
<p>Keep in mind that the Angular compiler needs type metadata in order to perform the process of compilation. This means that you cannot perform AOT compilation if you're not using TypeScript. </p>
<p>AOT compilation is performed by collecting metadata during build time. This means that, in some cases, our code may work with JIT, but may not work in AOT in case we have dynamic constructs, which cannot be resolved at build time.</p>
<div class="packt_infobox">For further details about which syntax constructs may not work with AOT compilation, take a look at this repository at <a href="https://goo.gl/F7cV1s">https://goo.gl/F7cV1s</a>.</div>
<p>Finally, the generated code for the templates is not part of the components controllers themselves. This means that we cannot bind to nonpublic fields because, during compilation, TypeScript will throw an error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to use the ahead-of-time compilation of Angular</h1>
                </header>
            
            <article>
                
<p>The Angular's AOT compilation is already supported in the most popular starters and the CLI.</p>
<p>At the time of writing, Angular CLI performs AOT compilation by default in the production build. To get the optimized production assets, run this command:</p>
<pre><strong>$ ng build --prod</strong></pre>
<p>Angular Seed introduced AOT compilation when Angular 2.0.0-rc.5 was released. With the seed, you can take advantage of all the benefits that come with it by running the following command:</p>
<pre><strong>$ npm run build.prod.aot</strong></pre>
<p>By executing the preceding commands, you'll get a well-optimized production build of your application.</p>
<div class="packt_tip packt_infobox">Since web tooling changes quite frequently, we didn't go into details of how Angular Seed or Angular CLI produce the production build. If you're interested in further reading on what is going on under the hood, you can take a look at an article at <a href="https://goo.gl/kAiJUJ">https://goo.gl/kAiJUJ</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We started our journey by introducing the reasons behind the rewrite of Angular, which was followed by a conceptual overview that gave us a general idea about the building blocks of the framework. In the next step, we went through <a href="c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml"/><a href="c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml">Chapter 4</a><em>, TypeScript Crash</em> <em>course</em>, that prepared us for <a href="1b60c28e-5f34-493d-8371-c69968f09020.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Getting Started with Angular Components and Directives</em>, where we went deep into Angular's directives, components, and change detection.</p>
<p>In <a href="3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml"/><a href="3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Dependency Injection in Angular</em>,<em> </em>we explained the dependency injection mechanism and saw how it's related to the component hierarchy. In the following chapters, we saw how we can develop forms and pipes and take advantage of Angular's router.</p>
<p>By completing this final chapter, we have finished our journey into the framework. At the time of writing, the design decisions and the ideas behind Angular's core are solid and finalized. Although the framework is still brand new, in the past year, its ecosystem reached a level where we can develop production-ready, high-performance, and SEO-friendly applications, and on top of this, have a great development experience with static typing and IDE support.</p>


            </article>

            
        </section>
    </body></html>