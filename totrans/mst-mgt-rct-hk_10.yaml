- en: '*Chapter 7*: Use Case Scenario 1 – Zustand'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：用例场景 1 – Zustand'
- en: So far, we have been exploring some basic patterns we can use to implement a
    global state in React. In this chapter, we will learn about a real implementation
    that is publicly available as a package, called Zustand.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探索了一些可以用来在 React 中实现全局状态的基本模式。在本章中，我们将学习一个公开作为包提供的真实实现，称为 Zustand。
- en: Zustand ([https://github.com/pmndrs/zustand](https://github.com/pmndrs/zustand))
    is a tiny library primarily designed to create module state for React. It's based
    on an immutable update model, in which state objects can't be modified but always
    have to be newly created. Render optimization is done manually using selectors.
    It has a straightforward and yet powerful `store` creator interface.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Zustand ([https://github.com/pmndrs/zustand](https://github.com/pmndrs/zustand))
    是一个主要用于为 React 创建模块状态的微型库。它基于不可变更新模型，其中状态对象不能被修改，但必须始终创建新的对象。渲染优化是通过选择器手动完成的。它提供了一个简单而强大的
    `store` 创建接口。
- en: In this chapter, we will explore how module state and subscriptions are used
    and see what the library API looks like.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨模块状态和订阅的使用，并查看库 API 的样子。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding module state and immutable state
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模块状态和不可变状态
- en: Adding React hooks to optimize re-renders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 React hooks 以优化重新渲染
- en: Working with read state and update state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理读取状态和更新状态
- en: Handling structured data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理结构化数据
- en: Pros and cons of this approach and library
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法和库的优缺点
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You are expected to have moderate knowledge of React, including React hooks.
    Please refer to the official site, [https://reactjs.org](https://reactjs.org),
    to learn more.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 预期您对 React 有一定的了解，包括 React hooks。请参考官方网站 [https://reactjs.org](https://reactjs.org)
    了解更多信息。
- en: In some of the code in this chapter, we will be using TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org)),
    so you should have basic knowledge of it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的一些代码中，我们将使用 TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org))，因此您应该对其有基本了解。
- en: The code in this chapter is available on GitHub at [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_07](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_07).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可在 GitHub 上找到 [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_07](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_07)。
- en: To run the code snippets in this chapter, you will need a React environment,
    such as Create React App ([https://create-react-app.dev](https://create-react-app.dev))
    or CodeSandbox ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码片段，您需要一个 React 环境，例如 Create React App ([https://create-react-app.dev](https://create-react-app.dev))
    或 CodeSandbox ([https://codesandbox.io](https://codesandbox.io))。
- en: At the time of writing, the current version of Zustand is v3\. Future versions
    may provide some different APIs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Zustand 的当前版本是 v3。未来的版本可能会提供一些不同的 API。
- en: Understanding module state and immutable state
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模块状态和不可变状态
- en: Zustand is a library that's used to create a `store` that holds a state. It's
    primarily designed for module state, which means you define this `store` in a
    module and export it. It's based on the immutable state model, in which you are
    not allowed to modify state object properties. Updating states must be done by
    creating new objects, while unmodified state objects must be reused. The benefit
    of the immutable state model is that you only need to check state object referential
    equality to know if there's any update; you don't have to check equality deeply.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Zustand 是一个用于创建包含状态的 `store` 的库。它主要用于模块状态，这意味着您在模块中定义此 `store` 并导出它。它基于不可变状态模型，其中不允许修改状态对象属性。更新状态必须通过创建新对象来完成，而未修改的状态对象必须被重用。不可变状态模型的好处是，您只需检查状态对象的引用等价性即可知道是否有任何更新；您不需要深入检查等价性。
- en: 'The following is a minimal example that can be used to create a `count` state.
    It takes a `store` creator function that returns an initial state:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个最小示例，可以用来创建一个 `count` 状态。它接受一个返回初始状态的 `store` 创建函数：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`store` exposes some functions such as `getState`, `setState`, and `subscribe`.
    You can use `getState` to get the state in `store` and `setState` to set the state
    in `store`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`store` 提供了一些函数，如 `getState`、`setState` 和 `subscribe`。您可以使用 `getState` 来获取
    `store` 中的状态，并使用 `setState` 来设置 `store` 中的状态：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The state is immutable, and you can''t mutate it like you can `++state.count`.
    The following example is an invalid usage that violates the state''s immutability:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是不可变的，你不能像`++state.count`那样修改它。以下是一个无效的使用示例，它违反了状态的不可变性：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`state1.count = 2` is the invalid usage, so it doesn''t work as expected. With
    this invalid usage, the new state has the same reference as the old state, and
    the library can''t detect the change properly.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`state1.count = 2`是无效的使用，所以它不会按预期工作。使用这种无效的使用方法，新状态与旧状态具有相同的引用，库无法正确检测到更改。'
- en: 'The state must be updated with a new object such as `store.setState({ count:
    2 })`. The `store.setState` function also accepts a function to update:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '必须使用新对象来更新状态，例如`store.setState({ count: 2 })`。`store.setState`函数也接受一个用于更新的函数：'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is called a function update, and it makes it easy to update the state with
    the previous state.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为函数更新，它使得使用前一个状态更新状态变得容易。
- en: 'So far, we only have one `count` property in the state. The state can have
    multiple properties. The following example has an additional `text` property:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，状态中只有一个`count`属性。状态可以有多个属性。以下示例中有一个额外的`text`属性：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Again, the state must be updated immutably, like so:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，状态必须不可变地更新，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, `store.setState()` will merge the new state and the old state. Hence,
    you can only specify the properties you want to set:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`store.setState()`将合并新状态和旧状态。因此，你只能指定要设置的属性：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first `console.log` statement outputs `{ count: 1, text: ''hello'' }`,
    while the second one outputs `{ count: 2, text: ''hello'' }`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个`console.log`语句输出`{ count: 1, text: ''hello'' }`，而第二个输出`{ count: 2, text:
    ''hello'' }`。'
- en: 'As this only changes `count`, the `text` property isn''t changed. Internally,
    this is implemented with `Object.assign()`, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这仅更改了`count`，`text`属性没有改变。内部，这是通过`Object.assign()`实现的，如下所示：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Object.assign` function will return a new object by merging the `oldState`
    and `newState` properties.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign`函数将通过合并`oldState`和`newState`属性来返回一个新的对象。'
- en: 'The last piece of the `store` function is `store.subscribe`. The `store.subscribe`
    function allows you to register a callback function, which will be invoked every
    time the state in `store` is updated. It works like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`store`函数的最后一部分是`store.subscribe`。`store.subscribe`函数允许你注册一个回调函数，每次`store`中的状态更新时都会调用该函数。它的工作方式如下：'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the `store.setState` statement, the `store.subscribe` is an important function
    for implementing React hooks.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`store.setState`语句时，`store.subscribe`是实现React钩子的重要函数。
- en: In this section, we learned about the basics of Zustand. You might notice that
    this is very close to what we learned in [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066),
    *Sharing Module State with Subscription*. Essentially, Zustand is a thin library
    built around the idea of an immutable state model and subscription.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了Zustand的基本知识。你可能注意到，这与我们在[*第4章*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066)中学习的内容非常相似，*通过订阅共享模块状态*。本质上，Zustand是一个围绕不可变状态模型和订阅思想的轻量级库。
- en: In the next section, we will learn how to use `store` in React.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在React中使用`store`。
- en: Using React hooks to optimize re-renders
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React钩子优化重新渲染
- en: For global states, optimizing re-renders is important because not all components
    use all the properties in a global state. Let's learn how Zustand addresses this.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于全局状态，优化重新渲染很重要，因为并非所有组件都使用全局状态中的所有属性。让我们看看Zustand是如何处理这个问题的。
- en: To use `store` in React, we need a custom hook. Zustand's `create` function
    creates a `store` that can be used as a hook.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要在React中使用`store`，我们需要一个自定义钩子。Zustand的`create`函数创建了一个可以用于钩子的`store`。
- en: 'To follow the naming convention of React hooks, we have named the created value
    `useStore` instead of `store`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循React钩子的命名约定，我们将创建的值命名为`useStore`而不是`store`：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we must use the created `useStore` hook in React components. The `useStore`
    hook, if it''s invoked, returns the entire `state` object, including all its properties.
    For example, let''s define a component that shows the `count` value in `store`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须在React组件中使用创建的`useStore`钩子。如果调用`useStore`钩子，它将返回整个`state`对象，包括其所有属性。例如，让我们定义一个组件来显示`store`中的`count`值：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This component shows the `count` value and that whenever the `store` state is
    changed, it will re-render. While this works fine of the time, if only the `text`
    value is changed and the `count` value is not changed, the component will output
    essentially the same `text` value causes extra re-renders.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件显示`count`值，并且每当`store`状态改变时，它都会重新渲染。虽然这在大多数情况下都很好，但如果只有`text`值改变而`count`值没有改变，组件将输出几乎相同的`text`值，这会导致额外的重新渲染。
- en: 'When we need to avoid extra re-renders, we can specify a selector function;
    that is, `useStore`. The previous component can be rewritten with a selector function,
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要避免额外的重新渲染时，我们可以指定一个选择器函数；即`useStore`。之前的组件可以用选择器函数重写，如下所示：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By making this change, but only when the `count` value is changed, the component
    will re-render.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行这个更改，但只有在`count`值改变时，组件才会重新渲染。
- en: This selector-based extra re-render control is what we call **manual render
    optimization**. The way the selector works to avoid re-renders is to compare the
    results of what the selector function returns. You need to be careful when you're
    defining a selector function to return stable results to avoid re-renders.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于选择器的额外重新渲染控制就是我们所说的**手动渲染优化**。选择器工作以避免重新渲染的方式是对比选择器函数返回的结果。在定义选择器函数以返回稳定结果时，你需要小心，以避免重新渲染。
- en: 'For example, the following example doesn''t work well because the selector
    function creates a new array with a new object in it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下示例工作得不好，因为选择器函数创建了一个包含新对象的新数组：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As a result, the component will re-render, even if the `count` value is unchanged.
    This is a pitfall when we use selectors for render optimization.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使`count`值没有改变，组件也会重新渲染。这是我们使用选择器进行渲染优化时的一个陷阱。
- en: In summary, the benefit of selector-based render optimization is that the behavior
    is fairly predictable because you explicitly write selector functions. However,
    the downside of selector-based render optimization is that it requires an understanding
    of object references.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，基于选择器的渲染优化的好处是行为相对可预测，因为你明确地编写了选择器函数。然而，基于选择器的渲染优化的缺点是它需要理解对象引用。
- en: In this section, we learned how to use a hook that's been created with Zustand,
    as well as how to optimize re-renders with selectors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用由Zustand创建的钩子，以及如何使用选择器优化重新渲染。
- en: Next, we will learn how to use Zustand with React using a minimal example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个最小示例学习如何使用Zustand与React。
- en: Working with read state and update state
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理读取状态和更新状态
- en: While Zustand is a library that can be used in various ways, it has a pattern
    to read state and update state. Let's learn how to use Zustand with a small example.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Zustand`是一个可以以多种方式使用的库，但它有一个读取状态和更新状态的模式。让我们通过一个小示例学习如何使用Zustand。
- en: 'Here''s our small `store` with the `count1` and `count2` properties:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的小型`store`，包含`count1`和`count2`属性：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This creates a new `store` with two properties called `count1` and `count2`.
    Notice that `StoreState` is the `type` definition in TypeScript.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个新的`store`，包含名为`count1`和`count2`的两个属性。请注意，`StoreState`是TypeScript中的`type`定义。
- en: 'Next, we must define the `Counter1` component, which shows a `count1` value.
    We must define the `selectCount1` selector function in advance and pass it to
    `useStore` to optimize re-renders:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义`Counter1`组件，它显示`count1`值。我们必须提前定义`selectCount1`选择器函数并将其传递给`useStore`以优化重新渲染：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that the inline `inc1` function is defined. We invoke the `setState`
    function in `store`. This is a typical pattern and we can define the function
    in `store` for more reusability and readability.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到内联的`inc1`函数已被定义。我们在`store`中调用`setState`函数。这是一个典型的模式，我们可以在`store`中定义函数以提高可重用性和可读性。
- en: 'The `store` creator function that is passed to the `create` function takes
    some arguments; the first argument is the `setState` function in `store`. Let''s
    redefine our `store` with this capability:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`create`函数的`store`创建函数接受一些参数；第一个参数是`store`中的`setState`函数。让我们使用这种能力重新定义我们的`store`。
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, our `store` has two new properties called `inc1` and `inc2`, which are
    function properties. Note that it's a good convention to name the first argument
    `set`, which is short for `setState`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`store`有两个新属性，称为`inc1`和`inc2`，它们是函数属性。请注意，将第一个参数命名为`set`是一个好习惯，它是`setState`的简称。
- en: 'Using the new `store`, we must define the `Counter2` component. You can compare
    it to the previous `Counter1` component and notice that it can be refactored in
    the same way:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 `store`，我们必须定义 `Counter2` 组件。你可以将其与之前的 `Counter1` 组件进行比较，并注意到它可以以相同的方式进行重构：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we have a new selector function called `selectInc2`, and the
    `inc2` function is just the result of `useStore`. Likewise, we could add more
    functions to `store`, which allows some logic to reside outside the components.
    You can co-locate state updating logic close to the state values. This is the
    reason why Zustand's `setState` merges old state and new state. We also discussed
    this in the *Understanding module state and immutable state* section, where we
    learned how `Object.assign` is used.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个名为 `selectInc2` 的新选择器函数，而 `inc2` 函数仅仅是 `useStore` 的结果。同样，我们还可以向
    `store` 中添加更多函数，这允许一些逻辑存在于组件之外。你可以将状态更新逻辑与状态值紧密地放在一起。这就是为什么 Zustand 的 `setState`
    会合并旧状态和新状态。我们也在 *理解模块状态和不可变状态* 部分讨论了这一点，那里我们学习了如何使用 `Object.assign`。
- en: 'What if we want to create a derived state? We can use a selector for a derived
    state. First, let''s look at a naive example. The following is a new component
    that shows the `total` number of `count1` and `count2`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想创建一个派生状态怎么办？我们可以使用一个派生状态的选择器。首先，让我们看看一个简单示例。以下是一个新组件，它显示了 `count1` 和 `count2`
    的 `total` 数量：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a valid pattern and it can stay as-is. There is an edge case where extra
    re-renders happen, which is when `count1` is increased and `count2` is decreased
    by the same amount. The `total` number won't change, but it will re-render. To
    avoid this, we can use a selector function for the derived state.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的模式，它可以保持原样。存在一个边缘情况，即额外的重新渲染发生，这是当 `count1` 增加，而 `count2` 以相同数量减少时。总数不会改变，但它会重新渲染。为了避免这种情况，我们可以使用一个选择器函数来处理派生状态。
- en: 'The following example shows a new `selectTotal` function being used to calculate
    the `total` number:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用新的 `selectTotal` 函数来计算 `total` 数量：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will only re-render when the `total` number is changed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会在 `total` 数量改变时重新渲染。
- en: 'With that, we have calculated the `total` number in a selector. While this
    is a valid solution, let''s look at another approach where we can create the total
    number in the store. If we could create the `total` number in `store`, it could
    remember the result and we can avoid unnecessary calculations when many components
    are using the value. This is not very common, but it''s important if the calculation
    is very computation-heavy. A naive way to do this would be as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在选择器中计算了 `total` 数量。虽然这是一个有效的解决方案，但让我们看看另一种方法，我们可以在存储中创建总数。如果我们能在 `store`
    中创建 `total` 数量，它将记住结果，并且当许多组件使用该值时，我们可以避免不必要的计算。这并不常见，但如果计算非常计算密集，这很重要。一个简单的方法如下：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is a more sophisticated way to do this, but the base idea is to calculate
    multiple properties at the same time and keep them in sync. Another library, Jotai,
    handles this well. Refer to [*Chapter 8*](B17780_08_Final_VK_ePub.xhtml#_idTextAnchor100),
    *Use Case Scenario 2 – Jotai*, to learn more.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更复杂的方法来做这件事，但基本思想是同时计算多个属性并保持它们同步。另一个库，Jotai，处理得很好。请参阅 [*第8章*](B17780_08_Final_VK_ePub.xhtml#_idTextAnchor100)，*用例场景2
    - Jotai*，了解更多信息。
- en: 'The last missing piece for running the example app is the `App` component:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例应用程序的最后一步是定义 `App` 组件：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you run this app, you will see something like the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个应用程序时，你会看到以下类似的内容：
- en: '![Figure 7.1 – Screenshot of the running app ](img/Figure_7.1_B17780.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 运行应用程序的截图](img/Figure_7.1_B17780.jpg)'
- en: Figure 7.1 – Screenshot of the running app
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 运行应用程序的截图
- en: If you click the first button, you will see that both numbers on the screen
    – after the `count1` label and the `total` number – increase. If you click the
    second button, you will see that both numbers on the screen – after the `count2`
    label and the `total` number – increase.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击第一个按钮，你会看到屏幕上的两个数字——在 `count1` 标签和 `total` 数量之后——都会增加。如果你点击第二个按钮，你会看到屏幕上的两个数字——在
    `count2` 标签和 `total` 数量之后——也会增加。
- en: In this section, we learned about reading and updating the state in a way that
    is often used in Zustand. Next, we will learn about how to handle structured data
    and how to use arrays.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了在 Zustand 中以常用方式读取和更新状态。接下来，我们将学习如何处理结构化数据以及如何使用数组。
- en: Handling structured data
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理结构化数据
- en: 'An example that deals with a set of numbers is fairly easy. In reality, we
    need to handle objects, arrays, and a combination of them. Let''s learn how to
    use Zustand by covering another example. This is a well-known Todo app example.
    It''s an app where you can do the following things:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 处理一组数字的示例相当简单。在现实中，我们需要处理对象、数组以及它们的组合。让我们通过另一个示例来学习如何使用Zustand。这是一个众所周知的Todo应用示例。这是一个你可以做以下事情的应用：
- en: Create a new Todo item.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的Todo项。
- en: See the list of Todo items.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看Todo项列表。
- en: Toggle a Todo item's done status.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换Todo项的完成状态。
- en: Remove a Todo item.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个Todo项。
- en: 'First, we must define some types before creating a store. The following is
    the type definition for a `Todo` object. It has the `id`, `title`, and `done`
    properties:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在创建存储之前，我们必须定义一些类型。以下是一个`Todo`对象的类型定义。它具有`id`、`title`和`done`属性：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, the `StoreState` type can be defined with `Todo`. The value part of the
    store is `todos`, which is a list of Todo items. In addition to this, there are
    three functions – `addTodo`, `removeTodo`, and `toggleTodo` – that can be used
    to manipulate the `todos` property:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以使用`Todo`定义`StoreState`类型。存储的值部分是`todos`，它是一系列Todo项。除此之外，还有三个函数——`addTodo`、`removeTodo`和`toggleTodo`——可以用来操作`todos`属性：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `todos` property is an array of objects. Having an array of objects in a
    `store` state is a typical practice and will be the focus of this section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`todos`属性是一个对象数组。在`store`状态中有一个对象数组是典型的做法，并将是本节的重点。'
- en: 'Next, we must define `store`. It''s also a hook that''s called `useStore`.
    When it''s created, `store` has an empty `todos` property and three functions
    called `addTodo`, `removeTodo`, and `toggleTodo`. `nextId` is defined outside
    the `create` function as a naive solution to provide a unique `id` for a new Todo
    item:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义`store`。它也是一个名为`useStore`的钩子。当它被创建时，`store`有一个空的`todos`属性和三个函数，分别称为`addTodo`、`removeTodo`和`toggleTodo`。`nextId`在`create`函数外部定义为一种原始解决方案，为新的Todo项提供唯一的`id`：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that the `addTodo`, `removeTodo`, and `toggleTodo` functions are implemented
    in an immutable manner. They don't mutate existing objects and arrays; they create
    new ones instead.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`addTodo`、`removeTodo`和`toggleTodo`函数是以不可变的方式实现的。它们不会修改现有的对象和数组；相反，它们创建新的。
- en: 'Before we define a main `TodoList` component, let''s look at a `TodoItem` component
    that is responsible for rendering one item:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义主`TodoList`组件之前，让我们看看一个负责渲染单个项的`TodoItem`组件：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As the `TodoItem` component takes a `todo` object in `props`, it''s a fairly
    simple component in terms of states. The `TodoItem` component has two controls:
    a button that is handled by `removeTodo` and a checkbox that is handled by `toggleTodo`.
    These are the two functions from `store` for each control. The `selectRemoveTodo`
    and `selectToggleTodo` functions are passed to the `useStore` function to get
    the `removeTodo` and `toggleTodo` functions, respectively.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`TodoItem`组件在`props`中接受一个`todo`对象，所以在状态方面它是一个相当简单的组件。`TodoItem`组件有两个控件：一个由`removeTodo`处理的按钮和一个由`toggleTodo`处理的复选框。这些是来自`store`的每个控件的两个函数。`selectRemoveTodo`和`selectToggleTodo`函数被传递给`useStore`函数，分别获取`removeTodo`和`toggleTodo`函数。
- en: 'Let''s create a memoized version of the `TodoItem` component named `MemoedTodoItem`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`MemoedTodoItem`的`TodoItem`组件的记忆化版本：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we will discuss how this will help in our app. We are ready to define the
    main `TodoList` component. It uses `selectTodos`, a function that's used to select
    the `todos` property from `store`. Then, it maps over the `todos` array and renders
    `MemoedTodoItem` for each todo item.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论这将如何帮助我们的应用。我们已经准备好定义主`TodoList`组件。它使用`selectTodos`函数，该函数用于从`store`中选择`todos`属性。然后，它遍历`todos`数组，并为每个todo项渲染`MemoedTodoItem`。
- en: It is important to use the memoized component here to avoid extra re-renders.
    Because we update the `store` state in an immutable manner, most of the `todo`
    objects in the `todos` array are not changed. If the `todo` object we pass to
    the `MemoedTodoItem` props is not changed, the component won't re-render. Whenever
    the `todos` array is changed, the `TodoList` component re-renders. However, its
    child components only re-render if the corresponding `todo` item is changed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用记忆化组件非常重要，以避免额外的重新渲染。因为我们以不可变的方式更新`store`状态，所以`todos`数组中的大多数`todo`对象都没有改变。如果我们传递给`MemoedTodoItem`属性的`todo`对象没有改变，组件就不会重新渲染。每当`todos`数组发生变化时，`TodoList`组件会重新渲染。然而，其子组件只有在相应的`todo`项发生变化时才会重新渲染。
- en: 'The following code shows the `selectTodos` function and the `TodoList` component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`selectTodos`函数和`TodoList`组件：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `TodoList` component maps over the `todos` list and, for each `todo` item,
    renders the `MemoedTodoItem` component.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoList`组件遍历`todos`列表，并为每个`todo`项目渲染`MemoedTodoItem`组件。'
- en: 'What remains is to add a new `todo` item. `NewTodo` is a component that can
    be used to render a text box and a button, as well as to call the `addTodo` function
    when the button is clicked. `selectAddTodo` is a function that can be used to
    select the `addTodo` function in `store`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是添加一个新的`todo`项目。`NewTodo`是一个可以用来渲染文本框和按钮的组件，以及当按钮被点击时调用`addTodo`函数。`selectAddTodo`是一个可以用来在`store`中选择`addTodo`函数的函数：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are two minor notes we should mention regarding improving the behavior
    in `NewTodo`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在`NewTodo`中改进行为，我们应该提到两个小问题：
- en: It clears the text box when the button is clicked **[1]**.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按钮被点击时，它会清除文本框**[1]**。
- en: It disables the button when the text box is empty **[2]**.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当文本框为空时，它会禁用按钮**[2]**。
- en: 'Finally, to finish up the Todo app, we must define the `App` component:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了完成Todo应用程序，我们必须定义`App`组件：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running this app will show only a text box and a disabled **Add** button at
    first:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用程序最初将只显示一个文本框和一个禁用的**添加**按钮：
- en: '![Figure 7.2 – First screenshot of the running app ](img/Figure_7.2_B17780.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 运行中的应用程序的第一次截图](img/Figure_7.2_B17780.jpg)'
- en: Figure 7.2 – First screenshot of the running app
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 运行中的应用程序的第一次截图
- en: 'If you enter some text and click the **Add** button, the item will appear:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入一些文本并点击**添加**按钮，项目将会出现：
- en: '![Figure 7.3 – Second screenshot of the running app ](img/Figure_7.3_B17780.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 运行中的应用程序的第二次截图](img/Figure_7.3_B17780.jpg)'
- en: Figure 7.3 – Second screenshot of the running app
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 运行中的应用程序的第二次截图
- en: 'Clicking a checkbox will toggle the `done` status of the item:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 点击复选框将切换项目的**完成**状态：
- en: '![Figure 7.4 – Third screenshot of the running app ](img/Figure_7.4_B17780.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 运行中的应用程序的第三次截图](img/Figure_7.4_B17780.jpg)'
- en: Figure 7.4 – Third screenshot of the running app
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 运行中的应用程序的第三次截图
- en: 'Clicking the **Delete** button on the screen will delete the item:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 点击屏幕上的**删除**按钮将删除项目：
- en: '![Figure 7.5 – Fourth screenshot of the running app ](img/Figure_7.5_B17780.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 运行中的应用程序的第四次截图](img/Figure_7.5_B17780.jpg)'
- en: Figure 7.5 – Fourth screenshot of the running app
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 运行中的应用程序的第四次截图
- en: You can add as many items as you want. All these features are implemented with
    all the code we have discussed in this section. Re-renders are optimized, thanks
    to the immutable update of the `store` state and the `memo` function provided
    by React.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加你想要的任何数量的项目。所有这些功能都是通过本节中我们讨论的所有代码实现的。由于`store`状态和React提供的`memo`函数的不可变更新，重新渲染得到了优化。
- en: In this section, we learned how to handle arrays with a typical Todo app example.
    Next, we will discuss the pros and cons of this library and the approach in general.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何通过典型的Todo应用程序示例来处理数组。接下来，我们将讨论这个库以及一般方法的优缺点。
- en: Pros and cons of this approach and library
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这种方法和库的优缺点
- en: "Let's discuss the pros and cons of using Zustand or any other libraries to\
    \ implement \Lthis approach."
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论使用Zustand或其他库来实现此方法的优缺点。
- en: 'To recap, the following are the reading and writing states of Zustand:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，以下是基于Zustand的读取和写入状态：
- en: '**Reading state**: This utilizes selector functions to optimize re-renders.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取状态**：这利用选择器函数来优化重新渲染。'
- en: '**Writing state**: This is based on the immutable state model.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写入状态**：这是基于不可变状态模型。'
- en: 'The key point is that React is based on object immutability for optimization.
    One example is `useState`. React optimizes re-renders with object referential
    equality based on immutability. The following example illustrates this behavior:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是React基于对象不可变性进行优化。一个例子是`useState`。React通过基于不可变性的对象引用相等性来优化重新渲染。以下示例说明了这种行为：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, even if you click the `Update` button, it won''t show the `"component
    updated"` message. This is because React assumes that the `countObj` value will
    not change if the object reference is the same. This means that changing the `handleClick`
    function doesn''t make any changes:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，即使你点击`更新`按钮，它也不会显示`"组件已更新"`消息。这是因为React假设如果对象引用相同，则`countObj`的值不会改变。这意味着更改`handleClick`函数不会产生任何变化：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you call `handleClick`, the `countObj` value will change, but the `countObj`
    object won't. Hence, React assumes it's unchanged. This is what we mean by React
    being based on immutability for optimization. This same behavior can be observed
    with functions such as `memo` and `useMemo`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用 `handleClick`，`countObj` 的值将会改变，但 `countObj` 对象本身不会变。因此，React 假设它没有改变。这就是我们所说的
    React 优化基于不可变性的原因。同样的行为也可以在 `memo` 和 `useMemo` 等函数中观察到。
- en: The Zustand state model is perfectly in line with this object immutability assumption
    (or convention). Zustand's render optimization with selector functions is also
    based on immutability – that is, if a selector function returns the same object
    referentially (or value), it assumes that the object is not changed and avoids
    re-rendering.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Zustand 的状态模型与这种对象不可变性假设（或约定）完全一致。Zustand 使用选择器函数的渲染优化也是基于不可变性的 – 也就是说，如果一个选择器函数返回相同的对象引用（或值），它假设对象没有改变，从而避免重新渲染。
- en: Zustand having the same model as React gives us a huge benefit in terms of library
    simplicity and its small bundle size.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Zustand 与 React 具有相同的模型，这给我们带来了巨大的好处，包括库的简单性和其小巧的体积。
- en: On the other hand, a limitation of Zustand is its manual render optimization
    with selectors. It requires that we understand object referential equality and
    the code for selectors tends to require more boilerplate code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Zustand 的一个限制是它使用选择器进行的手动渲染优化。这要求我们理解对象引用相等性，并且选择器的代码往往需要更多的样板代码。
- en: In summary, Zustand – or any other libraries with this approach – is a simple
    addition to the React principle. It's a good recommendation if you need a library
    with a small bundle size, if you are familiar with referential equality and memoization,
    or you prefer manual render optimization.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Zustand – 或者任何采用这种方法的库 – 是对 React 原则的一个简单补充。如果你需要一个体积小的库，如果你熟悉引用相等性和记忆化，或者你更喜欢手动渲染优化，这是一个很好的推荐。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the Zustand library. It's a tiny library that
    uses module state in React. We looked at a counting example and a Todo example
    to grasp how to use the library. We typically use this library to understand object
    referential equality. You can choose this library or similar approaches based
    on your requirements and what you have learned in this chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Zustand 库。这是一个使用 React 模块状态的微型库。我们通过计数示例和待办事项示例来了解如何使用这个库。我们通常使用这个库来理解对象引用相等性。你可以根据自己的需求和在本章中学到的知识选择这个库或类似的方法。
- en: We didn't discuss some aspects of Zustand in this chapter, including middleware,
    which allows you to give some features to the `store` creator, and non-module
    state usage, which creates a `store` in the React life cycle. These can be other
    considerations when you're choosing a library. You should always refer to the
    library documentation for more – and the latest – information.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们没有讨论 Zustand 的某些方面，包括中间件，它允许你向 `store` 创建者提供一些功能，以及非模块状态的使用，这在 React
    生命周期中创建一个 `store`。在选择库时，这些都是其他需要考虑的因素。你应该始终参考库文档以获取更多 – 以及最新的 – 信息。
- en: In the next chapter, we will learn about another library, Jotai.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习另一个库，Jotai。
