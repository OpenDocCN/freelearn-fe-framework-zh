- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Micro Frontend with Angular Elements
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular Elements的微前端
- en: As your application grows and becomes more complex, one team alone is not enough
    to maintain the growth rate, and new people are needed to handle other parts of
    the application as they appear. At this point, the architecture of your project
    needs to evolve, and one possibility is to divide your application into several
    projects that are integrated as one. This practice was born in the world of backend
    services and appears in the frontend world under the name of **micro frontends**.
    In this chapter, we will learn how to apply this principle in an Angular project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长和复杂化，仅一个团队不足以维持增长速度，需要新的人来处理出现的新应用程序部分。在这个时候，你的项目架构需要进化，一个可能的方法是将你的应用程序分解成几个项目，这些项目作为一个整体集成。这种做法起源于后端服务领域，在前端领域以**微前端**的名字出现。在本章中，我们将学习如何在Angular项目中应用这一原则。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Micro frontend – concepts and application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微前端 – 概念和应用
- en: Slicing your application in the micro frontend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微前端中切割你的应用程序
- en: Creating a micro frontend application with standalone components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用独立组件创建微前端应用程序
- en: Preparing a page to be loaded by the base application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备一个将被基础应用程序加载的页面
- en: Dynamically loading micro frontends
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态加载微前端
- en: By the end of this chapter, you will be able to assess when it is necessary
    to use a micro frontend, how to organize your Angular projects, and how to integrate
    it into a cohesive application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够评估何时需要使用微前端，如何组织你的Angular项目，以及如何将其整合成一个统一的应用程序。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，你需要以下内容：
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 18或更高版本([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch11](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch11).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在[https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch11](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch11)找到。
- en: Before you start reading this chapter, remember to run the backend of the application
    found in the `gym-diary-backend` folder with the `npm` `start` command.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始阅读本章之前，请记住使用`npm` `start`命令运行`gym-diary-backend`文件夹中的应用程序的后端。
- en: Micro frontend – concepts and application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微前端 – 概念和应用
- en: In 2014, an article by Martin Fowler and James Lewis ([https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html))
    shook the world of development with the formalization of the concept of microservices.
    Focused on the development of backend services, the idea of dividing a large system
    (known as a monolith) into small, independent services focused on just one aspect
    of the business was undoubtedly a milestone for system architecture.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，Martin Fowler和James Lewis的一篇文章([https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html))通过正式化微服务的概念，震撼了开发界。该文章专注于后端服务的开发，将一个大的系统（称为单体）分解成专注于业务单一方面的独立小服务，无疑是系统架构的一个里程碑。
- en: Not long after, this concept was applied to the frontend world, with one of
    the main articles written by Cam Jackson ([https://martinfowler.com/articles/micro-frontends.html](https://martinfowler.com/articles/micro-frontends.html)).
    The basic idea of the *micro frontend* is the same as its sibling, *microservices*,
    which consists of dividing a large frontend project (monolith) into small, independent
    projects focused on one aspect of the business. However, the concerns are different,
    of course. In microservices, we worry about databases and communication protocols,
    whereas on the frontend, we need to worry about packet size, accessibility, and
    user experience.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不久之后，这个概念被应用于前端领域，其中一篇主要文章由Cam Jackson撰写([https://martinfowler.com/articles/micro-frontends.html](https://martinfowler.com/articles/micro-frontends.html))。*微前端*的基本思想与其兄弟概念*微服务*相同，即把一个大的前端项目（单体）分解成专注于业务某一方面的独立小项目。然而，关注点当然不同。在微服务中，我们担心的是数据库和通信协议，而在前端，我们需要关注的是数据包大小、可访问性和用户体验。
- en: Let’s start by analyzing whether you need to use this type of architecture for
    your project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先分析一下你是否需要为你的项目使用这种类型的架构。
- en: When to use a micro frontend
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用微前端
- en: A big but very true cliché in systems architecture is that there is no silver
    bullet – that is, there is no one-size-fits-all solution for all problems – and
    micro frontends cannot escape this cliché. The main advantage of this architecture,
    before any technical aspect, is its organizational aspect.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统架构中有一个大但非常真实的陈词滥调，那就是没有银弹——也就是说，没有一种适合所有问题的万能解决方案——微前端也无法摆脱这个陈词滥调。这种架构的主要优势，在技术方面之前，是其组织方面的优势。
- en: When we use the micro frontend, we are separating an independent part focused
    on one aspect of the business that will be handled by a team specializing in that
    aspect. With this, your project can scale across different teams dealing with
    specific subjects that will be integrated into an experience for your user. Each
    team has autonomy in the delivery cycle of this project, with independence from
    build, deployment, and testing. Independence can reach a level where teams can
    work with different versions of Angular and even different frameworks such as
    React and Vue, although this is not highly recommended, as we will discuss in
    the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用微前端时，我们正在分离一个专注于业务某一方面的独立部分，这部分将由专注于该方面的团队处理。通过这种方式，你的项目可以跨不同团队扩展，这些团队处理特定主题，并将它们整合成用户的体验。每个团队在这个项目的交付周期中都有自主权，与构建、部署和测试独立。独立性可以达到一个水平，即团队可以与不同的Angular版本甚至不同的框架（如React和Vue）一起工作，尽管这并不高度推荐，我们将在下一节讨论这一点。
- en: When not to use a micro frontend project
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时不使用微前端项目
- en: Another software engineering cliché is that there is no free lunch, and choosing
    to use micro frontends has its costs and challenges.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个软件工程陈词滥调是没有免费的午餐，选择使用微前端有其成本和挑战。
- en: The first challenge is the performance issue of your frontend. As we saw in
    [*Chapter 1*](B19562_01.xhtml#_idTextAnchor017), *Starting Projects the Right
    Way*, in a **single-page application** (**SPA**), the user’s browser downloads
    the application bundle containing the Angular framework code, in addition to the
    code that your team produced. After this download, the browser interprets the
    bundle and renders the pages for the user. This entire process must be as quick
    and efficient as possible because, while it is occurring, the user cannot interact
    with the screen, causing frustration.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个挑战是前端性能问题。正如我们在[*第一章*](B19562_01.xhtml#_idTextAnchor017)，“正确开始项目”中看到的，在**单页应用**（**SPA**）中，用户的浏览器下载包含Angular框架代码的应用程序包，以及你的团队生产的代码。在这之后，浏览器解释这个包并为用户渲染页面。这个整个过程必须尽可能快和高效，因为在这个过程中，用户无法与屏幕交互，这会导致挫败感。
- en: Now imagine this process happening in every part of your system because, to
    guarantee version and even framework independence, each micro frontend carries
    its framework engine in the specific version. There are techniques and tools such
    as webpack’s module federation ([https://webpack.js.org/concepts/module-federation/](https://webpack.js.org/concepts/module-federation/)),
    but you and your team must evaluate this challenge.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象这个过程发生在你系统的每一个部分，因为为了保证版本和甚至框架的独立性，每个微前端都携带其特定版本的框架引擎。有像webpack的模块联邦（[https://webpack.js.org/concepts/module-federation/](https://webpack.js.org/concepts/module-federation/））这样的技术和工具，但你和你的团队必须评估这个挑战。
- en: Another care we must take is concerning the user experience and the design of
    the components on screen because, for them, the components between interfaces
    must be fundamentally the same to guarantee cohesion in their experience.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须关注的另一个问题是关于用户体验和屏幕上组件的设计，因为对于它们来说，界面之间的组件必须本质上相同，以保证他们在体验中的连贯性。
- en: This challenge can be overcome by implementing a design system – that is, a
    single design guide for your company’s components, preferably with a library that
    supports it. An example of a design system is Google’s Material Design.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施设计系统——即你公司组件的单个设计指南，最好有一个支持它的库——可以克服这个挑战。设计系统的一个例子是谷歌的Material Design。
- en: Now that we have a basic understanding of micro frontends, let’s move on to
    the next section, where we will explore how to split our application into micro
    frontends.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对微前端有了基本的了解，让我们继续到下一节，我们将探讨如何将我们的应用程序拆分为微前端。
- en: Slicing your application into micro frontends
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的应用程序拆分为微前端
- en: To maximize gains from the micro frontend architecture and minimize the risks
    defined in the previous section, we need to create microservices that are as independent
    as possible and that make sense for your team’s organization.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大限度地从微前端架构中获得收益并最小化前一部分定义的风险，我们需要创建尽可能独立且对团队组织有意义的微服务。
- en: The most common type of project organization is the verticalization of functionalities
    – that is, for one project you might have an entire user journey, such as a product
    purchase screen, another project for product registration, and another for the
    administration module of the application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的项目组织类型是功能垂直化 – 也就是说，对于一个项目，你可能有一个完整的用户旅程，例如产品购买屏幕，另一个项目用于产品注册，另一个用于应用的管理模块。
- en: '![Figure 11.1 – Micro frontend division](img/B19562_11_1.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 微前端划分](img/B19562_11_1.jpg)'
- en: Figure 11.1 – Micro frontend division
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 微前端划分
- en: This diagram exemplifies the concept of division using an Angular application.
    In each project, we have all the components for the user experience.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此图使用Angular应用程序展示了划分的概念。在每一个项目中，我们都有用户体验的所有组件。
- en: You may be wondering, “*Can I achieve this same separation using Angular modules?*”
    and the answer is yes, you can. If a team takes care of all the modules for your
    company’s organization or the teams can organize themselves into just one project,
    you can (and even should) do this.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“*我能否使用Angular模块实现这种相同的分离？*”答案是肯定的，你可以。如果一个团队负责你公司组织的所有模块，或者团队可以组织成只有一个项目，那么你可以（甚至应该）这样做。
- en: We need to keep in mind that the reason for dividing your project into micro
    frontends is to meet an organizational requirement of your project, and teams
    want to have deployment and development independence.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，将你的项目划分为微前端的原因是为了满足项目的一个组织需求，并且团队希望拥有部署和开发的独立性。
- en: With the basic concepts in mind, we will exemplify how to implement them in
    our gym diary project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记基本概念后，我们将展示如何在我们的健身日记项目中实现它们。
- en: Creating a micro frontend application with standalone components
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用独立组件创建微前端应用程序
- en: 'To exemplify the use of the micro frontend architecture in our gym diary, we
    will create a form to define new exercises for our users. Let’s create another
    Angular project, simulating a new team that will specifically take care of this
    functionality. In your operating system’s command line, use the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的健身日记中展示微前端架构的使用，我们将创建一个表单来定义用户的新练习。让我们创建另一个Angular项目，模拟一个专门负责这个功能的团队。在你的操作系统命令行中，使用以下命令：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We learned about the `ng new` command in [*Chapter 1*](B19562_01.xhtml#_idTextAnchor017),
    *Starting Projects the Right Way*, but here we are using some parameters that
    we haven’t seen before. We are using the `skip-git` parameter because, in this
    example, we are creating it in the same Git project (which already has the `gym-diary`
    and `gym-backend` projects). The `routing` parameter is set to `false` because
    our project will be loaded in the diary application route, and the `style` parameter
    is set to `CSS` so the Angular CLI does not need to ask what type of styling our
    project will have.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第一章*](B19562_01.xhtml#_idTextAnchor017)，“正确开始项目”，学习了`ng new`命令，但在这里我们使用了一些之前没有见过的参数。我们使用`skip-git`参数是因为，在这个例子中，我们是在同一个Git项目中创建的（该项目中已经包含了`gym-diary`和`gym-backend`项目）。`routing`参数设置为`false`，因为我们的项目将在日记应用的路由中加载，`style`参数设置为`CSS`，这样Angular
    CLI就不需要询问我们的项目将有什么类型的样式。
- en: The biggest difference in this command is `standalone`, which parameterized
    our project to create all components as standalone by default. But you might be
    wondering what a `standalone` component is. Created from version 15 of Angular,
    this feature allows you to create a component without using Angular modules (`NgModule`).
    Although modules are very important, as we saw in [*Chapter 2*](B19562_02.xhtml#_idTextAnchor081),
    *Organizing Your Application*, there are cases in which they are not very useful
    and make the project unnecessarily complicated. A good example of this is in small
    projects with a limited scope, such as this micro frontend, where we will not
    have multiple routes or lazy loading.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令中最大的区别是`standalone`参数，它将我们的项目参数化，默认创建所有组件为独立组件。但你可能想知道什么是`standalone`组件。从Angular的15版本开始创建，这个特性允许你创建一个组件而不使用Angular模块（`NgModule`）。尽管模块非常重要，正如我们在[*第二章*](B19562_02.xhtml#_idTextAnchor081)中看到的，*组织你的应用程序*，但在某些情况下它们并不非常有用，并且会使项目变得不必要地复杂。一个很好的例子是范围有限的小项目，例如这个微前端，我们将不会有多个路由或懒加载。
- en: 'Before we start creating the exercise form, let’s add and configure the Tailwind
    CSS framework, as we want to have a style compatible with our main application.
    Inside the created project folder, run the following command from the command
    line of your operating system:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建练习表单之前，让我们添加并配置Tailwind CSS框架，因为我们希望有一个与我们的主应用程序兼容的样式。在创建的项目文件夹中，从你的操作系统的命令行运行以下命令：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will add development dependencies to the project and create configuration
    files in the Tailwind CSS framework.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将向项目添加开发依赖项，并在Tailwind CSS框架中创建配置文件。
- en: 'In the `tailwind.config.js` file, make the following changes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tailwind.config.js`文件中，进行以下更改：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this file, we are telling Angular that it will apply the Tailwind CSS framework
    to all HTML files in the `src` folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们正在告诉Angular将Tailwind CSS框架应用于`src`文件夹中的所有HTML文件。
- en: 'Finally, add the following lines of code to the `app.component.css` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下代码行添加到`app.component.css`文件中：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With these CSS variables, the component will have access to the `tailwindcss`
    class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些CSS变量，组件将能够访问`tailwindcss`类。
- en: 'We will then create a service that will be responsible for interacting with
    our backend’s exercise API. On the command line, we will use the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个服务，该服务将负责与我们的后端练习API交互。在命令行中，我们将使用以下命令：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note a detail of our architecture: we already have a service that queries the
    exercise API in our main project, but we cannot reuse it here because they are
    independent projects, and certain code duplication is a cost of this architecture.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们架构的一个细节：我们已经在主项目中有一个查询练习API的服务，但在这里我们不能重用它，因为它们是独立的项目，并且某些代码重复是这个架构的成本。
- en: 'Following the best practices, we will create our API as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按照最佳实践，我们将创建我们的API如下：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we are recreating the types that represent the API data. For more details
    about TypeScript interfaces, you can consult [*Chapter 3*](B19562_03.xhtml#_idTextAnchor112),
    *TypeScript Patterns* *for Angular*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在重新创建表示API数据的类型。有关TypeScript接口的更多详细信息，你可以查阅[*第三章*](B19562_03.xhtml#_idTextAnchor112)，*TypeScript模式*
    *for Angular*。
- en: 'In the created service, we will add interaction with the backend:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建的服务中，我们将添加与后端的交互：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the service, we are making HTTP requests to consult exercises and add new
    ones. For more details about Angular services, you can consult [*Chapter 5*](B19562_05.xhtml#_idTextAnchor163),
    *Angular Services and the Singleton Pattern*, and [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242),
    *Exploring Reactivity* *with RxJS*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务中，我们正在通过HTTP请求查询练习并添加新的练习。有关Angular服务的更多详细信息，你可以查阅[*第五章*](B19562_05.xhtml#_idTextAnchor163)，*Angular服务和Singleton模式*，以及[*第九章*](B19562_09.xhtml#_idTextAnchor242)，*使用RxJS探索响应性*。
- en: However, we are experiencing an error because we are not importing the `HttpClientModule`
    module. But how can we import it if we don’t have a module in a standalone component?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们遇到了一个错误，因为我们没有导入`HttpClientModule`模块。但如果没有模块在独立组件中，我们如何导入它呢？
- en: 'In a project without modules, the import happens in the component itself; for
    services, we have the `app.config.ts` file, and we will add the import to it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有模块的项目中，导入发生在组件本身中；对于服务，我们有`app.config.ts`文件，我们将将其添加到其中：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we are importing the `provideHttpClient` provider and not the module.
    This happens because this provider was created by the Angular team to handle these
    standalone application cases.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们导入的是`provideHttpClient`提供者而不是模块。这是因为这个提供者是由Angular团队创建的，用于处理这些独立应用程序的情况。
- en: 'In the main components of the application, we will code its behavior as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的主要组件中，我们将按照以下方式编写其行为：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s first highlight the component configuration in the `@Component` decorator
    metadata. The `standalone` property means that this component can be used directly
    without being declared in any module. In the `imports` property, we declare its
    dependencies, which are `CommonModule`, the basis for any Angular component, and
    `ReactiveFormsModule`, as we will be developing a reactive form (for more details
    about the form, read [*Chapter 6*](B19562_06.xhtml#_idTextAnchor186), *Handling
    User Input: Forms*). In the component, we are injecting `NonNullableFormBuilder`
    and `ExercisesService` and we take the initial list and assign it to the `exerciseList$`
    attribute. We create the form object with the `formBuilder` service, and finally,
    we create the `newExercise` method responsible for the **Submit** button.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先强调`@Component`装饰器元数据中的组件配置。`standalone`属性表示该组件可以直接使用，而无需在任何模块中声明。在`imports`属性中，我们声明其依赖项，这些依赖项是`CommonModule`，它是任何Angular组件的基础，以及`ReactiveFormsModule`，因为我们将会开发一个响应式表单（更多关于表单的详情，请参阅[*第6章*](B19562_06.xhtml#_idTextAnchor186)，*处理用户输入：表单*）。在组件中，我们注入`NonNullableFormBuilder`和`ExercisesService`，并将初始列表分配给`exerciseList$`属性。我们使用`formBuilder`服务创建表单对象，并最终创建负责**提交**按钮的`newExercise`方法。
- en: As we will have the list of exercises in the same form, in the `subscribe` method,
    we assign the `exerciseList$` attribute again to refresh the list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将有相同的表单中的练习列表，在`subscribe`方法中，我们再次将`exerciseList$`属性分配给刷新列表。
- en: 'To finish the component, let’s create its template as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成组件，让我们创建其模板如下：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the first part, we have the list of exercises, and here we are using Angular’s
    `async` pipe to subscribe and search the list (for more details, read [*Chapter
    9*](B19562_09.xhtml#_idTextAnchor242), *Exploring Reactivity* *with RxJS*).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们有练习列表，这里我们使用Angular的`async`管道来订阅和搜索列表（更多详情，请参阅[*第9章*](B19562_09.xhtml#_idTextAnchor242)，*使用RxJS探索反应性*）。
- en: 'In the same template file, we will add the form:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的模板文件中，我们将添加表单：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We created a reactive form with just the **Description** field and added simple
    validation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅使用**描述**字段创建了一个响应式表单，并添加了简单的验证。
- en: 'By running our application with the `ng serve` command, we will have the following
    interface:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ng serve`命令运行我们的应用程序，我们将拥有以下界面：
- en: '![Figure 11.2 – Exercise form](img/B19562_11_2.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 练习表单](img/B19562_11_2.jpg)'
- en: Figure 11.2 – Exercise form
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 练习表单
- en: With our micro frontend project ready, we can prepare it to be consumed by our
    main application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的微前端项目准备就绪后，我们可以准备它以便被我们的主应用程序消费。
- en: Preparing a page to be loaded by the base application
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备一个页面以便由基础应用程序加载
- en: With our micro frontend project ready, we need to prepare it to be consumed
    by another application. There are several ways to share micro frontends, from
    the simplest (and obsolete), with the use of iframes, to more modern, but complex,
    solutions such as module federation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的微前端项目准备就绪后，我们需要准备它以便被另一个应用程序消费。共享微前端有多种方式，从最简单（且已过时）的通过使用iframe，到更现代但复杂的解决方案，如模块联邦。
- en: In this section, we will use an approach widely used in the market, which is
    the use of Web Components. Web Components is a specification that aims to standardize
    components created by different frameworks into a model that can be consumed between
    them. In other words, by creating an Angular component following this specification,
    an application created in React or Vue could consume this component. Although
    Web Components was not created with micro frontend projects in mind, we can see
    that its definition fits perfectly for what we need.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用市场上广泛使用的方法，即使用Web Components。Web Components是一个旨在将不同框架创建的组件标准化为可以在它们之间消费的模型的规范。换句话说，通过遵循此规范创建一个Angular组件，React或Vue创建的应用程序可以消费此组件。尽管Web
    Components并非专为微前端项目而创建，但我们可以看到其定义完美地符合我们的需求。
- en: 'Like almost everything in the Angular framework, to create this type of component,
    we don’t need to do it manually, as the Angular team created a tool for this:
    Angular elements. An Angular element component is a common component but *transpiled*
    to the Web Components standard, packaging not only our code but also the Angular
    rendering engine, making it framework agnostic.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Angular框架中的几乎所有内容一样，为了创建这种类型的组件，我们不需要手动操作，因为Angular团队为此创建了一个工具：Angular elements。一个Angular元素组件是一个通用组件，但被*转换*为Web
    Components标准，不仅打包我们的代码，还打包Angular渲染引擎，使其框架无关。
- en: 'Let’s add it to our `gym_exercises` project on the command line of our operating
    system with the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在操作系统的命令行上使用以下命令将其添加到我们的`gym_exercises`项目中：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the preceding command, we add the `angular/elements` dependency to our
    project, and to use it, we will make a change to the `angular.json` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们将`angular/elements`依赖项添加到我们的项目中，并且为了使用它，我们将对`angular.json`文件进行修改：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The component generated by Angular elements will encapsulate the Tailwind CSS
    framework, so we need to increase the component size budget a little to avoid
    errors when building the project.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由Angular elements生成的组件将封装Tailwind CSS框架，因此我们需要稍微增加组件大小预算，以避免在构建项目时出现错误。
- en: 'The next change we must make is to the project’s `main.ts` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须进行的下一个更改是项目的`main.ts`文件：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This file is responsible for configuring the initialization of an Angular project,
    and we normally do not change it as we want standard SPA build and execution behavior.
    However, here, we need to change it to inform Angular that the result of this
    project will be a web component generated by the Angular elements package. Here,
    we are configuring the project so that the application will generate a web component
    whose tag name will be `exercise-form`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件负责配置Angular项目的初始化，我们通常不会更改它，因为我们想要标准的SPA构建和执行行为。然而，在这里，我们需要将其更改以通知Angular，此项目的结果是Angular
    elements包生成的Web组件。在这里，我们正在配置项目，以便应用程序生成一个标签名为`exercise-form`的Web组件。
- en: 'We now need to change the `index.html` file to understand this new tag so that
    we can render our micro frontend for testing:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改`index.html`文件来理解这个新标签，这样我们就可以渲染我们的微前端进行测试：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we change the default `<app-root>` Angular component with the Web Components
    `<exercise-form> tag`. Our main application will be our micro frontend JavaScript,
    but the change to `index.html` will allow you and your team to maintain the micro
    frontend without needing to load the main project.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将默认的`<app-root>`Angular组件替换为Web Components的`<exercise-form>`标签。我们的主要应用程序将是我们的微前端JavaScript，但修改`index.html`将允许你和你的团队在不加载主项目的情况下维护微前端。
- en: 'We now have a challenge in that, despite creating a web component, the project
    build is creating it in three files and with hashes, which is correct if our application
    is not a micro frontend, but in our case, we would like to have all the code in
    a single file and without the hash. We can do this manually, but the community
    has a package that automates this treatment: the `ngx-build-plus` package.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在面临一个挑战，尽管我们创建了一个Web组件，但项目构建却在三个文件和哈希中创建它，如果我们的应用程序不是微前端，这是正确的，但就我们而言，我们希望所有代码都在一个文件中，并且没有哈希。我们可以手动完成这项工作，但社区有一个包可以自动化这种处理：`ngx-build-plus`包。
- en: 'Let’s add it to the command line with the help of the Angular CLI:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助Angular CLI将其添加到命令行：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To serve this micro frontend, we will use the `http-server` package, and add
    it with `npm` on the command line:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这个微前端，我们将使用`http-server`包，并在命令行上使用`npm`添加它：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, let’s create some `npm` scripts to make running `mfe` easier. In the
    `package.json` file, we will make the following change:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一些`npm`脚本来使运行`mfe`更加容易。在`package.json`文件中，我们将进行以下修改：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `build` script, we specify our intention to run it, resulting in a single
    generated file (`--single-bundle`). We also instruct it to retain and encapsulate
    the CSS (`--bundle-styles --keep-styles`) while ensuring that the generated file’s
    name does not include any type of hash (`--output-hashing=none`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build`脚本中，我们指定了运行它的意图，从而生成一个单独的文件（`--single-bundle`）。我们还指示它保留并封装CSS（`--bundle-styles
    --keep-styles`），同时确保生成的文件名不包含任何类型的哈希（`--output-hashing=none`）。
- en: The `serve-mfe` script uses the `http-server` service to publish the contents
    of the `dist` folder that will contain the compiled micro frontend.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`serve-mfe`脚本使用`http-server`服务发布包含编译后的微前端的`dist`文件夹的内容。'
- en: 'Let’s run our project with the following command and check the micro frontend
    we created:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行我们的项目并检查我们创建的微前端：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By accessing `http://127.0.0.1:8080`, we can see that our micro frontend application
    is being generated successfully.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问`http://127.0.0.1:8080`，我们可以看到我们的微前端应用程序正在成功生成。
- en: With our micro frontend ready to be consumed, in the next section, we will consume
    it in the main application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的微前端准备就绪，可以供消费，在下一节中，我们将在主应用程序中消费它。
- en: Dynamically loading micro frontends
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态加载微前端
- en: 'Let’s prepare our main application gym diary to consume the micro frontend
    that we prepared previously. To do this, let’s start by creating a new module
    in the application. On the command line, we will use the following Angular CLI
    commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备我们的主应用程序健身日记以消费我们之前准备的微前端。为此，让我们首先在应用程序中创建一个新的模块。在命令行中，我们将使用以下Angular CLI命令：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the preceding commands, we create the module with the generated route file
    and a component that will be responsible for loading `mfe`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们创建了一个包含生成的路由文件和负责加载`mfe`的组件的模块。
- en: 'Let’s adjust the `exercise-routing.module.ts` file to target the component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整`exercise-routing.module.ts`文件以指向组件：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `routes` array, we define a base route for the exercise registration
    component as it will be loaded via lazy loading.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes`数组中，我们定义了一个基础路由，用于练习注册组件，因为它将通过懒加载加载。
- en: 'Next, we will refactor the `home-routing.module.ts` file as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重构`home-routing.module.ts`文件如下：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our `HomePage` module contains the menu, and in this section, we are adding
    the new module to be loaded in the correct area of the interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`HomePage`模块包含菜单，在本节中，我们正在将新模块添加到界面的正确区域。
- en: 'To finish adding this new module, let’s change the `home.component.html` file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成添加此新模块，让我们更改`home.component.html`文件：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the new menu item added to the `home` template, we now have the task of
    including the micro frontend generated in the other project in our interface.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home`模板中添加了新的菜单项后，我们现在有任务将其他项目中生成的微前端包含到我们的界面中。
- en: 'For this, we have a community package called `@angular-extensions` that allows
    us to load our micro frontend simply using a directive, as we will see later.
    But first, let’s install this dependency in our project using the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们有一个名为`@angular-extensions`的社区包，它允许我们通过指令简单地加载我们的微前端，正如我们稍后将会看到的。但首先，让我们使用以下命令在我们的项目中安装这个依赖项：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once installed, we can change the `ExerciseModule` module:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以更改`ExerciseModule`模块：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this file, we are first adding the library module called `LazyElementsModule`
    to have access to the directive that we will use in the component. Furthermore,
    we have a new property in the metadata called `schemas`. In it, we are informing
    Angular with the `CUSTOM_ELEMENTS_SCHEMA` token that this module will receive
    elements from outside the project. By default, Angular checks whether the tag
    used in the template exists in the project or in the HTML standard, such as the
    `input` tag.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们首先添加了一个名为`LazyElementsModule`的库模块，以便访问我们将在组件中使用的指令。此外，我们在元数据中有一个新的属性`schemas`。在其中，我们通过`CUSTOM_ELEMENTS_SCHEMA`令牌通知Angular，此模块将接收来自项目外部的元素。默认情况下，Angular会检查模板中使用的标签是否存在于项目中或在HTML标准中，例如`input`标签。
- en: As we are going to import the `exercise-form` tag defined by our micro frontend
    here, this attribute will prevent Angular from carrying out this check at the
    project compile time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里将导入由我们的微前端定义的`exercise-form`标签，此属性将防止Angular在项目编译时执行此检查。
- en: 'In the `exercise.component.ts` file, we will add a new attribute:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`exercise.component.ts`文件中，我们将添加一个新属性：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we are defining the address where the micro frontend’s main files will
    be served.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了微前端主文件将被提供的服务地址。
- en: 'Finally, let’s change the component template:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更改组件模板：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we are declaring the new `exercise-form` element, and to load it, we use
    the `axLazyElement` directive assigning the micro frontend address.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了新的`exercise-form`元素，为了加载它，我们使用`axLazyElement`指令分配微前端地址。
- en: 'To run our project, make sure the micro frontend is being served with the `npm
    run serve-mfe` command. With everything configured, we can see the result of our
    work:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的项目，请确保微前端正在使用`npm run serve-mfe`命令提供服务。一切配置完成后，我们可以看到我们工作的结果：
- en: '![](img/B19562_11_3.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![img/B19562_11_3.jpg](img/B19562_11_3.jpg)'
- en: Figure 11.3 – Exercise form dynamically loaded into the main application
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 动态加载到主应用程序中的练习表单
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the architecture of micro frontends and how to
    apply one to an Angular project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了微前端架构以及如何将其应用于Angular项目。
- en: We learned about the concept of the architecture, its advantages, and its trade-offs.
    We explored how the main reason for opting for this architecture is its flexibility
    in relation to the organizational structure of each team, as several teams can
    work on different parts of the frontend project independently.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了架构的概念、其优势及其权衡。我们探讨了选择这种架构的主要原因是其与每个团队组织结构的灵活性，因为几个团队可以独立地工作在前端项目的不同部分。
- en: We also learned how we can ideally divide our application into micro frontends.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何理想地将我们的应用程序划分为微前端。
- en: With all these concepts, we applied our project by creating a small application
    using Angular’s standalone components feature and preparing it to be loaded by
    another project using the Angular elements library.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些概念的基础上，我们通过创建一个小型应用程序并利用Angular的独立组件功能，以及准备使用Angular元素库加载它，来应用我们的项目。
- en: Finally, we performed dynamic loading in our main application with the help
    of the `@``angular-extensions/elements` library.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在主应用程序中借助`@angular-extensions/elements`库实现了动态加载。
- en: In the next chapter, we will explore the best practices for deploying an Angular
    application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨部署Angular应用程序的最佳实践。
