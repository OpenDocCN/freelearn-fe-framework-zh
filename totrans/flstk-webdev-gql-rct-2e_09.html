<html><head></head><body>
		<div id="_idContainer062">
			<h1 id="_idParaDest-131"><em class="italic"><a id="_idTextAnchor154"/>Chapter 7</em>: Handling Image Uploads</h1>
			<p>All social networks have one thing in common: each of them allows its users to upload custom and personal pictures, videos, or any other kind of document. This feature can take place inside chats, posts, groups, or profiles. To offer the same functionality, we are going to implement an image upload feature in Graphbook.</p>
			<p>This chapter will cover the following topics:</p>
			<ul>
				<li>Setting up Amazon Web Services</li>
				<li>Configuring an AWS S3<strong class="bold"> </strong>bucket</li>
				<li>Accepting file uploads on the server</li>
				<li>Uploading images with React through Apollo</li>
				<li>Cropping images</li>
			</ul>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor155"/>Technical requirements</h1>
			<p>The source code for this chapter is available in the following GitHub repository: </p>
			<p><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter07">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter07</a></p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor156"/>Setting up Amazon Web Services</h1>
			<p>First, I have to <a id="_idIndexMarker591"/>mention that Amazon—or, to be specific, <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>)—is not the only provider of hosting, storage, or computing systems. There are many such providers, including the following:</p>
			<ul>
				<li>Heroku</li>
				<li>DigitalOcean</li>
				<li>Google Cloud</li>
				<li>Microsoft Azure</li>
			</ul>
			<p>AWS offers everything that you need to run a full-fledged web application, as with all the other providers. Furthermore, it is also widely used, which is why we are focusing on AWS for this book.</p>
			<p>Its services span from databases to object storage, to security services, and so much more. Besides, AWS <a id="_idIndexMarker592"/>is the go-to solution that you will find in most other books and tutorials, and many big companies use it to power their complete infrastructure. </p>
			<p>This book uses AWS for serving static files, such as images, to run the production database and the Docker container for our application.</p>
			<p>Before continuing with this chapter, you will be required to have an account for AWS. You can create one on<a id="_idIndexMarker593"/> the official web page at <a href="https://aws.amazon.com/">https://aws.amazon.com/</a>. For this, you will need a valid credit card; you can also run nearly all of the services on the Free Tier while working through this book without facing any problems.</p>
			<p>Once you have<a id="_idIndexMarker594"/> successfully registered for AWS, you will see the following dashboard. This<a id="_idIndexMarker595"/> screen is called the <strong class="bold">AWS Management Console</strong>:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_7.01_B17337.jpg" alt="Figure 7.1 – AWS Management Console&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – AWS Management Console</p>
			<p>The next section will cover the options for storing files with AWS.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor157"/>Configuring an AWS S3 bucket</h2>
			<p>For this chapter, we <a id="_idIndexMarker596"/>will require a storage service to save all uploaded images. AWS provides different storage types for various use cases. In our scenario of a social network, we will have dozens of people accessing many images at once. <strong class="bold">AWS Simple Storage Service</strong> (<strong class="bold">S3</strong>) is the best option for our scenario. Follow these steps to set up an S3 bucket:</p>
			<ol>
				<li>You can visit the <strong class="bold">Amazon S3</strong> screen by clicking on the <strong class="bold">Services</strong> drop-down menu at the top of the page, and then looking under the <strong class="bold">Storage</strong> category in the drop-down menu. There, you will find a link to S3. Having clicked on it, the screen will look like this:<div id="_idContainer054" class="IMG---Figure"><img src="image/Figure_7.02_B17337.jpg" alt="Figure 7.2 – S3 management screen&#13;&#10;"/></div><p class="figure-caption">Figure 7.2 – S3 management screen</p><p>In S3, you create a bucket inside of a specific AWS region, where you can store files.</p><p>The preceding <a id="_idIndexMarker597"/>screen provides many features for interacting with your S3 bucket. You can browse all of the files, upload your files via the management interface, and configure more settings.</p></li>
				<li>We will now create a new bucket for our project by clicking on <strong class="bold">Create bucket</strong> in the upper-right corner, as shown in <em class="italic">Figure 7.2</em>. You will be presented with a form, as shown in the following screenshot. To create a bucket, you must fill it out:</li>
			</ol>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_7.03_B17337.jpg" alt="Figure 7.3 – S3 bucket wizard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – S3 bucket wizard</p>
			<p>The bucket has to <a id="_idIndexMarker598"/>have a unique name across all buckets in S3. Then, we need to pick a region. For me, <strong class="bold">EU (Frankfurt) eu-central-1</strong> is the best choice, as it is the nearest origin point. Choose the best option for you, since the performance of a bucket corresponds to the distance between the region of the bucket and its accessor.</p>
			<p>Then, you need to uncheck the <strong class="bold">Block all public access</strong> option and also check the acknowledgment with the warning sign. AWS shows us this warning because we should only give public access to S3 buckets when really required. It should look like this: </p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_7.04_B17337.jpg" alt="Figure 7.4 – S3 bucket access&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – S3 bucket access</p>
			<p>For our use case, we can<a id="_idIndexMarker599"/> stay with the default settings provided for all the other options in this form wizard. The other options can be helpful in more advanced scenarios. AWS offers many features, such as a complete access log and versioning. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Many bigger companies have users across the globe, which requires a highly available application. When you reach this point, you can create many more S3 buckets in other regions, and you can set up the replication of one bucket to others living in various regions around the world. The correct bucket can then be distributed with AWS CloudFront and a router specific to each user. This approach gives every user the best possible experience.</p>
			<p>Finish the setup<a id="_idIndexMarker600"/> process by clicking on <strong class="bold">Create bucket</strong> at the bottom of the page. You will be redirected back to the table view for all buckets.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor158"/>Generating AWS access keys</h2>
			<p>Before<a id="_idIndexMarker601"/> implementing the upload feature, we must create an AWS <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) key<a id="_idIndexMarker602"/> to authorize our backend at AWS, in order to upload new files to the S3 bucket.</p>
			<p>Click on your username in the top bar of the AWS management screen. There, you will find a tab called <strong class="bold">My Security Credentials</strong>, which navigates to a screen offering various options to secure access to your AWS account.</p>
			<p>You will be confronted with a dialog box like this:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_7.05_B17337.jpg" alt="Figure 7.5 – S3 Identity and Access Management (IAM) dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – S3 Identity and Access Management (IAM) dialog</p>
			<p>You can click on <strong class="bold">Continue to Security Credentials</strong> to continue. It is generally recommended to use AWS IAM, which allows you to efficiently manage secure access to AWS resources with separate IAM users. Throughout this book, we are going to use the root user in the same way that we are now, but I recommend looking at AWS IAM when writing your next application.</p>
			<p>You should now see the credentials page, with a big list of different methods for storing credentials. This is how it should look:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_7.06_B17337.jpg" alt="Figure 7.6 – AWS access keys&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – AWS access keys</p>
			<p>In the list, expand <a id="_idIndexMarker603"/>the tab titled <strong class="bold">Access keys (access key ID and secret access key)</strong> shown in the preceding screenshot. In this tab, you will find all access tokens for your AWS account.</p>
			<p>To generate a new access token, click on <strong class="bold">Create New Access Key</strong>. The output should look like this:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_7.07_B17337.jpg" alt="Figure 7.7 – AWS access key&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – AWS access key</p>
			<p>The best practice <a id="_idIndexMarker604"/>is to download the key file as prompted and save it somewhere securely, just in case you lose the key at any time. You cannot retrieve access keys again after closing the window, so if you lose them, you will have to delete the old key and generate a new one.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This approach is acceptable for explaining the basics of AWS. With such a huge platform, there are further steps that you have to take to secure your application even more. For example, it is recommended to renew API keys every 90 days. You can read more about all of the best <a id="_idIndexMarker605"/>practices at <a href="https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html">https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html</a>.</p>
			<p>As you can see in <em class="italic">Figure 7.7</em>, AWS gives us two tokens. Both are required to gain access to our S3 bucket.</p>
			<p>Now, we can start to program the uploading mechanism.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor159"/>Uploading images to Amazon S3</h1>
			<p>Implementing file <a id="_idIndexMarker606"/>uploads and storing files is always a huge task, especially <a id="_idIndexMarker607"/>for image uploads in which the user may want to edit their files again.</p>
			<p>For our frontend, the user should be able to drag and drop their image into a dropzone, crop the image, and then submit it when they are finished. The backend needs to accept file uploads in general, which is not easy at all. The files must be processed and then stored efficiently so that all users can access them quickly.</p>
			<p>As this is a vast topic, the chapter only covers the basic upload of images from React, using a<a id="_idIndexMarker608"/> multipart <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) <strong class="source-inline">POST</strong> request to our GraphQL API, and then transferring the image to our S3 bucket. When it comes to compressing, converting, and cropping, you should check out further tutorials or books on this topic, including techniques for implementing them in the frontend and backend, since there is a lot to think about. For example, in many applications, it makes sense to store images in various resolutions that will be shown to the users in different situations, in order to save bandwidth.</p>
			<p>Let's start by implementing the upload process on the backend.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor160"/>GraphQL image upload mutation</h2>
			<p>When uploading images<a id="_idIndexMarker609"/> to S3, it is required to use an API key, which we have <a id="_idIndexMarker610"/>already generated. Because of this, we cannot directly upload the files from the client to S3 with the API key. Anyone accessing our application could read out the API key from the JavaScript code and access our bucket without us knowing.</p>
			<p>Uploading images directly from the client into the bucket is generally possible, however. To do this, you would need to send the name and type of the file to the server, which would then <a id="_idIndexMarker611"/>generate a <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) and signature. The client can then use the signature to upload the image. This technique results in many round trips for the client and does not allow us to postprocess the image, such as by converting or compressing, if needed.</p>
			<p>A better solution is to upload the images to our server, have the GraphQL API accept the file, and then make another request to S3—including the API key—to store the file in our bucket.</p>
			<p>We have to prepare our backend to communicate with AWS and accept file uploads. The preparation steps are listed here:</p>
			<ol>
				<li value="1">We install the official <strong class="source-inline">npm</strong> package to interact with AWS. It provides everything that's needed to use any AWS feature, not just S3. Also, we install <strong class="source-inline">graphql-upload</strong>, which provides some tools to resolve the file from any GraphQL request. The code to do this is illustrated here:<p class="source-code"><strong class="bold">npm install --save aws-sdk graphql-upload</strong></p></li>
				<li>Inside the server <strong class="source-inline">index.js</strong> file, we need to add the initialization of the <strong class="source-inline">graphql-upload</strong> package. For that, import the Express dependency at the top, as follows:<p class="source-code">import { graphqlUploadExpress } from 'graphql-upload';</p></li>
				<li>Inside the <strong class="source-inline">graphql</strong> case at the end of the file, before executing the <strong class="source-inline">applyMiddleware</strong> function, we need to initiate it, as follows:<p class="source-code">case 'graphql':</p><p class="source-code">  (async () =&gt; {</p><p class="source-code">    await services[name].start();</p><p class="source-code">    app.use(graphqlUploadExpress());</p><p class="source-code">    services[name].applyMiddleware({ app });</p><p class="source-code">  })();</p><p class="source-code">  break;</p></li>
				<li>The next thing<a id="_idIndexMarker612"/> to do is edit the GraphQL schema <a id="_idIndexMarker613"/>and add an <strong class="source-inline">Upload</strong> scalar to the top of it. The scalar is used to resolve details such as the <strong class="bold">Multipurpose Internet Mail Extensions</strong> (<strong class="bold">MIME</strong>) type and<a id="_idIndexMarker614"/> encoding when uploading files. Here's the code you'll need:<p class="source-code">scalar Upload</p></li>
				<li>Add the <strong class="source-inline">File</strong> type to the schema. This type returns the filename and the resulting URL under which the image can be accessed in the browser. The code is illustrated in the following snippet:<p class="source-code">type File {</p><p class="source-code">  filename: String!</p><p class="source-code">  mimetype: String!</p><p class="source-code">  encoding: String!</p><p class="source-code">  url: String!</p><p class="source-code">}</p></li>
				<li>Create a new <strong class="source-inline">uploadAvatar</strong> mutation. The user needs to be logged in to upload avatar images, so append the <strong class="source-inline">@auth</strong> directive to the mutation. The mutation takes the previously mentioned <strong class="source-inline">Upload</strong> scalar as input. The code is illustrated in the following snippet:<p class="source-code">uploadAvatar (</p><p class="source-code">  file: Upload!</p><p class="source-code">): File @auth</p></li>
				<li>Next, we will<a id="_idIndexMarker615"/> implement the mutation's resolver function<a id="_idIndexMarker616"/> in the <strong class="source-inline">resolvers.js</strong> file. For this, we will import and set up our dependencies at the top of the <strong class="source-inline">resolvers.js</strong> file, as follows:<p class="source-code">import { GraphQLUpload } from 'graphql-upload';</p><p class="source-code">import aws from 'aws-sdk';</p><p class="source-code">const s3 = new aws.S3({</p><p class="source-code">  signatureVersion: 'v4',</p><p class="source-code">  region: 'eu-central-1',</p><p class="source-code">});</p><p>We will initialize the <strong class="source-inline">s3</strong> object that we will use to upload images in the next step. It is required to pass a <strong class="source-inline">region</strong> property as a property in which we created the S3 bucket. We set the <strong class="source-inline">signatureVersion</strong> property to version <strong class="source-inline">'v4'</strong> as this is recommended.</p><p class="callout-heading">Note</p><p class="callout">You can find details about the signature process<a id="_idIndexMarker617"/> of AWS requests at <a href="https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html</a>.</p></li>
				<li>Inside the <strong class="source-inline">r</strong><strong class="source-inline">esolvers.js</strong> file, we need to add one <strong class="source-inline">Upload</strong> resolver, as follows:<p class="source-code">Upload: GraphQLUpload</p></li>
				<li>Inside the <strong class="source-inline">mutation</strong> property, insert the <strong class="source-inline">uploadAvatar</strong> function, as follows:<p class="source-code">async uploadAvatar(root, { file }, context) {</p><p class="source-code">  const { createReadStream, filename, mimetype,</p><p class="source-code">    encoding } = await file;</p><p class="source-code">  const bucket = 'apollo-book';</p><p class="source-code">  const params = {</p><p class="source-code">      Bucket: bucket,</p><p class="source-code">      Key: context.user.id + '/' + filename,</p><p class="source-code">      ACL: 'public-read',</p><p class="source-code">      Body: createReadStream()</p><p class="source-code">  };</p><p class="source-code">  const response = await s3.upload(params).promise();</p><p class="source-code">  return User.update({</p><p class="source-code">      avatar: response.Location</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">      where: {</p><p class="source-code">          id: context.user.id</p><p class="source-code">      }</p><p class="source-code">  }).then(() =&gt; {</p><p class="source-code">      return {</p><p class="source-code">          filename: filename,</p><p class="source-code">          url: response.Location</p><p class="source-code">      }</p><p class="source-code">  });</p><p class="source-code">},</p></li>
			</ol>
			<p>In the preceding code snippet, we start by specifying the function as <strong class="source-inline">async</strong> so that we can use the <strong class="source-inline">await</strong> method to resolve the file and its details. The result of the resolved <strong class="source-inline">await file</strong> method consists of the <strong class="source-inline">stream</strong>, <strong class="source-inline">filename</strong>, <strong class="source-inline">mimetype</strong>, and <strong class="source-inline">encoding</strong> properties.</p>
			<p>Then, we collect the<a id="_idIndexMarker618"/> following parameters in the <strong class="source-inline">params</strong> variable, in <a id="_idIndexMarker619"/>order to upload our avatar image:</p>
			<ul>
				<li>The <strong class="source-inline">Bucket</strong> field holds the name of the bucket where we save the image. I took the name <strong class="source-inline">'apollo-book'</strong>, but you will need to enter the name that you entered during the creation of the bucket. You could have specified this directly inside of the <strong class="source-inline">s3</strong> object, but this approach is a bit more flexible since you can have multiple buckets for different file types, without the need for multiple <strong class="source-inline">s3</strong> objects.</li>
				<li>The <strong class="source-inline">Key</strong> property is the path and name under which the file is saved. Notice that we store the file under a new folder, which is just the user <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>) taken from the <strong class="source-inline">context</strong> variable. In a future application, you can introduce some kind of hash for every file. That would be good since the filename should not include characters that are not allowed. Furthermore, the files cannot be guessed programmatically when using a hash.</li>
				<li>The <strong class="source-inline">ACL</strong> field sets the permission for who can access the file. Since uploaded images on a social network are publicly viewable by anyone on the internet, we set the property to <strong class="source-inline">'public-read'</strong>.</li>
				<li>The <strong class="source-inline">Body</strong> field receives the <strong class="source-inline">stream</strong> variable, which we initially got by resolving the file. The <strong class="source-inline">stream</strong> variable is nothing more than the image itself as a stream, which we can directly upload into the bucket.</li>
			</ul>
			<p>The <strong class="source-inline">params</strong> variable is given to the <strong class="source-inline">s3.upload</strong> function, which saves the file to our bucket. We directly chain the <strong class="source-inline">promise</strong> function onto the <strong class="source-inline">upload</strong> method. In the preceding code snippet, we use the <strong class="source-inline">await</strong> statement to resolve the promise returned by the <strong class="source-inline">upload</strong> function. Therefore, we specified the function as <strong class="source-inline">async</strong>. The <strong class="source-inline">response</strong> object of the AWS S3 upload includes the public URL under which the image is accessible to everyone.</p>
			<p>The last step is to set the new avatar picture on the user in our database. We execute the <strong class="source-inline">User.update</strong> model function from Sequelize by setting the new URL from <strong class="source-inline">response.Location</strong>, which S3 gave us after we resolved the promise.</p>
			<p>An example link to an S3 image is provided here:</p>
			<p class="source-code">https://apollo-book.s3.eu-central-1.amazonaws.com/1/test.png</p>
			<p>As you can see, the URL is<a id="_idIndexMarker620"/> prefixed with the name of the bucket and then<a id="_idIndexMarker621"/> the region. The suffix is, of course, the folder, which is the user ID and the filename. The preceding URL will differ from the one that your backend generates because your bucket name and region will vary.</p>
			<p>After updating the user, we can return the AWS response to update the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) accordingly, without refreshing the browser window.</p>
			<p>In the previous section, we generated access tokens in order to authorize our backend at AWS. By default, the AWS <strong class="bold">software development kit</strong> (<strong class="bold">SDK</strong>) expects both tokens to be available in our environment variables. As we did before with <strong class="source-inline">JWT_SECRET</strong>, we will set the tokens, as follows:</p>
			<p class="source-code">export AWS_ACCESS_KEY_ID=YOUR_AWS_KEY_ID</p>
			<p class="source-code">export AWS_SECRET_ACCESS_KEY=YOUR_AWS_SECRET_KEY</p>
			<p>Insert your AWS tokens into the preceding code. The AWS SDK will detect both environment variables automatically. We do not need to read or configure them anywhere in our code.</p>
			<p>We will now continue and implement all of the image upload features in the frontend.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor161"/>React image cropping and uploading</h2>
			<p>In social networks such<a id="_idIndexMarker622"/> as Facebook, there are multiple locations where<a id="_idIndexMarker623"/> you can select and upload files. You can send images in chats, attach them to posts, create galleries in your profile, and much more. For now, we will only look at how to change our user's avatar image. This is a great example for easily showing all of the techniques. </p>
			<p>The result that we are targeting looks like this:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_7.08_B17337.jpg" alt="Figure 7.8 – Cropping dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – Cropping dialog</p>
			<p>The user <a id="_idIndexMarker624"/>can select a file, crop it directly in the modal, and save it to AWS with the <a id="_idIndexMarker625"/>preceding dialog.</p>
			<p>I am not a big fan of using too many <strong class="source-inline">npm</strong> packages, as this often makes your application unnecessarily big. As of the time of writing this book, we cannot write custom React components for everything, such as displaying a dialog or cropping, no matter how easy it might be.</p>
			<p>To get the image upload<a id="_idIndexMarker626"/> working, we will install two new packages. To do this, you<a id="_idIndexMarker627"/> can follow these instructions:</p>
			<ol>
				<li value="1">Install the packages with <strong class="source-inline">npm</strong>, as follows:<p class="source-code"><strong class="bold">npm install --save react-modal react-dropzone react-cropper</strong></p><p>The <strong class="source-inline">react-modal</strong> package offers various dialog options that you can use in many different situations. The <strong class="source-inline">react-cropper</strong> package is a wrapper package around <strong class="source-inline">Cropper.js</strong>. The <strong class="source-inline">react-dropzone</strong> package provides an easy implementation for file drop functionality.</p></li>
				<li>When using the <strong class="source-inline">react-cropper</strong> package, we can <a id="_idIndexMarker628"/>rely on its included <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>) package. In your main <strong class="source-inline">App.js</strong> file, import it straight from the package itself, as follows:<p class="source-code">import 'cropperjs/dist/cropper.css';</p><p>Webpack takes care of bundling all assets, as we are already doing with our custom CSS. The rest of the required CSS is available on the official GitHub repository of this book.</p></li>
				<li>The next package that we will install is an extension for Apollo Client, which will enable us to upload files, as follows:<p class="source-code"><strong class="bold">npm install --save apollo-upload-client</strong></p></li>
				<li>To get the <strong class="source-inline">apollo-upload-client</strong> package running, we have to edit the <strong class="source-inline">index.js</strong> file from the <strong class="source-inline">apollo</strong> folder where we initialize Apollo Client and all of its links. Import <a id="_idIndexMarker629"/>the <strong class="source-inline">createUploadLink</strong> function at the top of the <strong class="source-inline">index.js</strong> file, as <a id="_idIndexMarker630"/>follows:<p class="source-code">import { createUploadLink } from 'apollo-upload-client';</p></li>
				<li>You must replace the old <strong class="source-inline">HttpLink</strong> instance at the bottom of the link array with the new upload link. Instead of having a new <strong class="source-inline">HttpLink</strong>, we will now pass the <strong class="source-inline">createUploadLink</strong> function, but with the same parameters. When executing it, a regular link is returned. The link should look like this:<p class="source-code">createUploadLink({</p><p class="source-code">  uri: 'http://localhost:8000/graphql',</p><p class="source-code">  credentials: 'same-origin',</p><p class="source-code">}),</p><p>It is important to note that when we make use of the new upload link and send a file with a GraphQL request, we do not send the standard <strong class="source-inline">application/json</strong> <strong class="source-inline">Content-Type</strong> request, but instead send a multipart <strong class="source-inline">FormData</strong> request. This allows us to upload files with GraphQL. Standard <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) HTTP bodies, as we use with our GraphQL requests, cannot hold any <strong class="source-inline">file</strong> objects.</p><p class="callout-heading">Note</p><p class="callout">Alternatively, it is possible to send a <strong class="source-inline">base64</strong> string instead of a <strong class="source-inline">file</strong> object when transferring images. This procedure would save you from the work that we are doing right now, as sending and receiving strings is no problem with GraphQL. You have to convert the <strong class="source-inline">base64</strong> string to a file if you want to save it in AWS S3. This approach only works for images, however, and web applications should be able to accept any file type.</p></li>
				<li>Now that the<a id="_idIndexMarker631"/> packages are<a id="_idIndexMarker632"/> prepared, we can start to implement our <strong class="source-inline">uploadAvatar</strong> mutation component for the client. Create a new file called <strong class="source-inline">uploadAvatar.js</strong> in the <strong class="source-inline">mutations</strong> folder.</li>
				<li>At the top of the file, import all dependencies and parse all GraphQL requests with <strong class="source-inline">gql</strong> in the conventional way, as follows:<p class="source-code">import { gql, useMutation } from '@apollo/client';</p><p class="source-code">const UPLOAD_AVATAR = gql'</p><p class="source-code">  mutation uploadAvatar($file: Upload!) {</p><p class="source-code">    uploadAvatar(file : $file) {</p><p class="source-code">      filename</p><p class="source-code">      url</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">';</p><p class="source-code">export const getUploadAvatarConfig = () =&gt; ({</p><p class="source-code">  update(cache, { data: { uploadAvatar } }) {</p><p class="source-code">    console.log(uploadAvatar);</p><p class="source-code">    if(uploadAvatar &amp;&amp; uploadAvatar.url) {</p><p class="source-code">      cache.modify({</p><p class="source-code">        fields: {</p><p class="source-code">          currentUser(user, { readField }) {</p><p class="source-code">            cache.modify({</p><p class="source-code">              id: user,</p><p class="source-code">              fields: {</p><p class="source-code">                avatar() {</p><p class="source-code">                  return uploadAvatar.url;</p><p class="source-code">                }</p><p class="source-code">              }</p><p class="source-code">            })</p><p class="source-code">          }</p><p class="source-code">        }</p><p class="source-code">      });</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">});</p><p class="source-code">export const useUploadAvatarMutation = () =&gt; useMutation(UPLOAD_AVATAR, getUploadAvatarConfig());</p><p>As you can see, we have <a id="_idIndexMarker633"/>just exported the new mutation by<a id="_idIndexMarker634"/> wrapping the GraphQL query with the <strong class="source-inline">useMutation</strong> Hook. Also, we added an <strong class="source-inline">update</strong> function that will update the cache by first getting the reference for the current user and afterward updating this one user by reference to the new avatar URL.</p></li>
				<li>Lastly, we need to add the <strong class="source-inline">id</strong> property to the <strong class="source-inline">userAttributes</strong> fragment. Otherwise, the update of the avatar URL on the user reference would only be reflected on the top bar and not with all the posts. The code is illustrated in the following snippet:<p class="source-code">import { gql } from '@apollo/client';</p><p class="source-code">export const USER_ATTRIBUTES = gql'</p><p class="source-code">  fragment userAttributes on User {</p><p class="source-code">    id</p><p class="source-code">    username</p><p class="source-code">    avatar</p><p class="source-code">  }</p><p class="source-code">';</p></li>
			</ol>
			<p>The preparation is now complete. We have installed all of the required packages, configured them, and implemented the new mutation component. We can begin to program the user-facing dialog to change the avatar image.</p>
			<p>For the purposes of this book, we are not relying on separate pages or anything like that. Instead, we are giving the user the opportunity to change their avatar when they click on their image in the top bar. To do so, we are going to listen for the click event on the avatar, opening up a dialog that includes a file dropzone and a button to submit the new image.</p>
			<p>Execute the following steps to get this logic running:</p>
			<ol>
				<li value="1">It is always good to make your components as reusable as possible, so create an <strong class="source-inline">avatarModal.js</strong> file inside of the <strong class="source-inline">components</strong> folder.</li>
				<li>As always, you will<a id="_idIndexMarker635"/> have to import the new <strong class="source-inline">react-modal</strong>, <strong class="source-inline">react-cropper</strong>, and <strong class="source-inline">react-dropzone</strong> packages first and then the <a id="_idIndexMarker636"/>mutation, as follows:<p class="source-code">import React, { useState, useRef } from 'react';</p><p class="source-code">import Modal from 'react-modal';</p><p class="source-code">import Cropper from 'react-cropper';</p><p class="source-code">import { useDropzone } from 'react-dropzone';</p><p class="source-code">import { useUploadAvatarMutation } from '../apollo/mutations/uploadAvatar';</p><p class="source-code">Modal.setAppElement('#root');</p><p class="source-code">const modalStyle = {</p><p class="source-code">  content: {</p><p class="source-code">    width: '400px',</p><p class="source-code">    height: '450px',</p><p class="source-code">    top: '50%',</p><p class="source-code">    left: '50%',</p><p class="source-code">    right: 'auto',</p><p class="source-code">    bottom: 'auto',</p><p class="source-code">    marginRight: '-50%',</p><p class="source-code">    transform: 'translate(-50%, -50%)'</p><p class="source-code">  }</p><p class="source-code">};</p><p>As you can see in the preceding code snippet, we tell the modal package at which point in the<a id="_idIndexMarker637"/> browser's <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) we want to render the dialog, using the <strong class="source-inline">setAppElement</strong> method. For our use case, it is okay to take the <strong class="source-inline">root</strong> DOMNode, as this is the starting point of our application. The modal is instantiated in this DOMNode.</p><p>The modal component accepts a special <strong class="source-inline">style</strong> parameter for the different parts of the dropzone. We can style all parts of the modal by specifying the <strong class="source-inline">modalStyle</strong> object with the correct properties.</p></li>
				<li>The <strong class="source-inline">react-cropper</strong> package gives the user the opportunity to crop the image. The result is not a <strong class="source-inline">file</strong> or <strong class="source-inline">blob</strong> object, but a <strong class="source-inline">dataURI</strong> object, formatted as <strong class="source-inline">base64</strong>. Generally, this is not a problem, but our GraphQL API expects that we send a<a id="_idIndexMarker638"/> real file, not just a string, as we explained previously. Consequently, we have to convert the <strong class="source-inline">dataURI</strong> object to<a id="_idIndexMarker639"/> a blob that we can send with our GraphQL request. Add the following function to take care of the conversion:<p class="source-code">function dataURItoBlob(dataURI) {</p><p class="source-code">  var byteString = atob(dataURI.split(',')[1]);</p><p class="source-code">  var mimeString = </p><p class="source-code">    dataURI.split(',')[0].split(':')[1].split(';')[0];</p><p class="source-code">  var ia = new Uint8Array(byteString.length);</p><p class="source-code"> </p><p class="source-code">  for (var i = 0; i &lt; byteString.length; i++) {</p><p class="source-code">    ia[i] = byteString.charCodeAt(i);</p><p class="source-code">  }</p><p class="source-code">  const file = new Blob([ia], {type:mimeString});</p><p class="source-code">  return file;</p><p class="source-code">}</p><p>Let's not get too deep into the logic behind the preceding function. The only thing that you need to know is that it converts <a id="_idIndexMarker640"/>all readable <strong class="bold">American Standard Code for Information Interchange</strong> (<strong class="bold">ASCII</strong>) characters into 8-bit binary data, and at the end, it returns a <strong class="source-inline">blob</strong> object to the calling function. It converts data URIs to blobs.</p></li>
				<li>The new component that we<a id="_idIndexMarker641"/> are implementing at the moment is called <strong class="source-inline">AvatarUpload</strong>. It receives the <strong class="source-inline">isOpen</strong> property, which sets the modal to visible or<a id="_idIndexMarker642"/> invisible. By default, the modal is invisible. Furthermore, when the modal is shown, the dropzone is rendered inside. First, set up the component itself and the required variables, as follows: <p class="source-code">const AvatarModal = ({ isOpen, showModal }) =&gt; {</p><p class="source-code">  const [file, setFile] = useState(null);</p><p class="source-code">  const [result, setResult] = useState(null);</p><p class="source-code">  const [uploadAvatar] = useUploadAvatarMutation();</p><p class="source-code">  const cropperRef = useRef(null);</p><p class="source-code">}</p><p>We require the <strong class="source-inline">file</strong> and <strong class="source-inline">result</strong> state variables to manage the original file selected and the cropped image. Furthermore, we set up the mutation and a reference using the <strong class="source-inline">useRef</strong> Hook, which is required for the <strong class="source-inline">cropper</strong> library.</p></li>
				<li>Next, we need to set up all the component functions that we will use to handle different events and callbacks. Add the following functions to the component:<p class="source-code">const saveAvatar = () =&gt; {</p><p class="source-code">  const resultFile = dataURItoBlob(result);</p><p class="source-code">  resultFile.name = file.filename;</p><p class="source-code">  uploadAvatar({variables: { file: resultFile </p><p class="source-code">    }}).then(() =&gt; {</p><p class="source-code">    showModal();</p><p class="source-code">  });</p><p class="source-code">};</p><p class="source-code">const changeImage = () =&gt; {</p><p class="source-code">  setFile(null);</p><p class="source-code">};</p><p class="source-code">const onDrop = (acceptedFiles) =&gt; {</p><p class="source-code">  const reader = new FileReader();</p><p class="source-code">  reader.onload = () =&gt; {</p><p class="source-code">    setFile({</p><p class="source-code">      src: reader.result,</p><p class="source-code">      filename: acceptedFiles[0].name,</p><p class="source-code">      filetype: acceptedFiles[0].type,</p><p class="source-code">      result: reader.result,</p><p class="source-code">      error: null,</p><p class="source-code">    });</p><p class="source-code">  };</p><p class="source-code">  reader.readAsDataURL(acceptedFiles[0]);</p><p class="source-code">};</p><p class="source-code">const {getRootProps, getInputProps, isDragActive} = useDropzone({onDrop});</p><p class="source-code">const onCrop = () =&gt; {</p><p class="source-code">  const imageElement = cropperRef?.current;</p><p class="source-code">  const cropper = imageElement?.cropper;</p><p class="source-code">  setResult(cropper.getCroppedCanvas().toDataURL());</p><p class="source-code">};</p><p>The <strong class="source-inline">saveAvatar</strong> function is the main function that will translate the <strong class="source-inline">base64</strong> string into a blob. The <strong class="source-inline">onDrop</strong> function is called when the user drops or selects an image. At this moment, we use <strong class="source-inline">FileReader</strong> to read the file and give us the <strong class="source-inline">base64</strong> string that we save in the <strong class="source-inline">file</strong> state variable as an object. The <strong class="source-inline">useDropZone</strong> Hook gives us all the properties that we can use to set up the actual dropzone.</p><p>The <strong class="source-inline">changeImage</strong> function will<a id="_idIndexMarker643"/> cancel the current crop process and allow us<a id="_idIndexMarker644"/> to upload a new file again.</p><p>The <strong class="source-inline">onCrop</strong> function is called every time the cropped selection is changed by the user. At this moment, we save the new cropped image as a <strong class="source-inline">base64</strong> string to the <strong class="source-inline">result</strong> state variable to have a clear separation between the original <strong class="source-inline">file</strong> variable and the <strong class="source-inline">result</strong> variable. </p></li>
				<li>The <strong class="source-inline">Modal</strong> component takes an <strong class="source-inline">onRequestClose</strong> method, which executes the <strong class="source-inline">showModal</strong> function when the user tries to close the modal by clicking outside of it, for example. We receive the <strong class="source-inline">showModal</strong> function from the parent component, which we are going to cover in the next step. The modal also receives the default <strong class="source-inline">style</strong> property and a label.<p>The <strong class="source-inline">Cropper</strong> component needs to receive a function in the <strong class="source-inline">crop</strong> property that is called on every change. Also, the <strong class="source-inline">Cropper</strong> component receives the <strong class="source-inline">src</strong> property from the <strong class="source-inline">file</strong> state<a id="_idIndexMarker645"/> variable, as illustrated in the following <a id="_idIndexMarker646"/>code snippet:</p><p class="source-code">return (</p><p class="source-code">  &lt;Modal</p><p class="source-code">    isOpen={isOpen}</p><p class="source-code">    onRequestClose={showModal}</p><p class="source-code">    contentLabel="Change avatar"</p><p class="source-code">    style={modalStyle}</p><p class="source-code">  &gt;</p><p class="source-code">    {!file &amp;&amp;</p><p class="source-code">      (&lt;div className="drop" {...getRootProps()}&gt;</p><p class="source-code">        &lt;input {...getInputProps()} /&gt;</p><p class="source-code">        {isDragActive ? &lt;p&gt;Drop the files here ...&lt;/p&gt;</p><p class="source-code">        : &lt;p&gt;Drag 'n' drop some files here, or click</p><p class="source-code">        to select files&lt;/p&gt;}</p><p class="source-code">        &lt;/div&gt;)</p><p class="source-code">      }</p><p class="source-code">      {file &amp;&amp; &lt;Cropper ref={cropperRef}</p><p class="source-code">      src={file.src} style={{ height: 400, width:</p><p class="source-code">      "100%" }} initialAspectRatio={16 / 9}</p><p class="source-code">      guides={false} crop={onCrop}/&gt;}</p><p class="source-code">      {file &amp;&amp; (</p><p class="source-code">        &lt;button className="cancelUpload" </p><p class="source-code">          onClick={changeImage}&gt;Change image&lt;/button&gt;</p><p class="source-code">      )}</p><p class="source-code">      &lt;button className="uploadAvatar"</p><p class="source-code">        onClick={saveAvatar}&gt;Save&lt;/button&gt;</p><p class="source-code">    &lt;/Modal&gt;</p><p class="source-code">  )</p><p>The <strong class="source-inline">return</strong> statement, as you can see, only includes the modal as a wrapper and a cropper. At the end, we have a button calling <strong class="source-inline">saveAvatar</strong> to execute the mutation, and with it send the cropped image or <strong class="source-inline">changeImage</strong>, which cancels the cropping for the current image. </p></li>
				<li>Don't forget to add the <strong class="source-inline">export</strong> statement to the end of the file, as follows:<p class="source-code">export default AvatarModal</p></li>
				<li>Now, switch over<a id="_idIndexMarker647"/> to the <strong class="source-inline">user.js</strong> file in the <strong class="source-inline">bar</strong> folder, where all of the other application bar-related <a id="_idIndexMarker648"/>files are stored. Import the new <strong class="source-inline">AvatarModal</strong> component, as follows:<p class="source-code">import AvatarModal from '../avatarModal';</p></li>
				<li>The <strong class="source-inline">UserBar</strong> component is the parent of <strong class="source-inline">AvatarUploadModal</strong>. Open the <strong class="source-inline">user.js</strong> file from the <strong class="source-inline">bar</strong> folder. That is why we handle the <strong class="source-inline">isOpen</strong> state variable of the dialog in the <strong class="source-inline">UserBar</strong> component. We introduce an <strong class="source-inline">isOpen</strong> state variable and catch the <strong class="source-inline">onClick</strong> event on the avatar of the user. Copy the following code into the <strong class="source-inline">UserBar</strong> component:<p class="source-code">const [isOpen, setIsOpen] = useState(false);</p><p class="source-code">const showModal = () =&gt; {</p><p class="source-code">  setIsOpen(!isOpen);</p><p class="source-code">}</p></li>
				<li>Replace the <strong class="source-inline">return</strong> statement with the following code:<p class="source-code">return (</p><p class="source-code">  &lt;div className="user"&gt;</p><p class="source-code">    &lt;img src={user.avatar} onClick={() =&gt; showModal()} /&gt;</p><p class="source-code">    &lt;AvatarModal isOpen={isOpen}</p><p class="source-code">      showModal={showModal}/&gt;</p><p class="source-code">    &lt;span&gt;{user.username}&lt;/span&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">);</p><p>The modal<a id="_idIndexMarker649"/> component directly receives the <strong class="source-inline">isOpen</strong> property, as<a id="_idIndexMarker650"/> we explained earlier. The <strong class="source-inline">showModal</strong> method is executed when the avatar image is clicked. This function updates the property of the <strong class="source-inline">AvatarModal</strong> component, and either shows or hides the modal.</p></li>
			</ol>
			<p>Start the server and client with the matching <strong class="source-inline">npm run</strong> commands. Reload your browser and try out the new feature. When an image is selected, the cropping tool is displayed. You can drag and resize the image area that should be uploaded. You can see an example of this in the following screenshot:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_7.09_B17337.jpg" alt="Figure 7.9 – Cropping in progress&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9 – Cropping in progress</p>
			<p>Hitting <strong class="bold">Save</strong> uploads<a id="_idIndexMarker651"/> the image under the <strong class="source-inline">user</strong> folder in the S3 bucket. Thanks to the <a id="_idIndexMarker652"/>mutation that we wrote, the avatar image in the top bar is updated with the new URL to the S3 bucket location of the image.</p>
			<p>The great thing that we have accomplished is that we send the images to our server. Our server transfers all of the images to S3. AWS responds with the public URL, which is then placed directly into the avatar field in the browser. The way that we query the avatar image from the backend, using our GraphQL API, does not change. We return the URL to the S3 file, and everything works.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor162"/>Summary</h1>
			<p>In this chapter, we started by creating an AWS account and an S3 bucket for uploading static images from our backend. Modern social networks consist of many images, videos, and other types of files. We introduced Apollo Client, which allows us to upload any type of file. In this chapter, we managed to upload an image to our server, and we covered how to crop images and save them through a server in AWS S3. Your application should now be able to serve your users with images at any time.</p>
			<p>The next chapter will cover the basics of client-side routing, with the use of React Router.</p>
		</div>
	</body></html>