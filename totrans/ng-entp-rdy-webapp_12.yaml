- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Recipes – Master/Detail, Data Tables, and NgRx
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 食谱 – 主/详细，数据表和 NgRx
- en: 'In this chapter, we complete the router-first architecture implementation on
    LemonMart by implementing the top two most used features in business applications:
    master/detail views and data tables. I demonstrate data tables with server-side
    pagination, highlighting the integration between the frontend and backend using
    LemonMart and LemonMart Server.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们在 LemonMart 上通过实现商业应用中最常用的两个功能：主/详细视图和数据表，完成了路由优先架构的实现。我通过 LemonMart 和
    LemonMart Server 的服务器端分页演示了数据表，突出了前端和后端的集成。
- en: Make sure to have your **lemon-mart-server** up and running as you implement
    the recipes outlined in this chapter. Refer to *Chapter 10*, *RESTful APIs and
    Full-Stack Implementation*, for more information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在实现本章概述的食谱时，你的**lemon-mart-server**正在运行。有关更多信息，请参阅*第10章*，*RESTful API 和全栈实现*。
- en: We leverage the concept of router orchestration to orchestrate how our components
    load data or render. We use resolve guards to reduce boilerplate code when loading
    data before navigating to a component. We use auxiliary routes to lay out components
    through the router configuration. We reuse the same component in multiple contexts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用路由编排的概念来编排组件如何加载数据或渲染。我们使用解析守卫在导航到组件之前加载数据时减少样板代码。我们使用辅助路由通过路由配置来布局组件。我们在多个上下文中复用相同的组件。
- en: We then dive into NgRx using the LocalCast Weather app and explore NgRx Data
    with LemonMart, so you can become familiar with more advanced application architecture
    concepts in Angular. By the end of this chapter, we will have touched upon most
    of the major functionality that Angular and Angular Material have to offer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 LocalCast 天气应用程序深入探讨 NgRx，并使用 LemonMart 探索 NgRx 数据，这样你就可以熟悉 Angular
    中更高级的应用程序架构概念。到本章结束时，我们将触及 Angular 和 Angular Material 提供的大多数主要功能。
- en: This chapter covers a lot of ground. It is organized in a recipe format, so
    you can quickly refer to a particular implementation when you are working on your
    projects. I cover the architecture, design, and major components of the implementation.
    I highlight important pieces of code to explain how the solution comes together.
    Leveraging what you've learned so far, I expect the reader to fill in routine
    implementation and configuration details. However, you can always refer to the GitHub
    repo if you get stuck.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。它以食谱格式组织，因此当你正在处理项目时，可以快速参考特定的实现。我涵盖了实现架构、设计和主要组件。我突出显示重要的代码片段来解释解决方案是如何组合在一起的。利用你迄今为止所学的内容，我期望读者能够填写常规实现和配置细节。然而，如果你遇到困难，你始终可以参考
    GitHub 仓库。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，你将学习以下主题：
- en: Loading data with resolve guards
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解析守卫加载数据
- en: Reusable components with route data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有路由数据的可复用组件
- en: Master/detail views using auxiliary routes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用辅助路由的主/详细视图
- en: Data tables with pagination
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有分页的数据表
- en: NgRx Store and Effects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgRx Store 和 Effects
- en: NgRx Data Library
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgRx 数据库
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked in the following list. The repository contains the final
    and completed state of the code. You can verify your progress at the end of this
    chapter by looking for the end-of-chapter snapshot of code under the `projects`
    folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍样本代码的最新版本可在以下列表中链接的 GitHub 仓库找到。该仓库包含代码的最终和完成状态。你可以在本章末尾通过查找`projects`文件夹下的代码快照来验证你的进度。
- en: 'To get set up for this chapter''s examples based on **lemon-mart**, do the
    following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为本章的基于**lemon-mart**的示例做好准备，请执行以下操作：
- en: Clone the repo at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)克隆仓库
- en: Execute `npm install` on the root folder to install dependencies
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根文件夹中执行`npm install`以安装依赖项
- en: 'The code sample for this chapter is under the following subfolder:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章的代码示例位于以下子文件夹中：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run the Angular app for this chapter, execute the following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular 应用程序，请执行以下命令：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run Angular unit tests for this chapter, execute the following command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular 单元测试，请执行以下命令：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run Angular e2e tests for this chapter, execute the following command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular e2e 测试，请执行以下命令：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To build a production-ready Angular app for this chapter, execute the following
    command:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建本章的生产就绪 Angular 应用程序，请执行以下命令：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the `dist/ch12` folder at the root of the repository will contain
    the compiled result.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，存储库根目录下的 `dist/ch12` 文件夹将包含编译结果。
- en: 'To prepare for this chapter''s examples based on **local-weather-app**, implement
    these steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备本章基于 **local-weather-app** 的示例，请执行以下步骤：
- en: Clone the repo at [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆 [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
    上的repo
- en: Execute `npm install` on the root folder to install dependencies
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行 `npm install` 以安装依赖项
- en: 'The code sample for this chapter is under the following subfolder:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章的代码示例位于以下子文件夹中：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To run the Angular app for this chapter, execute the following command:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的Angular应用，请执行以下命令：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To run Angular unit tests for this chapter, execute the following command:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的Angular单元测试，请执行以下命令：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To run Angular e2e tests for this chapter, execute the following command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的Angular端到端测试，请执行以下命令：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To build a production-ready Angular app for this chapter, execute the following
    command:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建本章的生产就绪Angular应用，请执行以下命令：
- en: '[PRE9]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that the `dist/ch12` folder at the root of the repository will contain
    the compiled result.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，存储库根目录下的 `dist/ch12` 文件夹将包含编译结果。
- en: Beware that the source code in the book or on GitHub may not always match the
    code generated by Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time. Also on GitHub, expect
    to find corrections, fixes to support newer versions of libraries, or side-by-side
    implementations of multiple techniques for the reader to observe. The reader is
    only expected to implement the ideal solution recommended in the book. If you
    find errors or have questions, please create an issue or submit a pull request
    on GitHub for the benefit of all readers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，书中或GitHub上的源代码可能并不总是与Angular CLI生成的代码匹配。由于生态系统不断演变，书中代码与GitHub上代码之间的实现可能也存在细微差异。随着时间的推移，示例代码发生变化是自然的。在GitHub上，您可能会找到更正、修复以支持库的新版本或为读者观察而并排实现多种技术的示例。读者只需实现书中推荐的理想解决方案即可。如果您发现错误或有疑问，请创建一个GitHub问题或提交一个拉取请求，以惠及所有读者。
- en: You can read more about updating Angular in the *Appendix C*, *Keeping Angular
    and Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    or at [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *附录C* 中了解更多关于更新Angular的信息，即 *保持Angular和工具常青*。您可以从 [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    或 [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen)
    在线找到此附录。
- en: In the next section, we will learn about resolve guards so that we can simplify
    our code and reduce the amount of boilerplate.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习解析守卫，以便我们可以简化代码并减少样板代码的数量。
- en: Editing existing users
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑现有用户
- en: In *Chapter 11*, *Recipes – Reusability, Routing, and Caching*, we created a
    `ViewUserComponent` with an `editUser` function. We need this functionality later
    in the chapter when implementing a master/detail view in the system, where a manager
    can see all users in the system and have the ability to edit them. Before we can
    enable the `editUser` functionality, we need to make sure that the `ViewUserComponent`
    component alongside the `ProfileComponent` can load any user given their ID.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第11章* 中，我们在 *食谱 – 可重用性、路由和缓存* 中创建了一个具有 `editUser` 函数的 `ViewUserComponent`。在章节后面实现系统中的主/详细视图时，我们需要这个功能，其中经理可以看到系统中的所有用户并具有编辑他们的能力。在我们能够启用
    `editUser` 功能之前，我们需要确保 `ViewUserComponent` 组件和 `ProfileComponent` 组件可以加载任何给定其ID的用户。
- en: Let's start by implementing a resolve guard we can use for both components.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现一个可以用于两个组件的解析守卫开始。
- en: Loading data with resolve guard
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用解析守卫加载数据
- en: A resolve guard is a type of router guard, as mentioned in *Chapter 8*, *Designing
    Authentication and Authorization*. A resolve guard can load necessary data for
    a component by reading record IDs from `route` parameters, asynchronously load
    the data, and have it ready by the time the component activates and initializes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*第8章*中提到的，resolve guard是一种路由守卫。resolve guard可以通过读取`route`参数中的记录ID来为组件加载数据，异步加载数据，并在组件激活和初始化时准备好数据。
- en: 'The major advantages of a resolve guard include reusability of the loading
    logic, a reduction of boilerplate code, and the shedding of dependencies because
    the component can receive the data it needs without having to import any service:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Resolve guard的主要优势包括加载逻辑的可重用性、减少了样板代码，以及减少了依赖性，因为组件可以在不导入任何服务的情况下接收所需的数据：
- en: 'Create a new `user.resolve.ts` class under `user/user`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user/user`下创建一个新的`user.resolve.ts`类：
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that similar to the `updateUser` method in `UserService`, we use `map(User.Build)`
    to hydrate the `user` object, so it is ready to be used when a component loads
    data from the `route` snapshot, as we'll see next.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，与`UserService`中的`updateUser`方法类似，我们使用`map(User.Build)`来填充`user`对象，以便在组件从`route`快照加载数据时可以使用，正如我们接下来将要看到的。
- en: Provide the resolver in `user.module.ts`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user.module.ts`中提供解析器。
- en: Next, let's configure the `router` and `ProfileComponent` to be able to load
    an existing user.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，让我们配置`router`和`ProfileComponent`，以便能够加载现有用户。
- en: 'Modify `user-routing.module.ts` to add a new path, `profile/:userId`, with
    a route resolver and the `canActivate AuthGuard`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`user-routing.module.ts`以添加一个新的路径，`profile/:userId`，带有路由解析器和`canActivate AuthGuard`：
- en: '[PRE11]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Remember to provide `UserResolve` and `AuthGuard` in `user.module.ts`.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记得在`user.module.ts`中提供`UserResolve`和`AuthGuard`。
- en: 'Update the `profile` component to load the data from the `route` if it exists:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`profile`组件更新为从`route`加载数据（如果存在）：
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We first check to see whether a user is present in the `route` snapshot. If
    so, we call `patchUser` to load this user. Otherwise, we fall back to our conditional
    cache-loading logic.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查`route`快照中是否存在用户。如果存在，我们调用`patchUser`来加载此用户。否则，我们回退到我们的条件缓存加载逻辑。
- en: Note that the `patchUser` method also sets the `currentUserId` and `nameInitialDate$`
    observables, as well as calling the `patchUpdateData` base to update the form
    data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`patchUser`方法还设置了`currentUserId`和`nameInitialDate$`可观察对象，并调用`patchUpdateData`基类来更新表单数据。
- en: You can verify that the resolver is working by navigating to the profile with
    your user ID. Using the out-of-the-box settings, this URL will look something
    like `http://localhost:5000/user/profile/5da01751da27cc462d265913`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过导航到具有您用户ID的配置文件来验证解析器是否工作。使用默认设置，此URL将类似于`http://localhost:5000/user/profile/5da01751da27cc462d265913`。
- en: Reusing components with binding and route data
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新使用具有绑定和路由数据的组件
- en: Now, let's refactor the `viewUser` component so that we can reuse it in multiple
    contexts. User information is displayed in two places in the app as per the mock-ups
    that were created.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重构`viewUser`组件，以便我们可以在多个上下文中重用它。根据创建的mock-ups，用户信息在应用程序中的两个地方显示。
- en: 'The first place is the **Review** step of the user profile that we implemented
    in the previous chapter. The second place is on the user management screen on
    the `/manager/users` route, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个地方是我们之前章节中实现的用户配置文件的**Review**步骤。第二个地方是在`/manager/users`路由上的用户管理屏幕，如下所示：
- en: '![](img/B14094_12_01.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：用户管理mock-up](img/B14094_12_01.png)'
- en: 'Figure 12.1: Manager user management mock-up'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：经理用户管理mock-up
- en: To maximize code reuse, we need to ensure that our shared `ViewUser` component
    can be used in both contexts.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化代码重用，我们需要确保我们的共享`ViewUser`组件可以在两种上下文中使用。
- en: 'For the **Review** step of the multi-step input form, we simply bind the current
    user to it. In the second use case, the component will need to load its own data
    using a resolve guard, so we don''t need to implement additional logic to achieve
    our goal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多步输入表单的**Review**步骤，我们只需将当前用户绑定到它。在第二个用例中，组件需要使用resolve guard来加载自己的数据，因此我们不需要实现额外的逻辑来实现我们的目标：
- en: 'Update the `viewUser` component to inject the `ActivatedRoute` object and set `currentUser$`
    from the route in `ngOnInit()`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`viewUser`组件以注入`ActivatedRoute`对象，并在`ngOnInit()`中将`currentUser$`从路由设置：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`ngOnInit` will only fire once when the component is first initialized or has
    been routed to. In this case, if any data for the route has been resolved, then
    it''ll be pushed to `this.currentUser$` with the `next()` function.'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ngOnInit`仅在组件首次初始化或被路由到时触发一次。在这种情况下，如果已解析路由的任何数据，则它将通过`next()`函数推送到`this.currentUser$`。'
- en: We now have two independent events to update data; one for `ngOnChanges`, which
    handles updates to the `@Input` value and pushes to it to `BehaviorSubject currentUser$`
    if `this.user` has been bound to.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在有两个独立的事件来更新数据；一个用于`ngOnChanges`，它处理对`@Input`值的更新，并将其推送到`BehaviorSubject
    currentUser$`，如果`this.user`已被绑定。
- en: 'To be able to use this component across multiple lazy loaded modules, we must
    wrap it in its own module:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了能够在多个懒加载的模块中使用此组件，我们必须将其包裹在其自己的模块中：
- en: 'Create a new `shared-components.module.ts` under `src/app`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/app`下创建一个新的`shared-components.module.ts`：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ensure that you import the `SharedComponentsModule` module into each feature
    module you intended to use `ViewUserComponent` in. In our case, these will be
    `UserModule` and `ManagerModule`.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将`SharedComponentsModule`模块导入到每个你打算使用`ViewUserComponent`的功能模块中。在我们的例子中，这些将是`UserModule`和`ManagerModule`。
- en: Remove `ViewUserComponent` from the `User` module declarations
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`User`模块声明中移除`ViewUserComponent`
- en: Similarly declare and export `NameInputComponent` in `SharedComponentsModule`,
    and then clean up its other declarations
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，在`SharedComponentsModule`中声明并导出`NameInputComponent`，然后清理其其他声明
- en: Import the modules necessary to support `ViewUserComponent` and `NameInputComponent`
    in `SharedComponentsModule` as well, such as `FieldErrorModule`
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponentsModule`中导入必要的模块以支持`ViewUserComponent`和`NameInputComponent`，例如`FieldErrorModule`
- en: We now have the key pieces in place to begin implementation of the master/detail
    view. Let's go over this next.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了开始实现主/详细视图的关键部分。让我们继续下一步。
- en: Master/detail view auxiliary routes
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主/详细视图辅助路由
- en: The true power of router-first architecture comes to fruition with the use of
    auxiliary routes, where we can influence the layout of components solely through
    router configuration, allowing for rich scenarios where we can remix the existing
    components into different layouts. Auxiliary routes are routes that are independent
    of each other where they can render content in named outlets that have been defined
    in the markup, such as `<router-outlet name="master">` or `<router-outlet name="detail">`.
    Furthermore, auxiliary routes can have their own parameters, browser history,
    children, and nested auxiliaries.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器首先架构的真正力量在于使用辅助路由的实现，我们可以通过路由配置单独影响组件的布局，允许我们进行丰富的场景，其中我们可以将现有组件重新组合到不同的布局中。辅助路由是彼此独立的路由，它们可以在标记中定义的命名出口中渲染内容，例如`<router-outlet
    name="master">`或`<router-outlet name="detail">`。此外，辅助路由可以有自己的参数、浏览器历史记录、子路由和嵌套辅助路由。
- en: 'In the following example, we will implement a basic master/detail view using
    auxiliary routes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用辅助路由实现基本的主/详细视图：
- en: 'Implement a simple component with two named outlets defined:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个具有两个命名出口的简单组件：
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Add a new `userTable` component under manager
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在manager下添加一个新的`userTable`组件
- en: 'Update `manager-routing.module.ts` to define the auxiliary routes:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`manager-routing.module.ts`以定义辅助路由：
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This means that when a user navigates to `/manager/users`, they'll see the `UserTableComponent`,
    because it is implemented with the default path.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着当用户导航到`/manager/users`时，他们将看到`UserTableComponent`，因为它使用的是默认路径。
- en: Provide `UserResolve` in `manager.module.ts` since `viewUser` depends on it
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`manager.module.ts`中提供`UserResolve`，因为`viewUser`依赖于它
- en: 'Implement a temporary button in `userTable`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`userTable`中实现一个临时按钮：
- en: '[PRE17]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `skipLocationChange` directive navigates without pushing a new record into
    history. So if the user views multiple records and hits the **Back** button, they
    will be taken back to the previous screen, instead of having to scroll through
    the records they viewed first.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`skipLocationChange`指令在导航时不会将新记录推入历史记录。因此，如果用户查看多个记录并点击**后退**按钮，他们将被带回到上一个屏幕，而不是必须先滚动查看他们查看的记录。'
- en: 'Imagine that a user clicks on a **View detail** button like the one defined
    previously – then, `ViewUserComponent` will be rendered for the user with the
    given `userId`. In the next screenshot, you can see what the **View Details**
    button will look like after we implement the data table in the next section:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想象一下，如果用户点击一个类似于之前定义的**查看详情**按钮，那么`ViewUserComponent`将为具有给定`userId`的用户渲染。在下一张截图中，你可以看到在下一节实现数据表后，**查看详情**按钮将看起来是什么样子：
- en: '![](img/B14094_12_02.png)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B14094_12_02.png)'
- en: 'Figure 12.2: View Details button'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.2：查看详情按钮
- en: 'You can have as many combinations and alternative components defined for the
    master and detail, allowing for the infinite possibilities of dynamic layouts.
    However, setting up the `routerLink` can be a frustrating experience. Depending
    on the exact condition, you have to either supply or not supply all or some outlets
    in the link. For example, for the preceding scenario, if the link was `[''/manager/users'',
    { outlets: { master: [''''], detail: [''user'', {userId: row.id}] } }]`, the route
    will silently fail to load. Expect these quirks to be ironed out in future Angular
    releases.'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '您可以为主视图和详情视图定义任意多的组合和替代组件，从而实现动态布局的无限可能性。然而，设置`routerLink`可能会让人感到沮丧。根据具体条件，您可能需要提供或不需要提供链接中的所有或部分出口。例如，对于前面的场景，如果链接是`[''/manager/users'',
    { outlets: { master: [''''], detail: [''user'', {userId: row.id}] } }]`，则路由将静默失败加载。预计这些怪癖将在未来的Angular版本中得到解决。'
- en: Now that we've completed the implementation of the resolve guard for `ViewUserComponent`,
    you can use Chrome DevTools to see the data being loaded correctly.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`ViewUserComponent`的解析保护器的实现，您可以使用Chrome DevTools查看正确加载的数据。
- en: Before debugging, ensure that the **lemon-mart-server** we created in *Chapter
    10*, *RESTful APIs and Full-Stack Implementation*, is running.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调试之前，请确保运行我们在第10章“RESTful APIs和全栈实现”中创建的**lemon-mart-server**。
- en: In Chrome DevTools, set a break point right after `this.currentUser` is assigned,
    as shown:![](img/B14094_12_03.png)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Chrome DevTools中，在`this.currentUser`被分配后立即设置一个断点，如图所示：![图片](img/B14094_12_03.png)
- en: 'Figure 12.3: Dev Tools debugging ViewUserComponent'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.3：Dev Tools调试ViewUserComponent
- en: You will observe that `this.currentUser` is correctly set without any boilerplate
    code for loading data inside the `ngOnInit` function, showing the true benefit
    of a resolve guard. `ViewUserComponent` is the detail view; now let's implement
    the master view as a data table with pagination.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您将观察到`this.currentUser`被正确设置，而无需在`ngOnInit`函数内部加载数据的任何样板代码，这显示了解析保护器的真正好处。"ViewUserComponent"是详情视图；现在让我们实现主视图，作为一个具有分页的数据表。
- en: Data table with pagination
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带分页的数据表
- en: We have created the scaffolding to lay out our master/detail view. In the master
    outlet, we will have a paginated data table of users, so let's implement `UserTableComponent`,
    which will contain a `MatTableDataSource` property named `dataSource`. We will
    need to be able to fetch user data in bulk using standard pagination controls
    such as `pageSize` and `pagesToSkip` and be able to further narrow down the selection
    with user-provided `searchText`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了主/详情视图的框架。在主出口中，我们将有一个用户的分页数据表，因此让我们实现`UserTableComponent`，它将包含一个名为`dataSource`的`MatTableDataSource`属性。我们需要能够使用标准的分页控件，如`pageSize`和`pagesToSkip`来批量获取用户数据，并且能够通过用户提供的`searchText`进一步缩小选择范围。
- en: 'Let''s start by adding the necessary functionality to the `UserService`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向`UserService`添加必要的功能开始：
- en: 'Implement a new `IUsers` interface to describe the data structure of the paginated
    data:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个新的`IUsers`接口来描述分页数据的结构：
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Update the interface for `UserService` with a `getUsers` function:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`getUsers`函数更新`UserService`的接口：
- en: '[PRE19]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add `getUsers` to `UserService`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`getUsers`添加到`UserService`：
- en: '[PRE20]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the sort direction is represented by the keywords `asc` for ascending
    and `desc` for descending. When we want to sort a column in ascending order, we
    pass the column name as a parameter to the server. To sort a column in descending
    order, we prepend the column name with a minus sign.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，排序方向由关键字`asc`（升序）和`desc`（降序）表示。当我们想按升序排序一列时，我们将列名作为参数传递给服务器。要按降序排序一列，我们在列名前加上一个减号。
- en: 'Set up `UserTable` with pagination, sorting, and filtering:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`UserTable`以支持分页、排序和过滤：
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We define and initialize various properties to support loading paginated data.
    `items$` stores the user records, `displayedColumns` defines the columns of data
    we intend to display, `paginator` and `sort` provide pagination and sorting preferences,
    and `search` provides the text we need to filter our results by.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义并初始化各种属性以支持加载分页数据。"items$"存储用户记录，"displayedColumns"定义了我们打算显示的数据列，"paginator"和"sort"提供分页和排序偏好，而"search"提供了我们用于过滤结果的文本。
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a `ManagerMaterialModule` containing the following Material modules:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含以下Material模块的`ManagerMaterialModule`：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Ensure that `manager.module.ts` correctly imports the following:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保正确导入`manager.module.ts`中的以下内容：
- en: The new `ManageMaterialModule`
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`ManageMaterialModule`
- en: The baseline `AppMaterialModule`
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基线`AppMaterialModule`
- en: 'The following required modules: `FormsModule`, `ReactiveFormsModule`, and `FlexLayoutModule`'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下必需模块：`FormsModule`、`ReactiveFormsModule`和`FlexLayoutModule`
- en: 'Implement the CSS for `userTable`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现对`userTable`的CSS：
- en: '[PRE24]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, implement the `userTable` template:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`userTable`模板：
- en: '[PRE25]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With just the master view in place, the table is as shown in the following
    screenshot (make sure you''ve updated to the latest version of Angular!):'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅使用主视图，表格如下截图所示（确保你已经更新到Angular的最新版本！）：
- en: '![](img/B14094_12_04.png)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B14094_12_04.png)'
- en: 'Figure 12.4: User table'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.4：用户表
- en: 'If you click on the **View** icon, `ViewUserComponent` will get rendered in
    the detail outlet, as shown:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你点击**查看**图标，`ViewUserComponent`将在详情出口中渲染，如下所示：
- en: '![](img/B14094_12_05.png)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B14094_12_05.png)'
- en: 'Figure 12.5: Master/detail view'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.5：主/详情视图
- en: In the previous chapter, we implemented the **Edit** button, passing the `userId`
    to the `UserProfile` so that the data can be edited and updated.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了**编辑**按钮，将`userId`传递给`UserProfile`，以便可以编辑和更新数据。
- en: Click on the **Edit** button to be taken to the `ProfileComponent`, edit the
    user record, and verify that you can update another user's record
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**编辑**按钮，将被带到`ProfileComponent`，编辑用户记录，并验证你是否可以更新其他用户的记录
- en: Confirm that you can view the updated user record in the data table
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认你可以在数据表中查看更新的用户记录
- en: This demonstration of data tables with pagination completes the major functionality
    of LemonMart for the purpose of this book. Now, before we move on, let's make
    sure that all of our tests pass.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个带有分页的数据表演示完成了本书中LemonMart的主要功能。现在，在我们继续之前，让我们确保所有测试都通过。
- en: Updating unit tests
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新单元测试
- en: 'Let''s go over some unit tests for `ProfileComponent` and `UserTableComponent`
    to see how we can leverage different techniques to test the components:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`ProfileComponent`和`UserTableComponent`的一些单元测试，看看我们如何利用不同的技术来测试组件：
- en: 'Observe the unit test file for `ProfileComponent` and identify the use of the
    `authServiceMock` object to provide initial data for the component:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察单元测试文件`ProfileComponent`，并识别使用`authServiceMock`对象为组件提供初始数据：
- en: '[PRE26]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that instead of using the `createComponentMock` function from `angular-unit-test-helper`
    to import `NameInputComponent` or `ViewUserComponent`, I import their actual implementations.
    This is because `createComponentMock` is not yet sophisticated enough to deal
    with binding data to child components. In the *Further reading* section, I've
    included a blog post by Aiko Klostermann that covers testing Angular components
    with `@Input()` properties.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我并不是使用`angular-unit-test-helper`中的`createComponentMock`函数来导入`NameInputComponent`或`ViewUserComponent`，而是导入它们的实际实现。这是因为`createComponentMock`还不够复杂，无法处理将数据绑定到子组件。在*进一步阅读*部分，我包括了一篇由Aiko
    Klostermann撰写的博客文章，该文章涵盖了使用`@Input()`属性测试Angular组件。
- en: 'Open the spec file for `UserTableComponent`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`UserTableComponent`的规范文件：
- en: 'After fixing up its providers and imports, you will notice that `UserTableComponent`
    is throwing an `ExpressionChangedAfterItHasBeenCheckedError` error. This is because the
    component initialization logic requires `dataSource` to be defined. If undefined,
    the component can''t be created. However, we can easily modify component properties
    in the second `beforeEach` method, which executes after `TestBed` has injected
    real, mocked, or fake dependencies into the component class. See the highlighted
    changes in the following snippet for the test data setup:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在修复其提供者和导入之后，你会注意到`UserTableComponent`抛出了`ExpressionChangedAfterItHasBeenCheckedError`错误。这是因为组件初始化逻辑需要`dataSource`被定义。如果未定义，则无法创建组件。然而，我们可以在第二个`beforeEach`方法中轻松修改组件属性，该方法在`TestBed`将真实、模拟或伪造的依赖项注入到组件类之后执行。以下片段中突出显示的更改用于测试数据设置：
- en: '[PRE27]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By now, you may have noticed that just by updating some of our central configuration
    files, such as `commonTestingProviders` and `commonTestingModules`, some tests
    are passing, and the rest of the tests can be resolved by applying the various
    patterns we have been using throughout the book. For example, `user-management.component.spec.ts`
    uses the common testing modules and providers we have created:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经注意到，仅仅通过更新一些我们的核心配置文件，例如`commonTestingProviders`和`commonTestingModules`，一些测试通过了，其余的测试可以通过应用我们在整本书中使用的各种模式来解决。例如，`user-management.component.spec.ts`使用了我们创建的通用测试模块和提供者：
- en: '[PRE28]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When you are mocking providers, keep in mind what module, component, service,
    or class is under test and take care only to mock dependencies.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你在模拟提供者时，请记住正在测试的模块、组件、服务或类，并注意只模拟依赖项。
- en: '`ViewUserComponent` is a special case where we can''t use our common testing
    modules and providers, otherwise, we would end up creating a circular dependency.
    In this case, manually specify the modules that need to be imported.'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ViewUserComponent` 是一个特殊情况，我们无法使用我们常见的测试模块和提供者，否则我们最终会创建一个循环依赖。在这种情况下，手动指定需要导入的模块。'
- en: Fix the unit test configurations so all of them are passing and no warnings
    are generated.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复单元测试配置，以确保所有测试都通过且不生成警告。
- en: With the heavy lifting of the implementation completed, we can now explore alternative
    architectures, tools, and libraries to better understand the best ways to architect
    Angular apps for various needs. Next, let's explore NgRx.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 完成实现的重任后，我们现在可以探索替代架构、工具和库，以更好地理解为各种需求构建 Angular 应用程序的最佳方式。接下来，让我们探索 NgRx。
- en: NgRx Store and Effects
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgRx Store 和 Effects
- en: As covered in *Chapter 1*, *Introduction to Angular and Its Concepts*, the NgRx
    library brings reactive state management to Angular based on RxJS. State management
    with NgRx allows developers to write atomic, self-contained, and composable pieces
    of code, creating actions, reducers, and selectors. This kind of reactive programming
    allows side effects in state changes to be isolated. In essence, NgRx is an abstraction
    layer over RxJS to fit the Flux pattern.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *第 1 章* 中所述，*Angular 及其概念简介*，NgRx 库基于 RxJS 将响应式状态管理引入 Angular。使用 NgRx 进行状态管理允许开发者编写原子性、自包含和可组合的代码片段，创建动作、reducer
    和选择器。这种响应式编程允许在状态变化中隔离副作用。本质上，NgRx 是 RxJS 之上的一个抽象层，以适应 Flux 模式。
- en: 'There are four major elements of NgRx:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx 有四个主要元素：
- en: '**Store**: The central location where state information is persisted. You implement
    a reducer to store a state transition in the store and a selector to read data
    out of the store. These are atomic and composable pieces of code.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Store**：状态信息持久化的中心位置。您在 store 中实现一个 reducer 以存储状态转换，并实现一个选择器以从 store 中读取数据。这些都是原子性和可组合的代码片段。'
- en: A view (or user interface) displays data from the store by using a selector.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个视图（或用户界面）通过使用选择器显示 store 中的数据。
- en: '**Action**: Unique events that happen throughout your app.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**：在整个应用程序中发生的独特事件。'
- en: Actions are triggered from a view with the purpose of dispatching them to the
    store.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动作从视图触发，目的是将它们分发给 store。
- en: '**Dispatcher**: This is a method to send actions to the store.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分发器**：这是一种将动作发送到 store 的方法。'
- en: Reducers on the store listen for dispatched actions.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Store 上的 reducer 监听已分发的动作。
- en: '**Effect**: This is a combination of an action and a dispatcher. Effects are
    usually used for actions that are not triggered from a view.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效果**：这是动作和分发器的组合。效果通常用于不是从视图触发的动作。'
- en: 'Let''s revisit the following Flux pattern diagram, which now highlights an
    **Effect**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视以下 Flux 模式图，现在它突出显示了一个**效果**：
- en: '![](img/B14094_12_06.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_12_06.png)'
- en: 'Figure 12.6: Flux pattern diagram'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：Flux 模式图
- en: Let's demonstrate how NgRx works by going over a concrete example. In order
    to keep it simple, we will be leveraging the LocalCast Weather app.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来演示 NgRx 的工作原理。为了使其简单，我们将利用 LocalCast 天气应用。
- en: Implementing NgRx for LocalCast Weather
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 LocalCast 天气实现 NgRx
- en: 'We will be implementing NgRx to execute the search functionality in the LocalCast
    Weather app. Consider the following architecture diagram:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 LocalCast 天气应用中实现 NgRx 以执行搜索功能。考虑以下架构图：
- en: '![](img/B14094_12_07.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_12_07.png)'
- en: 'Figure 12.7: LocalCast Weather architecture'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7：LocalCast 天气架构
- en: In order to achieve our implementation, we will use both the NgRx store and
    effects libraries. NgRx store actions are reflected in the diagram in light gray
    with a `WeatherLoaded` reducer and the app state. At the top, actions are represented
    as a stream of various data objects either dispatching actions or acting on dispatched
    actions, enabling us to implement the Flux pattern. The NgRx effects library extends
    the Flux pattern by isolating side effects in its own model without littering
    the store with temporary data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的实现，我们将同时使用 NgRx store 和 effects 库。NgRx store 动作在图中以浅灰色显示，包括 `WeatherLoaded`
    reducer 和应用状态。在顶部，动作被表示为一系列各种数据对象，这些对象要么分发动作，要么对已分发的动作进行操作，使我们能够实现 Flux 模式。NgRx
    effects 库通过在其自己的模型中隔离副作用，而不在 store 中散布临时数据，从而扩展了 Flux 模式。
- en: 'The effects workflow, represented in dark gray, begins with **Step 1**:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以深灰色表示的效果工作流程从**步骤 1**开始：
- en: '`CitySearchComponent` dispatches the `search` action'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CitySearchComponent` 分发 `search` 动作'
- en: The `search` action appears on the observable `@ngrx/action` stream (or data stream)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`search` 动作出现在 `@ngrx/action` 可观察流（或数据流）中'
- en: '`CurrentWeatherEffects` acts on the `search` action to perform a search'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CurrentWeatherEffects` 对 `search` 动作进行操作以执行搜索'
- en: '`WeatherService` performs the search to retrieve current weather information from
    the **OpenWeather API**'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WeatherService` 执行搜索以从**OpenWeather API**检索当前天气信息'
- en: 'Store actions, represented in light gray, begin with **Step A**:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以浅灰色表示的存储动作从**步骤 A**开始：
- en: '`CurrentWeatherEffects` dispatches the `weatherLoaded` action'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CurrentWeatherEffects` 分发 `weatherLoaded` 动作'
- en: The `weatherLoaded` action appears on the data stream
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`weatherLoaded` 动作出现在数据流中'
- en: The `weatherLoaded` reducer acts on the `weatherLoaded` action
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`weatherLoaded` 减法器对 `weatherLoaded` 动作进行操作'
- en: The `weatherLoaded` reducer transforms the weather information to be stored
    as a new state
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`weatherLoaded` 减法器将天气信息转换为要存储的新状态'
- en: The new state is a persisted `search` state, part of the `appStore` state
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新状态是持久化的 `search` 状态，是 `appStore` 状态的一部分
- en: Note that there's a parent-level `appStore` state, which contains a child `search`
    state. I intentionally retained this setup to demonstrate how the parent-level
    state scales as you add different kinds of data elements to the store.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，存在一个父级 `appStore` 状态，其中包含一个子 `search` 状态。我故意保留这种设置来演示当您向存储中添加不同类型的数据元素时，父级状态是如何扩展的。
- en: 'Finally, a view reads from the store, beginning with **step a**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个视图从存储中读取，从**步骤 a**开始：
- en: The `CurrentWeather` component subscribes to the `selectCurrentWeather` selector
    using the `async` pipe
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CurrentWeather` 组件使用 `async` 管道订阅 `selectCurrentWeather` 选择器'
- en: The `selectCurrentWeather` selector listens for changes to the `store.search.current`
    property in the `appStore` state
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`selectCurrentWeather` 选择器监听 `appStore` 状态中 `store.search.current` 属性的变化'
- en: The `appStore` state retrieves the persisted data
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`appStore` 状态检索持久化的数据'
- en: Using NgRx, when a user searches for a city, the actions to retrieve, persist,
    and display that information on the `CurrentWeatherComponent` happens automatically
    via individual composable and immutable elements.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NgRx，当用户搜索城市时，检索、持久化和在 `CurrentWeatherComponent` 上显示该信息的动作会通过单个可组合和不可变元素自动发生。
- en: Comparing BehaviorSubject and NgRx
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较BehaviorSubject和NgRx
- en: 'We will be implementing NgRx side by side with `BehaviorSubjects`, so you can
    see the differences in the implementation of the same feature. To do this, we
    will need a slide toggle to switch between the two strategies:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将同时实现 NgRx 和 `BehaviorSubjects`，这样您可以看到同一功能的实现差异。为此，我们需要一个滑动切换来在两种策略之间切换：
- en: This section uses the **local-weather-app** repo. You can find the code samples
    for this chapter under the `projects/ch12` folder.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用 **local-weather-app** 仓库。您可以在 `projects/ch12` 文件夹下找到本章的代码示例。
- en: Start by implementing a `<mat-slide-toggle>` element on `CitySearchComponent`,
    as shown in the following screenshot:![](img/B14094_12_08.png)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从在 `CitySearchComponent` 上实现 `<mat-slide-toggle>` 元素开始，如下面的截图所示：![](img/B14094_12_08.png)
- en: 'Figure 12.8: LocalCast Weather slide toggle'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.8：LocalCast Weather 滑动切换
- en: Ensure that the field is backed by a property on your component named `useNgRx`.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保该字段由组件上的 `useNgRx` 属性支持。
- en: Refactor the `doSearch` method to extract the `BehaviorSubject` code as its
    own function named `behaviorSubjectBasedSearch`
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `doSearch` 方法重构为提取名为 `behaviorSubjectBasedSearch` 的 `BehaviorSubject` 代码作为其自己的函数
- en: 'Stub out a function called `ngRxBasedSearch`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ngRxBasedSearch` 的函数原型：
- en: '[PRE29]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will be dispatching an action from the `ngRxBasedSearch` function that you
    just created.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从您刚刚创建的 `ngRxBasedSearch` 函数中分发一个动作。
- en: Setting up NgRx
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 NgRx
- en: 'You may add the NgRx Store package with the following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令添加 NgRx Store 包：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will create a reducers folder with an `index.ts` file in it. Now add the
    NgRx effects package:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含 `index.ts` 文件的 `reducers` 文件夹。现在添加 NgRx effects 包：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We use the `--minimal` option here to avoid creating unnecessary boilerplate.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `--minimal` 选项来避免创建不必要的样板代码。
- en: 'Next, install the NgRx schematics library so you can take advantage of generators
    to create the boilerplate code for you:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装 NgRx 模式库，这样您就可以利用生成器为您创建样板代码：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Implementing NgRx can be confusing due to its highly decoupled nature, which
    may necessitate some insight into the inner workings of the library.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NgRx高度解耦的特性，实现NgRx可能会令人困惑，这需要对其内部工作原理有一定的了解。
- en: The sample project under `projects/ch12` configures `@ngrx/store-devtools` for
    debugging.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在`projects/ch12`下的示例项目配置了`@ngrx/store-devtools`进行调试。
- en: If you would like to be able to `console.log` NgRx actions for debugging or
    instrumentation during runtime, refer to the *Appendix A*, *Debugging Angular*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在运行时进行调试或仪表化，并能够`console.log` NgRx动作，请参阅附录A，*调试Angular*。
- en: Defining NgRx actions
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义NgRx动作
- en: 'Before we can implement effects or reducers, we first need to define the actions
    our app is going to be able to execute. For LocalCast Weather, there are two types
    of actions:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以实现效果或还原器之前，我们首先需要定义我们的应用程序将要能够执行的动作。对于LocalCast Weather，有两种类型的动作：
- en: '`search`: Fetches the current weather for the city or zip code that''s being
    searched'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search`：获取正在搜索的城市或邮编的当前天气'
- en: '`weatherLoaded`: Indicates that new current weather information has been fetched'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weatherLoaded`：表示已获取新的当前天气信息'
- en: 'Create an action named `search` by running the following command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建一个名为`search`的动作：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Take the default options when prompted.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 按提示选择默认选项。
- en: The `--group` option groups actions under a folder named `action`. The `--creators`
    option uses creator functions to implement actions and reducers, which is a more
    familiar and straightforward way to implement these components.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`--group`选项将动作分组在名为`action`的文件夹下。`--creators`选项使用创建函数来实现动作和还原器，这是一种更熟悉且直接的方法来实现这些组件。'
- en: 'Now, let''s implement the two actions using the `createAction` function, providing
    a name and an expected list of input parameters:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`createAction`函数实现两个动作，提供一个名称和预期的输入参数列表：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The search action has the name `'[Search] Search'` and has `searchText` and
    an optional `country` parameter as inputs. The `weatherLoaded` action follows
    a similar pattern. At the end of the file, we create a union type of our actions,
    so we can group them under one parent type to use in the rest of the application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索操作名为`'[Search] Search'`，输入参数包括`searchText`和一个可选的`country`参数。`weatherLoaded`操作遵循类似的模式。在文件末尾，我们创建了一个动作的联合类型，这样我们就可以将它们分组在同一个父类型下，以便在应用程序的其余部分使用。
- en: Notice that action names are prepended by `[Search]`. This is a convention that
    helps developers visually group related actions together during debugging.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，动作名称前缀为`[Search]`。这是一个帮助开发者在调试期间视觉上分组相关动作的约定。
- en: Now that our actions are deﬁned, we can implement the effect to handle the search
    action and dispatch a `weatherLoaded` action.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了动作，我们可以实现效果来处理搜索动作并分发一个`weatherLoaded`动作。
- en: Implementing NgRx Effects
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现NgRx效果
- en: As mentioned earlier, effects let us change the stored state without necessarily
    storing the event data that is causing the change. For example, we want our state
    to only have weather data, not the search text itself. Effects allow us to do
    this in one step, rather than forcing us to use an intermediate store for the
    `searchText` and a far more complicated chain of events to just turn that into
    weather data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，效果允许我们更改存储的状态，而无需存储导致更改的事件数据。例如，我们希望我们的状态只包含天气数据，而不是搜索文本本身。效果允许我们一步完成这项工作，而不是强迫我们使用中间存储来存储`searchText`，以及一个更为复杂的链式事件来将其转换为天气数据。
- en: Otherwise, we would have to implement a reducer in between, to first store this
    value in the store, and then later retrieve it from a service and dispatch a `weatherLoaded`
    action. The effect will make it simpler to retrieve data from our service.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们不得不在中间实现一个还原器，首先将此值存储在存储中，然后稍后从服务中检索它并分发一个`weatherLoaded`动作。效果将使数据检索变得简单。
- en: 'Now let''s add `CurrentWeatherEffects` to our app:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将`CurrentWeatherEffects`添加到我们的应用程序中：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Take the default options when prompted.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 按提示选择默认选项。
- en: You will have a new `current-weather.effects.ts` file under the `effects` folder.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在`effects`文件夹下有一个新的`current-weather.effects.ts`文件。
- en: Once again, `--group` is used to group effects under a folder of the same name.
    `--root` registers the effect in `app.module.ts` and we use creator functions
    with the `--creators` option.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`--group`用于将效果分组在同名文件夹下。`--root`在`app.module.ts`中注册效果，我们使用带有`--creators`选项的创建函数。
- en: 'In the `CurrentWeatherEffects` ﬁle, start by implementing a private `doSearch`
    method:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CurrentWeatherEffects`文件中，首先实现一个私有的`doSearch`方法：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that we're choosing to ignore errors thrown with the `EMPTY` function.
    You can surface these errors to the user with a `UiService` like the one you've
    implemented for LemonMart.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们选择忽略由`EMPTY`函数抛出的错误。你可以使用类似于为LemonMart实现的`UiService`将这些错误暴露给用户。
- en: This function takes an action with search parameters, calls `getCurrentWeather`,
    and upon receiving a response, dispatches the `weatherLoaded` action, passing
    in the current weather property.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接收一个带有搜索参数的动作，调用`getCurrentWeather`，并在收到响应后，派发`weatherLoaded`动作，传递当前天气属性。
- en: 'Now let''s create the effect itself, so we can trigger the `doSearch` function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建效果本身，这样我们就可以触发`doSearch`函数：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is where we tap into the observable action stream, `this.actions$`, and
    listen to actions of the `SearchAction.search` type. We then use the `exhaustMap`
    operator to register for the emitted event. Due to its unique nature, `exhaustMap`
    won't allow another search action to be processed until the `doSearch` function
    completes dispatching its `weatherLoaded` action.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们接入可观察的动作流`this.actions$`并监听`SearchAction.search`类型动作的地方。然后我们使用`exhaustMap`操作符来注册发射的事件。由于其独特的性质，`exhaustMap`不会允许在`doSearch`函数完成其`weatherLoaded`动作的派发之前处理另一个搜索动作。
- en: Confused by all the different kinds of RxJS operators and worried you'll never
    remember them? See the *Appendix B*, *Angular Cheat Sheet*, for a quick reference.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有不同的RxJS操作符感到困惑，担心你永远不会记住它们？请参阅*附录B*，*Angular Cheat Sheet*，以获取快速参考。
- en: Implementing reducers
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现reducers
- en: With the `weatherLoaded` action triggered, we need a way to ingest the current
    weather information and store it in our `appStore` state. Reducers will help us
    handle specific actions, creating an isolated and immutable pipeline to store
    our data in a predictable way.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`weatherLoaded`动作触发后，我们需要一种方法来摄取当前的天气信息并将其存储在我们的`appStore`状态中。reducers将帮助我们处理特定动作，创建一个隔离且不可变的管道，以可预测的方式存储我们的数据。
- en: 'Let''s create a search reducer:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个搜索reducer：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Take the default options. Here, we use `--group` to keep files organized under
    the `reducers` folder and `--creators` to leverage the creator style of creating
    NgRx components. We also specify the location of our parent `appStore` state at
    `reducers/index.ts` with `--reducers`, so our new reducer can be registered with
    it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 采用默认选项。在这里，我们使用`--group`来保持文件在`reducers`文件夹下组织，并使用`--creators`来利用创建NgRx组件的创建者风格。我们还使用`--reducers`指定我们的父`appStore`状态的位置在`reducers/index.ts`，这样我们的新reducer就可以注册到它。
- en: You may observe that `reducers.index.ts` has been updated to register the new
    `search.reducer.ts`. Let's implement it step by step.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到`reducers.index.ts`已经更新以注册新的`search.reducer.ts`。让我们一步一步地实现它。
- en: 'In the `search` state, we will be storing the current weather, so implement
    the interface to reﬂect this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在`search`状态中，我们将存储当前天气，因此实现接口以反映这一点：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now let''s specify the `initialState`. This is similar to how we need to define
    a default value of a `BehaviorSubject`. Refactor the `WeatherService` to export
    a `const defaultWeather: ICurrentWeather` object that you can use to initialize
    `BehaviorSubject` and `initialState`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们指定`initialState`。这类似于我们需要定义`BehaviorSubject`的默认值。重构`WeatherService`以导出`const
    defaultWeather: ICurrentWeather`对象，你可以使用它来初始化`BehaviorSubject`和`initialState`。'
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, implement `searchReducer` to handle the `weatherLoaded` action using
    the `on` operator:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`on`操作符实现`searchReducer`以处理`weatherLoaded`动作：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We simply register for the `weatherLoaded` action and unwrap the data stored
    in it and pass it into the `search` state.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需注册`weatherLoaded`动作，并解包其中存储的数据，然后将其传递到`search`状态。
- en: This is, of course, a very simplistic case. However, it is easy to imagine a
    more complicated scenario, where we may need to flatten or process a piece of
    data received and store it in an easy-to-consume manner. Isolating such logic
    in an immutable way is the key value proposition of utilizing a library like NgRx.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一个非常简单的例子。然而，很容易想象一个更复杂的场景，在那里我们可能需要将接收到的数据展平或处理，并以易于消费的方式存储它。以不可变的方式隔离这种逻辑是使用像NgRx这样的库的关键价值主张。
- en: Registering with Store using selector
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选择器在Store中注册
- en: We need `CurrentWeatherComponent` to register with the `appStore` state for
    updated current weather data.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`CurrentWeatherComponent`注册到`appStore`状态以更新当前天气数据。
- en: 'Start by dependency injecting the `appStore` state and registering the selector
    to pluck current weather from the `State` object:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过依赖注入`appStore`状态并注册选择器来从`State`对象中提取当前天气：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We simply listen to state change events that flow through the store. Using the
    `select` function, we can implement an inline select to get the piece of data
    we need.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地监听通过商店流动的状态变化事件。使用`select`函数，我们可以实现一个内联选择，以获取我们所需的数据片段。
- en: 'We can refactor this a bit and make our selector reusable by using a `createSelector`
    to create a `selectCurrentWeather` property on `reducers/index.ts`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微重构一下，通过使用`createSelector`在`reducers/index.ts`上创建一个`selectCurrentWeather`属性，使我们的选择器可重用：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In addition, since we want to maintain the continued operation of the `BehaviorSubject`,
    we can implement a `merge` operator in `CurrentWeatherComponent` to listen to
    both `WeatherService` updates and `appStore` state updates:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们希望保持`BehaviorSubject`的持续操作，我们可以在`CurrentWeatherComponent`中实现一个`merge`操作符，以监听`WeatherService`更新和`appStore`状态更新：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that we are able to listen to store updates, let''s implement the final
    piece of the puzzle: dispatching the search action.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够监听商店更新了，让我们实现拼图的最后一部分：分发搜索动作。
- en: Dispatching store actions
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发商店动作
- en: We need to dispatch the search action so that our search effect can fetch current
    weather data and update the store. Earlier in this chapter, you implemented a
    stubbed function called `ngRxBasedSearch` in the `CitySearchComponent`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要分发搜索动作，以便我们的搜索效果可以获取当前天气数据并更新商店。在本章的早期部分，您在`CitySearchComponent`中实现了一个名为`ngRxBasedSearch`的存根函数。
- en: 'Let''s implement `ngRxBasedSearch`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现`ngRxBasedSearch`：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Don't forget to inject the `appState` store into the component!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`appState`商店注入到组件中！
- en: And that's it! Now you should be able to run your code and test to see whether
    it all works.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在你应该能够运行你的代码并测试是否一切正常工作。
- en: As you can see, NgRx brings a lot of sophisticated techniques to the table to
    create ways to make data transformations immutable, well deﬁned, and predictable.
    However, this comes with considerable implementation overhead. Use your best judgment
    to determine whether you really need the Flux pattern in your Angular app. Often,
    the frontend application code can be made much simpler by implementing RESTful
    APIs that return ﬂat data objects, with complicated data manipulations handled
    server side.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，NgRx带来了许多复杂的技巧，以创建使数据转换不可变、定义良好和可预测的方法。然而，这伴随着相当大的实现开销。请使用您的最佳判断来决定您是否真的需要在您的Angular应用程序中使用Flux模式。通常，前端应用程序代码可以通过实现返回平面数据对象的RESTful
    API来简化，复杂的数据处理在服务器端进行。
- en: Unit testing reducers and selectors
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试reducer和选择器
- en: 'You can implement unit tests for the `weatherLoaded` reducer and the `selectCurrentWeather`
    selector in `search.reducer.spec.ts`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`search.reducer.spec.ts`中为`weatherLoaded`reducer和`selectCurrentWeather`选择器实现单元测试：
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: These unit tests are fairly straightforward and will ensure that no unintentional
    changes to the data structure can happen within the store.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单元测试相当直接，将确保在商店内不会发生对数据结构的意外更改。
- en: Unit testing components with MockStore
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MockStore进行单元测试组件
- en: You need to update the tests for `CurrentWeatherComponent` so that we can inject
    a mock `Store` into the component to test the value of the `current$` property.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要更新`CurrentWeatherComponent`的测试，以便我们可以将模拟的`Store`注入到组件中，以测试`current$`属性的值。
- en: 'Let''s look at the delta of what needs to be added to the spec file to configure
    the mock store:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看需要添加到规范文件中的delta，以配置模拟商店：
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can now update the `''should get currentWeather from weatherService''` test
    to see whether `CurrentWeatherComponent` works with a mock store:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新`'should get currentWeather from weatherService'`测试，以查看`CurrentWeatherComponent`是否与模拟商店一起工作：
- en: '[PRE48]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The mock store allows us to set the current state of the store, which in turn
    allows the selector call in the constructor to fire and grab the provided fake
    weather data.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟商店允许我们设置商店的当前状态，这反过来又允许构造函数中的选择器调用触发并获取提供的假天气数据。
- en: TestBed is not a hard requirement for writing unit tests in Angular, a topic
    covered well at [https://angular.io/guide/testing](https://angular.io/guide/testing).
    My colleague and reviewer of this book, Brendon Caulkins, contributed a bed-less
    spec file for this chapter, named `current-weather.component.nobed.spec.ts`. He
    cites significant performance increases when running the tests, with fewer imports
    and less maintenance, but a higher level of care and expertise required to implement
    the tests. If you're on a large project, you should seriously consider skipping
    the `TestBed`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: TestBed 不是在 Angular 中编写单元测试的强制要求，这是一个在 [https://angular.io/guide/testing](https://angular.io/guide/testing)
    中得到良好阐述的话题。我的同事和本书的审稿人 Brendon Caulkins 为本章提供了一个无床的规范文件，名为 `current-weather.component.nobed.spec.ts`。他提到，在运行测试时，由于导入较少和维护较少，测试性能显著提高，但需要更高水平的关注和专业知识来实现测试。如果你在一个大型项目中，你应该认真考虑跳过
    `TestBed`。
- en: You can find the sample code on GitHub under the `projects/ch12` folder.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 的 `projects/ch12` 文件夹下找到示例代码。
- en: Go ahead and update the remainder of your tests and do not move on until they
    all start passing.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 继续更新你剩余的测试，直到它们全部通过后再继续。
- en: NgRx Data
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgRx Data
- en: If NgRx is a configuration-based framework, NgRx Data is a convention-based
    sibling of NgRx. NgRx Data automates the creation of stores, effects, actions,
    reducers, dispatches, and selectors. If most of your application actions are **CRUD**
    (**Create**, **Retrieve**, **Update**, and **Delete**) operations, then NgRx Data
    can achieve the same result as NgRx with a lot less code needing to be written.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 NgRx 是一个基于配置的框架，那么 NgRx Data 就是 NgRx 的基于约定的兄弟。NgRx Data 自动创建存储、效果、动作、还原器、分发和选择器。如果你的大多数应用程序动作是
    **CRUD**（**创建**、**检索**、**更新**和**删除**）操作，那么 NgRx Data 可以用更少的代码实现与 NgRx 相同的结果。
- en: NgRx Data may be a much better introduction to the Flux pattern for you and
    your team. Then you can go on to NgRx itself.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx Data 可能是你和你的团队更好地了解 Flux 模式的入门，然后你可以继续学习 NgRx 本身。
- en: '`@ngrx/data` works in tandem with the `@ngrx/entity` library. Together they
    offer a rich feature set, including transactional data management. Read more about
    it at [https://ngrx.io/guide/data](https://ngrx.io/guide/data).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ngrx/data` 与 `@ngrx/entity` 库协同工作。它们一起提供了一套丰富的功能，包括事务性数据管理。更多关于它的信息请参阅 [https://ngrx.io/guide/data](https://ngrx.io/guide/data)。'
- en: For this example, we will be switching back over to the LemonMart project.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将切换回 LemonMart 项目。
- en: 'Add NgRx Data to your project by executing the following commands:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令将 NgRx Data 添加到你的项目中：
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The sample project under `projects/ch12` configures `@ngrx/store-devtools` for
    debugging.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`projects/ch12` 下的示例项目配置了 `@ngrx/store-devtools` 用于调试。'
- en: If you would like to be able to `console.log` NgRx actions for debugging or
    instrumentation during runtime, refer to the *Appendix A*, *Debugging Angular*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望能够在运行时进行调试或仪表化，并使用 `console.log` NgRx 动作，请参阅 *附录 A*，*调试 Angular*。
- en: Implementing NgRx/Data in LemonMart
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 LemonMart 中实现 NgRx/Data
- en: In LemonMart, we have a great use case for the `@ngrx/data` library with the
    `User` class and the `UserService`. It neatly represents an entity that could
    support CRUD operations. With a few modifications and the least amount of effort,
    you can see the library in action.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LemonMart 中，我们有一个很好的用例来使用 `@ngrx/data` 库，特别是 `User` 类和 `UserService`。它巧妙地表示了一个可以支持
    CRUD 操作的实体。通过一些修改和最少的努力，你就可以看到库的实际应用。
- en: This section uses the **lemon-mart** repo. You can find the code samples for
    this chapter under the `projects/ch12` folder.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用 **lemon-mart** 仓库。你可以在 `projects/ch12` 文件夹下找到本章的代码示例。
- en: 'Let''s start by defining the `User` entity in `entity-metadata.ts`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在 `entity-metadata.ts` 中定义 `User` 实体开始：
- en: '[PRE50]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Ensure that the `entityConfig` object is registered with `EntityDataModule`:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将 `entityConfig` 对象注册到 `EntityDataModule`：
- en: '[PRE51]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a `User` entity service:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `User` 实体服务：
- en: '[PRE52]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You now have all the basic elements in place to integrate the entity service
    with a component. In a sense, it is this easy to set up NgRx Data. However, we'll
    have to customize it somewhat to fit into our existing REST API structure, which
    will be covered in detail in the next section. If you were to follow the API implementation
    pattern that NgRx Data expects, then no changes would be necessary.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经拥有了所有基本元素，可以将实体服务与组件集成。从某种意义上说，设置 NgRx Data 如此简单。然而，我们需要对其进行一些定制以适应我们现有的
    REST API 结构，这将在下一节中详细说明。如果你遵循 NgRx Data 期望的 API 实现模式，那么不需要进行任何更改。
- en: NgRx Data wants to access the REST API via the `/api` path, hosted on the same
    port as your Angular app. To accomplish this during development, we need to leverage
    Angular CLI's proxy feature.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx Data 想要通过 `/api` 路径访问 REST API，该路径托管在与你的 Angular 应用程序相同的端口上。为了在开发期间完成此操作，我们需要利用
    Angular CLI 的代理功能。
- en: Configuring proxy in Angular CLI
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Angular CLI 中配置代理
- en: Normally, HTTP requests sent to our web server and our API server should have
    exactly the same URL. However, during development, we usually host both applications
    on two different ports of `http://localhost`. Certain libraries, including NgRx
    Data, require that HTTP calls be on the same port. This creates a challenge for
    creating a frictionless development experience. For this reason, Angular CLI ships
    with a proxy feature with which you can direct the `/api` path to a different
    endpoint on your localhost. This way, you can use one port to serve your web app
    and your API requests.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，发送到我们的 web 服务器和 API 服务器的 HTTP 请求应该有完全相同的 URL。然而，在开发过程中，我们通常在 `http://localhost`
    的两个不同端口上托管两个应用程序。某些库，包括 NgRx Data，要求 HTTP 调用在同一个端口上。这为创建无摩擦的开发体验带来了挑战。因此，Angular
    CLI 随带了一个代理功能，你可以将 `/api` 路径指向 localhost 上的不同端点。这样，你可以使用一个端口来提供你的 web 应用程序和 API
    请求。
- en: 'Create a `proxy.conf.json` file under `src`, as shown:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src` 下创建一个 `proxy.conf.json` 文件，如下所示：
- en: If you're working in the **lemon-mart-server** monorepo, this will be `web-app/src`.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正在 **lemon-mart-server** monorepo 中工作，这将是在 `web-app/src`。
- en: '[PRE53]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Register the proxy with `angular.json`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `angular.json` 注册代理：
- en: '[PRE54]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now the server that is started when you run `npm start` or `ng serve` can rewrite
    the URLs of any call made to the `/api` route with `http://localhost:3000`. This
    is the port that **lemon-mart-server** runs by default.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行 `npm start` 或 `ng serve` 时启动的服务可以重写对 `/api` 路径的任何调用，使用 `http://localhost:3000`。这是默认运行
    **lemon-mart-server** 的端口。
- en: If your API is running a different port, then use the correct port number and
    child route.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 API 在不同的端口上运行，那么请使用正确的端口号和子路由。
- en: Next, let's use the `UserEntityService`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 `UserEntityService`。
- en: Using Entity Service
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用实体服务
- en: We will be updating the User Management master view, so we can optionally use
    `BehaviorSubject` or the `UserEntityService` we just created.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新用户管理主视图，因此我们可以选择使用 `BehaviorSubject` 或我们刚刚创建的 `UserEntityService`。
- en: Start by implementing a toggle switch in `user-table.component.ts`, similar
    to the way we did for LocalCast Weather and NgRx earlier in the chapter:![](img/B14094_12_09.png)
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `user-table.component.ts` 中实现一个切换开关，类似于我们在本章前面为 LocalCast Weather 和 NgRx
    所做的那样！![图片](img/B14094_12_09.png)
- en: 'Figure 12.9: UserTableComponent with the NgRx slide toggle'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.9：具有 NgRx 滑动切换的 UserTableComponent
- en: 'Inject the new service into `UserTableComponent` and merge its loading observable
    with the one that''s present on the component:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新服务注入到 `UserTableComponent` 中，并将其加载可观察对象与组件上现有的可观察对象合并：
- en: '[PRE55]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Since `EntityDataModule` is registered in `app.module.ts` at the root of our
    application, we need to provide `UserService` in `app.module.ts` as well, so we
    can consume data from it in `UserEntityService`. Even though `UserEntityService`
    is provided in `UserModule`, the order of operations within NgRx Data doesn't
    lend itself to properly working with feature modules. This will probably be fixed
    at some point.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 `EntityDataModule` 在我们应用程序的根目录 `app.module.ts` 中注册，因此我们还需要在 `app.module.ts`
    中提供 `UserService`，这样我们就可以在 `UserEntityService` 中使用它。尽管 `UserEntityService` 在 `UserModule`
    中提供，但 NgRx Data 中的操作顺序不适合与功能模块正确工作。这可能在某个时候得到修复。
- en: 'You can add CRUD methods to the component, as shown in the following code.
    However, we will be focused on just updating the `getUsers` function so there
    is no need to add the others:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以向组件中添加 CRUD 方法，如下面的代码所示。然而，我们将专注于仅更新 `getUsers` 函数，因此不需要添加其他方法：
- en: '[PRE56]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In `ngAfterViewInit`, refactor the call to `this.userService.getUsers` so that
    it is called from a method named `getUsers`
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ngAfterViewInit` 中，重构对 `this.userService.getUsers` 的调用，使其从名为 `getUsers` 的方法中调用
- en: 'Then implement a conditional call to `this.userEntityService.getAll()` and
    map out the return value so that it fits the `IUsers` interface:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后实现一个对 `this.userEntityService.getAll()` 的条件调用，并映射出返回值以适应 `IUsers` 接口：
- en: '[PRE57]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now your component can attempt to get data from either source by toggling the
    slide toggle and entering some new search text. However, our endpoint does not
    provide the data in the shape that NgRx Data expects, so we need to customize
    the entity service to overcome this issue.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的组件可以通过切换滑动开关并输入一些新的搜索文本来尝试从任一来源获取数据。然而，我们的端点没有以NgRx Data期望的形状提供数据，因此我们需要自定义实体服务来克服这个问题。
- en: Customizing Entity Service
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义实体服务
- en: You can customize the behavior of NgRx Data in numerous places. We are interested
    in overriding the behavior of the `getAll()` function, so the data we're receiving
    is properly hydrated and the data can be extracted from the item's object.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在多个位置自定义NgRx Data的行为。我们感兴趣的是覆盖`getAll()`函数的行为，以便我们接收到的数据得到适当的初始化，并且可以从项目的对象中提取数据。
- en: For this example, we will not attempt to restore the full pagination functionality
    using NgRx Data. To keep it simple, we focus on just getting an array of data
    into the data table.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们不会尝试使用NgRx Data恢复完整的分页功能。为了保持简单，我们只关注将数据数组获取到数据表中。
- en: 'Update User Entity Service to inject `UserService` and implement a `getAll`
    function that uses it:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 更新用户实体服务以注入`UserService`并实现一个使用它的`getAll`函数：
- en: '[PRE58]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, we're iterating through the item's object and hydrating objects
    with our builder function, thus flattening and transforming `Observable<IUsers>`
    to `Observable<User[]>`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在遍历项目的对象，并使用我们的构建函数初始化对象，从而将`Observable<IUsers>`扁平化和转换为`Observable<User[]>`。
- en: 'After implementing this change, you should be able to see data flow into the
    user table as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 实施此更改后，您应该能够看到数据如下流入用户表：
- en: '![](img/B14094_12_10.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_12_10.png)'
- en: 'Figure 12.10: User table with NgRx Data'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：NgRx Data的用户表
- en: Note that all seven users are displayed at once, and as magnified in the preceding
    screenshot, the pagination functionality is not working. However, this implementation
    is adequate enough to demonstrate what NgRx Data brings to the table.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有七个用户同时显示，如图中放大截图所示，分页功能没有正常工作。然而，这个实现足以展示NgRx Data带来的好处。
- en: So, should you implement NgRx Data in your next app? It depends. Since the library
    is an abstraction layer on top of NgRx, you may find yourself lost and restricted
    if you don't have a good understanding of the internals of NgRx. However, the
    library holds a lot of promise for reducing boilerplate code regarding entity
    data management and CRUD operations. If you're doing lots of CRUD operations in
    your app, you may save time, but be careful to keep the scope of your implementation
    only to the areas that need it. Either way, you should keep an eye out for the
    evolution of this great library.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您应该在您的下一个应用中实现NgRx Data吗？这取决于。由于该库是NgRx之上的抽象层，如果您没有很好地理解NgRx的内部结构，您可能会感到迷茫和受限。然而，该库在减少实体数据管理和CRUD操作方面的样板代码方面有很大的潜力。如果您在应用中执行大量的CRUD操作，您可能会节省时间，但请务必只将实现范围限制在需要它的区域。无论如何，您都应该关注这个伟大库的演变。
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we completed going over all major Angular app design considerations
    using router-first architecture, along with our recipes, to implement a line-of-business
    app with ease. We went over how to edit existing users, leverage a resolve guard
    to load user data, and hydrate and reuse a component in different contexts.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用路由优先架构和我们的食谱完成了对所有主要Angular应用设计考虑因素的回顾，从而轻松实现了一个业务应用。我们回顾了如何编辑现有用户，利用resolve
    guard加载用户数据，以及在不同的上下文中初始化和重用组件。
- en: We implemented a master/detail view using auxiliary routes and demonstrated
    how to build data tables with pagination. We then learned about NgRx and the `@ngrx/data`
    libraries and their impact on our code base using the **local-weather-app** and
    **lemon-mart** projects.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用辅助路由实现了主/详细视图，并展示了如何构建具有分页的数据表。然后我们学习了NgRx和`@ngrx/data`库以及它们对我们代码库的影响，使用了**local-weather-app**和**lemon-mart**项目。
- en: Overall, by using the router-first design, architecture, and implementation
    approach, we tackled our application's design with a good high-level understanding
    of what we wanted to achieve. By identifying code reuse opportunities early on,
    we were able to optimize our implementation strategy to implement reusable components
    ahead of time, without running the risk of grossly over-engineering our solution.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，通过使用路由优先的设计、架构和实现方法，我们以良好的高级理解来应对我们的应用程序设计，以实现我们想要达到的目标。通过早期识别代码复用机会，我们能够优化我们的实现策略，提前实现可重用组件，而不会冒着过度工程化解决方案的风险。
- en: In the next chapter, we will set up a highly available infrastructure on AWS
    to host LemonMart. We will update the project with new scripts to enable no-downtime
    blue-green deployments. Finally, in the last chapter, we will update LemonMart
    with Google Analytics and go over advanced Cloud Ops concerns.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在 AWS 上设置一个高可用性基础设施来托管 LemonMart。我们将更新项目以添加新脚本，以实现无停机时间的蓝绿部署。最后，在最后一章中，我们将更新
    LemonMart 以使用 Google Analytics，并讨论高级云运维问题。
- en: Further reading
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Testing Angular Components With @Input()*, Aiko Klostermann, 2017, available
    at [https://medium.com/better-programming/testing-angular-components-with-input-3bd6c07cfaf6](https://medium.com/better-programming/testing-angular-components-with-input-3bd6c07cfaf6)'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 @Input() 测试 Angular 组件*，艾可·克洛斯特曼，2017，可在[https://medium.com/better-programming/testing-angular-components-with-input-3bd6c07cfaf6](https://medium.com/better-programming/testing-angular-components-with-input-3bd6c07cfaf6)找到'
- en: '*What is NgRx?*, 2020, available at [https://ngrx.io/docs](https://ngrx.io/docs)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*什么是 NgRx？*，2020，可在[https://ngrx.io/docs](https://ngrx.io/docs)找到'
- en: '*NgRx Testing*, 2020, available at [https://ngrx.io/guide/store/testing](https://ngrx.io/guide/store/testing)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NgRx 测试*，2020，可在[https://ngrx.io/guide/store/testing](https://ngrx.io/guide/store/testing)找到'
- en: '*@ngrx/data*, 2020, available at [https://ngrx.io/guide/data](https://ngrx.io/guide/data)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*@ngrx/data*，2020，可在[https://ngrx.io/guide/data](https://ngrx.io/guide/data)找到'
- en: '*NgRx: Action Creators redesigned*, Alex Okrushko, 2019, available at [https://medium.com/angular-in-depth/ngrx-action-creators-redesigned-d396960e46da](https://medium.com/angular-in-depth/ngrx-action-creators-redesigned-d396960e46da)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重新设计 NgRx 的动作创建者*，亚历克斯·奥库什科，2019，可在[https://medium.com/angular-in-depth/ngrx-action-creators-redesigned-d396960e46da](https://medium.com/angular-in-depth/ngrx-action-creators-redesigned-d396960e46da)找到'
- en: '*Simplifying Frontend State Management with Observable Store*, Dan Wahlin,
    2019, available at [https://blog.codewithdan.com/simplifying-front-end-state-management-with-observable-store/](https://blog.codewithdan.com/simplifying-front-end-state-management-with-observable-store/)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Observable Store 简化前端状态管理*，丹·瓦林，2019，可在[https://blog.codewithdan.com/simplifying-front-end-state-management-with-observable-store/](https://blog.codewithdan.com/simplifying-front-end-state-management-with-observable-store/)找到'
- en: Questions
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地回答以下问题，以确保你已理解本章的关键概念，无需使用 Google。你需要帮助回答这些问题吗？请参阅 *附录 D*，*自我评估答案*，可在[https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)在线找到，或访问[https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment)。
- en: What is a resolve guard?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是解析守卫？
- en: What are the benefits of router orchestration?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由编排有什么好处？
- en: What is an auxiliary route?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是辅助路由？
- en: How does NgRx differ from using RxJS/Subject?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NgRx 与使用 RxJS/Subject 有何不同？
- en: What's the value of NgRx data?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NgRx 数据的价值是什么？
- en: 'In `UserTableComponent`, why do we use `readonly isLoadingResults$: BehaviorSubject<Boolean>`
    over a simple Boolean to drive the loading spinner?'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `UserTableComponent` 中，为什么我们使用 `readonly isLoadingResults$: BehaviorSubject<Boolean>`
    而不是简单的布尔值来驱动加载指示器？'
