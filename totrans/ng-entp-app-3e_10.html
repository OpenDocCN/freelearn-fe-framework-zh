<html><head></head><body>
  <div id="_idContainer546" class="Basic-Text-Frame">
    <h1 class="chapterNumber">10</h1>
    <h1 id="_idParaDest-308" class="chapterTitle">Releasing to Production with CI/CD</h1>
    <p class="normal">Ship it or it never happened! If you don’t publish your code, you create zero value. This motivation to ship your work is prevalent in many industries. However, delivering a piece of work to someone else or opening it up to public scrutiny can be terrifying. In software engineering, delivering anything is difficult; delivering something to production is even more difficult.</p>
    <div class="packt_tip">
      <p class="normal">Check out my 2018 talk, <em class="italic">Ship It or It Never Happened: The Power of Docker, Heroku, and CircleCI</em>, at <a href="https://bit.ly/ship-it-or-it-never-happened"><span class="url">https://bit.ly/ship-it-or-it-never-happened</span></a>.</p>
    </div>
    <p class="normal">We live in an era of moving fast and breaking things. However, the latter part of that statement rarely works in an enterprise. You can live on the edge and adopt the YOLO lifestyle, but this doesn’t make good business sense.</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.1: A creative CLI option for a tool</p>
    <p class="normal">In an enterprise project, code has to go through numerous quality gates before it can be merged. In this chapter, we will cover <strong class="keyWord">Continuous Integration</strong> (<strong class="keyWord">CI</strong>) pipelines leveraging GitHub flow and CircleCI, which help teams achieve frequent, reliable, high-quality, and flexible releases.</p>
    <p class="normal">Frequent and reliable releases are only possible if we have a set of automated tests that can quickly verify the correctness of our code for us. Automated testing is critical to ensure your changes don’t introduce regressions. So, we will go over the importance of writing unit tests and <strong class="keyWord">end-to-end</strong> (<strong class="keyWord">e2e</strong>) tests with Cypress.</p>
    <p class="normal">To move fast without breaking things, we need to implement <strong class="keyWord">Continuous Deployment</strong> (<strong class="keyWord">CD</strong>) using DevOps best practices such as <strong class="keyWord">Infrastructure as Code</strong> (<strong class="keyWord">IaC</strong>), so we can verify the correctness of our running code more often.</p>
    <p class="normal">In this chapter, we will cover deploying Angular apps using CLI tools, then go over a Docker-based approach to implement IaC that can be run on most CI services and cloud providers, allowing you to achieve repeatable builds and deployments from any CI environment to any cloud provider. Working with flexible tools, you will avoid overspecializing in one service and keep your configuration management skills relevant across different CI services.</p>
    <div class="packt_tip">
      <p class="normal">This book leverages CircleCI as the CI server. Other notable CI servers are Jenkins, Azure DevOps, and the built-in mechanisms within GitLab and GitHub.</p>
    </div>
    <p class="normal">This chapter covers:</p>
    <ul>
      <li class="bulletList">Automated testing</li>
      <li class="bulletList">Continuous integration</li>
      <li class="bulletList">Deploying to the cloud</li>
      <li class="bulletList">DevOps</li>
      <li class="bulletList">Containerizing web apps using Docker</li>
      <li class="bulletList">Working with containers in the cloud</li>
      <li class="bulletList">Continuous deployment</li>
      <li class="bulletList">Code coverage reports</li>
    </ul>
    <h1 id="_idParaDest-309" class="heading-1">Technical requirements</h1>
    <p class="normal">The following software is required to follow along with this chapter:</p>
    <ul>
      <li class="bulletList">Docker Desktop Community version 4+</li>
      <li class="bulletList">Docker Engine CE version 24+</li>
      <li class="bulletList">CircleCI account</li>
      <li class="bulletList">Vercel account</li>
      <li class="bulletList">Firebase account</li>
      <li class="bulletList">Coveralls account</li>
    </ul>
    <p class="normal">The most up-to-date versions of the sample code for the book are on GitHub at the repositories linked in the following list. The repository contains the final and completed state of the code. Follow the instructions below to find out how to verify your progress as you go through the sections of this chapter.</p>
    <p class="normal">For <em class="italic">Chapter 10</em>:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Clone the repositories <a href="https://github.com/duluca/local-weather-app"><span class="url">https://github.com/duluca/local-weather-app</span></a> and <a href="https://github.com/duluca/lemon-mart"><span class="url">https://github.com/duluca/lemon-mart</span></a>.</li>
      <li class="numberedList">Execute <code class="inlineCode">npm install</code> on the root folder to install dependencies.</li>
    </ol>
    <p class="normal"><code class="inlineCode">package.json</code> contains builds scripts.</p>
    <p class="normal">Note that the <code class="inlineCode">.circleci</code> folder contains extra YAML files.</p>
    <p class="normal">For <strong class="keyWord">local-weather-app</strong>:</p>
    <ol class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList" value="1"><code class="inlineCode">.circleci/config.stage4.yml</code> represents a simple CI pipeline.</li>
      <li class="alphabeticList"><code class="inlineCode">.circleci/config.stage9.yml</code> adds CD with target deployment to Vercel.</li>
      <li class="alphabeticList"><code class="inlineCode">.circleci/config.yml</code> shows an advanced pipeline with parallel builds and automated Cypress tests.</li>
    </ol>
    <p class="normal">For <strong class="keyWord">lemon-mart</strong>:</p>
    <ol class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList" value="1"><code class="inlineCode">.circleci/config.stage9.yml</code> adds CD with target deployment to Vercel.</li>
      <li class="alphabeticList"><code class="inlineCode">.circleci/config.docker-integration.yml</code> demonstrates a container within a container setup with multi-stage Dockerfiles and an AWS ECS Fargate deployment.</li>
      <li class="alphabeticList"><code class="inlineCode">.circleci/config.yml</code> shows an advanced pipeline with parallel builds and automated Cypress tests.</li>
    </ol>
    <p class="normal">Beware that the source code provided in the book and the version on GitHub will likely differ. Cloud services are ever-evolving and changing. If you find errors or have questions, please create an issue or submit a pull request on GitHub.</p>
    <p class="normal">First, let’s understand why automated testing is critical to delivering quality solutions via CI/CD pipelines.</p>
    <h1 id="_idParaDest-310" class="heading-1">Automated testing</h1>
    <p class="normal">As developers, we integrate code<a id="_idIndexMarker1079"/> from various sources into our solutions. This can be from coffee-fueled, long, and tiring code sessions, a copy-pasted StackOverflow answer, a snippet from a blog post, an npm package, or a major library like Angular. We are expected to deliver quality results within the confines of an estimate we threw out there. In these conditions, bugs inevitably end up in our code. When deadlines, ambition, or ill-fated architectural decisions intersect with the regular cadence of coding, things only get worse.</p>
    <p class="normal">Automated tests ensure that the code we write is correct and it stays correct. We rely on CI/CD pipelines for repeatable processes that are not prone to human error, but the pipeline is only as good as the quality of the automated tests we write.</p>
    <p class="normal">Angular has two main categories of tests, unit and e2e tests. Unit tests are meant to be fast and easy to create and execute, and e2e tests are slower and more expensive. However, there’s a problem: Angular unit tests are not unit tests.</p>
    <p class="normal">To understand why, we need a deep dive into unit testing fundamentals to familiarize you with the benefits of test-driven development and cover principles like FIRST and SOLID.</p>
    <h2 id="_idParaDest-311" class="heading-2">Unit testing</h2>
    <p class="normal">Unit testing is crucial to ensure<a id="_idIndexMarker1080"/> that the behavior of your application doesn’t unintentionally<a id="_idIndexMarker1081"/> change over time. Unit tests will enable you and your team to continue making changes to your application without introducing changes to previously verified functionality. Developers<a id="_idIndexMarker1082"/> write unit tests, where each test is scoped to test only the code in the <strong class="keyWord">Function Under Test</strong> (<strong class="keyWord">FUT</strong>) or <strong class="keyWord">Class Under Test</strong> (<strong class="keyWord">CUT</strong>). Unit tests should be plentiful, automated, and fast. You should<a id="_idIndexMarker1083"/> write unit tests alongside the original code. If they are separated from the implementation, even by a day or two, you will start forgetting the details of your code. Because of that, you may forget to write tests for potential edge cases.</p>
    <p class="normal">Unit tests should adhere<a id="_idIndexMarker1084"/> to the FIRST principle:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">F</strong>ast</li>
      <li class="bulletList"><strong class="keyWord">I</strong>solated</li>
      <li class="bulletList"><strong class="keyWord">R</strong>epeatable</li>
      <li class="bulletList"><strong class="keyWord">S</strong>elf-verifying</li>
      <li class="bulletList"><strong class="keyWord">T</strong>imely</li>
    </ul>
    <p class="normal">A unit test should be fast, taking only milliseconds to run, so we can have thousands of them running in just a few minutes. For fast tests to be possible, a unit test should be isolated. It shouldn’t talk to a database, make requests over the network, or interact with the DOM. Isolated tests are going to be repeatable so that every run of the test returns the same result. Predictability means we can assert the correctness of a test without relying on any outside environment, which makes our tests self-verifying. As mentioned earlier, you should write unit tests promptly; otherwise, you lose the benefits of writing unit tests.</p>
    <p class="normal">It is possible to adhere<a id="_idIndexMarker1085"/> to the FIRST principle<a id="_idIndexMarker1086"/> if your tests focus only on a single FUT/CUT. But what about other classes, services, or parameters we must pass into the FUT/CUT? A unit test can isolate the behavior of the FUT/CUT by leveraging test doubles. A test double allows us to control outside dependencies, so instead of injecting an <code class="inlineCode">HttpService</code> to your component, you may inject a fake or mocked <code class="inlineCode">HttpService</code>. Using test doubles, we can control the effects of outside dependencies and create fast and repeatable tests.</p>
    <div class="packt_tip">
      <p class="normal">How much testing is enough testing? You should have at least as much test code as production code. If you don’t, then you’re nowhere near writing enough tests.</p>
      <p class="normal">See the <em class="italic">Further reading</em> section for literature going back 20+ years on this.</p>
    </div>
    <p class="normal">Unit tests aren’t the only kind of tests you can create, but they are by far the kind you should create the most of. Consider the three kinds of tests you can create: unit, integration, and UI.</p>
    <p class="normal">As we’ve said, unit tests only focus on one FUT/CUT at a time. Integration tests test the integration of various components so that they can include database calls, network requests, and interaction with the DOM. Due to their nature, integration tests are slow to run and must be frequently maintained. Increases in runtime and maintenance mean that integration tests are more expensive than unit tests over time. UI tests test the application as if a user were using it, filling in fields, clicking buttons, and observing the expected outcome.</p>
    <p class="normal">You may imagine that these tests are the slowest and most fragile kind of tests. The UI of an application changes frequently, and it is very tough to create repeatable tests with UI testing.</p>
    <div class="note">
      <p class="normal">We can leverage integration and UI testing to create acceptance tests. Acceptance tests are written to automate the business acceptance of our functionality. Angular’s e2e tests are a way to create acceptance tests.</p>
    </div>
    <p class="normal">We can visualize the pros and cons of the three major classes of automated testing with Mike Cohn’s testing pyramid, shown as follows:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_02.png" alt="A picture containing text, screenshot, font, design  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.2: Mike Cohn’s testing pyramid</p>
    <p class="normal">The testing pyramid<a id="_idIndexMarker1087"/> effectively summarizes the relative amount of tests<a id="_idIndexMarker1088"/> of each kind we should create for our applications while considering their speed and cost.</p>
    <p class="normal">Given the description and expectations of unit tests, you can now begin understanding why <strong class="keyWord">Angular unit tests are not really unit tests</strong>. As I explained in the <em class="italic">Component architecture </em>section of <em class="chapterRef">Chapter 1</em>, <em class="italic">Angular’s Architecture and Concepts</em>, an Angular component consists of a component class and a template. To truly test a component, we must interact with the DOM. This is why Angular tests must utilize <code class="inlineCode">TestBed</code> to execute. Further, the dependency injection can be very cumbersome to configure and mock. Ultimately, <code class="inlineCode">TestBed</code> is slow and fragile compared to true unit tests.</p>
    <div class="note">
      <p class="normal">Consider using Spectator to simplify your Angular tests. Spectator aims to help you get rid of all the boilerplate grunt work, focusing on readable and streamlined unit tests.</p>
      <p class="normal">More info can be found at <a href="https://github.com/ngneat/spectator"><span class="url">https://github.com/ngneat/spectator</span></a>.</p>
    </div>
    <div class="packt_tip">
      <p class="normal">Standalone components are much easier to configure because they define their dependencies, and we no longer need to introduce modules to <code class="inlineCode">TestBed</code>.</p>
    </div>
    <p class="normal">What does all this mean for Angular? Within this reality, unit testing a component is a waste of time. You should extract all business logic into services and functions and test those thoroughly. Hopefully, future updates to the Angular unit testing setup will change this situation.</p>
    <div class="packt_tip">
      <p class="normal">Cypress component tests are a great way to integration test individual components’ functionality. Follow the instructions in the next section to set Cypress up for your project.</p>
      <p class="normal">More information about<a id="_idIndexMarker1089"/> component testing is at <a href="https://docs.cypress.io/guides/component-testing/angular/overview"><span class="url">https://docs.cypress.io/guides/component-testing/angular/overview</span></a>.</p>
    </div>
    <div class="note">
      <p class="normal">Beginning with Angular 17.1, you can swap<a id="_idIndexMarker1090"/> out the Karma test runner with the modern <strong class="keyWord">Web Test Runner</strong>. You can set it up with the following instructions:</p>
      <pre class="programlisting con"><code class="hljs-con">$ npm i -D @web/test-runner
</code></pre>
      <p class="normal">Update <code class="inlineCode">angular.json</code> with:</p>
      <pre class="programlisting code"><code class="hljs-code">"test": {
  "builder": "@angular-devkit/build-angular:web-test-runner"
}
</code></pre>
      <p class="normal">You can read<a id="_idIndexMarker1091"/> more at <a href="https://modern-web.dev/docs/test-runner/overview"><span class="url">https://modern-web.dev/docs/test-runner/overview</span></a>.</p>
    </div>
    <p class="normal">To test UI and template<a id="_idIndexMarker1092"/> logic, Angular e2e tests will deliver the best bang<a id="_idIndexMarker1093"/> for the buck, and now you can configure Cypress as the default e2e provider for your application.</p>
    <h2 id="_idParaDest-312" class="heading-2">Cypress e2e tests</h2>
    <p class="normal">While unit tests focus on isolating<a id="_idIndexMarker1094"/> the CUT, e2e tests are about integration<a id="_idIndexMarker1095"/> testing. I highly recommend that you configure Cypress as your e2e provider by executing:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npx ng add @cypress/schematic
</code></pre>
    <div class="packt_tip">
      <p class="normal">You can read more about<a id="_idIndexMarker1096"/> the Cypress integration at <a href="https://www.npmjs.com/package/@cypress/schematic"><span class="url">https://www.npmjs.com/package/@cypress/schematic</span></a>.</p>
    </div>
    <p class="normal">Cypress allows you to easily create tests for your modern web applications, debug them visually, and automatically run them in your CI builds. You can read more about Cypress at <a href="https://www.cypress.io/"><span class="url">https://www.cypress.io/</span></a>.</p>
    <p class="normal">e2e tests allow you to write <strong class="keyWord">Automated Acceptance Tests</strong> (<strong class="keyWord">AATs</strong>) from the perspective of a user interacting with your application<a id="_idIndexMarker1097"/> in a browser. Cypress tests are easy to create and run. By using the <code class="inlineCode">data-testid</code> attribute on HTML components, you can make them less fragile.</p>
    <p class="normal">You can find sample<a id="_idIndexMarker1098"/> Cypress tests for <strong class="keyWord">local-weather-app</strong> and <strong class="keyWord">lemon-mart</strong> under the <code class="inlineCode">cypress</code><code class="inlineCode"><a id="_idIndexMarker1099"/></code> folder.</p>
    <p class="normal">You can execute the tests in development by executing:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npx ng e2e 
</code></pre>
    <p class="normal">For CI, you can use the following commands:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npx ng run local-weather-app:cypress-run
<span class="hljs-con-meta">$</span> npx ng run lemon-mart:cypress-run
</code></pre>
    <p class="normal">In <code class="inlineCode">local-weather-app</code>, check out the <code class="inlineCode">cypress/e2e/app.cy.ts</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">cypress/e2e/app.</strong><strong class="hljs-property-slc">cy</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'../support/commands'</span>
<span class="hljs-title">describe</span>(<span class="hljs-string">'LocalCast Weather'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">beforeEach</span>(<span class="hljs-function">() =&gt;</span> {
    cy.<span class="hljs-title">visit</span>(<span class="hljs-string">'/'</span>)
  })
  <span class="hljs-title">it</span>(<span class="hljs-string">'has the correct title'</span>, <span class="hljs-function">() =&gt;</span> {
    cy.<span class="hljs-title">byTestId</span>(<span class="hljs-string">'title'</span>).<span class="hljs-title">should</span>(<span class="hljs-string">'</span><span class="hljs-string">have.text'</span>, <span class="hljs-string">'LocalCast Weather'</span>)
  })
})
</code></pre>
    <p class="normal">In the <code class="inlineCode">cypress/support/commands.ts</code> <code class="inlineCode">file</code>, I implemented a helper function called <code class="inlineCode">byTestId</code>, which finds an HTML element containing the <code class="inlineCode">data-testid</code> attribute with the given name. In this case, <code class="inlineCode">cy.byTestId("title")</code> will find the following element:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/app.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
&lt;span data-testid=<span class="hljs-string">"title"</span>&gt;<span class="hljs-title">LocalCast</span> <span class="hljs-title">Weather</span>&lt;/span&gt;
</code></pre>
    <p class="normal">The test will work even if the element<a id="_idIndexMarker1100"/> moves around on the page. Using test IDs makes it easy and convenient to write<a id="_idIndexMarker1101"/> more dependable tests.</p>
    <div class="note">
      <p class="normal">Building robust and maintainable e2e code requires some additional concepts like Page Objects. You can learn<a id="_idIndexMarker1102"/> more about Page Objects at <a href="https://docs.cypress.io/guides/end-to-end-testing/protractor-to-cypress#Using-Page-Objects"><span class="url">https://docs.cypress.io/guides/end-to-end-testing/protractor-to-cypress#Using-Page-Objects</span></a> and other<a id="_idIndexMarker1103"/> best practices at <a href="https://docs.cypress.io/guides/references/best-practices"><span class="url">https://docs.cypress.io/guides/references/best-practices</span></a>.</p>
    </div>
    <p class="normal">Next, let’s set up CI to ensure that our tests always run before we deploy the app to production.</p>
    <h1 id="_idParaDest-313" class="heading-1">Continuous integration</h1>
    <p class="normal">Before pushing your code<a id="_idIndexMarker1104"/> to production, you should enable CI. This simple tool helps ensure we don’t ship broken code to production by executing automated tasks, including the execution of tests, every time we make changes to our code.</p>
    <h2 id="_idParaDest-314" class="heading-2">CircleCI</h2>
    <p class="normal"><strong class="keyWord">CircleCI</strong> makes it easy to get started, with a free<a id="_idIndexMarker1105"/> tier and excellent documentation for beginners and pros alike. If you have unique enterprise needs, CircleCI can be brought on-premises, behind corporate firewalls, or as a private deployment in the cloud.</p>
    <p class="normal">CircleCI has pre-baked<a id="_idIndexMarker1106"/> build environments for the virtual configuration of free setups, but it can also run builds using Docker containers, making it a solution that scales to the user’s skills and needs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a CircleCI account at <a href="https://circleci.com/"><span class="url">https://circleci.com/</span></a>.</li>
      <li class="numberedList">Navigate to <strong class="screenText">Projects</strong> to add a new project.</li>
      <li class="numberedList">Search for <code class="inlineCode">local-weather-app</code> and click on <strong class="screenText">Set Up Project</strong>.</li>
      <li class="numberedList">Follow the on-screen prompts to create a sample <code class="inlineCode">.yml</code> file. Hello World or Node.js works, but you will replace the content anyway.<div class="note">
          <p class="normal">This section uses the <strong class="keyWord">local-weather-app</strong> repo. The <code class="inlineCode">config.yml</code> file for this section is named <code class="inlineCode">.circleci/config.stage4.yml</code>.</p>
        </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Copy the following <code class="inlineCode">.yml</code> content<a id="_idIndexMarker1107"/> into the file:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">.circleci/config.yml</strong></span>
<span class="hljs-attr">version:</span> <span class="hljs-number">2.1</span>
<span class="hljs-attr">orbs:</span>
  <span class="hljs-attr">browser-tools:</span> <span class="hljs-string">circleci/browser-tools@1</span>
  <span class="hljs-attr">cypress:</span> <span class="hljs-string">cypress-io/cypress@3</span>
<span class="hljs-attr">commands:</span>
  <span class="hljs-attr">install:</span>
    <span class="hljs-attr">description:</span> <span class="hljs-string">'Install project dependencies'</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">checkout</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">restore_cache:</span>
          <span class="hljs-attr">keys:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">node_modules-{{</span> <span class="hljs-string">checksum</span> <span class="hljs-string">"package-lock.json"</span> <span class="hljs-string">}}</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">save_cache:</span>
          <span class="hljs-attr">key:</span> <span class="hljs-string">node_modules-{{</span> <span class="hljs-string">checksum</span> <span class="hljs-string">"package-lock.json"</span> <span class="hljs-string">}}</span>
          <span class="hljs-attr">paths:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">node_modules</span>
  <span class="hljs-attr">lint:</span>
    <span class="hljs-attr">description:</span> <span class="hljs-string">'Check for code style and linting errors'</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">style</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">lint</span>
  <span class="hljs-attr">build_and_test:</span>
    <span class="hljs-attr">description:</span> <span class="hljs-string">'Builds and tests Angular project'</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npx</span> <span class="hljs-string">ng</span> <span class="hljs-string">build</span> <span class="hljs-string">--configuration</span> <span class="hljs-string">production</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">attach_workspace:</span>
          <span class="hljs-attr">at:</span> <span class="hljs-string">~/</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">browser-tools/install-chrome</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">browser-tools/install-chromedriver</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npx</span> <span class="hljs-string">ng</span> <span class="hljs-string">test</span> <span class="hljs-string">--watch=false</span> <span class="hljs-string">--code-coverage</span>
  <span class="hljs-attr">store:</span>
    <span class="hljs-attr">description:</span> <span class="hljs-string">'Stores build_and_test artifacts'</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">store_test_results:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">./test_results</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">store_artifacts:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">./coverage</span>
<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">run_build_and_test:</span>
    <span class="hljs-attr">docker:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">cimg/node:lts-browsers</span>
    <span class="hljs-attr">working_directory:</span> <span class="hljs-string">~/repo</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">install</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">cypress/install</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">lint</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build_and_test</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npx</span> <span class="hljs-string">ng</span> <span class="hljs-string">run</span> <span class="hljs-string">local-weather-app:cypress-run</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">store</span>
<span class="hljs-attr">workflows:</span>
  <span class="hljs-attr">build-and-test:</span>
    <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">run_build_and_test</span>
</code></pre>
      </li>
      <li class="numberedList">Select <strong class="screenText">Commit</strong> and <strong class="screenText">Run</strong>.</li>
      <li class="numberedList">CircleCI should run on a new branch.</li>
    </ol>
    <p class="normal">If everything goes well, you should<a id="_idIndexMarker1108"/> have a passing, <em class="italic">green</em> build. If not, you<a id="_idIndexMarker1109"/> will see a failed, <em class="italic">red</em> build.</p>
    <p class="normal">When you have a green build, you can leverage CircleCI to enforce the execution of your automated pipeline with every code push. GitHub flow allows us to control how code flows into our repositories.</p>
    <h2 id="_idParaDest-315" class="heading-2">GitHub flow</h2>
    <p class="normal">The main reason we’re developing software<a id="_idIndexMarker1110"/> is to deliver value. In automating<a id="_idIndexMarker1111"/> the way we deliver software, we are creating a value delivery stream. It is easy to deliver broken software; however, to reliably deliver value, each change to the code base should flow through a stream of checks and balances.</p>
    <p class="normal">With control gates, we can enforce standards, make our quality control process repeatable for every team member, and have the ability to isolate changes. If something goes wrong or the work doesn’t live up to your standards, you can easily discard the proposed changes and restart.</p>
    <p class="normal">GitHub flow is an essential part of defining a value delivery stream and implementing control gates. As GitHub puts it, “<em class="italic">GitHub flow is a lightweight, branch-based workflow that supports teams and projects where deployments are made regularly</em>.”</p>
    <p class="normal">GitHub flow consists of six steps, as shown in the following graphic from GitHub:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.3: GitHub flow diagram</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><strong class="keyWord">Branch</strong> – always add new code for a bug or a feature in a new branch</li>
      <li class="numberedList"><strong class="keyWord">Commit</strong> – make multiple commits to your branch</li>
      <li class="numberedList"><strong class="keyWord">Create a pull request</strong> – signal the readiness of your work to your team members and view CI results in a pull request</li>
      <li class="numberedList"><strong class="keyWord">Discuss and review</strong> – request a review of your code changes, address general or line-level comments, and make necessary modifications</li>
      <li class="numberedList"><strong class="keyWord">Deploy</strong> – optionally test your code on a test server or staging server with the ability to roll back to the main branch</li>
      <li class="numberedList"><strong class="keyWord">Merge</strong> – apply your changes to the main branch</li>
    </ol>
    <p class="normal">You can use GitHub flow to ensure that only high-quality code ends up in the main branch. A solid foundation sets other team members up for success when making changes. You must restrict push access to the main branch to enforce GitHub flow.</p>
    <p class="normal">Let’s enable<a id="_idIndexMarker1112"/> branch protection <a id="_idIndexMarker1113"/>for the main branch:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Navigate to the GitHub <strong class="screenText">Settings</strong> tab for your project.</li>
      <li class="numberedList">Select <strong class="screenText">Branches</strong> from the left navigation pane.</li>
      <li class="numberedList">If a rule exists for your main branch, click the <strong class="keyWord">Edit</strong> or <strong class="screenText">Add rule</strong> button.</li>
      <li class="numberedList">Enter <code class="inlineCode">main</code> as the branch name pattern.</li>
      <li class="numberedList">Enable the following options:<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">Require a pull request before merging.</li>
          <li class="alphabeticList">Require approvals from at least one peer.</li>
          <li class="alphabeticList">Dismiss stale pull request approvals.</li>
          <li class="alphabeticList">Require status checks to pass before merging.</li>
          <li class="alphabeticList">Require branches to be up to date before merging.</li>
          <li class="alphabeticList">Require linear history.</li>
        </ol>
      </li>
      <li class="numberedList">Search for <code class="inlineCode">CircleCI</code> and select the CI job that must succeed, in this case: <code class="inlineCode">run_build_and_test</code></li>
      <li class="numberedList">After you’ve saved your changes, you should see your new rule on the <strong class="screenText">Branches</strong> page as shown:
    <figure class="mediaobject"><img src="../Images/B20960_10_04.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.4: GitHub Branches</p></li>
    </ol>
    <p class="normal">You are no longer able to commit code to your main branch directly. To commit code, you first need to create a branch from the main branch, commit your changes to the new branch, and create a pull request using the new branch when you’re ready. If you’re unfamiliar with <code class="inlineCode">git</code> commands, you can use GitHub Desktop to assist you with these operations. See the handy <strong class="screenText">Branch</strong> menu in GitHub Desktop here:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.5: GitHub Desktop Branch menu</p>
    <p class="normal">After creating a pull request, you can<a id="_idIndexMarker1114"/> now observe checks running against<a id="_idIndexMarker1115"/> your branch. Now that we have CircleCI configured, if everything went well, you should be able to merge a pull request, as shown:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_06.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.6: GitHub.com status checks passing</p>
    <p class="normal">When the checks fail, you are forced<a id="_idIndexMarker1116"/> to fix any issues before you can merge<a id="_idIndexMarker1117"/> the new code. Also, you may run into merge conflicts if a team member merged to the main branch while you were working on your branch. In this case, you may use GitHub Desktop’s <strong class="screenText">Update from master</strong> feature for your branch to catch up with the latest main branch.</p>
    <p class="normal">Observe the state of a failing pull request in the following image:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_07.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.7: GitHub.com status checks failing</p>
    <div class="packt_tip">
      <p class="normal">Note that I have an additional check, DeepScan, which runs additional tests against my code base. You<a id="_idIndexMarker1118"/> can register your repository with DeepScan at <a href="https://deepscan.io"><span class="url">https://deepscan.io</span></a>. Later in the chapter, I demonstrate how you can enforce unit test code coverage using Coveralls.</p>
    </div>
    <p class="normal">For more information, refer to <a href="https://guides.github.com/introduction/flow"><span class="url">https://guides.github.com/introduction/flow</span></a>.</p>
    <p class="normal">Now that we have ensured<a id="_idIndexMarker1119"/> that our automated checks<a id="_idIndexMarker1120"/> are being enforced, we can be reasonably sure that we won’t push a broken app to production. Next, let’s learn how we can deploy our app to the cloud.</p>
    <h1 id="_idParaDest-316" class="heading-1">Deploying to the cloud</h1>
    <p class="normal">If delivering something to production<a id="_idIndexMarker1121"/> is difficult from a coding perspective, it is very complicated to do it right from an infrastructure perspective. Deploying solutions in the full-fledged versions of Azure, AWS, and Google Cloud is complicated. To deliver quick results, we can leverage cloud services that can serve the <code class="inlineCode">dist</code> folder of our Angular app within minutes.</p>
    <p class="normal">One such service is Vercel, and another is Firebase, which can leverage the <code class="inlineCode">ng deploy</code> command.</p>
    <h2 id="_idParaDest-317" class="heading-2">Vercel</h2>
    <p class="normal">Vercel, <a href="https://vercel.com"><span class="url">https://vercel.com</span></a>, is a multi-cloud service<a id="_idIndexMarker1122"/> that enables real-time global deployments<a id="_idIndexMarker1123"/> of applications directly from the CLI. Vercel works with static files, Node.js, PHP, Go applications, and any custom stack of software you’re willing to write a custom builder for, making it quite straightforward. Vercel has a free tier that you can use to deploy the <code class="inlineCode">dist</code> folder of your Angular applications very quickly.</p>
    <p class="normal">Install the <code class="inlineCode">vercel</code> package to your project and run the <code class="inlineCode">login</code> command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npm i -D vercel
<span class="hljs-con-meta">$</span> npx vercel login
</code></pre>
    <p class="normal">Follow the on-screen prompts<a id="_idIndexMarker1124"/> to complete the login process. Now, let’s configure the <code class="inlineCode">publish</code> script.</p>
    <h2 id="_idParaDest-318" class="heading-2">Deploying static files</h2>
    <p class="normal">After you build an Angular<a id="_idIndexMarker1125"/> project, the build output resides in the <code class="inlineCode">dist</code> folder. The files in this folder are considered static files; all a web server needs to do is deliver these files to a client browser, unmodified, and then the browser executes your code dynamically.</p>
    <p class="normal">This means that any web server can serve up your Angular project. However, <code class="inlineCode">vercel</code> makes it exceedingly easy and free to pull off.</p>
    <div class="note">
      <p class="normal">This section uses the <strong class="keyWord">local-weather-app</strong> repository.</p>
    </div>
    <p class="normal">Let’s begin deploying your Angular app using Vercel’s static file hosting capabilities:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add two new scripts to <code class="inlineCode">package.json</code>, as shown:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">package.json</strong></span>
...
<span class="hljs-attr">"prevercel:publish"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm run build:prod"</span><span class="hljs-punctuation">,</span>
<span class="hljs-attr">"vercel:publish"</span><span class="hljs-punctuation">:</span> 
  <span class="hljs-string">"vercel deploy --prod dist/local-weather-app --yes"</span>
</code></pre>
      </li>
      <li class="numberedList">Execute <code class="inlineCode">npm run vercel:publish</code>.</li>
      <li class="numberedList">Follow the on-screen commands to accept first-use settings.
    <p class="normal">In the terminal window, observe that the Angular project is built first and then uploaded to <code class="inlineCode">vercel</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npm run vercel:publish 
...
Build at: 2023-11-07T03:51:23.229Z - Hash: d6b1388088df7136 - Time: 5403ms
...
<img src="../Images/B20960_10_001.png" alt="" role="presentation"/>  Production: https://local-weather-hhk9xi3wz-duluca.vercel.app [1s] to clipboard] [4s]
</code></pre></li>
    </ol>



    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Follow the URL displayed on the screen to see that your app has been successfully <a id="_idIndexMarker1126"/>deployed.</li>
    </ol>
    <p class="normal">And you’re done! Congratulations, your Angular app is live on the internet!</p>
    <h2 id="_idParaDest-319" class="heading-2">Firebase</h2>
    <p class="normal">Firebase, <a href="https://firebase.google.com/"><span class="url">https://firebase.google.com/</span></a>, is an app development <a id="_idIndexMarker1127"/>platform that helps you build<a id="_idIndexMarker1128"/> and grow apps and games users love. It is backed by Google and trusted by millions of businesses around the world.</p>
    <p class="normal">In the Firebase authentication recipe section of <em class="chapterRef">Chapter 6</em>, <em class="italic">Implementing Role-Based Navigation</em>, you created a Firebase app for LemonMart and deployed your app using <strong class="keyWord">firebase deploy</strong>. We will leverage the account you created to deploy LemonMart to Firebase hosting using the new <code class="inlineCode">ng</code> <code class="inlineCode">deploy</code> command instead.</p>
    <h2 id="_idParaDest-320" class="heading-2">ng deploy</h2>
    <p class="normal"><code class="inlineCode">ng</code> <code class="inlineCode">deploy</code> is a new CLI command<a id="_idIndexMarker1129"/> that helps cloud services offer seamless integration with Angular, so you can easily deploy your app to the cloud.</p>
    <p class="normal">Now let’s configure the LemonMart project using <code class="inlineCode">@angular/fire</code>.</p>
    <div class="note">
      <p class="normal">This section uses the <strong class="keyWord">lemon-mart</strong> repository.</p>
    </div>
    <p class="normal">Execute the following command and make sure to select <code class="inlineCode">ng</code> <code class="inlineCode">deploy</code> -- <code class="inlineCode">hosting</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npx ng add @angular/fire
<img src="../Images/B20960_10_002.png" alt="" role="presentation"/> ng deploy -- hosting
</code></pre>
    <p class="normal">This will create a <code class="inlineCode">deploy</code> configuration in <code class="inlineCode">angular.json</code> and add or update existing Firebase configuration files.</p>
    <p class="normal">For LemonMart, I modified <code class="inlineCode">angular.json</code> so it would automatically build using the Firebase authentication mode:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">angular.json</strong></span>
...
<span class="hljs-attr">"deploy"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"builder"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"</span><span class="hljs-string">@angular/fire:deploy"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"options"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"browserTarget"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"lemon-mart:build:firebase"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">The Firebase configuration is defined under the <strong class="screenText">Configurations</strong> options, and it uses <code class="inlineCode">environment.firebase.ts</code> to build the app.</p>
    <p class="normal">I also modified <code class="inlineCode">firebase.json</code> to deploy <code class="inlineCode">dist/lemon-mart</code>, because the repository is configured as a multi-project Angular app. However, you shouldn’t need to modify the auto-generated files.</p>
    <p class="normal">Execute the following command to deploy:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npx ng deploy
...
Build at: 2023-11-07T04:27:36.842Z - Hash: ad999f95a270f4e6 - Time: 14141ms
=== Deploying to 'lemon-mart-007'...
...
<img src="../Images/B20960_10_003.png" alt="" role="presentation"/>  Deploy complete!
Project Console: https://console.firebase.google.com/project/lemon-mart-007/overview
Hosting URL: https://lemon-mart-007.web.app
</code></pre>
    <p class="normal">Follow the URL on the screen to see that your app has been successfully deployed.</p>
    <p class="normal"><code class="inlineCode">ng</code> <code class="inlineCode">deploy</code> offers a better integrated and simpler option compared to using platform-specific CLI commands. Working with CLI commands<a id="_idIndexMarker1130"/> is great, but one command that works on one machine can easily fail on another. IaC is the only way high-performing enterprise teams can deliver high-quality code with speed. However, to get there, we first need to understand what DevOps is.</p>
    <h1 id="_idParaDest-321" class="heading-1">DevOps</h1>
    <p class="normal">DevOps is the marriage of development<a id="_idIndexMarker1131"/> and operations. It is well established for development that code repositories like Git track every code change. In operations, there has long been a wide variety of techniques to track changes to environments, including scripts and various tools that aim to automate the provisioning of operating systems and servers.</p>
    <p class="normal">How often have you heard the saying, “It works on my machine”? Developers often use that line as a joke. Still, it is often the case that software that works perfectly well on a test server ends up running into issues on a production server due to minor differences in configuration.</p>
    <p class="normal">Earlier, we discussed how GitHub flow<a id="_idIndexMarker1132"/> can enable us to create a value delivery stream. We always branch from the main branch before making a change, enforce that change to go through our CI pipeline, and, once we’re reasonably sure that our code works, merge back to the main branch. See the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_08.png" alt="A line of dots and lines with a black background  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.8: Branching and merging</p>
    <div class="packt_tip">
      <p class="normal">Remember, your main branch should always be deployable, and you should frequently merge your work with the main branch.</p>
    </div>
    <p class="normal">Docker allows us to define the software and the specific configuration parameters that our code depends on in a declarative manner using a special file named a Dockerfile. Similarly, CircleCI allows us to define the configuration of our CI environment in a <code class="inlineCode">config.yml</code> file. By storing our configuration in files, we can check the files alongside our code. We can track changes using Git and enforce them to be verified by our CI pipeline. </p>
    <p class="normal">By storing the definition of our infrastructure in code, we achieve IaC, we also achieve repeatable integration, so no matter what environment we run our infrastructure in, we should be able to stand up our full-stack app with a one-line command.</p>
    <p class="normal">You may remember that in <em class="chapterRef">Chapter 1</em>, <em class="italic">Angular’s Architecture and Concepts</em>, we covered how TypeScript covers the JavaScript feature gap. Like TypeScript, Docker covers the configuration gap, as demonstrated in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_09.png" alt="A diagram of a diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.9: Covering the configuration gap</p>
    <p class="normal">By using Docker, we can be reasonably sure that our code, which worked on our machine during testing, will work the same way when we ship it.</p>
    <p class="normal">In summary, DevOps<a id="_idIndexMarker1133"/> brings operations closer to development, where it is cheaper to make changes and resolve issues. So, DevOps is primarily a developer’s responsibility, but it is also a way of thinking that the operations team must be willing to support. Let’s dive deeper into Docker.</p>
    <h1 id="_idParaDest-322" class="heading-1">Containerizing web apps using Docker</h1>
    <p class="normal">Docker, which can be found at <a href="https://docker.io"><span class="url">https://docker.io</span></a>, is an open platform<a id="_idIndexMarker1134"/> for developing, shipping, and running<a id="_idIndexMarker1135"/> applications. Docker<a id="_idIndexMarker1136"/> combines a lightweight container virtualization platform with workflows and tooling that help manage and deploy applications. The most obvious difference between <strong class="keyWord">Virtual Machines</strong> (<strong class="keyWord">VMs</strong>) and Docker containers is that VMs<a id="_idIndexMarker1137"/> are usually dozens of gigabytes in size and require gigabytes of memory, whereas containers take up megabytes in terms of disk and memory size requirements. Furthermore, the Docker platform abstracts away host <strong class="keyWord">Operating System</strong> (<strong class="keyWord">OS</strong>)-level configuration settings, so every piece of configuration that is needed to<a id="_idIndexMarker1138"/> successfully run an application<a id="_idIndexMarker1139"/> is encoded within a human-readable format.</p>
    <h2 id="_idParaDest-323" class="heading-2">Anatomy of a Dockerfile</h2>
    <p class="normal">A Dockerfile consists<a id="_idIndexMarker1140"/> of four main parts:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">FROM</strong> – where we can inherit <a id="_idIndexMarker1141"/>from Docker’s minimal “scratch” image or a pre-existing image</li>
      <li class="bulletList"><strong class="keyWord">SETUP</strong> – where we configure<a id="_idIndexMarker1142"/> software dependencies to our requirements</li>
      <li class="bulletList"><strong class="keyWord">COPY</strong> – where we copy our built<a id="_idIndexMarker1143"/> code into the operating environment</li>
      <li class="bulletList"><strong class="keyWord">CMD</strong> – where we specify the commands<a id="_idIndexMarker1144"/> that will bootstrap the operating environment</li>
    </ul>
    <div class="packt_tip">
      <p class="normal">Bootstrap refers to a set of initial instructions<a id="_idIndexMarker1145"/> that describe how a program loads or starts up.</p>
    </div>
    <p class="normal">Consider the following visualization of the anatomy of a Dockerfile:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_10.png" alt="A screenshot of a computer program  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.10: Anatomy of a Dockerfile</p>
    <p class="normal">A concrete representation of a Dockerfile is demonstrated in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">Dockerfile</strong></span>
<span class="hljs-keyword">FROM</span> duluca/minimal-nginx-web-server:<span class="hljs-number">1</span>-alpine
<span class="hljs-keyword">COPY</span> /dist/local-weather-app /var/www
<span class="hljs-keyword">CMD</span> <span class="hljs-string">'nginx'</span>
</code></pre>
    <p class="normal">You can map the <code class="inlineCode">FROM</code>, <code class="inlineCode">COPY</code>, and <code class="inlineCode">CMD</code> parts<a id="_idIndexMarker1146"/> of the script to the visualization. We inherit from the <code class="inlineCode">duluca/minimal-nginx-web-server</code> image using the <code class="inlineCode">FROM</code> command. Then, we copy the compiled result of our app from our development machine or build environment into the image using the <code class="inlineCode">COPY</code> (or, alternatively, the <code class="inlineCode">ADD</code>) command. Finally, we instruct the container to execute the nginx web server using the <code class="inlineCode">CMD</code> (or, alternatively, the <code class="inlineCode">ENTRYPOINT</code>) command.</p>
    <p class="normal">Note that the preceding <code class="inlineCode">Dockerfile</code> doesn’t have a distinct <code class="inlineCode">SETUP</code> part. <code class="inlineCode">SETUP</code> doesn’t map to an actual <code class="inlineCode">Dockerfile</code> command but represents a collection of commands you can execute to set up your container. In this case, all the necessary setup was done by the base image, so there are no additional commands to run.</p>
    <div class="note">
      <p class="normal">Common <code class="inlineCode">Dockerfile</code> commands are <code class="inlineCode">FROM</code>, <code class="inlineCode">COPY</code>, <code class="inlineCode">ADD</code>, <code class="inlineCode">RUN</code>, <code class="inlineCode">CMD</code>, <code class="inlineCode">ENTRYPOINT</code>, <code class="inlineCode">ENV</code>, and <code class="inlineCode">EXPOSE</code>. For the<a id="_idIndexMarker1147"/> full <code class="inlineCode">Dockerfile</code> reference, refer to <a href="https://docs.docker.com/engine/reference/builder/"><span class="url">https://docs.docker.com/engine/reference/builder/</span></a>.</p>
    </div>
    <p class="normal">The <code class="inlineCode">Dockerfile</code> describes a new container that inherits from a container named <code class="inlineCode">duluca/minimal-nginx-web-server</code>. This is a container that I published on Docker Hub, which inherits from the <code class="inlineCode">nginx:alpine</code> image, which itself inherits from the <code class="inlineCode">alpine</code> image. The <code class="inlineCode">alpine</code> image is a minimal Linux operating environment that is only 5 MB in size. The <code class="inlineCode">alpine</code> image itself inherits from <code class="inlineCode">scratch</code>, which is an empty image. See the inheritance hierarchy demonstrated in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_11.png" alt="A screenshot of a computer screen  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.11: Docker inheritance</p>
    <p class="normal">The <code class="inlineCode">Dockerfile</code> then copies<a id="_idIndexMarker1148"/> the contents of the <code class="inlineCode">dist</code> folder from your development environment into the container’s <code class="inlineCode">www</code> folder, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_12.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.12: Copying code into a containerized web server</p>
    <p class="normal">In this case, the parent image is configured with an <code class="inlineCode">nginx</code> server to act as a web server to serve the content inside the <code class="inlineCode">www</code> folder. At this point, our source code is accessible from the internet but lives inside layers of secure environments. Even if our app has a vulnerability of some kind, it would be tough for an attacker to harm the systems we are operating on. The following diagram demonstrates the layers of security that Docker provides:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_13.png" alt="A diagram of a software development  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.13: Docker security</p>
    <p class="normal">In summary, at the base layer, our host<a id="_idIndexMarker1149"/> OS, such as Windows or macOS, runs the Docker runtime, which will be installed in the next section. The Docker runtime can run self-contained Docker images, which the aforementioned Dockerfile defines. <code class="inlineCode">duluca/minimal-nginx-web-server</code> is based on the lightweight Linux operating system, Alpine. Alpine is a completely pared-down version of Linux that doesn’t come with any GUI, drivers, or even most of the CLI tools you may expect from a Linux system. As a result, the OS is only ~5 MB in size. We then inherit from the <code class="inlineCode">nginx</code> image, which installs the web server, which itself is around a few megabytes in size. Finally, our custom <code class="inlineCode">nginx</code> configuration is layered over the default image, resulting in a tiny ~7 MB image. The <code class="inlineCode">nginx</code> server is configured to serve the contents of the <code class="inlineCode">/var/www</code> folder. In the <code class="inlineCode">Dockerfile</code>, we merely copy the contents of the <code class="inlineCode">/dist</code> folder in our development environment and place it into the <code class="inlineCode">/var/www</code> folder. We will later build and execute this image, which will run our <code class="inlineCode">nginx</code> web server containing the output of our <code class="inlineCode">dist</code> folder. I have published a similar image named <code class="inlineCode">duluca/minimal-node-web-server</code>, which clocks in at ~15 MB.</p>
    <p class="normal"><code class="inlineCode">duluca/minimal-node-web-server</code> can be more straightforward<a id="_idIndexMarker1150"/> to work with, especially if you’re not familiar with <code class="inlineCode">nginx</code>. It relies on an <code class="inlineCode">Express.js</code> server to serve static content. Most cloud providers provide concrete examples using Node and Express, which can help you narrow down any errors. In addition, <code class="inlineCode">duluca/minimal-node-web-server</code> has HTTPS redirection support baked into it. You can spend a lot of time trying to set up an <code class="inlineCode">nginx</code> proxy to do the same thing when all you need to do is set the <code class="inlineCode">ENFORCE_HTTPS</code> environment variable in your <code class="inlineCode">Dockerfile</code>. See the following sample Dockerfile:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">Dockerfile</strong></span>
<span class="hljs-keyword">FROM</span> duluca/minimal-node-web-server:lts-alpine
<span class="hljs-keyword">WORKDIR</span> /usr/src/app
<span class="hljs-keyword">COPY</span> dist/local-weather-app public
<span class="hljs-keyword">ENTRYPOINT</span> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]
<span class="hljs-keyword">ENV</span> ENFORCE_HTTPS=xProto
</code></pre>
    <div class="note">
      <p class="normal">You can read more about the options <code class="inlineCode">minimal-node-web-server</code> provides at <code class="inlineCode">https://github.com/duluca/minimal-node-web-server</code>.</p>
    </div>
    <p class="normal">As we’ve now seen, the beauty<a id="_idIndexMarker1151"/> of Docker is that you can navigate to <a href="https://hub.docker.com"><span class="url">https://hub.docker.com</span></a>, search for <code class="inlineCode">duluca/minimal-nginx-web-server</code> or <code class="inlineCode">duluca/minimal-node-web-server</code>, read its <code class="inlineCode">Dockerfile</code>, and trace its origins all the way back to the original base image that is the foundation of the web server. I encourage you to vet every Docker image you use in this manner to understand what exactly it brings to the table for your needs. </p>
    <p class="normal">You may either find it overkill or that it has features you never knew about that can make your life a lot easier.</p>
    <p class="normal">Note that the parent images should pull a specific tag of <code class="inlineCode">duluca/minimal-nginx-web-server</code>, which is <code class="inlineCode">1-alpine</code>. Similarly, <code class="inlineCode">duluca/minimal-node-web-server</code> pulls from <code class="inlineCode">lts-alpine</code>. These evergreen base packages always contain the latest version 1 of <code class="inlineCode">nginx</code> and Alpine or an LTS release of Node. In Docker Hub, I have pipelines to automatically update both images when a new base image is published. So, you will get the latest bug fixes and security patches whenever you pull these images.</p>
    <p class="normal">Having an evergreen dependency tree removes the burden on you as the developer to hunt down the latest version of a Docker image. Alternatively, if you specify a version number, your images will not be subject to any potential breaking changes. However, it is better to remember to test your images after a new build than never update your image and, potentially, deploy compromised software. After all, the web is ever-changing and will not slow down for you to keep your images up to date.</p>
    <p class="normal">Just like npm packages, Docker<a id="_idIndexMarker1152"/> can bring great convenience and value, but you must take care to understand the tools you are working with.</p>
    <h2 id="_idParaDest-324" class="heading-2">Installing Docker</h2>
    <p class="normal">To be able to build<a id="_idIndexMarker1153"/> and run containers, you must first install the Docker execution environment on your computer. You can download<a id="_idIndexMarker1154"/> Docker Desktop at <a href="https://www.docker.com/products/docker-desktop/"><span class="url">https://www.docker.com/products/docker-desktop/</span></a>. Follow the instructions on the screen to complete the installation.</p>
    <h2 id="_idParaDest-325" class="heading-2">Setting up npm scripts for Docker</h2>
    <p class="normal">Now, let’s configure some Docker scripts<a id="_idIndexMarker1155"/> for your Angular apps that you can use to automate your container’s building, testing, and publishing. I have developed a set of scripts called <strong class="keyWord">npm scripts for Docker</strong> that works on Windows 10 and macOS. You can get the latest version of these scripts and automatically configure them in your project by executing the following command.</p>
    <div class="note">
      <p class="normal">Run the following command on both the <strong class="keyWord">local-weather-app</strong> and <strong class="keyWord">lemon-mart</strong> projects now!</p>
    </div>
    <p class="normal">Install the npm scripts for Docker task:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npx mrm npm-docker
</code></pre>
    <p class="normal">After you execute the <code class="inlineCode">mrm</code> scripts, we’re ready to take a deep dive into the configuration settings using the Local Weather app as an example.</p>
    <h2 id="_idParaDest-326" class="heading-2">Building and publishing an image to Docker Hub</h2>
    <p class="normal">Next, let’s ensure that your project <a id="_idIndexMarker1156"/>is configured correctly so we can containerize it, build <a id="_idIndexMarker1157"/>an executable image, and publish<a id="_idIndexMarker1158"/> it to Docker Hub, allowing us to access it from<a id="_idIndexMarker1159"/> any build environment.</p>
    <div class="note">
      <p class="normal">This section uses the <strong class="keyWord">local-weather-app</strong> repository.</p>
    </div>
    <p class="normal">You will need to take the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Sign up for a Docker Hub account at <a href="https://hub.docker.com/"><span class="url">https://hub.docker.com/</span></a>.</li>
      <li class="numberedList">Create a public (free) repository for your application.</li>
      <li class="numberedList">In <code class="inlineCode">package.json</code>, add or update the <code class="inlineCode">config</code> property with the following configuration properties:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">package.json</strong></span>
  ...
  <span class="hljs-attr">"config"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"imageRepo"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"[namespace]/[repository]"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"imageName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"custom_app_name"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"imagePort"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"0000"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"internalContainerPort"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"3000"</span>
  <span class="hljs-punctuation">},</span>
  ...
</code></pre>
     
    <p class="normal"><code class="inlineCode">namespace</code> will be your Docker Hub username. You will define what your repository will be called during creation. An example image <code class="inlineCode">repository</code> variable should look like <code class="inlineCode">duluca/localcast-weather</code>. The image name is for easy identification of your container while using Docker commands such as <code class="inlineCode">docker ps</code>. I will just call mine <code class="inlineCode">localcast-weather</code>. The <code class="inlineCode">imagePort</code> property will define which port should be used to expose your application from inside the container. Since we use port <code class="inlineCode">4200</code> for development, pick a different one, like <code class="inlineCode">8080</code>. <code class="inlineCode">internalContainerPort</code> defines the port that your web server is mapped to. This will mostly be port <code class="inlineCode">3000</code> for Node servers and, for <code class="inlineCode">nginx</code> servers, <code class="inlineCode">80</code>. Refer to the documentation of the base container you’re using.</p> </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Let’s review the Docker<a id="_idIndexMarker1160"/> scripts added to <code class="inlineCode">package.json</code> by the <code class="inlineCode">mrm</code> task <a id="_idIndexMarker1161"/>from earlier. The following section presents an annotated version of the scripts added, explaining each entry.
    <div class="packt_tip">
      <p class="normal">Note that with <code class="inlineCode">npm</code> scripts, the <code class="inlineCode">pre</code> and <code class="inlineCode">post</code> keywords are used to execute helper scripts before or after executing a given script. Scripts are intentionally broken into smaller pieces to make them easier to read and maintain.</p>
    </div>
    <ul>
      <li class="bulletList">The <code class="inlineCode">build</code> script is as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">package.json</strong></span>
...
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    ...
    <span class="hljs-attr">"predocker:build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm run build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"docker:build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cross-conf-env docker image build --platform linux/amd64,linux/arm64 . -t $npm_package_config_imageRepo:$npm_package_version"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"postdocker:build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm run docker:tag"</span><span class="hljs-punctuation">,</span>
    ...
</code></pre>
      </li>
    </ul>
    <div class="packt_tip">
      <p class="normal">Note that the following <code class="inlineCode">cross-conf-env</code> command ensures the script executes equally well in macOS, Linux, and Windows environments.</p>
    </div>
    <ul>
      <li class="bulletList"><code class="inlineCode">npm run docker:build</code> will build your Angular application in the <code class="inlineCode">pre</code> script, then build the Docker image using the <code class="inlineCode">docker image build</code> command, and tag the image with a version number in the <code class="inlineCode">post</code> script.</li>
    </ul>
    <div class="packt_tip">
      <p class="normal">In my project, the <code class="inlineCode">pre</code> command builds my Angular application in <code class="inlineCode">prod</code> mode and runs a test to ensure that I have an optimized build with no failing tests.</p>
      <p class="normal">My <code class="inlineCode">pre</code> command looks like this:</p>
      <pre class="programlisting con"><code class="hljs-con">"predocker:build": "npm run build:prod &amp;&amp; npm test -- --watch=false"
</code></pre>
    </div>
    <ul>
      <li class="bulletList">The <code class="inlineCode">tag</code> script is as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">package.json</strong></span>
    ...
    <span class="hljs-attr">"docker:tag"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">" cross-conf-env docker image tag $npm_package_config_imageRepo:$npm_package_version $npm_package_config_imageRepo:latest"</span><span class="hljs-punctuation">,</span>
    ...
</code></pre>
      </li>
      <li class="bulletList"><code class="inlineCode">npm run docker:tag</code> will tag an already built Docker image using the version number from the <code class="inlineCode">version</code> property in <code class="inlineCode">package.json</code> and the latest tag.</li>
      <li class="bulletList">The <code class="inlineCode">stop</code> script is as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">package.json</strong></span>
    ...
    <span class="hljs-attr">"docker:stop"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cross-conf-env docker stop $npm_package_config_imageName || true"</span><span class="hljs-punctuation">,</span>
    ...
</code></pre>
      </li>
      <li class="bulletList"><code class="inlineCode">npm run docker:stop</code> will stop<a id="_idIndexMarker1162"/> the image if it’s currently <a id="_idIndexMarker1163"/>running, so the <code class="inlineCode">run</code> script<a id="_idIndexMarker1164"/> can execute<a id="_idIndexMarker1165"/> without errors.</li>
      <li class="bulletList">The <code class="inlineCode">run</code> script is as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">package.json</strong></span>
    ...
    <span class="hljs-attr">"docker:run"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"run-s -c docker:stop docker:runHelper"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"docker:runHelper"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cross-conf-env docker run -e NODE_ENV=local --rm --name $npm_package_config_imageName -d -p $npm_package_config_imagePort:$npm_package_config_internalContainerPort $npm_package_config_imageRepo"</span><span class="hljs-punctuation">,</span>
    ...
</code></pre>
      </li>
    </ul>
    <div class="packt_tip">
      <p class="normal">Note that the <code class="inlineCode">run-s</code> and <code class="inlineCode">run-p</code> commands ship with the <code class="inlineCode">npm-run-all</code> package to synchronize or parallelize the execution of npm scripts.</p>
    </div>
    <ul>
      <li class="bulletList"><code class="inlineCode">npm run docker:run</code> will stop if the image is already running, and then run the newly built version of the image using the <code class="inlineCode">docker run</code> command. Note that the <code class="inlineCode">imagePort</code> property is used as the external port of the Docker image, which is mapped to the internal port of the image that the Node.js server listens to, port <code class="inlineCode">3000</code>.</li>
      <li class="bulletList">The <code class="inlineCode">publish</code> script is as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">package.json</strong></span>
    ...
    <span class="hljs-attr">"predocker:publish"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo Attention! Ensure `docker login` is correct."</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"docker:publish"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cross-conf-env docker image push $npm_package_config_imageRepo:$npm_package_version"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"postdocker:publish"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cross-conf-env docker image push $npm_package_config_imageRepo:latest"</span><span class="hljs-punctuation">,</span>
    ...
</code></pre>
      </li>
    </ul>
    <div class="packt_tip">
      <p class="normal">Note that <code class="inlineCode">docker:tag </code>adds the latest version tag on the container. When we push the latest tags, both tags get pushed simultaneously.</p>
    </div>
    <ul>
      <li class="bulletList"><code class="inlineCode">npm run docker:publish</code> will publish<a id="_idIndexMarker1166"/> a built image to the configured<a id="_idIndexMarker1167"/> repository, in this case, Docker<a id="_idIndexMarker1168"/> Hub, using<a id="_idIndexMarker1169"/> the <code class="inlineCode">docker image push</code> command.</li>
      <li class="bulletList">First, the versioned image is published, followed by one tagged with <code class="inlineCode">latest</code> in <code class="inlineCode">post</code>. The <code class="inlineCode">taillogs</code> script is as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">package.json</strong></span>
    ...
    <span class="hljs-attr">"docker:taillogs"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cross-conf-env docker logs -f $npm_package_config_imageName"</span><span class="hljs-punctuation">,</span>
    ...
</code></pre>
      </li>
      <li class="bulletList"><code class="inlineCode">npm run docker:taillogs</code> will display the internal console logs of a running Docker instance using the <code class="inlineCode">docker log -f</code> command, a useful tool for debugging your Docker instance.</li>
      <li class="bulletList">The <code class="inlineCode">open</code> script is as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">package.json</strong></span>
    ...
    <span class="hljs-attr">"docker:open"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"sleep 2 &amp;&amp; cross-conf-env open-cli http://localhost:$npm_package_config_imagePort"</span><span class="hljs-punctuation">,</span>
    ...
</code></pre>
      </li>
      <li class="bulletList"><code class="inlineCode">npm run docker:open</code> will wait for 2 seconds, accounting for latency, and then launch the browser with the correct URL for your application using the <code class="inlineCode">imagePort</code> property.</li>
      <li class="bulletList">The <code class="inlineCode">debug</code> script is as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">package.json</strong></span>
    ...
    <span class="hljs-attr">"predocker:debug"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"run-s docker:build docker:run"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"docker:debug"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"run-s -cs docker:open:win docker:open:mac docker:taillogs"</span>
  <span class="hljs-punctuation">},</span>
...
</code></pre>
      </li>
      <li class="bulletList"><code class="inlineCode">npm run docker:debug</code> will build your image and run an instance of it in <code class="inlineCode">pre</code>, open the browser, and then start displaying the internal logs of the container.</li>
    </ul></li>
    </ol>








    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Customize the pre-build script<a id="_idIndexMarker1170"/> to build your angular app in production<a id="_idIndexMarker1171"/> mode and execute unit<a id="_idIndexMarker1172"/> tests before building<a id="_idIndexMarker1173"/> the image:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">package.json</strong></span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ng build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build:prod"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ng build --prod"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"predocker:build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm run build:prod &amp;&amp; npm test -- --watch=false"</span><span class="hljs-punctuation">,</span>
</code></pre>
     
    <div class="packt_tip">
      <p class="normal">Note that <code class="inlineCode">ng build</code> is provided with the <code class="inlineCode">--prod</code> argument, which achieves two things: the size of the app<a id="_idIndexMarker1174"/> is optimized to be significantly smaller with <strong class="keyWord">Ahead-of-Time</strong> (<strong class="keyWord">AOT</strong>) compilation to increase runtime performance, and the configuration items defined in <code class="inlineCode">src/environments/environment.prod.ts</code> are used.</p>
    </div> </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Update <code class="inlineCode">src/environments/environment.prod.ts</code> to look like you’re using your own <code class="inlineCode">appId</code> from <code class="inlineCode">OpenWeather</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> environment = {   
  <span class="hljs-attr">production</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">appId</span>: <span class="hljs-string">'01ff1xxxxxxxxxxxxxxxxxxxxx'</span>,
  <span class="hljs-attr">username</span>: <span class="hljs-string">'localcast'</span>,
  <span class="hljs-attr">baseUrl</span>: <span class="hljs-string">'https://'</span>,
  <span class="hljs-attr">geonamesApi</span>: <span class="hljs-string">'secure'</span>,
}
</code></pre>
     
    <div class="packt_tip">
      <p class="normal">We are modifying how <code class="inlineCode">npm test</code> is executed, so the tests are run only once and the tool stops executing. The <code class="inlineCode">--watch=false</code> option is provided to achieve this behavior, as opposed to the development-friendly default continuous execution behavior.</p>
    </div> </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Create a new file named <code class="inlineCode">Dockerfile</code> with no file extensions in the project root.</li>
      <li class="numberedList">Implement or replace the contents of the <code class="inlineCode">Dockerfile</code>, as shown here:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">Dockerfile</strong></span>
<span class="hljs-keyword">FROM</span> duluca/minimal-node-web-server:lts-alpine 
<span class="hljs-keyword">WORKDIR</span> /usr/src/app
<span class="hljs-keyword">COPY</span> dist/local-weather-app public
</code></pre>
      
    <div class="packt_tip">
      <p class="normal">Be sure to inspect the contents of your <code class="inlineCode">dist</code> folder to ensure you’re copying the correct folder, which contains the <code class="inlineCode">index.html</code> file at its root.</p>
    </div></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">Execute <code class="inlineCode">npm run predocker:build</code> and see that it runs without errors in the Terminal to ensure that your application changes have been successful.</li>
      <li class="numberedList">Execute <code class="inlineCode">npm run docker:build</code> and see that it runs without errors in the Terminal to ensure that your image builds successfully.<ul>
          <li class="bulletList">While you can run<a id="_idIndexMarker1175"/> any of the provided scripts<a id="_idIndexMarker1176"/> individually, you really only<a id="_idIndexMarker1177"/> need to remember<a id="_idIndexMarker1178"/> two of them going forward:</li>
          <li class="bulletList"><code class="inlineCode">npm run docker:debug</code> will test, build, tag, run, tail, and launch your containerized app in a new browser window for testing.</li>
          <li class="bulletList"><code class="inlineCode">npm run docker:publish</code> will publish the image you just built and test to the online Docker repository.</li>
        </ul>
      </li>
      <li class="numberedList">Execute <code class="inlineCode">docker:debug</code> in your Terminal:
        <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npm run docker:debug
</code></pre>
        <ul>
          <li class="bulletList">A successful <code class="inlineCode">docker:debug</code> run should result in a new in-focus browser window with your application and the server logs being tailed in the Terminal, as follows:
            <pre class="programlisting con"><code class="hljs-con">Current Environment: local.
Server listening on port 3000 inside the container
Attention: To access server, use http://localhost:EXTERNAL_PORT
EXTERNAL_PORT is specified with 'docker run -p EXTERNAL_PORT:3000'. See 'package.json-&gt;imagePort' for the default port.      
GET / 304 2.194 ms - -
GET /runtime-es2015.js 304 0.371 ms - -
GET /polyfills-es2015.js 304 0.359 ms - -
GET /styles-es2015.js 304 0.839 ms - -
GET /vendor-es2015.js 304 0.789 ms - -
GET /main-es2015.js 304 0.331 ms - -
</code></pre>
          </li>
        </ul>
      
    <div class="packt_tip">
      <p class="normal">You should always run <code class="inlineCode">docker ps</code> to check whether your image is running, when it was last updated, and whether it clashes with any existing images claiming the same port.</p>
    </div></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="12">Execute <code class="inlineCode">docker:publish</code> in your Terminal:
        <pre class="programlisting con"><code class="hljs-con">$ npm run docker:publish
</code></pre>
        <ul>
          <li class="bulletList">You should<a id="_idIndexMarker1179"/> observe a successful<a id="_idIndexMarker1180"/> run in the Terminal<a id="_idIndexMarker1181"/> window<a id="_idIndexMarker1182"/> like this:
            <pre class="programlisting con"><code class="hljs-con">The push refers to a repository [docker.io/duluca/localcast- weather]
60f66aaaaa50: Pushed
...
latest: digest: sha256:b680970d76769cf12cc48f37391d8a542fe226b66d9a6f8a7ac81ad77be4 f58b size: 2827
</code></pre>
          </li>
        </ul>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">Over time, your local Docker cache may grow significantly; for example, it’s reached roughly 40 GB on my laptop over two years. You can use the <code class="inlineCode">docker image prune</code> and <code class="inlineCode">docker container prune</code> commands to reduce your cache size. For more<a id="_idIndexMarker1183"/> detailed information, refer to the documentation at <a href="https://docs.docker.com/config/pruning"><span class="url">https://docs.docker.com/config/pruning</span></a>.</p>
    </div>
    <p class="normal">By defining a <code class="inlineCode">Dockerfile</code> and scripting our use of it, we created living documentation in our code base. We have achieved DevOps and closed the configuration gap.</p>
    <div class="note">
      <p class="normal">Make sure to containerize <strong class="keyWord">lemon-mart</strong> like you’ve done with <strong class="keyWord">local-weather-app</strong> and verify your work by executing <code class="inlineCode">npm run docker:debug</code>.</p>
    </div>
    <p class="normal">VS Code offers<a id="_idIndexMarker1184"/> a visual way<a id="_idIndexMarker1185"/> to interact<a id="_idIndexMarker1186"/> with npm<a id="_idIndexMarker1187"/> scripts. Let’s take a look at VS Code’s npm script support next.</p>
    <h2 id="_idParaDest-327" class="heading-2">npm scripts in VS Code</h2>
    <p class="normal">VS Code provides support<a id="_idIndexMarker1188"/> for npm scripts <a id="_idIndexMarker1189"/>out of the box. In order to enable npm Script Explorer, open the VS Code settings and ensure that the <code class="inlineCode">"npm.enableScriptExplorer": true</code> property is present. Once you do, you will see an expandable title named <strong class="keyWord">NPM SCRIPTS</strong> in the <strong class="keyWord">Explorer</strong> pane, as highlighted with an arrow in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_14.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.14: NPM SCRIPTS in VS Code</p>
    <p class="normal">You can click on any script to launch the line that contains the script in <code class="inlineCode">package.json</code> or right-click<a id="_idIndexMarker1190"/> and select <strong class="screenText">Run</strong> to execute<a id="_idIndexMarker1191"/> the script.</p>
    <p class="normal">Let’s look at an easier way to interact with Docker next.</p>
    <h2 id="_idParaDest-328" class="heading-2">Docker extensions in VS Code</h2>
    <p class="normal">Another way to interact<a id="_idIndexMarker1192"/> with Docker images and containers is through<a id="_idIndexMarker1193"/> VS Code. If you have installed the <code class="inlineCode">ms-azuretools.vscode-docker</code> Docker extension from Microsoft, as suggested in <em class="chapterRef">Chapter 2</em>, <em class="italic">Forms, Observables, Signals, and Subjects</em>, you can identify the extension by the Docker logo on the left-hand navigation menu in VS Code, as circled in white in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_15.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.15: Docker extension in VS Code</p>
    <p class="normal">Let’s go through some of the functionality provided by the extension. Refer to the preceding screenshot and the numbered steps in the following list for a quick explanation:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><strong class="screenText">Images</strong> contain a list of all the container snapshots on your system.</li>
      <li class="numberedList">Right-clicking on a Docker image creates a context menu to run various operations like <strong class="screenText">Run</strong>, <strong class="screenText">Push</strong>, and <strong class="screenText">Tag</strong>.</li>
      <li class="numberedList"><strong class="screenText">Containers</strong> list all executable Docker containers on your system, which you can start, stop, or attach to.</li>
      <li class="numberedList"><strong class="screenText">Registries</strong> display the registries that you’re configured to connect to, such as Docker Hub or <strong class="keyWord">AWS Elastic Container Registry</strong> (<strong class="keyWord">AWS ECR</strong>).</li>
    </ol>
    <p class="normal">While the extension makes it easier to interact with Docker, the <strong class="keyWord">npm scripts for Docker</strong> (which you configured using the <code class="inlineCode">mrm </code>task) automate many of the chores related to building, tagging, and testing an image. They are both cross-platform and will work equally well in a CI environment.</p>
    <div class="note">
      <p class="normal">The <code class="inlineCode">npm</code> <code class="inlineCode">run</code> <code class="inlineCode">docker:debug</code> script automates a lot of chores to verify that you have a good image build!</p>
    </div>
    <p class="normal">Now let’s learn about deploying our containers to the cloud and later achieve CD.</p>
    <h1 id="_idParaDest-329" class="heading-1">Working with containers in the cloud</h1>
    <p class="normal">One of the advantages of using Docker is that we can deploy it on any number of operating environments, from personal PCs to servers and cloud providers. In any case, we expect our container to function the same across the board.</p>
    <p class="normal">Earlier in the chapter, I mentioned that working with full-fledged cloud providers like Azure, AWS, and Google Cloud is complicated. To deploy your containers in the cloud you will likely need to use one of these providers. Now and then, a provider that offers easy and seamless container hosting pops up, but over the years, these options have disappeared.</p>
    <p class="normal">Cloud services offer a wide variety of methods for running containers ranging from managed to unmanaged solutions. The key difference between managed and unmanaged is the level of control and responsibility shared between the user and the cloud provider. This is referred to as the Shared Responsibility Model. In a managed configuration, you concede more control and responsibility of the underlying infrastructure to the cloud provider. This consequently results in increased security and usually a cheaper cloud bill.</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_16.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.16: Shared Responsibility Model</p>
    <p class="normal">The figure above demonstrates the shared responsibility model for running containers in the cloud. In the unmanaged model, the cloud provider gives you access to a virtual machine. The cloud provider manages and maintains the physical machine, which is totally abstracted away fro user. Now it’s up to you to configure the <strong class="keyWord">Operating System </strong>(<strong class="keyWord">OS</strong>) and secure it. On top of the OS, you can set up a container runtime or a cluster that involves many virtual machines.</p>
    <div class="packt_tip">
      <p class="normal">Read the excellent article by Kaizhe Huang on ECS Fargate Threat Modeling at <a href="https://sysdig.com/blog/ecs-fargate-threat-modeling"><span class="url">https://sysdig.com/blog/ecs-fargate-threat-modeling</span></a>.</p>
    </div>
    <p class="normal">A container cluster is a group of hosts set up to run containerized workloads. Container orchestration software like Kubernetes automates and manages the containers across the cluster infrastructure. This allows you to scale container instances to respond to changes in load. Clusters also provide rich features like service discovery. You can learn more about Kubernetes at <a href="https://kubernetes.io"><span class="url">https://kubernetes.io</span></a>.</p>
    <p class="normal">In the managed model, the cloud provider gives you access to a container runtime environment with cluster-like features, including Kubernetes support. The cloud provider secures the runtime, and the user is only responsible for the container. These offerings are <strong class="keyWord">serverless</strong>. In this space, each cloud provider offers a variety of services that significantly differ in capabilities.</p>
    <p class="normal">Here is a list of some popular options:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">AWS Fargate </strong>is a serverless compute engine that runs containers without managing servers or clusters. Integrates with <strong class="keyWord">Elastic Container Service</strong> (<strong class="keyWord">ECS</strong>) and <strong class="keyWord">Elastic Kubernetes Service</strong> (<strong class="keyWord">EKS</strong>).</li>
      <li class="bulletList"><strong class="keyWord">Google Cloud Run </strong>is a fully managed serverless platform for stateless containerized applications. Auto-scales and bills per request.</li>
      <li class="bulletList"><strong class="keyWord">Azure Container Instances </strong>can run individual containers without adopting higher-level orchestration services. Per-second billing.</li>
      <li class="bulletList"><strong class="keyWord">Amazon ECS </strong>offers highly scalable Docker container management across a cluster of <strong class="keyWord">Elastic Compute Cloud</strong> (<strong class="keyWord">EC2</strong>) instances. Tight integration with other AWS services. AWS EKS is the Kubernetes-flavored version of AWS ECS.</li>
      <li class="bulletList"><strong class="keyWord">Google Kubernetes Engine</strong> (<strong class="keyWord">GKE</strong>) is a managed Kubernetes environment running on Google Cloud. Easily deploy containers with native Google Cloud integrations.</li>
      <li class="bulletList"><strong class="keyWord">Azure Kubernetes Service</strong> (<strong class="keyWord">AKS</strong>) is a fully managed Kubernetes cluster service hosted on Azure. Streamlined deployments to containers with auto-scaling capabilities.</li>
    </ul>
    <p class="normal">The main advantages of the serverless options (AWS Fargate, Google Cloud Run, Azure Container Instances) are that they are fully managed, automatically scale, and have payas-you-go pricing models. However, they offer limited customization compared to provisioned Kubernetes. The provisioned Kubernetes options (Amazon ECS, Google GKE, Azure AKS) offer more control, customization, and the ability to run stateful applications. However, they require manual scaling and managing of the infrastructure.</p>
    <p class="normal">Overall, serverless options are easier to use but less flexible, while provisioned Kubernetes offers more customization but requires DevOps know-how to manage the infrastructure. Your choice depends on whether the workload fits the serverless constraints and how much control vs simplicity is preferred.</p>
    <p class="normal">So far, you’ve deployed your code to the cloud, mastered the fundamentals of working with Docker containers, and understood the nuances of deploying containers in the cloud. <strong class="keyWord">Continuous Deployment</strong> (<strong class="keyWord">CD</strong>) is the manifestation of my motto, ship it, or it never happened. Next, we’ll go over how you can integrate deployments as part of your CI pipeline to achieve CD.</p>
    <p class="normal">The <code class="inlineCode">npm run docker:debug</code> script automates a lot of chores to verify that you have a good image build!</p>
    <h1 id="_idParaDest-330" class="heading-1">Continuous deployment</h1>
    <p class="normal">CD is the idea that code changes<a id="_idIndexMarker1194"/> that successfully pass through your pipeline can be automatically deployed to a target environment. Although examples of continuously deploying to production exist, most enterprises prefer to target a development environment. A gated approach is adopted to move the changes through the various stages of development environment, test, staging, and, ultimately, production. CircleCI can facilitate gated deployment with approval workflows, which is covered later in this section.</p>
    <p class="normal">In CircleCI, you need to implement a deploy job to deploy your image. You can deploy to many targets in this job, such as Google Cloud Run, Docker Hub, Heroku, Azure, or AWS ECS. Integration with these targets will involve multiple steps. At a high level, these steps are as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Configure an orb for your target environment, which provides the CLI tools required to deploy your software.</li>
      <li class="numberedList">Store login credentials or access keys specific to the target environment as CircleCI environment variables.</li>
      <li class="numberedList">Build a container in the CI pipeline if not using a platform-specific <code class="inlineCode">build</code> command. Then use <code class="inlineCode">docker push</code> to submit the resulting Docker image to the target platform’s registry.</li>
      <li class="numberedList">Execute a platform-specific <code class="inlineCode">deploy</code> command to instruct the target to run the Docker image that was just pushed.</li>
    </ol>
    <p class="normal">By using a Docker-based workflow, we achieve great amounts of flexibility in terms of systems and target environments we can use. The following diagram illustrates this point by highlighting the possible permutation of choices that are available to us:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_17.png" alt="A diagram of a structure  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.17: n-to-n deployment</p>
    <p class="normal">As you can see, in a containerized world, the possibilities are limitless. We will use the deployment related npm scripts we added later in this chapter to implement the deploy job in our CI pipeline. </p>
    <p class="normal">Outside of Docker-based workflows, you can use purpose-built CLI tools to quickly deploy your app. Next, let’s see how you can deploy your app to Vercel using CircleCI.</p>
    <h2 id="_idParaDest-331" class="heading-2">Deploying to Vercel using CircleCI</h2>
    <p class="normal">Earlier, we configured the LocalCast<a id="_idIndexMarker1195"/> Weather app to be built using CircleCI. We can enhance our CI pipeline to take the build output and optionally deploy it to Vercel.</p>
    <div class="note">
      <p class="normal">This section uses the <strong class="keyWord">local-weather-app</strong> repository. The <code class="inlineCode">config.yml</code> file for this section is named <code class="inlineCode">.circleci/config.stage9.yml</code>.</p>
    </div>
    <p class="normal">Let’s update the <code class="inlineCode">config.yml</code> file to add a new job named <code class="inlineCode">deploy</code>. In the upcoming <em class="italic">Workflows</em> section, we will use this job to deploy a pipeline when approved:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a token from your Vercel account.</li>
      <li class="numberedList">Add an environment variable to your CircleCI project named <code class="inlineCode">VERCEL_TOKEN</code> and store your Vercel token as the value.</li>
      <li class="numberedList">In <code class="inlineCode">config.yml</code>, update the <code class="inlineCode">build</code> job with the new steps and add a new job named <code class="inlineCode">deploy</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">.circleci/config.yml</strong></span>
<span class="hljs-string">...</span>
<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">build_and_test:</span>
    <span class="hljs-string">...</span>       
    <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">Move</span> <span class="hljs-string">compiled</span> <span class="hljs-string">app</span> <span class="hljs-string">to</span> <span class="hljs-string">workspace</span>
        <span class="hljs-attr">command:</span> <span class="hljs-string">|</span>
          <span class="hljs-string">set</span> <span class="hljs-string">-exu</span>
          <span class="hljs-string">mkdir</span> <span class="hljs-string">-p</span> <span class="hljs-string">/tmp/workspace/dist</span>
          <span class="hljs-string">mv</span> <span class="hljs-string">dist/local-weather-app</span> <span class="hljs-string">/tmp/workspace/dist/</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">persist_to_workspace:</span>
        <span class="hljs-attr">root:</span> <span class="hljs-string">/tmp/workspace</span>
        <span class="hljs-attr">paths:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">dist/local-weather-app</span>
  <span class="hljs-attr">deploy:</span>
    <span class="hljs-attr">docker:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">circleci/node:lts</span>
    <span class="hljs-attr">working_directory:</span> <span class="hljs-string">~/repo</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">attach_workspace:</span>
          <span class="hljs-attr">at:</span> <span class="hljs-string">/tmp/workspace</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npx</span> <span class="hljs-string">vercel</span> <span class="hljs-string">deploy</span> <span class="hljs-string">--token</span> <span class="hljs-string">$VERCEL_TOKEN</span> <span class="hljs-string">--prod</span> <span class="hljs-string">/tmp/</span>
<span class="hljs-string">             workspace/dist/&lt;&lt;</span> <span class="hljs-string">parameters.project</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">--yes</span>
</code></pre>
      
    <p class="normal">In the <code class="inlineCode">build</code> job, after the build<a id="_idIndexMarker1196"/> is complete, we add two new steps. First, we move the compiled app in the <code class="inlineCode">dist</code> folder to a workspace and persist that workspace so we can use it later in another job. In a new job named <code class="inlineCode">deploy</code>, we attach the workspace and use <code class="inlineCode">npx</code> to run the <code class="inlineCode">vercel</code> command to deploy the <code class="inlineCode">dist</code> folder. This is a straightforward process.</p>
    <div class="packt_tip">
      <p class="normal">Note that <code class="inlineCode">$VERCEL_TOKEN</code> is the environment variable we stored in the CircleCI project.</p>
    </div></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Implement a simple CircleCI workflow to deploy the outcome of your <code class="inlineCode">build</code> job continuously:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">.circleci/config.yml</strong></span>
<span class="hljs-string">...</span>
<span class="hljs-attr">workflows:</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">build-test-and-deploy:</span>
    <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build_and_test</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">deploy:</span>
         <span class="hljs-attr">requires:</span>
           <span class="hljs-bullet">-</span> <span class="hljs-string">build_and_test</span>
</code></pre>
        <div class="packt_tip">
          <p class="normal">Note that the <code class="inlineCode">deploy</code> job waits for the <code class="inlineCode">build</code> job to complete before it can execute.</p>
        </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Ensure that your CI pipeline executed successfully by inspecting the test results:
    <figure class="mediaobject"><img src="../Images/B20960_10_18.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.18: Successful Vercel deployment of local-weather-app</p></li>
    </ol>
    <p class="normal">Most CLI commands for cloud providers need to be installed in your pipeline to function. Since Vercel has an npm package, this is easy to do. CLI tools for AWS, Google Cloud, or Microsoft Azure need to be installed<a id="_idIndexMarker1197"/> using tools such as <code class="inlineCode">brew</code> or <code class="inlineCode">choco</code>. CircleCI offers orbs, reusable snippets of code that help automate repeated processes, speed up project setup, and make it easy to integrate with third-party tools.</p>
    <div class="packt_tip">
      <p class="normal">You can read more about orbs at <a href="https://circleci.com/orbs"><span class="url">https://circleci.com/orbs</span></a>.</p>
    </div>
    <p class="normal">Check out the Orb registry for more information on how to use these orbs at <a href="https://circleci.com/orbs/registry"><span class="url">https://circleci.com/orbs/registry</span></a>.</p>
    <p class="normal">CD works great for development and testing environments. However, it is usually desirable to have gated deployments, where a person must approve a deployment before it reaches a production<a id="_idIndexMarker1198"/> environment. Next, let’s see how you can implement this with CircleCI.</p>
    <h2 id="_idParaDest-332" class="heading-2">Gated CI workflows</h2>
    <p class="normal">In CircleCI, you can define a workflow<a id="_idIndexMarker1199"/> to control how and when your jobs are executed. Consider the following configuration, given the jobs <code class="inlineCode">build</code> and <code class="inlineCode">deploy</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">.circleci/config.yml</strong></span>
<span class="hljs-attr">workflows:</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">build-and-deploy:</span>
    <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">hold:</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">approval</span>
          <span class="hljs-attr">requires:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">deploy:</span>
          <span class="hljs-attr">requires:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">hold</span>
</code></pre>
    <p class="normal">First, the <code class="inlineCode">build</code> job gets executed. Then, we introduce a special job named <code class="inlineCode">hold</code> with type <code class="inlineCode">approval</code>, which requires the <code class="inlineCode">build</code> job to be successfully completed. Once this happens, the pipeline is put on hold. If or when a decision-maker approves <code class="inlineCode">hold</code>, then the <code class="inlineCode">deploy</code> step can execute. Refer to the following screenshot to see what a <strong class="screenText">hold</strong> looks like:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_19.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.19: A hold in the pipeline</p>
    <p class="normal">Consider a more sophisticated workflow, shown in the following code snippet, where the <code class="inlineCode">build</code> and <code class="inlineCode">test</code> steps are broken out into two separate jobs:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">workflows:</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
    <span class="hljs-attr">build-test-and-approval-deploy:</span>
      <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build</span> 
      <span class="hljs-bullet">-</span> <span class="hljs-string">test</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">hold:</span>
         <span class="hljs-attr">type:</span> <span class="hljs-string">approval</span>
         <span class="hljs-attr">requires:</span>
           <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
           <span class="hljs-bullet">-</span> <span class="hljs-string">test</span>
         <span class="hljs-attr">filters:</span>
           <span class="hljs-attr">branches:</span>
             <span class="hljs-attr">only:</span> <span class="hljs-string">main</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">deploy:</span>
        <span class="hljs-attr">requires:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">hold</span>
</code></pre>
    <p class="normal">In this case, the <code class="inlineCode">build</code> and <code class="inlineCode">test</code> jobs are executed in parallel. If we’re on a branch, this is where the pipeline stops. Once the branch is merged with <code class="inlineCode">main</code>, the pipeline is put on hold, and a decision-maker has the option to deploy the build or not. This type of branch filtering ensures that only code that’s been<a id="_idIndexMarker1200"/> merged to <code class="inlineCode">main</code> can be deployed, which is in line with GitHub flow.</p>
    <p class="normal">Next, we will go over how we can integrate code coverage reports with our CI runs to get better insight into our test coverage and optionally fail builds that don’t meet a certain threshold.</p>
    <h1 id="_idParaDest-333" class="heading-1">Code coverage reports</h1>
    <p class="normal">A code coverage report is a good way<a id="_idIndexMarker1201"/> to understand the amount and trends of unit test coverage for your Angular project.</p>
    <p class="normal">To generate the report for your app, execute the following command from your <code class="inlineCode">project</code> folder:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npx ng test --watch=false --code-coverage
</code></pre>
    <p class="normal">The resulting report will be created as an HTML file under a folder named <code class="inlineCode">coverage</code>; execute the following command to view it in your browser:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npx http-server -c-1 -o -p 9875 ./coverage
</code></pre>
    <div class="packt_tip">
      <p class="normal">You may need to specify <code class="inlineCode">--project</code> for the <code class="inlineCode">ng</code> <code class="inlineCode">test</code> command. Similarly, the coverage report may be generated in a sub-folder under <strong class="screenText">coverage</strong>. You can select the folder to view it.</p>
    </div>
    <p class="normal">Here’s the folder-level sample<a id="_idIndexMarker1202"/> coverage report generated by <code class="inlineCode">istanbul</code> for LemonMart:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_20.png" alt="A screenshot of a spreadsheet  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.20: Istanbul code coverage report for LemonMart</p>
    <p class="normal">You can drill down on a particular folder, such as <code class="inlineCode">src/app/auth</code>, and get a file-level report, as shown here:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_21.png" alt="A screenshot of a data  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.21: Istanbul code coverage report for src/app/auth</p>
    <p class="normal">You can drill down further to get line-level coverage<a id="_idIndexMarker1203"/> for a given file, such as <code class="inlineCode">cache.service.ts</code>, as shown here:</p>
    <figure class="mediaobject"><img src="../Images/B20960_10_22.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.22: Istanbul code coverage report for cache.service.ts</p>
    <p class="normal">In the preceding screenshot, you can see lines <strong class="screenText">5</strong>, <strong class="screenText">12</strong>, <strong class="screenText">17</strong>–<strong class="screenText">18</strong>, and <strong class="screenText">21</strong>–<strong class="screenText">22</strong> are not covered by any test. The <strong class="keyWord">I</strong> icon denotes that the <code class="inlineCode">if</code> path was not taken. We can increase our code coverage by implementing unit tests that exercise the functions that are contained within <code class="inlineCode">CacheService</code>. As an exercise, you should attempt<a id="_idIndexMarker1204"/> to at least cover one of these functions with a new unit test and observe the code coverage report change.</p>
    <h2 id="_idParaDest-334" class="heading-2">Code coverage in CI</h2>
    <p class="normal">Ideally, your CI server configuration<a id="_idIndexMarker1205"/> should generate and host the code coverage report with every test run. You can then use code coverage as another code quality gate to prevent pull requests from being merged if the new code reduces the overall code coverage<a id="_idIndexMarker1206"/> percentage. This is a great way to reinforce the <strong class="keyWord">Test-Driven Development</strong> (<strong class="keyWord">TDD</strong>) mindset.</p>
    <p class="normal">You can use a service<a id="_idIndexMarker1207"/> such as Coveralls, found at <a href="https://coveralls.io"><span class="url">https://coveralls.io</span></a>, to implement your code coverage checks, which can embed your code coverage levels directly on a GitHub pull request.</p>
    <p class="normal">Let’s configure Coveralls for LemonMart:</p>
    <div class="note">
      <p class="normal">In the <strong class="keyWord">lemon-mart</strong> repo, the <code class="inlineCode">config.yml</code> file for this section is named <code class="inlineCode">.circleci/config.stage9.yml</code>.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In your CircleCI account settings, under the <strong class="screenText">Security</strong> section, ensure that you allow the execution of uncertified/unsigned orbs.</li>
      <li class="numberedList">Register your GitHub project at <a href="https://coveralls.io/"><span class="url">https://coveralls.io/</span></a>.</li>
      <li class="numberedList">Copy the repository token and store it as an environment variable in CircleCI named <code class="inlineCode">COVERALLS_REPO_TOKEN</code>.</li>
      <li class="numberedList">Create a new branch before making any code changes.</li>
      <li class="numberedList">Update the <code class="inlineCode">.circleci/config.yml</code> file with the Coveralls orb as shown:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">.circleci/config.yml</strong></span>
<span class="hljs-attr">version:</span> <span class="hljs-number">2.1</span>
<span class="hljs-attr">orbs:</span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-attr-slc">coveralls:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">coveralls/coveralls@2</strong></span>
</code></pre>
      </li>
      <li class="numberedList">Update the <code class="inlineCode">build</code> job to store code coverage results and upload them to Coveralls:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">.circleci/config.yml</strong></span>
<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">build_and_test:</span>
    <span class="hljs-string">...</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">test</span> <span class="hljs-string">--</span> <span class="hljs-string">--watch=false</span> <span class="hljs-string">--code-coverage</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">store_test_results:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">./test_results</span>
      <span class="code-highlight"><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-attr-slc">store_artifacts:</strong></span>
          <span class="code-highlight"><strong class="hljs-attr-slc">path:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">./coverage</strong></span>
      <span class="code-highlight"><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">coveralls/upload</strong></span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">Tar</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">Gzip</span> <span class="hljs-string">compiled</span> <span class="hljs-string">app</span>
          <span class="hljs-attr">command:</span> <span class="hljs-string">tar</span> <span class="hljs-string">zcf</span> <span class="hljs-string">dist.tar.gz</span> <span class="hljs-string">dist/lemon-mart</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">store_artifacts:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">dist.tar.gz</span>
</code></pre>
      
    <div class="note">
      <p class="normal"><code class="inlineCode">store_test_results</code> and <code class="inlineCode">store_artifacts</code> will store test results and code coverage data to be analyzed in other jobs or orbs. CircleCI can display XML formatted coverage reports in its web UI. <code class="inlineCode">The</code> <code class="inlineCode">coveralls/upload</code> <code class="inlineCode">command</code> uploads the code coverage data we just stored for analysis.</p>
    </div>
    <div class="packt_tip">
      <p class="normal">Note that the orb automatically configures Coveralls for your account, so the <code class="inlineCode">coveralls</code>/<code class="inlineCode">upload</code> command can upload your code coverage results.</p>
    </div></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Commit your changes<a id="_idIndexMarker1208"/> to the branch and publish it.</li>
      <li class="numberedList">Create a pull request on GitHub using the branch.</li>
      <li class="numberedList">On the pull request, verify that you can see that Coveralls is reporting your project’s code coverage, as shown:
    <figure class="mediaobject"><img src="../Images/B20960_10_23.png" alt="A screenshot of a computer error  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.23: Coveralls reporting code coverage</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="10">Merge the pull request to your main branch.</li>
    </ol>
    <p class="normal">Congratulations! Now, you can modify your branch protection rules to require that code coverage levels be above a certain percentage before a pull request can be merged into the main branch.</p>
    <div class="packt_tip">
      <p class="normal">You can set coverage thresholds at <a href="https://coveralls.io"><span class="url">https://coveralls.io</span></a>.</p>
    </div>
    <div class="note">
      <p class="normal">The LemonMart project at <a href="https://github.com/duluca/lemon-mart"><span class="url">https://github.com/duluca/lemon-mart</span></a> implements a full-featured <code class="inlineCode">config.yml</code> file. This file also implements <a href="http://Cypress.io"><span class="url">Cypress.io</span></a>, overriding Angular’s default e2e tooling. The Cypress orb can record test results and allow you to view them from your CircleCI pipeline.</p>
    </div>
    <p class="normal">Leveraging what you have learned in this chapter, you can incorporate the <code class="inlineCode">deploy</code> scripts from LocalCast Weather for LemonMart and implement a gated deployment workflow.</p>
    <p class="normal">Good engineering practices and DevOps<a id="_idIndexMarker1209"/> practices are key to delivering successful projects and building a satisfying career. Thanks for reading this book!</p>
    <h1 id="_idParaDest-335" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, you learned about creating a value delivery stream using CI/CD pipelines. We covered the importance of automated unit testing to enable the delivery of quality code at speed in an enterprise context. You configured a CI pipeline using CircleCI. You learned about trunk-based development using GitHub flow and enforcing quality gates. You deployed a web application to Vercel and leveraged <code class="inlineCode">ng</code> <code class="inlineCode">deploy</code> for Firebase.</p>
    <p class="normal">Next, we covered DevOps and IaC techniques using Docker and npm scripts. You containerized your web app, learned about working with containers in the cloud, and learned how to implement gated CI workflows. Also, you became familiar with orbs, workflows, and code coverage tools.</p>
    <p class="normal">We leveraged CircleCI as a cloud-based CI service and highlighted that you can deploy the outcome of your builds to all major cloud hosting providers. You have seen how you can achieve CD. We covered an example deployment to Vercel via CircleCI demonstrating how you can implement continuous deployments.</p>
    <p class="normal">With a robust CI/CD pipeline, you can share every app build with clients and team members and quickly deliver bug fixes or new features to your end users.</p>
    <p class="normal">Congratulations! You have completed your <em class="italic">Angular for Enterprise Applications</em> journey. I hope you learned something new. The best way to learn and grow is by teaching and sharing, so I hope you keep this book around as a reference and share it with friends, family, and colleagues.</p>
    <blockquote class="packt_quote">
      <p class="quote">If you got this far, send me a picture of yourself with the (e-)book or a note on how the content impacted you, and I’ll share an exclusive digital badge with you for your achievement.</p>
      <p class="quote">Continue your journey at <a href="https://AngularForEnterprise.com"><span class="url">https://AngularForEnterprise.com</span></a>.</p>
    </blockquote>
    <h1 id="_idParaDest-336" class="heading-1">Exercises</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add CircleCI and Coveralls badges to the <code class="inlineCode">README.md</code> file on your code repository.</li>
      <li class="numberedList">Implement Cypress for e2e testing and run it in your CircleCI pipeline using the <code class="inlineCode">Cypress orb</code>.</li>
      <li class="numberedList">Implement a Vercel deployment and a conditional workflow for the LemonMart app. The resulting <code class="inlineCode">config.yml</code> file is in the <code class="inlineCode">lemon-mart</code> repo, named <code class="inlineCode">.circleci/config.stage9.yml</code>.</li>
    </ol>
    <h1 id="_idParaDest-337" class="heading-1">Further reading</h1>
    <ul>
      <li class="bulletList"><em class="italic">Working Effectively with Legacy Code</em>, Michael Feathers, 2004</li>
      <li class="bulletList"><em class="italic">The Three Laws of TDD</em>, Robert “Uncle Bob” Martin, 2005, <a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd"><span class="url">http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd</span></a> </li>
      <li class="bulletList"><em class="italic">Succeeding with Agile: Software Development Using Scrum</em>, Mike Cohn, 2009</li>
      <li class="bulletList"><em class="italic">TestPyramid</em>, Martin Fowler, 2012, <a href="https://martinfowler.com/bliki/TestPyramid.html"><span class="url">https://martinfowler.com/bliki/TestPyramid.html</span></a></li>
      <li class="bulletList"><em class="italic">Jasmine 2 Spy Cheat Sheet</em>, Dave Ceddia, 2015, <a href="https://daveceddia.com/jasmine-2-spy-cheat-sheet"><span class="url">https://daveceddia.com/jasmine-2-spy-cheat-sheet</span></a></li>
      <li class="bulletList"><em class="italic">The Practical Test Pyramid</em>, Ham Vocke, 2018, <a href="https://martinfowler.com/articles/practical-test-pyramid.html"><span class="url">https://martinfowler.com/articles/practical-test-pyramid.html</span></a></li>
      <li class="bulletList"><em class="italic">SOLID Principles</em>, Wikipedia, 2019, <a href="https://en.wikipedia.org/wiki/SOLID"><span class="url">https://en.wikipedia.org/wiki/SOLID</span></a></li>
      <li class="bulletList"><em class="italic">Dockerfile reference</em>, 2020, <a href="https://docs.docker.com/engine/reference/builder/"><span class="url">https://docs.docker.com/engine/reference/builder/</span></a></li>
      <li class="bulletList"><em class="italic">CircleCI orbs</em>, 2020, <a href="https://circleci.com/orbs/"><span class="url">https://circleci.com/orbs/</span></a></li>
      <li class="bulletList"><em class="italic">Deploying container images</em>, 2020, <a href="https://cloud.google.com/run/docs/deploying "><span class="url">https://cloud.google.com/run/docs/deploying</span></a></li>
      <li class="bulletList"><em class="italic">ECS Fargate Threat Modeling</em>, Kaizhe Huang, 2019, <a href="https://sysdig.com/blog/ecs-fargate-threat-modeling/ "><span class="url">https://sysdig.com/blog/ecs-fargate-threat-modeling/</span></a></li>
    </ul>
    <h1 id="_idParaDest-338" class="heading-1">Questions</h1>
    <p class="normal">Answer the following questions as best as possible to ensure you’ve understood the key concepts from this chapter without googling anything. Do you know if you got all the answers right? Visit <a href="https://angularforenterprise.com/self-assessment"><span class="url">https://angularforenterprise.com/self-assessment</span></a> for more:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What is the testing pyramid?</li>
      <li class="numberedList">What are fixtures and matchers?</li>
      <li class="numberedList">What are the differences between a mock, a spy, and a stub?</li>
      <li class="numberedList">What is the benefit of building Angular in prod mode?</li>
      <li class="numberedList">How does GitHub flow work?</li>
      <li class="numberedList">Why should we protect the main branch?</li>
      <li class="numberedList">Explain the difference between a Docker image and a Docker container.</li>
      <li class="numberedList">Why do you prefer a managed container runtime over an unmanaged one in the cloud?</li>
      <li class="numberedList">What is the purpose of a CD pipeline?</li>
      <li class="numberedList">What is the benefit of CD?</li>
      <li class="numberedList">How do we cover the configuration gap?</li>
      <li class="numberedList">What does a CircleCI orb do?</li>
      <li class="numberedList">What are the benefits of using a multi-stage Dockerfile?</li>
      <li class="numberedList">How does a code coverage report help maintain the quality of your app?</li>
    </ol>
  
  </div>
</body></html>