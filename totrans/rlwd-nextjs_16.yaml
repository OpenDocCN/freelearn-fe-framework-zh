- en: '*Chapter 13*: Building an E-Commerce Website with Next.js and GraphCMS'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During our journey exploring Next.js, we've learned a lot. We've explored different
    rendering methodologies, styling techniques, integrations, and even deployment
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to start creating something worth going to production, taking
    advantage of everything we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to adopt Next.js to build e-commerce storefronts
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the following in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: What GraphCMS is and how to adopt it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to integrate payment methods such as Stripe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deploy an e-commerce website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to describe a Next.js e-commerce
    architecture, find the right SEO and performance tradeoff, and deploy your Next.js
    instance on the right cloud platform.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer, you can use an online IDE, such as [https://repl.it](https://repl.it)
    or [https://codesandbox.io](https://codesandbox.io); they both support Next.js
    and you don''t need to install any dependency on your computer. As with the other
    chapters, you can find the code base for this chapter on GitHub: https://github.com/PacktPublishing/Real-World-Next.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating e-commerce websites for the modern web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the internet started to spread at the end of the 90s, it opened a world
    of possibilities for online businesses. As a result, many companies began to develop
    **software-as-a-service** (**SaaS**) products to help people build their own online
    shopping platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, there are several significant players in this area: Shopify, Big Cartel,
    WordPress (using WooCommerce or other plugins), and Magento, just to name a few.'
  prefs: []
  type: TYPE_NORMAL
- en: There are also companies, such as PayPal and Stripe, that make it incredibly
    easy to integrate payment methods on any platform, paving the ground for custom
    e-commerce creation, where our imagination is the only limit.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about "limits" in e-commerce creation, I'm referring to the fact
    that certain SaaS platforms can make it hard for us developers to customize the
    UI, payment flow, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Shopify, as an example, solved this problem by creating a new server-side-rendered
    React.js framework called **Hydrogen**, which ships with pre-built components
    and Hooks to communicate with its GraphQL APIs, allowing developers to create
    unique user experiences on the frontend with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js, released Next.js Commerce, a highly customizable starter kit for effortlessly
    creating e-commerce experiences, being able to integrate with many different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js Commerce doesn't add anything new to the Next.js framework. Instead,
    it acts as a template for starting a new e-commerce website, knowing that we can
    customize every single part of it with extreme ease. We will not touch upon the
    customization capabilities in practice; however, we will still deploy an incredibly
    performant and optimized online shop.
  prefs: []
  type: TYPE_NORMAL
- en: We can use Next.js commerce with any headless backend service. It doesn't matter
    whether we're using Shopify, BigCommerce, Saleor, or any other service, as long
    as they expose some APIs to communicate with the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from the next section, we will be using one of the best headless CMS
    platforms out there, which can manage any aspect of a modern e-commerce platform,
    from product inventory to content translations, always keeping an API-first approach:
    GraphCMS.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GraphCMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different competitors in the e-commerce world; all of them offer
    a great set of functionalities for building modern and performant solutions, but
    there's always a kind of tradeoff when it comes to analyzing back-office features,
    frontend customization capabilities, APIs, integrations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be using GraphCMS for a simple reason: it''s easy
    to integrate, offers a generous free plan, and requires no setup for complex release
    pipelines, databases, or whatever. We just need to open an account and take advantage
    of the massive set of free features to build a fully working e-commerce website.'
  prefs: []
  type: TYPE_NORMAL
- en: It also provides an e-commerce starter template with pre-built (yet fully customizable)
    contents, which translates to a pre-built GraphQL schema ready to consume on the
    frontend to create product pages, catalogs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We can start by creating a new GraphCMS account by going to [https://graphcms.com](https://graphcms.com).
    Once we log into our dashboard, we will see that GraphCMS prompts us to create
    a new project, and we will choose among several pre-made templates. We can select
    the **Commerce Shop** template, which will generate some mock content for us.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – The GraphCMS dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.1_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – The GraphCMS dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Once we have created the project by selecting **Commerce Shop** as a template,
    we can browse the **Content** section in our GraphCMS dashboard and see what mock
    data we have.
  prefs: []
  type: TYPE_NORMAL
- en: We will see many useful and prepopulated sections, such as products, product
    variants, categories, and reviews; we will use this data in our Next.js commerce
    application shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our content, we need to create a Next.js application to display
    it on the frontend by using the powerful GraphCMS GraphQL APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created the app, we can start thinking about how we want the UI
    to be. In this case, we want to keep things easy, and we''ll use Chakra UI for
    styling our components. Let''s install it and set it up inside our Next.js application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open our `_app.js` file and add the Chakra provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've set up an elementary Next.js application, we can start thinking
    about linking GraphCMS to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As said before, GraphCMS exposes excellent GraphQL APIs, so we need to connect
    to it by using that protocol. We''ve already discussed how to connect to any GraphQL
    endpoint using Apollo in [*Chapter 4*](B16985_04_Final_SB_epub.xhtml#_idTextAnchor053),
    *Organizing the Code base and Fetching Data in Next.js*. For the sake of simplicity,
    we''ll now use a more straightforward library for connecting to GraphCMS: `graphql-request`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install it by using Yarn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create a basic GraphQL interface to connect GraphCMS to our storefront.
    First, let''s create a new file called `lib/graphql/index.js` and add the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What's happening here?
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we will need to create a couple of environment variables: `GRAPHCMS_ENDPOINT`
    and `GRAPHCMS_API_KEY`. The first one contains the GraphCMS endpoint URL, and
    the second is an optional API key for accessing protected data.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, GraphCMS allows you to expose its data publicly, which can be handy
    in certain situations. In other cases, though, we want our data to be accessible
    to authorized clients only, so we need to use an API key.
  prefs: []
  type: TYPE_NORMAL
- en: We can retrieve those environment variables values by going to **Settings**
    then **API Access** on our GraphCMS dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – API access management in GraphCMS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.2_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – API access management in GraphCMS
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now take the `GRAPHCMS_ENDPOINT` value inside the `.env.local` file
    in our codebase. Of course, if this file does not exist, we can create it from
    scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We now need to set the API key, which allows us to perform mutations on the
    CMS (for example, save an order once it's paid). We can use the default `GRAPHCMS_API_KEY`
    value in our `.env.local` file.
  prefs: []
  type: TYPE_NORMAL
- en: We're now ready to go! We have a connection with the CMS, so we can read, write,
    and even update or delete data via GraphQL APIs. In the next section, we will
    use them to create the storefront and the product detail page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the storefront, cart, and product detail pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GraphCMS offers a well-made, rock-solid, open source template for creating
    e-commerce websites, which can be found at this URL: [https://github.com/GraphCMS/graphcms-commerce-starter](https://github.com/GraphCMS/graphcms-commerce-starter).'
  prefs: []
  type: TYPE_NORMAL
- en: We're not adopting this starter template because we want to fully understand
    the reasoning behind certain technical decisions and how to approach the problems
    that can appear during the development phase.
  prefs: []
  type: TYPE_NORMAL
- en: That said, we can focus on developing the first essential components for our
    storefront.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will wrap our entire application in a Chakra UI box so that every page will
    have a similar layout. We can do that by opening the `_app.js` file and adding
    the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can start thinking about how we want to show our products on the home
    page. However, before doing that, we may want to check the data provided via GraphQL
    APIs by the CMS, and we can easily do that by going into the **API Playground**
    section of our dashboard. Here, we can write our GraphQL queries, taking advantage
    of the **Explorer** functionality to help us create highly customizable GraphQL
    queries with ease.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – GraphCMS API Playground'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.3_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – GraphCMS API Playground
  prefs: []
  type: TYPE_NORMAL
- en: 'In the query shown in the preceding screenshot, we''re retrieving all the publicly
    available products. We can use this exact query in our Next.js app, so let''s
    create a new `/lib/graphql/queries/getAllProducts.js` file and add the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to fetch all the products to populate our home page. To generate
    a static page at build time, let''s head to our `pages/index.js` page and retrieve
    the products inside the `getStaticProps` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we might be wondering how to handle cases where we create a
    new product and want to display it immediately on the home page. Here, we have
    two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `getServerSideProps` instead of `getStaticProps`, which will dynamically
    generate the page on each request, but we already know its downsides, as seen
    in [*Chapter 10*](B16985_10_Final_SB_epub.xhtml#_idTextAnchor102), *Working with
    SEO and Managing Performance*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use incremental static regeneration so that after a given period, the page gets
    regenerated, including any new API changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll proceed with the second option by adding the following property to our
    returning `getStaticProps` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to display all the products on our home page. We''ll do that
    by creating a new component under `/components/ProductCard/index.js`, exposing
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is a straightforward component that displays a product
    card containing the product image, name, and price.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the used props (highlighted in the preceding code snippet),
    you will notice a one-to-one correspondence with the data we''re getting back
    from GraphCMS. That''s another slight advantage of using GraphQL: it allows you
    to model your data while querying it, making it incredibly easy to build components,
    functions, and even algorithms around it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `ProductCard` component, we can import it into our home
    page and use it to display all the products fetched from the CMS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we now launch our development server and head to [http://localhost:3000](http://localhost:3000),
    we will be able to see our storefront.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Our first Next.js-based storefront'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.4_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – Our first Next.js-based storefront
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a working storefront, we need to create a single product page.
  prefs: []
  type: TYPE_NORMAL
- en: As for the home page, we will use SSG + ISR to build all the product pages,
    which will help us maintain great performance and improve SEO and user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do that by creating a new file under `pages/product/[slug].js`, where
    we can start writing the following function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you may have guessed, we will need to generate a new page for each product,
    and we can do that by using Next.js' reserved `getStaticPaths` function.
  prefs: []
  type: TYPE_NORMAL
- en: Inside that function, we will query for all the products in our CMS, then generate
    the dynamic URL paths for each one; that way, at build time, Next.js will generate
    all the pages we need in our website.
  prefs: []
  type: TYPE_NORMAL
- en: The other two functions should already sound familiar, so we will implement
    them later.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to write a GraphQL query for getting all the products in GraphCMS.
    To keep it simple, we can reuse the query we wrote for the home page, which is
    already fetching all the products, including their slugs (which will be part of
    the product URL).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our product page by making a request to GraphCMS for all the
    products in the inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With this edit, we''re returning an object containing all the pages we need
    to generate at build time. In fact, the returning object will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you may guess, this will help Next.js to match a given `/product/[slug]`
    route with the correct product slug.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we need to create a GraphQL query to get the single product
    details. We can create a new file under `lib/graphql/queries/getProductDetail.js`
    and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this query, we will get all the products whose slug matches the `$slug`
    query variable. Given that the `slug` property is unique in GraphCMS, it will
    return an array with just one result if the requested products exist or an empty
    array if it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re now ready to import this query and edit the `getStaticProps` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we only need to create the product page layout, containing an image of
    our product, a title, a brief description, the price, and a quantity selector.
    To do that, we can edit the `ProductPage` function in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now launch the development server and open a single product page, we
    will see the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – The single product detail page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.5_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.5 – The single product detail page
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can navigate from the home page to a product page, we need to build
    a navigation bar that can allow us to go back to the storefront or go to the shopping
    cart to review the product we want to purchase and then make the payment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily create a navigation bar by opening a new file under `components/NavBar/index.js`
    and adding the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to install the `react-icons` library, which, as the name
    suggests, is an excellent package containing hundreds of well-made and useful
    icons for our React-based projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We now only need to update our `_app.js` file by including the newest `NavBar`
    component so that it will be rendered on all the application pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can finally navigate from the storefront to the product page and back!
  prefs: []
  type: TYPE_NORMAL
- en: Now that the website is taking shape, we want to add products to our shopping
    basket. We discussed a similar scenario in [*Chapter 5*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068),
    *Managing Local and Global States in Next.js*.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to create a React context to hold the shopping list until the user
    pays.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to create a new file under `lib/context/Cart/index.js`.
    Here, we will write the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to wrap the entire app under this context, so we need to open the
    `_app.js` file and edit it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is quite similar to the context we created in [*Chapter 5*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068),
    *Managing Local and Global States in Next.js*, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to link the single product page to the context to add products
    to the shopping cart. Let''s open the `components/ProductCard/index.js` file and
    link the context to the **select quantity** and **add to cart** actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also make things more exciting and dynamic by showing how many products
    we have in our shopping cart. We can do this by linking the `NavBar` component
    to the same `CartContext` by adding a few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a way to add items to the shopping cart, we need to create
    the cart page itself. Let''s create a new `pages/cart.js,` file where we will
    add the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will be the shopping cart's page default state. When a user puts any product
    into the basket, we need to display it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we can easily use the cart context we just created, which will
    tell us the ID and quantity of each product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We ended up having an object containing the IDs and the quantity for each product
    in the format `{ [product_id]: quantity }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the keys of this object to fetch all the required products from
    GraphCMS by using a new query, positioned under `lib/graphql/queries/getProductsById.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we finish writing the query, we can move back to our `cart.js` file and
    implement it using a `useEffect` React Hook, so that we fetch all the products
    as soon as the page loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as we try to add a couple of products to the shopping basket and then
    move to the cart page, we will see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – The browser can''t find the process variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.6_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – The browser can't find the process variable
  prefs: []
  type: TYPE_NORMAL
- en: Next.js is telling us that the `process` variable, containing all the environment
    variables, is not available on the browser. Thankfully, even if this variable
    is not officially supported by any browser, Next.js provides an excellent polyfill
    for us; we only need to make a couple of changes to make it effective.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we will need to rename the `GRAPHCMS_ENDPOINT` variable to `NEXT_PUBLIC_GRAPHCMS_ENDPOINT`.
    By prepending `NEXT_PUBLIC_` to any environment variable, Next.js will add a `process.env`
    object, available on the browser, exposing only the public variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the change in the `.env.local` file, then move back to the `lib/graphql/index.js`
    file and make a small change there too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we're not modifying the `GRAPHCMS_API_KEY` environment variable
    name, as it contains private data and should never be exposed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have fixed this little issue, we're finally ready to compose our
    cart page.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to write a function that calculates the final expense by
    summing the product prices multiplied by their quantity. We can do that by adding
    this function inside our component''s body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can update our component returning JSX by including the list of products
    that we added to the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We're all set for managing the cart! We now need to process the payment by choosing
    a financial service, such as Stripe, PayPal, or Braintree.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to implement the payment feature using
    Stripe.
  prefs: []
  type: TYPE_NORMAL
- en: Processing payments using Stripe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stripe is one of the best financial services out there; it's straightforward
    to use and offers excellent documentation to understand how to integrate their
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing with this section, make sure to open an account at https://stripe.com.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have an account, we can log in and go to [https://dashboard.stripe.com/apikeys](https://dashboard.stripe.com/apikeys),
    where we''ll retrieve the following information: the publishable key and secret
    key. We will need to store them inside of two environment variables, following
    this naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Please double-check that you're not exposing the `STRIPE_SECRET_KEY` variable
    and that the `.env.local` file is not added to the Git history by including it
    in the `.gitignore` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s install the Stripe JavaScript SDK inside of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the two packages are installed, we can create a new file under `lib/stripe/index.js`,
    containing the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This script will ensure that we load Stripe only once, even if we come back
    to the cart page multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we will need to create an API page that creates a Stripe session.
    By doing that, Stripe will create a beautiful and secure checkout page to redirect
    our users to insert their payment and shipping details. Once the users place their
    orders, they will get redirected to a landing page of our choice, but we'll see
    that later on in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new API route under `/pages/api/checkout/index.js`, where we
    will write a very basic Stripe checkout session request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Once we have created this basic function, we need to understand what data Stripe
    requires to complete the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to pass the following data in a particular order:'
  prefs: []
  type: TYPE_NORMAL
- en: All the products to purchase, containing names, quantities, prices, and (optionally)
    images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the available payment methods (credit cards, Alipay, SEPA Debit, or other
    payment methods, such as Klarna)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shipping rates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Success and cancel redirect URLs for either case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can start by considering the first point; we can easily pass the whole cart
    context object to this endpoint, including both product IDs to purchase and their
    quantity. We will need to then ask GraphCMS for product details, and we can do
    that by creating a new specific query under `lib/graphql/queries/getProductDetailsById.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to our `/pages/api/checkout/index.js` API page, we can start by
    implementing the query to retrieve the product details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Stripe requires a configuration object containing a property called `line_items`,
    which describes all the products ready for purchase. Now that we have all the
    product information, we can compose this property in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As a reference, if a user buys a couple of backpacks from our store, the `line_items`
    array would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start writing the Stripe checkout session request by using the `line_items`
    array and a bit more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re almost there. Now, we only need to get the shipping information and
    store it in two different Stripe session properties: `shipping_address_collection`
    and `shipping_options`.'
  prefs: []
  type: TYPE_NORMAL
- en: We can create two new variables outside the `handler` function. Still, as you
    can imagine, this can be completely CMS-driven.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep it simple, let''s create the first `shipping_address_collection` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can restrict shipping by manually selecting the countries
    where we ship to. You can simply avoid passing the `shipping_address_collection`
    property to the Stripe session if you want to ship worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: The second variable is more complex but allows us to create different shipping
    methods with different rates. Let's say we offer free shipping, which takes 3
    to 5 business days for delivery, and express next day shipping for €4.99\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create the following array of shipping options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The shipping objects are self-explanatory. We can finally add those two new
    properties to our Stripe checkout session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: And we're done! We're now replying with a session object that contains the redirect
    URL to be used on the frontend to redirect the user to the Stripe-hosted checkout
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do that by moving back to our `pages/cart.js` page and adding the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As a very last thing, we only need to link this function to the `Cart` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re finally ready to test out our checkout flow! Let''s boot the development
    server, add a couple of products to the shopping basket, then go to the **Cart**
    section and click on the **Pay now** button. We should end up on this beautiful,
    Stripe-powered checkout page, where we can insert our shipping information, choose
    the desired payment method, and modify the quantity for each product we put in
    the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – The Stripe checkout page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.7_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.7 – The Stripe checkout page
  prefs: []
  type: TYPE_NORMAL
- en: In my case, you can see that I've been redirected to a **Michele Riva** store
    (upper-left corner), as I opened my Stripe account using my name, but if you did
    the same and want to customize the store name, you can edit it on your Stripe
    dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: By clicking on the store name in the upper-left corner, we will be redirected
    to the `cancel_url` we set in the `pages/api/checkout/index.js` page; if we successfully
    complete a purchase, we will get redirected to `success_url`. I'll leave you the
    task of creating those two pages as a little homework to complete before moving
    on to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we saw how to create a straightforward e-commerce
    website using GraphCMS and Stripe, two incredible products that can help build
    scalable, secure, and maintainable storefronts.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we've made some significant progress during this chapter, we're
    still missing some features that would deserve an entire book on them exclusively.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we now want to navigate back from the Stripe checkout to the
    cart page, we will see that our shopping cart is empty, as the cart context is
    not persistent. And what if we want to allow our users to create an account and
    see the shipping progress, order history, and other helpful information?
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, these are complex topics, and there''s no way we can manage
    them in one chapter exclusively. One thing''s for sure: once we know how to handle
    users and authentication via Auth0, product inventory and order history on GraphCMS,
    and checkout on Stripe, we have all the elements we need to create rock-solid
    user experiences and development workflows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Vercel team also announced Next.js Commerce in the latest releases, a template
    ready to be attached to Shopify, Saleor, BigCommerce, and a few more e-commerce
    platforms to create a custom UI instantly for your storefront. The reason why
    we''re not digging into that template is simple: it is compelling, but it abstracts
    most of the work that is needed to connect different systems (such as Stripe and
    GraphCMS, or PayPal and WordPress), and we want to understand how to do it ourselves
    for the sake of learning more.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we saw how to integrate a headless CMS into our Next.js frontend.
    But if you found it easy, that's mainly because GraphCMS has been wisely built
    with the developer experience in mind, allowing us to take advantage of well-written
    GraphQL APIs built for the modern web era.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t say that the same applies to other CMSs, born when the web was still
    young and evolving, maintaining a full-stack approach, where we used the CMS itself
    to build both the backend and the frontend of our applications. But today, even
    those older CMS platforms are evolving thanks to an incredible community effort,
    aiming to provide a great developer experience by allowing us to adopt Next.js
    (or any other framework) as a frontend. For example, there''s a fantastic WordPress
    plugin that generates excellent GraphQL APIs from an existing website; that way,
    we can use WordPress as a complete headless CMS, creating a robust, performant,
    custom Next.js frontend. You can learn more about this plugin at https://www.wpgraphql.com.
    The same applies to Drupal, another popular, open source CMS that can expose GraphQL
    APIs thanks to the GraphQL module: [https://www.drupal.org/project/graphql](https://www.drupal.org/project/graphql).'
  prefs: []
  type: TYPE_NORMAL
- en: In the followingchapter, we will briefly recap what we've seen so far and see
    some example projects that we can build to practice more with Next.js.
  prefs: []
  type: TYPE_NORMAL
