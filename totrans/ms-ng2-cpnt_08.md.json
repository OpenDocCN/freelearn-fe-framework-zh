["```js\n…\n@Component({\n  selector: 'ngc-project-task-details',\n  …\n})\nexport class ProjectTaskDetails {\n  …\n}\n```", "```js\nconstructor(@Inject(forwardRef(() => Project)) project) {\n this.project = project; \n}\n```", "```js\n  routerOnActivate(currentRouteSegment) {\n    const taskNr = currentRouteSegment.getParam('nr');\n    this.projectChangeSubscription = this.project.document.change.subscribe((data) => {\n      this.task = data.tasks.find((task) => task.nr === +taskNr);\n      this.projectMilestones = data.milestones || [];\n    });\n  }\n```", "```js\nngOnDestroy() {\n this.projectChangeSubscription.unsubscribe();\n}\n```", "```js\n<h3 class=\"task-details__title\">\n  Task Details of task #{{task?.nr}}\n</h3>\n<div class=\"task-details__content\">\n  <div class=\"task-details__label\">Title</div>\n  <ngc-editor [content]=\"task?.title\"\n [showControls]=\"true\"\n (editSaved)=\"onTitleSaved($event)\"></ngc-editor>\n  <div class=\"task-details__label\">Description</div>\n  <ngc-editor [content]=\"task?.description\"\n [showControls]=\"true\"\n [enableTags]=\"true\"\n (editSaved)=\"onDescriptionSaved($event)\">\n  </ngc-editor>\n</div>\n```", "```js\nonTitleSaved(title) {\n this.task.title = title;\n this.project.document.persist();\n}\n\nonDescriptionSaved(description) {\n this.task.description = description;\n this.project.document.persist();\n}\n```", "```js\n…\nimport {ProjectTaskDetails} from './project-task-details/project-task-details';\n\n…\n@Component({\n  selector: 'ngc-project',\n  …\n})\n@Routes([\n new Route({ path: 'task/:nr', component: ProjectTaskDetails}),\n  …\n])\nexport class Project {\n  …\n}\n```", "```js\n…\n<div class=\"task__l-box-b\">\n  …\n <a [routerLink]=\"['../task', task?.nr]\"\n class=\"button button--small\">Details</a>\n</div>\n…\n```", "```js\n…\nexport const TAG_TYPE_TASK = 'task';\n\nexport function generateTag(subject) {\n  if (subject.type === TAG_TYPE_PROJECT) {\n    …\n  } else if (subject.type === TAG_TYPE_TASK) {\n    // If we're dealing with a task, we generate the according tag \n    // object\n    return new Tag(\n `#${subject.project._id}-task-${subject.task.nr}`,\n `${limitWithEllipsis(subject.task.title, 20)} (${subject.task.done ? 'done' : 'open'})`,\n `#/projects/${subject.project._id}/task/${subject.task.nr}`,\n TAG_TYPE_TASK\n );\n  }\n}\n```", "```js\n{task: …, project: …, type: TAG_TYPE_TASK}\n```", "```js\n…\nimport {generateTag, TAG_TYPE_TASK} from './generate-tag';\n…\n@Injectable()\nexport class TagsService {\n  …\n  // This method is used internally to initialize all available \n  // tags\n  initializeTags() {\n    …\n    // Let's also create task tags\n    this.projects.forEach((project) => {\n this.tags = this.tags.concat(project.tasks.map((task) => {\n return {\n type: TAG_TYPE_TASK,\n project,\n task\n };\n }).map(generateTag));\n });\n    …\n  }\n  …\n}\n```", "```js\nexport const UNITS = [{\n  short: 'w',\n  milliseconds: 5 * 8 * 60 * 60 * 1000\n}, {\n  short: 'd',\n  milliseconds: 8 * 60 * 60 * 1000\n}, {\n  short: 'h',\n  milliseconds: 60 * 60 * 1000\n}, {\n  short: 'm',\n  milliseconds: 60 * 1000\n}];\n```", "```js\nexport function parseDuration(formattedDuration) {\n  const pattern = /[\\d\\.]+\\s*[wdhm]/g;\n  let timeSpan = 0;\n  let result;\n  while (result = pattern.exec(formattedDuration)) {\n    const chunk = result[0].replace(/\\s/g, '');\n    let amount = Number(chunk.slice(0, -1));\n    let unitShortName = chunk.slice(-1);\n    timeSpan += amount * UNITS.find(\n      (unit) => unit.short === unitShortName\n    ).milliseconds;\n  }\n  return +timeSpan || null;\n}\n```", "```js\nexport function formatDuration(timeSpan) {\n  return UNITS.reduce((str, unit) => {\n    const amount = timeSpan / unit.milliseconds;\n    if (amount >= 1) {\n      const fullUnits = Math.floor(amount);\n      const formatted = `${str} ${fullUnits}${unit.short}`;\n      timeSpan -= fullUnits * unit.milliseconds;\n      return formatted;\n    } else {\n      return str;\n    }\n  }, '').trim();\n}\n```", "```js\nimport {Pipe, Inject} from '@angular/core';\nimport {formatDuration} from '../utilities/time-utilities';\n\n@Pipe({\n  name: 'formatDuration'\n})\nexport class FormatDurationPipe {\n  transform(value) {\n    if (value == null || typeof value !== 'number') {\n      return value;\n    }\n\n return formatDuration(value);\n  }\n}\n```", "```js\n…\nimport {FormatDurationPipe} from '../../pipes/format-duration';\nimport {Editor} from '../../ui/editor/editor';\nimport {parseDuration} from '../../utilities/time-utilities';\n\n@Component({\n  selector: 'ngc-duration',\n  …\n  directives: [Editor],\n pipes: [FormatDurationPipe]\n})\nexport class Duration {\n  @Input() duration;\n @Output() durationChange = new EventEmitter();\n\n onEditSaved(formattedDuration) {\n this.durationChange.next(formattedDuration ? \n parseDuration(formattedDuration) : null);\n }\n}\n```", "```js\n<ngc-editor [content]=\"duration | formatDuration\"\n            [showControls]=\"true\"\n            (editSaved)=\"onEditSaved($event)\"></ngc-editor>\n```", "```js\n<div class=\"efforts__label\">Estimated:</div>\n<ngc-duration [duration]=\"estimated\"\n (durationChange)=\"onEstimatedChange($event)\">\n</ngc-duration>\n<div class=\"efforts__label\">Effective:</div>\n<ngc-duration [duration]=\"effective\"\n (durationChange)=\"onEffectiveChange($event)\">\n</ngc-duration>\n<button class=\"button button--small\" \n        (click)=\"addEffectiveHours(1)\">+1h</button>\n<button class=\"button button--small\" \n        (click)=\"addEffectiveHours(4)\">+4h</button>\n<button class=\"button button--small\" \n        (click)=\"addEffectiveHours(8)\">+1d</button>\n```", "```js\n…\nimport {Duration} from '../ui/duration/duration'; \nimport {UNITS} from '../utilities/time-utilities';\n\n@Component({\n  selector: 'ngc-efforts',\n  …\n directives: [Duration]\n})\nexport class Efforts {\n  @Input() estimated;\n @Input() effective;\n @Output() effortsChange = new EventEmitter();\n\n  onEstimatedChange(estimated) {\n    this.effortsChange.next({\n estimated,\n effective: this.effective\n });\n  }\n\n  onEffectiveChange(effective) {\n    this.effortsChange.next({\n effective,\n estimated: this.estimated\n });\n  }\n\n addEffectiveHours(hours) {\n this.effortsChange.next({\n effective: (this.effective || 0) + \n hours * UNITS.find((unit) => unit.short === 'h'),\n estimated: this.estimated\n });\n }\n}\n```", "```js\n…\nimport {Efforts} from '../../efforts/efforts';\n\n@Component({\n  selector: 'ngc-project-task-details',\n  …\n  directives: [Editor, Efforts]\n})\nexport class ProjectTaskDetails {\n  …\n onEffortsChange(efforts) {\n if (!efforts.estimated && !efforts.effective) {\n this.task.efforts = null;\n } else {\n this.task.efforts = efforts;\n }\n this.project.document.persist();\n }\n  …\n}\n```", "```js\n…\n<div class=\"task-details__content\">\n  …\n  <div class=\"task-details__label\">Efforts</div>\n <ngc-efforts [estimated]=\"task?.efforts?.estimated\"\n [effective]=\"task?.efforts?.effective\"\n (effortsChange)=\"onEffortsChange($event)\">\n </ngc-efforts>\n</div>\n```", "```js\n…\n@Component({\n  selector: 'ngc-efforts-timeline',\n  …\n})\nexport class EffortsTimeline {\n @Input() estimated;\n @Input() effective;\n @Input() height;\n\n  ngOnChanges(changes) {\n this.done = 0;\n this.overtime = 0;\n\n    if (!this.estimated && this.effective || \n        (this.estimated && this.estimated === this.effective)) {\n      // If there's only effective time or if the estimated time \n      // is equal to the effective time we are 100% done\n this.done = 100;\n    } else if (this.estimated < this.effective) {\n      // If we have more effective time than estimated we need to \n      // calculate overtime and done in percentage\n this.done = this.estimated / this.effective * 100;\n this.overtime = 100 - this.done;\n    } else {\n      // The regular case where we have less effective time than \n      // estimated\n this.done = this.effective / this.estimated * 100;\n    }  \n  }\n}\n```", "```js\n<svg width=\"100%\" [attr.height]=\"height\">\n  <rect [attr.height]=\"height\"\n        x=\"0\" y=\"0\" width=\"100%\"\n        class=\"efforts-timeline__remaining\"></rect>\n  <rect *ngIf=\"done\" x=\"0\" y=\"0\" \n        [attr.width]=\"done + '%'\" [attr.height]=\"height\"\n        class=\"efforts-timeline__done\"></rect>\n  <rect *ngIf=\"overtime\" [attr.x]=\"done + '%'\" y=\"0\"\n [attr.width]=\"overtime + '%'\" [attr.height]=\"height\"\n        class=\"efforts-timeline__overtime\"></rect>\n</svg>\n```", "```js\n…\n<ngc-efforts-timeline height=\"10\"\n [estimated]=\"estimated\"\n [effective]=\"effective\">\n</ngc-efforts-timeline>\n```", "```js\n…\nimport {Editor} from '../editor/editor';\n\n@Component({\n  selector: 'ngc-auto-complete',\n  …\n directives: [Editor]\n})\nexport class AutoComplete {\n @Input() items;\n @Input() selectedItem;\n @Output() selectedItemChange = new EventEmitter();\n @Output() itemCreated = new EventEmitter();\n  …\n}\n```", "```js\nfilterItems(filter) {\n this.filter = filter || '';\n this.filteredItems = this.items\n .filter(\n (item) => item\n .toLowerCase()\n .indexOf(this.filter.toLowerCase().trim()) !== -1)\n .slice(0, 10);\n  this.exactMatch = this.items.includes(this.filter);\n}\n```", "```js\nngOnChanges(changes) {\n  if (this.items && this.selectedItem) {\n this.filterItems(this.selectedItem);\n  }\n}\n```", "```js\nonEditModeChange(editMode) {\n  if (editMode) {\n    this.showCallout = true;\n this.previousSelectedItem = this.selectedItem;\n  } else {\n this.showCallout = false;\n  }\n}\n```", "```js\nonEditableInput(content) {\n this.filterItems(content);\n}\n```", "```js\nonEditSaved(content) {\n  if (content === '') {\n this.selectedItemChange.next(null);\n  } else if (content !== this.selectedItem && \n             !this.items.includes(content)) {\n this.itemCreated.next(content);\n  }\n}\n```", "```js\n    onEditCanceled() {\n     this.selectedItemChange.next(this.previousSelectedItem);\n    }\n    ```", "```js\nselectItem(item) {\n this.selectedItemChange.next(item);\n}\n\ncreateItem(item) {\n this.itemCreated.next(item);\n}\n```", "```js\n<ngc-editor [content]=\"selectedItem\"\n            [showControls]=\"true\"\n            (editModeChange)=\"onEditModeChange($event)\"\n (editableInput)=\"onEditableInput($event)\"\n (editSaved)=\"onEditSaved($event)\"\n (editCanceled)=\"onEditCanceled($event)\"></ngc-editor>\n```", "```js\n<ul *ngIf=\"showCallout\" class=\"auto-complete__callout\">\n  <li *ngFor=\"let item of filteredItems\"\n      (click)=\"selectItem(item)\"\n      class=\"auto-complete__item\"\n      [class.auto-complete__item--selected]=\"item === selectedItem\">{{item}}</li>\n  <li *ngIf=\"filter && !exactMatch\"\n      (click)=\"createItem(filter)\"\n      class=\"auto-complete__item auto-complete__item--create\">Create \"{{filter}}\"</li>\n</ul>\n```", "```js\n…\nimport {AutoComplete} from '../../ui/auto-complete/auto-complete';\n\n@Component({\n  selector: 'ngc-project-task-details',\n  …\n  directives: […, AutoComplete]\n})\nexport class ProjectTaskDetails {\n  constructor(@Inject(forwardRef(() => Project)) project, {\n    …\n    this.projectChangeSubscription = this.project.document.change.subscribe((data) => {\n      …\n this.projectMilestones = data.milestones || [];\n    });\n  }\n  …\n onMilestoneSelected(milestone) {\n this.task.milestone = milestone;\n this.project.document.persist();\n }\n\n onMilestoneCreated(milestone) {\n this.project.document.data.milestones = this.project.document.data.milestones || [];\n this.project.document.data.milestones.push(milestone);\n this.task.milestone = milestone;\n this.project.document.persist();\n }\n  …\n}\n```", "```js\n…\n<div class=\"task-details__content\">\n  …\n  <ngc-auto-complete [items]=\"projectMilestones\"\n [selectedItem]=\"task?.milestone\"\n (selectedItemChange)=\"onMilestoneSelected($event)\"\n (itemCreated)=\"onMilestoneCreated($event)\">\n  </ngc-auto-complete>\n</div>\n```"]