- en: 14\. Deploying Your Code to the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 将您的代码部署到网络
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to explain the benefits of a CI/CD
    workflow and how it ties into the release cycle, release cadence, and development
    workflows. To this end, you'll be able to articulate what the differences between
    Vue.js development and production builds are and what trade-offs are made. In
    order to test and deploy a Vue.js application, you'll configure GitLab CI/CD with
    pipelines, jobs, and steps. You'll become familiar with Netlify, AWS S3, and AWS
    CloudFront, and their key similarities and differences.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够解释 CI/CD 工作流程的好处以及它是如何与发布周期、发布节奏和开发工作流程相结合的。为此，您将能够阐述 Vue.js 开发与生产构建之间的差异以及所做出的权衡。为了测试和部署
    Vue.js 应用程序，您将配置 GitLab CI/CD，包括管道、作业和步骤。您将熟悉 Netlify、AWS S3 和 AWS CloudFront，以及它们的关键相似之处和差异。
- en: In this chapter, we will look at how to deploy a Vue.js application to be consumed
    over the World Wide Web and how to automate this deployment process to release
    often with ease and confidence.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何将 Vue.js 应用程序部署到万维网，以及如何自动化此部署过程以轻松和有信心地频繁发布。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will look at how you might leverage CI/CD tools and techniques
    to deliver applications to production with high confidence and at high frequency.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用 CI/CD 工具和技术，以高信心和高频率将应用程序交付到生产环境中。
- en: In previous chapters, we saw how to build and test complex Vue.js applications.
    This chapter is about leveraging all the techniques, including testing and automating
    them, in order to deliver software to production with minimal risk and time overhead.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何构建和测试复杂的 Vue.js 应用程序。本章是关于利用所有技术，包括测试和自动化它们，以最小风险和时间开销将软件交付到生产环境中。
- en: The Benefits of CI/CD as Part of an Agile Software Development Process
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD 作为敏捷软件开发过程的一部分的好处
- en: '**Continuous integration** (**CI**) is the practice of integrating code multiple
    times a day. In order to support this, a modern **version control system** (**VCS**)
    such as Git that supports multiple working states (branches) in a single repository
    is necessary in order to allow developers to work on code independently, while
    still allowing them to collaborate and integrate their changes safely.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）是每天多次集成代码的实践。为了支持这一点，需要一个支持单个存储库中多个工作状态（分支）的现代 **版本控制系统**（**VCS**），如
    Git，以便允许开发者独立工作代码，同时仍然允许他们安全地协作和集成他们的更改。'
- en: To augment the abilities of the VCS, hosting and collaboration tools around
    repositories (such as GitLab or GitHub) have been created and allow developers
    to view and manage code changes more efficiently through a web **user interface**
    (**UI**).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强版本控制系统（VCS）、存储库（如 GitLab 或 GitHub）周围的托管和协作工具的能力，已经创建了这些工具，并允许开发者通过网页 **用户界面**（**UI**）更有效地查看和管理代码更改。
- en: As part of, or in addition to, these hosting platforms and the collaboration
    tools they provide, automated checks are crucial to maintaining high confidence
    in the quality of the code before, during, and after integration. Adopting a CI
    approach often entails including additional code quality steps, such as unit or
    integration tests, coverage checks, and building artifacts on the mainline branches
    (branches into which changes are integrated) every time any new code is integrated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些托管平台及其提供的协作工具的一部分，或作为补充，自动检查对于在集成前后保持代码质量的高信心至关重要。采用 CI 方法通常意味着包括额外的代码质量步骤，例如单元或集成测试、覆盖率检查，以及每次任何新代码集成到主线分支（集成更改的分支）时构建工件。
- en: The conventions that a team follows for using Git for code collaboration and
    CI are called a **Git workflow**, which is often shortened to **Git flow**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 团队遵循的用于代码协作和 CI 的 Git 规范被称为 **Git 工作流程**，通常简称为 **Git flow**。
- en: A Git flow will predicate branch naming conventions, as well as how and when
    changes are integrated. For example, a team might decide that branches should
    be prefixed with ticket numbers followed by a short dash-cased description such
    as `WRK-2334-fix-ie-11-scroll`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Git flow 将决定分支命名规范，以及如何以及何时集成更改。例如，一个团队可能会决定分支应以工单编号开头，后跟一个简短的短划线小写描述，例如 `WRK-2334-fix-ie-11-scroll`。
- en: Other examples of conventions that are decided on and adhered to as part of
    a Git flow are commit message lengths and titles, the automated checks that should
    pass or are allowed to fail, and the number of reviewers required to merge a change
    request, which is a pull request or merge request in GitHub and GitLab parlance, respectively.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Git flow的一部分，决定并遵守的其他约定示例包括提交消息的长度和标题、应该通过或允许失败的自动检查，以及合并变更请求所需的审阅者数量，在GitHub和GitLab的术语中，分别称为拉取请求或合并请求。
- en: 'Git flows fall under two rough categories: trunk-based development and (feature)
    branch-based development. We''ll cover branch-based development first since its
    limitations have become quite clear and the majority of projects tend to use trunk-based
    development.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Git流程分为两大类：基于主干的开发和（功能）基于分支的开发。我们将首先介绍基于分支的开发，因为其局限性已经变得非常明显，大多数项目倾向于使用基于主干的开发。
- en: In a branch-based Git workflow, multiple working branches are kept in the repository.
    Branch-based flows can be used to keep branches that mirror the state of environments.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于分支的Git工作流程中，多个工作分支被保存在仓库中。基于分支的流程可以用来保持与环境状态一致的分支。
- en: 'For example, the following diagram shows three branches – **production**, **staging**,
    and **develop**. **production** does not contain any changes from **staging**
    or **develop**. **staging** is ahead of **production** but has no changes in common
    with **develop** other than the changes that are on **production**. **develop**
    is ahead of both **staging** and **production**: it''s branched off of **production**
    at the same commit as **staging** is, but it doesn''t share any further commits
    with **staging**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下图表显示了三个分支——**生产**、**预发布**和**开发**。**生产**不包含来自**预发布**或**开发**的任何变更。**预发布**领先于**生产**，但除了**生产**上的变更外，与**开发**没有共同变更。**开发**领先于**预发布**和**生产**：它在与**预发布**相同的提交上从**生产**分支出来，但它与**预发布**没有共享任何进一步的提交：
- en: '![Figure 14.1: An example of a branch-based Git commit/branch tree'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.1：基于分支的Git提交/分支树示例'
- en: with three environment branches
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个环境分支
- en: '](img/B15218_14_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_01.jpg)'
- en: 'Figure 14.1: An example of a branch-based Git commit/branch tree with three
    environment branches'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：具有三个环境分支的基于分支的Git提交/分支树示例
- en: A branch-based workflow can also be used to keep track of changes going into
    release lines. This is useful in cases where a project has to maintain two versions
    of an application or library, but bug fixes or security patches need to be applied
    to both versions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基于分支的工作流程也可以用来跟踪进入发布线的变更。这在项目需要维护应用程序或库的两个版本，但需要对两个版本都应用错误修复或安全补丁的情况下很有用。
- en: 'In the following example, we have got a similar branching example as the environment
    branch one. Release 1.0.0 contains some changes that are not present in 1.0.1
    and 1.1.0 but does not share any of the newer code. Releases 1.0.1 and 1.1.0 are
    branched off of 1.0.0 at the same time, but they do not share further changes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们有一个与环境分支类似的分支示例。版本1.0.0包含一些在1.0.1和1.1.0中不存在的变化，但不共享任何新的代码。版本1.0.1和1.1.0同时从1.0.0分支出来，但它们没有共享进一步的变更：
- en: '![Figure 14.2: An example of a branch-based Git commit/branch tree'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.2：基于分支的Git提交/分支树示例'
- en: with three release branches
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个发布分支
- en: '](img/B15218_14_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_02.jpg)'
- en: 'Figure 14.2: An example of a branch-based Git commit/branch tree with three
    release branches'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：具有三个发布分支的基于分支的Git提交/分支树示例
- en: 'In a trunk-based Git flow, each member of the team will create new branches
    off of a single branch, usually the "master" branch. This process is often referred
    to as "branching off of":'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于主干分支的Git工作流程中，团队中的每个成员都会从一个单一分支创建新的分支，通常是“master”分支。这个过程通常被称为“从分支分支”：
- en: '![Figure 14.3: A sample trunk-based Git commit/branch tree with two feature
    branches branched off of the master'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.3：一个基于主干分支的Git提交/分支树示例，有两个功能分支从主分支分支出来'
- en: '](img/B15218_14_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_03.jpg)'
- en: 'Figure 14.3: A sample trunk-based Git commit/branch tree with two feature branches
    branched off of the master'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：一个基于主干分支的Git提交/分支树示例，有两个功能分支从主分支分支出来
- en: An extreme case of a trunk-based workflow is to have a *single* branch that
    everyone commits on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干分支的工作流程的一个极端情况是只有一个**单一**的分支供所有人提交。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a trunk-based environment, an alternative to "release branches" is to use
    Git tags to keep track of release snapshots. This gives the same advantages as
    maintaining branches with reduced branch noise and the added benefit of immutability
    since tags cannot be changed once they're created.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于仓库的环境下，"发布分支"的替代方案是使用 Git 标签来跟踪发布快照。这提供了与维护分支相同的优势，即减少了分支噪音，并且由于标签一旦创建就不能更改，因此具有不可变性的额外好处。
- en: '**Continuous delivery** (**CD**) is the ability of a team to deploy every good
    build to a production environment.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续交付（CD**）是团队能够将每个良好的构建部署到生产环境的能力。'
- en: A pre-requisite to CD is CI, since CI provides some initial confidence in the
    quality of a build. As part of CD, new systems, tools, and practices are required
    beyond CI.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付（CD）的一个先决条件是持续集成（CI），因为持续集成（CI）为构建的质量提供了一些初始的信心。作为持续交付（CD）的一部分，除了持续集成（CI）之外，还需要新的系统、工具和实践。
- en: 'Refer to the following diagram for a look at the tools and practices that relate
    more to CI and those that relate more to CD:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下图表，了解与持续集成（CI）和持续交付（CD）相关的工具和实践：
- en: '![Figure 14.4: The relationship between CI and CD practices'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.4：持续集成（CI）和持续交付（CD）实践之间的关系'
- en: '](img/B15218_14_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_04.jpg)'
- en: 'Figure 14.4: The relationship between CI and CD practices'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4：持续集成（CI）和持续交付（CD）实践之间的关系
- en: The extra ingredient required to adopt CD is a high level of confidence that
    the application is going to keep working as expected (for the end user) and that
    new defects have not been unwittingly introduced. This means an additional end-to-end
    testing step is needed during or after the CI checks, to validate the build before
    being able to deploy it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 采用持续交付（CD）所需的额外成分是对应用程序将继续按预期（对于最终用户）工作以及新缺陷没有无意中引入的高度信心。这意味着在能够部署之前，需要在持续集成（CI）检查期间或之后进行额外的端到端测试步骤来验证构建。
- en: These end-to-end tests can be conducted manually, or they can be automated.
    In an ideal CD setup, the latter (automated end-to-end tests) is preferred since
    it means deployments do not include manual interaction. If the end-to-end tests
    pass, the build can automatically be deployed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端到端测试可以手动进行，也可以自动化。在一个理想的持续交付（CD）设置中，后者（自动化端到端测试）是首选的，因为它意味着部署不包括人工交互。如果端到端测试通过，构建可以自动部署。
- en: In order to facilitate CD, systems used to deploy software have had to be rethought.
    As part of CD, deployment cannot be a long-winded manual process. This has led
    to companies adopting cloud-native technologies, such as Docker, and infrastructure
    as code tools, such as HashiCorp's **Terraform**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进持续交付（CD），用于部署软件的系统必须重新思考。作为 CD 的一部分，部署不能是一个冗长的手动过程。这导致公司采用云原生技术，如 Docker，以及基础设施即代码工具，如
    HashiCorp 的 **Terraform**。
- en: The emphasis on moving toward CD practices has led to the inception of ideas
    such as **GitOps** and **ChatOps**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 向持续交付（CD）实践转变的强调导致了 **GitOps** 和 **ChatOps** 等想法的诞生。
- en: In GitOps and ChatOps, deployments and operational tasks are driven by the tools
    that developers and stakeholders interact with daily.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitOps 和 ChatOps 中，部署和运营任务是由开发者和利益相关者每天交互的工具驱动的。
- en: In GitOps, deployments can be done through GitHub/GitLab (or another Git-hosting
    provider), directly with GitHub Actions or GitLab CI/CD, or through CI/CD software
    (such as CircleCI or Jenkins), which have tight integrations and reporting with
    GitHub/GitLab.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitOps 中，可以通过 GitHub/GitLab（或另一个 Git 托管提供商）、直接使用 GitHub Actions 或 GitLab CI/CD，或者通过具有紧密集成和报告功能的持续集成/持续交付（CI/CD）软件（如
    CircleCI 或 Jenkins）来进行部署。
- en: In the case of ChatOps, conversational interfaces are used to deploy and operate
    software. Some flavors of ChatOps can be considered a subset of GitOps, for example,
    interacting with tools such as `deploy <service-name> <environment>`, which will
    deploy the service to the relevant environment. Note that chat interfaces are
    very reminiscent of command-line interfaces that developers might be used to but
    other stakeholders might take some time to adopt.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ChatOps 的情况下，使用对话界面来部署和操作软件。某些 ChatOps 的变体可以被认为是 GitOps 的子集，例如，与 `deploy <service-name>
    <environment>` 等工具交互，这些工具会将服务部署到相关环境。请注意，聊天界面非常类似于开发者可能习惯的命令行界面，但其他利益相关者可能需要一些时间来适应。
- en: 'We''ve now looked at approaches to CI and CD; what we''ll discuss next is the
    advantages of using CI and CD:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经探讨了持续集成（CI）和持续交付（CD）的方法；接下来我们将讨论使用持续集成（CI）和持续交付（CD）的优势：
- en: '![Figure 14.5: Advantages of CI and CD'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.5：持续集成（CI）和持续交付（CD）的优势'
- en: '](img/B15218_14_05.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_05.jpg)'
- en: 'Figure 14.5: Advantages of CI and CD'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5：持续集成（CI）和持续交付（CD）的优势
- en: Both practices also have an impact on the team's mindset and performance. Being
    able to see the changes you make integrated within a day and in production in
    less than a week means that contributors can see their work having an impact immediately.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种实践也会对团队的心态和表现产生影响。能够在一天内看到您的更改集成，并在一周内将其部署到生产环境中，这意味着贡献者可以立即看到他们的工作产生了影响。
- en: CI/CD also helps promote agile principles, where changes are applied and deployed
    iteratively. This is as opposed to long timelines for projects, for which inaccuracies
    in estimations compound and can cause major delays.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 还有助于推广敏捷原则，其中更改是迭代地应用和部署的。这与项目长期的时间表形成对比，其中估计的不准确会累积并可能导致重大延误。
- en: Building for Production
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为生产构建
- en: Deploying applications to production starts with creating an artifact that can
    be deployed. In the case of Vue.js, we're building a client-side application,
    which means our build artifact will contain HTML, JavaScript, and CSS files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到生产环境始于创建一个可以部署的工件。在 Vue.js 的情况下，我们正在构建一个客户端应用程序，这意味着我们的构建工件将包含 HTML、JavaScript
    和 CSS 文件。
- en: The Vue CLI comes with a `build` command. This `build` command will take our
    Vue.js single-file components (`.vue` files) and compile them into render functions
    (JavaScript functions that the Vue runtime can use to render our application)
    that will be output to JavaScript.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Vue CLI 内置了一个 `build` 命令。这个 `build` 命令将把我们的 Vue.js 单文件组件（`.vue` 文件）编译成渲染函数（Vue
    运行时可以使用这些函数来渲染我们的应用程序），并将它们输出到 JavaScript 中。
- en: As part of the build process, the Vue CLI will take JavaScript, Vue single-file
    components, and modules that are imported into each other and *bundle* them. Bundling
    means that related chunks of code that depend on each other will be output as
    a single JavaScript file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为构建过程的一部分，Vue CLI 将会处理 JavaScript、Vue 单文件组件以及相互导入的模块，并将它们 *打包*。打包意味着相互依赖的相关代码块将被输出为一个单一的
    JavaScript 文件。
- en: Due to our use of the Vue CLI, the Vue.js library itself can also be slimmed
    down. The Vue.js runtime bundle can include a **runtime compiler** that takes
    string templates and turns them into render functions on the client side. Since
    we are compiling to render functions with the Vue CLI at build time, this part
    of Vue.js doesn't need to be included in our JavaScript.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了 Vue CLI，Vue.js 库本身也可以被精简。Vue.js 运行时包可以包含一个 **运行时编译器**，它可以将字符串模板转换为客户端上的渲染函数。由于我们在构建时使用
    Vue CLI 编译为渲染函数，因此 Vue.js 的这部分不需要包含在我们的 JavaScript 中。
- en: The Vue CLI build step also includes a `dead code elimination` step. That means
    that it can analyze the code being generated and if any of it is obviously never
    used – for example, a statement such as `if (false) { /* do something */}` – then
    it will not be present in the build output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Vue CLI 的构建步骤还包括一个 `死代码消除` 步骤。这意味着它可以分析正在生成的代码，如果其中任何部分显然从未使用过——例如，一个如 `if (false)
    { /* do something */ }` 这样的语句——那么它将不会出现在构建输出中。
- en: By default, the Vue CLI builds for production when we call `vue service build`,
    which in Vue CLI projects is aliased to the `build` script, which can be run with
    `npm run build` or `yarn build`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当我们调用 `vue service build` 时，Vue CLI 会为生产环境构建，这在 Vue CLI 项目中是通过 `build`
    脚本来实现的，可以使用 `npm run build` 或 `yarn build` 来运行。
- en: 'In a sample Vue CLI project, we''ll see something along these lines:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个示例 Vue CLI 项目中，我们将看到类似以下的内容：
- en: '![Figure 14.6: Output of "npm run build" in a fresh Vue CLI project'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.6：在新的 Vue CLI 项目中 "npm run build" 的输出'
- en: '](img/B15218_14_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_14_06.jpg](img/B15218_14_06.jpg)'
- en: 'Figure 14.6: Output of "npm run build" in a fresh Vue CLI project'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6：在新的 Vue CLI 项目中 "npm run build" 的输出
- en: The `dist` folder is now ready to deploy using a static hosting solution such
    as Netlify or AWS S3 and CloudFront.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`dist` 文件夹现在可以使用静态托管解决方案（如 Netlify 或 AWS S3 和 CloudFront）进行部署。'
- en: We have now seen how to build a Vue.js application for production using the
    Vue CLI with the `npm run build` command.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用 Vue CLI 和 `npm run build` 命令来构建用于生产的 Vue.js 应用程序。
- en: Next, we will see how to use GitLab CI/CD to test our code (before deploying
    it).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何使用 GitLab CI/CD 来测试我们的代码（在部署之前）。
- en: Using GitLab CI/CD to Test Your Code
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitLab CI/CD 测试您的代码
- en: GitLab has a built-in CI/CD tool called GitLab CI/CD.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 有一个内置的 CI/CD 工具，称为 GitLab CI/CD。
- en: In order to use GitLab CI/CD, you'll need a GitLab account.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 GitLab CI/CD，您需要一个 GitLab 账户。
- en: To interact with Git repositories hosted on GitLab, you'll also need to associate
    an SSH key from your machine and to your GitLab account.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要与托管在 GitLab 上的 Git 仓库交互，您还需要将您机器上的 SSH 密钥与您的 GitLab 账户关联。
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instructions to add an SSH key in the GitLab documentation can be found at [https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html](https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitLab 文档中添加 SSH 密钥的说明可以在 [https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html](https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html)
    找到。
- en: 'Once you''ve created an account, you can create a new repository using the
    `New Project` button at the top right of the `Projects` page, as shown in the
    following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了账户，您可以使用 `项目` 页面右上角的 `新建项目` 按钮创建一个新的存储库，如图所示 截图：
- en: '![Figure 14.7: The GitLab "Projects" page with the New Project button'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.7：带有新建项目按钮的 GitLab "项目"页面'
- en: '](img/B15218_14_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_07.jpg)'
- en: 'Figure 14.7: The GitLab "Projects" page with the New Project button'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7：带有新建项目按钮的 GitLab "项目"页面
- en: 'If you click the `New Project` button, you will be taken to the `New Project`
    page, where you can use the default `Blank Project` tab to create a project by
    giving it a name and a slug, as seen in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击 `新建项目` 按钮，您将被带到 `新建项目` 页面，在那里您可以使用默认的 `空白项目` 选项卡通过给它一个名称和 slug 来创建项目，如图所示 截图：
- en: '![Figure 14.8: The GitLab New Project page with Blank Project selected'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.8：选择空白项目的 GitLab 新项目页面'
- en: '](img/B15218_14_08.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_08.jpg)'
- en: 'Figure 14.8: The GitLab New Project page with Blank Project selected'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8：选择空白项目的 GitLab 新项目页面
- en: 'Once you click `Create Project`, the GitLab `Project` page will appear in an
    empty state that displays instructions on how to clone it. You should run the
    commands required to clone the repository, which probably boils down to an equivalent
    of the following (which you are expected to run on your machine):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您点击 `创建项目`，GitLab `项目` 页面将以空状态出现，显示如何克隆项目的说明。您应该运行克隆存储库所需的命令，这可能是以下等效命令（您应该在您的机器上运行）：
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you did not associate an SSH key with your account, at this stage GitLab
    should be showing you a warning with a link you can follow to set up an SSH key.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有将 SSH 密钥与您的账户关联，在此阶段 GitLab 应该会显示一个带有您可点击链接的警告，以设置 SSH 密钥。
- en: '`git clone <repository-url>`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clone <repository-url>`'
- en: On your machine, you should then open the directory into which the repository
    was cloned. To add GitLab CI/CD, we need to add a `.gitlab-ci.yml` file into the
    root of the project. A sample `.gitlab-ci.yml` file that adds a `build` job to
    the `build` stage of the pipeline that installs dependencies (using `npm ci`),
    runs the production build (`npm run build`), and caches the output artifact is
    defined as follows.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上，您应该打开已克隆存储库的目录。为了添加 GitLab CI/CD，我们需要在项目的根目录中添加一个 `.gitlab-ci.yml` 文件。一个示例
    `.gitlab-ci.yml` 文件，它将一个 `build` 作业添加到管道的 `build` 阶段，用于安装依赖项（使用 `npm ci`），运行生产构建（`npm
    run build`），并缓存输出工件，定义如下。
- en: The job name is defined by setting a top-level key in the YAML file – in this
    case, `build:`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 作业名称是通过在 YAML 文件中设置顶级键来定义的——在这种情况下，`build:`。
- en: In YAML syntax, we'll then increase the indent to denote that the `build` key
    points to an object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 YAML 语法中，我们将增加缩进来表示 `build` 键指向一个对象。
- en: 'In the `build job` object, we will define which Docker image is used to run
    the job, using `image: node:lts`. This means we want this job to run on a Node.js
    **Long Term Support** (**LTS**) image, which will be Node.js 12 until October
    20, 2020, at which point it will point to a Node.js 14 image.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `build job` 对象中，我们将定义用于运行作业的 Docker 镜像，使用 `image: node:lts`。这意味着我们希望这个作业在
    Node.js **长期支持** (**LTS**) 镜像上运行，该镜像将是 Node.js 12，直到 2020 年 10 月 20 日，届时它将指向 Node.js
    14 镜像。'
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can access the up-to-date Node.js LTS schedule at [https://nodejs.org/en/about/releases/](https://nodejs.org/en/about/releases/).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://nodejs.org/en/about/releases/](https://nodejs.org/en/about/releases/)
    访问最新的 Node.js LTS 发布计划。
- en: 'The other property we can define in our job is the stage. GitLab CI/CD pipelines
    by default have three stages: **build**, **test**, and **deploy**. These stages
    can be replaced using custom stages when a team''s workflow doesn''t fit into
    these three categories (for example, if there is more than one environment to
    deploy to). See the documentation ([https://docs.gitlab.com/ee/ci/yaml/#stages](https://docs.gitlab.com/ee/ci/yaml/#stages)).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在作业中定义的另一个属性是阶段。GitLab CI/CD 管道默认有三个阶段：**构建**、**测试**和**部署**。当团队的工作流程不适合这三个类别时（例如，如果需要部署到多个环境），可以使用自定义阶段来替换这些阶段。请参阅文档
    ([https://docs.gitlab.com/ee/ci/yaml/#stages](https://docs.gitlab.com/ee/ci/yaml/#stages))。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`stages` is used to define stages that can be used by jobs, and it is defined globally.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`stages`用于定义作业可以使用的阶段，并且它是全局定义的。'
- en: 'The specification of `stages` allows for flexible multistage pipelines. The
    ordering of elements in stages defines the ordering of jobs'' execution:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`stages`的指定允许灵活的多阶段管道。阶段中元素的顺序定义了作业执行的顺序：'
- en: a) Jobs of the same stage are run in parallel.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: a) 同一阶段的作业是并行运行的。
- en: b) Jobs of the next stage are run after the jobs from the previous stage complete
    successfully.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: b) 下一个阶段的作业将在前一个阶段的作业成功完成后运行。
- en: Our pipeline only has one stage and one job at the moment, so most of the preceding
    doesn't apply to us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管道目前只有一个阶段和一个作业，所以大部分前面的内容对我们不适用。
- en: The final properties we set are `script`, which defines steps that should be
    run when the job is running, and `artifacts`, which configures artifact storage.
    In our case, we'll run `npm ci` to install all dependencies followed by `npm run
    build`, which will run the production Vue.js CLI build. Our artifact is set up
    to be held for a week and to contain the `dist` folder (which is where the Vue
    CLI `build` output is stored).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的最后一个属性是`script`，它定义了在作业运行时应运行的步骤，以及`artifacts`，它配置了工件存储。在我们的例子中，我们将运行`npm
    ci`来安装所有依赖项，然后运行`npm run build`，这将运行生产Vue.js CLI构建。我们的工件被设置为保留一周，并包含`dist`文件夹（Vue
    CLI `build`输出存储的地方）。
- en: 'In full, we have the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 完整来说，我们有以下内容：
- en: '[PRE0]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we push this `.gitlab-ci.yml` file to a repository containing a Vue CLI
    project, we will see the following in the repository view, where a pipeline with
    one step is running on the latest commit:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将这个`.gitlab-ci.yml`文件推送到包含Vue CLI项目的仓库中，我们将在仓库视图中看到以下内容，其中有一个步骤的管道正在最新提交上运行：
- en: '![Figure 14.9: GitLab repository view with the build job running on the latest
    commit'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.9：GitLab仓库视图，显示在最新提交上运行的构建作业'
- en: '](img/B15218_14_09.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_09.jpg)'
- en: 'Figure 14.9: GitLab repository view with the build job running on the latest
    commit'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9：GitLab仓库视图，显示在最新提交上运行的构建作业
- en: 'If we click on the `Pipeline` icon (the blue in-progress indicator), we get
    the pipeline view. In the pipeline view, `Build` represents the `state` pipeline
    (which we set as `build`) and it represents the job name (which we defined as
    `build`). We see the same in-progress indicator until the job completes, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击`Pipeline`图标（蓝色进行中指示器），我们将获得管道视图。在管道视图中，`Build`代表`状态管道`（我们将其设置为`build`）并且它代表作业名称（我们将其定义为`build`）。在作业完成之前，我们会看到相同的进行中指示器，如下所示：
- en: '![Figure 14.10: GitLab CI pipeline view with the build job running'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.10：GitLab CI管道视图，显示正在运行的构建作业'
- en: '](img/B15218_14_10.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_10.jpg)'
- en: 'Figure 14.10: GitLab CI pipeline view with the build job running'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10：GitLab CI管道视图，显示正在运行的构建作业
- en: 'Once the job completes, we see a `success` icon (green check-mark). We can
    click this icon or the job name to access the job view while the job is running
    or after it has completed (whether it has failed or succeeded). When a job has
    completed, we also see a `Retry` icon, which can be useful to retry a failed pipeline
    step. The following screenshot shows that the job ran successfully:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作业完成后，我们会看到一个`成功`图标（绿色勾号）。我们可以在作业运行时或完成后（无论它是否失败或成功）点击此图标或作业名称来访问作业视图。当作业完成时，我们还会看到一个`重试`图标，这可以用来重试失败的管道步骤。以下截图显示了作业成功运行：
- en: '![Figure 14.11: GitLab CI pipeline view with the build job passing'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.11：GitLab CI管道视图，显示构建作业通过'
- en: '](img/B15218_14_11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_11.jpg)'
- en: 'Figure 14.11: GitLab CI pipeline view with the build job passing'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11：GitLab CI管道视图，显示构建作业通过
- en: 'After clicking the job, we see the `Job` view, which shows us a detailed breakdown
    of all the steps in the job. Starting with the `Preparing the docker_machine executor`
    steps, which load up the Node.js Docker image, we see steps for running the script
    as well as cache and artifact restores, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 点击作业后，我们会看到`作业`视图，它显示了作业中所有步骤的详细分解。从`准备docker_machine执行器`步骤开始，该步骤加载Node.js Docker镜像，我们看到运行脚本以及缓存和工件恢复的步骤，如下所示：
- en: '![Figure 14.12: The GitLab CI job view with the successful build job'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.12：GitLab CI作业视图，显示成功的构建作业'
- en: '](img/B15218_14_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_12.jpg)'
- en: 'Figure 14.12: The GitLab CI job view with the successful build job'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12：GitLab CI作业视图，显示成功的构建作业
- en: If we want to add a `test` step to our GitLab CI/CD runs, we need to be in a
    project that supports unit testing. This can be achieved using the Vue CLI, which
    is installed using `vue add @vue/unit-jest`. Installing and adding unit tests
    is covered in depth in *Chapter 12*, *Unit Testing*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在GitLab CI/CD运行中添加`test`步骤，我们需要在一个支持单元测试的项目中。这可以通过使用Vue CLI来实现，它是通过`vue
    add @vue/unit-jest`安装的。安装和添加单元测试在*第12章*，*单元测试*中进行了详细说明。
- en: 'We will need to add a new job to the `.gitlab-ci.yml` file; we will call it
    `test`, use the `node:lts` image, and assign the job to the `test` state. In the
    job, we run `npm ci`, followed by `npm run test:unit` (which is the `npm` script
    added by the `unit-jest` CLI plugin):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`.gitlab-ci.yml`文件中添加一个新的作业；我们将称之为`test`，使用`node:lts`镜像，并将作业分配给`test`状态。在作业中，我们运行`npm
    ci`，然后是`npm run test:unit`（这是由`unit-jest` CLI插件添加的`npm`脚本）：
- en: '[PRE1]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once we push this new `.gitlab-ci.yml` file up, we get the following view on
    the main repository page:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们推送这个新的`.gitlab-ci.yml`文件，我们将在主存储库页面上看到以下视图：
- en: '![Figure 14.13: Repository view with GitLab CI/CD running the pipeline with
    the new test step'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.13：存储库视图，GitLab CI/CD正在运行包含新测试步骤的管道'
- en: '](img/B15218_14_13.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_13.jpg)'
- en: 'Figure 14.13: Repository view with GitLab CI/CD running the pipeline with the
    new test step'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13：存储库视图，GitLab CI/CD正在运行包含新测试步骤的管道
- en: 'We can click through to the pipeline view. The reason GitLab CI/CD uses pipelines
    is that a failing step at a certain stage will mean steps in any subsequent stages
    will not run. For example, if we get a failing `build` job, the jobs that are
    part of the `test` stage will not run. The following screenshot explains this
    well:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击进入管道视图。GitLab CI/CD使用管道的原因是，在某个阶段的失败步骤将意味着后续阶段的步骤将不会运行。例如，如果我们得到一个失败的`build`作业，`test`阶段的作业将不会运行。以下截图很好地解释了这一点：
- en: '![Figure 14.14: GitLab CI/CD pipeline view with a failed build job that stops'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.14：GitLab CI/CD管道视图，失败的构建作业阻止'
- en: the test job/stage from running
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 测试作业/阶段运行
- en: '](img/B15218_14_14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_14.jpg)'
- en: 'Figure 14.14: GitLab CI/CD pipeline view with a failed build job that stops
    the test job/stage from running'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14：GitLab CI/CD管道视图，失败的构建作业阻止测试作业/阶段运行
- en: 'If we push another commit or retry the build step (if the failure is not caused
    by changes) and navigate to the pipeline view again, we''ll see the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次提交另一个提交或重试构建步骤（如果失败不是由更改引起的）并再次导航到管道视图，我们将看到以下内容：
- en: '![Figure 14.15: GitLab CI/CD pipeline view with the test job running'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.15：GitLab CI/CD管道视图，测试作业正在运行'
- en: after the build stage jobs have all succeeded
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 构建阶段的作业全部成功后
- en: '](img/B15218_14_15.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_15.jpg)'
- en: 'Figure 14.15: GitLab CI/CD pipeline view with the test job running after the
    build stage jobs have all succeeded'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15：构建阶段作业全部成功后，GitLab CI/CD管道视图中的测试作业正在运行
- en: 'Once the `test` job has succeeded, we''ll see the following pipeline:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`测试`作业成功，我们将看到以下管道：
- en: '![Figure 14.16: GitLab CI/CD pipeline view with all jobs succeeding in the
    build and test stages'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.16：GitLab CI/CD管道视图，构建和测试阶段的作业全部成功'
- en: '](img/B15218_14_16.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_16.jpg)'
- en: 'Figure 14.16: GitLab CI/CD pipeline view with all jobs succeeding in the build
    and test stages'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16：GitLab CI/CD管道视图，构建和测试阶段的作业全部成功
- en: We've now added a GitLab CI/CD pipeline with the `build` and `test` stages that
    will validate that on every push to the GitLab repository, the code still integrates
    as expected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已添加了一个包含`build`和`test`阶段的GitLab CI/CD管道，该管道将验证在每次向GitLab存储库推送时，代码仍然按预期集成。
- en: 'Exercise 14.01: Adding a Lint Step to Your GitLab CI/CD Pipeline'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.01：向您的GitLab CI/CD管道添加Lint步骤
- en: Linting is a way to get automated formatting and code style checks. Integrating
    it as part of CI makes sure that all code merged into the mainline branches adheres
    to a team's code style guide. It also reduces the number of code style review
    comments, which can be noisy and might detract from fundamental issues with the
    change request.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Linting是一种获取自动化格式化和代码风格检查的方法。将其集成到CI中可以确保所有合并到主线分支的代码都遵循团队的代码风格指南。它还减少了代码风格审查评论的数量，这些评论可能会很嘈杂，并可能分散对更改请求的基本问题的关注。
- en: 'To access the code files for this exercise, refer to [https://packt.live/2IQDFW0](https://packt.live/2IQDFW0):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2IQDFW0](https://packt.live/2IQDFW0)：
- en: 'In order to add linting, we need to ensure that our `package.json` file includes
    the `lint` script. If it''s missing, we''ll need to add it and set it to `vue-cli-service
    lint`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了添加代码检查，我们需要确保我们的 `package.json` 文件中包含 `lint` 脚本。如果它缺失，我们需要添加它并将其设置为 `vue-cli-service
    lint`：
- en: '[PRE2]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to run the lint on GitLab CI/CD, we need to add a new `lint` job that
    will run in a Node.js LTS Docker image at the `test` stage of the GitLab CI/CD
    pipeline. We will do this in `.gitlab-ci.yml`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在 GitLab CI/CD 上运行代码检查，我们需要添加一个新的 `lint` 作业，该作业将在 GitLab CI/CD 管道的 `test`
    阶段运行在 Node.js LTS Docker 映像中。我们将在 `.gitlab-ci.yml` 中这样做：
- en: '[PRE3]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the `lint` job to run the `lint` script as per `package.json`, we need
    to add a `script` section in the `.gitlab-ci.yml` file. It first needs to run
    `npm ci` to install the dependencies, and then `npm run lint` to run the linting:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让 `lint` 作业按照 `package.json` 中的设置运行 `lint` 脚本，我们需要在 `.gitlab-ci.yml` 文件中添加一个
    `script` 部分。首先需要运行 `npm ci` 来安装依赖项，然后运行 `npm run lint` 来执行代码检查：
- en: '[PRE4]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we need to commit and push the code to GitLab using the following commands:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要使用以下命令提交和推送代码到 GitLab：
- en: '[PRE5]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the code is pushed, we can see the pipeline run using the GitLab CI/CD
    UI, as follows. Note how all the jobs at the `test` stage are run in parallel:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦代码被推送，我们就可以通过 GitLab CI/CD UI 看到管道运行，如下所示。注意，在 `test` 阶段的全部作业都是并行运行的：
- en: '![Figure 14.17: The GitLab CI/CD pipeline view with all the jobs succeeding,'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.17：GitLab CI/CD 管道视图，所有作业均成功，包括并行运行的 "test" 和 "lint"](img/B15218_14_17.jpg)'
- en: including "test" and "lint" running in parallel
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包括并行运行的 "test" 和 "lint"
- en: '](img/B15218_14_17.jpg)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_14_17.jpg](img/B15218_14_17.jpg)'
- en: 'Figure 14.17: The GitLab CI/CD pipeline view with all the jobs succeeding,
    including "test" and "lint" running in parallel'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.17：GitLab CI/CD 管道视图，所有作业均成功，包括并行运行的 "test" 和 "lint"
- en: We've now seen how to use GitLab CI/CD to run builds and tests on every commit.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用 GitLab CI/CD 在每次提交时运行构建和测试。
- en: Next, we'll see how to deploy a Vue.js application to Netlify.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何将 Vue.js 应用程序部署到 Netlify。
- en: Deploying to Netlify
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到 Netlify
- en: Netlify is a hosting provider that specializes in static hosting and relevant
    supporting services in order to have a fully interactive site that uses static
    hosting. This includes offerings such as Netlify Functions (serverless functions),
    Netlify Forms (a no-backend form submission system), and Netlify Identity (an
    identity/authentication provider).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify 是一家专注于静态托管和相关支持服务的托管提供商，以便拥有一个使用静态托管的全交互网站。这包括诸如 Netlify Functions（无服务器函数）、Netlify
    Forms（无后端表单提交系统）和 Netlify Identity（身份/认证提供商）等服务。
- en: The following sections require you to have a Netlify account, which is free.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分需要您拥有一个 Netlify 账户，这是免费的。
- en: 'The simplest way to deploy a site to Netlify is to use the drag and drop interface.
    You''ll find this at the bottom of the home page in the logged-in view: [https://app.netlify.com](https://app.netlify.com).
    It looks as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将网站部署到 Netlify 的最简单方法是使用拖放界面。您可以在登录视图的首页底部找到它：[https://app.netlify.com](https://app.netlify.com)。它看起来如下所示：
- en: '![Figure 14.18: Netlify''s drag and drop deployment section at the'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.18：Netlify 的拖放部署区域位于 App 首页底部](img/B15218_14_18.jpg)'
- en: bottom of the App home page
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: App 首页底部
- en: '](img/B15218_14_18.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_14_18.jpg](img/B15218_14_18.jpg)'
- en: 'Figure 14.18: Netlify''s drag and drop deployment section at the bottom of
    the App home page'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.18：Netlify 的拖放部署区域位于 App 首页底部
- en: 'We can, therefore, choose a project where we''ve run the `npm run build` command
    and deploy the `dist` folder by simply dragging it to the drag and drop deployment
    section, as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以选择一个已经运行过 `npm run build` 命令并可以通过简单地将 `dist` 文件夹拖动到拖放部署区域来部署的项目，如下面的截图所示：
- en: '![Figure 14.19: Dragging and dropping the dist folder onto the Netlify drag
    and drop deployment section'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.19：将 dist 文件夹拖放到 Netlify 拖放部署区域](img/B15218_14_19.jpg)'
- en: '](img/B15218_14_19.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_14_19.jpg](img/B15218_14_19.jpg)'
- en: 'Figure 14.19: Dragging and dropping the dist folder onto the Netlify drag and
    drop deployment section'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.19：将 dist 文件夹拖放到 Netlify 拖放部署区域
- en: 'Once the upload has succeeded, Netlify redirects you to your new website''s
    administration page. This will look as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上传成功，Netlify 会将您重定向到您的新网站管理页面。它看起来如下所示：
- en: '![Figure 14.20: The Netlify new app page for the drag and drop site'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.20：Netlify 新应用页面用于拖放网站](img/B15218_14_20.jpg)'
- en: '](img/B15218_14_20.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_14_20.jpg](img/B15218_14_20.jpg)'
- en: 'Figure 14.20: The Netlify new app page for the drag and drop site'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.20：Netlify 新应用页面用于拖放网站
- en: 'We can click on the link to the site and we''ll see the default Vue CLI home
    page template, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击网站链接，然后我们会看到默认的 Vue CLI 首页模板，如下所示：
- en: '![Figure 14.21: Netlify new app displaying a greeting message'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.21：Netlify新应用显示问候信息]'
- en: '](img/B15218_14_21.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_14_21.jpg]'
- en: 'Figure 14.21: Netlify new app displaying a greeting message'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.21：Netlify新应用显示问候信息
- en: We have now seen how to manually deploy a site to Netlify using the drag and
    drop interface.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用拖放界面手动将站点部署到Netlify。
- en: Next, we will see how to deploy our site from GitLab to Netlify.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何从GitLab将我们的站点部署到Netlify。
- en: 'On the Netlify app home page, we need to click the `New site from Git` button,
    as displayed in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Netlify应用主页上，我们需要点击显示在以下截图中的“从Git创建新站点”按钮：
- en: '![Figure 14.22: Netlify home page with the New site from Git button'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.22：Netlify主页，带有从Git创建新站点的按钮]'
- en: '](img/B15218_14_22.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_14_22.jpg]'
- en: 'Figure 14.22: Netlify home page with the New site from Git button'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.22：Netlify主页，带有从Git创建新站点的按钮
- en: 'We''ll see a page asking us to choose a Git provider to connect to. For this
    example, we will use `GitLab`. The following screenshot represents how the screen
    will look:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个页面，要求我们选择要连接的Git提供商。在这个例子中，我们将使用“GitLab”。以下截图显示了屏幕将如何显示：
- en: '![Figure 14.23: Netlify – Create a new site | Connect to Git provider'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.23：Netlify – 创建新站点 | 连接到Git提供商]'
- en: '](img/B15218_14_23.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_14_23.jpg]'
- en: 'Figure 14.23: Netlify – Create a new site | Connect to Git provider'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.23：Netlify – 创建新站点 | 连接到Git提供商
- en: 'Upon clicking `GitLab`, we will get an OAuth authorization challenge from GitLab,
    which we need to accept by clicking on the `Authorize` button as shown in the
    following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“GitLab”后，我们将收到GitLab的OAuth授权挑战，我们需要通过点击以下截图所示的“授权”按钮来接受：
- en: '![Figure 14.24: GitLab OAuth authorization modal'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.24：GitLab OAuth授权模态框]'
- en: '](img/B15218_14_24.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_14_24.jpg]'
- en: 'Figure 14.24: GitLab OAuth authorization modal'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.24：GitLab OAuth授权模态框
- en: 'We will then be redirected to Netlify and asked to choose a repository to deploy,
    as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将被重定向到Netlify，并被要求选择要部署的仓库，如下所示：
- en: '![Figure 14.25: Select a GitLab repository to deploy'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.25：选择要部署的GitLab仓库]'
- en: '](img/B15218_14_25.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_14_25.jpg]'
- en: 'Figure 14.25: Select a GitLab repository to deploy'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.25：选择要部署的GitLab仓库
- en: We select the repository we want to deploy and are met with a configuration
    page. Since we're now building on Netlify's build servers, we need to configure
    Netlify to build the application and deploy the correct folder.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择我们想要部署的仓库，并遇到一个配置页面。由于我们现在是在Netlify的构建服务器上构建，我们需要配置Netlify以构建应用程序并部署正确的文件夹。
- en: We fill out the `build` command as `npm run build` since that's our build script.
    The publish directory is `dist`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建命令填写为“npm run build”，因为这是我们构建脚本。发布目录是“dist”。
- en: 'We can then click the `Deploy site` button, which will start the deployment
    process, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以点击“部署站点”按钮，这将启动部署过程，如下所示：
- en: '![Figure 14.26: The Netlify build configuration tab, filled in with npm run
    build'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.26：Netlify构建配置选项卡，已填写npm run build]'
- en: and dist for the build command and publish directory, respectively
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 分别为构建命令和发布目录的dist
- en: '](img/B15218_14_26.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_14_26.jpg]'
- en: 'Figure 14.26: The Netlify build configuration tab, filled in with npm run build
    and dist for the build command and publish directory, respectively'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.26：Netlify构建配置选项卡，已填写npm run build和dist作为构建命令和发布目录
- en: 'We will then be redirected to the newly created app''s page, as shown here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将被重定向到新创建的应用程序页面，如下所示：
- en: '![Figure 14.27: New Netlify app'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.27：新的Netlify应用]'
- en: '](img/B15218_14_27.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_14_27.jpg]'
- en: 'Figure 14.27: New Netlify app'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.27：新的Netlify应用
- en: We have now seen how to deploy an application to Netlify using the manual upload
    method and using GitLab as the Git hosting provider.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用手动上传方法将应用程序部署到Netlify，以及如何使用GitLab作为Git托管提供商。
- en: 'Exercise 14.02: Deploying a Site to Netlify from GitHub'
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.02：从GitHub将站点部署到Netlify
- en: 'We have seen how to deploy a site to Netlify from GitLab, but how different
    is it from deploying it from GitHub? The answer is that they are very similar;
    the only notable difference is the first step in the `Connect to Git provider`
    tab:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何从GitLab将站点部署到Netlify，但它与从GitHub部署有何不同？答案是它们非常相似；唯一的显著区别是“连接到Git提供商”选项卡中的第一步：
- en: 'We''ll begin by clicking the `New site from Git` button on the home page, as follows:![Figure
    14.28: New site from Git on the Netlify dashboard'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先点击主页上的“从Git创建新站点”按钮，如下所示：![图 14.28：Netlify仪表板上的从Git创建新站点]
- en: '](img/B15218_14_28.jpg)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_14_28.jpg]'
- en: 'Figure 14.28: New site from Git on the Netlify dashboard'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.28：Netlify 控制台上的 Git 新站点
- en: 'We will then choose `GitHub` as the Git hosting provider, as shown in the following
    screenshot:![Figure 14.29: Continuous Deployment'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将选择 `GitHub` 作为 Git 托管提供商，如下截图所示：![图 14.29：持续部署
- en: '](img/B15218_14_29.jpg)'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_14_29.jpg)'
- en: 'Figure 14.29: Continuous Deployment'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.29：持续部署
- en: 'When we get the GitHub OAuth authorization challenge, as shown in the following
    screenshot, we authorize Netlify:![Figure 14.30: GitHub authorization challenge'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们遇到 GitHub OAuth 授权挑战，如下截图所示，我们授权 Netlify：![图 14.30：GitHub 授权挑战
- en: '](img/B15218_14_30.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_14_30.jpg)'
- en: 'Figure 14.30: GitHub authorization challenge'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.30：GitHub 授权挑战
- en: 'We select the Vue CLI project we want to deploy from the repository list, as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从仓库列表中选择我们想要部署的 Vue CLI 项目，如下所示：
- en: '![Figure 14.31: Selecting the correct repository'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图 14.31：选择正确的仓库'
- en: '](img/B15218_14_31.jpg)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_14_31.jpg)'
- en: 'Figure 14.31: Selecting the correct repository'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.31：选择正确的仓库
- en: On the deployment options tab, we select `master` as the branch to deploy.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署选项选项卡上，我们选择 `master` 作为要部署的分支。
- en: We set the build command as `npm run build`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将构建命令设置为 `npm run build`。
- en: We set the publish directory as `dist`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将发布目录设置为 `dist`。
- en: 'The completed deployment options look as follows:![Figure 14.32: The Netlify
    build configuration tab filled in with npm run'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成的部署选项如下所示：![图 14.32：Netlify 构建配置选项卡已填写 npm run
- en: build and dist for the build command and publish directory, respectively
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: build 和 dist 分别代表构建命令和发布目录
- en: '](img/B15218_14_32.jpg)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_14_32.jpg)'
- en: 'Figure 14.32: The Netlify build configuration tab filled in with npm run build
    and dist for the build command and publish directory, respectively'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.32：Netlify 构建配置选项卡已填写 npm run build 和 dist，分别代表构建命令和发布目录
- en: We click `Deploy site` to start the deployment process.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击 `部署站点` 以开始部署过程。
- en: We've now seen how to deploy an application to Netlify using the manual upload
    method and using GitLab or GitHub as the Git hosting provider.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用手动上传方法以及使用 GitLab 或 GitHub 作为 Git 托管提供商将应用程序部署到 Netlify。
- en: Next, we will see how to use **Amazon Web Services Simple Storage Service**
    (**AWS S3**) and AWS CloudFront to deploy a Vue.js application.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解如何使用 **Amazon Web Services 简单存储服务**（**AWS S3**）和 AWS CloudFront 部署
    Vue.js 应用程序。
- en: Deploying to AWS Using S3 and CloudFront
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 S3 和 CloudFront 部署到 AWS
- en: Amazon S3 is a static storage offering that can be used as a host for static
    files, such as what is generated by the Vue CLI's `build` script.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon S3 是一种静态存储服务，可以用作静态文件的托管，例如由 Vue CLI 的 `build` 脚本生成的文件。
- en: CloudFront is AWS' **content delivery network** (**CDN**) offering. A CDN can
    improve a web application's performance by serving static content from an **edge**
    location. These servers are positioned around the world and are more likely to
    be geographically located close to the end user than the **origin** servers (the
    ones that actually serve the content). Edge servers in a CDN request resources
    from the origin if they don't have them cached but will serve subsequent requests.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFront 是 AWS 的 **内容分发网络**（**CDN**）服务。CDN 可以通过从 **边缘**位置提供静态内容来提高 Web 应用程序的性能。这些服务器位于世界各地，并且更有可能位于比
    **源**服务器（实际提供内容的服务器）更靠近最终用户的地方。如果 CDN 的边缘服务器没有缓存资源，它们将从源请求资源，但会为后续请求提供服务。
- en: 'A prerequisite for the following steps is an AWS account:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤的一个先决条件是 AWS 账户：
- en: We will start by creating and configuring an S3 bucket.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建并配置一个 S3 存储桶。
- en: 'We begin by heading to the S3 product page. It will look similar to the following screenshot:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先前往 S3 产品页面。它将类似于以下截图：
- en: '![Figure 14.33: Select S3 from the AWS service list'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.33：从 AWS 服务列表中选择 S3'
- en: '](img/B15218_14_33.jpg)'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_14_33.jpg)'
- en: 'Figure 14.33: Select S3 from the AWS service list'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.33：从 AWS 服务列表中选择 S3
- en: 'On the S3 console home page, we can click the `Create bucket` button, which
    will take us to the bucket creation page, as seen here:![Figure 14.34: The Create
    bucket button on the AWS S3 console'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 S3 控制台主页上，我们可以点击 `创建存储桶` 按钮，这将带我们到存储桶创建页面，如下所示：![图 14.34：AWS S3 控制台上的创建存储桶按钮
- en: '](img/B15218_14_34.jpg)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_14_34.jpg)'
- en: 'Figure 14.34: The Create bucket button on the AWS S3 console'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.34：AWS S3 控制台上的创建存储桶按钮
- en: 'To begin, we start by naming our bucket. For the purposes of this example,
    let''s call it `vue-workshop`, as follows:![Figure 14.35: Entering the bucket
    name on the bucket creation page'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们给我们的存储桶命名。为了本例的目的，让我们称它为`vue-workshop`，如下所示：![图14.35：在存储桶创建页面输入存储桶名称
- en: '](img/B15218_14_35.jpg)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_35.jpg)'
- en: 'Figure 14.35: Entering the bucket name on the bucket creation page'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.35：在存储桶创建页面输入存储桶名称
- en: 'We will also need to set the S3 bucket to be public. This is done by unselecting
    the `Block all public access` checkbox. Once this is done, we must check the acknowledgment
    checkbox, as seen here:![Figure 14.36: Set the S3 bucket to be public and acknowledge
    the warning'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将S3存储桶设置为公开。这是通过取消选择`阻止所有公开访问`复选框来完成的。一旦这样做，我们必须检查确认复选框，如下所示：![图14.36：将S3存储桶设置为公开并确认警告
- en: '](img/B15218_14_36.jpg)'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_36.jpg)'
- en: 'Figure 14.36: Set the S3 bucket to be public and acknowledge the warning'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.36：将S3存储桶设置为公开并确认警告
- en: 'Once this is done, we are redirected to the bucket list page. We want to click
    into our new bucket. Then, we need to access the `Properties` tag in order to
    find the `Static website hosting` option:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，我们将被重定向到存储桶列表页面。我们想要点击进入我们新的存储桶。然后，我们需要访问`属性`标签，以找到`静态网站托管`选项：
- en: '![Figure 14.37: The Static website hosting option in the S3 bucket''s Properties
    tab'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图14.37：S3存储桶属性标签中的静态网站托管选项'
- en: '](img/B15218_14_37.jpg)'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_37.jpg)'
- en: 'Figure 14.37: The Static website hosting option in the S3 bucket''s Properties
    tab'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.37：S3存储桶属性标签中的静态网站托管选项
- en: 'We can fill out the `Static website hosting` S3 property, selecting `Use this
    bucket to host a website` and setting the index document and error document to
    `index.html`. It is a good idea to take note of the `Endpoint` URL, which we''ll
    need to configure CloudFront, as follows:![Figure 14.38: Filling out the Static
    website hosting S3 property'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以填写`静态网站托管`S3属性，选择`使用此存储桶托管网站`，并将索引文档和错误文档设置为`index.html`。记下`端点`URL是个好主意，因为我们需要配置CloudFront，如下所示：![图14.38：填写静态网站托管S3属性
- en: '](img/B15218_14_38.jpg)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_38.jpg)'
- en: 'Figure 14.38: Filling out the Static website hosting S3 property'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.38：填写静态网站托管S3属性
- en: 'We can now go back to the `Overview` tab of the S3 bucket page, click `Upload`,
    and drag and drop the files from one of our `dist` folders, as seen in the following
    screenshot:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以回到S3存储桶页面的`概览`标签，点击`上传`，并将文件从我们的`dist`文件夹之一拖放到以下截图所示的位置：
- en: '![Figure 14.39: Adding files to the vue-workshop S3 bucket through drag and
    drop'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图14.39：通过拖放将文件添加到vue-workshop S3存储桶'
- en: '](img/B15218_14_39.jpg)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_39.jpg)'
- en: 'Figure 14.39: Adding files to the vue-workshop S3 bucket through drag and drop'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.39：通过拖放将文件添加到vue-workshop S3存储桶
- en: 'Once files are dropped on the overview page, we click `Next` and need to make
    sure file permissions are set to `public` by selecting `Grant public read access
    to this object(s)` in the `Manage public permissions` section of the page. Once
    that is completed, we can complete the upload without any changes from the default
    values by clicking `Next` and `Upload`, after having reviewed the files being
    uploaded, as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件被拖放到概览页面，我们点击`下一步`，并确保在页面的`管理公开权限`部分选择`授予此对象（s）公开读取访问权限`，以确保文件权限设置为`公开`。完成此操作后，我们可以通过点击`下一步`和`上传`，在审查上传的文件后，不更改默认值完成上传，如下所示：
- en: '![Figure 14.40: Setting file permissions to public on files being uploaded
    to the S3 bucket'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图14.40：设置上传到S3存储桶的文件权限为公开'
- en: '](img/B15218_14_40.jpg)'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_40.jpg)'
- en: 'Figure 14.40: Setting file permissions to public on files being uploaded to
    the S3 bucket'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.40：设置上传到S3存储桶的文件权限为公开
- en: 'Our S3 bucket should now be configured to host static content, and by visiting
    the website endpoint (which is available in **Properties** | **Static website
    hosting**), we see the following Vue.js application (which is what we uploaded):![Figure
    14.41: The Vue.js application being served from our AWS S3 bucket'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在应该已经配置了S3存储桶以托管静态内容，通过访问网站端点（在**属性** | **静态网站托管**中可用），我们看到以下Vue.js应用程序（这是我们上传的）：![图14.41：从我们的AWS
    S3存储桶提供的Vue.js应用程序
- en: '](img/B15218_14_41.jpg)'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_41.jpg)'
- en: 'Figure 14.41: The Vue.js application being served from our AWS S3 bucket'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.41：从我们的AWS S3存储桶提供的Vue.js应用程序
- en: Note that S3 can only serve sites over HTTP, and domain names cannot be configured
    directly from S3 buckets. Beyond performance and robustness, being able to set
    custom domain names and HTTPS support are other reasons to set up AWS CloudFront
    as a CDN for our website.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，S3只能通过HTTP提供网站服务，并且无法直接从S3存储桶配置域名。除了性能和健壮性之外，能够设置自定义域名和HTTPS支持也是将AWS CloudFront设置为网站CDN的其他原因。
- en: 'We will start by navigating to the CloudFront console and clicking the `Create
    Distribution` button as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先导航到CloudFront控制台并点击“创建分布”按钮，如下所示：
- en: '![Figure 14.42: Select CloudFront from the AWS service list'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图14.42：从AWS服务列表中选择CloudFront](img/B15218_14_42.jpg)'
- en: '](img/B15218_14_42.jpg)'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_14_42.jpg](img/B15218_14_42.jpg)'
- en: 'Figure 14.42: Select CloudFront from the AWS service list'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.42：从AWS服务列表中选择CloudFront
- en: 'When prompted for which type of distribution we want to create, we will select
    `Web` by clicking the relevant `Get Started` button, as seen in the following screenshot:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示我们想要创建哪种类型的分布时，我们将通过点击相关的“开始”按钮选择“Web”，如下截图所示：
- en: '![Figure 14.43: Choosing to create a Web CloudFront distribution'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图14.43：选择创建Web CloudFront分布](img/B15218_14_43.jpg)'
- en: '](img/B15218_14_43.jpg)'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_14_43.jpg](img/B15218_14_43.jpg)'
- en: 'Figure 14.43: Choosing to create a Web CloudFront distribution'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.43：选择创建Web CloudFront分布
- en: '`Origin Domain Name` should be the S3 bucket website endpoint domain – in other
    words, the domain of the URL we used to access it earlier. It looks something
    like `example.s3-website.us-west-1.amazonaws.com` for the `example` bucket in
    the `us-east-1` region. The following screenshot displays this:![Figure 14.44:
    Enter the website endpoint domain in the CloudFront'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “源域名”应该是S3存储桶网站端点域名——换句话说，就是之前我们用来访问它的URL的域名。对于位于“us-east-1”区域的“example”存储桶，它看起来像`example.s3-website.us-west-1.amazonaws.com`。以下截图显示了这一点：![图14.44：在CloudFront中输入网站端点域名](img/B15218_14_44.jpg)
- en: '](img/B15218_14_44.jpg)'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_14_44.jpg](img/B15218_14_44.jpg)'
- en: 'Figure 14.44: Enter the website endpoint domain in the CloudFront distribution''s
    "Origin Domain Name" field'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.44：在CloudFront分布的“源域名”字段中输入网站端点域名
- en: 'While we are setting up the distribution, it''s a good idea to select the `Redirect
    HTTP to HTTPS` option for the `Default Cache Behavior` section''s `Viewer Protocol
    Policy` field as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置分布时，选择“默认缓存行为”部分的“查看器协议策略”字段的“将HTTP重定向到HTTPS”选项是个好主意，如下所示：
- en: '![Figure 14.45: Select Redirect HTTP to HTTPS for the Viewer Protocol Policy
    field'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图14.45：为查看器协议策略字段选择将HTTP重定向到HTTPS](img/B15218_14_45.jpg)'
- en: '](img/B15218_14_45.jpg)'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_14_45.jpg](img/B15218_14_45.jpg)'
- en: 'Figure 14.45: Select Redirect HTTP to HTTPS for the Viewer Protocol Policy
    field'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.45：为查看器协议策略字段选择将HTTP重定向到HTTPS
- en: We are now ready to click the `Create Distribution` button and wait for the
    changes to propagate.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好点击“创建分布”按钮并等待更改传播。
- en: Note
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: CloudFront distribution changes take a while to propagate since they are being
    deployed to servers around the world.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CloudFront分布更改正在部署到世界各地的服务器上，因此它们需要一段时间才能传播。
- en: We can open the domain name for the CloudFront distribution once the console
    shows its status as `Deployed`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦控制台显示其状态为“已部署”，我们就可以打开CloudFront分布的域名。
- en: We have seen how to set up S3 and CloudFront to serve a static website. We will
    now see how to use the AWS CLI to synchronize a local directory to the S3 bucket.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何设置S3和CloudFront来托管静态网站。现在我们将看到如何使用AWS CLI将本地目录同步到S3存储桶。
- en: A prerequisite for the next section is a shell instance that has AWS credentials
    injected using the `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `AWS_DEFAULT_REGION`
    environment variables. The access key and secret key need to be generated from
    the `Account` dropdown | `My Security Credentials` | `Access Keys`. It also requires
    the AWS CLI version 2.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分的前提条件是有一个使用`AWS_ACCESS_KEY_ID`、`AWS_SECRET_ACCESS_KEY`和`AWS_DEFAULT_REGION`环境变量注入AWS凭证的shell实例。访问密钥和秘密密钥需要从“账户”下拉菜单中的“我的安全凭证”下的“访问密钥”生成。它还需要AWS
    CLI版本2。
- en: 'If we''re in a Vue CLI project, we can deploy the `dist` folder (which can
    be built using `npm run build`) to our `vue-workshop` bucket using an AWS S3 CLI
    command. We want to update an `s3` resource so that our command will start with
    `aws s3`. The command we want to issue is to synchronize files, so we will use
    the `aws s3 sync` command. We will sync `./dist` to the `vue-workshop` S3 bucket,
    using the AWS URI syntax – that is, `s3://vue-workshop`. We also want to make
    sure that the files we upload, just like the bucket configuration, allow `public-read`.
    In full, the command looks as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们是在 Vue CLI 项目中，我们可以使用 AWS S3 CLI 命令将 `dist` 文件夹（可以使用 `npm run build` 构建）部署到我们的
    `vue-workshop` 存储桶。我们想要更新一个 `s3` 资源，以便我们的命令以 `aws s3` 开始。我们想要执行的命令是同步文件，所以我们将使用
    `aws s3 sync` 命令。我们将同步 `./dist` 到 `vue-workshop` S3 存储桶，使用 AWS URI 语法，即 `s3://vue-workshop`。我们还想要确保我们上传的文件，就像存储桶配置一样，允许
    `public-read`。完整的命令如下：
- en: '[PRE6]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Exercise 14.03: Deploying to S3 from GitLab CI/CD'
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.03：从 GitLab CI/CD 部署到 S3
- en: S3 is a very cost-effective and performant solution for storing static files
    at scale. In this exercise, we'll look at how to integrate GitLab CI/CD and AWS
    S3 to deploy a Vue.js application. This automates the deployment of the Vue.js
    application. The deployment will run on every push to GitLab without any manual
    intervention.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: S3 是一种非常经济高效且性能出色的解决方案，用于大规模存储静态文件。在这个练习中，我们将探讨如何集成 GitLab CI/CD 和 AWS S3 来部署
    Vue.js 应用程序。这将自动化 Vue.js 应用的部署。部署将在每次向 GitLab 推送时运行，无需任何手动干预。
- en: To access the code files for this exercise, refer to [https://packt.live/3kJ1HPD](https://packt.live/3kJ1HPD).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/3kJ1HPD](https://packt.live/3kJ1HPD)。
- en: 'In order to deploy to the S3 bucket from GitLab CI/CD, we will need to first
    set credential management:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 GitLab CI/CD 部署到 S3 存储桶，我们首先需要设置凭证管理：
- en: 'Navigate to the `CI/CD` settings section of GitLab as follows:![Figure 14.46:
    CI/CD in the Settings menu'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤导航到 GitLab 的 `CI/CD` 设置部分：![图 14.46：设置菜单中的 CI/CD](img/B15218_14_46.jpg)
- en: '](img/B15218_14_46.jpg)'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.46：14_46.jpg](img/B15218_14_46.jpg)'
- en: 'Figure 14.46: CI/CD in the Settings menu'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.46：设置菜单中的 CI/CD
- en: 'We will want to add variables, so let''s expand that section. You will see
    a message as shown in the following screenshot:![Figure 14.47: The Variables section
    of the GitLab CI/CD settings expanded'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将想要添加变量，所以让我们展开该部分。你将看到如下截图所示的消息：![图 14.47：GitLab CI/CD 设置的变量部分展开](img/B15218_14_47.jpg)
- en: '](img/B15218_14_47.jpg)'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.47：14_47.jpg](img/B15218_14_47.jpg)'
- en: 'Figure 14.47: The Variables section of the GitLab CI/CD settings expanded'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.47：GitLab CI/CD 设置的变量部分展开
- en: 'Next, we''ll add `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` using the
    UI (values not shown since they''re sensitive API keys), as follows:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 UI 添加 `AWS_ACCESS_KEY_ID` 和 `AWS_SECRET_ACCESS_KEY`（由于它们是敏感的 API 密钥，所以未显示其值），如下所示：
- en: '![Figure 14.48: Entering the AWS_ACCESS_KEY_ID environment variable'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图 14.48：输入 AWS_ACCESS_KEY_ID 环境变量](img/B15218_14_48.jpg)'
- en: '](img/B15218_14_48.jpg)'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.48：14_48.jpg](img/B15218_14_48.jpg)'
- en: 'Figure 14.48: Entering the AWS_ACCESS_KEY_ID environment variable'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.48：输入 AWS_ACCESS_KEY_ID 环境变量
- en: 'We can then add the default `AWS_REGION` variable using the UI. This isn''t
    so sensitive, so its value is shown in the following screenshot:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 UI 添加默认的 `AWS_REGION` 变量。这不是那么敏感，所以其值在以下截图中显示：
- en: '![Figure 14.49: Entering the AWS_DEFAULT_REGION environment variable'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图 14.49：输入 AWS_DEFAULT_REGION 环境变量](img/B15218_14_49.jpg)'
- en: '](img/B15218_14_49.jpg)'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.49：14_49.jpg](img/B15218_14_49.jpg)'
- en: 'Figure 14.49: Entering the AWS_DEFAULT_REGION environment variable'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.49：输入 AWS_DEFAULT_REGION 环境变量
- en: 'Now that we have set up our environment variables on GitLab CI/CD, we can start
    updating our `.gitlab-ci.yml` file. First, we want to start caching the `dist`
    directory after our `build` step. In order to do this, we need to add a `cache`
    property to the `build` job:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在 GitLab CI/CD 上设置了环境变量，我们可以开始更新我们的 `.gitlab-ci.yml` 文件。首先，我们想在 `build`
    步骤之后开始缓存 `dist` 目录。为了做到这一点，我们需要在 `build` 作业中添加一个 `cache` 属性：
- en: '[PRE7]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can now add our `deploy` job, which will be a part of the `deploy` stage.
    To access the AWS CLI, we will use a Python image (`python:latest`) and install
    the AWS CLI using `pip` (a Python package manager) in our `before_script` step.
    Once we''ve installed the AWS CLI, we will run the deployment in the `script`
    step using the `aws s3 sync` command we used to deploy from our local machine:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以添加我们的 `deploy` 作业，它将是 `deploy` 阶段的一部分。为了访问 AWS CLI，我们将使用 Python 映像（`python:latest`）并在
    `before_script` 步骤中使用 `pip`（Python 包管理器）安装 AWS CLI。一旦我们安装了 AWS CLI，我们将在 `script`
    步骤中使用我们用于从本地机器部署的 `aws s3 sync` 命令来运行部署：
- en: '[PRE8]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We don't need to invalidate caches since the Vue CLI `build` command has built-in
    cache-busting through fingerprinting the contents of a file in the filename. Fingerprinting
    means that if the contents of a file change, its name/URL will change accordingly.
    When this new file is requested, it will be loaded from an un-cached URL and will
    therefore get the latest version of the file.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 Vue CLI 的 `build` 命令通过指纹文件内容内置了缓存清除功能，我们不需要使缓存失效。指纹化意味着如果文件内容发生变化，其名称/URL
    将相应地更改。当请求此新文件时，它将从未缓存的 URL 加载，因此将获取文件的最新版本。
- en: 'Once this update to the configuration is pushed to the GitLab repository, we
    can see the pipeline running three stages that all pass, as follows:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦将此配置更新推送到 GitLab 仓库，我们可以看到管道运行了三个阶段，所有阶段都通过了，如下所示：
- en: '![Figure 14.50: Passing build, test, and deploy jobs'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.50：通过构建、测试和部署作业'
- en: '](img/B15218_14_50.jpg)'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_14_50.jpg)'
- en: 'Figure 14.50: Passing build, test, and deploy jobs'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.50：通过构建、测试和部署作业
- en: We have now seen how to configure and deploy a Vue.js application to S3 and
    CloudFront using the AWS CLI and GitLab CI/CD.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 AWS CLI 和 GitLab CI/CD 配置和部署 Vue.js 应用程序到 S3 和 CloudFront。
- en: 'Activity 14.01: Adding CI/CD with GitLab to a Book Search App and Deploying
    to Amazon S3 and CloudFront'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 14.01：将 GitLab CI/CD 添加到图书搜索应用程序并部署到 Amazon S3 和 CloudFront
- en: Let's now take a fully built **book search** Vue.js application that loads data
    from the Google Books API and deploy it to S3/CloudFront using GitLab CI/CD. We
    will start by running the production build locally and checking the output. We
    will then switch to running the build and code quality steps (linting) on GitLab
    CI. Finally, we'll set up an S3 bucket and CloudFront distribution and integrate
    them with GitLab CI/CD to deploy on every push to the repository.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 GitLab CI/CD 将一个完全构建的 **图书搜索** Vue.js 应用程序部署到 S3/CloudFront，该应用程序从
    Google Books API 加载数据。我们将从在本地运行生产构建并检查输出开始。然后，我们将切换到在 GitLab CI 上运行构建和代码质量步骤（linting）。最后，我们将设置
    S3 存储桶和 CloudFront 分发，并将它们与 GitLab CI/CD 集成，以便在每次向仓库推送时部署。
- en: 'The start code for this activity can be found at `Chapter14/Activity14.01_initial`;
    we start with a `Chapter14/Activity14.01_solution`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的起始代码可以在 `Chapter14/Activity14.01_initial` 中找到；我们从一个 `Chapter14/Activity14.01_solution`
    开始：
- en: To start, we will want to run a production build locally. We can use the regular
    command used to build all Vue CLI projects for production. We will also want to
    check that the relevant assets (JavaScript, CSS, and HTML) are generated correctly.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们想要在本地运行生产构建。我们可以使用用于构建所有 Vue CLI 项目的常规命令。我们还将检查相关的资产（JavaScript、CSS 和 HTML）是否正确生成。
- en: 'We expect the `dist` folder to contain a similar structure, as follows:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们预计 `dist` 文件夹将包含以下类似的结构：
- en: '![Figure 14.51: Sample contents of the dist folder (generated using the tree
    command)'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.51：Vue CLI 生产构建运行后 dist 文件夹的示例内容（使用 tree 命令）'
- en: after a Vue CLI production build run
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Vue CLI 生产构建运行之后
- en: '](img/B15218_14_51.jpg)'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_14_51.jpg)'
- en: 'Figure 14.51: Sample contents of the dist folder (generated using the tree
    command) after a Vue CLI production build run'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.51：Vue CLI 生产构建运行后 dist 文件夹的示例内容（使用 tree 命令生成）
- en: In order to run GitLab CI/CD, we will need a `.gitlab-ci.yml` file. We will
    add a job to `.gitlab-ci.yml` in which we run an install of the packages followed
    by the production build in a Node.js LTS Docker container, at the `build` stage.
    We will also make sure to cache the output of the production build.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行 GitLab CI/CD，我们需要一个 `.gitlab-ci.yml` 文件。我们将在 `.gitlab-ci.yml` 中添加一个作业，该作业在
    `build` 阶段运行 Node.js LTS Docker 容器中的包安装，然后是生产构建。我们还将确保缓存生产构建的输出。
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `build` job while
    it is in the running state:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们使用 `git add .gitlab-ci.yml` 并提交和推送更改，我们应该看到以下 GitLab CI/CD 管道运行，其中包含正在运行状态的
    `build` 作业：
- en: '![Figure 14.52: The GitLab CI/CD pipeline with the build job running'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.52：构建作业正在运行的 GitLab CI/CD 管道'
- en: '](img/B15218_14_52.jpg)'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_14_52.jpg)'
- en: 'Figure 14.52: The GitLab CI/CD pipeline with the build job running'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.52：构建作业正在运行的 GitLab CI/CD 管道
- en: 'The following screenshot, on the other hand, represents the GitLab CI/CD pipeline
    when the `build` job has completed and is in the `passed` state:'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一方面，以下截图表示 `build` 作业完成并处于 `passed` 状态时的 GitLab CI/CD 管道：
- en: '![Figure 14.53: GitLab CI/CD pipeline with the build job passed'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.53：构建作业通过后的 GitLab CI/CD 管道'
- en: '](img/B15218_14_53.jpg)'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_14_53.jpg)'
- en: 'Figure 14.53: GitLab CI/CD pipeline with the build job passed'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.53：GitLab CI/CD流水线中build作业通过
- en: Next, we will want to add a code quality job to the `test` stage on GitLab CI/CD
    (by updating `.gitlab-ci.yml`). We'll call the job `lint` and it will run an install
    of the dependencies as well as linting through the Vue CLI.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望在GitLab CI/CD的`test`阶段添加一个代码质量作业（通过更新`.gitlab-ci.yml`）。我们将这个作业命名为`lint`，它将运行依赖项的安装以及通过Vue
    CLI进行代码检查。
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `lint` job while
    it is in the running state:'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们使用`git add .gitlab-ci.yml`提交并推送更改，我们应该看到以下GitLab CI/CD流水线运行，其中包含正在运行状态的`lint`作业：
- en: '![Figure 14.54: The GitLab CI/CD pipeline with the lint job running'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.54：GitLab CI/CD流水线中lint作业运行'
- en: '](img/B15218_14_54.jpg)'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_54.jpg)'
- en: 'Figure 14.54: The GitLab CI/CD pipeline with the lint job running'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.54：运行中的GitLab CI/CD流水线及lint作业
- en: 'The following screenshot displays the GitLab CI/CD pipeline with the `lint`
    job successfully completed:'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了GitLab CI/CD流水线，其中`lint`作业已成功完成：
- en: '![Figure 14.55: GitLab CI/CD pipeline with the lint job passed'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.55：GitLab CI/CD流水线中lint作业通过'
- en: '](img/B15218_14_55.jpg)'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_55.jpg)'
- en: 'Figure 14.55: GitLab CI/CD pipeline with the lint job passed'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.55：GitLab CI/CD流水线中lint作业通过
- en: In order to deploy our application, we'll need to create a `vue-workshop-book-search`
    S3 bucket with `public access` enabled using the S3 console.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了部署我们的应用程序，我们需要在S3控制台中创建一个启用`public access`的`vue-workshop-book-search` S3存储桶。
- en: 'The S3 bucket creation page should look as follows:'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: S3存储桶创建页面应如下所示：
- en: '![Figure 14.56: The S3 bucket creation page with vue-workshop-book-'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.56：S3存储桶创建页面，输入vue-workshop-book-'
- en: search entered as the bucket name
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: search作为存储桶名称输入
- en: '](img/B15218_14_56.jpg)'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_56.jpg)'
- en: 'Figure 14.56: The S3 bucket creation page with vue-workshop-book-search entered
    as the bucket name'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.56：S3存储桶创建页面，输入vue-workshop-book-search作为存储桶名称
- en: 'The following screenshot displays the public access and disclaimer information
    on the S3 bucket creation page:'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了S3存储桶创建页面上的公共访问和免责声明信息：
- en: '![Figure 14.57: The S3 bucket creation page with public access enabled'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.57：启用公共访问并添加变量（值已隐藏）的S3存储桶创建页面'
- en: and the relevant disclaimer accepted
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并接受相关免责声明
- en: '](img/B15218_14_57.jpg)'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_57.jpg)'
- en: 'Figure 14.57: The S3 bucket creation page with public access enabled and the
    relevant disclaimer accepted'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.57：S3存储桶创建页面，启用公共访问并接受相关免责声明
- en: To access the S3 bucket contents over the web, we'll also need to configure
    it for web hosting. We can configure the web hosting property through the S3 console.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过Web访问S3存储桶内容，我们还需要配置其网络托管。我们可以通过S3控制台配置网络托管属性。
- en: 'It should be configured as follows, with the index and error page set to `index html`:'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该按照以下配置，将索引和错误页面设置为`index html`：
- en: '![Figure 14.58: The S3 bucket properties page with web hosting enabled and
    configured with the index and error page set to index.html'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.58：S3存储桶属性页面，启用网络托管并配置索引和错误页面为index.html'
- en: '](img/B15218_14_58.jpg)'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_58.jpg)'
- en: 'Figure 14.58: The S3 bucket properties page with web hosting enabled and configured
    with the index and error page set to index.html'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.58：S3存储桶属性页面，启用网络托管并配置索引和错误页面为index.html
- en: 'For GitLab CI/CD to be able to create and update files on S3, we will need
    to add the relevant AWS secrets to our GitLab repo CI/CD settings. The secrets
    are found in the AWS management console at the `Username` dropdown | `My Security
    Credentials` | `Access keys` (access key ID and secret access key) | `Create New
    Access Key` (or pick a key to reuse). The following screenshot displays these
    details:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让GitLab CI/CD能够在S3上创建和更新文件，我们需要将相关的AWS密钥添加到我们的GitLab仓库CI/CD设置中。这些密钥可以在AWS管理控制台的`Username`下拉菜单
    | `My Security Credentials` | `Access keys`（访问密钥ID和秘密访问密钥） | `Create New Access
    Key`（或选择一个密钥进行重用）中找到。以下截图显示了这些详细信息：
- en: '![Figure 14.59: The GitLab CI/CD settings page with required the AWS environment'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图14.59：GitLab CI/CD设置页面，已添加所需的AWS环境变量'
- en: variables added (with values masked)
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: variables added (with values masked)
- en: '](img/B15218_14_59.jpg)'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_59.jpg)'
- en: 'Figure 14.59: The GitLab CI/CD settings page with required the AWS environment
    variables added (with values masked)'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.59：GitLab CI/CD设置页面，已添加所需的AWS环境变量（值已隐藏）
- en: Next, we will want to add a `deploy` job to the `deploy` stage on GitLab CI/CD
    (by updating `.gitlab-ci.yml`). We will call the job `deploy`; it will need to
    download the `awscli` `pip` package (Python package manager), which means the
    Docker image that makes the most sense is `python:latest`. The `deploy` job will
    load the built production build from cache, install `awscli` with `pip`, and run
    `aws s3 sync <build_directory> s3://<s3-bucket-name> --acl=public-read`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望在 GitLab CI/CD 的 `deploy` 阶段添加一个 `deploy` 作业（通过更新 `.gitlab-ci.yml`）。我们将作业命名为
    `deploy`；它需要下载 `awscli` `pip` 包（Python 包管理器），这意味着最有意义的 Docker 镜像是 `python:latest`。`deploy`
    作业将从缓存中加载构建好的生产构建，使用 `pip` 安装 `awscli`，并运行 `aws s3 sync <build_directory> s3://<s3-bucket-name>
    --acl=public-read`。
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `deploy` job in
    the running state:'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们使用 `git add .gitlab-ci.yml` 并提交和推送更改，我们应该看到以下 GitLab CI/CD 管道运行，其中包含运行状态的
    `deploy` 作业：
- en: '![Figure 14.60: The GitLab CI/CD pipeline with the deploy job running'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.60：GitLab CI/CD 管道中部署作业正在运行'
- en: '](img/B15218_14_60.jpg)'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_14_60.jpg](img/B15218_14_60.jpg)'
- en: 'Figure 14.60: The GitLab CI/CD pipeline with the deploy job running'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.60：GitLab CI/CD 管道中部署作业正在运行
- en: 'The following screenshot displays the GitLab CI/CD pipeline with the `deploy`
    job completed successfully:'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了成功完成的 `deploy` 作业的 GitLab CI/CD 管道：
- en: '![Figure 14.61: The GitLab CI/CD pipeline with the deploy job passed'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.61：GitLab CI/CD 管道中部署作业已通过'
- en: '](img/B15218_14_61.jpg)'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_14_61.jpg](img/B15218_14_61.jpg)'
- en: 'Figure 14.61: The GitLab CI/CD pipeline with the deploy job passed'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.61：GitLab CI/CD 管道中部署作业已通过
- en: 'Once the pipeline completes, our application should be available through the
    `web` S3 endpoint as in the following screenshot:'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦管道完成，我们的应用程序应可通过以下截图所示的 `web` S3 端点访问：
- en: '![Figure 14.62: Book search accessed through the S3 web endpoint URL'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.62：通过 S3 网端点 URL 访问的图书搜索'
- en: '](img/B15218_14_62.jpg)'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_14_62.jpg](img/B15218_14_62.jpg)'
- en: 'Figure 14.62: Book search accessed through the S3 web endpoint URL'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.62：通过 S3 网端点 URL 访问的图书搜索
- en: 'Finally, we''ll create a CloudFront distribution that acts as a CDN for the
    `web` S3 endpoint. We''ll want to set `origin` to the origin of our S3 bucket''s
    web endpoint and also make sure that we''ve enabled `Redirect HTTP to HTTPS`,
    as shown in the following screenshot:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个充当 `web` S3 端点 CDN 的 CloudFront 分发。我们需要将 `origin` 设置为我们的 S3 存储桶网端点的源，并确保我们已经启用了
    `Redirect HTTP to HTTPS`，如下面的截图所示：
- en: '![Figure 14.63: The CloudFront distribution creation page, displaying the'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图 14.63：显示源和设置行为的 CloudFront 分发创建页面'
- en: origin and behavior settings
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 源和设置行为
- en: '](img/B15218_14_63.jpg)'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_14_63.jpg](img/B15218_14_63.jpg)'
- en: 'Figure 14.63: The CloudFront distribution creation page, displaying the origin
    and behavior settings'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.63：显示源和设置行为的 CloudFront 分发创建页面
- en: 'Once the CloudFront distribution is deployed, our application should be accessible
    through the CloudFront distribution''s domain as shown in the following screenshot:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 CloudFront 分发部署，我们的应用程序应可通过以下截图所示的 CloudFront 分发域名访问：
- en: '![Figure 14.64: Book search accessed through the CloudFront domain displaying'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.64：通过 CloudFront 域访问的图书搜索显示 "harry potter" 搜索的结果'
- en: results for a "harry potter" query
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 "harry potter" 搜索的结果
- en: '](img/B15218_14_64.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_14_64.jpg](img/B15218_14_64.jpg)'
- en: 'Figure 14.64: Book search accessed through the CloudFront domain displaying
    results for a "harry potter" query'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.64：通过 CloudFront 域访问的图书搜索显示 "harry potter" 搜索的结果
- en: Note
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor412).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor412)找到。
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we've looked at how to introduce CI and CD practices
    to Vue.js projects in order to deploy to production safely and efficiently. We've
    seen how CI and CD are beneficial in the context of an agile delivery process.
    We used GitLab's CI/CD features to run tests, linting, and builds on every commit.
    We saw how to leverage Netlify to host a static website by connecting Netlify
    to our hosting provider. Finally, we looked at how to set up and deploy to AWS
    S3 and CloudFront.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何将 CI 和 CD 实践引入 Vue.js 项目，以便安全高效地部署到生产环境。我们看到了 CI 和 CD 在敏捷交付过程中的好处。我们使用
    GitLab 的 CI/CD 功能在每次提交时运行测试、代码检查和构建。我们看到了如何通过将 Netlify 连接到我们的托管提供商来利用 Netlify
    托管静态网站。最后，我们探讨了如何设置和部署到 AWS S3 和 CloudFront。
- en: Throughout this book, you have learned how to build, test, and deploy a Vue.js
    application that scales and performs for your team and your end users.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，你已经学会了如何构建、测试和部署一个适用于你的团队和最终用户的可扩展且性能良好的 Vue.js 应用程序。
