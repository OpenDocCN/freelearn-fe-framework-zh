- en: '*Chapter 9*: Use Case Scenario 3 – Valtio'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Valtio ([https://github.com/pmndrs/valtio](https://github.com/pmndrs/valtio))
    is yet another library for global state. Unlike Zustand and Jotai, it's based
    on the mutating update model. It's primarily for module states like Zustand. It
    utilizes proxies to get an immutable snapshot, which is required to integrate
    with React.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The API is just JavaScript and everything works behind the scenes. It also leverages
    proxies to automatically optimize re-renders. It doesn't require a selector to
    control re-renders. The automatic render optimization is based on a technique
    called **state usage tracking**. Using state usage tracking, it can detect which
    part of the state is used, and it can let a component re-render only if the used
    part of the state is changed. In the end, developers need to write less code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the basic usage of the Valtio library and
    how it deals with mutating updates. Snapshots are a key feature to create an immutable
    state. We will also discuss how snapshots and proxies allow us to optimize re-renders.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Valtio, another module state library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing proxies to detect mutations and create an immutable state
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using proxies to optimize re-renders
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating small application code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pros and cons of this approach
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are expected to have moderate knowledge of React, including React Hooks.
    Refer to the official site, [https://reactjs.org](https://reactjs.org), to learn
    more.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In some code, we use TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org)),
    and you should have basic knowledge of it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in this chapter is available on GitHub: [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_09](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_09).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: To run the code snippets, you need a React environment, for example, Create
    React App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Valtio, another module state library
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Valtio is a library primarily used for module state, which is the same as Zustand.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned in [*Chapter 7*](B17780_07_Final_VK_ePub.xhtml#_idTextAnchor092),
    *Use Case Scenario 1 – Zustand*, we create a store in Zustand as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `store` variable has some properties, one of which is `setState`. With
    `setState`, we can update the state. For example, the following is incrementing
    the `count` value:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Why do we need to use `setState` to update a state value? Because we want to
    update the state immutably. Internally, the previous `setState` works like the
    following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the way to update an object immutably.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine a case where we don''t need to follow the immutable update rule.
    In this case, the code to increment the `count` value in `moduleState` would be
    the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Wouldn't it be nice if we could write code like that and make it work with React?
    Actually, we can implement this with proxies.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'A proxy is a special object in JavaScript ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)).
    We can define some handlers to trap object operations. For example, you can add
    a `set` handler to trap object mutations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We create `proxyObject` with `new Proxy` with two arguments. The first argument
    is an object itself. The second argument is a collection object of handlers. In
    this case, we have a `set` handler, which traps the `set` operation and adds `console.log`
    statements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '`proxyObject` is a special object and when you set a value, it will log to
    the console before and after setting the value. The following is the screen output
    if you run the code in the Node.js REPL ([https://nodejs.dev/learn/how-to-use-the-nodejs-repl](https://nodejs.dev/learn/how-to-use-the-nodejs-repl)):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Conceptually, as a proxy can detect any mutations, we could technically use
    similar behavior to `setState` in Zustand. Valtio is a library that utilizes proxies
    to detect state mutations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned that Valtio is a library that uses the mutating
    update model. Next up, we will learn how Valtio creates immutable states with
    mutations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing proxies to detect mutations and create an immutable state
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Valtio creates immutable objects from mutable objects with proxies. We call
    the immutable object a **snapshot**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: To create a mutable object wrapped in a proxy object, we use the `proxy` function
    exported by Valtio.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is to create an object with a `count` property:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `state` object returned by the `proxy` function is a proxy object that detects
    mutations. This allows you to create an immutable object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an immutable object, we use the `snapshot` function exported by Valtio,
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Though the `state` variable is `{ count: 0 }` and the `snap1` variable is `{
    count: 0 }`, `state` and `snap1` have different references. `state` is a mutable
    object wrapped in a proxy, whereas `snap1` is an immutable object frozen with
    `Object.freeze` ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how snapshots work. We mutate the `state` object and create another
    snapshot, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `state` variable is `{ count: 1 }` and has the same reference as before.
    The `snap2` variable is `{ count: 1 }` and has a new reference. Because `snap1`
    and `snap2` are immutable, we can check the equality with `snap1 === snap2`, and
    know whether anything in the objects differs.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'The `proxy` and `snapshot` functions work for nested objects and optimize snapshot
    creation. That means the `snapshot` function will create a new snapshot only if
    necessary, that is, when any of its properties are changed. Let''s look at another
    example. `state2` has two nested `c` properties:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, the `snap21` variable is `{ obj1: { c: 0 }, obj2: { c: 0 } }`
    and the `snap22` variable is `{ obj1: { c: 1 }, obj2: { c: 0 } }`. `snap21` and
    `snap22` have difference references, hence `snap21 !== snap22` holds.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: How about nested objects? `snap21.obj1` and `snap22.obj1` are different, but
    `snap21.obj2` and `snap22.obj2` are the same. This is because the value of the
    internal `c` property of `obj2` isn't changed. `obj2` doesn't need to be changed,
    hence `snap21.obj2 === snap22.obj2` holds.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: This snapshot optimization is an important feature. The fact that `snap21.obj2`
    and `snap22.obj2` have the same reference means they share memory. Valtio creates
    snapshots only if necessary, optimizing memory usage. This optimization can be
    done in Zustand, but it's the developer's responsibility to properly create new
    immutable states. In contrast, Valtio does the optimization behind the scenes.
    In Valtio, developers are free from the responsibility of creating new immutable
    states.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Valtio's optimization is based on caching with a previous snapshot. In other
    words, the cache size is 1\. If we increment the count with `++state.count` and
    then decrement it with `--state.count`, a new snapshot will be created.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how Valtio creates immutable state "snapshots" automatically.
    Next up, we will learn about Valtio's hooks for React.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Using proxies to optimize re-renders
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Valtio uses proxies to optimize re-renders, as well as detecting mutations.
    This is the pattern of optimizing re-renders we learned about in the *Detecting
    property access* section of [*Chapter 6*](B17780_06_Final_VK_ePub.xhtml#_idTextAnchor080),
    *Introducing Global State Libraries*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn about the usage and behavior of Valtio hooks with a counter app.
    The hook is called `useSnapshot`. The implementation of `useSnapshot` is based
    on the `snapshot` function and another proxy to wrap it. This `snapshot` proxy
    has a different purpose from the proxy used in the `proxy` function. The `snapshot`
    proxy is used to detect the property access of a snapshot object. We will see
    how render optimization works, thanks to the `snapshot` proxy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with importing functions from Valtio to create a counter app:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`proxy` and `useSnapshot` are two main functions provided by Valtio and they
    cover most use cases.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a `state` object with `proxy`. In our counter app, there are
    two counts – `count1` and `count2`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `proxy` function takes an initial object and returns a new proxy object.
    We can mutate the `state` object as we like.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the `Counter1` component, which uses the `state` object and
    shows the `count1` property:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's our convention to set the name of the return value of `useSnapshot` to
    `name`. The `inc` action is a function to mutate the `state` object. We mutate
    the `state` proxy object; `snap` is only to read. The `snap` object is frozen
    with `Object.freeze` ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze))
    and it can't be mutated technically. Without `Object.freeze`, JavaScript objects
    are always mutable and we can only treat it as immutable by convention. `snap.count1`
    is accessing the `count1` property of the `state` object. The access is detected
    by the `useSnapshot` hook as tracking information, and based on the tracking information,
    the `useSnapshot` hook triggers re-renders only when necessary.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `Counter2` component likewise:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The difference from `Counter1` is it uses the `count2` property instead of the
    `count1` property. If we want to define a shared component, we can define a single
    component and take the property name in `props`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define the `App` component. As we don''t use Context, there are
    no providers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'How does this app work? On the initial render, the `state` object is `{ count1:
    0, count2: 0 }` and so is its snapshot object. The `Counter1` component accesses
    the `count1` property of the snapshot object and the `Counter2` component accesses
    the `count2` property of the snapshot object. Each `useSnapshot` hook knows and
    remembers tracking information. The tracking information represents which property
    is accessed.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click the button in the `Counter1` component (the first button in *Figure
    9.1*), it increments the `count1` property of the `state` object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – First screenshot of the counter app ](img/Figure_9.01_B17780.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – First screenshot of the counter app
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the `state` object becomes `{ count1: 1, count2: 0 }`. The `Counter1`
    component re-renders with the new number `1`. However, the `Counter2` component
    doesn''t re-render, because `count2` is still `0` and not changed (*Figure 9.2*):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Second screenshot of the counter app ](img/Figure_9.02_B17780.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Second screenshot of the counter app
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Re-renders are optimized with tracking information.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'In our counter app, the `state` object is simple with two properties with number
    values. Valtio supports nested objects and arrays. A contrived example is the
    following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Basically, any objects containing plain objects and arrays are fully supported
    even though they are nested deeply. For more information, please refer to the
    project site: [https://github.com/pmndrs/valtio](https://github.com/pmndrs/valtio).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how Valtio optimizes re-renders with snapshots and
    proxies. In the next section, we will learn how to structure an app with an example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Creating small application code
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will learn how to create a small app. Our example app is a to-do app. Valtio
    is unopinionated about how to structure apps. This is one of the typical patterns.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how a to-do app can be structured. First, we define the `Todo`
    type:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A `Todo` item has an `id` string value, a `title` string value, and a `done`
    Boolean value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define a `state` object using the defined `Todo` type:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `state` object is created by wrapping an initial object with `proxy`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'To manipulate the `state` object, we define some helper functions – `addTodo`
    to add a new to-do item, `removeTodo` to remove it, and `toggleTodo` to toggle
    the `done` status:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`nanoid` is a small function to generate a unique ID ([https://www.npmjs.com/package/nanoid](https://www.npmjs.com/package/nanoid)).
    Notice these three functions are based on normal JavaScript syntax. They treat
    `state` just like a normal JavaScript object. This is accomplished with proxies.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `TodoItem` component, which has a checkbox toggle with
    the `done` status, text with a different style with the `done` status, and a button
    to remove the item:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice this component receives the `id`, `title`, and `done` properties separately,
    instead of receiving the `todo` object. This is because we use the `memo` function
    and create the `MemoedTodoItem` component. Our state usage tracking detects property
    access, and if we pass an object to a memoed component, the property access is
    omitted.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `MemoedTodoItem` component, the `TodoList` component is defined
    with `useSnapshot`, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This component takes `todos` from the result of `useSnapshot` and accesses all
    properties in objects in the `todos` array. Hence, `useSnapshot` triggers a re-render
    if any part of `todos` is changed. It's not a big issue and this is a valid pattern
    because the `MemoedTodoItem` component won't re-render unless `id`, `title`, or
    `done` is changed. We will learn about another pattern later in this section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new to-do item, the following is a small component that has a local
    state for the input field and invokes `createTodo` when the **Add** button is
    clicked:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we combine the defined components in the `App` component:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s look at how this app works:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: At first, it has only a text field and an **Add** button (*Figure 9.3*):![Figure
    9.3 – First screenshot of the todos app ](img/Figure_9.03_B17780.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.3 – First screenshot of the todos app
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we click the **Add** button, a new item is added (*Figure 9.4*):![Figure
    9.4 – Second screenshot of the todos app ](img/Figure_9.04_B17780.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.4 – Second screenshot of the todos app
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can add as many items as we want (*Figure 9.5*):![Figure 9.5 – Third screenshot
    of the todos app ](img/Figure_9.05_B17780.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.5 – Third screenshot of the todos app
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clicking a checkbox will toggle the `done` status (*Figure 9.6*):![Figure 9.6
    – Fourth screenshot of the todos app ](img/Figure_9.06_B17780.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.6 – Fourth screenshot of the todos app
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Clicking the **Delete** button will delete the item (*Figure 9.7*):'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Fifth screenshot of the todos app ](img/Figure_9.07_B17780.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Fifth screenshot of the todos app
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The app we created so far works pretty well. But there is room for improvement
    in terms of extra re-renders. When we toggle the `done` state of an existing item,
    not only the corresponding `TodoItem` component but also the `TodoList` component
    will re-render. As noted, this is not a big issue as long as the `TodoList` component
    itself is fairly lightweight.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: We have another pattern to eliminate the extra re-render in the `TodoList` component.
    This doesn't mean the overall performance can always be improved. Which approach
    we should take depends on the app in question.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new approach, we use `useSnapshot` in each `TodoItem` component. The
    `TodoItem` component only receives the `id` property. The following is the modified
    `TodoItem` component:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Based on the `id` property, it finds `todoState`, uses `useSnapshot` with `todoState`,
    and gets the `title` and `done` properties. This component will re-render only
    if the `id`, `title`, or `done` properties are changed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the modified `TodoList` component. Unlike the previous
    one, it only needs to pass the `id` properties:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, `todoIds` is created from the `id` property of each `todo` object. This
    component will only re-render if the order of `id` is changed, or if some `id`
    is added or removed. If only the `done` status of an existing item is changed,
    this component won't re-render. Hence, the extra re-render is eliminated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In medium-sized apps, the change in the two approaches is subtle in terms of
    performance. The two approaches are more meaningful for different coding patterns.
    Developers can choose the one that is more comfortable with their mental model.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about `useSnapshot` use cases with a small app.
    Next up, we will discuss some pros and cons of this library and the approach in
    general.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The pros and cons of this approach
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how Valtio works and one question is when we should use it and
    when we should not.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: One big aspect is the mental model. We have two state-updating models. One is
    for immutable updates and the other for mutable updates. While JavaScript itself
    allows mutable updates, React is built around immutable states. Hence, if we mix
    the two models, we should be careful not to confuse ourselves. One possible solution
    would be to clearly separate the Valtio state and React state so that the mental
    model switch is reasonable. If it works, Valtio can fit in. Otherwise, maybe stick
    with immutable updates.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The major benefit of mutable updates is we can use native JavaScript functions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, removing an item from an array with an `index` value can be written
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In immutable updates, this is not so easy. For example, it can be written with
    `slice`, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Another example is to change the value in a deeply nested object. It can be
    done in mutable updates as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是更改深层嵌套对象中的值。可以在可变更新中这样做：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In immutable updates, it has to be something like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在不可变更新中，它必须类似于以下内容：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is not very pleasant to write. Valtio helps to reduce application code
    with mutable updates.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这样写并不愉快。Valtio帮助减少具有可变更新的应用程序代码。
- en: Valtio also helps to reduce application code with proxy-based render optimization.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Valtio还帮助减少基于代理的渲染优化的应用程序代码。
- en: 'Suppose we have a state with the `count` and `text` properties, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个具有`count`和`text`属性的状态，如下所示：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we use only `count` in a component, we can write the following in Valtio:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只在一个组件中使用`count`，我们可以在Valtio中写出以下内容：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In comparison, with Zustand, this will be something like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用Zustand，它将类似于以下内容：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The difference is trivial, but we have `count` in two places.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 差异微不足道，但我们有两个地方都有`count`。
- en: 'Let''s look at a contrived scenario. Suppose we want to show the `text` value
    if the `showText` property is truthy. With `useSnapshot`, it can be done as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个假设的场景。假设我们想在`showText`属性为真时显示`text`值。使用`useSnapshot`，可以这样做：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Implementing the same behavior with selector-based hooks is tough. One solution
    is to use a hook twice. With Zustand, it will be like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于选择器的钩子实现相同的行为很困难。一个解决方案是使用钩子两次。使用Zustand，它将类似于以下内容：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This means if we have more conditions, we need more hooks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们有更多条件，我们需要更多钩子。
- en: On the other hand, a disadvantage of proxy-based render optimization can be
    less predictability. Proxies take care of render optimization behind the scenes
    and sometimes it's hard to debug the behavior. Some may prefer explicit selector-based
    hooks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，基于代理的渲染优化的一个缺点可能是可预测性较低。代理在幕后处理渲染优化，有时很难调试行为。有些人可能更喜欢显式的基于选择器的钩子。
- en: In summary, there's no one-size-fits-all solution. It's up to developers to
    choose the solution that fits their needs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，没有一种适合所有情况的解决方案。选择适合他们需求的解决方案取决于开发者。
- en: In this section, we discussed the approach taken in the Valtio library.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了Valtio库采用的方法。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about a library called Valtio. It utilizes proxies
    extensively. We've seen examples and learned how it can be used. It allows mutating
    state, which feels like using normal JavaScript objects, and the proxy-based render
    optimization helps reduce application code. It depends on developers' requirements
    whether this approach is a good choice.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了一个名为Valtio的库。它广泛使用代理。我们已经看到了示例，并学习了如何使用它。它允许修改状态，感觉就像使用正常的JavaScript对象一样，并且基于代理的渲染优化有助于减少应用程序代码。这种方法是否是一个好的选择取决于开发者的需求。
- en: In the next chapter, we will learn about another library, called React Tracked,
    which is a library that is based on Context and has proxy-based render optimization
    like Valtio.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解另一个名为React Tracked的库，这是一个基于Context的库，类似于Valtio，具有基于代理的渲染优化。
