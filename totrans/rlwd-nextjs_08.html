<html><head></head><body>
		<div id="_idContainer023">
			<h1 id="_idParaDest-76"><em class="italic"><a id="_idTextAnchor075"/>Chapter 6</em>: CSS and Built-In Styling Methods</h1>
			<p>What makes the difference between a great and a bad UI? Some people may answer "features!" and others may say "speed of interaction!" but I would personally define it as a good combination of a great design and ease of use. Your web application could potentially be the most powerful app in the world. Still, it would be difficult for your users to make it work as intended if the UI is not well designed and implemented. So here comes the concept of styling.</p>
			<p>We all know what CSS is: <em class="italic">a basic set of rules telling the browser how to render HTML content graphically</em>. While this seems an easy task, the CSS ecosystem has evolved a lot during recent years, and so has all the tooling that helps developers build great user interfaces with modular, lightweight, and performant CSS rules.</p>
			<p>In this chapter, we will look at several approaches to writing CSS rules. That will pave the way to <a href="B16985_07_Final_SB_epub.xhtml#_idTextAnchor081"><em class="italic">Chapter 7</em></a>, <em class="italic">Using UI Frameworks</em>, where we'll implement UIs using external UI frameworks and utilities to make the developer experience even smoother.</p>
			<p class="callout-heading">Attention</p>
			<p class="callout">This chapter is not intended to teach you how to write CSS rules in any specific technology or language. Instead, we will look at the technologies Next.js integrates out of the box for writing modular, maintainable, and performant CSS styles. If any of the following technologies arouse your interest, I'd recommend reading the official documentation before moving any further into implementing a UI with them.</p>
			<p>We will look in detail at the following topics:</p>
			<ul>
				<li>Styled JSX</li>
				<li>CSS modules</li>
				<li>How to integrate the SASS preprocessor</li>
			</ul>
			<p>By the end of the chapter, you will have learned about the three different built-in styling methods, their differences, and how to configure them for your needs.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Technical requirements</h1>
			<p>To run the code examples in this chapter, you need to have both Node.js and npm installed on your local machine.</p>
			<p>If you prefer, you can use an online IDE such as <a href="https://repl.it">https://repl.it</a> or <a href="https://codesandbox.io">https://codesandbox.io</a>; they both support Next.js, and you don't need to install any dependency on your computer. As for the other chapters, you can find the code base for this chapter on GitHub: https://github.com/PacktPublishing/Real-World-Next.js.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Exploring and using Styled JSX</h1>
			<p>In this <a id="_idIndexMarker334"/>section, we<a id="_idIndexMarker335"/> will explore Styled JSX, a built-in styling mechanism provided by default by Next.js.</p>
			<p>If you don't want to learn a new <a id="_idIndexMarker336"/>styling language such as <strong class="bold">SASS</strong> or <strong class="bold">LESS</strong> and want to integrate a bit of JavaScript into your CSS rules, you might be interested in <strong class="bold">Styled JSX</strong>. It's a <strong class="bold">CSS-in-JS</strong> library (meaning<a id="_idIndexMarker337"/> that we can use JavaScript to write CSS properties) created by Vercel, the company behind Next.js, that allows you to write CSS rules and classes that are scoped to a specific component. </p>
			<p>Let me explain this concept with an easy example. Let's say that we have a <strong class="source-inline">Button</strong> component, and we want to style it using Styled JSX:</p>
			<p class="source-code">export default function Button(props) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code">      &lt;button <strong class="bold">className="button"</strong>&gt;{props.children}&lt;/button&gt;</p>
			<p class="source-code"><strong class="bold">      &lt;style jsx&gt;{`</strong></p>
			<p class="source-code"><strong class="bold">        .button {</strong></p>
			<p class="source-code"><strong class="bold">          padding: 1em;</strong></p>
			<p class="source-code"><strong class="bold">          border-radius: 1em;</strong></p>
			<p class="source-code"><strong class="bold">          border: none;</strong></p>
			<p class="source-code"><strong class="bold">          background: green;</strong></p>
			<p class="source-code"><strong class="bold">          color: white;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">      `}&lt;/style&gt;</strong></p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>As you can see, we're using a very generic <strong class="source-inline">button</strong> class name, which is likely to cause some conflicts <a id="_idIndexMarker338"/>with other components using the same class name, right? The <a id="_idIndexMarker339"/>answer is no! Here's why Styled JSX is so powerful. Not only does it allow you to write highly dynamic CSS thanks to JavaScript, but it also makes sure that the rule you're declaring won't affect any component other than the one you're writing.</p>
			<p>So, if we now want to create a new component called <strong class="source-inline">FancyButton</strong>, we can use the same class name and, thanks to Styled JSX, it won't override the <strong class="source-inline">Button</strong> components styles when both are rendered on page:</p>
			<p class="source-code">export default function FancyButton(props) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code">      &lt;button <strong class="bold">className="button"</strong>&gt;{props.children}&lt;/button&gt;</p>
			<p class="source-code"><strong class="bold">      &lt;style jsx&gt;{`</strong></p>
			<p class="source-code"><strong class="bold">        .button {</strong></p>
			<p class="source-code"><strong class="bold">          padding: 2em;</strong></p>
			<p class="source-code"><strong class="bold">          border-radius: 2em;</strong></p>
			<p class="source-code"><strong class="bold">          background: purple;</strong></p>
			<p class="source-code"><strong class="bold">          color: white;</strong></p>
			<p class="source-code"><strong class="bold">          font-size: bold;</strong></p>
			<p class="source-code"><strong class="bold">          border: pink solid 2px;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">      `}&lt;/style&gt;</strong></p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>The same happens with HTML selectors. If we're writing a <strong class="source-inline">Highlight</strong> component, we can simply <a id="_idIndexMarker340"/>use<a id="_idIndexMarker341"/> Styled JSX to style the whole component without even declaring a specific class:</p>
			<p class="source-code">export default function Highlight(props) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code"><strong class="bold">      &lt;span&gt;{props.text}&lt;/span&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;style jsx&gt;{`</strong></p>
			<p class="source-code"><strong class="bold">        span {</strong></p>
			<p class="source-code"><strong class="bold">          background: yellow;</strong></p>
			<p class="source-code"><strong class="bold">          font-weight: bold;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">       `}&lt;/style&gt;</strong></p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>In that case, the <strong class="source-inline">&lt;span&gt;</strong> style we wrote will be applied to the <strong class="source-inline">Highlight</strong> component only and won't affect any other <strong class="source-inline">&lt;span&gt;</strong> element inside of your pages.</p>
			<p>If you want to create a CSS rule that will be applied to all components, you can just use the <strong class="source-inline">global</strong> prop, and Styled JSX will apply that rule to all the HTML elements matching your selector:</p>
			<p class="source-code">export default function Highlight(props) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code">      &lt;span&gt;{props.text}&lt;/span&gt;</p>
			<p class="source-code">      &lt;style jsx <strong class="bold">global</strong>&gt;{<strong class="bold">`</strong></p>
			<p class="source-code">        span {</p>
			<p class="source-code">          background: yellow;</p>
			<p class="source-code">          font-weight: bold;</p>
			<p class="source-code">        }</p>
			<p class="source-code">      `}&lt;/style&gt;</p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>In the<a id="_idIndexMarker342"/> previous<a id="_idIndexMarker343"/> example, we added the <strong class="source-inline">global</strong> prop to our style declaration, so now, every time we use a <strong class="source-inline">&lt;span&gt;</strong> element, it will inherit the styles we declared inside of our <strong class="source-inline">Highlight</strong> component. Of course, this can be risky, so make sure that's what you want.</p>
			<p>If you're wondering how to get started using Styled JSX and why we haven't covered this package's installation yet... that's because Styled JSX is built into Next.js, so you can start using it right after initializing the project!</p>
			<p>In the next section, we'll look at a more <em class="italic">classic</em> approach for writing CSS rules: CSS modules.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>CSS modules</h1>
			<p>In the previous <a id="_idIndexMarker344"/>section, we saw a CSS-in-JS library, meaning that we had to write our CSS definitions in JavaScript, transforming those styling rules to plain CSS at runtime or compile time, depending on which library we choose and how we configure it.</p>
			<p>While I personally like the CSS-in-JS approach, I eventually recognized that it has some significant drawbacks to consider when choosing the styling method for a new Next.js app.</p>
			<p>Many CSS-in-JS libraries don't provide good IDE/code editor support, making things way harder for developers (no syntax highlighting, autocomplete, linting, and so on). Also, using CSS-in-JS forces you to adopt more and more dependencies, making your application bundle bigger and slower.</p>
			<p>Talking about performance, here's another big drawback: even if we pre-generate CSS rules on the server side, we would need to re-generate them after React hydration on the client side. That adds a high runtime cost, making the web application slower and slower, and it will only worsen when we add more features to our app.</p>
			<p>But here comes an excellent alternative to Styled-JSX: CSS modules. In the previous section, we talked about locally-scoped CSS rules and how Styled-JSX makes it easy to create CSS classes with the same names but different purposes (avoiding naming collisions). CSS modules bring the same concept to the table by writing plain CSS classes, then importing them to your React components without any runtime cost.</p>
			<p>Let's look at an elementary example: a simple landing page with a blue background and welcome text. Let's start by creating a new Next.js app, then creating the <strong class="source-inline">pages/index.js</strong> file as follows:</p>
			<p class="source-code"><strong class="bold">import styles from '../styles/Home.module.css';</strong></p>
			<p class="source-code">export default function Home() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div <strong class="bold">className={styles.homepage}</strong>&gt;</p>
			<p class="source-code">      &lt;h1&gt; Welcome to the CSS Modules example &lt;/h1&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>As you can see, we're importing our CSS classes from a plain CSS file ending with <strong class="source-inline">.module.css</strong>. Even though <strong class="source-inline">Home.module.css</strong> is a CSS file, CSS modules transform its content into a JavaScript object, where every key is a class name. Let's look at the <strong class="source-inline">Home.module.css</strong> file <a id="_idIndexMarker345"/>in detail:</p>
			<p class="source-code">.homepage {</p>
			<p class="source-code">  display: flex;</p>
			<p class="source-code">  justify-content: center;</p>
			<p class="source-code">  align-items: center;</p>
			<p class="source-code">  width: 100%;</p>
			<p class="source-code">  min-height: 100vh;</p>
			<p class="source-code">  background-color: #2196f3;</p>
			<p class="source-code">}</p>
			<p class="source-code">.title {</p>
			<p class="source-code">  color: #f5f5f5;</p>
			<p class="source-code">}</p>
			<p>And after running it, here's the result:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_6.01_B16985.jpg" alt="Figure 6.1 – Home page styled with CSS modules&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Home page styled with CSS modules</p>
			<p>As mentioned before, those <a id="_idIndexMarker346"/>classes are component-scoped. If you inspect the generated HTML page, your landing page will contain a <strong class="source-inline">div</strong> with a class that looks like this:</p>
			<p class="source-code">&lt;div class="<strong class="bold">Home_homepage__14e3j</strong>"&gt;</p>
			<p class="source-code">  &lt;h1 class="<strong class="bold">Home_title__3DjR7</strong>"&gt;</p>
			<p class="source-code">    Welcome to the CSS Modules example</p>
			<p class="source-code">  &lt;/h1&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>As you can see, CSS modules generated unique class names for our rules. Even if we now create new classes using the same generic <strong class="source-inline">title</strong> and <strong class="source-inline">homepage</strong> names in other CSS files, there won't be any naming collision thanks to that strategy.</p>
			<p>But there might be cases where we want our rules to be global. For instance, if we try to render the home page we just created, we will notice that the font family is still the default one. There's also the default <strong class="source-inline">body</strong> margin, and we might want to override those default settings. We can quickly solve that problem by creating a new <strong class="source-inline">styles/globals.css</strong> file with the following content:</p>
			<p class="source-code">html,</p>
			<p class="source-code">body {</p>
			<p class="source-code">  padding: 0;</p>
			<p class="source-code">  margin: 0;</p>
			<p class="source-code">  font-family: sans-serif;</p>
			<p class="source-code">}</p>
			<p>We can then import<a id="_idIndexMarker347"/> it into our <strong class="source-inline">pages/_app.js</strong> file:</p>
			<p class="source-code"><strong class="bold">import '../styles/globals.css';</strong></p>
			<p class="source-code">function MyApp({ Component, pageProps }) {</p>
			<p class="source-code">  return &lt;Component {...pageProps} /&gt;;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default MyApp;</p>
			<p>If we try to render the home page now, we will see that the default <strong class="source-inline">body</strong> margin has disappeared, and the font now is a sans-serif one:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_6.02_B16985.jpg" alt="Figure 6.2 – Home page styled with global CSS module styles&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Home page styled with global CSS module styles</p>
			<p>We can <a id="_idIndexMarker348"/>also use the <strong class="source-inline">:global</strong> keyword to create globally available CSS rules, for example:</p>
			<p class="source-code">.button <strong class="bold">:global</strong> {</p>
			<p class="source-code">  padding: 5px;</p>
			<p class="source-code">  background-color: blue;</p>
			<p class="source-code">  color: white;</p>
			<p class="source-code">  border: none;</p>
			<p class="source-code">  border-radius: 5px;</p>
			<p class="source-code">}</p>
			<p>There's also another excellent CSS module feature that I'd like you to consider when testing out that styling method: <strong class="bold">selector composition</strong>.</p>
			<p>In fact, you can create a very generic rule and then override some of its properties by using the <strong class="source-inline">composes</strong> property:</p>
			<p class="source-code">.button-default {</p>
			<p class="source-code">  padding: 5px;</p>
			<p class="source-code">  border: none;</p>
			<p class="source-code">  border-radius: 5px;</p>
			<p class="source-code">  background-color: grey;</p>
			<p class="source-code">  color: black;</p>
			<p class="source-code">}</p>
			<p class="source-code">.button-success {</p>
			<p class="source-code"><strong class="bold">  composes: button-default;</strong></p>
			<p class="source-code">  background-color: green;</p>
			<p class="source-code">  color: white;</p>
			<p class="source-code">}</p>
			<p class="source-code">.button-danger {</p>
			<p class="source-code"><strong class="bold">  composes: button-default;</strong></p>
			<p class="source-code">  background-color: red;</p>
			<p class="source-code">  color: white;</p>
			<p class="source-code">}</p>
			<p>The main idea of CSS<a id="_idIndexMarker349"/> modules is to provide a straightforward way to write<a id="_idIndexMarker350"/> modular CSS classes with zero runtime costs in every language. Thanks to <strong class="bold">PostCSS modules</strong> (<a href="https://github.com/madyankin/postcss-modules">https://github.com/madyankin/postcss-modules</a>), you can use CSS modules in basically every language (PHP, Ruby, Java, and so on) and templating engine (Pug, Mustache, EJS, and so on).</p>
			<p>We've only scratched the surface of CSS modules and why they are an excellent solution for writing modular, lightweight, classes with zero runtime cost. If you want to learn more about CSS module specifications, you can look at the official repository: <a href="https://github.com/css-modules/css-modules">https://github.com/css-modules/css-modules</a>.</p>
			<p>Just like Styled JSX, CSS modules are available out of the box in every Next.js installation, so once you bootstrap your project, you can get started using them immediately. Still, you might need to tweak the default configuration to add, remove, or edit some features, and Next.js makes this step easy too.</p>
			<p>In fact, Next.js<a id="_idIndexMarker351"/> compiles CSS modules using <strong class="bold">PostCSS</strong>, a popular tool for compiling CSS at build time.</p>
			<p>By default, it is configured by Next.js to include the following features:</p>
			<ul>
				<li><em class="italic">Autoprefixer</em>: It adds vendor<a id="_idIndexMarker352"/> prefixes to your CSS rules using values<a id="_idIndexMarker353"/> from <strong class="bold">Can I Use</strong> (<a href="https://caniuse.com">https://caniuse.com</a>). For instance, if you're writing a rule for the <strong class="source-inline">::placeholder</strong> selector, it will compile it to make it compatible with all the browsers where the selector is slightly different, such as <strong class="source-inline">:-ms-input-placeholder</strong>, <strong class="source-inline">::-moz-placeholder</strong>, and so on. You can learn more about that feature at <a href="https://github.com/postcss/autoprefixer">https://github.com/postcss/autoprefixer</a>.</li>
				<li><em class="italic">Cross-browser flexbox bug fixes</em>: PostCSS follows a community-curated list of flexbox issues (which can be found at <a href="https://github.com/philipwalton/flexbugs">https://github.com/philipwalton/flexbugs</a>) and adds some workarounds for making it work correctly on every browser.</li>
				<li><em class="italic">IE11 compatibility</em>: PostCSS compiles new CSS features, making them available on older browsers such as IE11. Still, there's an exception: CSS variables are not compiled, as it is not safe to do so. If you really need to support older browsers and still want to use them, you can jump to the next section (<em class="italic">Integrating SASS with Next.js</em>) and use SASS/SCSS variables.</li>
			</ul>
			<p>We can edit the PostCSS default configuration by creating a <strong class="source-inline">postcss.config.json</strong> file inside of our project root, then adding the default Next.js configuration:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "plugins": [</p>
			<p class="source-code">    "postcss-flexbugs-fixes",</p>
			<p class="source-code">    [</p>
			<p class="source-code">      "postcss-preset-env",</p>
			<p class="source-code">      {</p>
			<p class="source-code">        "autoprefixer": {</p>
			<p class="source-code">          "flexbox": "no-2009"</p>
			<p class="source-code">        },</p>
			<p class="source-code">        "stage": 3,</p>
			<p class="source-code">        "features": {</p>
			<p class="source-code">          "custom-properties": false</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }</p>
			<p class="source-code">    ]</p>
			<p class="source-code">  ]</p>
			<p class="source-code">}</p>
			<p>From this point, we can<a id="_idIndexMarker354"/> edit the configuration as we prefer, adding, removing, or changing any property.</p>
			<p>In the next section, we will see how to integrate another popular CSS preprocessor: <strong class="bold">Sass</strong>.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Integrating SASS with Next.js</h1>
			<p>SASS is <a id="_idIndexMarker355"/>probably<a id="_idIndexMarker356"/> one of the most loved and used CSS preprocessors out there, and Next.js did an excellent job making it possible to integrate it with ease. In fact, just like CSS modules and Styled JSX, SASS is supported out of the box; we just need to install the <strong class="source-inline">sass npm</strong> package inside of our Next.js project, and we're ready to go:</p>
			<p class="source-code">yarn add sass</p>
			<p>At this point, you can start using CSS modules with SASS and SCSS syntax, just like we did in the previous section.</p>
			<p>Let's look at a simple example. If we open the <strong class="source-inline">pages/index.js</strong> file from the previous section, we <a id="_idIndexMarker357"/>can just change the CSS import to look as <a id="_idIndexMarker358"/>follows:</p>
			<p class="source-code">import styles from '../styles/Home.module<strong class="bold">.scss</strong>';</p>
			<p class="source-code">export default function Home() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div className={styles.homepage}&gt;</p>
			<p class="source-code">      &lt;h1&gt; Welcome to the CSS Modules example &lt;/h1&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>Now we need to rename our <strong class="source-inline">styles/Home.module.css</strong> file to <strong class="source-inline">styles/Home.module.scss</strong> and we're ready to edit that file using the Sass (or SCSS) specific syntax.</p>
			<p>Thanks to SASS and SCSS syntax, we can take advantage of a large set of features that makes our code even more modular and easy to maintain.</p>
			<p class="callout-heading">Pay Attention to the Names!</p>
			<p class="callout">SASS and SCSS are two different syntaxes for the same CSS preprocessor. However, they both provide enhanced ways for writing CSS styles such as <strong class="source-inline">for</strong> variables, loops, mixins, and many other features.</p>
			<p class="callout">While the names may look similar, and the final purpose remains the same, the main difference is that SCSS (Sassy CSS) extends the CSS syntax by adding those features available in every <strong class="source-inline">.scss</strong> file. Any standard <strong class="source-inline">.css</strong> file can be renamed as <strong class="source-inline">.scss</strong> without any problem, as the CSS syntax is valid in <strong class="source-inline">.scss</strong> files.</p>
			<p class="callout">SASS is an older syntax that is not compatible with standard CSS. It doesn't use curly brackets or semicolons; it just uses indentation and new lines to separate properties and nested selectors.</p>
			<p class="callout">Both of those syntaxes need to be transpiled into vanilla CSS in order to be used on regular web browsers.</p>
			<p>Let's take the <a id="_idIndexMarker359"/>CSS<a id="_idIndexMarker360"/> module <strong class="source-inline">compose</strong> property as an example. We've previously seen how to create new CSS classes extending an existing one:</p>
			<p class="source-code">.button-default {</p>
			<p class="source-code">  padding: 5px;</p>
			<p class="source-code">  border: none;</p>
			<p class="source-code">  border-radius: 5px;</p>
			<p class="source-code">  background-color: grey;</p>
			<p class="source-code">  color: black;</p>
			<p class="source-code">}</p>
			<p class="source-code">.button-success {</p>
			<p class="source-code"><strong class="bold">  composes: button-default;</strong></p>
			<p class="source-code">  background-color: green;</p>
			<p class="source-code">  color: white;</p>
			<p class="source-code">}</p>
			<p class="source-code">.button-danger {</p>
			<p class="source-code"><strong class="bold">  composes: button-default;</strong></p>
			<p class="source-code">  background-color: red;</p>
			<p class="source-code">  color: white;</p>
			<p class="source-code">}</p>
			<p>With SCSS, we can choose between many different approaches, such as using the <strong class="source-inline">@extend</strong> keyword (which <a id="_idIndexMarker361"/>works just like the <strong class="source-inline">compose</strong> keyword from <a id="_idIndexMarker362"/>CSS modules):</p>
			<p class="source-code">.button-default {</p>
			<p class="source-code">  padding: 5px;</p>
			<p class="source-code">  border: none;</p>
			<p class="source-code">  border-radius: 5px;</p>
			<p class="source-code">  background-color: grey;</p>
			<p class="source-code">  color: black;</p>
			<p class="source-code">}</p>
			<p class="source-code">.button-success {</p>
			<p class="source-code"><strong class="bold">  @extend .button-default;</strong></p>
			<p class="source-code">  background-color: green;</p>
			<p class="source-code">  color: white;</p>
			<p class="source-code">}</p>
			<p class="source-code">.button-danger {</p>
			<p class="source-code"><strong class="bold">  @extend .button-default;</strong></p>
			<p class="source-code">  background-color: red;</p>
			<p class="source-code">  color: white;</p>
			<p class="source-code">}</p>
			<p>Alternatively, we can<a id="_idIndexMarker363"/> change our class names a bit and take advantage of the <strong class="bold">selector nesting</strong> feature:</p>
			<p class="source-code">.button {</p>
			<p class="source-code">  padding: 5px;</p>
			<p class="source-code">  border: none;</p>
			<p class="source-code">  border-radius: 5px;</p>
			<p class="source-code">  background-color: grey;</p>
			<p class="source-code">  color: black;</p>
			<p class="source-code"><strong class="bold">  &amp;.success {</strong></p>
			<p class="source-code"><strong class="bold">    background-color: green;</strong></p>
			<p class="source-code"><strong class="bold">    color: white;</strong></p>
			<p class="source-code"><strong class="bold">  }</strong></p>
			<p class="source-code"><strong class="bold">  &amp;.danger {</strong></p>
			<p class="source-code"><strong class="bold">    background-color: red;</strong></p>
			<p class="source-code"><strong class="bold">    color: white;</strong></p>
			<p class="source-code"><strong class="bold">  }</strong></p>
			<p class="source-code">}</p>
			<p>SCSS ships with <a id="_idIndexMarker364"/>a<a id="_idIndexMarker365"/> large set of features, such as loops, mixins, functions, and more, allowing any developer to write complex UIs with ease.</p>
			<p>Even though Next.js integrates it natively, you may still need to enable or disable some specific feature or edit the default SASS configuration.</p>
			<p>You can easily do that by editing the <strong class="source-inline">next.config.js</strong> configuration file:</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code"><strong class="bold">  sassOptions: {</strong></p>
			<p class="source-code"><strong class="bold">    outputStyle: 'compressed'</strong></p>
			<p class="source-code"><strong class="bold">    // ...add any SASS configuration here</strong></p>
			<p class="source-code"><strong class="bold">  },</strong></p>
			<p class="source-code">}</p>
			<p>If you're<a id="_idIndexMarker366"/> interested in learning more about SASS and SCSS, I'd highly <a id="_idIndexMarker367"/>recommend looking at the official documentation<a id="_idIndexMarker368"/> at <a href="https://sass-lang.com">https://sass-lang.com</a>.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Summary</h1>
			<p>The CSS ecosystem has evolved a lot in recent years, and the Next.js team keeps the framework up to date with the most modern, performant, and modular solutions for writing CSS styles.</p>
			<p>In this chapter, we've looked at three different built-in solutions, and of course, any one of them has some trade-offs compared with the others.</p>
			<p>Styled JSX, for instance, is definitely one of the easiest ways of writing CSS rules. You can interoperate with JavaScript, dynamically change some CSS rules and properties depending on the user actions, and so on, but it also has some significant drawbacks. Like most CSS-in-JS libraries, Styled JSX first renders on the server side but re-renders the whole generated CSS on the client right after React hydration occurs. That adds some runtime cost to your application, making your application less performant and more challenging to scale. Also, it makes it impossible for the browser to cache your CSS rules, as they get regenerated on every request for server-side and client-side rendered pages.</p>
			<p>SASS and SCSS syntaxes are well integrated into Next.js, and they give you tons of great features for writing complex UIs with zero runtime cost. In fact, Next.js will compile all the <strong class="source-inline">.scss</strong> and <strong class="source-inline">.sass</strong> files to plain CSS at build time, making it possible for the browser to cache all your styling rules. However, we should consider that we can't see the production-optimized plain CSS output until the final build phase. Unlike CSS modules, where what we write is really close to what we get in the final production bundle, the vast set of features provided by SASS could potentially produce a huge final CSS file, and it's not always easy to predict the compiler output while writing deeply nested rules, loops, and so on.</p>
			<p>Ultimately, CSS modules and PostCSS seems to be an excellent option for writing modern CSS styles. The produced output is more easily predictable, and PostCSS automatically polyfills modern CSS features for older browsers (down to IE11).</p>
			<p>In the next chapter, will see how to integrate external UI libraries, making it even easier to write style and feature-rich components and UIs.</p>
		</div>
	</body></html>