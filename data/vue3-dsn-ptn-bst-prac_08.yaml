- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Multithreading with Web Workers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web Workers进行多线程
- en: In this chapter, we will cover important topics that will highly improve the
    performance of a web application, especially single-page applications. First,
    we will learn how websites and JavaScript work, and how to use `web workers` to
    leverage our application processing power, data access, and network communications.
    Then, we will introduce two new conceptual design patterns and will implement
    them in an example application together with other patterns that we have previously
    seen. On top of this, we will also introduce two libraries that will facilitate
    our network communications as well as the handling of our persistent database(s)
    in IndexedDB. We will also implement a simple Node.js server to provide us with
    feedback and test our work in a highly decoupled architecture, where our frontend
    and backend services communicate using standard APIs over the HTTP protocol.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖一些重要主题，这些主题将极大地提高Web应用程序的性能，尤其是单页应用程序。首先，我们将学习网站和JavaScript是如何工作的，以及如何使用`web
    workers`来利用我们的应用程序处理能力、数据访问和网络通信。然后，我们将介绍两种新的概念设计模式，并将它们与我们在之前看到的其他模式一起在一个示例应用程序中实现。在此基础上，我们还将介绍两个库，它们将简化我们的网络通信以及在我们的IndexedDB中处理持久数据库。我们还将实现一个简单的Node.js服务器，以提供反馈并测试我们在高度解耦的架构中的工作，在这种架构中，我们的前端和后端服务通过HTTP协议使用标准API进行通信。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: WebWorkers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebWorkers
- en: Business and dispatcher patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业和调度器模式
- en: Network communication inside a `WebWorker`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`WebWorker`内部的网络通信
- en: A browser’s persistent embedded database – IndexedDB
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器持久嵌入式数据库 – IndexedDB
- en: How to build a simple Node.js API server for testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建简单的Node.js API服务器进行测试
- en: The concepts in this chapter can be considered “advanced,” but we will condense
    them down into understandable pieces that we will implement right away. By the
    end of this chapter, you will have a solid knowledge of how to implement multithreading
    in your web applications and also a reference framework to scale and facilitate
    the use of complex browser APIs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的概念可以被认为是“高级”的，但我们将把它们浓缩成可理解的片段，并立即实现。到本章结束时，你将拥有如何在Web应用程序中实现多线程的扎实知识，以及一个参考框架来扩展和简化复杂浏览器API的使用。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not add additional requirements to our application. However,
    we will only see relevant parts of the code, so to see the entire application
    working, you should refer to the code examples for [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186),
    *Multithreading with Web Workers*, in the book’s GitHub repository at [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter08](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter08).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会对我们的应用程序增加额外的要求。然而，我们只会看到代码的相关部分，因此要查看整个应用程序的工作情况，你应该参考书中[*第8章*](B18602_08.xhtml#_idTextAnchor186)，*使用Web
    Workers进行多线程*，在GitHub仓库[https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter08](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter08)中的代码示例。
- en: 'Check out the following video to see the Code in Action: [https://packt.link/D4EHt](https://packt.link/D4EHt)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://packt.link/D4EHt](https://packt.link/D4EHt)
- en: An introduction to web workers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Workers简介
- en: JavaScript is a single-threaded language, meaning that it doesn’t natively have
    a way to spawn processes in separate threads. This makes web browsers run the
    JavaScript in a web page on the same thread as other processes, which directly
    affects the performance of the page, most notably, the rendering process,that
    is in charge of presenting the page on the screen. Bowsers make a considerable
    effort to optimize the performance of all these moving parts to make a page responsive,
    performant, fast, and efficient. However, there are tasks that a web application
    must do in JavaScript that are heavy and potentially “render-blocking”. This means
    that the browser will have to pay attention to the results of the code and use
    all the resources to complete the running function before it can focus on the
    rendering (presenting the page to the screen). If you ever find a process on a
    web page that makes the site seem “unresponsive” or “stuttering” after you start
    an action (your mouse may even freeze in some cases), this could be one of the
    causes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种单线程语言，这意味着它本身没有在单独的线程中生成进程的方法。这使得网络浏览器在网页上运行 JavaScript 时，与其他进程在同一个线程上运行，这直接影响了页面的性能，尤其是渲染过程，它负责在屏幕上呈现页面。浏览器会付出相当大的努力来优化所有这些移动部件的性能，以使页面响应、性能良好、快速且高效。然而，有一些任务网络应用程序必须在
    JavaScript 中执行，这些任务很重，并且可能“阻塞渲染”。这意味着浏览器必须关注代码的结果，并使用所有资源来完成正在运行的函数，然后才能专注于渲染（将页面呈现到屏幕上）。如果你在开始操作后（在某些情况下，你的鼠标甚至可能冻结）发现网页上的某个进程使网站看起来“无响应”或“卡顿”，这可能是其中的一个原因。
- en: 'If we open the developer tools in a modern browser, we can access some performance
    tools to analyze how a web page behaves and how much time each process step takes.
    For example, here is a quick view of the first load of YouTube on a shared link,
    in Firefox for Linux:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在现代浏览器中打开开发者工具，我们可以访问一些性能工具来分析网页的行为以及每个进程步骤花费多少时间。例如，这里是对共享链接中 Firefox for
    Linux 上 YouTube 首次加载的快速查看：
- en: '![Figure 8.1 – The performance of YouTube’s first load, seen using developer
    tools](img/Figure_8.01_B18602.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 使用开发者工具看到的 YouTube 首次加载的性能](img/Figure_8.01_B18602.jpg)'
- en: Figure 8.1 – The performance of YouTube’s first load, seen using developer tools
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 使用开发者工具看到的 YouTube 首次加载的性能
- en: The preceding screenshot has zoomed into the actual processing of the page,
    showing what happens before the first rendering, meaning before the user can actually
    see something on the screen. That is represented in the first line, **Screenshots**,
    where for this case, the first visible elements appear towards the end of the
    timeline (*#1*). The second line shows what the main **Parent Process** has been
    busy doing, and if you pay attention, the very first section (*#2*) is all about
    processing JavaScript. The **Renderer**process, highlighted and displayed with
    a black bar (#3), can’t even start until the JavaScript has been run. When it
    does run, it draws the page on the screen, and you have the visible content from
    *#1*. This gives an approximate idea of the work the browser does each cycle in
    between screen paints (called “frames”). The browser attempts to produce as many
    **frames per second** (**fps**) as possible. To keep a fluent 60 fps, it needs
    to do all this processing in about 16.67 milliseconds or less. At best, your JavaScript
    process should be resolved in half that time to keep a fluid experience for the
    user. With this in mind, what happens when your JavaScript takes longer than that?
    Simple enough, the render process is postponed, the fps drop, and the user experiences
    stuttering and a frozen **user interface** (**UI**) may happen. Depending on your
    web application, this could be an important issue.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图已经放大到页面的实际处理过程，显示了在第一次渲染之前发生的事情，也就是说，在用户实际上可以在屏幕上看到某样东西之前。这体现在第一行，**截图**，在这个案例中，第一个可见元素出现在时间轴的末尾（*#1*）。第二行显示了主要的**父进程**一直在忙于做什么，如果你注意看，第一个部分（*#2*）全部都是关于处理
    JavaScript 的。**渲染器**进程，用黑色条带突出显示并显示（#3），甚至在 JavaScript 运行之前都无法开始。当它运行时，它会在屏幕上绘制页面，你就可以看到从
    *#1* 出来的可见内容。这给出了浏览器在屏幕绘制（称为“帧”）之间每个周期所做工作的近似概念。浏览器试图尽可能多地产生每秒**帧数**（**fps**）。为了保持流畅的
    60 fps，它需要在大约 16.67 毫秒或更短的时间内完成所有这些处理。最佳情况下，你的 JavaScript 进程应该在半数时间内解决，以保持用户的流畅体验。考虑到这一点，如果你的
    JavaScript 耗时超过这个时间，会发生什么呢？很简单，渲染过程会被推迟，fps 会下降，用户可能会体验到卡顿，甚至可能发生用户界面**（UI**）冻结的情况。根据你的网络应用程序，这可能会成为一个重要的问题。
- en: 'You may say, “Wait a minute, why we don’t make heavy tasks asynchronous? Wouldn’t
    that resolve the issue?” The answer is: maybe and no. When you declare an asynchronous
    function, it only means that the execution will be deferred to a place in time
    when the processing of the sequential code has been executed. Most likely, this
    pushes the asynchronous code toward the end or after the sequential code has been
    executed, but then it will be run sequentially as usual. If the rendering process
    happens before that, you may perceive a performance gain, but if not, you face
    the same issue if the async function takes longer (as it will affect the next
    rendering). If we moved all functions to be asynchronous, we would end up potentially
    with the same result as if everything were sequential, plus the overhead of making
    the asynchronous calls:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说，“等等，为什么我们不将重任务异步化？这不会解决我们的问题吗？” 答案是：可能和不一定。当你声明一个异步函数时，这只意味着执行将被推迟到顺序代码处理完成的时间点。很可能是将异步代码推到最后或顺序代码执行之后，但随后它将像往常一样顺序执行。如果在那时渲染过程发生，你可能会感觉到性能提升，但如果不是，如果异步函数执行时间更长（因为它将影响下一次渲染），你将面临同样的问题。如果我们把所有函数都改为异步，我们可能会得到与所有内容都是顺序执行相同的结果，加上异步调用的开销：
- en: '![Figure 8.2 – A representation of the execution of async code, moved after
    the sequential code has been executed (1)](img/Figure_8.02_B18602.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 异步代码执行表示，在顺序代码执行之后移动（1）](img/Figure_8.02_B18602.jpg)'
- en: Figure 8.2 – A representation of the execution of async code, moved after the
    sequential code has been executed (1)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 异步代码执行表示，在顺序代码执行之后移动（1）
- en: 'Then, if asynchronous operations would not completely solve the performance
    issue, how do we resolve it? Beyond all the optimizations you could make, there
    is one technology you should also consider at the top of the list of alternatives:
    the web workers API.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果异步操作不能完全解决性能问题，我们该如何解决它？在所有可能的优化之外，你还应该考虑将一种技术放在替代方案列表的顶部：Web Workers API。
- en: 'Web workers are JavaScript scripts that execute in their own process (or thread,
    depending on the implementation); thus, they do not compromise the parent process
    where the rendering happens. The browser API provides a rather simple yet effective
    way to communicate to and from the parent process: a messaging system. These messages
    can only pass serializable data. The parent process and each web worker operate
    in their own environment and memory boundaries, so they cannot share references
    or functions, hence why all the data passed between them has to be serializable
    as it is copied into each process. While this may seem like a disadvantage, it
    is actually an asset when used properly, as we will see soon here. Another caveat
    of this architecture is that web workers do not have access to the **Document
    Object Model** (**DOM**) or the Window objects and, consequently, to any of their
    services. They do, however, have access to the network and IndexedDB. This opens
    up a wealth of opportunities for the architectural design of your frontend application,
    as you can easily separate what a presentation layer and a business layer is.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers是执行在其自身进程（或线程，取决于实现方式）中的JavaScript脚本；因此，它们不会影响渲染发生的父进程。浏览器API提供了一个相对简单但有效的通信方式：消息系统。这些消息只能传递可序列化的数据。父进程和每个Web
    Worker在自己的环境和内存边界内操作，因此它们不能共享引用或函数，这就是为什么所有在它们之间传递的数据都必须是可序列化的，因为它们被复制到每个进程中。虽然这看起来可能像是一个缺点，但实际上，如果正确使用，它实际上是一个优点，正如我们很快就会看到的。这个架构的另一个缺点是，Web
    Workers无法访问**文档对象模型**（**DOM**）或Window对象及其任何服务。然而，它们确实可以访问网络和IndexedDB。这为你的前端应用程序的架构设计开辟了丰富的机会，因为你可以轻松地分离表示层和业务层。
- en: "![Figure 8.3 – A layer\uFEFFed representation of a Vue application with background\
    \ processes using web workers](img/Figure_8.03_B18602.jpg)"
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 使用Web Workers的Vue应用程序分层表示，包含后台进程](img/Figure_8.03_B18602.jpg)'
- en: Figure 8.3 – A layered representation of a Vue application with background processes
    using web workers
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 使用Web Workers的Vue应用程序分层表示，包含后台进程
- en: As you can see in the previous diagram, we can instantiate multiple web workers
    to represent different types of layers in our application (**Business**, **Data**,
    **Communication**, and so on). While a web worker can be started and terminated
    from the parent process at will, both of these actions are computationally expensive,
    so the recommendation is that web workers, once created, remain active during
    the duration of the application and accessed when needed. It is also recommended
    not to abuse this resource by creating “too many” web workers, as each one is
    a different process with its own resources reserved. There is no clear definition
    of what constitutes “too many”, so discretion is advised. In my experience, while
    the number of web workers remains in the lower single digits, even low-powered
    devices should handle your application with excellent performance. As with many
    other things, there can be too much of a good thing, and this also applies with
    web workers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们可以实例化多个Web Worker来表示我们应用程序中不同类型的层（**业务**、**数据**、**通信**等）。虽然Web Worker可以从父进程随意启动和终止，但这两个动作都是计算密集型的，因此建议一旦创建Web
    Worker，就保持其在应用程序运行期间活跃，并在需要时访问。还建议不要过度使用这种资源，创建“太多”的Web Worker，因为每个Web Worker都是一个不同的进程，拥有自己的资源预留。没有明确的定义来界定“太多”，因此建议谨慎行事。根据我的经验，当Web
    Worker的数量保持在个位数时，即使是低功耗设备也应该能够以出色的性能处理你的应用程序。与许多其他事物一样，好事可能做得太多，这也适用于Web Worker。
- en: Now that we know what web workers are and what they can do for us, let’s see
    how to implement them in pure JavaScript and then how to do so with Vite.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了什么是Web Worker以及它们能为我们做什么，让我们来看看如何在纯JavaScript中实现它们，然后是如何使用Vite来实现。
- en: Implementing a Web Worker
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Web Worker
- en: 'Creating a web worker in plain JavaScript is quite simple and straightforward.
    The `window``Worker`, which receives as a parameter the path to a script file.
    For example, considering that our web worker is contained in a `my_worker.js`
    file, this is how we can create it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯JavaScript中创建Web Worker非常简单直接。`window.Worker`接收一个参数，即脚本文件的路径。例如，考虑到我们的Web
    Worker包含在`my_worker.js`文件中，我们可以这样创建它：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Simple enough, if the constructor exists in the `window` object, then we just
    create a new worker accessing the constructor directly. The newly created worker
    again exposes a simple API:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单，如果构造函数存在于`window`对象中，那么我们只需直接访问构造函数来创建一个新的worker。新创建的worker再次暴露了一个简单的API：
- en: '`.postMessage(message)`: This will send the message to the web worker. It can
    be any data type that can be serialized (basic data types, arrays, objects, and
    so on).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.postMessage(message)`: 这将消息发送到Web Worker。它可以是被序列化的任何数据类型（基本数据类型、数组、对象等）。'
- en: '`.onmessage(callback(event))`: This event is triggered when the workers send
    a message to the parent process. The event received has a `.data` field that contains
    the message/data passed by the worker.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.onmessage(callback(event))`: 当worker向父进程发送消息时，将触发此事件。接收的事件有一个`.data`字段，其中包含worker传递的消息/数据。'
- en: '`.onerror(callback(event))`: When an error occurs in the worker, this event
    is triggered, and it will contain the following fields:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.onerror(callback(event))`: 当worker中发生错误时，将触发此事件，并且它将包含以下字段：'
- en: '`.filename`: With the name of the script filename that generated the error.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.filename`: 生成错误的脚本文件名。'
- en: '`.lineno`: The line number where the error occurred.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.lineno`: 发生错误的行号。'
- en: '`.message`: A string containing the description of the error.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.message`: 包含错误描述的字符串。'
- en: 'This messaging system allows us to carry on what otherwise could be a very
    complex form of **inter-process communication** (**IPC**). Our previous code should
    look as follows due to implementing it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息系统允许我们进行原本可能非常复杂的**进程间通信**（IPC）。由于实现了它，我们的代码应该看起来如下：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To complete this, we now need to implement the `my_worker.js` script. For this
    example, it can be something as simple as this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们现在需要实现`my_worker.js`脚本。对于这个例子，它可以像这样简单：
- en: ./my_worker.js
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ./my_worker.js
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our example worker is very simple. It prints the data received to the console,
    and 3 seconds after it has been activated, it sends a message to the parent process.
    Notice that we are using the `self` reserved word. This is needed when accessing
    the API from within a function, as it references the worker itself. This is why
    it is necessary inside the `setTimeout` callback. At the root level, it is optional,
    so you can write `self.onmessage` as in our example or directly `onmessage`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例工作线程非常简单。它将接收到的数据打印到控制台，并在激活后 3 秒钟向父进程发送一条消息。请注意，我们正在使用 `self` 保留字。当在函数内部访问
    API 时需要它，因为它引用的是工作线程本身。这就是为什么它需要在 `setTimeout` 回调内部使用。在根级别，它是可选的，因此你可以像我们的示例中那样写
    `self.onmessage`，或者直接写 `onmessage`。
- en: Web Workers can instantiate other workers and also import other scripts through
    the `self.importScript()` method or just `importScript()`. This method receives
    a string with the script filename as a parameter. This is analogous to how we
    use the `import` statement in our services and components in our main application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers 可以通过 `self.importScript()` 方法或直接使用 `importScript()` 来实例化其他工作线程并导入其他脚本。此方法接收一个包含脚本文件名的字符串作为参数。这与我们在主应用程序中的服务和组件中使用
    `import` 语句的方式类似。
- en: 'When using Vite, as we are doing to bundle our Vue application, we have an
    alternative way to import and create a worker by using a suffix. For example,
    add the following in our `main.js` script:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Vite 时，正如我们用来打包 Vue 应用程序那样，我们可以通过使用后缀来提供一种替代方法来导入和创建一个工作线程。例如，在我们的 `main.js`
    脚本中添加以下内容：
- en: ./main.js
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ./main.js
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When using the `worker` suffix notation, Vite wraps the implementation in a
    constructor, which we can use to instantiate our worker. This way makes handling
    workers more akin to using any other class in our application, as we can use the
    same approach to include it in our application, and this is the syntax we will
    use in our examples. Additionally, Vite will process the scripts from our worker,
    so we can use our more familiar syntax to import resources (`import ... from ...`)
    instead of the native `self.importScript()`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `worker` 后缀表示法时，Vite 会将实现包装在一个构造函数中，我们可以使用它来实例化我们的工作线程。这种方式使得处理工作线程更类似于使用我们应用程序中的任何其他类，因为我们可以使用相同的方法将其包含在我们的应用程序中，这就是我们将在示例中使用的语法。此外，Vite
    将处理我们工作线程中的脚本，因此我们可以使用更熟悉的语法来导入资源（`import ... from ...`），而不是使用原生的 `self.importScript()`。
- en: There is more about web workers to learn. For our purposes, this is enough and
    what we will use. If you would like to know more, please refer to the documentation
    on the Mozilla Developer Network ([https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Web Workers 有更多内容需要学习。就我们的目的而言，这已经足够，我们将使用这些内容。如果您想了解更多信息，请参阅 Mozilla 开发者网络上的文档（[https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)）。
- en: 'With these building blocks, we can now implement a robust and easier-to-handle
    connection to our web workers by applying design patterns. Before we do that,
    we need to learn two more patterns conceptually: the business delegate and the
    dispatcher patterns.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些构建块，我们现在可以通过应用设计模式来实现一个健壮且易于处理的对我们的 Web Workers 的连接。在我们这样做之前，我们需要从概念上学习两个更多的模式：业务代理模式和调度器模式。
- en: The business delegate pattern
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务代理模式
- en: 'This pattern is used to hide the complexity of accessing business services
    or a business layer from the client or presentation layer by providing a single
    point of access with a well-defined and simple(r) interface. It can be reasoned
    to some degree as a variant or evolution of the proxies and decorator patterns
    that we saw in [*Chapter 2*](B18602_02.xhtml#_idTextAnchor040)*, Software Design
    Principles and Patterns*, but applied at a larger logical scale between architectural
    layers. It usually involves at least the following entities:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式通过提供一个具有良好定义和简单（更）接口的单一点访问，用于隐藏从客户端或表示层访问业务服务或业务层的复杂性。它可以在一定程度上被视为我们在 [*第
    2 章*](B18602_02.xhtml#_idTextAnchor040)*，软件设计原则和模式* 中看到的代理和装饰器模式的变体或演变，但应用于更大逻辑尺度的架构层之间。它通常涉及以下至少实体：
- en: A **business delegate** entity, which acts as the single point of entry for
    the client to all the available services
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **业务代理** 实体，作为客户端进入所有可用服务的单一入口点
- en: A **business lookup or router** entity whose function is to route the execution
    of the incoming request to the appropriate service
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **业务查找或路由器** 实体，其功能是将传入请求的执行路由到适当的服务
- en: The **business services** that expose a common interface (directly or via a
    proxy pattern) with the provided function
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供公共接口（直接或通过代理模式）的**业务服务**
- en: 'The pattern can be represented for our purposes in the following diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，这个模式可以用以下图表来表示：
- en: '![Figure 8.4 – A representation of the business delegate pattern](img/Figure_8.04_B18602.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 业务代理模式的表示](img/Figure_8.04_B18602.jpg)'
- en: Figure 8.4 – A representation of the business delegate pattern
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 业务代理模式的表示
- en: This pattern can be applied to multiple architectural levels. In our particular
    case, we want to apply this design to our application with web workers. We will
    consider the parent process as our presentation layer and our web worker as our
    business layer. In the parent (or main process), we will have our Vue application,
    as usual, focusing primarily on providing an excellent user experience. The worker
    will then be responsible for providing us with access to services, either local,
    as in the case of the IndexedDB, or remote, encapsulating the communication with
    our server and additional services and any additional computationally intensive
    function. This separation of concerns has many advantages, not only from the performance
    point of view but also from the design and implementation of the application as
    a whole.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以应用于多个架构级别。在我们特定的案例中，我们希望将这种设计应用于我们的Web Workers应用程序。我们将把父进程视为我们的表示层，把Web
    Worker视为我们的业务层。在父进程（或主进程）中，我们将拥有我们的Vue应用程序，一如既往地主要关注提供卓越的用户体验。然后，工作者将负责为我们提供访问服务，无论是本地的（如IndexedDB的情况），还是远程的，封装与我们的服务器和附加服务以及任何额外的计算密集型函数的通信。这种关注点的分离具有许多优点，不仅从性能角度来看，而且从整个应用程序的设计和实现来看。
- en: Before we implement the code for this chapter, we need to see one more pattern
    that we will implement since we can only pass serializable data between processes
    and cannot execute function calls as a plain Business Delegate pattern proposes.
    We will expand on the idea of the command pattern and use what is called a dispatcher
    pattern.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现本章的代码之前，我们需要看到另一个我们将要实现的模式，因为我们只能在进程间传递可序列化的数据，而不能像纯业务代理模式所建议的那样执行函数调用。我们将扩展命令模式的想法，并使用所谓的分发器模式。
- en: The dispatcher pattern
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发器模式
- en: We have seen previously that either our parent process or the web worker process
    can initiate communication by posting (sending) a message to each other. As long
    as the proper listener (`onmessage`) has been defined, either one can receive
    and react to these events. In the Dispatcher pattern, these messages contain information
    related to the event, such as data. The key factor that separates this design
    pattern is that *the event messages must be published between threads and scheduled
    for execution upon arrival*. Of course, this scheduling can also include the “immediate
    execution” of some task or function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到，无论是我们的父进程还是Web Worker进程都可以通过向对方发送消息来启动通信。只要定义了适当的监听器（`onmessage`），任何一个都可以接收并响应这些事件。在分发器模式中，这些消息包含与事件相关的信息，例如数据。区分这种设计模式的关键因素是*事件消息必须在线程间发布，并在到达时进行调度*。当然，这种调度也可以包括某些任务或函数的“立即执行”。
- en: The implementation of this pattern is rather trivial, and you may think of it
    as akin to the Command Pattern that we saw in [*Chapter 2*](B18602_02.xhtml#_idTextAnchor040),
    *Software Design Principles and Patterns*, so we will not see this again. Instead,
    we will take these concepts of communication between threads, scheduling, and
    events with data to create our solution to work with web workers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的实现相当简单，你可能认为它类似于我们在[*第2章*](B18602_02.xhtml#_idTextAnchor040)“软件设计原则与模式”中看到的命令模式，因此我们不会再看到这个模式。相反，我们将利用线程间通信、调度和与数据相关的事件这些概念来创建我们与Web
    Workers协同工作的解决方案。
- en: Establishing a communication pipeline with the web worker
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立与Web Worker的通信管道
- en: 'We have now seen the key concepts that we want to apply to our implementation
    of the communication with web workers for our Vue application. This model can
    be used repeatedly from application to application and improved upon as needed.
    As a general plan of action, this is what we will build using the design patterns
    seen thus far:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了我们想要应用于我们的Vue应用程序Web Workers通信实现的关键概念。这个模型可以在应用程序之间重复使用，并根据需要改进。作为一个一般行动计划，这是我们将会使用迄今为止看到的模式来构建的：
- en: We will create a web worker with a single point of access in our Vue application,
    following the Business Delegate pattern
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在Vue应用程序中创建一个网络工作器，遵循业务代表模式，以实现单一点访问。
- en: Each message will raise an event to either process (parent-worker or worker-parent)
    and include command and payload data, as well as tracking information for scheduling
    as in the Dispatcher Pattern
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条消息都会引发一个事件，用于处理（父-工作器或工作器-父）并包含命令和有效负载数据，以及调度信息，如调度器模式中所述。
- en: 'Simple enough, the architecture described in the preceding points allows us
    to establish a workflow as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单，前面描述的架构使我们能够建立如这里所示的工作流程：
- en: '![Figure 8.5 – Implementation of the communication workflow with the web worker](img/Figure_8.05_B18602.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 与网络工作器的通信工作流程实现](img/Figure_8.05_B18602.jpg)'
- en: Figure 8.5 – Implementation of the communication workflow with the web worker
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 与网络工作器的通信工作流程实现
- en: 'Now that we have the theoretical basis and a broad understanding of what we
    will create, it is time to move into the code. We will focus on the most relevant
    parts of the code that implement the model mentioned previously. To see the entire
    application code, please review the full source code from the GitHub repository.
    Let’s start by creating a service that will be our entry point in the client application:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了理论基础和广泛的了解，我们将要创建的内容，是时候进入代码编写阶段了。我们将关注实现之前提到的模型的代码中最相关的部分。要查看整个应用程序代码，请查看GitHub仓库中的完整源代码。让我们首先创建一个服务，它将成为客户端应用程序的入口点：
- en: ./services/WebWorker.js
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ./services/WebWorker.js
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This implementation is simple yet effective. It serves us well to understand
    how these patterns work. We start by importing the web worker constructor using
    Vite’s special suffix `worker` and then creating the instance reference in line
    *//1*. As usual, this service will be a singleton, so we create it as a JavaScript
    object, which we will export later in line *//10*. The service has only three
    members:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现简单而有效。它很好地帮助我们理解这些模式是如何工作的。我们首先使用Vite的特殊后缀 `worker` 导入网络工作器构造函数，然后在第 *//1*
    行创建实例引用。像往常一样，这个服务将是一个单例，所以我们将其创建为一个JavaScript对象，我们将在第 *//10* 行将其导出。该服务只有三个成员：
- en: '`queue`: This is defined on line *//2* and is a dictionary that we will use
    to store our scheduled calls to the web worker using a unique identification.
    Each entry will save the reference to the resolution methods of a promise (`resolve`
    and `reject`).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queue`：在第 *//2* 行定义，是一个我们将使用它来存储对网络工作器预定调用的字典，使用唯一标识符。每个条目将保存承诺（`resolve`
    和 `reject`）的解析方法的引用。'
- en: 'The `request()` method: Defined on line //3 here, this will be used by other
    services and components (the “clients”) to request tasks from the web worker.
    It always returns a promise (line //4). The message passed to the web worker encapsulates
    the `command` and `payload` received as parameters with a unique identification.
    We save the reference to the `resolve()` and `reject()` methods in the `queue`
    (line //5), and finally, using the native messaging method of the web worker,
    we post the message on line //6.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request()` 方法：在这里的第 //3 行定义，将由其他服务和组件（“客户端”）用来从网络工作器请求任务。它总是返回一个承诺（第 //4 行）。传递给网络工作器的消息封装了作为参数接收的
    `command` 和 `payload` 以及一个唯一的标识符。我们在 `queue` 中保存 `resolve()` 和 `reject()` 方法的引用（第
    //5 行），最后，使用网络工作器的原生消息方法，在第 //6 行发布消息。'
- en: 'The `processMessage()` method: This receives the data submitted by the web
    worker, and based on the identification and the result of the operation passed
    in the `.success` attribute (Boolean), we access `queue` and either use the `resolve()`
    or the `reject()` function to resolve or reject the promise (line //7). Finally,
    we remove the reference from the `queue` in line //8.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`processMessage()` 方法：这个方法接收网络工作器提交的数据，根据标识符和 `.success` 属性（布尔值）中传递的操作结果，我们访问
    `queue` 并使用 `resolve()` 或 `reject()` 函数来解析或拒绝承诺（第 //7 行）。最后，我们在第 //8 行从 `queue`
    中移除引用。'
- en: 'The last step in this file is to link the incoming messages passing the data
    directly from the worker to `service.processMessage()` in line //9\. It may be
    clear by now that we have made some decisions regarding the structure of the message
    and also the reply. Messages have three components: `id`, `command`, and `payload`.
    Replies also have three elements: `id`, `success`, and `payload`. On the client
    side, we have chosen to operate with promises, as they do not “time out”.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件的最后一步是将传入的消息直接从工作器链接到第9行的`service.processMessage()`。到现在为止，可能已经很清楚，我们已经就消息的结构和回复做出了一些决定。消息有三个组成部分：`id`、`command`和`payload`。回复也有三个元素：`id`、`success`和`payload`。在客户端，我们选择使用承诺来操作，因为它们不会“超时”。
- en: 'With the client side resolved, now it’s time to work on the web worker script.
    Create the following `index.js` file in the `webworker` directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端解决后，现在是我们开始工作在网页工作器脚本的时候了。在`webworker`目录中创建以下`index.js`文件：
- en: ./webworker/index.js
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ./webworker/index.js
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The web worker is even shorter, and we have also made some decisions regarding
    the interface implemented by each underlying service: each of their methods has
    to return a Promise as well. Let’s see the code and find out why.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 网页工作器甚至更短，我们还在每个底层服务实现的接口上做出了一些决定：它们的方法必须返回一个承诺。让我们看看代码，找出原因。
- en: 'We start on line //1by importing `testService` (we will create it later) and
    include it in an array of services. This will make it easier to add new services
    by importing them and just including them in this array (this could be a stepping
    stone to a plugin architecture but we’ll stay simple for now). We then define
    a `sendRequest()` global function, which will send a message to the parent process
    with a coded message with three fields: `id`, `success`, and `payload`, as expected
    by the client in our defined . This is what happens in line//2.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第1行开始，导入`testService`（我们稍后会创建它），并将其包含在一个服务数组中。这将使得通过导入并仅将它们包含在这个数组中来添加新服务变得更容易（这可能是通向插件架构的垫脚石，但现在我们将保持简单）。然后我们定义一个全局的`sendRequest()`函数，它将向父进程发送一个带有三个字段：`id`、`success`和`payload`的编码消息，正如客户端在定义中所期望的那样。这就是第2行发生的事情。
- en: 'In line //3, we define the `onmessage` event handler to process the incoming
    messages. When one is received, we traverse our `services` array to find a matching
    command (line //4), and when we do (line //5), we execute the function by passing
    the payload as a parameter (line //6) after we parse it through the JSON utility.
    Then, with the resolution or rejection of the promise, we transmit the proper
    result to the client in line *//7*. This short piece of code acts as the *business
    delegator and dispatcher*. Finally, let’s take a look at `testService` to see
    how it works:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们定义了`onmessage`事件处理器来处理传入的消息。当收到一个消息时，我们遍历我们的`services`数组以找到匹配的命令（第4行），当我们找到时（第5行），我们通过JSON实用程序解析它后，将有效载荷作为参数传递给函数执行（第6行）。然后，通过承诺的解决或拒绝，我们在第7行将适当的结果传输给客户端。这段简短的代码充当了*业务委托和调度器*。最后，让我们看看`testService`是如何工作的：
- en: ./webworker/services/test.js
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ./webworker/services/test.js
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can appreciate, this test service doesn’t do much other than just return
    a Promise and set a timer to resolve it after 3 seconds. This delay is artificial
    since, otherwise, the reply would be immediate. If you run the example application,
    when you click the **Send request** button, you will see the message changing
    from **Waiting...** to **Worker alive and working!** after 3 seconds, just as
    expected:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个测试服务除了返回一个承诺并设置一个3秒后解决的定时器外，没有做太多其他的事情。这个延迟是人为的，因为否则回复将是立即的。如果你运行示例应用程序，当你点击**发送请求**按钮时，你将看到消息在3秒后从**等待...**变为**工作器活跃并工作！**，正如预期的那样：
- en: '![Figure 8.6 – The test application dispatches a command to the worker and
    shows the result](img/Figure_8.06_B18602.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 测试应用程序向工作器发送命令并显示结果](img/Figure_8.06_B18602.jpg)'
- en: Figure 8.6 – The test application dispatches a command to the worker and shows
    the result
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 测试应用程序向工作器发送命令并显示结果
- en: 'To make this happen, in our `App.vue` component, we import our web worker service
    and send our request with the command string as the name of the function in the
    service we want to execute. For this example, add the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，在我们的`App.vue`组件中，我们导入我们的网页工作器服务，并使用命令字符串作为服务中要执行的函数的名称发送我们的请求。对于这个例子，添加以下代码：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These simple lines of code to create and manage a web worker provide your application
    with a considerable increase in computational power and performance. Now that
    our bases are set, it is time to do something more significant with our service
    worker. Let’s make it access our local database and the network.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的代码行用于创建和管理Web Worker，为您的应用程序提供了相当大的计算能力和性能提升。现在我们的基础已经打好，是时候用我们的服务Worker做些更有意义的事情了。让我们让它访问我们的本地数据库和网络。
- en: Accessing IndexedDB with DexieJS in the web worker
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Web Worker中使用DexieJS访问IndexedDB
- en: 'IndexedDB is a very powerful key-value database; however, the native implementation
    provides an API that is rather hard to handle. The actual recommendation is not
    to use it but, instead, work with it through a framework or library. The database
    engine is fast and very malleable, so multiple libraries have built upon its foundation
    and recreated functions and features not present originally. Some libraries even
    mimic SQL and document-based databases. Some available and free-to-use libraries
    are the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB是一个非常强大的键值数据库；然而，其原生实现提供的API相当难以处理。实际建议是不要直接使用它，而是通过框架或库来与之交互。数据库引擎速度快且非常灵活，因此许多库在其基础上构建，并重新创建了原本不存在的功能和特性。一些库甚至模仿SQL和基于文档的数据库。以下是一些可用且免费使用的库：
- en: '**DexieJS** ([https://dexie.org/](https://dexie.org/)): A very fast and well-documented
    library that implements a NoSQL document-based database.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DexieJS** ([https://dexie.org/](https://dexie.org/))：一个非常快且文档齐全的库，实现了基于NoSQL的文档数据库。'
- en: '**PouchDB** ([https://pouchdb.com/](https://pouchdb.com/)): A database that
    mimics the functionality of Apache’s CouchDB and provides built-in synchronization
    with remote servers.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PouchDB** ([https://pouchdb.com/](https://pouchdb.com/))：一个模仿Apache CouchDB功能的数据库，并提供与远程服务器的内置同步。'
- en: '**RxDB** ([https://rxdb.info/](https://rxdb.info/)): This is a database that
    implements the reactive model. It also supports replication to CouchDB.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RxDB** ([https://rxdb.info/](https://rxdb.info/))：这是一个实现了响应式模型的数据库。它还支持与CouchDB的复制。'
- en: '**IDB** ([https://www.npmjs.com/package/idb](https://www.npmjs.com/package/idb)):
    This is a light wrapper implementation on top of the IndexedDB API, with some
    changes to improve its usability.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDB** ([https://www.npmjs.com/package/idb](https://www.npmjs.com/package/idb))：这是在IndexedDB
    API之上实现的一个轻量级包装实现，进行了一些改进以提高其可用性。'
- en: 'Depending on your requirements for local storage, these or other options will
    suit you well. We will use DexieJS for this example as it is well documented and
    boasts impressive speeds for bulk operations. We will expand our previous example
    and create a single-component mini-application to store, retrieve, delete, and
    view notes. This covers very basic **create, read, update, and delete** (**CRUD**)
    operations. When you run the example code, it will look something like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您对本地存储的要求，这些或其他选项将非常适合您。我们将使用DexieJS作为此示例，因为它有很好的文档记录，并且在批量操作方面速度惊人。我们将扩展我们之前的示例，创建一个单组件迷你应用程序来存储、检索、删除和查看笔记。这涵盖了非常基础的**创建、读取、更新和删除**（**CRUD**）操作。当您运行示例代码时，它看起来可能像这样：
- en: '![Figure 8.7 – A single-component CRUD example](img/Figure_8.07_B18602.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 单组件CRUD示例](img/Figure_8.07_B18602.jpg)'
- en: Figure 8.7 – A single-component CRUD example
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 单组件CRUD示例
- en: 'In this example, you can create new notes, view what was saved before (this
    will be persistent based on the domain), select them to view the text, and also
    delete them. All the operations will be resolved in the web worker. Let’s include
    Dexie in our application using `npm`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您可以创建新的笔记，查看之前保存的内容（这将基于域名持久化），选择它们以查看文本，还可以删除它们。所有操作都将由Web Worker解决。让我们使用`npm`将Dexie包含到我们的应用程序中：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let’s create our example component application:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的示例组件应用程序：
- en: /src/components/DbNotes.vue
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: /src/components/DbNotes.vue
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding file has been stripped of styles and other layout elements, so
    we can focus on the active parts of the code that implement the operations we
    are learning about. We start by importing our service class to handle the web
    worker in line *//1* and create a few internal reactive variables in line *//2*.
    We will use `_notes` to hold the full list of notes as extracted from the database,
    `_note` as a placeholder to create new notes, and `_selected` to display a note
    clicked on from the list. You can find the CRUD operations in each function (lines
    *//3* to *//6)* and will notice that they are very similar other than handling
    UI reactive elements. They just gather the necessary information to create a request
    to the web worker and then apply the result. However, notice how in the `saveNote()`
    function, when it is time to pass the object that describes our new note, we are
    stringifying the Vue reactive value. This is because the proxy implementation
    that Vue uses to handle reactivity is not serializable, so unless we create a
    copy of the plain object or apply other similar techniques to extract the values,
    the web worker communication will fail and throw an error. An easy way to make
    sure the data object is provided as a clonable object is to convert it into a
    string with `JSON.stringify(_note.value)` as in our code (you could also create
    directly a clone, with `JSON.parse(JSON.stringify(_note.value))`. You need to
    keep in mind how the information will be sent so that it can be properly processed
    at the receiving end of the web worker. This will become apparent now when we
    see `dbService.js` in the worker:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件已经去除了样式和其他布局元素，这样我们就可以专注于实现我们所学习操作的代码的活跃部分。我们首先在第*//1*行导入我们的服务类以处理web worker，并在第*//2*行创建一些内部反应性变量。我们将使用`_notes`来保存从数据库中提取的完整笔记列表，`_note`作为创建新笔记的占位符，以及`_selected`来显示从列表中点击的笔记。你可以在每个函数（第*//3*到*//6*行）中找到CRUD操作，并且你会注意到除了处理UI反应性元素之外，它们非常相似。它们只是收集创建对web
    worker请求所需的信息，然后应用结果。然而，请注意，在`saveNote()`函数中，当需要传递描述我们新笔记的对象时，我们正在将Vue反应值序列化。这是因为Vue用于处理反应性的代理实现不可序列化，除非我们创建一个纯对象的副本或应用其他类似技术来提取值，否则web
    worker通信将失败并抛出错误。确保数据对象作为可克隆对象提供的简单方法是将其转换为字符串，如我们的代码中所示使用`JSON.stringify(_note.value)`（你也可以直接创建一个克隆，使用`JSON.parse(JSON.stringify(_note.value))`）。你需要记住信息将如何发送，以便在web
    worker接收端得到适当的处理。现在当我们看到`dbService.js`在worker中时，这一点将变得明显：
- en: ./src/webworker/services/dbService.js
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ./src/webworker/services/dbService.js
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To use Dexie, we first import the constructor as in line *//1*, and we create
    a new database with the name `Notes`. Before we can actually use it, we need to
    define the version and a simple schema of tables/collections with the fields that
    will be indexed. This is what happens in line *//2*, where we define the `notes`
    collection with two indexed fields: `id` and `title`. These indexed fields are
    passed as a string, comma-separated by field names. We also included a double
    plus sign as a prefix for the `id` field. This makes the field auto-generated
    by the database and auto-incremented with each new record.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Dexie，我们首先在第*//1*行导入构造函数，并创建一个名为`Notes`的新数据库。在我们实际使用它之前，我们需要定义版本和表格/集合的简单模式，包括将要索引的字段。这就是第*//2*行发生的事情，在那里我们定义了具有两个索引字段`id`和`title`的`notes`集合。这些索引字段以字符串形式传递，字段名以逗号分隔。我们还为`id`字段包含了一个双加号作为前缀。这使得该字段由数据库自动生成并随着每个新记录自动递增。
- en: The next significant function, `addNote()`, adds the record to the `notes` collection.
    Since we are passing data serializing an object as a string in our component,
    in line *//4*, we need to parse the string to recompose the object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的函数`addNote()`，将记录添加到`notes`集合中。由于我们在组件中通过将对象序列化为字符串传递数据，在第*//4*行，我们需要解析字符串以重新组合对象。
- en: In the `getNotes()` function, we just retrieve all the elements from the collection
    and use the `toArray()` method provided by Dexie, which will convert it into a
    JavaScript array (line *//5*). This way, we can return it directly as our result
    to resolve the promise.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getNotes()`函数中，我们只是从集合中检索所有元素，并使用Dexie提供的`toArray()`方法将其转换为JavaScript数组（第*//5*行）。这样，我们可以直接将其作为我们的结果返回以解决承诺。
- en: 'A final note on this code is on the `deleteNote()` method: on line *//6*, we
    are not capturing the result of the asynchronous operation. This is because this
    operation does not return a usable value. In this case, this operation will always
    resolve unless a database engine error interrupts the execution.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这段代码的最后一句话是关于 `deleteNote()` 方法的：在第 *//6* 行，我们没有捕获异步操作的结果。这是因为这个操作不返回可用的值。在这种情况下，这个操作总是会解析，除非数据库引擎错误中断执行。
- en: It is important to keep in mind that errors on the web worker will not affect
    the parent process, and any operations in that process will be unaffected.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，Web Worker 上的错误不会影响父进程，并且该进程中的任何操作都不会受到影响。
- en: 'Now that we have our service in place, it is time to slightly modify the web
    worker index file. Add the following lines:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了服务，是时候稍微修改一下 web worker 的索引文件了。添加以下行：
- en: ./src/webworker/index.js
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ./src/webworker/index.js
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: No other change is necessary for this file. As we can see, it does not take
    much to implement CRUD operations on the web worker. Even though these can be
    done in the parent process, and there is a small penalty from the interprocess
    communication, the benefits in performance are considerable and well worth the
    effort. Especially if our application includes what should be background processes,
    such as synchronization with a remote server, these should be done by a web worker.
    Let’s see next how we can access the network and consume a **Representational
    State Transfer API** (**RESTful API**) from a worker as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此文件，无需进行其他更改。正如我们所看到的，在 web worker 上实现 CRUD 操作并不需要太多。尽管这些可以在父进程中完成，并且会有轻微的进程间通信的代价，但性能上的好处是相当可观的，并且值得付出努力。特别是如果我们的应用程序包括应该作为后台进程的内容，比如与远程服务器的同步，这些应该由
    web worker 完成。让我们看看接下来我们如何从 worker 访问网络并消费 **表示状态转换 API**（**RESTful API**）。
- en: Consuming a RESTful API with the web worker
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Web Worker 消费 RESTful API
- en: 'One of the most common applications of network APIs today in web development
    is through the implementation of a RESTful API. It is a protocol where each communication
    is stateless and representative of the type of action required at the destination.
    The HTTP protocol used on the web provides a perfect match for this type of API,
    as each network call exposes a method that identifies the type of operation required:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 今天在 Web 开发中，网络 API 最常见的应用之一是通过实现 RESTful API。这是一个无状态的协议，每个通信都代表了在目的地所需操作的类型。Web
    上使用的 HTTP 协议为这种类型的 API 提供了完美的匹配，因为每个网络调用都暴露了一个标识所需操作类型的方法：
- en: The `GET` operations retrieve data and files
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` 操作检索数据和文件'
- en: The `PUT` operations update data
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` 操作更新数据'
- en: The `POST` operations create new data on the server
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` 操作在服务器上创建新数据'
- en: The `DELETE` operations erase data on the server
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` 操作在服务器上擦除数据'
- en: It is easy to see how these methods match CRUD operations, so by making the
    appropriate network call, the server knows how to process the data received at
    the proper endpoint. There are many standards used to format the data sent between
    endpoints. In particular, one of the most common ones is the JSON format, which
    we so conveniently use in JavaScript.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出这些方法与 CRUD 操作相匹配，因此通过进行适当的网络调用，服务器就知道如何处理在正确端点接收到的数据。在端点之间发送的数据格式有许多标准。特别是其中最常见的一种是
    JSON 格式，我们在 JavaScript 中非常方便地使用它。
- en: 'Handling asynchronous calls with the native implementation in the browser is,
    at the very least, cumbersome but not impossible. The recommendation, for practicality
    and security, is to use a well-known library such as **Axios**. To install the
    library, we need to run the following command from the terminal:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中使用原生实现处理异步调用，至少是繁琐的，但并非不可能。出于实用性和安全性的考虑，建议使用像 **Axios** 这样的知名库。要安装库，我们需要从终端运行以下命令：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After a few moments, the library will be installed into our project as a dependency.
    The library provides very handy methods to launch network calls for each HTTP
    method. For example, `axios.get` makes a `GET` request, `axios.post` makes a `POST`
    request, and so forth.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，库将作为依赖项安装到我们的项目中。该库提供了非常方便的方法来为每个 HTTP 方法发起网络调用。例如，`axios.get` 发起 `GET`
    请求，`axios.post` 发起 `POST` 请求，依此类推。
- en: 'We will implement a simple service for our learning exercise to make network
    calls to a remote server from within our web worker. For simplicity, we will only
    create two methods:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的学习练习实现一个简单的服务，以便在我们的 web worker 中从远程服务器进行网络调用。为了简单起见，我们只会创建两个方法：
- en: ./webworker/services/network.js
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ./webworker/services/network.js
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This service is rather simple. In a production application, it would be middleware
    to serve other services. This example implements only two methods to match the
    corresponding HTTP request methods. Notice that they are extremely similar, only
    changing the name of the method and the signature for some of the parameters.
    The first parameter is always the endpoint (URI) to connect. The second parameter
    is either data or an object with options. I refer you to the official documentation
    for how to handle each specific request and handle edge cases ([https://axios-http.com/docs/intro](https://axios-http.com/docs/intro)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务相当简单。在生产应用中，它将是服务于其他服务的中间件。此示例仅实现了两种方法来匹配相应的HTTP请求方法。请注意，它们非常相似，只是更改了方法名称和一些参数的签名。第一个参数始终是连接的端点（URI）。第二个参数是数据或包含选项的对象。我建议您参考官方文档了解如何处理每个具体的请求和处理边缘情况（[https://axios-http.com/docs/intro](https://axios-http.com/docs/intro)）。
- en: It is worth noting that at the beginning of the file, we set the default domain
    for all other network calls. This way, we avoid repeating it in each call. We
    can easily set specific HTTP headers and options with this library, such as **JSON
    Web Tokens**, for authentication, as we covered in [*Chapter 5*](B18602_05.xhtml#_idTextAnchor130),
    *Single-Page Applications*, when we mentioned different authentication methods.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在文件的开头，我们为所有其他网络调用设置了默认域名。这样，我们就可以避免在每个调用中重复设置。我们可以使用这个库轻松地设置特定的HTTP头和选项，例如**JSON
    Web Tokens**，用于身份验证，正如我们在[*第五章*](B18602_05.xhtml#_idTextAnchor130)，“单页应用”，提到不同的身份验证方法时所述。
- en: 'To include this service in our web worker, we import it and add it to our `services`
    array as we did before. Modify the beginning of this file so it looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此服务包含在我们的web worker中，我们导入它并将其添加到我们之前使用的`services`数组中。修改此文件的开头，使其看起来像这样：
- en: ./webworker/index.js
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ./webworker/index.js
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With this new inclusion, our web worker is now ready. We now implement a single
    component to test the communication, and it will look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个新添加的功能，我们的web worker现在已准备就绪。我们现在实现一个单独的组件来测试通信，它看起来像这样：
- en: '![Figure 8.8 – A simple test, where the server mirrors back the information
    sent](img/Figure_8.08_B18602.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 一个简单的测试，其中服务器返回发送的信息](img/Figure_8.08_B18602.jpg)'
- en: Figure 8.8 – A simple test, where the server mirrors back the information sent
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 一个简单的测试，其中服务器返回发送的信息
- en: 'Our component will let us select the method for the HTTP request (`GET` or
    `POST`) and will send some arbitrary data. The test server will just mirror the
    data received back to the client, where the component will present it on the screen.
    The implementation is quite straightforward:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件将允许我们选择HTTP请求的方法（`GET`或`POST`）并发送一些任意数据。测试服务器将仅将接收到的数据返回给客户端，组件将在屏幕上展示这些数据。实现相当直接：
- en: ./src/components/NetworkCommunication.vue
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ./src/components/NetworkCommunication.vue
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this component, we import the `webWorker` service and declare three reactive
    variables to send and receive data and one to hold the selected method to make
    the request. Our simple test server will receive the request and will just mirror
    back the data that we submit. We will see later how to create this simple server
    using Node.js.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，我们导入`webWorker`服务并声明三个响应式变量用于发送和接收数据，以及一个用于保存所选方法的请求。我们的简单测试服务器将接收请求并将我们提交的数据返回。我们将在后面看到如何使用Node.js创建这个简单服务器。
- en: In the template, the user can choose the type of request to send (`GET` or `POST`),
    a choice that we save in the `_method` variable. We use this value as the command
    passed to the worker in line *//1*. We pass the data as a member object as a payload.
    When this promise resolves, we save the value from the reply in the `_data_received`
    variable. The rest of the source code should be trivial to understand at this
    point, as it deals mainly with the template and presentation of the information
    on the screen. Before we end this chapter, let’s take a look a how the test server
    can be implemented using Node.js.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，用户可以选择要发送的请求类型（`GET`或`POST`），我们将这个选择保存在`_method`变量中。我们使用这个值作为传递给工作线程的命令（在行*//1*）。我们将数据作为成员对象作为有效载荷传递。当这个承诺解决时，我们将回复中的值保存到`_data_received`变量中。在此阶段，源代码的其他部分应该很容易理解，因为它主要涉及模板和信息在屏幕上的展示。在我们结束这一章之前，让我们看看如何使用Node.js实现测试服务器。
- en: A simple NodeJS server for testing
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的NodeJS服务器用于测试
- en: 'To test our network communications, it seems fitting that we implement a small
    server using Node.js to implement the endpoints that we are testing. In a separate
    directory from our Vue application, open a terminal window and enter the following
    command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的网络通信，似乎使用Node.js实现端点以测试我们正在测试的内容是合适的。在我们的Vue应用程序的单独目录中，打开一个终端窗口并输入以下命令：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The command-line wizard will ask you a few questions to create the `package.json`
    file that represents a Node.js application. When it is done, run this command
    to install the **Express.js** dependency, which will give us a framework to create
    a web server:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行向导会问你一些问题来创建代表Node.js应用程序的`package.json`文件。完成后，运行以下命令来安装**Express.js**依赖项，这将为我们提供一个创建Web服务器的框架：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the process completes, create an `index.js` file with the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦过程完成，创建一个包含以下代码的`index.js`文件：
- en: ./server/index.js
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ./server/index.js
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With these few lines of code, we can start a small server that receives and
    responds with JSON data. We import the express constructor (line *//1*), and a
    plugin (line *//2*). This is important so that we can access this server from
    any domain (origin). The `GET` requests (line *//6*) and another one for a `POST`
    request. The first parameter is the URL where the server will be listening for
    calls. In this case, they are the same, as the only difference will be the type
    of request method. This is standard practice.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这几行代码，我们可以启动一个小型服务器，该服务器接收并响应JSON数据。我们导入express构造函数（第*//1*行），以及一个插件（第*//2*行）。这样做很重要，这样我们才能从任何域名（源）访问这个服务器。`GET`请求（第*//6*行）和另一个用于`POST`请求。第一个参数是服务器将监听调用的URL。在这种情况下，它们是相同的，因为唯一的区别将是请求方法的类型。这是标准做法。
- en: 'Each endpoint receives as the last argument a callback function with at least
    two parameters: `req` (request) and `res` (response). These objects contain methods
    and information about the request received and the necessary methods to create
    a response to the client.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个端点作为最后一个参数接收一个至少包含两个参数的回调函数：`req`（请求）和`res`（响应）。这些对象包含关于接收到的请求和创建对客户端响应所需的方法和信息。
- en: For the `GET` requests, the data received is passed attached to the URL as a
    “query string”, so in order to access it, *Express* wraps it nicely as an object
    in the `request.query` field (line *//7*). Since we are just replying with the
    same data received, in line *//8*, we use the `res`(ponse) object to create a
    padded JSON reply with the same data object. We do this because we consider that
    we could receive calls from any domain (because we enabled CORS) and want to ensure
    the reply is fully understood. **JSON with Padding** (**JSONP**) is a method to
    send the response using a different method. We don’t need to worry about this,
    as both ends (sender and receiver) are handled by the Express server and the Axios
    client.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`GET`请求，接收到的数据作为“查询字符串”附加到URL上，因此为了访问它，*Express*将其优雅地包装在`request.query`字段中的对象（第*//7*行）。由于我们只是回复接收到的相同数据，在第*//8*行，我们使用`res`(ponse)对象创建一个带有相同数据对象的填充JSON回复。我们这样做是因为我们认为我们可能会从任何域名（因为我们启用了CORS）接收调用，并确保回复被完全理解。**带有填充的JSON**（**JSONP**）是使用不同方法发送响应的方法。我们不需要担心这一点，因为两端（发送者和接收者）都由Express服务器和Axios客户端处理。
- en: In the `post` method, the difference is that the data is contained in the body
    of the message (line *//9*), hence the different treatment. Finally, the server
    starts listening on the designated port (line *//10*). We can now access the server
    at [http://localhost:3000](http://localhost:3000), which is the address that we
    configured in our network service as the default for Axios.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`post`方法中，区别在于数据包含在消息体中（第*//9*行），因此有不同的处理方式。最后，服务器开始在指定的端口上监听（第*//10*行）。现在我们可以通过[http://localhost:3000](http://localhost:3000)访问服务器，这是我们配置在网络服务中作为Axios默认地址的地址。
- en: With the implementation of this server, we can now have a full test of all the
    parts of the system.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现这个服务器，我们现在可以对系统的所有部分进行全面测试。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed some very important concepts to fundamentally improve
    the architecture and performance of our application. Web workers is an amazing
    technology that allows web applications to take advantage of modern hardware architectures
    and modern operating systems. From a fixed point of view, multithreading using
    web workers involves little additional effort and complications, and the gains
    are highly rewarding. We also saw how to make use of workers to access network
    services as well as the local persistent database provided by the browser (IndexedDB).
    We learned about two more design patterns to implement a scalable architecture
    for our application and tested the concepts and implementations through simple
    components and services. The use of web workers marks a significant difference
    in the performance and execution of a well-designed web application. In the next
    chapter, we will look into tools and techniques to test our code automatically,
    ensuring the individual parts comply with their intended purpose to match our
    software specifications and requirements.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了一些非常重要的概念，这些概念可以从根本上提高我们应用程序的架构和性能。网络工作者是一项惊人的技术，它允许网络应用程序利用现代硬件架构和现代操作系统。从固定点的角度来看，使用网络工作者进行多线程涉及很少的额外努力和复杂性，而且收益是高度可观的。我们还看到了如何利用工作者来访问网络服务以及浏览器提供的本地持久数据库（IndexedDB）。我们学习了两种更多设计模式来实现我们应用程序的可扩展架构，并通过简单的组件和服务测试了这些概念和实现。使用网络工作者在性能和执行方面为精心设计的网络应用程序带来了显著差异。在下一章中，我们将探讨工具和技术来自动测试我们的代码，确保各个部分符合其预期目的，以匹配我们的软件规范和需求。
- en: Review questions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: What limitations does JavaScript have that can compromise the performance of
    a web application?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript有哪些限制可能会损害网络应用程序的性能？
- en: What are web workers? What are their limitations?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络工作者是什么？它们的限制是什么？
- en: How can Vue applications communicate with web workers?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue应用程序如何与网络工作者通信？
- en: What are the benefits of using a design pattern such as the Business Delegate
    to work with web workers?
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像业务代表（Business Delegate）这样的设计模式与网络工作者（web workers）一起工作的好处是什么？
- en: What can you change in the example code to manage multiple web workers instead
    of just one? When would this be advisable, in your opinion?
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在示例代码中做哪些更改来管理多个网络工作者而不是一个？在你看来，何时这样做是可取的？
