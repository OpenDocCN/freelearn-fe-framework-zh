- en: 5\. Global Component Composition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 全局组件组合
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to reduce duplication in your Vue.js application
    code using global abstractions, new composition models, and new types of components.
    You will experiment with Vue.js **mixins**, **plugins**, and new types of components
    and ways of composing them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用全局抽象、新的组合模型和新的组件类型来减少你的Vue.js应用程序代码中的重复。你将实验Vue.js的**混合**、**插件**和新的组件类型以及它们的组合方式。
- en: By the end of this chapter, you will be able to identify situations where **mixins**
    and **plugins** can be used to achieve global composition and keep code **DRY**
    (**don't repeat yourself**) in a Vue.js application, as well as how to define
    global components, functional components, and components in non-Vue files. You
    will also be able to contrast the advantages and drawbacks of global composition
    and select the right abstraction to maximize component flexibility.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够识别在Vue.js应用程序中使用**混合**和**插件**以实现全局组合并保持代码DRY（不要重复自己）的情况，以及如何定义全局组件、功能组件和非Vue文件中的组件。你还将能够对比全局组合的优点和缺点，并选择正确的抽象以最大化组件的灵活性。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Component nesting is an approach to composition where the application is built
    up from smaller units (components). The application can be thought of as components
    fitting within each other. In this scenario, any shared functionality will be
    provided through components. Vue.js provides other methods of composition.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 组件嵌套是一种组合方法，其中应用程序由更小的单元（组件）构建而成。应用程序可以被视为组件相互嵌套。在这种情况下，任何共享功能将通过组件提供。Vue.js提供了其他组合方法。
- en: Component-based composition can be very verbose and will mean we repeat imports
    wherever a certain piece of functionality is needed. This does not follow the
    DRY principle. To avoid this duplication and verbosity, we can globally register
    `import MyComponent from ...` in every consumer of `MyComponent`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的组合可能会非常冗长，这意味着我们会在需要某个特定功能的地方重复导入。这不符合DRY原则。为了避免这种重复和冗长，我们可以在`MyComponent`的每个消费者中全局注册`import
    MyComponent from ...`。
- en: Much in the same way, applications can be built from different types of primitives
    (mixins, plugins, and components). For maximum flexibility, components can be
    defined in different ways beyond Vue.js single-file component files (`.vue` files).
    In this category, we have the case of functional components, as well as components
    defined with `render` functions. Each of these types of components has some advantages
    and drawbacks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，应用程序也可以由不同类型的原语（混合、插件和组件）构建而成。为了最大灵活性，组件可以以不同的方式定义，而不仅仅是Vue.js的单文件组件文件（`.vue`文件）。在这个类别中，我们有功能组件以及使用`render`函数定义的组件。每种类型的组件都有其优点和缺点。
- en: To keep code DRY, a component should be easy to use and extend. This chapter
    will look at a few tips that we can follow to make a component more reusable,
    thereby making the application more DRY.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码DRY（Don't Repeat Yourself），组件应该易于使用和扩展。本章将探讨一些我们可以遵循的技巧，以使组件更具可重用性，从而使应用程序更加DRY。
- en: Mixins
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合
- en: 'Mixins can add methods, properties, and default life cycle methods to components
    that consume them. In the following example, we are defining a mixin that adds
    a `greet` method and a `greeting` field to the component''s `data` function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 混合可以为使用它们的组件添加方法、属性和默认的生命周期方法。在下面的示例中，我们正在定义一个混合，它向组件的`data`函数添加一个`greet`方法和一个`greeting`字段：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Mixins allow multiple components' shared functionality to be defined independently.
    They are used through a `mixins` component property, which accepts an array.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 混合（Mixins）允许独立定义多个组件的共享功能。它们通过一个`mixins`组件属性来使用，该属性接受一个数组。
- en: In the `App.vue` file, we can consume the mixin by setting the component's `mixins` property.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.vue`文件中，我们可以通过设置组件的`mixins`属性来使用混合。
- en: 'The properties and methods of the mixin are then available in the component
    (just as they would be if they were defined in the component itself):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 混合的属性和方法随后将在组件中可用（就像它们在组件本身中定义一样）：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This displays the following message in the browser:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在浏览器中显示以下消息：
- en: '![Figure 5.1: Hello World using a greeter mixin'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1：使用greeter混合的Hello World'
- en: '](img/B15218_05_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_05_01.jpg]'
- en: 'Figure 5.1: Hello World using a greeter mixin'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：使用greeter混合的Hello World
- en: When there is a conflict, in terms of instance properties or methods that are
    named the same, between the component and the mixin, the component wins. This
    can be thought of as the component adopting mixin behavior by default unless said
    component declares the same instance property or method. In this case, instance
    access that is defined in the mixin would access the component's instance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件和混合器在实例属性或方法名称相同的情况下发生冲突时，组件获胜。这可以理解为组件默认采用混合器行为，除非该组件声明了相同的实例属性或方法。在这种情况下，混合器中定义的实例访问将访问组件的实例。
- en: 'For example, let''s add a `data()` initializer to our `App` component that
    has `greeting` set to `Hi`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们向具有`greeting`设置为`Hi`的`App`组件添加一个`data()`初始化器：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The mixin defines a `data` method, but so does the component. In this case,
    the component *wins*, hence why the greeting displayed is `Hi` (as defined in
    the component) instead of `Hello` (as defined in the mixin), as displayed in the
    following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 混合器定义了一个`data`方法，但组件也定义了。在这种情况下，组件获胜，因此显示的问候语是`Hi`（在组件中定义），而不是`Hello`（在混合器中定义），如下所示：
- en: '![Figure 5.2: Hi World using a greeter mixin with overridden data'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：使用重写数据的greeter mixin实现的Hi World]'
- en: '](img/B15218_05_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B15218_05_02.jpg]'
- en: 'Figure 5.2: Hi World using a greeter mixin with overridden data'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：使用重写数据的greeter mixin实现的Hi World
- en: Note that when the component does not define a `data` method, the mixin's implementation
    is used but the component "wins" if both the mixin and the component define it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当组件没有定义`data`方法时，将使用混合器的实现，但如果混合器和组件都定义了它，组件将获胜。
- en: Vue.js life cycle hooks are prime candidates to be extracted into mixins. The
    life cycle hooks we can use are (in order of execution) `beforeCreated`, `created`,
    `beforeMount`, `mounted`, `beforeUpdate`, `updated`, `beforeDestroy`, and `destroyed`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js生命周期钩子是提取到混合器的首选候选者。我们可以使用的生命周期钩子（按执行顺序）是`beforeCreated`、`created`、`beforeMount`、`mounted`、`beforeUpdate`、`updated`、`beforeDestroy`和`destroyed`。
- en: Life cycle hooks are an exception to the mixin/component conflict resolution
    rule mentioned previously. In the case of Vue.js life cycle hooks functions, for
    each mixin, component, and hook, the hook functions are all executed in the order
    of mixins first (in order of addition to the component), component last.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期钩子是之前提到的混合器/组件冲突解决规则的例外。在Vue.js生命周期钩子函数的情况下，对于每个混合器、组件和钩子，钩子函数都是按照混合器的顺序（按添加到组件的顺序）首先执行，组件最后执行。
- en: 'We can see this in action in the following example. Let''s create two mixins
    that implement the `mounted` life cycle hook and implement that hook in the component.
    This illustrates the case of life cycle hooks for mixin/component conflict resolution:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下示例中看到这一点。让我们创建两个实现`mounted`生命周期钩子的混合器，并在组件中实现该钩子。这说明了混合器/组件冲突解决的案例：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The browser console output for this component will be (in order) `First mixin
    mounted hook`, `Second mixin mounted hook`, and `Component mounted hook`, as shown
    in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件的浏览器控制台输出（按顺序）将是`First mixin mounted hook`、`Second mixin mounted hook`和`Component
    mounted hook`，如下所示：
- en: '![Figure 5.3: Browser console output showing the hooks defined in the mixins
    that were executed before the component hooks'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3：显示在组件钩子之前执行的混合器中定义的钩子的浏览器控制台输出]'
- en: '](img/B15218_05_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B15218_05_03.jpg]'
- en: 'Figure 5.3: Browser console output showing the hooks defined in the mixins
    that were executed before the component hooks'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：显示在组件钩子之前执行的混合器中定义的钩子的浏览器控制台输出
- en: All the examples we have seen have used mixins directly to inject functionality
    into components. Mixins can also be created globally by using a `Vue.mixin` function
    call.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所看到的所有示例都直接使用混合器将功能注入到组件中。混合器也可以通过使用`Vue.mixin`函数调用全局创建。
- en: 'We can, for example, make our greeting function a global instance method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使我们的问候函数成为全局实例方法：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`this.$greet` will now be available on all Vue instances declared after the
    `Vue.mixin` call. This use case, however, is better served by a plugin.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.$greet`现在将在`Vue.mixin`调用之后声明的所有Vue实例上可用。然而，此用例最好通过插件来实现。'
- en: Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `$methodName` convention is used in Vue.js for methods that are provided
    by the Vue.js application instance (as opposed to the current component instance).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js中用于由Vue.js应用程序实例提供的方法（而不是当前组件实例）的约定是`$methodName`。
- en: 'Exercise 5.01: Creating Your Own Mixin'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.01：创建自己的混合器
- en: In this exercise, we will create a mixin called `debug` that will return the
    JSON-stringified representation of the input it has been passed. `debug` do what
    is called pretty-printing so that we can read it more easily.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个名为 `debug` 的混入，它将返回传入输入的 JSON 字符串表示形式。`debug` 执行所谓的漂亮打印，以便我们可以更容易地阅读它。
- en: This can also be useful for printing data inside HTML when debugging a Vue.js
    application in a situation where Vue.js DevTools are not available or reliable.
    To access the code files for this exercise, refer to [https://packt.live/38ivgFq](https://packt.live/38ivgFq).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这在调试 Vue.js 应用程序时也可能很有用，尤其是在 Vue.js DevTools 不可用或不可靠的情况下打印数据。要访问此练习的代码文件，请参阅
    [https://packt.live/38ivgFq](https://packt.live/38ivgFq)。
- en: We will start with a clean Vue CLI project (this can be created with the `vue
    new exercise5.01` command). The application in the Vue CLI project can be started
    with `npm run serve`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个干净的 Vue CLI 项目开始（这可以通过 `vue new exercise5.01` 命令创建）。Vue CLI 项目中的应用程序可以通过
    `npm run serve` 启动。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'Create a new `src/mixins` folder and a `src/mixins/debug.js` file where we
    will define the skeleton of our mixin:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/mixins` 文件夹和一个 `src/mixins/debug.js` 文件，我们将在这里定义混入的框架：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The mixin will add a `debug` method, which we should define under `methods`.
    The `debug` method will take an `obj` parameter and return the output of `JSON.stringify`
    for that data. We will use `JSON.stringify(obj, null, 2)` to output two-space
    pretty-printed JSON:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 混入将添加一个 `debug` 方法，我们应该在 `methods` 下定义它。`debug` 方法将接受一个 `obj` 参数，并返回该数据的 `JSON.stringify`
    输出。我们将使用 `JSON.stringify(obj, null, 2)` 来输出两空格缩进的漂亮打印 JSON：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We are now able to import the `debug` mixin from `src/App.vue` and register
    it under the `mixins` property:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在能够从 `src/App.vue` 导入 `debug` 混入，并在 `mixins` 属性下注册它：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To see the `debug` method in action, we will add a `data` method and a `created`
    hook (from which we can print the output of `debug`) in the `src/App.vue` file:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看 `debug` 方法的实际效果，我们将在 `src/App.vue` 文件中添加一个 `data` 方法和一个 `created` 钩子（从中我们可以打印
    `debug` 的输出）：
- en: '[PRE8]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should get the following output:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.4: Browser console output due to the created hook'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.4：由于创建钩子而产生的浏览器控制台输出]'
- en: '](img/B15218_05_04.jpg)'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_04.jpg]'
- en: 'Figure 5.4: Browser console output due to the created hook'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.4：由于创建钩子而产生的浏览器控制台输出]'
- en: '`debug` is also available in the template; we can interpolate its output in
    a `pre` tag so that whitespace is respected:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`debug` 也在模板中可用；我们可以在 `pre` 标签中插入其输出，以便尊重空白字符：'
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The application, as well as this template, will look as follows:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序以及此模板将如下所示：
- en: '![Figure 5.5: Browser printing myObj using the debug method from the mixin'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.5：使用混入的 debug 方法打印 myObj]'
- en: '](img/B15218_05_05.jpg)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_05.jpg]'
- en: 'Figure 5.5: Browser printing myObj using the debug method from the mixin'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5：使用混入的 debug 方法打印 myObj]'
- en: With that, we have learned how mixins can be used to inject shared functionality
    into multiple components in a manner that is quite explicit (a `mixins` property).
    We also got a chance to see what happens when a component's implementation overwrites
    properties and methods provided by the mixin (the component usually wins).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们学习了如何使用混入以相当明确的方式（`mixins` 属性）将共享功能注入到多个组件中。我们还看到了当组件的实现覆盖了混入提供的属性和方法时会发生什么（组件通常获胜）。
- en: We will now look at how to inject instance and global functionality and distribute
    it through plugins.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何注入实例和全局功能，并通过插件进行分发。
- en: Plugins
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件
- en: Vue.js plugins are a way to add custom functionality to Vue.js globally. Good
    candidates for plugins are core to the application and used widely. Classic examples
    of plugin candidates are translation/internationalization libraries (such as `i18n-next`)
    and HTTP clients (such as the `axios`, `fetch`, and `GraphQL` clients). The plugin
    initializer has access to the `Vue` instance, so it can be a good way to wrap
    global directive, mixin, component, and filter definitions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 插件是一种向 Vue.js 全局添加自定义功能的方法。插件的良好候选者通常是应用程序的核心，并且被广泛使用。插件候选者的经典例子包括翻译/国际化库（例如
    `i18n-next`）和 HTTP 客户端（例如 `axios`、`fetch` 和 `GraphQL` 客户端）。插件初始化器可以访问 `Vue` 实例，因此它是一个很好的方式来包装全局指令、混入、组件和过滤器定义。
- en: Plugins can inject functionality by registering directives and filters. They
    can also add `global` and `instance` Vue.js methods, as well as defining global
    component mixins.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 插件可以通过注册指令和过滤器来注入功能。它们还可以添加 `global` 和 `instance` Vue.js 方法，以及定义全局组件混入。
- en: 'A Vue.js plugin is an object that exposes an `install` method. The `install`
    function is called with `Vue` and `options`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 插件是一个暴露 `install` 方法的对象。`install` 函数使用 `Vue` 和 `options` 调用：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Within the `install` method, we can register directives, filters, and mixins
    and add global and instance properties and methods:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `install` 方法中，我们可以注册指令、过滤器、混入，并添加全局和实例属性和方法：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Plugins are registered using the `Vue.use` method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 插件使用 `Vue.use` 方法进行注册：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Vue.use` can also be passed options as the second argument. These options
    are passed to the plugin:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vue.use` 也可以将选项作为第二个参数传递。这些选项传递给插件：'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One of the features of `Vue.use` is that it does not allow you to register the
    same plugin twice. This is a nice feature that avoids edge case behavior when
    attempting to instantiate or install the same plugin multiple times.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vue.use` 的一个特性是不允许你注册相同的插件两次。这是一个很好的特性，可以避免在尝试多次实例化或安装相同插件时出现的边缘情况行为。'
- en: A popular HTTP client to use in combination with Vue.js is `axios`. It is common
    to configure `axios` with interceptors or `axios` options to achieve things such
    as retries, passing cookies, or following redirects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 Vue.js 结合使用时，`axios` 是一个流行的 HTTP 客户端。通常，我们会通过拦截器或 `axios` 选项来配置 `axios`，以实现重试、传递
    cookies 或跟随重定向等功能。
- en: '`axios` can be installed using: `npm install –save axios`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令安装 `axios`：`npm install –save axios`。
- en: 'Exercise 5.02: Creating a Custom Axios Plugin'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.02：创建自定义 Axios 插件
- en: In order to avoid having to add `import axios from 'axios'` or having to wrap
    our custom `axios` instance under an `http` or `transport` internal module, we'll
    inject our custom `axios` instance into the Vue object and Vue component instances
    under `Vue.axios` and `this.axios`. This will make it easier and more ergonomic
    to use in our application, which needs to call out to an API using `axios` as
    the HTTP client. To access the code files for this exercise, refer to [https://packt.live/36po08b](https://packt.live/36po08b).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免必须添加 `import axios from 'axios'` 或将我们的自定义 `axios` 实例包装在 `http` 或 `transport`
    内部模块下，我们将我们的自定义 `axios` 实例注入到 Vue 对象和 Vue 组件实例的 `Vue.axios` 和 `this.axios` 下。这将使它在我们的应用程序中使用，该应用程序需要使用
    `axios` 作为 HTTP 客户端调用 API，变得更加容易和舒适。要访问此练习的代码文件，请参阅 [https://packt.live/36po08b](https://packt.live/36po08b)。
- en: We will start with a clean Vue CLI project (this can be created with the `vue
    new exercise5.02` command). The application in the Vue CLI project can be started
    with `npm run serve`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个干净的 Vue CLI 项目开始（可以使用 `vue new exercise5.02` 命令创建）。Vue CLI 项目中的应用程序可以使用
    `npm run serve` 启动。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'To organize our code properly, we will create a new folder in `src/plugins`
    and a new file for our `axios` plugin at `src/plugins/axios.js`. In the new file,
    we will scaffold the `axios` plugin:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了正确组织我们的代码，我们将在 `src/plugins` 中创建一个新的文件夹，并在 `src/plugins/axios.js` 中为我们的 `axios`
    插件创建一个新的文件。在新文件中，我们将构建 `axios` 插件：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will now register our `axios` plugin on the Vue.js instance in `src/main.js`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在 `src/main.js` 中的 Vue.js 实例上注册我们的 `axios` 插件：
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will now install `axios` through `npm` using the following command. This
    will allow us to import `axios` and expose it on Vue through a plugin:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将通过以下命令使用 `npm` 安装 `axios`。这将允许我们导入 `axios` 并通过插件在 Vue 中暴露它：
- en: '[PRE16]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will now add `axios` to Vue as a global property in `src/plugins/axios.js`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在 `src/plugins/axios.js` 中将 `axios` 添加到 Vue 作为全局属性：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`axios` is now available on `Vue`. In `src/App.vue`, we can make a request
    to an API that will populate a list of `todos`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`axios` 现在在 `Vue` 中可用。在 `src/App.vue` 中，我们可以向一个 API 发送请求，该 API 将填充 `todos`
    列表：'
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the expected output:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的输出是预期的：
- en: '![Figure 5.6: Global Vue.axios todo display sample'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.6：全局 Vue.axios todo 显示示例](img/B15218_05_06.jpg)'
- en: '](img/B15218_05_06.jpg)'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_05_06.jpg)'
- en: 'Figure 5.6: Global Vue.axios todo display sample'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.6：全局 Vue.axios todo 显示示例
- en: 'Having to add `import Vue from ''vue''` is a bit odd in our case. The whole
    point of injecting `axios` through a plugin was to get rid of the `import` boilerplate.
    The better way to expose `axios` is through the component instance; that is, `this.axios`.
    To do so, we need to update the install step in the `src/plugins/axios.js` file
    and add `axios` to the `Vue.prototype` so that any `new Vue()` component will
    have it as a property:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的情况下，必须添加 `import Vue from 'vue'` 有点奇怪。通过插件注入 `axios` 的全部目的是为了消除 `import`
    模板。更好的方法是通过对组件实例进行暴露；即 `this.axios`。为此，我们需要更新 `src/plugins/axios.js` 文件中的安装步骤，并将
    `axios` 添加到 `Vue.prototype`，这样任何 `new Vue()` 组件都将将其作为属性：
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can now remove the `import Vue from ''vue''` line and access `axios` through
    `this.axios` in `src/App.vue`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以删除 `import Vue from 'vue'` 行，并在 `src/App.vue` 中通过 `this.axios` 访问 `axios`：
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is the output:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![Figure 5.7: Vue instance axios todo display sample'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.7：Vue 实例 axios todo 显示示例'
- en: '](img/B15218_05_07.jpg)'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_05_07.jpg)'
- en: 'Figure 5.7: Vue instance axios todo display sample'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：Vue 实例 axios todo 显示示例
- en: With that, we have used a plugin to inject both global and instance-level properties
    and methods, as well as having learned how they can be used to create directives
    and other Vue constructs in a format that is easy to distribute.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经使用插件注入了全局和实例级别的属性和方法，以及学习了如何以易于分发的方式使用它们来创建指令和其他 Vue 构造。
- en: We will now look at how globally registering components can help reduce boilerplate
    for high usage components in a code base.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨如何在代码库中全局注册组件，以帮助减少高使用频率组件的样板代码。
- en: Globally Registering Components
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局注册组件
- en: A reason for using plugins is to reduce boilerplate in all Vue application files
    by removing `imports` and replacing them with access to `this` and/or `Vue`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用插件的一个原因是减少所有 Vue 应用程序文件中的样板代码，通过删除 `导入` 并用对 `this` 和/或 `Vue` 的访问来替换它们。
- en: Vue.js components are usually defined in a single-file component and imported
    explicitly. Much for the same reasons as we define global methods and properties,
    we might want to register components globally. This will allow us to use these
    components in all our other component templates without having to import them
    and register them under the `components` property.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 组件通常在单个文件组件中定义，并显式导入。出于与定义全局方法和属性相同的原因，我们可能希望全局注册组件。这将允许我们在所有其他组件模板中使用这些组件，而无需导入它们并在
    `components` 属性下注册它们。
- en: A situation where this can be very useful is when using a design system or when
    a component is used across the code base.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在使用设计系统或组件在代码库中跨模块使用时非常有用。
- en: Globally registering a component helps with some types of updates, such as if
    the filename is not exposed to the consumer so that when changing the filename,
    there is only one path to update as opposed to one per user.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 全局注册组件有助于某些类型的更新，例如，如果文件名未暴露给消费者，那么在更改文件名时，只有一个路径需要更新，而不是每个用户一个。
- en: 'Let''s assume we have a `CustomButton` component in the `CustomButton.vue`
    file that looks as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在 `CustomButton.vue` 文件中有一个 `CustomButton` 组件，其外观如下：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can register `CustomButton` globally as follows (this is usually done in
    the `main.js` file):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `CustomButton` 全局注册如下（这通常在 `main.js` 文件中完成）：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now use it in the `App.vue` file without locally registering it or importing
    it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 `App.vue` 文件中使用它，而无需本地注册或导入：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This renders as expected, with a button called `Click Me`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按预期渲染，按钮名为“点击我”：
- en: '![Figure 5.8: CustomButton rendering with a Click Me button'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8：CustomButton 渲染与“点击我”按钮'
- en: '](img/B15218_05_08.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_05_08.jpg)'
- en: 'Figure 5.8: CustomButton rendering with a Click Me button'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：使用“点击我”按钮的 CustomButton 渲染
- en: With that, we have explored how globally registering components can cut down
    on boilerplate when components are used often across a code base.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经探讨了如何在代码库中频繁使用组件时，全局注册组件可以减少样板代码。
- en: Next, we will look at some tips on how to increase component flexibility in
    Vue.js.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何在 Vue.js 中提高组件的灵活性的一些技巧。
- en: Maximizing Component Flexibility
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大化组件灵活性
- en: Vue.js components take props and slots as input; their output is rendered as
    HTML and emitted events.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 组件接受 props 和 slots 作为输入；它们的输出以 HTML 渲染，并发出事件。
- en: To maximize component flexibility, it always makes sense to leverage slots and
    props.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化组件的灵活性，始终利用插槽和 props 是很有意义的。
- en: 'Leveraging props and default values judiciously means a component can be reused
    and extended. For example, instead of hardcoding a value in the component, we
    could set it as a default prop. In this case, `date` defaults to the current date,
    `new Date()`. We then extract the epoch using a computed property:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 精确利用 props 和默认值意味着组件可以被重用和扩展。例如，我们可以在组件中不硬编码值，而是将其设置为默认 prop。在这种情况下，`date` 默认为当前日期，`new
    Date()`。然后我们使用计算属性提取纪元：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When registered and used, this renders as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当注册并使用时，渲染如下：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Slots can be thought of as a way for a component to delegate rendering back
    to its consumers. Delegating parts of the template to the parent component helps
    with reusability.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽可以被视为组件将渲染委托回其消费者的一种方式。将模板的部分委托给父组件有助于可重用性。
- en: 'A specific example of slots used to maximize reusability is the **renderless
    component** pattern. For example, in the epoch display example, we could leverage scoped
    slots and remove any rendering logic from the component:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用插槽来最大化重用性的一个特定例子是**无渲染组件**模式。例如，在时代显示示例中，我们可以利用作用域插槽并从组件中移除任何渲染逻辑：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the parent component, the rendering can be defined using a scoped slot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在父组件中，可以使用作用域插槽来定义渲染：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This means that the delegation of the component is delegated to the parent
    and displays the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着组件的委托被委托给了父组件，并显示以下内容：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The next set of practices maximize the reuse of components by making their API
    predictable. In many ways, forwarding attributes, leveraging the `style` and `class`
    attributes being merged, and implementing a `v-model` interface is another way
    of making Vue.js custom components behave more like HTML elements.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组实践通过使它们的API可预测来最大化组件的重用。在许多方面，前向属性、利用`style`和`class`属性合并以及实现`v-model`接口是使Vue.js自定义组件表现得更像HTML元素的一种方式。
- en: 'Forwarding attributes can be interesting. For example, a `CustomInput` component
    (in the `CustomInput.vue` file) might need to pass the `type` attribute, as well
    as a `required` attribute:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前向属性可能很有趣。例如，一个`CustomInput`组件（在`CustomInput.vue`文件中）可能需要传递`type`属性，以及`required`属性：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `CustomInput` component can be used to render any type of component (`src/App.vue`):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomInput`组件可以用来渲染任何类型的组件（`src/App.vue`）：'
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This renders the text and date inputs correctly:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这正确渲染了文本和日期输入：
- en: '![Figure 5.9: CustomInput with text and date as types'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9：具有文本和日期类型的 CustomInput'
- en: '](img/B15218_05_09.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_09.jpg](img/B15218_05_09.jpg)'
- en: 'Figure 5.9: CustomInput with text and date as types'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：具有文本和日期类型的 CustomInput
- en: 'Vue.js does a lot of the heavy lifting around classes/inline styles since it
    merges the `style` and `class` objects defined on a component with the `style`
    and `class` objects of the root element in said component. As per the documentation,
    "*the class and style attributes are a little smarter, so both values are merged*"
    (*Vue.js Component Props guide*: [https://vuejs.org/v2/guide/components-props.html#Replacing-Merging-with-Existing-Attributes](https://vuejs.org/v2/guide/components-props.html#Replacing-Merging-with-Existing-Attributes)).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js在类/内联样式方面做了很多繁重的工作，因为它将组件上定义的`style`和`class`对象与该组件根元素的`style`和`class`对象合并。根据文档，“类和样式属性有点智能，所以两个值都会合并”
    (*Vue.js 组件属性指南*：[https://vuejs.org/v2/guide/components-props.html#Replacing-Merging-with-Existing-Attributes](https://vuejs.org/v2/guide/components-props.html#Replacing-Merging-with-Existing-Attributes))。
- en: In Vue.js, the tendency is for input elements and components to be controlled
    through `v-model`, a two-way reactive Vue.js binding. `v-model` is shorthand for
    using `v-bind:value` and `v-on:input` to provide a value and keep it in sync with
    the output from the child component or element.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue.js中，输入元素和组件倾向于通过`v-model`进行双向响应式绑定，`v-model`是使用`v-bind:value`和`v-on:input`来提供值并保持与子组件或元素的输出同步的简写。
- en: The `value` that is passed is only used as the starting value; `input` events
    are emitted when the input is done being captured (for example, typing is done).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的`value`仅用作起始值；当输入被捕获完成时（例如，完成输入）会发出`input`事件。
- en: If a component implements the `v-model` shape, it works as a direct replacement
    for form elements.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件实现了`v-model`形状，它可以直接替换表单元素。
- en: 'For example, a `TextInput` that implements the `v-model` interface can be used
    interchangeably with `input` and `textarea`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，实现了`v-model`接口的`TextInput`可以与`input`和`textarea`互换使用：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This can then be used as follows in `src/App.vue`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在`src/App.vue`中如下使用：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The application renders as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序渲染如下：
- en: '![Figure 5.10: Custom component implementing v-model'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10：实现 v-model 的自定义组件'
- en: '](img/B15218_05_10.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_10.jpg](img/B15218_05_10.jpg)'
- en: 'Figure 5.10: Custom component implementing v-model'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：实现 v-model 的自定义组件
- en: With that, we have looked at how to leverage props and slots, inherit attributes,
    and implement well-known Vue.js interfaces to help maximize component flexibility.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就已经探讨了如何利用props和slots、继承属性以及实现已知的Vue.js接口来帮助最大化组件的灵活性。
- en: The next section is dedicated to deepening our understanding of Vue.js components
    by learning how to use them without `.vue` files.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将专门介绍如何通过学习在不使用`.vue`文件的情况下使用Vue.js组件来加深我们对Vue.js组件的理解。
- en: Using Vue.js Components without a .vue Single-File Component
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue.js组件而不使用.vue单文件组件
- en: Most of the examples we have seen of Vue.js components have leveraged `.vue`
    single-file components.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所看到的 Vue.js 组件的大部分示例都利用了 `.vue` 单文件组件。
- en: This is not the only way to define a Vue.js component. In this section, we will
    look at four different ways to define Vue.js components without using a `.vue`
    file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是定义 Vue.js 组件的唯一方法。在本节中，我们将探讨四种不同的方法来定义 Vue.js 组件，而不使用 `.vue` 文件。
- en: Evaluating these options will help us understand what a Vue.js component is
    at its core.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 评估这些选项将帮助我们理解 Vue.js 组件的核心是什么。
- en: Runtime Definition with a String Template
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字符串模板的运行时定义
- en: A component can use a `template` property that accepts a string value. This
    is commonly called a **string template**. This template is evaluated at runtime
    (in the browser).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以使用接受字符串值的 `template` 属性。这通常被称为 **字符串模板**。此模板在运行时（在浏览器中）被评估。
- en: 'We can define a component in the `StringTemplate.js` file by defining an object
    with a `template` property:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `StringTemplate.js` 文件中定义一个组件，通过定义一个具有 `template` 属性的对象：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This can then be consumed from the `App.vue` file, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以从 `App.vue` 文件中消费它，如下所示：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Unfortunately, this crashes on load and displays the following Vue warning
    in the console:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这会在加载时崩溃，并在控制台显示以下 Vue 警告：
- en: '![Figure 5.11: Vue runtime compiler missing warning'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11：Vue 运行时编译器缺失警告](img/B15218_05_11.jpg)'
- en: '](img/B15218_05_11.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_05_11.jpg)'
- en: 'Figure 5.11: Vue runtime compiler missing warning'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：Vue 运行时编译器缺失警告
- en: As per the Vue warning, for this component to work when imported, we need to
    include the Vue.js compiler in the runtime build. To do so, in a Vue CLI project,
    we can set the `runtimeCompiler` option to `true` in `vue.config.js` (the Vue
    CLI configuration file).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Vue 警告，为了使此组件在导入时工作，我们需要在运行时构建中包含 Vue.js 编译器。为此，在 Vue CLI 项目中，我们可以在 `vue.config.js`（Vue
    CLI 配置文件）中将 `runtimeCompiler` 选项设置为 `true`。
- en: 'Your `vue.config.js` should look like the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `vue.config.js` 应该看起来像以下这样：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After setting this option and restarting the development server, a message
    from the `StringTemplate` component appears in the browser:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 设置此选项并重新启动开发服务器后，来自 `StringTemplate` 组件的消息会出现在浏览器中：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Props and other component instance properties can be defined with `.vue` component
    objects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `.vue` 组件对象定义属性和其他组件实例属性。
- en: The render Function
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染函数
- en: A Vue.js single-file component `template` section gets compiled into a `render`
    function at build time.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 单文件组件的 `template` 部分在构建时被编译成一个 `render` 函数。
- en: 'A `render` function tends to be used in the `main.js` file of a Vue CLI project
    – specifically, the `new Vue()` call:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 函数通常用于 Vue CLI 项目的 `main.js` 文件中 - 特别是 `new Vue()` 调用：'
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A `render` function takes a `createElement` parameter and returns a virtual
    DOM node. This is done by calling the `createElement` function (in the preceding
    example, this is `h`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `render` 函数接受一个 `createElement` 参数，并返回一个虚拟 DOM 节点。这是通过调用 `createElement`
    函数（在上面的示例中，这是 `h`）来完成的。
- en: '`h` is often used as shorthand for `createElement` due to its compactness.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`h` 由于其紧凑性，常被用作 `createElement` 的缩写。'
- en: 'We can define a component in a JavaScript file (`RenderFunction.js`) with a
    `render` property like so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 JavaScript 文件（`RenderFunction.js`）中定义一个具有 `render` 属性的组件，如下所示：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This can be rendered in the `App.vue` file as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在 `App.vue` 文件中这样呈现：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This component displays a `h2` with **Render Function Component** as its content
    in the browser:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件在浏览器中显示一个 `h2`，内容为 **渲染函数组件**：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Beyond writing components in non `.vue` files, `render` functions can be useful
    for highly dynamic components.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在非 `.vue` 文件中编写组件外，`render` 函数对于高度动态的组件也很有用。
- en: JSX
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX
- en: JSX has been popularized by React. As per the React documentation, *JSX is a
    syntax extension to JavaScript. We recommend using it with React to describe what
    the UI should look like* ([https://reactjs.org/docs/introducing-jsx.html](https://reactjs.org/docs/introducing-jsx.html)).
    JSX is a superset of JavaScript that allows `HTML-style` tags and interpolation
    using braces.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 由 React 推广。根据 React 文档，*JSX 是 JavaScript 的语法扩展。我们建议与 React 一起使用它来描述 UI 应该是什么样子*
    ([https://reactjs.org/docs/introducing-jsx.html](https://reactjs.org/docs/introducing-jsx.html))。JSX
    是 JavaScript 的超集，允许使用花括号进行 `HTML-style` 标签和插值。
- en: React, like Vue.js, does not render JSX to the DOM. Like Vue.js templates, React
    application build tools compile JSX to `render` functions that are used at runtime
    so that they can be rendered to the Virtual DOM. The Virtual DOM is then *reconciled*
    (synced) with the real DOM.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Vue.js 一样，React 不会将 JSX 渲染到 DOM 中。与 Vue.js 模板类似，React 应用程序构建工具将 JSX 编译为在运行时使用的
    `render` 函数，以便它们可以渲染到虚拟 DOM。然后虚拟 DOM 与真实 DOM 进行 *reconcile*（同步）。
- en: JSX compiles to `render` functions and Vue.js supports component definitions
    with `render` functions. Moreover, **Vue CLI 3+** compiles JSX out of the box.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 编译为 `render` 函数，Vue.js 支持 `render` 函数的组件定义。此外，**Vue CLI 3+** 默认编译 JSX。
- en: 'This means we can write the following, which is the equivalent of the `RenderFunction`
    component, `JSXRender.js` file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以编写以下内容，这与 `RenderFunction` 组件、`JSXRender.js` 文件等效：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The equivalent `render` function without JSX looks as follows (based on the
    example from the previous section):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 JSX 的等效 `render` 函数如下所示（基于上一节中的示例）：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following `App.vue` file renders `JSXRender` to the browser:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `App.vue` 文件将 `JSXRender` 渲染到浏览器中：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we can see the `h2` from `JSXRender` on the screen with the expected content:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在屏幕上看到 `JSXRender` 中的 `h2`，内容符合预期：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With that, we have learned that Vue.js components are just objects with a `render`
    or `template` function. `.vue` component `template` sections are compiled to `render`
    functions at build time, which means that to use string templates, we need to
    include the Vue.js compiler in the application runtime. We have also learned how
    to use `render` functions, as well as JSX, to define components and pointed out
    some things React and Vue.js have in common from an implementation point of view.
    When choosing to use JSX or `render` functions, JSX can be easier to read with
    the full flexibility of `render` functions (which regular templates do not always
    have).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经了解到 Vue.js 组件只是具有 `render` 或 `template` 函数的对象。`.vue` 组件的 `template`
    部分在构建时编译为 `render` 函数，这意味着要使用字符串模板，我们需要在应用程序运行时包含 Vue.js 编译器。我们还学习了如何使用 `render`
    函数以及 JSX 来定义组件，并指出了 React 和 Vue.js 在实现方面的一些共同点。在决定使用 JSX 或 `render` 函数时，JSX 可以更容易阅读，同时具有
    `render` 函数的完整灵活性（而常规模板并不总是具备）。
- en: We will now look at how components can be rendered dynamically from runtime
    data using the Vue.js `component` tag.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何使用 Vue.js 的 `component` 标签从运行时数据动态渲染组件。
- en: The Vue component Tag
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 组件标签
- en: JSX and `render` functions are great for situations where the component being
    rendered needs to be very dynamic.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 和 `render` 函数非常适合需要非常动态渲染的组件的情况。
- en: The way to achieve this within regular Vue.js templates is by using the `component` tag.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规 Vue.js 模板中实现这一点的办法是使用 `component` 标签。
- en: The `component` tag uses the `is` prop to dynamically select which component
    will be rendered.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`component` 标签使用 `is` 属性来动态选择将渲染哪个组件。'
- en: 'To render a dynamic component, we use a `component` tag with a bound `is` property
    (here, we are using the shorthand `:is`, which is equivalent to `v-bind:is`):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染一个动态组件，我们使用一个带有绑定 `is` 属性的 `component` 标签（在这里，我们使用缩写 `:is`，它等同于 `v-bind:is`）：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We will now learn how to render dynamic components using a name or component reference.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何使用名称或组件引用渲染动态组件。
- en: Rendering Dynamic Components by Name or Component Reference
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过名称或组件引用渲染动态组件
- en: Let's say we have a grid that contains items whose display can be toggled between
    a card display (a design element with an image and text) or an image-only view.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个网格，其中包含可以切换显示为卡片显示（一个包含图像和文本的设计元素）或仅图像视图的项目。
- en: 'First, we need to import the relevant components and register them as components.
    We will also set some fixture data to loop through for the grid:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入相关组件并将它们注册为组件。我们还将设置一些固定数据以循环网格：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can then reference the components by name – that is, `card` and `image-entry`
    – and set `itemComponent` as the value for `is`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按名称引用组件——即 `card` 和 `image-entry`——并将 `itemComponent` 设置为 `is` 的值：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this case, the `Card` component will render since we are passing its lowercased
    name (`card`) to the `component` tag.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Card` 组件将被渲染，因为我们传递了其小写名称（`card`）给 `component` 标签。
- en: 'If we turned `itemComponent` into `image-entry`, the `ImageEntry` component
    would render. This switch can be made as follows using `v-model`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `itemComponent` 改为 `image-entry`，则 `ImageEntry` 组件将被渲染。此切换可以使用 `v-model`
    如下进行：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can also pass components to `is` using the component reference itself (instead
    of the name). For example, we could set `itemComponent` to `Card`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用组件引用本身（而不是名称）将组件传递给 `is`。例如，我们可以将 `itemComponent` 设置为 `Card`：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this case, switching between card and image views would be more difficult
    since we would need to use component references instead of using names.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在卡片视图和图像视图之间切换会更困难，因为我们需要使用组件引用而不是使用名称。
- en: 'We can pass props to components that have been dynamically rendered with `component`
    as we would pass regular props either with `v-bind:prop-name` or the `:prop-name`
    shorthand:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将属性传递给使用 `component` 动态渲染的组件，就像我们使用 `v-bind:prop-name` 或 `:prop-name` 简写传递常规属性一样：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Given the following `Card` and `ImageEntry` components, we get an application
    that has toggleable views for grid items.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下 `Card` 和 `ImageEntry` 组件，我们得到一个具有可切换视图的网格项的应用程序。
- en: '`Card.vue` renders the image and the title and has a `150px` maximum width:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Card.vue` 渲染图像和标题，并具有最大宽度 `150px`：'
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Your output will display the entries in card view, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出将显示卡片视图中的条目，如下所示：
- en: '![Figure 5.12: Grid rendering entries in card view'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12：在卡片视图中渲染网格条目]'
- en: '](img/B15218_05_12.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_12.jpg]'
- en: 'Figure 5.12: Grid rendering entries in card view'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：在卡片视图中渲染网格条目
- en: 'Use `ImageEntry.vue` to render only the image at double the width of the card view:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ImageEntry.vue` 以卡片视图的两倍宽度渲染图像：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You will now see the entries in an image view, as shown in the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在将看到图像视图中的条目，如下面的截图所示：
- en: '![Figure 5.13: Grid rendering entries in an image view'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.13：在图像视图中渲染网格条目]'
- en: '](img/B15218_05_13.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_13.jpg]'
- en: 'Figure 5.13: Grid rendering entries in an image view'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13：在图像视图中渲染网格条目
- en: A caveat of the `component` tag is that the rendered dynamic component gets
    completely torn down when it is not displayed anymore. In this example, the dynamic
    components being rendered do not have any state, so this teardown does not create
    any issues.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`component` 标签的一个注意事项是，当它不再显示时，渲染的动态组件会被完全销毁。在这个例子中，正在渲染的动态组件没有任何状态，所以这种销毁不会引起任何问题。'
- en: We will now learn how a dynamic component state is cached.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将学习如何缓存动态组件状态。
- en: Caching a Dynamic Component State with Keep-Alive
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Keep-Alive 缓存动态组件状态
- en: Components that are dynamically rendered through the `component` tag can have
    state, such as in a multipart form, with a `name` field and an `address` field
    on the next page.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `component` 标签动态渲染的组件可以有状态，例如在多部分表单中，下一页有 `name` 字段和 `address` 字段。
- en: 'Let''s implement this with a `component` tag, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `component` 标签来实现这一点，如下所示：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'By doing this, we can enter data in the `Name` field:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以在 `Name` 字段中输入数据：
- en: '![Figure 5.14: My name is entered in the name field'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.14：在名称字段中输入我的名字]'
- en: '](img/B15218_05_14.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_14.jpg]'
- en: 'Figure 5.14: My name is entered in the name field'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14：在名称字段中输入我的名字
- en: 'If we navigate, using `Next`, (to the address part of the form) and then `Back`,
    the name will disappear, as shown in the following screenshot:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `Next` 导航到表单的地址部分，然后使用 `Back`，名称将会消失，如下面的截图所示：
- en: '![Figure 5.15: Empty name field upon clicking Next and then Back in the address
    step'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.15：在地址步骤中点击 Next 然后Back后的空名称字段]'
- en: '](img/B15218_05_15.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_15.jpg]'
- en: 'Figure 5.15: Empty name field upon clicking Next and then Back in the address
    step'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：在地址步骤中点击 Next 然后 Back 后的空名称字段
- en: This is due to the component being torn down (destroyed) when it is not the
    currently rendered dynamic component.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为组件在不是当前渲染的动态组件时会被销毁（摧毁）。
- en: 'To fix this, we can use the `keep-alive` element around the `component` tag:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在 `component` 标签周围使用 `keep-alive` 元素：
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In this manner, filling out the name and going `Back` from the address section
    of the form shows the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，填写名称并从表单的地址部分返回将显示以下内容：
- en: '![Figure 5.16: My name is is still the value in the Name field after navigation'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.16：导航后，我的名字仍然是名称字段中的值]'
- en: '](img/B15218_05_16.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_16.jpg]'
- en: 'Figure 5.16: My name is is still the value in the Name field after navigation'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16：导航后，我的名字仍然是名称字段中的值
- en: With that, we have learned how to use the `component` tag to denote an area
    within which we can dynamically display a component based on a string or the component
    itself (as imported). We have also explored how to work around the main gotcha
    of `component`; namely, how to use `keep-alive` to maintain component state when
    it is not the component being actively used in the `component` tag.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经学习了如何使用 `component` 标签来表示一个区域，在这个区域内我们可以根据字符串或组件本身（如导入的）动态显示组件。我们还探讨了如何解决
    `component` 的主要问题；即如何使用 `keep-alive` 在 `component` 标签中不是正在积极使用的组件时保持组件状态。
- en: 'Exercise 5.03: Creating a Dynamic Card Layout with the component Tag'
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.03：使用 component 标签创建动态卡片布局
- en: A modern application layout is a grid with cards. `Card` layouts have the benefit
    of being well-suited to mobile, desktop, and tablet displays. In this exercise,
    we will create a dynamic `card` layout with three different modes and a way to
    select between the three of them. This layout will allow the user to select how
    much information is displayed on the screen to suit their preference.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序布局是一个带有卡片网格。`Card` 布局的好处是适合移动、桌面和平板显示器。在这个练习中，我们将创建一个具有三种不同模式和选择其中之一的方式的动态
    `card` 布局。此布局将允许用户选择屏幕上显示多少信息以适应他们的偏好。
- en: The `Rich` view will display all the details for an item, including the image,
    the title, and the description.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rich` 视图将显示一个项目的所有详细信息，包括图片、标题和描述。'
- en: The `Compressed` view will display all the details but not the image preview.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`Compressed` 视图将显示所有详细信息，但不显示图片预览。'
- en: The `List` view will only display the title and should be a vertical layout.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 视图将仅显示标题，应采用垂直布局。'
- en: Each of the `card` views will be implemented as a separate component that will
    then be dynamically rendered using the `component` tag. To access the code files
    for this exercise, refer to [https://packt.live/3mYYvkq](https://packt.live/3mYYvkq).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `card` 视图都将作为一个单独的组件实现，然后使用 `component` 标签动态渲染。要访问此练习的代码文件，请参阅 [https://packt.live/3mYYvkq](https://packt.live/3mYYvkq)。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'Create the rich layout at `src/components/Rich.vue`. It contains three props
    called `url` (the image URL), `title`, and `description` and renders the image,
    the title, and the description, respectively:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/components/Rich.vue` 中创建丰富的布局。它包含三个属性：`url`（图片 URL）、`title` 和 `description`，分别渲染图片、标题和描述：
- en: '[PRE55]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Set up `src/App.vue` with some fixture data:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一些固定数据设置 `src/App.vue`：
- en: '[PRE56]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Import the `Rich` view component into `src/App.vue` and register it locally:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Rich` 视图组件导入到 `src/App.vue` 并本地注册：
- en: '[PRE57]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once we have got the `Rich` view component, wire it into the application in
    `src/App.vue`, render it with `component`, and pass the relevant props through:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们获得了 `Rich` 视图组件，将其连接到 `src/App.vue` 应用程序中，使用 `component` 渲染它，并通过相关属性传递：
- en: '[PRE58]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is a good point to add a bit of styling to make the grid look like a grid:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个添加一些样式使网格看起来像网格的好地方：
- en: '[PRE59]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This displays the following output:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示以下输出：
- en: '![Figure 5.17: Rich component rendering dynamically'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.17：动态渲染丰富的组件]'
- en: '](img/B15218_05_17.jpg)'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_17.jpg](img/B15218_05_17.jpg)'
- en: 'Figure 5.17: Rich component rendering dynamically'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.17：动态渲染丰富的组件
- en: 'Now, implement the `Compressed` view, which is just the `Rich` view without
    the image in the `Compressed.vue` file:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现 `Compressed` 视图，它只是 `Rich` 视图，但在 `Compressed.vue` 文件中没有图片：
- en: '[PRE60]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Import and register the `Compressed` component in `src/App.vue`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/App.vue` 中导入并注册 `Compressed` 组件：
- en: '[PRE61]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add a `select` to switch between views. It will have two options with values
    for `rich` and `compressed` and will be bound to `layout` using `v-model`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `select` 来在视图之间切换。它将有两个选项，值为 `rich` 和 `compressed`，并使用 `v-model` 绑定到 `layout`：
- en: '[PRE62]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Using this `select`, we can switch to the `compressed` layout, which looks
    as follows:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用此 `select`，我们可以切换到 `compressed` 布局，其外观如下：
- en: '![Figure 5.18: Compressed layout with select open'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.18：打开选择器的压缩布局]'
- en: '](img/B15218_05_18.jpg)'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_18.jpg](img/B15218_05_18.jpg)'
- en: 'Figure 5.18: Compressed layout with select open'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.18：打开选择器的压缩布局
- en: 'Add the `List` layout to `src/components/List.vue`. The `list` view is the
    compressed view but without the description:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `List` 布局添加到 `src/components/List.vue`。`list` 视图是压缩视图，但没有描述：
- en: '[PRE63]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Import the `List` component into `src/App.vue` and register it locally:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `List` 组件导入到 `src/App.vue` 并本地注册：
- en: '[PRE64]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add an extra option with `value="list"` to switch to the `List` layout:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个额外的选项 `value="list"` 以切换到 `List` 布局：
- en: '[PRE65]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When switching to the `list` layout, the items are displayed in a horizontal
    row, as follows:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当切换到`list`布局时，项目将按如下方式显示为水平行：
- en: '![Figure 5.19: List view with incorrect horizontal stacking'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.19：水平堆叠错误的列表视图'
- en: '](img/B15218_05_19.jpg)'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_19.jpg](img/B15218_05_19.jpg)'
- en: 'Figure 5.19: List view with incorrect horizontal stacking'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.19：水平堆叠错误的列表视图
- en: 'To fix this horizontal stacking, create a new `grid-column` class that sets
    `flex-direction: column` (as opposed to `row`, which is the default) and conditionally
    applies it when the layout is `list`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '要修复这种水平堆叠，创建一个新的`grid-column`类，将其设置为`flex-direction: column`（与默认的`row`相对）并在布局为`list`时条件性地应用它：'
- en: '[PRE66]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Our `List` layout now looks as follows:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的`List`布局现在看起来如下：
- en: '![Figure 5.20: List view with vertical stacking'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.20：垂直堆叠的列表视图'
- en: '](img/B15218_05_20.jpg)'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_20.jpg](img/B15218_05_20.jpg)'
- en: 'Figure 5.20: List view with vertical stacking'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20：垂直堆叠的列表视图
- en: With that, we have learned how to use the `component` tag to dynamically render
    different components both by name and by using the component object itself. We
    have also explored the pitfalls of stateful dynamic components, namely the teardown
    of components when they are not displayed anymore and how to circumvent them using
    the `keep-alive` element.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学习了如何使用`component`标签动态渲染不同组件，无论是通过名称还是使用组件对象本身。我们还探讨了有状态动态组件的陷阱，即组件不再显示时的组件销毁以及如何使用`keep-alive`元素来规避这些问题。
- en: We will now look at how simple components can be implemented using only a `render`
    function or `template` tag using functional components.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何仅使用`render`函数或`template`标签使用功能组件来实现简单组件。
- en: Functional Components
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能组件
- en: Functional components are a subset of regular Vue.js components. They do not
    have state or a component instance. They can be thought of as `render` functions
    (as shown earlier in this chapter) to which props are passed.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件是常规Vue.js组件的子集。它们没有状态或组件实例。它们可以被视为`render`函数（如本章前面所示），其中传递了属性。
- en: Note
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can mark components as functional, which means that they are stateless (no
    reactive data) and instance-less (no `this` context).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将组件标记为功能性的，这意味着它们是无状态的（没有响应式数据）和实例化的（没有`this`上下文）。
- en: See the Vue.js documentation for more ([https://vuejs.org/v2/guide/render-function.html#Functional-Components](https://vuejs.org/v2/guide/render-function.html#Functional-Components)).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅Vue.js文档（[https://vuejs.org/v2/guide/render-function.html#Functional-Components](https://vuejs.org/v2/guide/render-function.html#Functional-Components)）。
- en: Functional components can only access props, children, slots, and scoped slots,
    as passed from their parent component. They also receive references to **parents**
    and **listeners**.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件只能访问从父组件传递过来的属性、子组件、插槽和作用域插槽，它们还接收对**父组件**和**监听器**的引用。
- en: 'The following is a `Greet` component (in the `Greet.vue` file). Note the `functional`
    annotation in `template`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`Greet`组件（在`Greet.vue`文件中）。注意`template`中的`functional`注解：
- en: '[PRE67]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Functional components must access props through `props.propName`. Functional
    components can also be denoted by the `functional: true` Boolean and be used with
    a `render` function:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '功能组件必须通过`props.propName`访问属性。功能组件也可以通过`functional: true`布尔值表示，并使用`render`函数：'
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can use both these functional components in the `App.vue` file:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`App.vue`文件中使用这两个功能组件：
- en: '[PRE69]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This renders the following to the browser:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在浏览器中渲染以下内容：
- en: '![Figure 5.21: Functional component rendering'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.21：功能组件渲染'
- en: '](img/B15218_05_21.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_21.jpg](img/B15218_05_21.jpg)'
- en: 'Figure 5.21: Functional component rendering'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21：功能组件渲染
- en: Functional components are a great way to encapsulate functionality that is render-only;
    that is, they derive their templates from props. They have a slightly better performance
    profile than regular components since they do not have any associated reactive
    state or a component instance.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件是封装仅渲染功能的绝佳方式；也就是说，它们从属性中获取模板。由于它们没有关联的响应式状态或组件实例，因此它们比常规组件有更好的性能表现。
- en: 'A common use case we have covered for non-functional components is emitting
    events, which can be done as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为非功能组件覆盖了一个常见用例，即发出事件，可以如下操作：
- en: '[PRE70]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: To emit an event with a functional component, we can bind elements to properties
    in the `listeners` object.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用功能组件发出事件，我们可以将元素绑定到`listeners`对象中的属性。
- en: 'To delegate all events to a child, we can use `v-on="listeners"`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要将所有事件委派给子组件，我们可以使用`v-on="listeners"`：
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To bind a specific listener, we can use `v-on:eventName="listeners.listenerName"`,
    where `listenerName` is the listener that the parent of the functional component
    is bound to:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要绑定一个特定的监听器，我们可以使用 `v-on:eventName="listeners.listenerName"`，其中 `listenerName`
    是功能组件的父组件绑定的监听器：
- en: '[PRE72]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Binding to a listener property that does not exist will result in an error.
    To avoid this, we can use the `listeners.listenerName || (() => {})` expression.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到一个不存在的监听器属性将导致错误。为了避免这种情况，我们可以使用 `listeners.listenerName || (() => {})` 表达式。
- en: With that, we have learned how to implement common Vue.js component patterns
    using functional components with both the `.vue` component `template` variant
    and `render` functions.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学习了如何使用功能组件以及 `.vue` 组件的 `template` 变体和 `render` 函数来实现常见的Vue.js组件模式。
- en: We will now build a to-do application that uses all the patterns we have looked
    at throughout this chapter.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将构建一个使用本章中我们查看的所有模式的待办事项应用程序。
- en: 'Activity 5.01: Building a Vue.js Application with Plugins and Reusable Components'
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动五.01：使用插件和可重用组件构建Vue.js应用程序
- en: In this activity, we will build a `jsonplaceholder` as a data source.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将构建一个 `jsonplaceholder` 作为数据源。
- en: Our to-do app will load todos and display them as a list. It will display a
    checkbox based on whether the to-do has been completed, as well as the name of
    the to-do.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的待办事项应用程序将加载待办事项并将它们显示为列表。它将根据待办事项是否已完成显示复选框，以及待办事项的名称。
- en: When checking off a to-do, the application will sync it to the API.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当勾选待办事项时，应用程序将同步到API。
- en: We will inject `axios` as a plugin to query against [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将作为插件注入 `axios` 以查询 [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)。
- en: 'Follow these steps to complete this activity:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Install `axios` into the project.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `axios` 安装到项目中。
- en: To inject `axios` as a property into `this` component instances, create a `src/plugins/axios.js`
    plugin file that, on `install`, will mean component instances have an `axios`
    property.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 `axios` 注入为 `this` 组件实例的属性，创建一个 `src/plugins/axios.js` 插件文件，在 `install` 时，这意味着组件实例将有一个
    `axios` 属性。
- en: For the plugin to work, import and register it in `src/main.js`.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使插件工作，请在 `src/main.js` 中导入并注册它。
- en: We also want to inject our API's `baseUrl` into all our components. We will
    create a plugin inline of the `src/main.js` file to do this.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望将我们的API的 `baseUrl` 注入到所有组件中。我们将创建一个内联的 `src/main.js` 文件插件来完成此操作。
- en: We now want to fetch all the to-dos from our `src/App.vue`. A good place to
    do this is in the `mounted` life cycle method.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要从我们的 `src/App.vue` 中获取所有待办事项。一个好的地方是在 `mounted` 生命周期方法中做这件事。
- en: To display the to-do list, we will create a `TodoList` functional component
    in `src/components/TodoList.vue` that takes a `todos` prop, loops through the
    items, and defers rendering of the to-do under a `todo` scoped slot that binds
    the to-do.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示待办事项列表，我们将在 `src/components/TodoList.vue` 中创建一个 `TodoList` 功能组件，它接受一个 `todos`
    属性，遍历项目，并在 `todo` 作用域插槽中延迟渲染待办事项，该插槽绑定待办事项。
- en: We can now use the `TodoList` component to render out the todos we have already
    fetched in `src/App.vue`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `TodoList` 组件在 `src/App.vue` 中渲染我们已获取的待办事项。
- en: We now need to create a `TodoEntry` component where we will implement most of
    the to-do-specific logic. A good practice for components is to have the props
    be very specific to the component's role. In this case, the properties of the
    `todo` object we will tackle are `id`, `title`, and `completed`, so those should
    be the props that our `TodoEntry` component receives. We will not make `TodoEntry`
    a functional component since we will need a component instance to create HTTP
    requests.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个 `TodoEntry` 组件，我们将在这里实现大部分待办事项特定的逻辑。对于组件来说，一个好的做法是让属性非常具体于组件的角色。在这种情况下，我们将处理的
    `todo` 对象的属性是 `id`、`title` 和 `completed`，因此这些应该是我们的 `TodoEntry` 组件接收的属性。我们不会将
    `TodoEntry` 制作成功能组件，因为我们需要组件实例来创建HTTP请求。
- en: We will then update `src/App.vue` so that it consumes `TodoEntry` (making sure
    to bind `id`, `title`, and `completed`).
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将更新 `src/App.vue`，使其消费 `TodoEntry`（确保绑定 `id`、`title` 和 `completed`）。
- en: Add the ability to toggle the `todo`. We will implement the majority of this
    in `src/components/TodoEntry.vue`. We will listen to the `input` change event.
    On change, we will want to read the new value and send a `PATCH` request to `/todos/{todoId}`
    with an object containing `completed` set to the new value. We will also want
    to emit a `completedChange` event in Vue.js so that the `App` component can update
    the data that's in-memory.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加切换 `todo` 的功能。我们将大部分实现放在 `src/components/TodoEntry.vue` 中。我们将监听 `input` 变更事件。在变更时，我们将读取新值并向
    `/todos/{todoId}` 发送一个包含 `completed` 设置为新值的 `PATCH` 请求。我们还将想要在 Vue.js 中发出一个 `completedChange`
    事件，以便 `App` 组件可以更新内存中的数据。
- en: In `App.vue`, we will want to update the relevant `todo` when `completeChange`
    is triggered. Since `completeChange` does not include the ID of the `todo`, we
    will need to read that from the context when setting the `handleCompleteChange`
    function to listen to `completeChange`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App.vue` 中，当触发 `completeChange` 时，我们希望更新相关的 `todo`。由于 `completeChange` 不包括
    `todo` 的 ID，我们需要在设置 `handleCompleteChange` 函数以监听 `completeChange` 时从上下文中读取该 ID。
- en: 'The expected output is as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 5.22: Our to-do app using jsonplaceholder data'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.22：使用 jsonplaceholder 数据的待办事项应用]'
- en: '](img/B15218_05_22.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.22](img/B15218_05_22.jpg)'
- en: 'Figure 5.22: Our to-do app using jsonplaceholder data'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22：使用 jsonplaceholder 数据的待办事项应用
- en: Note
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor389).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以通过[这个链接](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor389)找到。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have looked at global composition patterns and advanced
    component setups that can be used to reduce duplication throughout a Vue.js application.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了全局组合模式和高级组件设置，这些可以在 Vue.js 应用程序中减少重复。
- en: First, we learned about mixins, which explicitly share functionality while letting
    components have the last say and saw the exceptions to this rule. We then saw
    how plugins are a great hook into multiple Vue.js primitives.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们学习了混合（mixins），它明确地共享功能，同时让组件有最后的决定权，并看到了这个规则的例外情况。然后，我们看到了插件是如何成为深入多个 Vue.js
    原语的一个很好的钩子。
- en: Next, we looked at how prescriptive patterns maximize component reusability
    in Vue.js. Ideas such as leveraging props to delegate data, slots to delegate
    templates, and implementing interfaces that allow components to be used with Vue-idiomatic
    shorthand such as `v-model` were shown.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了如何通过规定模式在 Vue.js 中最大化组件的可重用性。例如，利用 props 来委派数据、slots 来委派模板，以及实现允许组件使用
    Vue-idiomatic 简写（如 `v-model`）的接口。
- en: We also took an in-depth look at what Vue.js components are beyond `.vue` files.
    We delved into what a Vue.js component is by introducing string templates, `render`
    functions, and JSX, as well as the requirements for each of these approaches to
    work. The `component` tag and `keep-alive` showed another approach to dynamically
    rendering components in Vue.js applications based on reactive data. Finally, we
    saw how functional components cement how we can define components with `.vue`
    files.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还深入探讨了 Vue.js 组件是什么，而不仅仅是 `.vue` 文件。我们通过引入字符串模板、`render` 函数和 JSX，以及这些方法各自的工作要求，来深入了解
    Vue.js 组件。最后，我们看到了功能组件如何巩固我们使用 `.vue` 文件定义组件的方法。
- en: So far, we have learned how to build applications in terms of components, mixins,
    and plugins. To build applications that span multiple pages, we need to implement
    routing. This is what we will tackle in the next chapter.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何从组件、混合和插件的角度构建应用程序。要构建跨越多个页面的应用程序，我们需要实现路由。这就是我们在下一章将要解决的问题。
