- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server-Side Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step in building React applications is learning how **server-side rendering**
    (**SSR**) works and what benefits it can give us. By implementing SSR, we can
    create **universal applications** that are better for **search engine optimization**
    (**SEO**) and enable knowledge-sharing between the frontend and the backend. They
    can also improve the perceived speed of a web application, which usually leads
    to increased conversions. However, applying SSR to a React application comes at
    a cost, and we should think carefully about whether we need it or not.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will see how to set up a server-side-rendered application,
    and by the end of the relevant sections, you will be able to build a universal
    application and understand the pros and cons of the technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what a universal application is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figuring out the reasons why we may want to enable SSR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple static server-side-rendered application with React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding data fetching to server-side rendering and understanding concepts such
    as dehydration/hydration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **Next.js** by Zeit to easily create a React application that runs on
    both the server and the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 19+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code for this chapter in the book’s GitHub repository at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fouth-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fouth-Edition/tree/main/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding universal applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A universal application is an application that can run both on the server side
    and client side with the same code. In this section, we will look at the reasons
    why we should consider making our applications universal, and we will learn how
    React components can be easily rendered on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about JavaScript web applications, we usually think of client-side
    code that lives in the browser. The way they usually work is that the server returns
    an empty HTML page with a script tag to load the application. When the application
    is ready, it manipulates the DOM inside the browser to show the UI and interact
    with users. This has been the case for the last few years, and it is still the
    way to go for a huge number of applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we have seen how easy it is to create applications using React
    components and how they work within the browser. What we have not seen yet is
    how React can render the same components on the server, giving us a powerful feature
    called SSR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going into the details, let’s try to understand what it means to create
    applications that render both on the server and the client. For years, we used
    to have completely different applications for the server and client: for example,
    a Django application to render the views on the server, and some JavaScript frameworks,
    such as Backbone or jQuery, on the client. Those separate apps usually had to
    be maintained by two teams of developers with different skill sets. If you needed
    to share data between the server-side-rendered pages and the client-side application,
    you could inject some variables into a script tag. Using two different languages
    and platforms, there was no way to share common information, such as models or
    views, between the different sides of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Since Node.js was released in 2009, JavaScript has gained a lot of attention
    and popularity on the server side as well, thanks to web application frameworks
    such as **Express**.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same language on both sides not only makes it easy for developers
    to reuse their knowledge but also enables different ways of sharing code between
    the server and the client.
  prefs: []
  type: TYPE_NORMAL
- en: With React in particular, the concept of isomorphic web applications became
    very popular within the JavaScript community. Writing an **isomorphic application**
    means building an application that looks the same on the server and the client.
    The fact that the same language is used to write the two applications means that
    a big part of the logic can be shared, which opens many possibilities. This makes
    the code base easier to reason about and avoids unnecessary duplication.
  prefs: []
  type: TYPE_NORMAL
- en: React brings the concept a step forward, giving us a simple API to render our
    components on the server and transparently applying all the logic needed to make
    the page interactive (for example, event handlers) on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term *isomorphic* does not fit in this scenario because, in the case of
    React, the applications are the same, and that is why one of the creators of React
    Router, Michael Jackson, proposed a more meaningful name for this pattern: **universal**.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we delve into the specific reasons for implementing universal server-side
    rendering, let us take a moment to pause and ensure that we possess a solid understanding
    of when and why this feature might be necessary for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Reasons for implementing SSR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSR is a great feature, but we should not jump into it just for the sake of
    it. We should have a real, solid reason to start using it.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting SSR without a clear purpose can introduce unwarranted complexities
    and issues into your application. The intricacies of SSR can complicate aspects
    such as managing states, data fetching, and routing, among others. Additionally,
    SSR puts an increased load on the server as it is responsible for rendering HTML
    for each request. If not carefully optimized, this can result in slower response
    times and higher server costs.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the added complexity that SSR brings to an application can slow down
    the development process, complicate debugging, and require maintenance of specific
    tools and configurations. Furthermore, if your application does not have a significant
    amount of public content, the SEO benefits that often drive the adoption of SSR
    may not be substantial.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, while SSR can offer benefits, it is crucial to implement it with
    a clear understanding of its trade-offs. Carefully assess your application’s needs
    and consider the advantages against the potential disadvantages before deciding
    to adopt SSR.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing SEO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main reasons why we may want to render our applications on the server
    side is SEO. If we serve an empty HTML skeleton to the crawlers of the main search
    engines, they are not able to extract any meaningful information from it. Nowadays,
    Google seems to be able to run JavaScript, but there are some limitations, and
    SEO is often a critical aspect of our businesses.
  prefs: []
  type: TYPE_NORMAL
- en: 'For years, we used to write two applications: an SSR one for the crawlers,
    and another one to be used on the client side by users. We used to do that because
    SSR applications could not give us the level of interactivity users expect, while
    client-side applications did not get indexed by search engines.'
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining and supporting two applications is difficult and makes the code
    base less flexible and less prone to changes. Luckily, with React, we can render
    our components on the server side and serve the content of our applications to
    the crawlers in such a way that it is easy for them to understand and index the
    content.
  prefs: []
  type: TYPE_NORMAL
- en: This is great, not only for SEO but also for social sharing services. Platforms
    such as Facebook or Twitter give us a way of defining the content of the snippets
    that is shown when our pages are shared.
  prefs: []
  type: TYPE_NORMAL
- en: For example, using Open Graph, we can tell Facebook that, for a particular page,
    we want a certain image to be shown and a particular title to be used as the title
    of the post. It is almost impossible to do that using client-side-only applications
    because the engine that extracts the information from the pages uses the markup
    returned by the server.
  prefs: []
  type: TYPE_NORMAL
- en: If our server returns an empty HTML structure for all the URLs, the result is
    that when the pages are shared on social networks, the snippets of our web application
    are empty as well, which affects their virality.
  prefs: []
  type: TYPE_NORMAL
- en: A common code base
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Utilizing JavaScript on both the client and server sides of an application offers
    numerous benefits. Firstly, it simplifies matters by employing the same language
    across all components. This streamlines the process of maintaining a well-functioning
    system and facilitates knowledge sharing among colleagues within the company.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, sharing code between the frontend and backend of a website eliminates
    the need for redundant efforts. As a result, this approach generally reduces the
    occurrence of mistakes and issues.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, maintaining a single code base is more manageable compared to handling
    two separate ones. Additionally, incorporating JavaScript on the server side enhances
    collaboration between frontend and backend developers. By leveraging the same
    language, they can efficiently reuse code and make prompt decisions, thereby enhancing
    workflow and productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Better performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Last but not least, we all love client-side applications because they are fast
    and responsive, but there is a problem—the bundle has to be loaded and run before
    users can take any action on the application.
  prefs: []
  type: TYPE_NORMAL
- en: This might not be a problem using a modern laptop or a desktop computer with
    a fast internet connection. However, if we load a huge JavaScript bundle using
    a mobile device with a 3G connection, users have to wait for a little while before
    interacting with the application. This is not only bad for the UX in general but
    it also affects conversions. It has been proven by major e-commerce websites that
    a few milliseconds added to the page load can have an enormous impact on revenues.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we serve our application with an empty HTML page and a script
    tag on the server and we show a spinner to our users until they can click on anything,
    the perception of the speed of the website is significantly affected.
  prefs: []
  type: TYPE_NORMAL
- en: If we render our website on the server side instead and users start seeing some
    of the content as soon as they hit the page, they are more likely to stay, even
    if they have to wait the same amount of time before doing anything for real, because
    the client-side bundle has to be loaded regardless of the SSR.
  prefs: []
  type: TYPE_NORMAL
- en: This perceived performance is something we can improve greatly using SSR because
    we can output our components on the server and return some information to users
    straight away.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t underestimate the complexity of SSR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though React provides an easy API to render components on the server, creating
    a universal application has a cost. So, we should consider carefully before enabling
    it for one of the preceding reasons and check whether our team is ready to support
    and maintain a universal application.
  prefs: []
  type: TYPE_NORMAL
- en: SSR can incur additional costs, extending development time and adding complexity.
    It also increases the server load, potentially necessitating costlier infrastructure.
    Operationally, SSR requires a well-maintained server with a complete setup, leading
    to increased operational costs. Additionally, testing may become more time-consuming
    due to the heightened complexity.
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to strike a balance between these costs and the potential benefits
    of SSR, such as improved SEO and faster initial page loads.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through the upcoming sections, we will discover that rendering
    components is not the sole task involved in creating server-side-rendered applications.
    We must establish and maintain a server with its routes and logic, manage the
    server data flow, and perform various other essential tasks to sustain a fully
    functional universal application. Consider caching content to serve pages more
    efficiently and address other necessary responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, my recommendation is to initially focus on constructing the client-side
    version of your web application. Once it is fully functional and performs well
    on the server, you can then consider incorporating SSR to enhance the user experience.
    It is essential to enable SSR only when genuinely required. For instance, if improving
    your website’s visibility in search engines (SEO) is a priority, that is when
    you should begin contemplating the implementation of SSR.
  prefs: []
  type: TYPE_NORMAL
- en: If you realize that your application takes a lot of time to load fully and you
    have already done all the optimization (refer to *Chapter 16*, *Improving the
    Performance of Your Applications*, for more on this topic), you can consider using
    SSR to offer a better experience to your users and improve the perceived speed.
    Now that we have learned what SSR is and the benefits of universal applications,
    let’s jump into some basic examples of SSR in our next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic example of SSR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create a very simple server-side application to look at the steps
    that are needed to build a basic universal setup. It is going to be a minimal
    and simple setup on purpose because the goal here is to show how SSR works rather
    than providing a comprehensive solution or a boilerplate, even though you could
    use the example application as a starting point for a real-world application.
  prefs: []
  type: TYPE_NORMAL
- en: This section assumes that readers have a basic understanding of Node.js and
    are familiar with the concepts related to JavaScript build tools, such as **webpack**
    and its loaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will consist of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, where we will use Express to create a basic web server and
    serve an HTML page with the server-side-rendered React application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the client side, where we will render the application, as usual, using `react-dom`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring our project from scratch with webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both sides of the application will be transpiled with Babel and bundled with
    webpack before being run, which will let us use the full power of ES6 and the
    modules both on Node.js and on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new project folder (you can call it `ssr-project`)
    and running the following command to create a new package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `package.json` is created, it is time to install the dependencies. We
    can start with webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After this is done, it is time to install `ts-loader` and the presets that
    we need to write an ES6 application using React and TSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to create the server bundle, we need to install a dependency. Webpack
    allows us to define a set of externals, which are dependencies that we do not
    want to include in the bundle. When generating a build for the server, it is preferable
    not to include all the `Node.js` packages used; instead, we only want to bundle
    our server code. Excluding dependencies from the server bundle offers several
    advantages, including reduced bundle size, faster compilation, and compatibility
    with the Node.js environment. By leveraging the native module system of Node.js,
    the server code can directly access the installed packages without the need for
    bundling. Tools like `webpack-node-externals` assist in defining these dependencies
    as externals in the webpack configuration, resulting in an optimized server bundle
    and a streamlined build process. Let’s proceed with the installation of this tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Great. It is now time to create an entry in the npm scripts section of `package.json`
    so that we can easily run the `build` command from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to create a `.babelrc` file in your root path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We now have to create the configuration file, called `webpack.config.js`, to
    tell webpack how we want our files to be bundled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by importing the library we will use to set our node externals.
    We will also define the configuration for `ts-loader`, which we will use for both
    the client and the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In *Chapter 6*, *Making Your Components Look Beautiful*, we looked at how we
    had to export a configuration object from the configuration file. There is one
    cool feature in webpack that lets us export an array of configurations as well
    so that we can define both client and server configurations in the same place
    and use both in one go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client configuration shown in the following block should be very familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We are telling webpack that the source code of the client application is inside
    the `src` folder, and we want the output bundle to be generated in the `dist`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also set the module loaders using the previous object we created with `ts-loader`.
    The server configuration is slightly different; we need to define a different
    entry, and add some new nodes, such as `target`, `externals`, and `resolve`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `entry`, `output`, and `module` are the same, except for the
    filenames.
  prefs: []
  type: TYPE_NORMAL
- en: The new parameters are the target, where we specify the node to tell webpack
    to ignore all the built-in system packages of Node.js, such as `fs`, and `externals`,
    where we use the library we imported earlier to tell webpack to ignore the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we have to export the configurations as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The configuration is done. We are now ready to write some code, and we will
    start with the React application, which we are more familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create an `src` folder and an `app.ts` file inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `app.ts` file should have the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Nothing complex here; we import React, create an `App` component, which renders
    the `Hello React` message, and export it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create `client.tsx`, which is responsible for rendering the `App`
    component inside the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Again, this should sound familiar, since we import React, ReactDOM, and the
    `App` component we created earlier, and we use ReactDOM to render it in a DOM
    element with the app ID.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to create a `template.ts` file, which exports a function
    that we will use to return the markup of the page that our server will give back
    to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It should be pretty straightforward. The function accepts `body`, which we will
    later see contains the React app, and it returns the skeleton of the page.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that we load the bundle on the client side even if the app
    is rendered on the server side. SSR is only half of the job that React does to
    render our application. We still want our application to be a client-side application,
    with all the features we can use in the browser, such as event handlers, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, you need to install `express`, `react`, and `react-dom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to create `server.tsx`, which has more dependencies and is worth
    exploring in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that we import is `express`, the library that allows us to create
    a web server with some routes easily, and which is also able to serve static files.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we import React and ReactDOM to render `App`, which we import as well.
    Notice the `/server` path in the `import` statement of ReactDOM. The last thing
    we import is the template we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we create an Express application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We tell the application where our static assets are stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, the path is the same that we used in the client configuration
    of webpack as the output destination of the client bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, here comes the logic of SSR with React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are telling Express that we want to listen to the `/` route, and when it
    gets hit by a client, we render `App` to a string using the ReactDOM library.
    Here comes the magic and simplicity of the SSR of React.
  prefs: []
  type: TYPE_NORMAL
- en: What `renderToString` does is return a string representation of the DOM elements
    generated by our `App` component, the same tree that it would render in the DOM
    if we were using the ReactDOM `render` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the `body` variable is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it represents what we defined in the `render` method of `App`,
    except for a couple of data attributes that React uses on the client to attach
    the client-side application to the server-side-rendered string.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the SSR representation of our app, we can use the `template`
    function to apply it to the HTML template and send it back to the browser within
    the Express response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we have to start the Express application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to go; there are only a few operations left. The first one
    is to define the start script of npm and set it to run the node server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The scripts are ready, so we can first build the application with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When the bundles are created, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Point the browser to `http://localhost:3000` and see the result.
  prefs: []
  type: TYPE_NORMAL
- en: There are two important things to note here. First, when we use the **View Page
    Source** feature of the browser, we can see the source code of the application
    being rendered and returned from the server, which we would not see if SSR was
    not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Second, if we open DevTools and we have the React extension installed, we can
    see that the `App` component has been booted on the client as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the source of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, website  Description automatically
    generated](img/B18414_12_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Source code page'
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now that you have created your first React application using SSR, let’s
    learn how to fetch data in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing data fetching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example in the previous section should clearly explain how to set up a universal
    application in React. It is pretty straightforward, and the main focus is on getting
    things done. However, in a real-world application, we will likely want to load
    some data instead of a static React component, such as `App` in the example.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume, for example, we want to load Dan Abramov’s gists on the server
    and return the list of items from the Express app we just created.
  prefs: []
  type: TYPE_NORMAL
- en: In the data fetching examples in *Chapter 12*, *Managing Data*, we looked at
    how we can use `useEffect` to fire the data loading. That wouldn’t work on the
    server because components do not get mounted on the DOM and the life cycle Hook
    never gets fired.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks that were executed earlier will not work either because the data
    fetching operation is async, while `renderToString` is not. For that reason, we
    have to find a way to load the data beforehand and pass it to the component as
    props.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how we can take the application from the previous section and
    change it a bit to make it load gists during the SSR phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to change **App.tsx** to accept a list of `gists`
    as `props`, and loop through it in the `render` method to display their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Applying the concept that we learned in the previous chapter, we define a stateless
    functional component, which receives `gists` as `props` and loops through the
    elements to render a list of items. Now, we have to change the server to retrieve
    `gists` and pass them to the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `fetch` API on the server side, we have to install a library called
    `isomorphic-fetch`, which implements the fetch standards. It can be used in Node.js
    and the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We first import the library into `server.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The API call that we want to make looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, gists are available to be used inside the last `then` function. In our
    case, we want to pass them down to `App`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can change the `/` route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first fetch `gists`, and then we render `App` as a string, passing
    the property.
  prefs: []
  type: TYPE_NORMAL
- en: Once `App` is rendered and we have its markup, we use the template we used in
    the previous section and return it to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in the console and point the browser to `http://localhost:3000`.
    You should be able to see a `server-side render` list of `gists`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To make sure that the list is rendered from the Express app, you can navigate
    to `view-source:http://localhost:3000` and you will see the markup and the descriptions
    of gists.
  prefs: []
  type: TYPE_NORMAL
- en: That is great, and it looks easy, but if we check the DevTools console, we can
    see `Cannot read property 'map' of undefined error`. The reason we see the error
    is that, on the client, we are rendering `App` again, but without passing `gists`
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: This could sound counter-intuitive in the beginning because we might think that
    React is smart enough to use `gists` rendered within the server-side string on
    the client. But that is not what happens, so we have to find a way to make `gists`
    available on the client side as well.
  prefs: []
  type: TYPE_NORMAL
- en: You may consider that you could execute the fetch again on the client. That
    would work, but it is not optimal because you would end up firing two HTTP calls,
    one on the Express server and one in the browser. If we think about it, we already
    made the call on the server, and we have all the data we need. A typical solution
    to sharing data between the server and the client is dehydrating the data in the
    HTML markup and hydrating it back in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: This seems like a complex concept, but it is not. We will now look at how easy
    it is to implement. The first thing we must do is inject `gists` into the template
    after we have fetched them on the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we have to change the template slightly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `template` function now accepts two parameters—the `body` of the app and
    the collection of `gists`. The first one is inserted into the `app` element, while
    the second is used to define a global `gists` variable attached to the `window`
    object so that we can use it in the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the Express route (`server.ts`), we just have to change the line where
    we generate the template passing the body, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, we have to use gists attached to a window inside **client.tsx**,
    which is pretty easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The hydrate method was introduced in React 16 and works similarly to `render`
    on the client side, irrespective of whether the HTML has server-side-rendered
    markup or not. If there is no markup previously using SSR, then the `hydrate`
    method will fire a warning, which you can silence by using the new `suppressHydrationWarning`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: We read `gists` directly, and we pass them to the `App` component that gets
    rendered on the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If we point the browser window to `http://localhost:3000`, the error is gone,
    and if we inspect the `App` component using React DevTools, we can see how the
    client-side `App` component receives the collection of gists.
  prefs: []
  type: TYPE_NORMAL
- en: As we have created our first SSR application, let’s now see how we can do this
    more easily by using an SSR framework called Next.js in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Next.js to create a React application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have looked at the basics of SSR with React, and you can use the project
    we created as a starting point for a real app. However, you may think that there
    is too much boilerplate and that you are required to know about too many different
    tools to run a simple universal application with React. This is a common feeling
    called **JavaScript fatigue**, as described in the introduction to this book.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Meta developers and other companies in the React community are working
    very hard to improve the DX and make the lives of developers easier. You might
    have used `create-react-app` at this point to try out the examples in the previous
    chapters, and you should understand how it makes it very simple to create React
    applications without requiring developers to learn about many technologies and
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Now, `create-react-app` does not support SSR yet, but there’s a company called
    **Vercel** that has created a tool called **Next.js**, which makes it incredibly
    easy to generate universal applications without worrying about configuration files.
    It also reduces the boilerplate a lot.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to say that using abstractions is always very good for building
    applications quickly. However, it is crucial to know how the internals work before
    adding too many layers, and that is why we started with the manual process before
    learning Next.js. We have looked at how SSR works and how we can pass the state
    from the server to the client. Now that the base concepts are clear, we can move
    on to a tool that hides a little bit of complexity and makes us write less code
    to achieve the same results.
  prefs: []
  type: TYPE_NORMAL
- en: We will create the same app where all gists from Dan Abramov are loaded, and
    you will see how clean and simple the code is, thanks to Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, create a new project folder (you can call it `next-project`)
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is done, we can install the Next.js library and React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the project is created, we have to add an npm script to run the binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! It is now time to generate our `App` component. Next.js is based on
    conventions, with the most important one being that you can create pages to match
    the browser URLs. The default page is `index`, so we can create a folder called
    `pages` and put an `index.js` file inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start importing the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Again, we import `isomorphic-fetch` because we want to be able to use the `fetch`
    function on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define a component called `App`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Then we define a static async function, called `getInitialProps`, which is where
    we tell Next.js which data we want to load, both on the server side and on the
    client side. The library will make the object returned from the function available
    as props inside the component.
  prefs: []
  type: TYPE_NORMAL
- en: The `stati`c and `async` keywords applied to a class method mean that the function
    can be accessed outside the instance of the class and that the function yields
    the execution of the `wait` instructions inside its body.
  prefs: []
  type: TYPE_NORMAL
- en: These concepts are pretty advanced, and they are not part of the scope of this
    chapter, but if you are interested in them, you should check out the ECMAScript
    proposals ([https://github.com/tc39/proposals](https://github.com/tc39/proposals)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the method we just described is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We are telling the function to fire the `fetch` and wait for the response, then
    we are transforming the response into JSON, which returns a promise. When the
    promise is resolved, we can return the `props` object with `gists`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The render of the component looks pretty similar to the preceding one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you run the project, you need to configure `tsconfig.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the console and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If we point the browser to that URL, we can see the universal application in
    action. It is really impressive how easy it is to set up a universal application
    with a few lines of code and zero configuration, thanks to Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: You may also notice that if you edit the application inside your editor, you
    will be able to see the results within the browser instantly without needing to
    refresh the page. That is another feature of Next.js, which enables hot module
    replacement. It is incredibly useful in development mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you liked this chapter, go and give it a star on GitHub: [https://github.com/zeit/next.js](https://github.com/zeit/next.js).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The journey through SSR has come to an end. You are now able to create a server-side-rendered
    application with React, and it should be clear why it can be useful for you. SEO
    is certainly one of the main reasons, but social sharing and performance are important
    factors as well. You learned how it is possible to load the data on the server
    and dehydrate it in the HTML template to make it available to the client-side
    application when it boots on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you looked at how tools such as Next.js can help you reduce the boilerplate
    and hide some of the complexity that setting up a server-side-rendered React application
    usually brings to the code base.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about how to improve the performance of our
    React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/React18DesignPatterns4e](https://packt.link/React18DesignPatterns4e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2450023176943770109.png)'
  prefs: []
  type: TYPE_IMG
