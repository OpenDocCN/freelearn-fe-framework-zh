- en: <st c="0">3</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">3</st>
- en: <st c="2">Writing Effective Unit Tests for Angular Components, Services, and
    Directives</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">为 Angular 组件、服务和指令编写有效的单元测试</st>
- en: <st c="79">In this chapter, we’re going to dive into the art of writing effective
    unit tests for Angular components, services, and directives.</st> <st c="212">We’ll
    dive into writing unit tests for Angular components, continuing what we started
    in the previous chapter.</st> <st c="323">Components are the building blocks of
    Angular applications, and it’s crucial to test them thoroughly.</st> <st c="425">In
    this chapter, we’ll learn how to set up test environments, create component instances,
    and test component properties, methods, and event handling.</st> <st c="575">We’ll
    also explore techniques for testing component models, including DOM manipulation
    and</st> <st c="666">event simulation.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="79">在本章中，我们将深入探讨如何为 Angular 组件、服务和指令编写有效的单元测试。</st> <st c="212">我们将继续上一章的内容，深入编写
    Angular 组件的单元测试。</st> <st c="323">组件是 Angular 应用程序的基本构建块，彻底测试它们至关重要。</st> <st
    c="425">在本章中，我们将学习如何设置测试环境，创建组件实例，并测试组件属性、方法和事件处理。</st> <st c="575">我们还将探讨测试组件模型的技术，包括
    DOM 操作和</st> <st c="666">事件模拟。</st>
- en: <st c="683">We’ll also be focusing on unit testing Angular services.</st> <st
    c="741">Services play an essential role in Angular applications, providing reusable
    logic and data manipulation.</st> <st c="846">We’ll learn how to create service
    instances, simulate test service methods, and carry out</st> <st c="936">data
    manipulation.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="683">我们还将关注 Angular 服务的单元测试。</st> <st c="741">服务在 Angular 应用程序中扮演着至关重要的角色，提供可重用的逻辑和数据操作。</st>
    <st c="846">我们将学习如何创建服务实例，模拟测试服务方法，并进行</st> <st c="936">数据操作。</st>
- en: <st c="954">Finally, we’ll look at unit testing Angular directives.</st> <st
    c="1011">Directives are powerful tools for manipulating the DOM and improving
    the behavior of our applications.</st> <st c="1114">We’ll learn how to set up
    test environments for directives, create directive instances, and test their behavior
    and interaction with</st> <st c="1247">the DOM.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="954">最后，我们将探讨如何对 Angular 指令进行单元测试。</st> <st c="1011">指令是操作 DOM 和改进我们应用程序行为的强大工具。</st>
    <st c="1114">我们将学习如何为指令设置测试环境，创建指令实例，并测试其行为以及与</st> <st c="1247">DOM 的交互。</st>
- en: <st c="1255">Throughout this chapter, I’ll provide practical examples and real-world
    scenarios to illustrate effective unit-testing concepts and techniques.</st> <st
    c="1400">We’ll also discuss common unit-testing pitfalls and challenges and provide
    strategies for</st> <st c="1490">overcoming them.</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1255">在本章中，我将提供实际示例和真实场景，以说明有效的单元测试概念和技术。</st> <st c="1400">我们还将讨论常见的单元测试陷阱和挑战，并提供克服它们的策略。</st>
- en: <st c="1506">In summary, here are the main topics that will</st> <st c="1554">be
    covered:</st>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1506">总结来说，以下是一些主要话题，我们将</st> <st c="1554">进行探讨：</st>
- en: '<st c="1565">Advanced techniques for Angular unit testing: lifecycle hooks</st>
    <st c="1628">and dependencies</st>'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1565">Angular 单元测试的高级技术：生命周期钩子和</st> <st c="1628">依赖关系</st>
- en: <st c="1644">Advanced techniques for Angular unit testing:</st> <st c="1691">Angular
    services</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1644">Angular 单元测试的高级技术：</st> <st c="1691">Angular 服务</st>
- en: <st c="1707">Using rigorous directive testing to ensure proper rendering</st>
    <st c="1768">and functionality</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1707">使用严格的指令测试来确保适当的渲染</st> <st c="1768">和功能</st>
- en: <st c="1785">By the end of this chapter, you’ll have a solid understanding of
    how to write effective unit tests for Angular components, services, and directives.</st>
    <st c="1935">You’ll be equipped with the knowledge and tools you need to ensure
    the quality and reliability of your Angular code.</st> <st c="2052">So, let’s
    dive in and master the art of writing effective unit tests for</st> <st c="2125">Angular
    applications.</st>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1785">在本章结束时，你将牢固地理解如何为 Angular 组件、服务和指令编写有效的单元测试。</st> <st c="1935">你将具备确保
    Angular 代码质量和可靠性的知识和工具。</st> <st c="2052">因此，让我们深入探讨，掌握编写有效单元测试的技巧，以</st> <st
    c="2125">Angular 应用程序。</st>
- en: <st c="2146">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2146">技术要求</st>
- en: <st c="2169">To follow along with the examples and exercises in this chapter,
    you will need to have a basic understanding of Angular and TypeScript, as well
    as</st> <st c="2317">the following:</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2169">为了跟随本章中的示例和练习，你需要对 Angular 和 TypeScript 有基本的了解，以及</st> <st c="2317">以下内容：</st>
- en: <st c="2331">Node.js and npm installed on</st> <st c="2361">your computer</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的计算机上安装了Node.js和npm
- en: <st c="2374">Angular CLI</st> <st c="2387">installed globally</st>
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局安装Angular CLI
- en: <st c="2405">A code editor, such as Visual Studio Code, installed on</st> <st
    c="2462">your computer</st>
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的计算机上安装了代码编辑器，例如Visual Studio Code
- en: <st c="2475">The code files of this chapter can be found</st> <st c="2520">at</st>
    [<st c="2523">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%203</st>](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%203)<st
    c="2621">.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[该章节的代码文件可以在以下位置找到](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%203)<st
    c="2621">。</st>'
- en: <st c="2622">Advanced techniques for Angular unit testing – lifecycle hooks</st>
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Angular单元测试技术 – 生命周期钩子
- en: <st c="2685">In this section, we will understand how to leverage lifecycle hooks
    and manage dependencies in our unit tests for Angular components.</st> <st c="2820">You’ll
    be empowered with the knowledge and skills you need to write robust and efficient
    unit tests, ensuring the quality and stability of your Angular applications.</st>
    <st c="2986">Let’s dive in and explore advanced unit-testing techniques for</st>
    <st c="3049">Angular components.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何利用生命周期钩子来管理Angular组件的单元测试中的依赖关系。<st c="2820">您将获得编写健壮和高效单元测试所需的知识和技能，以确保您的Angular应用程序的质量和稳定性。</st>
    <st c="2986">让我们深入探讨Angular组件的高级单元测试技术。</st>
- en: <st c="3068">Discovering lifecycle hooks</st>
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现生命周期钩子
- en: <st c="3096">Angular provides several</st> <st c="3121">lifecycle hooks that
    allow us to perform actions at specific stages of a component’s lifecycle.</st>
    <st c="3218">Testing these hooks ensures that our components behave as expected.</st>
    <st c="3286">But before we look deeper into the subject of the testing lifecycle,
    let’s</st> <st c="3360">take a look at some of Angular’s</st> <st c="3394">lifecycle
    methods:</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了几个生命周期钩子，允许我们在组件生命周期的特定阶段执行操作。<st c="3218">测试这些钩子确保我们的组件按预期行为。</st>
    <st c="3286">但在我们深入探讨测试生命周期的主题之前，让我们</st> <st c="3360">看看一些Angular的</st> <st c="3394">生命周期方法：</st>
- en: '`<st c="3412">ngOnInit()</st>`<st c="3423">: The</st> `<st c="3430">ngOnInit()</st>`
    <st c="3440">hook is called</st> <st c="3456">after the component has been initialized.</st>
    <st c="3498">In our</st> `<st c="3505">Calculator</st>` <st c="3515">component,
    we can use this hook to set the initial values and perform any necessary setup.</st>
    <st c="3607">To test</st> `<st c="3615">ngOnInit()</st>`<st c="3625">, we can
    verify whether the initial values are correctly set and whether any necessary
    setup</st> <st c="3718">is performed.</st>'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="3412">ngOnInit()</st>`<st c="3423">: The</st> `<st c="3430">ngOnInit()</st>`
    <st c="3440">hook is called</st> <st c="3456">after the component has been initialized.</st>
    <st c="3498">In our</st> `<st c="3505">Calculator</st>` <st c="3515">component,
    we can use this hook to set the initial values and perform any necessary setup.</st>
    <st c="3607">To test</st> `<st c="3615">ngOnInit()</st>`<st c="3625">, we can
    verify whether the initial values are correctly set and whether any necessary
    setup</st> <st c="3718">is performed.</st>'
- en: '`<st c="3731">ngOnChanges()</st>`<st c="3745">: The</st> `<st c="3752">ngOnChanges()</st>`
    <st c="3765">hook is called whenever there are changes to the component’s input</st>
    <st c="3833">properties.</st> <st c="3845">In our</st> `<st c="3852">Calculator</st>`
    <st c="3862">component, we can use this hook to update the component state based
    on the changes.</st> <st c="3947">To test</st> `<st c="3955">ngOnChanges()</st>`<st
    c="3968">, we can simulate changes to the input properties and verify whether
    the component state is</st> <st c="4060">updated accordingly.</st>'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="3731">ngOnChanges()</st>`<st c="3745">: The</st> `<st c="3752">ngOnChanges()</st>`
    <st c="3765">hook is called whenever there are changes to the component’s input</st>
    <st c="3833">properties.</st> <st c="3845">In our</st> `<st c="3852">Calculator</st>`
    <st c="3862">component, we can use this hook to update the component state based
    on the changes.</st> <st c="3947">To test</st> `<st c="3955">ngOnChanges()</st>`<st
    c="3968">, we can simulate changes to the input properties and verify whether
    the component state is</st> <st c="4060">updated accordingly.</st>'
- en: '`<st c="4080">ngOnDestroy()</st>`<st c="4094">: The</st> `<st c="4101">ngOnDestroy()</st>`
    <st c="4114">hook is called</st> <st c="4130">just before the component is destroyed.</st>
    <st c="4170">In our</st> `<st c="4177">Calculator</st>` <st c="4187">component,
    we can use this hook to clean up any resources or subscriptions.</st> <st c="4264">To
    test</st> `<st c="4272">ngOnDestroy()</st>`<st c="4285">, we can simulate the
    component destruction and verify whether the necessary cleanup actions</st> <st
    c="4378">are performed.</st>'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="4080">ngOnDestroy()</st>`<st c="4094">: The</st> `<st c="4101">ngOnDestroy()</st>`
    <st c="4114">hook is called</st> <st c="4130">just before the component is destroyed.</st>
    <st c="4170">In our</st> `<st c="4177">Calculator</st>` <st c="4187">component,
    we can use this hook to clean up any resources or subscriptions.</st> <st c="4264">To
    test</st> `<st c="4272">ngOnDestroy()</st>`<st c="4285">, we can simulate the
    component destruction and verify whether the necessary cleanup actions</st> <st
    c="4378">are performed.</st>'
- en: <st c="4392">In the next section, we will learn how to test the dependencies
    present in an</st> <st c="4471">Angular component.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4392">在下一节中，我们将学习如何测试 Angular 组件中存在的依赖关系。</st>
- en: <st c="4489">Practical application</st>
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="4489">实际应用</st>
- en: <st c="4511">We will continue our project from the</st> <st c="4549">previous
    chapter, namely the Calculator application.</st> <st c="4603">We’ll start testing
    the expected behavior when we initialize our calculator.</st> <st c="4680">When
    our calculator is launched, the result displayed should be</st> `<st c="4744">0</st>`<st
    c="4745">, since no operation has been performed.</st> <st c="4786">To do this,
    we’ll test the</st> `<st c="4813">ngOnInit()</st>` <st c="4823">method of the
    Angular lifecycle, which allows us to initialize</st> <st c="4887">our component.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4511">We will continue our project from the</st> <st c="4549">previous
    chapter, namely the Calculator application.</st> <st c="4603">We’ll start testing
    the expected behavior when we initialize our calculator.</st> <st c="4680">When
    our calculator is launched, the result displayed should be</st> `<st c="4744">0</st>`<st
    c="4745">, since no operation has been performed.</st> <st c="4786">To do this,
    we’ll test the</st> `<st c="4813">ngOnInit()</st>` <st c="4823">method of the
    Angular lifecycle, which allows us to initialize</st> <st c="4887">our component.</st>
- en: <st c="4901">In</st> `<st c="4905">calculator.component.spec.ts</st>`<st c="4933">,
    we will add the following</st> <st c="4961">unit t</st><st c="4967">est:</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4901">在</st> `<st c="4905">calculator.component.spec.ts</st>`<st c="4933">中，我们将添加以下</st>
    <st c="4961">单元测试</st><st c="4967">:</st>
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="5081">After writing this code snippet, you’ll notice that there are errors
    in the code because</st> `<st c="5171">result</st>` <st c="5177">is not an attribute
    of the</st> `<st c="5205">Calculator</st>` <st c="5215">class:</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5081">编写此代码片段后，你会注意到代码中有错误，因为</st> `<st c="5171">result</st>` <st c="5177">不是</st>
    `<st c="5205">Calculator</st>` <st c="5215">类的属性：</st>
- en: '![Figure 3.1 – ngOnInit method test case with error](img/B21146_03_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – ngOnInit 方法测试用例出错](img/B21146_03_1.jpg)'
- en: <st c="5331">Figure 3.1 – ngOnInit method test case with error</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5331">图 3.1 – ngOnInit 方法测试用例出错</st>
- en: <st c="5380">Don’t forget the principles of TDD.</st> <st c="5417">It’s normal
    for the test to fail in the first instance and then for you to write the minimum
    amount of code necessary for the test to succeed.</st> <st c="5560">In the meantime,
    we need to rectify the problem with our</st> `<st c="5617">result</st>` <st c="5623">class
    attribute by declaring it in</st> <st c="5659">our component.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5380">Don’t forget the principles of TDD.</st> <st c="5417">It’s normal
    for the test to fail in the first instance and then for you to write the minimum
    amount of code necessary for the test to succeed.</st> <st c="5560">In the meantime,
    we need to rectify the problem with our</st> `<st c="5617">result</st>` <st c="5623">class
    attribute by declaring it in</st> <st c="5659">our component.</st>
- en: <st c="5673">Our component</st> <st c="5687">should now look</st> <st c="5704">like
    this:</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5673">我们的组件</st> <st c="5687">现在应该看起来像这样：</st>
- en: '![Figure 3.2 – Adding the add method in calculator.component.ts](img/B21146_03_2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 在 calculator.component.ts 中添加 add 方法](img/B21146_03_2.jpg)'
- en: <st c="6054">Figure 3.2 – Adding the add method in calculator.component.ts</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6054">图 3.2 – 在 calculator.component.ts 中添加 add 方法</st>
- en: <st c="6115">Now that the declaration issue has been resolved, let’s focus on
    our red test.</st> <st c="6195">We have an error telling us that the result should
    be initialized</st> <st c="6261">to</st> `<st c="6264">0</st>`<st c="6265">:</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6115">现在声明问题已经解决，让我们专注于我们的红色测试。</st> <st c="6195">我们得到一个错误，告诉我们结果应该初始化为</st>
    <st c="6261">到</st> `<st c="6264">0</st>`<st c="6265">:</st>
- en: '![Figure 3.3 – calculator.component.ts test failed](img/B21146_03_3.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – calculator.component.ts 测试失败](img/B21146_03_3.jpg)'
- en: <st c="6953">Figure 3.3 – calculator.component.ts test failed</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6953">图 3.3 – calculator.component.ts 测试失败</st>
- en: <st c="7001">To fix this, we</st> <st c="7018">just need to initialize the</st>
    `<st c="7046">result</st>` <st c="7052">value to</st> `<st c="7062">0</st>` <st
    c="7063">in our</st> `<st c="7071">ngOnInit()</st>` <st c="7081">method:</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7001">为了解决这个问题，我们</st> <st c="7018">只需要在我们的</st> `<st c="7046">result</st>`
    <st c="7052">值中初始化</st> `<st c="7062">0</st>` <st c="7063">在我们的</st> `<st c="7071">ngOnInit()</st>`
    <st c="7081">方法中：</st>
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="7127">As a result, our test turns green.</st> <st c="7163">Well done!</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7127">结果，我们的测试变成了绿色。</st> <st c="7163">做得好！</st>
- en: '![Figure 3.4 – calculator.component.ts test succeeded](img/B21146_03_4.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – calculator.component.ts 测试成功](img/B21146_03_4.jpg)'
- en: <st c="7453">Figure 3.4 – calculator.component.ts test succeeded</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7453">图3.4 – calculator.component.ts 测试成功</st>
- en: <st c="7504">We’ve now tested the</st> `<st c="7526">ngOnDestroy()</st>` <st
    c="7539">method of our component’s lifecycle, ensuring that our component is initialized
    with the expected values, while respecting the principles</st> <st c="7678">of
    TDD.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7504">我们现在已经测试了</st> `<st c="7526">ngOnDestroy()</st>` <st c="7539">方法，确保我们的组件以预期的值初始化，同时尊重TDD的原则。</st>
- en: <st c="7685">This is the same philosophy to be adopted for other lifecycle methods.</st>
    <st c="7757">To be able to test our</st> `<st c="7780">ngOnDestroy()</st>` <st
    c="7793">method, we add a small layer to our</st> <st c="7830">business logic.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7685">这是其他生命周期方法应采用的相同哲学。</st> <st c="7757">为了能够测试我们的</st> `<st c="7780">ngOnDestroy()</st>`
    <st c="7793">方法，我们在业务逻辑中添加了一个小层。</st>
- en: <st c="7845">Let’s assume the</st> <st c="7863">following scenario.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7845">让我们假设以下场景。</st>
- en: <st c="7882">We have a service that handles the various arithmetic operations
    of our calculator and returns the result to us.</st> <st c="7996">This service
    is injected into our</st> `<st c="8030">CalculatorComponent</st>` <st c="8049">to
    call the various methods that would return the result following the</st> <st c="8121">arithmetic
    operation.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7882">我们有一个处理计算器各种算术运算并返回结果给我们的服务。</st> <st c="7996">这个服务被注入到我们的</st>
    `<st c="8030">CalculatorComponent</st>` <st c="8049">中，以调用各种方法，这些方法会在算术运算后返回结果。</st>
- en: <st c="8142">As we are used to</st> <st c="8161">by now, we will first initialize
    our</st> `<st c="8198">CalculatorService</st>` <st c="8215">in the test file of</st>
    <st c="8236">our</st> `<st c="8240">CalculatorComponent</st>`<st c="8259">:</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8142">正如我们现在所习惯的，我们首先在我们的</st> `<st c="8198">CalculatorService</st>`
    <st c="8215">测试文件中初始化</st> `<st c="8236">我们的</st> `<st c="8240">CalculatorComponent</st>`<st
    c="8259">：</st>
- en: '![Figure 3.5 – Declaration of an instance of CalculatorService](img/B21146_03_5.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 声明CalculatorService的一个实例](img/B21146_03_5.jpg)'
- en: <st c="8464">Figure 3.5 – Declaration of an instance of CalculatorService</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8464">图3.5 – 声明CalculatorService的一个实例</st>
- en: <st c="8524">Then, since it’s a service, we need to declare it in t</st><st
    c="8579">he</st> `<st c="8583">providers</st>` <st c="8592">array:</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8524">然后，由于它是一个服务，我们需要在</st><st c="8579">t</st> `<st c="8583">providers</st>`
    <st c="8592">数组</st>中声明它：</st>
- en: '![Figure 3.6 – Adding CalculatorService in the providers array](img/B21146_03_6.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 在提供者数组中添加CalculatorService](img/B21146_03_6.jpg)'
- en: <st c="8759">Figure 3.6 – Adding CalculatorService in the providers array</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8759">图3.6 – 在提供者数组中添加CalculatorService</st>
- en: <st c="8819">Finally, we’ll inject it so that it can be used in our descriptive</st>
    <st c="8887">test suites:</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8819">最后，我们将注入它，以便在描述性</st> <st c="8887">测试套件</st>中使用：</st>
- en: '![Figure 3.7 – Injection of CalculatorService in our test context](img/B21146_03_7.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 在测试上下文中注入CalculatorService](img/B21146_03_7.jpg)'
- en: <st c="9216">Figure 3.7 – Injection of CalculatorService in our test context</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9216">图3.7 – 在测试上下文中注入CalculatorService</st>
- en: <st c="9279">We can now create our service so that it is recognized by our test
    file.</st> <st c="9353">In our project’s</st> `<st c="9370">src</st>` <st c="9373">folder,
    create a</st> `<st c="9391">core</st>` <st c="9395">folder containing a</st> `<st
    c="9416">services</st>` <st c="9424">folder.</st> <st c="9433">Basically, you’ll</st>
    <st c="9451">have</st> `<st c="9456">src/core/services</st>`<st c="9473">.</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9279">现在我们可以创建我们的服务，使其被测试文件识别。</st> <st c="9353">在我们的项目的</st> `<st c="9370">src</st>`
    <st c="9373">文件夹中，创建一个包含一个</st> `<st c="9391">core</st>` <st c="9395">文件夹的</st>
    `<st c="9416">services</st>` <st c="9424">文件夹。</st> <st c="9433">基本上，你将</st> <st
    c="9451">拥有</st> `<st c="9456">src/core/services</st>`<st c="9473">。</st>
- en: <st c="9474">Open the</st> `<st c="9484">services</st>` <st c="9492">folder
    in the terminal and run the</st> <st c="9528">following command:</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9474">在终端中打开</st> `<st c="9484">services</st>` <st c="9492">文件夹，并运行以下命令：</st>
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="9564">Once the service has been created, import it into the test file
    and the errors will disappear from your</st> <st c="9669">code editor:</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9564">一旦服务被创建，将其导入测试文件，错误将从你的</st> <st c="9669">代码编辑器中消失：</st>
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="9755">According to our</st> <st c="9773">scenario, the service is now
    in charge of performing arithmetic operations.</st> <st c="9849">So, we’ll move
    the logic o</st><st c="9875">f ou</st><st c="9880">r</st> `<st c="9883">add()</st>`
    <st c="9888">method from the component to</st> <st c="9918">the service.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9755">根据我们的</st> <st c="9773">场景，服务现在负责执行算术运算。</st> <st c="9849">因此，我们将</st>
    <st c="9875">从</st> <st c="9880">我们</st> <st c="9883">的</st> `<st c="9883">add()</st>`
    <st c="9888">方法中移动逻辑到</st> <st c="9918">服务中。</st>
- en: <st c="9930">Here’s how it would look on the</st> <st c="9963">test side:</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9930">这是在</st> <st c="9963">测试端的样子：</st>
- en: '![Figure 3.8 – Add method test case](img/B21146_03_8.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – Add方法测试用例](img/B21146_03_8.jpg)'
- en: <st c="10190">Figure 3.8 – Add method test case</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10190">图3.8 – Add方法测试用例</st>
- en: <st c="10223">We’ve refactored our</st> `<st c="10245">should add two numbers
    correctly</st>` <st c="10277">test suite.</st> <st c="10290">Previously, the calculation
    was performed directly in the component.</st> <st c="10359">Now, it’s transferred
    to a service that takes care of it.</st> <st c="10417">After calculation, the
    service returns the result to</st> <st c="10470">the component.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10223">我们已经重构了我们的</st> `<st c="10245">应该正确添加两个数字</st>` <st c="10277">测试套件。</st>
    <st c="10290">之前，计算是在组件中直接执行的。</st> <st c="10359">现在，它被转移到负责这项工作的服务中。</st> <st
    c="10417">计算后，服务将结果返回给</st> <st c="10470">组件。</st>
- en: <st c="10484">The</st> <st c="10488">service’s</st> `<st c="10498">add()</st>`
    <st c="10504">method must perform the sum and return</st> <st c="10544">the result.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10484">服务的</st> <st c="10488">add()</st> <st c="10498">方法必须执行求和并返回</st>
    <st c="10544">结果。</st>
- en: <st c="10555">The</st> <st c="10559">component’s</st> `<st c="10571">add()</st>`
    <st c="10577">method calls on the</st> <st c="10597">service’s</st> `<st c="10607">add()</st>`
    <st c="10613">method to retrieve</st> <st c="10633">the result.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10555">组件的</st> `<st c="10571">add()</st>` <st c="10577">方法调用服务的</st>
    `<st c="10607">add()</st>` <st c="10613">方法以检索</st> <st c="10633">结果。</st>
- en: <st c="10644">Now we just need to</st> <st c="10664">declare th</st><st c="10675">e</st>
    `<st c="10678">add()</st>` <st c="10683">method in our service, so that our editor
    code no longer</st> <st c="10741">contains errors:</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10644">现在我们只需要</st> <st c="10664">声明</st> <st c="10675">的</st> `<st c="10678">add()</st>`
    <st c="10683">方法在我们的服务中，这样我们的编辑器代码就不再</st> <st c="10741">包含错误：</st>
- en: '![Figure 3.9 – Adding an add method declaration in calculator.service.ts](img/B21146_03_9.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 在calculator.service.ts中添加add方法声明](img/B21146_03_9.jpg)'
- en: <st c="10921">Figure 3.9 – Adding an add method declaration in calculator.service.ts</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10921">图3.9 – 在calculator.service.ts中添加add方法声明](img/B21146_03_9.jpg)
- en: <st c="10991">Our test now compiles and displays</st> <st c="11027">an error:</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10991">我们的测试现在编译并显示</st> <st c="11027">一个错误：</st>
- en: '![Figure 3.10 – add method test case failed](img/B21146_03_10.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – add方法测试用例失败](img/B21146_03_10.jpg)'
- en: <st c="12297">Figure 3.10 – add method test case failed</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12297">图3.10 – add方法测试用例失败</st>
- en: <st c="12338">We can now use the</st> <st c="12357">minimum amount of code necessary
    to turn our service green.</st> <st c="12418">To do this, our</st> <st c="12433">service’s</st>
    `<st c="12443">add()</st>` <st c="12449">method must return a number (we’ll limit
    ourselves to an integer).</st> <st c="12517">It then takes two arguments, namely
    the numbers</st> `<st c="12565">a</st>` <st c="12566">and</st> `<st c="12570">b</st>`<st
    c="12571">:</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12338">我们现在可以使用最少的代码将我们的服务变为绿色。</st> <st c="12357">为此，我们的</st> <st c="12433">服务的</st>
    `<st c="12443">add()</st>` <st c="12449">方法必须返回一个数字（我们将限制自己为整数）。</st> <st c="12517">然后它接受两个参数，即数字</st>
    `<st c="12565">a</st>` <st c="12566">和</st> `<st c="12570">b</st>`<st c="12571">：</st>
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="12609">Finally, it must return the sum of</st> `<st c="12645">a</st>`
    <st c="12646">and</st> `<st c="12650">b</st>`<st c="12651">:</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12609">最后，它必须返回</st> `<st c="12645">a</st>` <st c="12646">和</st> `<st
    c="12650">b</st>`<st c="12651">的和：</st>
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="12704">Now that the work is done on the service side, we need to update
    our component code.</st> <st c="12790">First, we’ll inject the service into our</st>
    <st c="12831">component’s constructor:</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12704">现在工作已经在服务端完成，我们需要更新我们的组件代码。</st> <st c="12790">首先，我们将服务注入到我们的</st>
    <st c="12831">组件构造函数中：</st>
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="12916">Then, our</st> <st c="12926">component’s</st> `<st c="12938">add()</st>`
    <st c="12944">method</st> <st c="12952">becomes this:</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12916">然后，我们的</st> <st c="12926">组件的</st> `<st c="12938">add()`</st>
    <st c="12944">方法</st> <st c="12952">变成这样：</st>
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="13049">If you notice, we’ve gone from a function that returned a</st>
    `<st c="13108">number</st>` <st c="13114">value to a</st> `<st c="13126">void</st>`<st
    c="13130">. The</st> `<st c="13136">result</st>` <st c="13142">value is returned
    directly by our service.</st> <st c="13186">If all goes well, the</st> `<st c="13208">ng
    test</st>` <st c="13215">command returns the</st> <st c="13235">following on</st>
    <st c="13249">the screen:</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13049">如果您注意到，我们已经从返回一个</st> `<st c="13108">数字</st>` <st c="13114">值的函数转变为返回一个</st>
    `<st c="13126">void</st>`<st c="13130">。我们的服务直接返回</st> `<st c="13136">result</st>`
    <st c="13142">值。</st> <st c="13186">如果一切顺利，`<st c="13208">ng test</st>` <st c="13215">命令将在屏幕上返回以下内容：</st>
- en: '![Figure 3.11 – calculator.component.ts test cases succeeded](img/B21146_03_11.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – calculator.component.ts 测试用例成功](img/B21146_03_11.jpg)'
- en: <st c="13585">Figure 3.11 – calculator.component.ts test cases succeeded</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13585">图 3.11 – calculator.component.ts 测试用例成功</st>
- en: <st c="13643">We’ve just carried out a small dependency test using our service.</st>
    <st c="13710">In the next section, we’ll go a little further in relation to the
    tests related to</st> <st c="13793">our service.</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13643">我们刚刚使用我们的服务执行了一个小的依赖测试。</st> <st c="13710">在下一节中，我们将进一步探讨与我们的服务相关的测试。</st>
- en: <st c="13805">Advanced techniques for Angular unit testing – Angular services</st>
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="13805">Angular 单元测试的先进技术 – Angular 服务</st>
- en: <st c="13869">In this section, we will</st> <st c="13895">explore advanced techniques
    for unit testing Angular services.</st> <st c="13958">We will dive into the various
    aspects of testing services, including testing methods, HTTP requests, observables,
    and error handling.</st> <st c="14092">By mastering these techniques, you will
    be able to write comprehensive and robust unit tests for your Angular services,
    ensuring that they perform as expected and handle various</st> <st c="14270">scenarios
    gracefully.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将<st c="13869">探讨用于单元测试 Angular 服务的先进技术。</st> <st c="13895">我们将深入研究测试服务的各个方面，包括测试方法、HTTP
    请求、可观察对象和错误处理。</st> <st c="13958">通过掌握这些技术，您将能够为您的 Angular 服务编写全面且健壮的单元测试，确保它们按预期执行并能优雅地处理各种</st>
    <st c="14270">场景。</st>
- en: <st c="14291">Testing service methods</st>
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="14291">测试服务方法</st>
- en: <st c="14315">Services typically contain</st> <st c="14343">methods that perform
    specific operations or logic.</st> <st c="14394">These methods can be tested individually
    to ensure they produce the expected results.</st> <st c="14480">By mocking any
    dependencies and providing appropriate inputs, you can test the behavior of service
    methods and validate</st> <st c="14600">their output.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14315">服务通常包含</st> <st c="14343">执行特定操作或逻辑的方法。</st> <st c="14394">这些方法可以单独测试以确保它们产生预期的结果。</st>
    <st c="14480">通过模拟任何依赖并提供适当的输入，您可以测试服务方法的行为了解</st> <st c="14600">它们的输出。</st>
- en: <st c="14613">We’ve already started by testing o</st><st c="14648">ur service</st><st
    c="14659">’s</st> `<st c="14663">add()</st>` <st c="14668">method in the previous
    section.</st> <st c="14701">As repetition is educational, we’ll be implementing
    other methods, namely subtraction, multiplication,</st> <st c="14804">and division.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14613">我们在上一节中已经开始了对服务</st><st c="14648">的</st><st c="14659">`add()`</st>
    <st c="14668">方法进行测试。</st> <st c="14701">重复是教育的，我们将实现其他方法，即减法、乘法和除法。</st>
- en: <st c="14817">Let’s open our</st> `<st c="14833">calculator.component.spec.ts</st>`
    <st c="14861">file and continue writing our tests linked to our business logic,
    following</st> <st c="14938">TDD principles.</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14817">让我们打开我们的</st> `<st c="14833">calculator.component.spec.ts</st>`
    <st c="14861">文件，并继续编写与我们的业务逻辑相关的测试，遵循</st> <st c="14938">TDD 原则。</st>
- en: <st c="14953">We’re about to write our red test for subtracting two numbers.</st>
    <st c="15017">As we already have experience with the</st> <st c="15056">addition
    functionality, we can draw inspiration</st> <st c="15104">from it:</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14953">我们将编写我们的红色测试，用于减去两个数字。</st> <st c="15017">由于我们已经有了对</st> <st c="15056">加法功能</st>
    <st c="15104">的经验，我们可以从中汲取灵感：</st>
- en: '![Figure 3.12 – subtract method test code without some errors](img/B21146_03_12.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 没有某些错误的减法方法测试代码](img/B21146_03_12.jpg)'
- en: <st c="15355">Figure 3.12 – subtract method test code without some errors</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15355">图 3.12 – 没有某些错误的减法方法测试代码</st>
- en: <st c="15414">Obviously, we ha</st><st c="15431">ve red because the</st> `<st
    c="15451">subtract</st>` <st c="15459">method doesn’t yet exist.</st> <st c="15486">Our
    test won’t even run.</st> <st c="15511">Let</st><st c="15514">’s take a look at
    our</st> `<st c="15537">calculator.service.ts</st>` <st c="15558">service and
    add it.</st> <st c="15579">Keep in mind that we need to write as little code</st>
    <st c="15629">as possible:</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 明显，我们还没有实现减法方法，因为 `<st c="15451">subtract</st>` 方法还不存在。我们的测试甚至无法运行。让我们看看我们的
    `<st c="15537">calculator.service.ts</st>` 服务并添加它。记住，我们需要尽可能少地编写代码：
- en: '![Figure 3.13 – subtract method declaration in calculator.service.ts](img/B21146_03_13.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – calculator.service.ts 中的减法方法声明](img/B21146_03_13.jpg)'
- en: <st c="15700">Figure 3.13 – subtract method declaration in calculator.service.ts</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – calculator.service.ts 中的减法方法声明
- en: <st c="15766">One the other hand, in our</st> `<st c="15794">calculator.component.spec.ts</st>`<st
    c="15822">, note that there’s less red, but there’s still some, as shown in the</st>
    <st c="15892">following figure:</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 《st c="15766">另一方面，在我们的 `<st c="15794">calculator.component.spec.ts</st>` 中，注意红色变少了，但仍然有一些，如图所示：</st
    c="15892">
- en: "![Figure 3.14 – subtract method test before\uFEFF implementing it in calculator.component.ts](img/B21146_03_14.jpg)"
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – 在 calculator.component.ts 中实现减法方法之前的减法方法测试](img/B21146_03_14.jpg)'
- en: <st c="16152">Figure 3.14 – subtract method test before</st> <st c="16193">implementing
    it in calculator.component.ts</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 在 calculator.component.ts 中实现减法方法之前的减法方法测试
- en: <st c="16236">Our</st> `<st c="16241">calculator.component.ts</st>` <st c="16264">component
    is missing the</st> `<st c="16290">substract()</st>` <st c="16301">method.</st>
    <st c="16310">Just as we did with</st> `<st c="16329">add()</st>`<st c="16335">,
    we’re going to take inspiration</st> <st c="16369">from it:</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 《st c="16236">我们的 `<st c="16241">calculator.component.ts</st>` 组件缺少 `<st c="16290">subtract()</st>`
    方法。</st c="16301">就像我们处理 `<st c="16329">add()</st>` 一样，我们将从中汲取灵感：</st c="16369">
- en: '![Figure 3.15 – Adding the substract method in calculator.component.ts](img/B21146_03_15.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 在 calculator.component.ts 中添加减法方法](img/B21146_03_15.jpg)'
- en: <st c="16474">Figure 3.15 – Adding the substract method in calculator.component.ts</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 在 calculator.component.ts 中添加减法方法
- en: <st c="16542">The result in</st> <st c="16556">our</st> `<st c="16561">calculator.component.spec.ts</st>`
    <st c="16589">test file is</st> <st c="16603">as expected:</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 《st c="16542">在我们的 `<st c="16561">calculator.component.spec.ts</st>` 测试文件中的结果与预期相符：</st
    c="16589">
- en: '![Figure 3.16 – subtract method test case without error](img/B21146_03_16.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – 没有错误的减法方法测试用例](img/B21146_03_16.jpg)'
- en: <st c="16856">Figure 3.16 – subtract method test case without error</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 没有错误的减法方法测试用例
- en: <st c="16909">When we take a tour of the terminal, we get</st> <st c="16954">this
    preview:</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在终端中浏览时，我们得到以下预览：
- en: '![Figure 3.17 – Test coverage of our app](img/B21146_03_17.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – 我们应用的测试覆盖率](img/B21146_03_17.jpg)'
- en: <st c="17211">Figure 3.17 – Test coverage of our app</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.17 – 我们应用的测试覆盖率](img/B21146_03_17.jpg)'
- en: <st c="17249">We’ll do the same exercise for multiplication and division.</st>
    <st c="17310">In our</st> `<st c="17317">calculator.component.spec.ts</st>`<st
    c="17345">, we’ll</st> <st c="17353">get this:</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对乘法和除法进行相同的练习。在我们的 `<st c="17317">calculator.component.spec.ts</st>` 中，我们会得到以下结果：
- en: '![Figure 3.18 – Adding multiply and divide methods test cases](img/B21146_03_18.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18 – 添加乘法和除法方法测试用例](img/B21146_03_18.jpg)'
- en: <st c="17826">Figure 3.18 – Adding multiply and divide methods test cases</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 《st c="17826">图 3.18 – 添加乘法和除法方法测试用例</st c="17826">
- en: <st c="17885">Then in</st> <st c="17894">our</st> `<st c="17898">calculator.service.ts</st>`
    <st c="17919">service, we have</st> <st c="17937">the following:</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们的 `<st c="17898">calculator.service.ts</st>` 服务中，我们有以下内容：
- en: '![Figure 3.19 – Adding multiply and divide methods in calculator.service.ts](img/B21146_03_19.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.19 – 在 calculator.service.ts 中添加乘法和除法方法](img/B21146_03_19.jpg)'
- en: <st c="18094">Figure 3.19 – Adding multiply and divide methods in calculator.service.ts</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 《st c="18094">图 3.19 – 在 calculator.service.ts 中添加乘法和除法方法</st c="18094">
- en: <st c="18167">And finally, in our</st> `<st c="18188">calculator.component.ts</st>`<st
    c="18211">, we have</st> <st c="18221">the following:</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的 `<st c="18188">calculator.component.ts</st>` 中，我们有以下内容：
- en: '![Figure 3.20 – Adding multiply and divide methods in calculator.component.ts](img/B21146_03_20.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图3.20 – 在calculator.component.ts中添加乘法和除法方法](img/B21146_03_20.jpg)'
- en: <st c="18421">Figure 3.20 – Adding multiply and divide methods in calculator.component.ts</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18421">图3.20 – 在calculator.component.ts中添加乘法和除法方法</st>
- en: <st c="18496">In our</st> <st c="18503">terminal, we can see</st> <st c="18525">the
    following:</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18496">在我们的</st> <st c="18503">终端中，我们可以看到</st> <st c="18525">以下内容：</st>
- en: '![Figure 3.21 – Test coverage of our app](img/B21146_03_21.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图3.21 – 我们应用的测试覆盖率](img/B21146_03_21.jpg)'
- en: <st c="19411">Figure 3.21 – Test coverage of our app</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19411">图3.21 – 我们应用的测试覆盖率</st>
- en: <st c="19449">And in our browser, we can see</st> <st c="19481">the following:</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19449">在我们的浏览器中，我们可以看到</st> <st c="19481">以下内容：</st>
- en: '![Figure 3.22 – calculator.component.ts test cases succeeded](img/B21146_03_22.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图3.22 – calculator.component.ts测试用例成功](img/B21146_03_22.jpg)'
- en: <st c="19952">Figure 3.22 – calculator.component.ts test cases succeeded</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19952">图3.22 – calculator.component.ts测试用例成功</st>
- en: <st c="20010">In the next section, we’ll make things a little more interesting.</st>
    <st c="20077">We’re going to turn our</st> `<st c="20101">result</st>` <st c="20107">variable
    into an observable.</st> <st c="20137">This way, we won’t have to call it up every
    time in our component’s calculation methods.</st> <st c="20226">This will also
    enable us to see how to test</st> <st c="20270">an observable.</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20010">在下一节中，我们将使事情变得更有趣。</st> <st c="20077">我们将把我们的</st> `<st c="20101">result</st>`
    <st c="20107">变量转换为一个可观察对象。</st> <st c="20137">这样，我们就不必每次在组件的计算方法中调用它。</st> <st
    c="20226">这将使我们能够了解如何测试</st> <st c="20270">一个可观察对象。</st>
- en: <st c="20284">Using rigorous directive testing to ensure proper rendering and
    functionality</st>
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="20284">使用严格的指令测试以确保适当的渲染和功能</st>
- en: <st c="20362">Angular directives play a vital role in structuring and enhancing
    the functionality of web applications.</st> <st c="20468">They allow developers
    to manipulate the DOM, create reusable components, and provide dynamic behavior.</st>
    <st c="20571">Directive testing is the process of verifying that directives render
    correctly and function as expected.</st> <st c="20676">By thoroughly testing directives,
    developers can identify and fix issues before they impact the application’s overall
    performance and</st> <st c="20810">user experience.</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20362">Angular指令在构建和增强Web应用程序的功能方面发挥着至关重要的作用。</st> <st c="20468">它们允许开发者操作DOM，创建可重用组件，并提供动态行为。</st>
    <st c="20571">指令测试是验证指令是否正确渲染并按预期工作的过程。</st> <st c="20676">通过彻底测试指令，开发者可以在它们影响应用程序的整体性能和</st>
    <st c="20810">用户体验之前识别并修复问题。</st>
- en: <st c="20826">In our current calculator application development project, we’re
    going to use a directive to apply a color to the calculation result displayed
    on</st> <st c="20973">the screen.</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20826">在我们的当前计算器应用程序开发项目中，我们将使用一个指令来将颜色应用到屏幕上显示的计算结果。</st>
- en: <st c="20984">Implementing color change directives</st>
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="20984">实现颜色更改指令</st>
- en: <st c="21021">To handle color</st> <st c="21038">changes in our Angular calculator
    application, we’re going to create a custom directive.</st> <st c="21127">Directives
    allow us to extend the functionality of HTML elements and encapsulate</st> <st
    c="21208">specific behaviors.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21021">为了处理我们的Angular计算器应用程序中的颜色</st> <st c="21038">更改，我们将创建一个自定义指令。</st>
    <st c="21127">指令允许我们扩展HTML元素的功能并封装</st> <st c="21208">特定的行为。</st>
- en: <st c="21227">In this case, we’ll create a directive called</st> `<st c="21274">colorChange</st>`
    <st c="21285">that will be responsible for handling color transitions.</st> <st
    c="21343">The directive will accept an input parameter specifying the color to
    be changed.</st> <st c="21424">It will then apply the CSS styles required to achieve
    the</st> <st c="21482">desired effect.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21227">在这种情况下，我们将创建一个名为</st> `<st c="21274">colorChange</st>` <st c="21285">的指令，该指令将负责处理颜色过渡。</st>
    <st c="21343">该指令将接受一个输入参数，指定要更改的颜色。</st> <st c="21424">然后它将应用所需的CSS样式以实现</st>
    <st c="21482">期望的效果。</st>
- en: <st c="21497">To create the</st> <st c="21512">directive, follow</st> <st c="21530">these
    steps:</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21497">要创建</st> <st c="21512">指令，请按照</st> <st c="21530">以下步骤操作：</st>
- en: <st c="21542">Create a</st> `<st c="21552">directives</st>` <st c="21562">folder
    in the</st> `<st c="21577">core</st>` <st c="21581">folder of our project.</st>
    <st c="21605">So, we’ll basically have</st> `<st c="21630">src/core/directives</st>`<st
    c="21649">, and we’ll execute the following command from our terminal while in
    the</st> `<st c="21722">directives</st>` <st c="21732">folder:</st>
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="21542">在项目</st> `<st c="21577">core</st>` <st c="21581">文件夹中创建一个</st>
    `<st c="21552">directives</st>` <st c="21562">文件夹。</st> <st c="21605">因此，我们将基本上有</st>
    `<st c="21630">src/core/directives</st>`<st c="21649">，并且我们将在</st> `<st c="21722">directives</st>`
    <st c="21732">文件夹中执行以下命令：</st>
- en: '[PRE8]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Figure 3.23 – Adding ColorChangeDirective in the declarations array of CalculatorModule](img/B21146_03_23.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图3.23 – 在CalculatorModule的声明数组中添加ColorChangeDirective](img/B21146_03_23.jpg)'
- en: <st c="22200">Figure 3.23 – Adding ColorChangeDirective in the declarations
    array of CalculatorModule</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22200">图3.23 – 在CalculatorModule的声明数组中添加ColorChangeDirective</st>
- en: <st c="22287">Then, in our</st> `<st c="22301">color-change.directive.ts</st>`
    <st c="22326">file, in the</st> `<st c="22340">selector</st>` <st c="22348">attribute,
    we’ll replace</st> `<st c="22374">appColorChange</st>` <st c="22388">with a</st>
    <st c="22396">simple</st> `<st c="22403">colorChange</st>`<st c="22414">:</st>
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="22287">然后，在我们的</st> `<st c="22301">color-change.directive.ts</st>` <st
    c="22326">文件中，在</st> `<st c="22340">selector</st>` <st c="22348">属性中，我们将用简单的</st>
    `<st c="22374">appColorChange</st>` <st c="22388">替换为</st> `<st c="22396">colorChange</st>`<st
    c="22403">:</st>
- en: '![Figure 3.24 – Changing the selector name of ColorChangeDirective](img/B21146_03_24.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图3.24 – 修改ColorChangeDirective的选择器名称](img/B21146_03_24.jpg)'
- en: <st c="22517">Figure 3.24 – Changing the selector name of ColorChangeDirective</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22517">图3.24 – 修改ColorChangeDirective的选择器名称</st>
- en: <st c="22581">Now that we</st> <st c="22594">have created the</st> `<st c="22611">colorChange</st>`
    <st c="22622">directive, let’s move on to the next section, whe</st><st c="22672">re
    will write tests for this newly</st> <st c="22708">created directive.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22581">现在我们已经创建了</st> <st c="22594">colorChange</st> <st c="22611">指令，让我们继续到下一部分，在那里我们将为这个新创建的指令编写测试。</st>
    <st c="22672">我们将编写测试来检查这个新创建的指令。</st> <st c="22708">的测试。</st>
- en: <st c="22726">Writing tests for the colorChange directive</st>
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="22726">为colorChange指令编写测试</st>
- en: <st c="22770">As we are</st> <st c="22781">following the TDD approach, our tests
    should check the use of</st> <st c="22843">our directive.</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22770">由于我们遵循TDD方法，我们的测试应该检查我们指令的使用。</st> <st c="22781">由于我们遵循TDD方法，我们的测试应该检查我们指令的使用。</st>
- en: <st c="22857">When we apply a color to our HTML content through the directive,
    that color should change.</st> <st c="22949">Our test will naturally fail because
    we haven’t yet written the appropriate code for our</st> `<st c="23038">colorChange</st>`
    <st c="23049">directive.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22857">当我们通过指令将颜色应用到我们的HTML内容中时，该颜色应该改变。</st> <st c="22949">我们的测试将自然失败，因为我们还没有为我们的</st>
    `<st c="23038">colorChange</st>` <st c="23049">指令</st> <st c="23049">编写适当的代码。</st>
- en: <st c="23060">Subsequently, we’ll write the minimum amount of code necessary
    for our test to pa</st><st c="23142">ss, and refactor it</st> <st c="23163">if
    necessary.</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23060">随后，我们将编写测试通过所需的最小代码量，并在必要时进行重构。</st> <st c="23142">通过测试，并在必要时进行重构。</st>
    <st c="23163">重构。</st>
- en: <st c="23176">In our</st> `<st c="23184">color-chnage.directive.spec.ts</st>`
    <st c="23214">file, we have</st> <st c="23229">the following:</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23176">在我们的</st> `<st c="23184">color-chnage.directive.spec.ts</st>`
    <st c="23214">文件中，我们有</st> <st c="23229">以下内容：</st>
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="23477">We’re going to modify the previous code and complete the test
    suites in line with the</st> <st c="23564">expected logic.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23477">我们将修改前面的代码，并按照预期的逻辑完成测试套件。</st> <st c="23564">的预期逻辑。</st>
- en: <st c="23579">In the previous code, when our directive is created, we notice
    that the written test checks whether the instance exists by creating an object.</st>
    <st c="23723">In our scenario, we won’t do this.</st> <st c="23758">We’ll declare
    our directive directly in the</st> `<st c="23802">configureTestingModule</st>`
    <st c="23824">method, which guarantees its existence and the possibility of accessing
    it without passing through the</st> <st c="23927">constructor.</st> <st c="23941">This
    will give us the</st> <st c="23963">following result:</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23579">在前面的代码中，当我们的指令被创建时，我们注意到编写的测试通过创建一个对象来检查实例是否存在。</st> <st c="23723">在我们的场景中，我们不会这样做。</st>
    <st c="23758">我们将在</st> `<st c="23802">configureTestingModule</st>` <st c="23824">方法中直接声明我们的指令，这保证了它的存在以及无需通过</st>
    <st c="23927">构造函数</st> <st c="23941">访问它的可能性。</st> <st c="23963">这将给我们以下结果：</st>
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="24270">The preceding code will be our starting point.</st> <st c="24318">Now
    for a quick reminder.</st> <st c="24344">When we want to use a directive on an
    HTML tag that takes a property as a parameter, here’s what it</st> <st c="24444">looks
    like:</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="24270">前面的代码将是我们的起点。</st>` `<st c="24318">现在快速提醒一下。</st>` `<st c="24344">当我们想在HTML标签上使用一个接受属性作为参数的指令时，它看起来是这样的：</st>`
    `<st c="24444">：</st>`'
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="24486">According to the preceding code,</st> `<st c="24520">colorChange</st>`
    <st c="24531">is our directive.</st> <st c="24550">It takes</st> `<st c="24559">color</st>`
    <st c="24564">as a parameter.</st> <st c="24581">This implies that color is an
    attribute of our component.</st> <st c="24639">So, we’re going to call our</st>
    `<st c="24667">CalculatorComponent</st>` <st c="24686">for our test suite, linked
    to the directive, so that we can interact with it.</st> <st c="24765">Here’s what
    it</st> <st c="24780">looks like:</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码，`<st c="24520">colorChange</st>` `<st c="24531">是我们的指令。</st>` `<st c="24550">它接受</st>`
    `<st c="24559">color</st>` `<st c="24564">作为参数。</st>` `<st c="24581">这意味着颜色是我们组件的一个属性。</st>`
    `<st c="24639">因此，我们将调用我们的</st>` `<st c="24667">CalculatorComponent</st>` `<st
    c="24686">以测试套件，与指令链接，以便我们可以与之交互。</st>` `<st c="24765">下面是它的样子：</st>` `<st c="24780">：</st>`
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="25409">We know that</st> <st c="25423">we need to select our paragraph,</st>
    `<st c="25456">p</st>`<st c="25457">, in the component</st> `<st c="25476">CalculatorComponent</st>`
    <st c="25495">to change the color of our paragraph,</st> `<st c="25534">p</st>`<st
    c="25535">, as we see fit.</st> <st c="25552">As we only have one paragraph in
    the component, here’s how we</st> <st c="25614">can proceed:</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="25409">我们知道</st>` `<st c="25423">我们需要选择我们的段落</st>` `<st c="25456">p</st>`
    `<st c="25457">，在</st>` `<st c="25476">CalculatorComponent</st>` `<st c="25495">组件中，以改变段落的颜色</st>`
    `<st c="25534">p</st>` `<st c="25535">，如我们所愿。</st>` `<st c="25552">由于组件中只有一个段落，以下是我们的操作步骤：</st>`
    `<st c="25614">：</st>`'
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="26547">In the preceding code, we’ve managed to select the paragraph using</st>
    `<st c="26615">By</st>`<st c="26617">. So, since the</st> `<st c="26633">color</st>`
    <st c="26638">attribute will be used to define the color of our paragraph, we
    will use it in our test suite.</st> <st c="26734">The code editor highlights</st>
    `<st c="26761">color</st>` <st c="26766">in red because we haven’t yet declared
    it in our component.</st> <st c="26827">We’ll</st> <st c="26833">make the necessary
    changes to our</st> <st c="26867">component next.</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="26547">在前面代码中，我们已经使用</st>` `<st c="26615">By</st>` `<st c="26617">.
    因此，由于</st>` `<st c="26633">color</st>` `<st c="26638">属性将用于定义段落的颜色，我们将在测试套件中使用它。</st>`
    `<st c="26734">代码编辑器将</st>` `<st c="26761">color</st>` `<st c="26766">用红色突出显示，因为我们还没有在我们的组件中声明它。</st>`
    `<st c="26827">我们将</st>` `<st c="26833">对我们的</st>` `<st c="26867">组件进行必要的更改。</st>`'
- en: <st c="26882">In the</st> `<st c="26890">CalculatorComponent</st>` <st c="26909">class,
    we’ll declare the</st> `<st c="26935">color</st>` <st c="26940">attribute:</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="26882">在</st>` `<st c="26890">CalculatorComponent</st>` `<st c="26909">类中，我们将声明</st>`
    `<st c="26935">color</st>` `<st c="26940">属性：</st>`'
- en: '![Figure 3.25 – Adding the color attribute in calculator.component.ts](img/B21146_03_25.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图3.25 – 在calculator.component.ts中添加颜色属性](img/B21146_03_25.jpg)'
- en: <st c="26984">Figure 3.25 – Adding the color attribute in calculator.component.ts</st>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="26984">图3.25 – 在calculator.component.ts中添加颜色属性</st>`'
- en: <st c="27051">In the HTML file, we have</st> <st c="27078">the following:</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="27051">在HTML文件中，我们有</st>` `<st c="27078">以下内容：</st>`'
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="27136">In the preceding code, notice that</st> `<st c="27172">[colorChange]</st><st
    c="27185">="color"</st>` <st c="27194">is considered an error in our</st> <st
    c="27225">HTML template:</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意，`<st c="27172">[colorChange]</st><st c="27185">="color"</st>` `<st
    c="27194">在我们的</st>` `<st c="27225">HTML模板中</st>`被视为一个错误：
- en: '![Figure 3.26 – Adding a colorChange directive with an error](img/B21146_03_26.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图3.26 – 添加带有错误的colorChange指令](img/B21146_03_26.jpg)'
- en: <st c="27548">Figure 3.26 – Adding a colorChange directive with an error</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="27548">图3.26 – 添加带有错误的colorChange指令</st>`'
- en: <st c="27606">This is normal, as our directive is missing a declaration.</st>
    <st c="27666">Since the direction takes an attribute as a parameter, we need to</st>
    <st c="27732">declare it.</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="27606">这是正常的，因为我们的指令缺少一个声明。</st>` `<st c="27666">由于指令接受一个属性作为参数，我们需要</st>`
    `<st c="27732">声明它。</st>`'
- en: <st c="27743">Here’s what we need to do in our</st> `<st c="27777">color-change.directive.ts</st>`
    <st c="27802">directive:</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="27743">在我们的</st>` `<st c="27777">color-change.directive.ts</st>` `<st
    c="27802">指令中，我们需要做的是：</st>`'
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="27992">In our HTML</st> <st c="28004">template for the</st> `<st c="28022">calculator</st>`
    <st c="28032">component, there are no</st> <st c="28057">more errors:</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27992">在我们的 HTML</st> <st c="28004">模板</st> <st c="28022">计算器</st> <st
    c="28032">组件中，没有</st> <st c="28057">更多错误：</st>
- en: '![Figure 3.27 – Adding a colorChange directive without errors](img/B21146_03_27.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.27 – 无错误地添加 colorChange 指令](img/B21146_03_27.jpg)'
- en: <st c="28114">Figure 3.27 – Adding a colorChange directive without errors</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28114">图 3.27 – 无错误地添加 colorChange 指令</st>
- en: <st c="28173">Nevertheless, we’ll always have</st> `<st c="28206">calculator.component.spec.ts</st>`
    <st c="28234">test cases that have failed, and we’ll display this on the screen
    when we run</st> <st c="28313">our tests:</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28173">尽管如此，我们仍然会有</st> `<st c="28206">calculator.component.spec.ts</st>`
    <st c="28234">测试用例失败，并且当我们在运行</st> <st c="28313">测试时会在屏幕上显示这些失败：</st>
- en: '![Figure 3.28 – calculator.component.ts test failed due to colorChange](img/B21146_03_28.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.28 – 由于 colorChange 导致 calculator.component.ts 测试失败](img/B21146_03_28.jpg)'
- en: <st c="32046">Figure 3.28 – calculator.component.ts test failed due to colorChange</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32046">图 3.28 – 由于 colorChange 导致 calculator.component.ts 测试失败</st>
- en: <st c="32114">To fix this, we</st> <st c="32130">need to declare our directive
    in the test file of our</st> `<st c="32185">CalculatorComponent</st>`<st c="32204">,</st>
    <st c="32206">namely</st> `<st c="32213">calculator.component.spec.ts</st>`<st
    c="32241">:</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32114">为了解决这个问题，我们需要在我们的</st> <st c="32130">CalculatorComponent</st><st
    c="32204">的测试文件</st> <st c="32206">中声明我们的指令，即</st> `<st c="32213">calculator.component.spec.ts</st>`<st
    c="32241">：</st>
- en: '![Figure 3.29 – Updating the beforeEach method in calculator.component.spec.ts](img/B21146_03_29.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.29 – 更新 calculator.component.spec.ts 中的 beforeEach 方法](img/B21146_03_29.jpg)'
- en: <st c="32408">Figure 3.29 – Updating the beforeEach method in calculator.component.spec.ts</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32408">图 3.29 – 更新 calculator.component.spec.ts 中的 beforeEach 方法</st>
- en: <st c="32484">We’ll then have just</st> <st c="32506">one error:</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32484">然后我们只会有一处错误：</st>
- en: '![Figure 3.30 – calculator.component.ts test failed due to colorChange](img/B21146_03_30.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.30 – 由于 colorChange 导致 calculator.component.ts 测试失败](img/B21146_03_30.jpg)'
- en: <st c="33066">Figure 3.30 – calculator.component.ts test failed due to colorChange</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33066">图 3.30 – 由于 colorChange 导致 calculator.component.ts 测试失败</st>
- en: <st c="33134">Thi</st><st c="33138">s error is due to the fact that we haven’t
    yet written the logic for our directive.</st> <st c="33223">We need to write the
    minimum amount of code for the test</st> <st c="33280">to pass:</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33134">Thi</st><st c="33138">s 错误是由于我们还没有为我们的指令编写逻辑。</st> <st c="33223">我们需要编写最少的代码以使测试通过：</st>
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="33672">In the preceding</st> <st c="33690">code, we implemented the</st>
    `<st c="33715">ngOnInit()</st>` <st c="33725">lifecycle to ensure that the directive
    is loaded into the DOM.</st> <st c="33789">Then we injected dependencies into
    the constructor, namely</st> `<st c="33848">ElementRef</st>` <st c="33858">and</st>
    `<st c="33863">Renderer2</st>`<st c="33872">, to manipulate the HTML element and
    apply the style to it.</st> <st c="33932">The result can be seen in the</st> <st
    c="33962">following screenshot:</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33672">在前面的</st> <st c="33690">代码中，我们实现了</st> `<st c="33715">ngOnInit()</st>`
    <st c="33725">生命周期</st>，以确保指令被加载到 DOM 中。</st> <st c="33789">然后我们在构造函数中注入了依赖项，即</st>
    `<st c="33848">ElementRef</st>` <st c="33858">和</st> `<st c="33863">Renderer2</st>`<st
    c="33872">，以操作 HTML 元素并应用样式。</st> <st c="33932">结果可以在以下屏幕截图中看到：</st>
- en: '![Figure 3.31 – ColorChangeDirective test succeeded](img/B21146_03_31.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.31 – ColorChangeDirective 测试成功](img/B21146_03_31.jpg)'
- en: <st c="34509">Figure 3.31 – ColorChangeDirective test succeeded</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34509">图 3.31 – ColorChangeDirective 测试成功</st>
- en: <st c="34558">By implementing custom directives and writing rigorous tests following
    the TDD principles, we can ensure that our application behaves as expected, providing
    users with a visually appealing and</st> <st c="34752">interactive experience.</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34558">通过实现自定义指令并遵循 TDD 原则编写严格的测试，我们可以确保我们的应用程序按预期运行，为用户提供视觉上吸引人和</st>
    <st c="34752">交互式的体验。</st>
- en: <st c="34775">Summary</st>
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="34775">总结</st>
- en: <st c="34783">This chapter covered various aspects of component testing, including
    initializing components, rendering templates, handling events, and manipulating
    the DOM.</st> <st c="34942">It explained how to use Angular’s testing utilities,
    such as</st> `<st c="35003">TestBed</st>` <st c="35010">and</st> `<st c="35015">ComponentFixture</st>`<st
    c="35031">, for setting up and interacting with components during testing.</st>
    <st c="35096">It provided insights into testing Angular services, including testing
    service methods and handling dependencies.</st> <st c="35209">It explored the
    testing of Angular directives, focusing on testing directive behavior and interactions
    with the DOM.</st> <st c="35326">It explained how to test directive attributes,
    inputs, and</st> <st c="35385">outputs effectively.</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34783">本章涵盖了组件测试的各个方面，包括初始化组件、渲染模板、处理事件以及操作DOM。</st> <st c="34942">它解释了如何使用Angular的测试工具，例如</st>
    `<st c="35003">TestBed</st>` <st c="35010">和</st> `<st c="35015">ComponentFixture</st>`<st
    c="35031">，在测试期间设置和交互组件。</st> <st c="35096">它提供了关于测试Angular服务的见解，包括测试服务方法和处理依赖关系。</st>
    <st c="35209">它探讨了Angular指令的测试，重点关注测试指令行为和与DOM的交互。</st> <st c="35326">它解释了如何有效地测试指令属性、输入和</st>
    <st c="35385">输出。</st>
- en: <st c="35405">In the next chapter, we’ll look at how to mock and stub dependencies</st>
    <st c="35475">in Angular.</st>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35405">在下一章中，我们将探讨如何在Angular中模拟和存根依赖</st> <st c="35475">。
