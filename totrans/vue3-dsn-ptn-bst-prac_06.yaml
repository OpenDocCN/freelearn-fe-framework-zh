- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Progressive Web Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渐进式网络应用程序
- en: 'In this chapter, we will see the next evolutionary step for web applications:
    **progressive web applications** (**PWAs**). This term may not seem descriptive
    enough, but it refers to a group of technologies that create the general concept
    and can be implemented gradually or partially. The basic idea behind it is to
    bring a web application out of the context of the browser and implement it in
    any type of device, to act and behave as much as possible to a native application.
    This is done thanks to the implementation of new APIs in the browser engines,
    as well as integrations among the most popular operating systems for desktop and
    mobile devices. The starting point for a PWA is, of course, a **single-page**
    **application** (**SPA**).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到网络应用程序的下一个进化步骤：**渐进式网络应用程序**（**PWAs**）。这个术语可能看起来描述不够充分，但它指的是一组技术，这些技术创造了通用概念，可以逐步或部分实现。其背后的基本思想是将网络应用程序从浏览器环境中解放出来，在任何类型的设备上实现，尽可能像原生应用程序一样行动和表现。这是通过在浏览器引擎中实现新的API以及桌面和移动设备上最流行的操作系统的集成来实现的。PWA的起点当然是**单页应用程序**（**SPA**）。
- en: 'By the end of this chapter, we will have learned the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将学习以下内容：
- en: What makes a SPA a PWA, and which technologies are involved
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是使SPA成为PWA的因素，以及涉及哪些技术
- en: How to implement manually a responsive SPA, manifest file, service workers,
    offline storage, and so on
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何手动实现响应式SPA、清单文件、服务工作者、离线存储等
- en: What *service* *workers* are
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 *服务* *工作者*
- en: How to use Vite plugins to automate the creation of PWAs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Vite插件自动化创建PWAs
- en: How to test the readiness of your application using *Google Lighthouse*
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 *Google Lighthouse* 测试应用程序的准备工作
- en: From the preceding list, we will concentrate on learning the scaffolding for
    several technologies, setting the foundation to use them later, implemented in
    detail in [*Chapter 7*](B18602_07.xhtml#_idTextAnchor173), *Data Flow Management*,
    and [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186), *Multithreading with Web
    Workers*. By the end of these chapters, you will know how to create PWAs that
    make good use of today’s computing power, making them responsive, reliable, and
    performant.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的列表中，我们将专注于学习几种技术的脚手架，为以后使用它们打下基础，这些内容在[*第7章*](B18602_07.xhtml#_idTextAnchor173)
    *数据流管理*和[*第8章*](B18602_08.xhtml#_idTextAnchor186) *使用Web Workers的多线程*中详细实现。到这些章节结束时，您将了解如何创建充分利用当今计算能力的PWAs，使它们响应、可靠且性能良好。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to follow along with this chapter, you will need the code examples
    found in the repository at [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter06](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter06).
    The text code examples in this section may not be enough to create a working example,
    without the additional code from the repository.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章内容，您需要查看存储库中的代码示例，该存储库位于[https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter06](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter06)。本节中的文本代码示例可能不足以创建一个可工作的示例，除非您从存储库中添加额外的代码。
- en: 'Check out the following video to see the Code in Action: [https://packt.link/SBZys](https://packt.link/SBZys)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://packt.link/SBZys](https://packt.link/SBZys)
- en: PWAs or installable SPAs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PWAs或可安装的SPA
- en: A PWA is not a single setting or technology, but a systematic enhancement of
    a web application to comply with certain conditions, be it either a **multi-page
    application** (**MPA**) or a SPA. However, they really shine and come to life
    when these technologies are applied to SPAs, giving us powerful applications that
    blend the line between online/offline and desktop or web. The term **progressive**
    used here has the same connotation as we have discussed previously when applied
    to the Vue framework—an incremental application of web technologies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: PWA不是一个单一的设置或技术，而是对网络应用程序的系统增强，以符合某些条件，无论是**多页应用程序**（**MPA**）还是SPA。然而，当这些技术应用于SPA时，它们真正闪耀并变得生动，为我们提供了融合在线/离线和桌面或网络之间界限的强大应用程序。这里使用的**渐进式**一词与我们之前在Vue框架中讨论的含义相同——对网络技术的增量应用。
- en: 'PWAs are then treated somehow specially by the browsers and the operating system.
    They can be installed alongside native or desktop applications and manage network
    communications (to send, receive, cache files, and even push notifications from
    the server). At this point, it is important to note that we are no longer referring
    only to desktop computers but also to mobile devices such as tablets and phones,
    and different operating systems. It is because of this multiplatform approach
    that special consideration needs to be taken if the intention is to cover a user
    base on different devices, such as the use of special and dedicated CSS rules
    to adapt the UI to different sizes (the so-called **responsive applications**),
    different icons, and colors to blend with local user customizations at the operating
    system level (for example, light and dark modes), and so on. Moreover, PWAs have
    the capacity (just as with SPAs) to store content for offline use and, hopefully,
    should also provide some functionality for offline use. To accomplish all of this,
    at the bare minimum, a PWA must comply with the following requirements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器和操作系统对PWA有某种特殊处理。它们可以与原生或桌面应用程序一起安装，并管理网络通信（发送、接收、缓存文件，甚至从服务器推送通知）。在此阶段，重要的是要注意，我们不再仅仅指的是桌面计算机，还包括移动设备，如平板电脑和手机，以及不同的操作系统。正因为这种多平台方法，如果目的是覆盖不同设备上的用户基础，就需要特别注意，例如使用特殊的和专用的CSS规则来适应不同大小的UI（所谓的**响应式应用程序**），不同的图标和颜色，以与操作系统级别的本地用户自定义设置相融合（例如，浅色和深色模式）等。此外，PWA（就像SPAs一样）具有存储内容以供离线使用的功能，并且希望也能提供一些离线使用功能。为了实现所有这些，至少，一个PWA必须符合以下要求：
- en: The web application must be served through a secure connection (HTTPS).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络应用程序必须通过安全连接（HTTPS）提供服务。
- en: The application must provide a manifest file.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序必须提供一个清单文件。
- en: It must provide and install a service worker.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须提供和安装一个服务工作者。
- en: When all these conditions are met, the browser or operating system may prompt
    the user to “install” the application. If the user accepts, the manifest file
    will be used to customize the appearance of the application to match the local
    operating system (icons, names, colors, and so on), and it will appear alongside
    all the other applications in the system. When run, it will open in its own window
    (if so selected) outside the confines of the web browser, just as with a regular
    native application. Internally, it will still run over the browser engine using
    web technologies, but the intent is that this will be transparent for the user,
    providing the best of both worlds. Chances are that a user may have been using
    PWAs instead of regular applications without knowing. Successful examples of this
    approach are Starbucks, Trivago, and Tinder ([https://medium.com/@addyosmani/a-tinder-progressive-web-app-performance-case-study-78919d98ece0](https://medium.com/@addyosmani/a-tinder-progressive-web-app-performance-case-study-78919d98ece0)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些条件都满足时，浏览器或操作系统可能会提示用户“安装”应用程序。如果用户接受，则使用清单文件来定制应用程序的外观，以匹配本地操作系统（图标、名称、颜色等），并将在系统中所有其他应用程序旁边显示。当运行时，它将在自己的窗口中打开（如果选择这样做），位于网络浏览器之外，就像常规原生应用程序一样。内部，它仍然使用浏览器引擎通过Web技术运行，但目的是让用户感觉这是透明的，提供两者的最佳之处。可能的情况是，用户可能一直在使用PWA而不是常规应用程序，而自己却不知道。这种方法的成功案例包括星巴克、Trivago和Tinder（[https://medium.com/@addyosmani/a-tinder-progressive-web-app-performance-case-study-78919d98ece0](https://medium.com/@addyosmani/a-tinder-progressive-web-app-performance-case-study-78919d98ece0)）。
- en: 'This creates a good number of advantages that overpower the complications of
    creating a web application to match the different installation scenarios:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这创造了大量优势，这些优势超过了创建一个适应不同安装场景的Web应用程序的复杂性：
- en: One single code base to install an application on multiple devices (desktop,
    mobile, …) and operating systems (Windows, Linux, macOS, Android, iOS, and so
    on)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单一代码库即可在多个设备（桌面、移动设备等）和操作系统（Windows、Linux、macOS、Android、iOS等）上安装应用程序
- en: Support push notifications from the server, manual handling of caching, offline
    use, and so on
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持从服务器推送通知、手动处理缓存、离线使用等功能
- en: They integrate with the local operating system
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们与本地操作系统集成
- en: Updates are transparent for the user and are much faster than a traditional
    application (for the most part)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新对用户来说是透明的，并且比传统应用程序（大部分情况下）要快得多
- en: Developing a PWA incurs much fewer costs than the equivalent targeted individual
    applications for each platform
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发PWA的成本远低于针对每个平台的等效针对性独立应用
- en: One can use all available web technologies, frameworks, and libraries
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用所有可用的Web技术、框架和库
- en: Can be indexed by search engines, and the distribution and installation do not
    depend on proprietary application stores
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以被搜索引擎索引，其分发和安装不依赖于专有应用商店
- en: They are responsive, safe, and fast, and can be shared with just a link
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是响应式的、安全的和快速的，并且只需一个链接就可以分享
- en: You can access local devices using standard web APIs, such as the local filesystem
    and USB devices, use hardware accelerated graphics, and so on
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用标准Web API访问本地设备，例如本地文件系统和USB设备，使用硬件加速图形等
- en: Some proprietary application stores allow you to re-package your PWA and distribute
    it as a regular application (Microsoft Store, Amazon Store, Android Store, and
    so on)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些专有应用商店允许你重新打包你的PWA并将其作为常规应用分发（例如，微软商店、亚马逊商店、安卓商店等）
- en: 'There are more advantages, but these may be enough to make our case for them.
    Also, it is easier to add the necessary elements to our SPA to make it a PWA.
    This may make PWAs look like the silver bullet of applications; however, there
    are a few caveats and drawbacks to consider as well:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多优势，但这些可能已经足够让我们为它们辩护。此外，向我们的单页应用（SPA）添加必要元素以使其成为渐进式Web应用（PWA）更容易；这可能会让PWA看起来像是应用的银弹；然而，还有一些需要注意的注意事项和缺点：
- en: The performance of a PWA is good but will always fall behind a native application
    for certain specific scenarios. The same may happen in older hardware—they will
    run, but performance may suffer.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PWA的性能良好，但在某些特定场景中始终会落后于原生应用。在较旧的硬件上也可能发生这种情况——它们可以运行，但性能可能会受到影响。
- en: Apple devices fall a little behind in the adoption of some web technologies
    or limit them purposely for PWAs (for example, server push notifications).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果设备在采用某些Web技术或有意限制PWA方面稍微落后（例如，服务器推送通知）。
- en: There’s a need to dedicate a bit more effort to cover different user experience
    scenarios on multiple devices (but slightly more than for a normal responsive
    web application).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要投入更多精力来覆盖多设备上的不同用户体验场景（但略多于普通响应式Web应用）。
- en: Some application stores will not allow PWAs (specifically at the time of this
    writing, the Apple App Store). Also, the application will not benefit from the
    exposure and *foot traffic* from an app store.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些应用商店不允许PWA（特别是在撰写本文时，苹果应用商店）。此外，应用将无法从应用商店的曝光和*流量*中受益。
- en: Overall, the advantages outweigh considerably the disadvantages. As web technologies
    continue to advance, PWAs benefit more from them and become more ubiquitous. Now,
    with a better understanding of what a PWA is and what it can do, let’s upgrade
    our SPAs into PWAs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，优势远大于劣势。随着Web技术的不断发展，PWA从中受益更多，变得更加普遍。现在，让我们更好地理解PWA是什么以及它能做什么，将我们的SPA升级为PWA。
- en: Upscaling a SPA into a PWA
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SPA升级为PWA
- en: The first requirement mentioned previously is to serve the application over
    a secure connection. We will see how to accomplish this by installing a free SSL
    certificate in our server using **Let’s Encrypt**, in [*Chapter 10*](B18602_10.xhtml#_idTextAnchor224),
    *Deploying Your Application*. With that in mind, let’s see how to fulfil the other
    requirements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的第一个要求是在安全连接上提供服务。我们将在[*第10章*](B18602_10.xhtml#_idTextAnchor224)“部署您的应用”中看到如何通过在我们的服务器上安装免费的SSL证书来实现这一点，使用**Let’s
    Encrypt**，在[*第10章*](B18602_10.xhtml#_idTextAnchor224)，*部署您的应用*。考虑到这一点，让我们看看如何满足其他要求。
- en: The manifest file
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清单文件
- en: 'Adding a manifest file is the starting point to turn our application into a
    PWA. It is nothing less than a JSON file with well-known fields that instruct
    the browser or operating system on how the application should be installed on
    the desktop or mobile device. This file must appear linked in the `head` section
    of our `index.html` file, and while it could be arbitrarily named, the convention
    is to use the name `manifest.json` or `app.webmanifest`. The official specification
    suggests the `.webmanifest` extension, but at the same type clarifies that the
    name is not really important as long as the file is received properly with the
    `application/manifest+json -` `manifest.json` for simplicity:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 添加清单文件是将我们的应用程序转变为PWA的起点。这不仅仅是一个包含已知字段的JSON文件，它指导浏览器或操作系统如何将应用程序安装在桌面或移动设备上。此文件必须出现在我们的`index.html`文件的`head`部分中，尽管它可以任意命名，但惯例是使用名称`manifest.json`或`app.webmanifest`。官方规范建议使用`.webmanifest`扩展名，但同时也明确指出，只要文件正确接收，名称实际上并不重要，为了简便起见，这里使用`manifest.json`：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice from the previous code that the file is placed at the root of our application,
    and the `rel` attribute must be `manifest`. The field attributes in our manifest
    file can appear in any order, and all of them are considered *optional* by the
    aforementioned specification. However, some platforms do expect a minimum set
    of attributes that we will consider *necessary*. The common practice also demands
    other attributes that we will catalogue as *recommended*, and finally, some attributes
    in the specification are used often in app stores, social media, and so on to
    present or describe the application, so we will refer to these as *descriptive*
    fields. This classification is not part of the specifications but is useful to
    guide you in the implementation. Here is a list of the most common and useful
    attributes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，文件放置在我们的应用程序的根目录中，并且`rel`属性必须是`manifest`。我们清单文件中的字段属性可以以任何顺序出现，并且根据上述规范，所有这些都被认为是*可选的*。然而，一些平台确实期望一组最小属性，我们将它们视为*必需的*。常见的做法还要求其他属性，我们将它们分类为*推荐项*，最后，规范中的一些属性在应用商店、社交媒体等地方经常被用来展示或描述应用程序，因此我们将这些称为*描述性字段*。这种分类不是规范的一部分，但有助于指导你的实现。以下是最常见和有用的属性列表：
- en: '| Classification | Attribute |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 分类 | 属性 |'
- en: '| Necessary |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 必需项 |'
- en: '| `short_name` | A short name to be used when there is not enough space to
    display the entire name of the application. In mobile devices, it is often used
    for the icon name. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `short_name` | 当没有足够空间显示应用程序的全名时使用的简称。在移动设备上，它通常用于图标名称。|'
- en: '| `name` | The full name of the application. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 应用程序的全名。|'
- en: '| `icons` | An array of objects, each one representing an individual icon to
    be used in different contexts. Each object has at least two attributes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '| `icons` | 一个对象数组，每个对象代表一个在不同上下文中使用的独立图标。每个对象至少有两个属性：'
- en: '`src`: The path to the image'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`: 图片的路径'
- en: '`sizes`: A string with the dimensions of the image'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizes`: 包含图像尺寸的字符串'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `start_url` | The URL where the application should start, as set by the developer.
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `start_url` | 应用程序应启动的URL，由开发者设置。|'
- en: '| `display` | A string that represents how the application is presented:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '| `display` | 表示应用程序如何呈现的字符串：'
- en: '`fullscreen`: Fullscreen, but showing browser UI.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fullscreen`: 全屏显示，但显示浏览器UI。'
- en: '`standalone`: Like `fullscreen`, but without browser controls. On a desktop,
    windows controls will still display.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`standalone`: 与`fullscreen`类似，但没有浏览器控制。在桌面设备上，窗口控制仍会显示。'
- en: '`minimal-ui`: Like `standalone`, but with basic navigation to move forward
    and backward, print, share, and so on.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minimal-ui`: 与`standalone`类似，但具有基本导航以前进和后退、打印、分享等。'
- en: '`browser`: The application is open in the default browser.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browser`: 应用程序在默认浏览器中打开。'
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Recommended |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 推荐项 |'
- en: '| `theme_color` | A string representing a CSS color for the application. It
    is upon the OS to decide how to use this value (usually, applied in the window
    title bar). |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `theme_color` | 表示应用程序的CSS颜色的字符串。操作系统将决定如何使用此值（通常，应用于窗口标题栏）。|'
- en: '| `background_color` | A string that represents the background color of the
    application when it is launched and before the actual styles from the application
    are applied. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `background_color` | 表示应用程序启动时以及实际应用应用程序样式之前背景颜色的字符串。|'
- en: '| `orientation` | Mostly used in mobile devices, it defines the orientation
    that the application must use—for example, `landscape, portrait, any,` and so
    on. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `orientation` | 主要用于移动设备，它定义了应用程序必须使用的方向——例如，`横向、纵向、任意`等。 |'
- en: '| `lang` | A string that defines the main language of the application. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `lang` | 定义应用程序主要语言的字符串。 |'
- en: '| Descriptive |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 描述 |'
- en: '| `shortcuts` | This is an array of objects that define direct menu options
    for tight integration with the operating system. Usually, these appear in the
    context menu, such as when a user right-clicks on the application icon. Each shortcut
    object must contain at least `name` and `URL`, and—optionally—a `description`
    and `icons` array. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `shortcuts` | 这是一个对象数组，定义了与操作系统紧密集成的直接菜单选项。通常，这些出现在上下文菜单中，例如当用户右键单击应用程序图标时。每个快捷方式对象必须至少包含`name`和`URL`，并且可选地包含`description`和`icons`数组。
    |'
- en: '| `description` | A string with a short description of the application. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `description` | 包含应用程序简短描述的字符串。 |'
- en: '| `screenshots` | An array of objects, with the following fields:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '| `screenshots` | 一个对象数组，具有以下字段： |'
- en: '`src`: URL for the image'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`: 图片的URL'
- en: '`type`: MIME type of the image'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 图片的MIME类型'
- en: '`sizes`: A string with the dimensions of the image'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizes`: 包含图片尺寸的字符串'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 6.1 – Manifest fields
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 – 清单字段
- en: In practice, I would recommend that the necessary and recommended fields are
    completed for each PWA, while the descriptive fields are used as needed based
    on the context of your application. Additionally, research your target platforms
    for additional supported fields that are not part of the standard specification.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我建议为每个PWA完成必要的和推荐的字段，而描述性字段则根据您应用程序的上下文按需使用。此外，研究您的目标平台以获取标准规范之外的额外支持字段。
- en: 'Following the preceding table, here is an example of a `manifest.json` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的表格，以下是一个`manifest.json`文件的示例：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, creating a manifest file is not much additional effort and is
    an easy addition to our SPA.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，创建清单文件并不需要太多额外的工作，并且很容易添加到我们的SPA中。
- en: Testing your manifest
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试您的清单
- en: 'Once you have created your manifest file and linked it to your `index.html`
    file, you can use the Developer Tools in a browser to check that it has been properly
    loaded. For example, when using Google Chrome, in the **Application** menu, we
    can see here that the example file has been properly loaded:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了清单文件并将其链接到您的`index.html`文件，您就可以使用浏览器中的开发者工具来检查它是否已正确加载。例如，当使用Google Chrome时，在**应用程序**菜单中，我们可以看到示例文件已被正确加载：
- en: '![Figure 6.1 – Developer Tools on Google Chrome, showing the manifest file](img/Figure_6.01_B18602.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – Google Chrome中的开发者工具，显示清单文件](img/Figure_6.01_B18602.jpg)'
- en: Figure 6.1 – Developer Tools on Google Chrome, showing the manifest file
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – Google Chrome中的开发者工具，显示清单文件
- en: 'However, there is one more topic related to the installation of the application
    that we must review: when and how does the user know that the web application
    can be installed? This is where the *Install prompt* comes into play, which we
    will see next.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个与应用程序安装相关的话题需要我们审查：用户何时以及如何知道该Web应用程序可以安装？这就是*安装提示*发挥作用的地方，我们将在下一节中看到。
- en: Install prompt
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装提示
- en: Each platform (mobile or desktop) has its own method of determining when a PWA
    that meets the installation criteria can be installed. This could trigger a notification
    for the user to accept the installation after a certain amount of time, or only
    provide a UI to do so. On mobile devices, the installed PWA will be placed on
    the home screen alongside other native applications, while on a desktop, it may
    be placed inside the browser and/or also in the main menu. Also, in mobile operating
    systems such as Android, a splash screen will be automatically created with the
    theme and background colors and the application icon provided in the manifest.
    Independently of how and when the PWA can be installed, it is important to know
    that it can only be done with the user’s consent and initiative. We cannot trigger
    the installation automatically from the code without the user’s approval.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台（移动或桌面）都有自己确定符合安装标准 PWA 可以安装的方法。这可能会在一段时间后触发一个通知，让用户接受安装，或者只提供一个用户界面来执行此操作。在移动设备上，已安装的
    PWA 将被放置在主屏幕上，与其他原生应用程序并列，而在桌面上，它可能被放置在浏览器内和/或主菜单中。此外，在像 Android 这样的移动操作系统中，将自动创建一个带有主题和背景颜色以及清单中提供的应用程序图标的启动画面。无论
    PWA 可以如何和何时安装，重要的是要知道，它只能通过用户的同意和主动操作来完成。在没有用户批准的情况下，我们不能从代码中自动触发安装。
- en: 'The basic installation flow is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基本安装流程如下：
- en: When the platform detects that our application can be installed, it will trigger
    an event in the window object called `beforeinstallprompt`. We can cache this
    event to trigger the prompt later from our application.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当平台检测到我们的应用程序可以安装时，它将在窗口对象中触发一个名为 `beforeinstallprompt` 的事件。我们可以缓存这个事件，以便稍后从我们的应用程序中触发提示。
- en: The user initiates the install either through the platform UI or through our
    PWA-provided method (such as a button).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以通过平台 UI 或通过我们提供的 PWA 方法（如按钮）启动安装。
- en: The platform will prompt the user to accept or reject the installation.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平台将提示用户接受或拒绝安装。
- en: If the user accepts, it will install the PWA and trigger another event named
    `appinstalled`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户接受，它将安装 PWA 并触发另一个名为 `appinstalled` 的事件。
- en: This is a rather simple workflow. However, the `beforeinstallprompt` event is
    triggered only once, so if the user rejects the installation, we need to wait
    until the browser triggers the event again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的流程。然而，`beforeinstallprompt` 事件只会触发一次，所以如果用户拒绝安装，我们需要等待浏览器再次触发该事件。
- en: 'Now that we understand how things will work, it is time to see this in code.
    Consider that in our Vue 3 component’s template, we have the following elements:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了事情的工作原理，是时候看看代码中的实现了。假设在我们的 Vue 3 组件模板中，我们有以下元素：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we have two paragraphs that will show according to the value
    of the `_install_ready` and `_app_installed` reactive variables, both Boolean.
    The first will appear when the PWA is ready to be installed and will provide a
    button to trigger the installation through the `installPWA()` function. The second
    will show once it has been performed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有两个段落将根据 `_install_ready` 和 `_app_installed` 这两个布尔值反应变量显示。第一个将在 PWA 准备安装时出现，并提供一个按钮通过
    `installPWA()` 函数触发安装。第二个将在安装完成后显示。
- en: 'Our code in the script section is also rather straightforward:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在脚本部分中的代码也是相当直接的：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous code, we register two listeners when our component is mounted
    on the page, one to manage and cache the installation prompt, and another to detect
    when the application has been installed. Some parts have been omitted to keep
    the code simple, but the full component with styles can be found in the GitHub
    repository.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当我们的组件被挂载到页面上时，我们注册了两个监听器，一个用于管理和缓存安装提示，另一个用于检测应用程序何时已安装。为了保持代码简单，一些部分已被省略，但完整的组件（包括样式）可以在
    GitHub 仓库中找到。
- en: 'While the preceding example is rather simplistic, there are some well-known
    patterns to promote or introduce the installation option to the end user. They
    all rely on the same logic of capturing the event and prompting it later while
    showing the trigger element. The implementation is trivial and has more to do
    with design than a coding pattern, so we will only see the mock-ups here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的例子相当简单，但有一些众所周知的模式可以促进或向最终用户介绍安装选项。它们都依赖于相同的逻辑，即捕获事件并在稍后显示触发元素。实现很简单，更多与设计有关，而不是编码模式，所以我们在这里只展示原型图：
- en: 'Simple **Install** button (as in our example application):'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的**安装**按钮（如我们的示例应用程序所示）：
- en: '![Figure 6.2 – Simple Install button](img/Figure_6.02_B18602.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 简单安装按钮](img/Figure_6.02_B18602.jpg)'
- en: Figure 6.2 – Simple Install button
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 简单安装按钮
- en: 'Menu **Install** button—placed in the main navigation:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单 **安装** 按钮一放置在主导航中：
- en: '![Figure 6.3 – Main menu Install button](img/Figure_6.03_B18602.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 主菜单安装按钮](img/Figure_6.03_B18602.jpg)'
- en: Figure 6.3 – Main menu Install button
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 主菜单安装按钮
- en: 'An overlay notification:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个叠加通知：
- en: '![Figure 6.4 – Overlay notification](img/Figure_6.04_B18602.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 叠加通知](img/Figure_6.04_B18602.jpg)'
- en: Figure 6.4 – Overlay notification
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 叠加通知
- en: 'An on-top overlayed element, such as an installation banner (either before
    the header or at the bottom of the viewport):'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在顶部叠加的元素，例如安装横幅（在页眉之前或视口底部）：
- en: '![Figure 6.5 – Installation prompt banner](img/Figure_6.05_B18602.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 安装提示横幅](img/Figure_6.05_B18602.jpg)'
- en: Figure 6.5 – Installation prompt banner
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 安装提示横幅
- en: 'Once the application has been installed, we want to prevent keeping prompting
    the user for an install. In this case, it is recommendable that we save the offline
    flag, in `localStorage`, a cookie, on `indexeDB,` or mark the start URL of our
    application to a specific location. We will see offline persistent storage options
    in [*Chapter 7*](B18602_07.xhtml#_idTextAnchor173), *Data Flow Management*. Now,
    it’s time to look at the last item to make our SPA a true PWA: service workers.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序已安装，我们希望防止不断提示用户进行安装。在这种情况下，建议我们在 `localStorage`、cookie、`indexeDB` 上保存离线标志，或将我们应用程序的起始
    URL 标记为特定位置。我们将在 [*第 7 章*](B18602_07.xhtml#_idTextAnchor173) *数据流管理* 中看到离线持久存储选项。现在，是时候看看使我们的
    SPA 成为真正的 PWA 的最后一项：服务工作者。
- en: Service workers
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者
- en: A service worker is a JavaScript script that runs on a separate thread, as a
    background process to your application. It acts like a proxy for the network,
    intercepting all calls and behaving according to a programmed strategy to serve
    pages and data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者是一个在单独的线程上运行的 JavaScript 脚本，作为应用程序的后台进程。它充当网络的代理，拦截所有调用，并根据预定的策略提供页面和数据。
- en: We can have multiple service workers as each one is responsible for their scope.
    The scope is defined as the directory (URL path) where the source file for the
    service worker is located. Thus, a service worker placed at the root of the application
    will handle the entire SPA/PWA.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有多个服务工作者，因为每个服务工作者都负责其作用域。作用域定义为服务工作者源文件所在的目录（URL 路径）。因此，放置在应用程序根目录的服务工作者将处理整个
    SPA/PWA。
- en: Service workers are installed without user intervention, so they can be used
    even if the user does not install the PWA. They have a well-defined life cycle
    (see https://web.dev/service-worker-lifecycle/), triggering events for each accomplished
    state. To start, a service worker needs to be first *registered*, then it becomes
    *activated*, and eventually, we can also *unregister* it. Once the service worker
    is activated, it will not take control of the application communication until
    the next time the site is accessed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者无需用户干预即可安装，因此即使用户没有安装 PWA，也可以使用它们。它们有一个定义良好的生命周期（见 https://web.dev/service-worker-lifecycle/），为每个完成状态触发事件。首先，服务工作者需要先
    *注册*，然后它变为 *激活*，最终我们也可以 *注销* 它。一旦服务工作者被激活，它将不会控制应用通信，直到下次访问网站。
- en: 'The most common strategies to program a service worker are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编程服务工作者的最常见策略如下：
- en: Serve the cache only
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅提供缓存
- en: Serve network only
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅提供网络
- en: Try to serve the cache first, fall back to the network
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试首先提供缓存，然后回退到网络
- en: Try to serve the network first, fall back to the cache
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试首先提供网络，然后回退到缓存
- en: Serve the cache first, update the cache next
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先提供缓存，然后更新缓存
- en: When considering the cache and offline strategies, we need to consider what
    are the files and assets that our application needs to run that will have little
    or no change, to cache them. We also need to identify routes that should never
    be cached.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑缓存和离线策略时，我们需要考虑我们的应用程序运行所需的哪些文件和资产将几乎不会改变，以便进行缓存。我们还需要确定永远不会被缓存的路径。
- en: 'To use a service worker, we register it in our `main.js` file with the following
    lines:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用服务工作者，我们在 `main.js` 文件中通过以下行进行注册：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In these lines, we first test if the current browser has capabilities to use
    service workers, and if so, we register it. As we can see, we have placed the
    worker at the root. For this example, we will use a cache-first, network-fallback
    strategy manually for all network calls:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行中，我们首先测试当前浏览器是否有使用服务工作者的能力，如果有，我们就注册它。正如我们所见，我们将工作者放置在根目录。对于这个例子，我们将手动对所有网络调用使用缓存优先、网络回退策略：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous code is based almost verbose on the example provided in the **Mozilla
    Developer Network** documentation at [https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers).
    The comments in the code will help you understand the logic for the implementation
    of the strategy. However, using the basic APIs available to the service worker
    can be cumbersome, if not verbose. Instead, it is more convenient to use a framework
    or library to handle them and implement more complex strategies. The standard
    today is to use **Workbox**, made by **Google** (https://developer.chrome.com/docs/workbox/).
    We will not use it directly, but through a Vite plugin that we will see in the
    next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码几乎完全基于在[https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers)提供的**Mozilla开发者网络**文档中的示例。代码中的注释将帮助您理解实现策略的逻辑。然而，如果不说得太多，使用服务工作者可用的基本API可能会很繁琐。相反，使用框架或库来处理它们并实现更复杂的策略会更方便。今天的标准是使用由**Google**（https://developer.chrome.com/docs/workbox/）制作的**Workbox**。我们不会直接使用它，而是通过下一节将要看到的Vite插件来使用它。
- en: 'With all the code seen thus far, our PWA is ready to work and be installed.
    If we run the example application in the development server, we will notice that
    it can be installed. Using either the browser UI or our **Install** button, we
    will receive the following prompt:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有代码，我们的PWA已经准备好工作并安装。如果我们运行示例应用程序在开发服务器上，我们会注意到它可以安装。使用浏览器UI或我们的**安装**按钮，我们将收到以下提示：
- en: '![Figure 6.6 – PWA install prompt from localhost](img/Figure_6.06_B18602.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 本地主机上的PWA安装提示](img/Figure_6.06_B18602.jpg)'
- en: Figure 6.6 – PWA install prompt from localhost
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 本地主机上的PWA安装提示
- en: 'Adapting manually our SPA to turn it into a PWA is not complicated, but it
    does require some manual work. However, with the choice of tools we have, we can
    do better. There is an easier way to generate and inject both the manifest file
    and service worker as part of our workflow directly into our SPA: using a Vite
    plugin.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的SPA手动调整为PWA并不复杂，但这确实需要一些手动工作。然而，有了我们选择的工具，我们可以做得更好。有一种更简单的方法可以直接将清单文件和服务工作者作为工作流程的一部分生成并注入我们的SPA：使用Vite插件。
- en: Vite-PWA plugin
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vite-PWA插件
- en: 'In the Vite ecosystem of plugins, there is an excellent zero-configuration
    Vite-PWA plugin ([https://vite-pwa-org.netlify.app/](https://vite-pwa-org.netlify.app/)).
    Out of the box, it provides us with great functionality without much manual work.
    We install the plugin as a developer dependency with the following command in
    the terminal:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vite插件生态系统中，有一个出色的零配置Vite-PWA插件([https://vite-pwa-org.netlify.app/](https://vite-pwa-org.netlify.app/))。开箱即用，它为我们提供了许多功能，而无需太多手动工作。我们使用以下终端命令将插件作为开发依赖项安装：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once it has been installed, we must register it in the Vite configuration.
    Modify the `vite.config.js` file to match the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，我们必须在Vite配置中注册它。修改`vite.config.js`文件以匹配以下内容：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using this plugin, we unload the burden of generating the service worker and
    web manifest to the bundler. This is necessary since with each production build,
    Vite will generate different filenames for each script according to our strategy
    to lazy load components, as we discussed in the previous chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此插件，我们将生成服务工作者和Web清单的负担卸载给打包器。这是必要的，因为随着每次生产构建，Vite都会根据我们在上一章中讨论的按需加载组件的策略为每个脚本生成不同的文件名。
- en: In the preceding example, we pass into the `VitePWA()` plugin an object with
    some sensible options for the automatic creation and injection of our manifest
    and worker. If we need finer control over the service worker strategy created,
    as well as with the web manifest, it is possible to use the plugin in “inject
    mode” and provide a base file for our service worker. In this case, the script
    will be injected with the generated files from the build process. Underneath,
    this plugin uses `workbox` field. Going further into the details of the different
    implementations and strategies goes beyond the scope of this book, but the reader
    should consult the documentation about the **Vite-PWA** plugin and **Workbox**
    for specific contexts and use cases.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将一个包含一些合理选项的对象传递给 `VitePWA()` 插件，用于自动创建和注入我们的清单和工作者。如果我们需要更精细地控制创建的服务工作者策略以及网络清单，可以使用“注入模式”使用插件，并为我们提供服务工作者的基础文件。在这种情况下，脚本将注入构建过程中生成的文件。在底层，此插件使用
    `workbox` 字段。深入探讨不同实现和策略的细节超出了本书的范围，但读者应查阅有关 **Vite-PWA** 插件和 **Workbox** 的文档，以了解特定上下文和使用案例。
- en: Testing your PWA score with Google Lighthouse
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Lighthouse 测试您的 PWA 评分
- en: 'Chrome-based browsers provide together with the developer tools a utility called
    Lighthouse, specifically designed to test and rate web pages, and the readiness
    of PWAs. To access this tool, after you have opened your application in the browser,
    follow these steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Chrome 的浏览器与开发者工具一起提供了一个名为 Lighthouse 的工具，专门用于测试和评分网页以及 PWA 的就绪状态。要访问此工具，在浏览器中打开您的应用程序后，请按照以下步骤操作：
- en: Open the developer tools (by pressing *F12* in Windows/Linux, *Fn* + *F12* in
    Mac, or through the browser menu).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开开发者工具（在 Windows/Linux 上按 *F12*，在 Mac 上按 *Fn* + *F12*，或通过浏览器菜单）。
- en: Click the **Lighthouse** menu toward the further right.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击位于更右侧的 **Lighthouse** 菜单。
- en: Select **Mobile** or **Desktop**, plus make sure the **Progressive Web App**
    category is checked.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **移动** 或 **桌面**，并确保已勾选 **渐进式网络应用** 类别。
- en: Click **Analyze page load** in the top-right corner of the tool.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具的右上角点击 **分析页面加载**。
- en: 'The developer tools should look something like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者工具应该看起来像这样：
- en: '![Figure 6.7 – Lighthouse utility](img/Figure_6.07_B18602.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – Lighthouse 工具](img/Figure_6.07_B18602.jpg)'
- en: Figure 6.7 – Lighthouse utility
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – Lighthouse 工具
- en: 'The tool will run a number of tests, and each different category will display
    a rating, as well as a detailed list of items that have either passed or failed.
    If our application does not qualify to be a PWA, the items marked in red will
    tell us why and how to fix them:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 工具将运行一系列测试，每个不同的类别都会显示一个评分，以及一个详细的项目列表，显示这些项目是已通过还是未通过。如果我们的应用程序不符合 PWA 的标准，标记为红色的项目将告诉我们原因以及如何修复它们：
- en: '![Figure 6.8 – Chapter 6 code example ratings in Lighthouse](img/Figure_6.08_B18602.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – Lighthouse 中第 6 章代码示例的评分](img/Figure_6.08_B18602.jpg)'
- en: Figure 6.8 – Chapter 6 code example ratings in Lighthouse
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – Lighthouse 中第 6 章代码示例的评分
- en: Our example code application fully qualifies as a PWA and passes all tests with
    flying colors. This is easier to accomplish with smaller applications, of course.
    In practice, every rating above 90 is great.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例代码应用程序完全符合 PWA 的标准，并且所有测试都轻松通过。当然，对于较小的应用程序来说，这更容易实现。在实践中，任何超过 90 分的评分都是非常好的。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have taken a simple SPA and learned how to upgrade it into
    a PWA, manually and through the use of a plugin in Vite. Users can install PWAs
    in their platforms alongside native applications and interact with them, even
    if they are not connected to the internet. PWAs offer many advantages over web-only
    applications. We also saw how we can measure and rate our application in several
    industry-standard categories using Lighthouse. With this chapter, we end the incremental
    building of applications using web technologies and henceforth will focus on patterns
    and models for internal performance and efficiency.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从一个简单的单页面应用（SPA）开始，学习了如何手动以及通过 Vite 插件将其升级为渐进式网络应用（PWA）。用户可以在他们的平台上安装
    PWA 并与它们交互，即使它们没有连接到互联网。PWA 相比纯网络应用提供了许多优势。我们还看到了如何使用 Lighthouse 在几个行业标准类别中衡量和评估我们的应用程序。随着本章的结束，我们使用网络技术构建应用程序的增量构建也随之结束，从此我们将专注于内部性能和效率的模式和模型。
- en: Review questions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: 'To help you solidify the concepts learned in this chapter, answer the following
    questions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您巩固本章学到的概念，请回答以下问题：
- en: What is the difference between a SPA and a PWA?
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPA 和 PWA 之间的区别是什么？
- en: What are the advantages of a PWA?
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PWA 的优势是什么？
- en: What are the basic three requirements that a web application must comply with
    to be considered a PWA?
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Web应用要被视为PWA，必须遵守的基本三个要求是什么？
- en: Which tools we can use to incrementally prepare our application to be a PWA?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些工具来逐步准备我们的应用成为PWA？
- en: What is a service worker, and what are some strategies to use it?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是服务工作者，以及有哪些策略可以使用它？
- en: What is a web manifest and why is it necessary?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Web清单，为什么它是必要的？
