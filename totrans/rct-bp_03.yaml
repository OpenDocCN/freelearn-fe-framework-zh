- en: Chapter 3. Responsive Web Development with ReactJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：使用ReactJS进行响应式Web开发
- en: A few years ago, building web apps was relatively easy. Your web apps were viewed
    on desktops and laptops with roughly the same screen sizes and could create a
    lightweight mobile version to serve the few mobile users who visited your site.
    Today the tables have turned and mobile devices are just as important, often even
    more so than desktops and laptops. The screen sizes today can vary from a 4" smartphone
    to a 9" tablet and any size in between.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，构建Web应用相对容易。您的Web应用在具有大致相同屏幕尺寸的台式机和笔记本电脑上查看，并且可以创建一个轻量级的移动版本来服务访问您网站的少量移动用户。如今，情况已经逆转，移动设备同样重要，有时甚至比台式机和笔记本电脑更重要。今天的屏幕尺寸可以从4英寸智能手机到9英寸平板电脑，以及任何介于两者之间的尺寸。
- en: In this chapter, we'll be looking at the practice of building a web app suitable
    to work on any device, regardless of size or whether the app will be viewed on
    a desktop or mobile browser. The goal is to create an app environment that moulds
    itself to the user's setup and provides a gratifying experience for everyone.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨构建适用于任何设备（无论大小或应用是否在桌面或移动浏览器上查看）的Web应用的实践。目标是创建一个能够适应用户设置并为每个人提供愉悦体验的应用环境。
- en: 'The term "**responsive development**" is an umbrella term covering a range
    of design techniques such as **adaptive**, **fluid**, **liquid**, or **elastic**
    layouts, and **hybrid** or **mobile** development. It can be broken into two main
    components: a flexible layout and flexible media content.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “**响应式开发**”这个术语是一个涵盖一系列设计技术（如**自适应**、**流体**、**液体**或**弹性**布局，以及**混合**或**移动**开发）的通用术语。它可以分为两个主要组件：灵活布局和灵活媒体内容。
- en: 'We''ll cover everything you need to create a responsive app in ReactJS in these
    topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些主题中，我们将涵盖创建响应式ReactJS应用所需的所有内容：
- en: Creating a flexible layout
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建灵活布局
- en: Choosing the right framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的框架
- en: Setting up a responsive app with Bootstrap
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bootstrap设置响应式应用
- en: Creating a flexible grid
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建灵活的网格
- en: Creating a responsive menu and navigation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应式菜单和导航
- en: Creating responsive wells
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应式井
- en: Creating responsive panels
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应式面板
- en: Creating responsive alerts
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应式警报
- en: Embedding media and video content
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入媒体和视频内容
- en: Creating responsive buttons
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应式按钮
- en: Creating dynamic progress bars
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态进度条
- en: Creating fluid carousels
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建流体轮播
- en: Working with fluid images and the picture element
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与流体图片和图片元素一起工作
- en: Creating responsive form fields
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应式表单字段
- en: Using glyph- and font-awesome icons
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图标和字体图标
- en: Creating a responsive landing page
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应式着陆页
- en: Creating a flexible layout
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建灵活布局
- en: Flexible layouts change in width based on the size of a user's viewport. Viewport
    is a generic term for the viewable area of the user's device. It's preferred over
    terms such as a window or browser size because not all devices use Windows. You
    may design the layout to use a percentage of the user's width or not assign any
    width at all and have the layout fill up the viewport regardless of how big or
    small it is.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活布局的宽度会根据用户视口的尺寸而变化。视口是用户设备可查看区域的通用术语。它比“窗口”或“浏览器大小”等术语更受欢迎，因为并非所有设备都使用Windows。您可以设计布局以使用用户宽度的百分比，或者根本不指定任何宽度，让布局无论大小都填满视口。
- en: Before we talk about all the advantages of a **flexible** layout, let's briefly
    look at its counterpart, the **fixed width** layout.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论**灵活布局**的所有优点之前，让我们简要地看看它的对立面，即**固定宽度布局**。
- en: Fixed width means setting the overall width of a page to a predetermined pixel
    value and then designing the app elements with this constraint in mind. Before
    the explosive proliferation of web-enabled mobile devices, this was the primary
    design technique for developing web applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 固定宽度意味着将页面的整体宽度设置为预定的像素值，然后考虑到这个限制来设计应用元素。在可联网移动设备爆炸性增长之前，这是开发网络应用的主要设计技术。
- en: A fixed width design has certain benefits. The main benefit is that it gives
    designers complete control of the look. Basically, the user sees what the designer
    designs. It's also easier to structure, and working with fixed width elements,
    such as images and forms, is less of a hassle.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 固定宽度设计具有一定的优势。主要优势是它让设计师对外观拥有完全的控制权。基本上，用户看到的就是设计师设计的。它也更容易进行结构化，并且与固定宽度的元素（如图片和表单）一起工作，不那么麻烦。
- en: The obvious drawback with this type of design is that you end up with a rigid
    layout that doesn't change based on any variation in the user environment. You
    will often end with excessive white space for devices with large viewports, upsetting
    certain design principles, or a design that is too wide for devices with small
    viewports.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计类型的明显缺点是，你最终得到的是一个僵化的布局，它不会根据用户环境的任何变化而改变。你经常会遇到对于大视口设备来说白空间过多，这会违背某些设计原则，或者对于小视口设备来说设计过宽的情况。
- en: Going with a fixed width design may be appropriate for some use cases, but as
    it depends on your decision to guess which layout constraints work best for most
    users of your app, you're likely to exclude a potentially huge group of users
    from using your app.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 采用固定宽度设计可能适用于某些用例，但它取决于你猜测哪种布局约束对大多数应用用户来说效果最佳的决定，你很可能会排除一个可能非常大的用户群体使用你的应用。
- en: For this reason, a responsive app should generally be designed with a flexible
    layout in order to remain usable for every user of your app.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个响应式应用通常应该设计成一个灵活的布局，以便为你的应用的所有用户保持可用性。
- en: An *adaptive* app generally refers to an app that is easily modifiable when
    a change occurs, while *responsive* means to react quickly to changes. The terms
    are interchangeable, and when we use the term "responsive", it's usually inferred
    that it should also be adaptive. *Elastic* and *fluid* roughly mean the same and
    usually describe a percentage-based design that molds to changes in browser or
    viewport size.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*自适应*应用通常指的是当发生变化时易于修改的应用，而*响应式*意味着快速对变化做出反应。这两个术语可以互换使用，当我们使用“响应式”这个术语时，通常意味着它也应该具有自适应的特性。*弹性*和*流体*大致意思相同，通常描述的是基于百分比的布局设计，能够适应浏览器或视口大小的变化。
- en: '*Mobile* development, on the other hand, means creating a separate version
    of your app that is meant to run exclusively on cell phone browsers. This is occasionally
    a good approach, but it comes with several tradeoffs, such as maintaining a separate
    code base, relying on browser sniffing to send users to the mobile version, and
    problems with **search engine optimization** (**SEO**), since you have to maintain
    separate URLs for the mobile and the desktop version.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*移动端开发*意味着创建一个专门版本的应用，该版本旨在仅在手机浏览器上运行。这种方法偶尔是可行的，但它伴随着一些权衡，例如维护一个独立的代码库，依赖浏览器嗅探将用户引导到移动版本，以及**搜索引擎优化**（**SEO**）方面的问题，因为你必须为移动版和桌面版维护不同的URL。
- en: '*Hybrid apps* refer to mobile apps that are developed in such a manner that
    they can be hosted inside a native application that utilizes a mobile platform''s
    **WebView**. You can think of WebView as an exclusive, full-screen browser for
    your app that is hooked inside the mobile platform''s native environment. The
    benefit of this approach is that you can use standard development practices for
    the Web, and in addition, you can gain access to native capabilities that are
    often restricted to access from inside the mobile browsers. Another benefit is
    that you can publish your app on native app stores.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*混合应用*指的是以这种方式开发的移动应用，它们可以托管在利用移动平台**WebView**的本地应用中。你可以将WebView视为一个专有的、全屏的浏览器，它被钩在移动平台的本地环境中。这种方法的优点是，你可以使用标准的Web开发实践，此外，你还可以访问通常仅限于从移动浏览器内部访问的本地功能。另一个优点是，你可以将你的应用发布到原生应用商店。'
- en: Developing native apps with ReactJS is an attractive proposition, and with the
    React Native project, it's also a viable option. With React Native, you can use
    everything that you've learned about ReactJS and apply it to develop apps that
    can run on Apple and Android devices and that can be published on Apple's App
    Store and Google Play.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ReactJS开发原生应用是一个有吸引力的提议，而React Native项目也提供了一个可行的选择。使用React Native，你可以将你关于ReactJS所学的所有内容应用到开发可以在苹果和安卓设备上运行的应用，并且可以发布到苹果的App
    Store和谷歌的Play商店。
- en: Choosing the right framework
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的框架
- en: While it's certainly possible to set up a flexible layout on your own, using
    a responsive framework makes a lot of sense. For reasons such as you'll save a
    lot of time using a framework that's already been battle tested and maintained
    for many years by a team of skilled designers. You can also take advantage of
    the fact that a widely used responsive framework has a lot of helpful resources
    on the Web. The drawback is that you will need to learn how the framework expects
    you to lay out your pages, and that sometimes, you may not entirely agree on the
    design decisions that the frameworks imposes on you.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当然可以自己设置一个灵活的布局，但使用响应式框架有很多意义。例如，你可以节省大量时间，使用已经经过多年战斗测试并由一支熟练的设计师团队维护的框架。你还可以利用这样一个广泛使用的响应式框架在网络上拥有大量有用资源的优势。缺点是，你可能需要学习框架期望你如何布局你的页面，有时，你可能不完全同意框架强加给你的设计决策。
- en: 'With these considerations in mind, let''s take a look at some of the major
    frameworks that are available for you:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，让我们来看看一些可供你选择的重大框架：
- en: '**Bootstrap**: The undisputed leader of the pack is Bootstrap. It''s massively
    popular and there are tons of resources and extensions available. The tie-in with
    the React-Bootstrap project also makes this a very obvious choice when developing
    web apps in ReactJS.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bootstrap**: 毫无疑问，Bootstrap 是这个领域的领导者。它非常受欢迎，有大量的资源和扩展可用。与 React-Bootstrap
    项目的结合也使得在 ReactJS 中开发网络应用时，这是一个非常明显的选择。'
- en: '**Zurb Foundation**: Foundation is the second biggest player after Bootstrap
    and a natural choice if you decide that Bootstrap is not for you. It''s a mature
    framework that offers a lot of complexity for very little effort.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zurb Foundation**: 基础框架是继 Bootstrap 之后第二大玩家，如果你认为 Bootstrap 不适合你，它是一个自然的选择。这是一个成熟的框架，只需付出很少的努力就能提供很多复杂性。'
- en: '**Pure**: Pure by Yahoo! is a lightweight and modular framework. It''s perfect
    if you''re concerned about the byte size of other frameworks (this one checks
    in at around 4 KB, while Bootstrap checks in around 150 KB and Foundation at 350
    KB).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pure**: 由 Yahoo! 提供的 Pure 是一个轻量级且模块化的框架。如果你担心其他框架的字节大小（这个大约有 4 KB，而 Bootstrap
    大约是 150 KB，Foundation 是 350 KB），它非常合适。'
- en: '**Material Design**: Material Design by Google is a very strong contender.
    It brings a lot of fresh ideas to the table and is an exciting alternative to
    Bootstrap and Foundation. There''s also a ReactJS implementation called **Material
    UI** that brings together Material Design and ReactJS, which makes this an attractive
    alternative to Bootstrap and React-Bootstrap. Material Design is highly opinionated
    in how the UX elements it provides should behave and interact, while Bootstrap
    and the others give you more freedom on how you set up your interactions.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Material Design**: 由 Google 提供的 Material Design 是一个非常有力的竞争者。它带来了很多新的想法，是
    Bootstrap 和 Foundation 的一个令人兴奋的替代品。还有一个名为 **Material UI** 的 ReactJS 实现，它将 Material
    Design 和 ReactJS 结合起来，这使得它成为 Bootstrap 和 React-Bootstrap 的一个有吸引力的替代品。Material
    Design 在其提供的 UX 元素应该如何表现和交互方面非常具有意见性，而 Bootstrap 和其他框架则给你在设置交互方面提供了更多的自由度。'
- en: It's obviously not easy to choose one framework that's right for every project.
    Another choice that we did not mention previously was doing it alone, that is,
    creating the grid and the flexible layout all on your own. It's absolutely a doable
    strategy, but it comes with certain drawbacks.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，选择一个适合每个项目的框架并不容易。我们之前没有提到的另一个选择是独自完成，也就是说，完全自己创建网格和灵活布局。这绝对是一个可行的策略，但它也带来了一些缺点。
- en: The major drawback is that you won't benefit from many years of tweaking and
    testing. Even though most modern browsers are quite capable, your code will often
    be run on a myriad of browsers and devices. It's very likely that your users will
    run into issues that you don't know about because you simply don't have the same
    hardware setup.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的缺点是，你将无法从多年的调整和测试中受益。尽管大多数现代浏览器都相当强大，但你的代码将在众多浏览器和设备上运行。很可能你的用户会遇到你不知道的问题，因为你没有相同的硬件配置。
- en: In the end, you have to decide whether you want to design apps or you desire
    to create a new flexible CSS framework. That choice should make it clear why in
    this chapter we have chosen a particular framework to focus on, and that framework
    is Bootstrap.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你必须决定你是想设计应用程序，还是想创建一个新的灵活 CSS 框架。这个选择应该清楚地说明为什么在本章中我们选择了一个特定的框架来关注，而这个框架就是
    Bootstrap。
- en: Bootstrap is without doubt the most mature and popular of the preceding frameworks
    and has excellent support in the community. The web landscape is still evolving
    at a fast pace, and you can be confident that Bootstrap will evolve with it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Bootstrap是前面提到的框架中最成熟和最受欢迎的，并且在社区中拥有出色的支持。网络景观仍在以快速的速度发展，您可以确信Bootstrap会随着它一起发展。
- en: Setting up your app with Bootstrap
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Bootstrap设置您的应用
- en: We've already looked at an implementation of Bootstrap and React-Bootstrap in
    the previous chapter, but we only skimmed the surface as to what you can do. Let's
    take a closer look at what React-Bootstrap can provide us.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中查看了一个Bootstrap和React-Bootstrap的实现，但我们只是略过了您可以做什么。让我们更深入地看看React-Bootstrap能为我们提供什么。
- en: 'Start this project by making a copy of the scaffolding from [Chapter 1](ch01.html
    "Chapter 1. Diving Headfirst into ReactJS"), *Diving Headfirst into ReactJS*,
    and then add React-Bootstrap to your project. Open a terminal, go to the root
    of your project, and replace your `dependencies` or your `devDependencies` (whichever
    you prefer) with the following list, then issue an `npm install` command from
    your command line:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制[第1章](ch01.html "第1章。深入ReactJS")中的脚手架来开始这个项目，*深入ReactJS*，然后向您的项目中添加React-Bootstrap。打开终端，转到您的项目根目录，然后使用您喜欢的`dependencies`或`devDependencies`（
    whichever you prefer）替换以下列表，然后从命令行运行`npm install`命令：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Additionally, you''ll need to either download the Bootstrap CSS or use a CDN
    to include it in your `index.html` file. Then, add the following to the `<head>`
    section of `index.html`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要下载Bootstrap CSS或使用CDN将其包含在您的`index.html`文件中。然后，将以下内容添加到`index.html`的`<head>`部分：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating a flexible grid
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个灵活的网格
- en: At the heart of CSS frameworks such as Bootstrap lies the concept of the **grid**.
    The Grid is a structure that allows you to stack content horizontally and vertically
    in a consistent manner. It provides a predictable layout scaffolding that is easy
    to visualize when you code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bootstrap等CSS框架的核心中，存在着**网格**的概念。网格是一种结构，允许您以一致的方式水平垂直堆叠内容。它提供了一个可预测的布局框架，当您编码时易于可视化。
- en: 'Grids are made up of two main components: rows and columns. Within each row,
    you can add a number of columns, from one to as many as 12, depending on the framework.
    Some frameworks, such as Bootstrap, also add a container that you can wrap around
    the rows and columns.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 网格由两个主要组件组成：行和列。在每一行中，您可以添加一定数量的列，从一列到最多12列，具体取决于框架。一些框架，如Bootstrap，还会添加一个容器，您可以将它包裹在行和列周围。
- en: Using a grid is ideal for a responsive design. You can effortlessly craft websites
    that look great on both large desktop browsers as well as small mobile browsers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网格非常适合响应式设计。您可以轻松地制作出在大桌面浏览器和小型移动浏览器上看起来都很棒的网络站。
- en: It's all down to how you structure your columns. For instance, you can set up
    a column to be of full width when the browser width is less than or equal to 320
    pixels (a typical mobile browser width), and one-third width when the browser
    width is greater than a given pixel size. The method you employ when toggling
    classes on browser dimension is called **media queries**. All grid frameworks
    come with built-in classes for toggling sizes based on media queries; you will
    rarely need to write your own media queries.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都取决于您如何构建您的列。例如，您可以将列设置为当浏览器宽度小于或等于320像素（典型的移动浏览器宽度）时为全宽，当浏览器宽度大于给定的像素大小时为三分之一宽度。您在浏览器尺寸上切换类的方法称为**媒体查询**。所有网格框架都内置了基于媒体查询切换大小的类；您很少需要自己编写媒体查询。
- en: The grid system in Bootstrap utilizes 12 columns and can optionally be set to
    be fluid by initializing it with `<Grid fluid={true}>`. It defaults to nonfluid,
    but it's worth noting that both settings return a responsive grid. The main difference
    is that a fluid grid has 100% width all the time and continually readjusts at
    every width change. A nonfluid grid is controlled by media queries and changes
    widths when the width of the viewport crosses certain thresholds.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap中的网格系统使用12列，并且可以通过初始化为`<Grid fluid={true}>`来选择性地设置为流体。默认情况下是非流体，但值得注意的是，这两种设置都会返回一个响应式网格。主要区别在于流体网格始终具有100%的宽度，并且会在每次宽度变化时不断调整。非流体网格由媒体查询控制，当视口宽度超过某些阈值时，会改变宽度。
- en: 'Grid columns can be differentiated with these properties:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 网格列可以通过以下属性来区分：
- en: '**xs**: This is for extra small devices such as phones (<768 px)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**xs**：这是用于额外小型的设备，如手机（<768 px）'
- en: '**sm**: This is for small devices such as tablets (≥768 px)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**md**: This is for medium devices such as desktops (≥992 px)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lg**: This is for large devices such as desktops (≥1200 px)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use `push` and `offset` in combination with the preceding properties,
    so, for instance, you can use `xsOffset` to offset a column visible on extra small
    devices, and so on. The difference between `offset` and `push` is that `offset`
    will force other columns to move, while `push` will overlap other columns.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Sizes bubble upwards. If you define an `xs` property but no `sm`, `md`, or `lg`
    properties, all columns will use the `xs` settings. If you define `xs` and `sm`
    properties, extra small viewports will use the `xs` property, while all other
    viewports will use the `sm` property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a practical example. Create a file in your `source/examples`
    folder (create the folder if it doesn''t exist), call it `grid.jsx`, and add the
    following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our scripts, we only import what we currently need. In this example, we need
    `Grid`, `Row`, and `Col`, so we'll name these and make sure that they're imported
    and available under those names.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: While it would be more convenient to import all the components without naming
    each one specifically, being specific with your imports makes it easier to understand
    what you require in the file you're working on. It will also potentially result
    in a smaller footprint when bundling your JavaScript code for deployment because
    the bundler can remove all components that are available but never used. Note
    that this is not true for current versions of **Browserify** or **Webpack** (which
    we'll talk about in [Chapter 6](ch06.html "Chapter 6. Advanced React"), *Advanced
    React*), but is in the pipeline, at least for Webpack.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you''re importing a single component from a larger library, import it
    with this method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will import just the desired component while ignoring the rest of the library.
    If you do this consistently, your bundle size will decrease.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This row will show different column sizes for extra small devices and small
    to large devices:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that sizes bubble upwards, but not downwards.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This row shows two columns that change drastically depending on the viewport.
    On smart phones, the columns are of equal width. On small viewports, the left-hand
    side column covers one third of the row and the right-hand side column covers
    the rest. On medium viewports, the left-hand side column is suddenly the dominant
    column, but on very large viewports, the left-hand side column is again reduced
    to a much smaller proportion.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'This is obviously a contrived setting meant to demonstrate the capabilities
    of the grid. This would be a very strange setting for a live app:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Both columns start with an offset here. This will create a column of empty
    space at the beginning of each column:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Push` moves the column to the right, but doesn''t force the other column to
    move, so it will overlap the next column. This means that the offset in the second
    column will be overlapped by the contents of the first column:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Push`将列移动到右边，但不会强制其他列移动，因此它将覆盖下一个列。这意味着第二列的偏移量将被第一列的内容覆盖：'
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to view this example, open `app.jsx` and replace the content with
    this code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这个示例，请打开`app.jsx`并替换内容为以下代码：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We'll create a lot of components in this chapter, and they can all be added
    to `app.jsx` by adding an `import` statement in the head of your code. ReactJS
    requires you to capitalize your components when you import them. The name you
    give to the import can then be used in your render code by adding the name in
    brackets.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建许多组件，并且它们都可以通过在代码头部添加一个`import`语句来添加到`app.jsx`中。ReactJS要求你在导入组件时首字母大写。你可以通过在括号中添加名称来在渲染代码中使用你给导入的名称。
- en: 'When creating a grid, it can be very beneficial to make it visible while you''re
    setting it up. You can add this to `app.css` to make it appear in your browser:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建网格时，在设置时使其可见非常有好处。你可以将其添加到`app.css`中，使其在浏览器中显示：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This styling will make it easy to view and debug the columns that we're adding.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种样式将使查看和调试我们添加的列变得容易。
- en: Bootstrap's grid system is very versatile and makes it easy to structure your
    page just the way you want it. The grid you've made in this example is visible
    and fluid on all devices you throw at it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap的网格系统非常灵活，可以很容易地以你想要的方式构建你的页面。在这个示例中创建的网格在所有你抛向它的设备上都是可见的且流动的。
- en: '![Creating a flexible grid](img/B04943_03_01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个灵活的网格](img/B04943_03_01.jpg)'
- en: Creating a responsive menu and navigation bar
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个响应式菜单和导航栏
- en: This was extensively covered in [Chapter 2](ch02.html "Chapter 2. Creating a
    Web Shop"), *Creating a Web Shop*, so we'll just set up a basic menu here and
    refer to the previous chapter for details on how to connect to a router and set
    up links that work.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这在[第2章](ch02.html "第2章。创建一个网店")中进行了广泛介绍，*创建一个网店*，所以我们在这里只设置一个基本的菜单，并参考上一章的细节，了解如何连接到路由器并设置工作链接。
- en: 'Create a file in your `source/examples` folder, call it `navbar.jsx`, and add
    the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`source/examples`文件夹中创建一个文件，命名为`navbar.jsx`，并添加以下代码：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Adding `Navbar.Collapse` automatically makes this a mobile-friendly navigation
    bar that replaces the menu items with a **Hamburger** button when the viewport
    is less than 768 pixels:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 自动添加`Navbar.Collapse`将使这个导航栏成为一个移动友好的导航栏，当视口小于768像素时，它将用**汉堡**按钮替换菜单项：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can set the following properties on the main `Navbar` component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在主要的`Navbar`组件上设置以下属性：
- en: '`defaultExpanded`: This will expand `Navbar` on small devices if it is set
    to `true`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultExpanded`：如果设置为`true`，这将展开小设备上的`Navbar`'
- en: '`expanded`: This sets the `Navbar` component expanded on runtime (requires
    `onToggle`)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expanded`：这将在运行时设置`Navbar`组件展开（需要`onToggle`）'
- en: '`fixedBottom`: This will fix the `Navbar` component at the bottom of the viewport'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixedBottom`：这将固定`Navbar`组件在视口的底部'
- en: '`fixedTop`: This will fix the `Navbar` component at the top of the viewport'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixedTop`：这将固定`Navbar`组件在视口的顶部'
- en: '`staticTop`: This will float `Navbar` along with the page'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`staticTop`：这将使`Navbar`随着页面浮动'
- en: '`fluid`: This works in the same way as the fluid setting in the grid'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fluid`：这与网格中的`fluid`设置工作方式相同'
- en: '`inverse`: This inverses the colors in `Navbar`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inverse`：这将反转`Navbar`中的颜色'
- en: '`onToggle`: This is a function that you can run when `Navbar` is toggled'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onToggle`：这是一个当`Navbar`被切换时可以运行的函数'
- en: '`componentClass`: This is used to add your own classes to `Navbar`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentClass`：这用于向`Navbar`添加你自己的类'
- en: Creating responsive wells
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建响应式井
- en: A well is an inset that can be used for good effect. It's an easy, but effective
    way of emphasizing content. It's also very simple to set up in Bootstrap.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 井是一个可以用于良好效果的嵌入元素。这是一种简单但有效的方式来强调内容。在Bootstrap中设置它也非常简单。
- en: 'Add a new file in `source/examples`, name it `wells.jsx`, and add this code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`source/examples`中添加一个新文件，命名为`wells.jsx`，并添加以下代码：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can set the following properties on the `Wells` component:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Wells`组件上设置以下属性：
- en: '`bsSize`: A well can be either *small* or *large*'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bsSize`：井可以是*小*或*大*'
- en: '![Creating responsive wells](img/B04943_03_02.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![创建响应式井](img/B04943_03_02.jpg)'
- en: Creating responsive panels
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建响应式面板
- en: A panel is like a well, but with more information and functionality.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 面板就像一口井，但拥有更多的信息和功能。
- en: It can have a heading and it can be collapsible, so it's a good candidate for
    presenting information, containing forms, and so on.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以有一个标题，也可以是可折叠的，因此它是一个很好的信息展示、表单包含等的候选者。
- en: 'Let''s create a basic panel. Add a new file in `source/components`, name it
    `panels.jsx`, and add this code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的面板。在`source/components`中添加一个新文件，命名为`panels.jsx`，并添加以下代码：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This panel is closed by default and controlled by the component''s state variable,
    `open`. When you click on the button, it executes the internal `setState` function.
    The state simply reverses the Boolean value of the `open` variable using the rather
    clever `not` operator. When we use it, we say that we want the opposite of the
    current value, which is either `true` or `false`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个面板默认是关闭的，并由组件的状态变量`open`控制。当你点击按钮时，它执行内部的`setState`函数。状态只是使用相当聪明的`not`运算符反转`open`变量的布尔值。当我们使用它时，我们说我们想要当前值的相反，这可能是`true`或`false`：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There''s a bit more that we can do with the panel component, but let''s briefly
    look at which other properties we can set on `Panel` first:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对面板组件做更多的事情，但让我们先简要看看我们可以在`Panel`上设置哪些其他属性：
- en: '`header (string)`: Add this to the `Panel` initializer and pass a value to
    give the header some content.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header (string)`: 将此添加到`Panel`初始化器中，并传递一个值以给标题添加一些内容。'
- en: '`footer (string)`: This is the same as the header but creates the information
    block at the bottom instead of at the top.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`footer (string)`: 这与标题相同，但会在底部而不是顶部创建信息块。'
- en: '`bsStyle (string)`: This makes the content meaningful by adding a context class.
    You can choose between all the common Bootstrap context names: `primary`, `success`,
    `danger`, `info`, `warning`, as well as `default`.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bsStyle (string)`: 这通过添加上下文类使内容有意义。你可以选择所有常见的Bootstrap上下文名称：`primary`、`success`、`danger`、`info`、`warning`以及`default`。'
- en: '`expanded (boolean)`: This can either be `true` or `false`. This needs to be
    coupled with `collapsible`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expanded (boolean)`: 这可以是`true`或`false`。这需要与`collapsible`一起使用。'
- en: '`defaultExpanded (boolean)`: This too can be `true` or `false`. This does not
    override the `expanded` function.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultExpanded (boolean)`: 这也可以是`true`或`false`。这不会覆盖`expanded`函数。'
- en: You will often want to display more than one panel and group them together.
    This can be achieved by adding a component called `PanelGroup`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会想要显示多个面板并将它们分组在一起。这可以通过添加一个名为`PanelGroup`的组件来实现。
- en: '`PanelGroups` is a wrapper that you set around all the panels you want to group.
    The code looks like this if you want to group two panels:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`PanelGroups`是一个包装器，你可以在你想要分组的所有面板周围设置它。如果你想分组两个面板，代码看起来是这样的：'
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a controlled `PanelGroup` instance. This means that only one panel will
    be open at any time, and this is signified by adding the `activeKey` attribute
    to the `PanelGroup` initializer. When you click on the panels in the group, the
    function in the `onSelect()` method is called, and it updates the active panel
    state, which then tells ReactJS to open the active panel and close the inactive
    one.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个受控的`PanelGroup`实例。这意味着在任何时候只有一个面板会打开，这是通过在`PanelGroup`初始化器中添加`activeKey`属性来表示的。当你点击组中的面板时，`onSelect()`方法中的函数会被调用，并更新活动面板状态，然后告诉ReactJS打开活动面板并关闭非活动面板。
- en: 'You can also create an uncontrolled `PanelGroup` instance by simply dropping
    the `activeKey` and `onSelect` attributes from the `PanelGroup` initializer and
    the `expanded` attribute from the `Panel` initializers:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过简单地从`PanelGroup`初始化器中删除`activeKey`和`onSelect`属性，以及从`Panel`初始化器中删除`expanded`属性来创建一个无控制的`PanelGroup`实例：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The main difference between them is that with the controlled groups, one panel
    will be toggled open every time, but with uncontrolled groups, the user can close
    all panels.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的主要区别在于，在有控制组的情形下，每次只会打开一个面板，但在无控制组的情形下，用户可以关闭所有面板。
- en: 'Finally, if all you want are uncontrolled panel groups, you can ditch the `PanelGroup`
    component and import the `Accordion` component instead. `<Accordion />` is an
    alias for `<PanelGroup accordion />`. It doesn''t really save you much code, but
    may be easier to remember. The code looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你只想使用无控制面板组，你可以丢弃`PanelGroup`组件，转而导入`Accordion`组件。`<Accordion />`是`<PanelGroup
    accordion />`的别名。它实际上并没有节省多少代码，但可能更容易记住。代码看起来是这样的：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Creating responsive panels](img/B04943_03_03.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![创建响应式面板](img/B04943_03_03.jpg)'
- en: Creating responsive alerts
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建响应式警报
- en: Much like panels, alerts are padded information blocks with a few added features,
    and they're good for displaying timely information to the user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与面板类似，警报是填充了少量附加功能的信息块，非常适合向用户展示及时信息。
- en: Let's take a look at what you can do with alerts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你可以用警报做什么。
- en: 'Create a file called `examples/alerts.jsx` and add this code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`examples/alerts.jsx`的文件，并添加以下代码：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is our flag to keep the alert visible. When this is set to `false`, the
    alert is hidden:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的标志，用于保持警报可见。当这个设置为`false`时，警报会被隐藏：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, there are two attributes to be noted. The first is `isDismissable`, which
    renders a button that allows the user to dismiss the alert. This attribute is
    optional.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有两个需要注意的属性。第一个是`isDismissable`，它渲染一个按钮，允许用户取消警报。这个属性是可选的。
- en: 'The second is `onDismiss`, which is a function that is called when the user
    clicks on the **Dismiss** button. In this case, the `alertVisible` flag is set
    to 0, and the `render` function now returns `null` instead of an `Alert` component:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`onDismiss`，这是一个在用户点击**取消**按钮时被调用的函数。在这种情况下，`alertVisible`标志被设置为0，并且`render`函数现在返回`null`而不是`Alert`组件：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The **Action** button isn''t set up to do anything, so clicking on it is fruitless
    at this time. The **Hide** button receives a function that will set the `alertVisible`
    flag to 0 and hide the `Alert` box:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作**按钮尚未设置任何功能，因此点击它目前是徒劳的。**隐藏**按钮接收一个函数，该函数将`alertVisible`标志设置为0并隐藏`Alert`框：'
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Responsively embedded media and video content
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 响应式嵌入媒体和视频内容
- en: Embedding YouTube videos can be a worthwhile addition to your site, so let's
    create a custom component to handle this.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网站上嵌入YouTube视频可以是一个值得考虑的添加项，因此让我们创建一个自定义组件来处理这个问题。
- en: 'For this module, we need another dependency, so go ahead and open a terminal,
    navigate to the root folder, and execute this `install` command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模块，我们还需要另一个依赖项，所以请继续打开终端，导航到根目录，并执行以下`install`命令：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `classnames` component allows you to dynamically define classes that are
    to be included with simple `true` and `false` comparisons, and it is easier to
    use and understand than relying on string concatenation and `if...else` statements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`classnames`组件允许你通过简单的`true`和`false`比较动态定义要包含的类，它比依赖于字符串连接和`if...else`语句更容易使用和理解。'
- en: 'Create a folder called `components` and a file in that folder called `media.jsx`,
    and then, add this code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`components`的文件夹，并在该文件夹中创建一个名为`media.jsx`的文件，然后添加以下代码：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will require one property: the YouTube source. The others are optional.
    If widescreen is not provided, the component will show the video in the 4:3 aspect
    ratio:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个属性：YouTube源。其他的是可选的。如果没有提供宽屏，组件将以4:3的宽高比显示视频：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This snippet returns an `iframe` or `embed` element based on the type of media
    being passed. The responsive classes are based on the ones provided by Bootstrap
    and will scale the media to any viewport automatically.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段根据传递的媒体类型返回`iframe`或`embed`元素。响应式类基于Bootstrap提供的类，并将媒体自动缩放到任何视口。
- en: 'Open `app.jsx` and add this import:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app.jsx`并添加以下导入：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, add `< Media src="img/x7cQ3mrcKaY"/>` to the `render()` method (or any
    other video you want to display). You can also add the `wideScreen` optional attribute
    to show the video in a 16 x 9 size and `allowFullScreen` if you want to allow
    the user to view the video in full screen. You can also pass `height` and `width`
    parameters in order to make it consistent with your layout.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`< Media src="img/x7cQ3mrcKaY"/>`添加到`render()`方法（或你想要显示的任何其他视频）。你也可以添加`wideScreen`可选属性来以16
    x 9的尺寸显示视频，以及`allowFullScreen`，如果你希望允许用户全屏查看视频。你还可以传递`height`和`width`参数，以便使其与你的布局保持一致。
- en: 'Of course, this component is not just for videos, but any type of media content.
    For instance, try replacing the code in `app.jsx` with this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个组件不仅限于视频，任何类型的媒体内容都可以。例如，尝试用以下代码替换`app.jsx`中的代码：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will show a grid with two columns, one with an SVG and the other with a
    video from YouTube.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个两列的网格，一列是SVG，另一列是YouTube的视频。
- en: Creating responsive buttons
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建响应式按钮
- en: Buttons are ubiquitous on any web app. They're responsible for a lot of user
    interaction that you'll do in your apps, so it's worth knowing the many types
    of buttons available to you.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮在任何Web应用中都很常见。它们负责你在应用中进行的许多用户交互，因此了解你可用到的多种按钮类型是很有价值的。
- en: Some of the options available to you are extra-small, small, and large buttons,
    full-width buttons, the active and disabled state, grouping, dropup and dropdown,
    and the loading state. Let's look at the code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `examples/buttons.jsx` and add the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we execute `setLoading`, we set the `isLoading` state to `true`, and then,
    we set a timer that reverts the state to `false` after 2 seconds:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`ButtonToolbar` along with `ButtonGroup` are the two components that you can
    use for grouping buttons. The main difference between them is that `ButtonToolbar`
    will preserve the spacing between multiple inline buttons or button groups, whereas
    `ButtonGroup` will not:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The styles provide visual weight and identify the primary action of the button.
    The final style, `link`, makes the button look like a normal link but maintains
    the button''s behavior:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Adding `block` turns it into a full-width button. The `bsSize` attribute is
    available for all the buttons and can be `xsmall`, `small`, or `large`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To set the button''s active state, simply add the `active` attribute:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Adding the `disabled` attribute makes the button look unclickable by fading
    it to 50% of the original opacity:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This button receives a `click` action and hands it over to the `setLoading`
    function, as shown in the preceding code. As long as the `isLoading` state is
    set to `false`, it will have a `disabled` attribute and show the text **Loading…**:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This segment shows how you can combine `ButtonToolbar` and `ButtonGroup` to
    maintain two or more sets of visually grouped buttons. Another striking effect
    you can add to `ButtonGroup` is the `vertical` attribute, which will show the
    button stacked on top of each other instead of side by side:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our final set of buttons shows us the various ways in which you can add drop-down
    and split-button effects. This preceding code is the simplest set of drop-down
    buttons that you can show, and all you need to do is wrap them inside the `DropdownButton`
    component:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This next set adds the `noCaret` attribute to illustrate how you can create
    a drop-down button without any visual clue that it will display a set of buttons
    when you click on it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can turn the dropdown into a dropup instead by adding the `dropup` attribute:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Similarly, you can create a split button effect by wrapping the buttons inside
    the `SplitButton` component instead of the `DropdownButton` component:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following screenshot shows the output of this code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating responsive buttons](img/B04943_03_04.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: Creating dynamic progress bars
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Progress bars can be used to show users the state of a process and how much
    is left to process until it's finished.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `examples/progressbars.jsx` and add this code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this component, we want to create an interval for progress bars. We create
    a variable to hold the interval because we want to be able to access it later
    in the `unmount` method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We create an interval when we mount the component, telling it to execute our
    `tick` method every 500 milliseconds:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `tick()` method updates our internal `progress` variable by adding `1`
    to it if it''s less than `100` or resetting to `0` if it isn''t:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: All of the progress bars will now update and display an ever-increasing progress
    until it completely fills up and then resets to `empty` when it does.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: If you apply the `active` attribute, the progress bar will be animated. You
    can also furnish it with stripes by adding the `striped` attribute.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add your own custom label or use one of the following to interpolate
    the current value:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '`%(percent)s%`: This adds a percentage value'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%(bsStyle)s`: This shows the current style'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%(now)s`: This shows the current value'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%(max)s`: This shows the max value (couple this by setting `max={x}`, where
    *x* is any number)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%(min)s`: This shows the minx value (couple this by setting `min={x}`, where
    *x* is any number)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It''s possible to nest several progress bars on top of each other by wrapping
    them inside `ProgressBar`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Creating fluid carousels
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A carousel is a component that is used for cycling through elements, such as
    a slideshow. The functionality is quite complex, but can be achieved with very
    little code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at it. Create a new file called `examples/carousels.jsx`
    and add this code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The direction can be either `prev` or `next`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The first carousel that we create is uncontrolled. That is, it animates itself
    automatically, but can be manually triggered by the user:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The second carousel is controlled and won't be animated until the user clicks
    on the left-hand side or the right-hand side arrow. When the user clicks on one
    of the arrows, the `handleSelect` function receives the desired direction and
    animates the carousel.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the carousel uses the left and right arrow icons from the included
    `Glyphicon` set. You can specify your own arrows using the `nextIcon` and `prevIcon`
    attributes:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![Creating fluid carousels](img/B04943_03_05.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: Working with fluid images and the picture element
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The topic of responsive images is a subject fraught with difficulty. On one
    hand, there's the issue of simply scaling and presenting the images in a responsive
    manner. On the other, you'll often want to download smaller images for small devices
    and hire images for desktops.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how you can set up the responsive code first.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `examples/images.jsx` and add the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We''ll start by defining `Grid` and then create a set of three columns (2 if
    on small mobile devices). In the columns, we add three images with three available
    attributes: `portrait`, `circle`, and `rounded`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: This will scale well to any viewport.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create another row, this time, using a component called `Thumbnail`
    rather than `Image`. This component makes it easy for us to add any kind of HTML
    data that goes along with your image, such as a headline, a description, and an
    action button:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To show this component in your app, open `app.jsx` and add this import:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Then, add `<Images />` to the `render()` method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with fluid images and the picture element](img/B04943_03_06.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: Reducing your footprint
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When serving small devices, it's a good idea to limit the amount of data they
    need to download in order to view the contents of your app. After all, if your
    target audience is users with mobile phones, it's probably not a good idea to
    serve them with high-resolution images that may take several seconds to download.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: There's no universal solution to this problem yet, but there are several decent
    ways of tackling it. Let's look at a few ways you can go about solving this problem.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: One option is to look at the device your user is using to view your app. This
    is called **sniffing** and usually means identifying metrics such as the user
    agent and viewport size in order to serve different images for desktops and mobile
    phones. The problem with this solution is that it's not very reliable. User agents
    can be faked, and a small viewport size doesn't automatically translate into a
    user surfing your app on a small device.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Another option is media queries (which we'll discuss in more depth a little
    bit later). This works well for static elements, such as images that you can place
    in your menus, toolbars, and other fixed content, but not so for dynamic elements.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: One decent solution that's recently come into play is the use of a new element
    called `<picture>`. This element lets you use the concept of media queries dynamically
    and load different images based on the requirements that you specify.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how this works in HTML:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This block will download and show a large image if the browser viewport is at
    least 750 px; it will show a medium image if the viewport is at least 375 px,
    and a small image if neither conditions are met. This element scales gracefully,
    so if the user has a browser that doesn't support this element, it will show the
    image named in the `<img>` element.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'The media query here is relatively simple. You can get pretty creative with
    your queries and `include` attributes, such as the orientation and pixel ratio.
    Here''s a media query that matches smart phones in the portrait mode:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This one matches tables with retina displays in the portrait mode:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Creating a Reactified picture element
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We want to work within the confines of ReactJS, so we don't want segments such
    as the previous one where we break out of the mould and use plain HTML instead
    of a ReactJS component for our pictures. However, since it doesn't exist, we need
    to create one.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'For this module, we need another dependency, so go ahead and execute the following
    command in your terminal (if you haven''t done so already):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, create a new file in your `components` folder and call it `picture.jsx`.
    Let''s start using the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We'll start by adding a set of `property` types and their default values. Note
    that two of the values, `imgSet` and `defaultImage`, are defined as shapes. That's
    because we want to define the `property` types inside the objects and instruct
    ReactJS to let us know if we forget some values or pass the wrong value type.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'We also require a few values that are specific to Bootstrap, and you''ll probably
    recognize them from the preceding `Image` examples. Since we''re creating our
    own image component, we want to be able to add attributes such as `rounded` and
    `portrait`, and this is how we make sure we do that:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here, we use the `ClassNames` component to add the correct Bootstrap classes
    if we pass along the attributes we mentioned previously:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For every element in `imgSet`, we add a `source` item:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we add the default image along with the `width` and `height` attributes.
    If you don''t specify the width and height, it will be set to `auto`. It''s usually
    a good idea to set the width and height because that makes it easier for the browser
    to lay out the page initially and prevents it from jumping in case the document
    is served before the images are completely downloaded:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s use the new component in `examples/images.jsx`. Open the file and add
    this import:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Immediately after the import line, add these variables:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, add this code just before `</Grid>` in the `render()` method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: When you reload the app in the browser, you'll see a rounded image in your browser,
    and depending on your viewport size, you'll either see an image with the dimensions
    500 x 300, 200 x 500, 250 x 150, or 100 x 100\. Resize the browser and play around
    with the settings to see how it works in practice.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Creating responsive form fields
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Forms are tricky because you'll often need to verify the input and present some
    feedback in case the user does something you didn't expect. We'll look at both
    the issues here, creating responsive forms and presenting feedback to the user.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, call it `examples/formfields.jsx`, and add this code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When this function is executed, it gets the e-mail string from the state and
    then uses a rather complicated `regex` query to check whether the e-mail is written
    in the correct format. It''s hardly foolproof, but it''s good enough. If the e-mail
    is deemed valid, the function returns `''success''`. If not, it either returns
    `''error''` or `''warning''`, both providing visual clues to the user that the
    e-mail is not entered correctly:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This simple validator function checks whether the password has a number and
    an uppercase letter. If it does and the length is five characters or more, it
    will return `''success''`. If not, it will return `''error''`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'These two functions fetch the input values via `this.refs` and stores them
    as state variables. Go back to [Chapter 1](ch01.html "Chapter 1. Diving Headfirst
    into ReactJS"), *Diving Headfirst into ReactJS*, if you want to learn more about
    refs:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This function returns `true` if both validator functions return the `''success''`
    string:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The second input field has several interesting attributes. It has an `onChange`
    attribute, which makes sure to call a function whenever new input is entered into
    the field. It has a `ref` attribute so that it''s possible to find it later via
    `this.refs`. Finally it has a `bsStyle` attribute that can receive `null`, `''success''`,
    `''warning''`, or `''error''`. It will turn the border green on `''success''`,
    yellow on `''warning''`, and red on `''error''`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This button is disabled as long as the validator functions don''t return `''success''`.
    When they do, the user is allowed to proceed and push the button:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To show this component in your app, open `app.jsx` and add this import:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Then, add `<Formfields />` to the `render()` method.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Formfields` component we''ve created here can be extended with more input
    fields and more validators. Let''s briefly look at the different input types that
    you can use:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '**Select**:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: These two select fields let the user select from a list one at a time or several
    items at once by adding the `multiple` attribute.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '**File**:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The text in `help` will be displayed underneath the file upload box. You can
    add an `onChange` handler to immediately upload files.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkbox**:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Since ReactJS will render everything literally, you need to either explicitly
    control the checked status of your checkboxes or leave it out completely. In the
    preceding snippet, we control the checked status by setting the state of `CheckBoxOne`
    in `handleCheckboxChange`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you provide the `checked` attribute, you must provide an `onChange`
    handler; otherwise, ReactJS will throw a warning in your console. If you want
    to provide a checked value to a checkbox without controlling it, use the `defaultChecked`
    attribute instead.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '**Radio**:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Within a form, only one radio button can be checked. As with checkboxes, you
    can control the checked status by adding a `checked` attribute and an `onChange`
    handler or use `defaultChecked` if you want to precheck a radio button.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding snippet, we used `bind` instead of `refs` to pass the value
    along to the function. In JavaScript, `bind()` produces a new that will have `this`
    set to the first parameter passed to `bind()`. We're not interested in this; however,
    because that's just the synthetic mouse click event, we'll set `this` to `null`
    and fix another argument to the bind using `partial function application`. Simply
    put, we'll provide the radio button name to `handleRadioChange`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'The `handleRadioChange()` function looks like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The reason we're doing it this way is that it's difficult to know which radio
    button reference you need in order to fetch unless you create a unique `onChange`
    handler for each radio button. This is not uncommon though, and either way is
    fine.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '**Textarea**:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Text areas are input fields where you can enter longer paragraphs of text. You
    can add an `onChange` handler if you need to apply functions when text is entered.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating responsive form fields](img/B04943_03_07.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: Using Glyphicons and font-awesome icons
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Glyphicons** is a set of about 200 glyphs provided with Bootstrap. We added
    them to our `index.html` file in the beginning of the chapter, when we fetched
    Bootstrap from a CDN, so they''re already included and ready to be used in your
    app.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: You can use Glyphicons anywhere you would use a text string because they're
    provided as a font set rather than a set of images.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'You add them to your code by importing them with this line of code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You can add a glyph in your code by writing `<Glyphicon glyph="cloud"/>` to
    add a cloud or `<Glyphicon glyph="envelope"/>` to add an envelope.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily add glyphs to input elements using one of the sets of special
    attributes: `addonBefore`, `addonAfter`, `buttonBefore`, or `buttonAfter`.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you want to add a dollar or a euro sign before an input field
    that takes money as an input parameter, use a code block like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The complete set of glyphs and how they look is available in the code distributed
    with this book. It's in the `examples` folder and the file is called `glyphicons.jsx`.
    If you import this file and add it to `app.jsx`, the entire set will be displayed
    in your browser.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap also provides another set of icons in **font awesome**. We included
    this library in the beginning of the chapter in addition to Glyphicons. Before
    you build your app, it's useful to decide between either font-awesome or Glyphicons
    icons so that you have one less library for your users to download.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Font-awesome library doesn''t have a component equivalent to Glyphicons, so
    let''s make one. Create a file called `fontawesome` in your `components` folder
    and add this code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The preceding code should be very familiar. What it does is it takes a single
    property called `icon` and returns a font-awesome icon element. It doesn't verify
    that the icon exists, so you need to familiarize yourself with more than 500 icons
    in the set in advance.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: To use this component, import it by adding `import FontAwesome from './components/fontawesome.jsx';`
    in `app.jsx`, and then in your render code, add `<FontAwesome icon="facebook"/>`
    to display a Facebook icon. You can use this component in the same manner as you
    would use the Glyphicon component, including the preceding input element example.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Creating a responsive landing page
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When developing responsive web apps, there comes a point when you need to differentiate
    between small and large devices in your code. Let's put together a landing page
    and demonstrate how you can use the size of the viewport in your code to present
    your app content.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'This app will be entirely contained in `app.jsx`. Remove the existing code
    in `app.jsx` (or rename it to `example.jsx` if you want to keep a copy of what
    you''ve done), and remove all code in `app.css` as well. Add the following to
    `app.jsx`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We will be relying on the `FontAwesome` component that we created earlier:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We''ll store the viewport height and width as state variables:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The state variables will initially be set to 320 x 480, but as soon as the
    app mounts, we''ll calculate the real values. First, we''ll add an event listener
    that will execute a function anytime the viewport changes. Second, we''ll run
    the function for the first time:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The viewport calculation will use the most appropriate value and store it as
    the component''s state:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We''ll create two `render` functions for the form on the landing page. Note
    that we set all CSS inline inside double curly braces, and that the width will
    automatically be half of the viewport width:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The main difference between the small and the large form is that the large form
    uses input groups to show the input field and the **Submit** button on the same
    horizontal line. The small form puts the button under the input field.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'We added an `onClick` handler to our form, so let''s proceed by adding this
    function:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We won't actually process the click event beyond logging the value, but the
    function shows you how to grab the value from the form based on the event that
    occurs when the user clicks on the **Submit** button.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll the functions for the social icons.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The social icons use the images from the `font-awesome` library. The font size
    is set to 32 pixels in order to show large, crisp buttons that are easy to hit
    with your fingers on smart phones:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This simple snippet toggles the rendering of small and large forms and hides
    the social icons whenever the viewport height is less than 320 pixels:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The margin top will be set to a dynamic pixel value that equals 1/20 of the
    viewport height:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This is how we add the `socialIcons` variable. It will either be a ReactJS
    element or `null`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We reused some of the components from this chapter in this simple app and added
    a few new techniques. You could get the same result using media queries and CSS,
    but you would write more code and split the logic between JavaScript and CSS.
    It may look strange to write style code inline, but one of the main benefits of
    this approach is that it enables you to write very advanced styling rules in the
    same programming language as the rest of your app.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered the aspects around creating a responsive web
    app that will work on any device. We looked at some of the different frameworks
    that are available for ReactJS, and we took a deep dive into using react-bootstrap
    for our purposes. In most cases, we could get by with using the components from
    React-Bootstrap, but in certain cases, such as pictures and media, we also made
    our own components.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we combined a few of the components we made earlier along with some
    new techniques, such as programmatic inline styling and event listeners to tackle
    viewport resizing, and made a simple, responsive landing page.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be working on a real-time search app. We'll be covering
    the concept of data stores and efficient querying and provide a smooth, responsive
    experience for users. Turn the page to get working.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
