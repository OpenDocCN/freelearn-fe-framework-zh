- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Testing and Debugging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和调试
- en: Thanks to its components, React makes it easy to test our applications. There
    are many different tools available that we can use to create tests with React.
    In this chapter, we will cover the most popular ones to understand the benefits
    they provide.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了其组件，React使得测试我们的应用变得容易。有许多不同的工具可供我们使用，我们可以用React创建测试。在本章中，我们将介绍最受欢迎的工具，以了解它们提供的优势。
- en: '**Jest** is an *all-in-one* testing framework solution maintained by Christoph
    Nakazawa from Meta and contributors within the community and aims to give you
    the best developer experience.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jest** 是由Meta的Christoph Nakazawa和社区内的贡献者维护的**一站式**测试框架解决方案，旨在为您提供最佳的开发者体验。'
- en: By the end of this chapter, you’ll be able to create a test environment from
    scratch and write tests for your application’s components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够从头开始创建测试环境并为您的应用组件编写测试。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Why it is important to test our applications and how they help developers move
    faster
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么测试我们的应用很重要以及它们如何帮助开发者更快地工作
- en: How to set up a Jest environment to test components using Enzyme
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置Jest环境以使用Enzyme测试组件
- en: What the React Testing Library is and why it is a *must-have* for testing React
    applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Testing Library是什么以及为什么它是测试React应用的**必备**工具
- en: How to test events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何测试事件
- en: How to implement Vitest
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现Vitest
- en: React DevTools and some error-handling techniques
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React DevTools和一些错误处理技术
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，您需要以下内容：
- en: Node.js 19+
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 19+
- en: Visual Studio Code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: 'You can find the code for this chapter in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter16).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到本章的代码：[https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter16)。
- en: Understanding the benefits of testing
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试的优势
- en: Testing web UIs has always been a difficult job. From unit to end-to-end tests,
    the fact that the interfaces depend on browsers, user interactions, and many other
    variables makes it difficult to implement an effective testing strategy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Web UI一直是一项困难的任务。从单元测试到端到端测试，接口依赖于浏览器、用户交互以及许多其他变量，这使得实施有效的测试策略变得困难。
- en: If you’ve ever tried to write end-to-end tests for the web, you’ll know how
    complex it is to get consistent results and how the results are often affected
    by false negatives due to different factors, such as the network. Other than that,
    user interfaces are frequently updated to improve the experience, maximize conversions,
    or simply add new features.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经尝试为Web编写端到端测试，您就会知道如何获得一致的结果是多么复杂，以及结果通常如何受到网络等不同因素的影响，导致出现假阴性。除此之外，用户界面经常更新以提高体验、最大化转化率或简单地添加新功能。
- en: If tests are hard to write and maintain, developers are less prone to cover
    their applications. On the other hand, tests are important because they make developers
    more confident with their code, which is reflected in speed and quality. If a
    piece of code is well tested (and the tests are well written), developers can
    be sure that it works and is ready to ship. Similarly, thanks to tests, it becomes
    easier to refactor the code because tests guarantee that the functionalities do
    not change during the rewrite.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试难以编写和维护，开发者就不太可能覆盖他们的应用。另一方面，测试很重要，因为它们使开发者对自己的代码更有信心，这体现在速度和质量上。如果一段代码经过良好的测试（并且测试编写得很好），开发者可以确信它能够正常工作并准备好发布。同样，多亏了测试，重构代码变得更加容易，因为测试保证了在重写过程中功能不会改变。
- en: Developers tend to focus on the feature they are currently implementing, and
    sometimes it is hard to know if other parts of the application are affected by
    those changes. Tests help to avoid regressions because they can tell if the new
    code breaks the old tests. Greater confidence in writing new features leads to
    faster releases.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者往往专注于他们当前正在实施的功能，有时很难知道应用的其他部分是否受到了这些更改的影响。测试有助于避免回归，因为它们可以告诉我们新代码是否破坏了旧测试。对编写新功能的更大信心导致更快地发布。
- en: Testing the main functionalities of an application makes the code base more
    solid, and whenever a new bug is found, it can be reproduced, fixed, and covered
    by tests so that it does not happen again in the future.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用程序的主要功能可以使代码库更加稳固，每当发现新的错误时，它都可以被重现、修复并通过测试来防止未来再次发生。
- en: Luckily, React (and the component era) makes testing user interfaces easy and
    efficient. Testing components, or trees of components, is a less arduous job because
    every single part of the application has its responsibilities and boundaries.
    If components are built in the right way, if they are pure and aim for composability
    and reusability, they can be tested as simple functions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，React（以及组件时代）使得测试用户界面变得简单高效。测试组件或组件树是一项不那么繁重的任务，因为应用程序的每个部分都有其职责和边界。如果组件以正确的方式构建，如果它们是纯的，并且旨在具有可组合性和可重用性，那么它们可以像简单的函数一样进行测试。
- en: Another great power that modern tools bring us is the ability to run tests using
    Node.js and the console. Spinning up a browser for every single test makes tests
    slower and less predictable, degrading the developer experience; instead, running
    the tests using the console is faster.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现代工具带给我们的另一个强大功能是使用Node.js和控制台运行测试的能力。为每个测试启动浏览器会使测试变慢且不可预测，降低开发者的体验；相反，使用控制台运行测试要快得多。
- en: Testing components only in the console can sometimes give unexpected behaviors
    when they are rendered in a real browser, but in my experience, this is rare.
    When we test React components, we want to make sure that they work properly and
    that, given different sets of props, their output is always correct.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在控制台中测试组件有时在它们在真实浏览器中渲染时可能会出现意外的行为，但根据我的经验，这种情况很少见。当我们测试React组件时，我们想要确保它们能正常工作，并且给定不同的props集合，它们的输出始终是正确的。
- en: We may also want to cover all the various states that a component can have.
    The state might change by clicking a button, so we write tests to check if all
    the event handlers are doing what they are supposed to do.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能想要覆盖组件可能具有的所有各种状态。状态可能会通过点击按钮而改变，因此我们编写测试来检查所有事件处理器是否正在执行它们应该执行的操作。
- en: When all the functionalities of the component are covered, but we want to do
    more, we can write tests to verify the component’s behavior on **edge cases**.
    Edge cases are states that the component can assume when, for example, all the
    props are null or there is an error. Once the tests are written, we can be pretty
    confident that the component behaves as expected.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件的所有功能都被覆盖，但我们还想做更多的时候，我们可以编写测试来验证组件在**边缘情况**下的行为。边缘情况是组件可以假设的状态，例如，当所有props都是null或存在错误时。一旦编写了测试，我们就可以相当有信心地认为组件的行为符合预期。
- en: Testing a single component is great, but it does not guarantee that multiple
    individually tested components will still work once they are put together. As
    we will see later, with React, we can mount a tree of components and test the
    integration between them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 测试单个组件固然很好，但这并不能保证将多个单独测试过的组件组合在一起后仍然能正常工作。正如我们稍后将会看到的，使用React，我们可以挂载一个组件树并测试它们之间的集成。
- en: There are different techniques that we can use to write tests, and one of the
    most popular ones is **test-driven development** (**TDD**). Applying TDD means
    writing the tests first and then writing the code to pass the tests.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的技术来编写测试，其中最受欢迎的一种是**测试驱动开发**（**TDD**）。应用TDD意味着先编写测试，然后再编写代码以通过测试。
- en: Following this pattern helps us to write better code because we are forced to
    think more about the design before implementing the functionalities, which usually
    leads to higher quality.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这种模式有助于我们编写更好的代码，因为我们被迫在实现功能之前更多地思考设计，这通常会导致更高的代码质量。
- en: So, now that we have covered all of this, let’s roll up our sleeves and start
    writing tests for our React components. We will also learn about a cool way of
    writing code called test-driven development and use a handy tool called Jest to
    simplify our JavaScript testing. Are you ready? Let’s dive in and start working
    with real code!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经涵盖了所有这些内容，那就让我们挽起袖子开始为我们的React组件编写测试。我们还将了解一种称为测试驱动开发（test-driven development）的酷炫编程方式，并使用一个名为Jest的便捷工具来简化我们的JavaScript测试。准备好了吗？让我们深入其中，开始使用真实代码进行工作！
- en: Painless JavaScript testing with Jest
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest进行无痛苦JavaScript测试
- en: The most important way to learn how to test React components in the right way
    is by writing some code, and that is what we are going to do in this section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何正确测试React组件最重要的方式是通过编写代码，这正是我们将在本节中要做的。
- en: The React documentation says that Facebook uses Jest to tests its components.
    However, React does not force you to use a particular test framework, and you
    can use your favorite one without any problems. To see Jest in action, we are
    going to create a project from scratch, install all the dependencies, and write
    a component with some tests. It’ll be fun!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: React 文档说明 Facebook 使用 Jest 来测试其组件。然而，React 并不强制你使用特定的测试框架，你可以使用你喜欢的任何一个而没有任何问题。为了看到
    Jest 的实际应用，我们将从头创建一个项目，安装所有依赖项，并编写一个带有一些测试的组件。这将很有趣！
- en: 'The first thing to do is to move into a new folder and run the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是要进入一个新的文件夹并运行以下命令：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once `package.json` is created, we can start installing the dependencies, with
    the first one being the `jest` package itself:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 `package.json`，我们就可以开始安装依赖项，第一个是 `jest` 包本身：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To tell `npm` that we want to use the `jest` command to run the tests, we must
    add the following scripts to `package.json`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉 `npm` 我们想使用 `jest` 命令来运行测试，我们必须将以下脚本添加到 `package.json` 中：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To write components and tests using ES6 and JSX, we must install all Babel-related
    packages so that Jest can use them to transpile and understand the code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 ES6 和 JSX 编写组件和测试，我们必须安装所有与 Babel 相关的包，以便 Jest 可以使用它们进行转译和理解代码。
- en: 'The second set of dependencies is installed as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组依赖项的安装方式如下：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you may know, we now have to create a `.babelrc` file, which is used by Babel
    to know the presets and the plugins that we would like to use inside the project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，我们现在必须创建一个 `.babelrc` 文件，它被 Babel 用于知道我们希望在项目中使用的预设和插件。
- en: 'The `.babelrc` file looks like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`.babelrc` 文件看起来如下：'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, it is time to install React and ReactDOM, which we need to create and
    render components:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候安装 React 和 ReactDOM，这是我们创建和渲染组件所需的：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The setup is ready, and we can run Jest against the ES6 code and render our
    components in the DOM, but there is one more thing to do.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 设置已完成，我们可以运行 Jest 对 ES6 代码进行测试，并在 DOM 中渲染我们的组件，但还有一件事要做。
- en: 'We need to install `jest-environment-jsdom`, `@testing-library/jest-dom`, and
    `@testing-library/react`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装 `jest-environment-jsdom`、`@testing-library/jest-dom` 和 `@testing-library/react`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After you have installed these packages, you must create the `jest.config.js`
    file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在你安装了这些包之后，你必须创建 `jest.config.js` 文件：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, let’s create the `setUpTests.ts` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建 `setUpTests.ts` 文件：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s imagine we have a `Hello` component (`src/components/Hello/index.tsx`):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象我们有一个 `Hello` 组件 (`src/components/Hello/index.tsx`)：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to test this component, we need to create a file with the same name
    but add the `.test` (or `.spec`) suffix to the new file. This will be our test
    file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个组件，我们需要创建一个具有相同名称但添加 `.test`（或 `.spec`）后缀的新文件。这将是我们的测试文件：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, in order to run the test, you need to execute the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了运行测试，你需要执行以下命令：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see this result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下结果：
- en: '![Text  Description automatically generated](img/B18414_16_01.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![文本自动生成描述](img/B18414_16_01.png)'
- en: 'Figure 16.1: npm test'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1：npm 测试
- en: 'The **PASS** label means that all tests have been passed successfully; if at
    least one test failed, you will see the **FAIL** label. Let’s change one of our
    tests to make it fail:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**PASS** 标签表示所有测试都已成功通过；如果至少有一个测试失败，你将看到 **FAIL** 标签。让我们更改我们的一个测试使其失败：'
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![Text  Description automatically generated](img/B18414_16_02.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![文本自动生成描述](img/B18414_16_02.png)'
- en: 'Figure 16.2: Fail tests'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2：失败的测试
- en: As you can see, the **FAIL** label is specified with an **X**. Also, the expected
    and received values provide useful information, and you can see which value is
    expected and which value is received.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**FAIL** 标签用 **X** 指定。此外，预期的和接收到的值提供了有用的信息，你可以看到预期的值和接收到的值。
- en: 'If you want to see the coverage percentage of all your unit tests, you can
    execute the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看所有单元测试的覆盖率百分比，你可以执行以下命令：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_16_03.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本自动生成描述](img/B18414_16_03.png)'
- en: 'Figure 16.3: Passing tests'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3：通过测试
- en: 'The coverage also generates an HTML version of the result; it creates a directory
    called `coverage` and inside another called `Icov-report`. If you open the `index.xhtml`
    file in your browser, you will see the HTML version as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率还会生成结果的 HTML 版本；它创建一个名为 `coverage` 的目录，并在其中创建一个名为 `Icov-report` 的目录。如果你在浏览器中打开
    `index.xhtml` 文件，你会看到以下 HTML 版本：
- en: '![Graphical user interface, application, table  Description automatically generated](img/B18414_16_04.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、应用程序、表格描述自动生成](img/B18414_16_04.png)'
- en: 'Figure 16.4: Icov-report'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4：Icov-report
- en: Now that you have done your first tests and you know how to collect the coverage
    data, let’s see how we can test events in the next section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了第一次测试，并且知道如何收集覆盖率数据，让我们看看如何在下一节测试事件。
- en: Testing events
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试事件
- en: 'Events are very common in any web application, and we need to test them as
    well, so let’s learn how to test events. For this, let’s create a new `ShowInformation`
    component:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在任何网络应用中都非常常见，我们同样需要测试它们，所以让我们学习如何测试事件。为此，让我们创建一个新的 `ShowInformation` 组件：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let’s create the test file at `src/components/ShowInformation/index.test.tsx`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `src/components/ShowInformation/index.test.tsx` 创建测试文件：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run the test and it works fine, you should see this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行测试并且一切正常，你应该会看到以下内容：
- en: '![Text  Description automatically generated](img/B18414_16_05.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_16_05.png)'
- en: 'Figure 16.5: Passing tests'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5：通过测试
- en: Introducing Vitest
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Vitest
- en: '**Vitest** is a unit test framework built on **Vite**, designed for speed and
    minimal configuration. It serves as a replacement for various testing tools such
    as Jest, Mocha, and Chai. Since Vitest is built on top of the Jest API, if you
    already know how to use Jest, it works in a similar manner.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vitest** 是一个基于 **Vite** 构建的单元测试框架，旨在追求速度和最小化配置。它可作为 Jest、Mocha 和 Chai 等各种测试工具的替代品。由于
    Vitest 是建立在 Jest API 之上的，如果你已经知道如何使用 Jest，它的工作方式将非常相似。'
- en: In this context, we will utilize Vite, a build tool that aims to provide a fast
    and lean development experience for modern web projects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，我们将利用 Vite，这是一个旨在为现代网络项目提供快速和精简开发体验的构建工具。
- en: 'Firstly, you need to install Vite globally with:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要使用以下命令全局安装 Vite：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After it’s installed, you need to create your first project with the `npm`
    command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你需要使用 `npm` 命令创建你的第一个项目：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It will ask you for the project name. You can use `my-first-vite-project`,
    then for the framework you want to use (`React`), and finally, choose the variant
    (`TypeScript`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它会要求你输入项目名称。你可以使用 `my-first-vite-project`，然后选择你想要使用的框架（`React`），最后选择变体（`TypeScript`）：
- en: '![](img/B18414_16_06.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_16_06.png)'
- en: 'Figure 16.6: npm create vite@latest'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.6：npm create vite@latest
- en: 'Next, you need to install the project dependencies and run the `npm run dev`
    command. If you do so, you will see something similar to the following on port
    `5173`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要安装项目依赖并运行 `npm run dev` 命令。如果你这样做，你将在端口 `5173` 上看到类似以下内容：
- en: '![](img/B18414_16_07.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_16_07.png)'
- en: 'Figure 16.7: Vite app'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.7：Vite 应用
- en: Installing and configuring Vitest
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 Vitest
- en: 'Once you have your Vite app running, it is time to install Vitest. To do so,
    you simply need to run this command in your project terminal:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的 Vite 应用运行起来，就是时候安装 Vitest 了。要做到这一点，你只需要在你的项目终端中运行这个命令：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After you’ve installed Vitest, you need to modify the `vite.config.ts` file
    with the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 Vitest 之后，你需要使用以下代码修改 `vite.config.ts` 文件：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, we will use the `jsdom` environment, so you’ll need to install
    it as well:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将使用 `jsdom` 环境，因此你也需要安装它：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Additionally, Vitest offers a plugin called Vitest UI, which enables Vitest
    to provide a visually appealing user interface for viewing and interacting with
    your tests in the browser. While it is an optional plugin, we will be using it.
    You can install it by executing the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Vitest 还提供了一个名为 Vitest UI 的插件，它使 Vitest 能够在浏览器中提供直观的用户界面来查看和交互测试。虽然这是一个可选插件，但我们将使用它。你可以通过执行以下命令来安装它：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In order to test your code, you need to add the test script to your `package.json`
    file using the `vitest --ui` command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的代码，你需要使用 `vitest --ui` 命令将测试脚本添加到你的 `package.json` 文件中：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will be using the same `Hello` component that we used for Jest, although
    there will be a few differences. You need to save this component at `src/components/Hello/index.tsx`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与 Jest 相同的 `Hello` 组件，尽管会有一些差异。你需要将此组件保存到 `src/components/Hello/index.tsx`：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then you need to create a test file called `index.test.tsx` under the same
    component directory:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要在同一组件目录下创建一个名为 `index.test.tsx` 的测试文件：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, the code is quite similar to Jest. However, one of the main
    differences is that we are now importing all the testing methods we will use,
    such as `afterAll`, `describe`, `expect`, and `it`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码与 Jest 非常相似。然而，主要区别之一是我们现在正在导入我们将要使用的所有测试方法，例如 `afterAll`、`describe`、`expect`
    和 `it`。
- en: 'If you run the `test` command, you should see something similar to this in
    your terminal:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行`test`命令，您应该在您的终端中看到类似以下的内容：
- en: '![](img/B18414_16_08.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_16_08.png)'
- en: 'Figure 16.8: npm test'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：npm测试
- en: 'If you have noticed, there is a link that is generated by the Vitest UI plugin
    we installed earlier. If you click on that link, you will see the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经注意到，这是由我们之前安装的Vitest UI插件生成的链接。如果您点击该链接，您将看到以下内容：
- en: '![](img/B18414_16_09.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_16_09.png)'
- en: 'Figure 16.9: Vitest UI'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：Vitest UI
- en: 'Currently, we only have one test file, but if you add more, you will see them
    listed on the sidebar on the left. Now, let’s click on our current `Hello` test:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只有一个测试文件，但如果您添加更多，您将在左侧侧边栏上看到它们。现在，让我们点击我们当前的`Hello`测试：
- en: '![](img/B18414_16_10.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_16_10.png)'
- en: Figure 16.10 – Report
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 – 报告
- en: 'You will be able to see the test cases that are passing correctly. However,
    one of the most interesting advantages of this UI plugin is that you can even
    modify the test code directly in the browser by clicking on the **Code** tab:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够看到正确通过的测试用例。然而，这个UI插件最有趣的优势之一是您甚至可以直接在浏览器中通过点击**代码**标签来修改测试代码：
- en: '![](img/B18414_16_11.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_16_11.png)'
- en: 'Figure 16.11: Code'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11：代码
- en: 'Let’s modify our code to intentionally cause some tests to fail. You can change
    the first test to say `"Hello Foo"` instead of `"Hello World"` and make sure to
    save it (*Cmd + S*):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的代码，故意让一些测试失败。您可以将第一个测试改为“Hello Foo”而不是“Hello World”，并确保保存（*Cmd + S*）：
- en: '![](img/B18414_16_12.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_16_12.png)'
- en: 'Figure 16.12: Failing test'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12：失败的测试
- en: As you can see, now our first test fails because it is unable to find the `"Hello
    Foo"` text.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在我们的第一次测试失败了，因为它无法找到“Hello Foo”文本。
- en: Enabling globals
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用全局变量
- en: Personally, I prefer importing all the necessary functions or variables in a
    file. However, I am aware that when creating numerous test files, repeatedly importing
    global testing variables like `describe`, `it`, `expect`, and so on, can become
    tedious and cumbersome.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我更喜欢在一个文件中导入所有必要的函数或变量。然而，我意识到在创建大量测试文件时，反复导入全局测试变量如`describe`、`it`、`expect`等可能会变得繁琐和麻烦。
- en: 'Fortunately, Vitest offers a configuration option to enable `globals`, eliminating
    the need to import them every time. To enable this feature, you need to modify
    your `vite.config.ts` file with the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Vitest提供了一个配置选项来启用`globals`，从而消除了每次都需要导入它们的需要。要启用此功能，您需要使用以下代码修改您的`vite.config.ts`文件：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After making the changes mentioned earlier, you also need to update your `tsconfig.json`
    file by adding the global types:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行前面提到的更改后，您还需要通过添加全局类型来更新您的`tsconfig.json`文件：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After following these steps, you will now be able to remove the import of the
    `globals` in your test file. If you still encounter any TypeScript errors, it
    is likely that you will need to restart your TypeScript server or reload the window
    in your VSCode.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循这些步骤之后，您现在将能够从您的测试文件中移除对`globals`的导入。如果您仍然遇到任何TypeScript错误，您可能需要重新启动您的TypeScript服务器或重新加载VSCode中的窗口。
- en: In-source testing
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在源代码中测试
- en: Vitest also offers a way to run tests within your source code alongside the
    implementation, similar to Rust’s module tests.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest还提供了一种在源代码与实现一起运行测试的方法，类似于Rust的模块测试。
- en: Personally, I have an old-school approach, and I usually prefer to have a separate
    test file for my testing. However, there are situations where the component or
    functions being tested are very small, and creating a new test file may seem excessive.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我有一个老式的做法，我通常更喜欢为我的测试保留一个单独的测试文件。然而，在某些情况下，被测试的组件或函数非常小，创建一个新的测试文件可能看起来有些过度。
- en: 'To enable this feature, you need to modify your `vite.config.ts` file and add
    the `includeSource` option:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此功能，您需要修改您的`vite.config.ts`文件并添加`includeSource`选项：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To resolve the TypeScript issues, you need to make another change by adding
    the `vitest/importMeta` type to your `tsconfig.json` file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决TypeScript问题，您需要在您的`tsconfig.json`文件中添加`vitest/importMeta`类型进行另一个更改：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, let’s move our `Hello` component test file inside the same `Hello` component.
    Again, this is optional and is just to demonstrate that it is possible to do so.
    In the end, you can decide which testing approach to use.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的`Hello`组件测试文件移到同一个`Hello`组件内部。再次强调，这是可选的，只是为了演示这是可能的。最后，您可以选择使用哪种测试方法。
- en: 'To achieve this, we need to add an `if` statement inside our `Hello` component
    to check if we are in testing mode. We can accomplish this with the following
    code: `if (import.meta.vitest)`. Inside this block, we will move all the testing
    cases, and we will also require the **React Testing Library** methods only within
    that block. This way, our code will resemble the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要在我们的 `Hello` 组件内部添加一个 `if` 语句来检查我们是否处于测试模式。我们可以用以下代码来完成这个任务：`if (import.meta.vitest)`。在这个块内部，我们将移动所有的测试用例，并且我们也将只在该块内部要求
    **React 测试库** 方法。这样，我们的代码将类似于以下内容：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now you can delete your previous file (`index.test.tsx`). If you run your tests
    again, they should work the same.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以删除你之前的文件（`index.test.tsx`）。如果你再次运行你的测试，它们应该会按预期工作。
- en: 'The difference is that now you will be able to see the entire code (`Component`
    and `Test` cases):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于现在你将能够看到整个代码（`Component` 和 `Test` 用例）：
- en: '![](img/B18414_16_13.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_16_13.png)'
- en: 'Figure 16.13: Passing test'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.13：通过测试
- en: This approach may potentially speed up the testing process for a component or
    a function. However, personally, I still prefer to perform testing in a separate
    test file. Nevertheless, you are free to choose what works best for you and your
    project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能会加快组件或函数的测试过程。然而，我个人仍然更喜欢在单独的测试文件中进行测试。尽管如此，你可以自由选择对你和你的项目最有效的方法。
- en: After exploring the concept of in-source testing, let’s proceed to understand
    how React DevTools can be effectively applied in our development process to optimize
    our application’s performance and ensure it runs smoothly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了源代码测试的概念之后，让我们继续了解如何有效地将 React DevTools 应用于我们的开发过程中，以优化我们应用程序的性能并确保其平稳运行。
- en: Using React DevTools
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React DevTools
- en: When testing in the console is not enough, and we want to inspect our application
    while it is running inside the browser, we can use React DevTools.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当在控制台测试不够时，并且我们想在浏览器内运行的应用程序中检查我们的应用程序时，我们可以使用 React DevTools。
- en: 'You can install this as a Chrome extension at the following URL: [https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgo
    fadopljbjfkapdkoienihi?hl=en](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下网址将其作为 Chrome 扩展安装：[https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgo
    fadopljbjfkapdkoienihi?hl=en](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en)。
- en: The installation adds a tab to the Chrome DevTools called **React**, where you
    can inspect the rendered tree of components and check which properties they have
    received and what their state is at a particular point in time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 安装会在 Chrome DevTools 中添加一个名为 **React** 的标签页，你可以检查组件的渲染树并检查它们在特定时间点接收了哪些属性以及它们的状态。
- en: Props and states can be read, and they can be changed in real time to trigger
    updates in the UI and see the results straight away. This is a must-have tool,
    and in the most recent versions, it has a new feature that can be enabled by checking
    the **Trace React Updates** checkbox.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 可以读取属性和状态，并且可以实时更改它们以触发 UI 的更新并立即看到结果。这是一个必备的工具，在最新版本中，它有一个可以通过勾选**跟踪 React
    更新**复选框来启用的新功能。
- en: When this functionality is enabled, we can use our application and see which
    components get updated when we perform a particular action. The updated components
    are highlighted with colored rectangles, and it becomes easy to spot possible
    optimizations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个功能被启用时，我们可以使用我们的应用程序，并查看当我们执行特定操作时哪些组件被更新。更新的组件会用彩色矩形突出显示，这使得发现可能的优化变得容易。
- en: Using Redux DevTools
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Redux DevTools
- en: 'If you are using Redux in your application, you probably want to use Redux
    DevTools to be able to debug your Redux flow. You can install it at the following
    URL: [https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=es](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=es)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在你的应用程序中使用 Redux，你可能想使用 Redux DevTools 来调试你的 Redux 流程。你可以在以下网址安装它：[https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=es](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=es)
- en: 'Also, you need to install the `redux-devtools-extension` package:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要安装 `redux-devtools-extension` 包：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once you have installed React DevTools and Redux DevTools, you will need to
    configure them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了 React DevTools 和 Redux DevTools，你将需要配置它们。
- en: 'If you try to use Redux DevTools directly, it won’t work; this is because we
    need to pass the `composeWithDevTools` method into the Redux store; this should
    be the `configureStore.ts` file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试直接使用 Redux DevTools，它将不会工作；这是因为我们需要将 `composeWithDevTools` 方法传递给 Redux
    存储；这应该是 `configureStore.ts` 文件：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is the best tool to test our Redux applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试我们 Redux 应用程序的最佳工具。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you gained a comprehensive understanding of the benefits of
    testing, as well as the various frameworks and tools available for testing React
    components. You learned how to implement and test components and events using
    the React Testing Library and how to use Jest coverage to optimize your testing
    process. Additionally, you explored tools such as React DevTools and Redux DevTools
    to further enhance your development experience. It’s important to keep in mind
    common solutions when it comes to testing complex components, such as higher-order
    components or forms with multiple nested fields, to ensure that your tests accurately
    reflect the functionality of your application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你全面了解了测试的好处，以及可用于测试 React 组件的各种框架和工具。你学习了如何使用 React Testing Library 来实现和测试组件和事件，以及如何使用
    Jest 覆盖率来优化你的测试过程。此外，你还探索了 React DevTools 和 Redux DevTools 等工具，以进一步增强你的开发体验。在测试复杂组件时，如高阶组件或具有多个嵌套字段的表单，记住常见的解决方案是很重要的，以确保你的测试能够准确反映应用程序的功能。
- en: In the next chapter, you will learn how to deploy your application to production.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何将你的应用程序部署到生产环境。
