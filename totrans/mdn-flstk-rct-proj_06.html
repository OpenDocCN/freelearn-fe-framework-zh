<html><head></head><body>
<div id="_idContainer052" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-75"><a id="_idTextAnchor076" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-76" class="calibre5"><a id="_idTextAnchor077" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Integrating a Frontend Using React and TanStack Query</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">After designing, implementing, and testing our backend service, it’s now time to create a frontend to interface with the backend. </span><span class="kobospan" id="kobo.3.2">First, we will start by setting up a full-stack React project based on the Vite boilerplate and the backend service created in the previous chapters. </span><span class="kobospan" id="kobo.3.3">Then, we are going to create a basic user interface for our blog application. </span><span class="kobospan" id="kobo.3.4">Finally, we will use TanStack Query, a data fetching library to handle backend state, to integrate the backend API into the frontend. </span><span class="kobospan" id="kobo.3.5">By the end of this chapter, we will have successfully developed our first </span><span><span class="kobospan" id="kobo.4.1">full-stack application!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.6.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.7.1">Principles </span><span><span class="kobospan" id="kobo.8.1">of React</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Setting up a full-stack </span><span><span class="kobospan" id="kobo.10.1">React project</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">Creating the user interface for </span><span><span class="kobospan" id="kobo.12.1">our application</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Integrating the backend service using </span><span><span class="kobospan" id="kobo.14.1">TanStack Query</span></span></li>
</ul>
<h1 id="_idParaDest-77" class="calibre5"><a id="_idTextAnchor078" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.15.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.16.1">Before we start, please install all requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.17.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.18.1">, </span><em class="italic"><span class="kobospan" id="kobo.19.1">Preparing for Full-stack Development</span></em><span class="kobospan" id="kobo.20.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.21.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.22.1">, </span><em class="italic"><span class="kobospan" id="kobo.23.1">Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.24.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.25.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.26.1">The versions listed in those chapters are the ones used in the book. </span><span class="kobospan" id="kobo.26.2">While installing a newer version should not be an issue, please note that certain steps might work differently on a newer version. </span><span class="kobospan" id="kobo.26.3">If you are having an issue with the code and steps provided in this book, please try using the versions mentioned in </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.27.1">Chapter 1</span></em></span></a> <span><span class="kobospan" id="kobo.28.1">and </span></span><span><em class="italic"><span class="kobospan" id="kobo.29.1">2</span></em></span><span><span class="kobospan" id="kobo.30.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.32.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch4" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.33.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch4</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.34.1">If you cloned the full repository for the book, Husky may not find the </span><strong class="source-inline"><span class="kobospan" id="kobo.35.1">.git</span></strong><span class="kobospan" id="kobo.36.1"> directory when running </span><strong class="source-inline"><span class="kobospan" id="kobo.37.1">npm install</span></strong><span class="kobospan" id="kobo.38.1">. </span><span class="kobospan" id="kobo.38.2">In that case, just run </span><strong class="source-inline"><span class="kobospan" id="kobo.39.1">git init</span></strong><span class="kobospan" id="kobo.40.1"> in the root of the corresponding </span><span><span class="kobospan" id="kobo.41.1">chapter folder.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.42.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.43.1">at: </span></span><a href="https://youtu.be/WXqJu2Ut7Hs" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.44.1">https://youtu.be/WXqJu2Ut7Hs</span></span></a></p>
<h1 id="_idParaDest-78" class="calibre5"><a id="_idTextAnchor079" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.45.1">Principles of React</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.46.1">Before we start learning how to set up a full-stack React project, let’s revisit the three fundamental principles of React. </span><span class="kobospan" id="kobo.46.2">These principles allow us to easily write scalable </span><span><span class="kobospan" id="kobo.47.1">web applications:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.48.1">Declarative</span></strong><span class="kobospan" id="kobo.49.1">: Instead of </span><a id="_idIndexMarker250" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.50.1">telling React how to do things, we tell it what we want it to do. </span><span class="kobospan" id="kobo.50.2">As a result, we can easily design our applications and React will efficiently update and render just the right components when the data changes. </span><span class="kobospan" id="kobo.50.3">For example, the following code, which duplicates strings in an array is imperative, which is the opposite </span><span><span class="kobospan" id="kobo.51.1">of declarative:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.52.1">
const input = ['a', 'b', 'c']
let result = []
for (let i = 0; i &lt; input.length; i++) {
  result.push(input[i] + input[i])
}
console.log(result) // prints: [ 'aa', 'bb', 'cc' ]</span></pre><p class="calibre3"><span class="kobospan" id="kobo.53.1">As we can see, in imperative code, we need to tell JavaScript exactly what to do, step by step. </span><span class="kobospan" id="kobo.53.2">However, with declarative code, we can simply tell the computer what we want, </span><span><span class="kobospan" id="kobo.54.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.55.1">const input = ['a', 'b', 'c']
</span><strong class="bold1"><span class="kobospan1" id="kobo.56.1">const result = input.map(str =&gt; str + str)</span></strong><span class="kobospan1" id="kobo.57.1">
console.log(result) // prints: ['aa', 'bb', 'cc']</span></pre><p class="calibre3"><span class="kobospan" id="kobo.58.1">In this declarative code, we tell the computer that we want to map each element of the </span><strong class="source-inline"><span class="kobospan" id="kobo.59.1">input</span></strong><span class="kobospan" id="kobo.60.1"> array from </span><strong class="source-inline"><span class="kobospan" id="kobo.61.1">str</span></strong><span class="kobospan" id="kobo.62.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.63.1">str + str</span></strong><span class="kobospan" id="kobo.64.1">. </span><span class="kobospan" id="kobo.64.2">As you can see, declarative code is much </span><span><span class="kobospan" id="kobo.65.1">more concise.</span></span></p></li> <li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.66.1">Component-based</span></strong><span class="kobospan" id="kobo.67.1">: React encapsulates components that manage their own state and views and then allows us to compose them in order to create complex </span><span><span class="kobospan" id="kobo.68.1">user interfaces.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.69.1">Learn once, write anywhere</span></strong><span class="kobospan" id="kobo.70.1">: React does not make assumptions about your technology stack and tries to ensure that you can develop apps without rewriting existing code as</span><a id="_idIndexMarker251" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.71.1"> much </span><span><span class="kobospan" id="kobo.72.1">as possible.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.73.1">React’s three fundamental principles make it easy to write code, encapsulate components, and share code across multiple platforms. </span><span class="kobospan" id="kobo.73.2">Instead of reinventing the wheel, React tries to make use of existing JavaScript features as much as possible. </span><span class="kobospan" id="kobo.73.3">As a result, we will learn software design patterns that will be applicable in many more cases than just designing </span><span><span class="kobospan" id="kobo.74.1">user interfaces.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.75.1">Now that we have learned the fundamental principles of React, let’s get started setting up a full-stack </span><span><span class="kobospan" id="kobo.76.1">React project!</span></span></p>
<h1 id="_idParaDest-79" class="calibre5"><a id="_idTextAnchor080" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.77.1">Setting up a full-stack React project</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.78.1">Before we can start</span><a id="_idIndexMarker252" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.79.1"> developing our frontend application, we first need to merge our previously created frontend boilerplate based on Vite with the backend service created in </span><a href="B19385_03_split_000.xhtml#_idTextAnchor050" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.80.1">Chapter 3</span></em></span></a><span class="kobospan" id="kobo.81.1">, </span><em class="italic"><span class="kobospan" id="kobo.82.1">Implementing a Backend Using Express, Mongoose ODM, and Jest</span></em><span class="kobospan" id="kobo.83.1">. </span><span class="kobospan" id="kobo.83.2">Let’s merge them now by following </span><span><span class="kobospan" id="kobo.84.1">these steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.85.1">Copy the </span><strong class="source-inline1"><span class="kobospan" id="kobo.86.1">ch1</span></strong><span class="kobospan" id="kobo.87.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.88.1">ch4</span></strong><span class="kobospan" id="kobo.89.1"> folder, </span><span><span class="kobospan" id="kobo.90.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.91.1">$ cp -R ch1 ch4</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.92.1">Copy the </span><strong class="source-inline1"><span class="kobospan" id="kobo.93.1">ch3</span></strong><span class="kobospan" id="kobo.94.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.95.1">ch4/backend</span></strong><span class="kobospan" id="kobo.96.1"> folder, </span><span><span class="kobospan" id="kobo.97.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.98.1">$ cp -R ch3 ch4/backend</span></strong></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.99.1">Delete</span></em><span class="kobospan" id="kobo.100.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.101.1">.git</span></strong><span class="kobospan" id="kobo.102.1"> folder in the copied </span><strong class="source-inline1"><span class="kobospan" id="kobo.103.1">ch4/backend</span></strong><span class="kobospan" id="kobo.104.1"> folder, </span><span><span class="kobospan" id="kobo.105.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.106.1">$ rm -rf ch4/backend/.git</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.107.1">Open the new </span><strong class="source-inline1"><span class="kobospan" id="kobo.108.1">ch4</span></strong><span class="kobospan" id="kobo.109.1"> folder in </span><span><span class="kobospan" id="kobo.110.1">VS Code.</span></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.111.1">Remove</span></em><span class="kobospan" id="kobo.112.1"> the Husky </span><strong class="source-inline1"><span class="kobospan" id="kobo.113.1">prepare</span></strong><span class="kobospan" id="kobo.114.1"> script (the line is highlighted in the code snippet) from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.115.1">backend/package.json</span></strong><span class="kobospan" id="kobo.116.1"> file, as we already have Husky set up in the </span><span><span class="kobospan" id="kobo.117.1">root directory:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.118.1">
  "scripts": {
    "dev": "nodemon src/index.js",
    "start": "node src/index.js",
    "test": "NODE_OPTIONS=--experimental-vm-modules jest",
    "lint": "eslint src"</span><strong class="bold1"><span class="kobospan1" id="kobo.119.1">,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.120.1">    "prepare": "husky install"</span></strong><span class="kobospan1" id="kobo.121.1">
  },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.122.1">Also </span><em class="italic"><span class="kobospan" id="kobo.123.1">remove</span></em><span class="kobospan" id="kobo.124.1"> the</span><a id="_idIndexMarker253" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.125.1"> following </span><strong class="source-inline1"><span class="kobospan" id="kobo.126.1">lint-staged</span></strong><span class="kobospan" id="kobo.127.1"> config from the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.128.1">backend/package.json</span></strong></span><span><span class="kobospan" id="kobo.129.1"> file:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.130.1">  "lint-staged": {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.131.1">    "**/*.{js,jsx}": [</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.132.1">      "npx prettier --write",</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.133.1">      "npx eslint --fix"</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.134.1">    ]</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.135.1">  }</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.136.1">Then, </span><em class="italic"><span class="kobospan" id="kobo.137.1">remove</span></em><span class="kobospan" id="kobo.138.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.139.1">backend/.husky</span></strong><span class="kobospan" id="kobo.140.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.141.1">backend/.vscode</span></strong><span class="kobospan" id="kobo.142.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.143.1">backend/.git</span></strong></span><span><span class="kobospan" id="kobo.144.1"> folders.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.145.1">To make sure all dependencies are installed properly, run the following command in the root of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.146.1">ch4</span></strong></span><span><span class="kobospan" id="kobo.147.1"> folder:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.148.1">$ npm install</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.149.1">Also go to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.150.1">backend/</span></strong><span class="kobospan" id="kobo.151.1"> directory and install all </span><span><span class="kobospan" id="kobo.152.1">dependencies there:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.153.1">$ cd backend/</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.154.1">$ npm install</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.155.1">We can</span><a id="_idIndexMarker254" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.156.1"> now also remove the </span><strong class="source-inline1"><span class="kobospan" id="kobo.157.1">husky</span></strong><span class="kobospan" id="kobo.158.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.159.1">lint-staged</span></strong><span class="kobospan" id="kobo.160.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.161.1">@commitlint</span></strong><span class="kobospan" id="kobo.162.1"> packages from the backend project, as we already have it set up in the main </span><span><span class="kobospan" id="kobo.163.1">project folder:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.164.1">$ npm uninstall husky lint-staged \</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.165.1">  @commitlint/cli @commitlint/config-conventional</span></strong></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.166.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.167.1">It is always a good idea to regularly check which packages you still need and which you can get rid of, to keep your project clean. </span><span class="kobospan" id="kobo.167.2">In this case, we copied code from another project, but do not need the Husky / lint-staged / commitlint setup, as we already have it set up in the root of </span><span><span class="kobospan" id="kobo.168.1">our project.</span></span></p>
<ol class="calibre15">
<li value="11" class="calibre11"><span class="kobospan" id="kobo.169.1">Now go back to the root of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.170.1">ch4</span></strong><span class="kobospan" id="kobo.171.1"> folder and run the following command to start the </span><span><span class="kobospan" id="kobo.172.1">frontend server:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.173.1">$ cd ../</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.174.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.175.1">Open the frontend in your browser by going to the URL shown by </span><span><span class="kobospan" id="kobo.176.1">Vite: </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.177.1">http://localhost:5173/</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.178.1">Open </span><strong class="source-inline1"><span class="kobospan" id="kobo.179.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.180.1">, change the title as follows, and save </span><span><span class="kobospan" id="kobo.181.1">the file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.182.1">
      &lt;h1&gt;Vite + React</span><strong class="bold1"><span class="kobospan1" id="kobo.183.1"> + Node.js</span></strong><span class="kobospan1" id="kobo.184.1">&lt;/h1&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.185.1">You </span><a id="_idIndexMarker255" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.186.1">will see that the change is reflected instantly in </span><span><span class="kobospan" id="kobo.187.1">the browser!</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.188.1">After successfully setting up our full-stack project by combining our projects from previous chapters, let’s now get started designing and creating the user interface for our </span><span><span class="kobospan" id="kobo.189.1">blog application.</span></span></p>
<h1 id="_idParaDest-80" class="calibre5"><a id="_idTextAnchor081" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.190.1">Creating the user interface for our application</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.191.1">When designing the structure of a frontend, we should also consider the folder structure, so that our app can grow easily in the future. </span><span class="kobospan" id="kobo.191.2">Similar to how we did for the backend, we will also put all our source code into a </span><strong class="source-inline"><span class="kobospan" id="kobo.192.1">src/</span></strong><span class="kobospan" id="kobo.193.1"> folder. </span><span class="kobospan" id="kobo.193.2">We can then group the files in separate folders for the different features. </span><span class="kobospan" id="kobo.193.3">Another popular way to structure frontend projects is to group code by routes. </span><span class="kobospan" id="kobo.193.4">Of course, it is also possible to mix them, for example, in Next.js projects we can group our components by features and then create another folder and file structure for the routes, where the components are used. </span><span class="kobospan" id="kobo.193.5">For full-stack projects, it additionally makes sense to first separate our code by creating separate folders for the API integration and </span><span><span class="kobospan" id="kobo.194.1">UI components.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.195.1">Now, let’s define the folder structure for </span><span><span class="kobospan" id="kobo.196.1">our project:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.197.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.198.1">src/api/</span></strong></span><span><span class="kobospan" id="kobo.199.1"> folder.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.200.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.201.1">src/components/</span></strong></span><span><span class="kobospan" id="kobo.202.1"> folder.</span></span></li>
</ol>
<p class="callout-heading"><span class="kobospan" id="kobo.203.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.204.1">It is a good idea to start with a simple structure at first, and only nest more deeply when you actually need it. </span><span class="kobospan" id="kobo.204.2">Do not spend too much time thinking about the file structure when starting a project, because usually, you do not know upfront how files should be grouped, and it may change </span><span><span class="kobospan" id="kobo.205.1">later anyway.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.206.1">After defining the high-level folder structure for our projects, let’s now take some time to consider the </span><span><span class="kobospan" id="kobo.207.1">component structure.</span></span></p>
<h2 id="_idParaDest-81" class="calibre7"><a id="_idTextAnchor082" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.208.1">Component structure</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.209.1">Based on what we defined in the backend, our blog application is going to have the </span><span><span class="kobospan" id="kobo.210.1">following features:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.211.1">Viewing a </span><span><span class="kobospan" id="kobo.212.1">single post</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.213.1">Creating a </span><span><span class="kobospan" id="kobo.214.1">new post</span></span></li>
<li class="calibre11"><span><span class="kobospan" id="kobo.215.1">Listing posts</span></span></li>
<li class="calibre11"><span><span class="kobospan" id="kobo.216.1">Filtering posts</span></span></li>
<li class="calibre11"><span><span class="kobospan" id="kobo.217.1">Sorting posts</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.218.1">The idea of components in React is to have each component deal with a single task or UI element. </span><span class="kobospan" id="kobo.218.2">We should try to make components as fine-grained as possible, in order to be able to reuse code. </span><span class="kobospan" id="kobo.218.3">If we find ourselves copying and pasting code from one component to another, it might be a good idea to create a new component and reuse it in multiple </span><span><span class="kobospan" id="kobo.219.1">other components.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.220.1">Usually, when developing a frontend, we start with a UI mock-up. </span><span class="kobospan" id="kobo.220.2">For our blog application, a mock-up could look </span><span><span class="kobospan" id="kobo.221.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer048">
<span class="kobospan" id="kobo.222.1"><img alt="Figure 4.1 – An initial mock-up of our blog application" src="image/B19385_04_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.223.1">Figure 4.1 – An initial mock-up of our blog application</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.224.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.225.1">In this book, we will not cover UI or CSS frameworks. </span><span class="kobospan" id="kobo.225.2">As such, the components are designed and developed without styling. </span><span class="kobospan" id="kobo.225.3">Instead, the book focuses on the full-stack aspect of the integration of backends with frontends. </span><span class="kobospan" id="kobo.225.4">Feel free to use a UI framework (such as MUI), or a CSS framework (such as Tailwind) to style the blog application on </span><span><span class="kobospan" id="kobo.226.1">your own.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.227.1">When splitting up the UI into components, we use the </span><strong class="bold"><span class="kobospan" id="kobo.228.1">single-responsibility principle</span></strong><span class="kobospan" id="kobo.229.1">, which states that </span><a id="_idIndexMarker256" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.230.1">every module should have responsibility over a single encapsulated part of </span><span><span class="kobospan" id="kobo.231.1">the functionality.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.232.1">In our mock-up, we can draw boxes around each component and subcomponent, and give them names. </span><span class="kobospan" id="kobo.232.2">Keep in mind that each component should have exactly one responsibility. </span><span class="kobospan" id="kobo.232.3">We start with the fundamental components that make up </span><span><span class="kobospan" id="kobo.233.1">the app:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer049">
<span class="kobospan" id="kobo.234.1"><img alt="Figure 4.2 – Defining the fundamental components in our mock-up" src="image/B19385_04_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.235.1">Figure 4.2 – Defining the fundamental components in our mock-up</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.236.1">We defined a </span><strong class="source-inline"><span class="kobospan" id="kobo.237.1">CreatePost</span></strong><span class="kobospan" id="kobo.238.1"> component, with a form to create a new post, a </span><strong class="source-inline"><span class="kobospan" id="kobo.239.1">PostFilter</span></strong><span class="kobospan" id="kobo.240.1"> component to filter the list of posts, a </span><strong class="source-inline"><span class="kobospan" id="kobo.241.1">PostSorting</span></strong><span class="kobospan" id="kobo.242.1"> component to sort posts, and a </span><strong class="source-inline"><span class="kobospan" id="kobo.243.1">Post</span></strong><span class="kobospan" id="kobo.244.1"> component to display a </span><span><span class="kobospan" id="kobo.245.1">single post.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.246.1">Now that we have defined our fundamental components, we are going to look at which components logically belong together, thereby forming a group: we can group the </span><strong class="source-inline"><span class="kobospan" id="kobo.247.1">Post</span></strong><span class="kobospan" id="kobo.248.1"> components together in </span><strong class="source-inline"><span class="kobospan" id="kobo.249.1">PostList</span></strong><span class="kobospan" id="kobo.250.1">, then make an </span><strong class="source-inline"><span class="kobospan" id="kobo.251.1">App</span></strong><span class="kobospan" id="kobo.252.1"> component to group everything together and define the structure of </span><span><span class="kobospan" id="kobo.253.1">our app.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.254.1">Now that we are done with structuring our React components, we can move on to implementing the static </span><span><span class="kobospan" id="kobo.255.1">React components.</span></span></p>
<h2 id="_idParaDest-82" class="calibre7"><a id="_idTextAnchor083" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.256.1">Implementing static React components</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.257.1">Before integrating</span><a id="_idIndexMarker257" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.258.1"> with the backend, we are going to model the basic features of our application as static React components. </span><span class="kobospan" id="kobo.258.2">Dealing with the static view structure of our application first makes sense, as we can play around and re-structure the application UI if needed, before adding integration to the components, which would make it harder and more tedious to move them around. </span><span class="kobospan" id="kobo.258.3">It is also easier to deal only with the UI first, which helps us to get started quickly with projects and features. </span><span class="kobospan" id="kobo.258.4">Then, we can move on to implementing integrations and </span><span><span class="kobospan" id="kobo.259.1">handling state.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.260.1">Let’s get started implementing the static </span><span><span class="kobospan" id="kobo.261.1">components now.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.262.1">The Post component</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.263.1">We have already</span><a id="_idIndexMarker258" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.264.1"> thought about which elements a post has during the creation of the mock-up and the design of the backend. </span><span class="kobospan" id="kobo.264.2">A post should have a </span><strong class="source-inline"><span class="kobospan" id="kobo.265.1">title</span></strong><span class="kobospan" id="kobo.266.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.267.1">contents</span></strong><span class="kobospan" id="kobo.268.1">, and </span><span><span class="kobospan" id="kobo.269.1">an </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.270.1">author</span></strong></span><span><span class="kobospan" id="kobo.271.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.272.1">Let’s implement the </span><strong class="source-inline"><span class="kobospan" id="kobo.273.1">Post</span></strong> <span><span class="kobospan" id="kobo.274.1">component now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.275.1">First, create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.276.1">src/components/Post.jsx</span></strong></span><span><span class="kobospan" id="kobo.277.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.278.1">In that file, </span><span><span class="kobospan" id="kobo.279.1">import </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.280.1">PropTypes</span></strong></span><span><span class="kobospan" id="kobo.281.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.282.1">
import PropTypes from 'prop-types'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.283.1">Define a function component, accepting </span><strong class="source-inline1"><span class="kobospan" id="kobo.284.1">title</span></strong><span class="kobospan" id="kobo.285.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.286.1">contents</span></strong><span class="kobospan" id="kobo.287.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.288.1">author</span></strong></span><span><span class="kobospan" id="kobo.289.1"> props:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.290.1">
export function Post({ title, contents, author }) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.291.1">Next, render all props in a way that resembles </span><span><span class="kobospan" id="kobo.292.1">the mock-up:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.293.1">
  return (
    &lt;article&gt;
      &lt;h3&gt;{title}&lt;/h3&gt;
      &lt;div&gt;{contents}&lt;/div&gt;
      {author &amp;&amp; (
        &lt;em&gt;
          &lt;br /&gt;
          Written by &lt;strong&gt;{author}&lt;/strong&gt;
        &lt;/em&gt;
      )}
    &lt;/article&gt;
  )
}</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.294.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.295.1">Please note that you should always prefer spacing via CSS, rather than using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.296.1">&lt;br /&gt;</span></strong><span class="kobospan" id="kobo.297.1"> HTML tag. </span><span class="kobospan" id="kobo.297.2">However, we are focusing on the UI structure and integration with the backend in this book, so we simply use HTML </span><span><span class="kobospan" id="kobo.298.1">whenever possible.</span></span></p>
<ol class="calibre15">
<li value="5" class="calibre11"><span class="kobospan" id="kobo.299.1">Now, define </span><strong class="source-inline1"><span class="kobospan" id="kobo.300.1">propTypes</span></strong><span class="kobospan" id="kobo.301.1">, making</span><a id="_idIndexMarker259" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.302.1"> sure only </span><strong class="source-inline1"><span class="kobospan" id="kobo.303.1">title</span></strong> <span><span class="kobospan" id="kobo.304.1">is required:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.305.1">
Post.propTypes = {
  title: PropTypes.string.isRequired,
  contents: PropTypes.string,
  author: PropTypes.string,
}</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.306.1">Info</span></p>
<p class="callout"><strong class="source-inline1"><span class="kobospan" id="kobo.307.1">PropTypes</span></strong><span class="kobospan" id="kobo.308.1"> are used to validate the props passed to React components and to ensure that we are passing the correct props when using JavaScript. </span><span class="kobospan" id="kobo.308.2">When using a type-safe language, such as TypeScript, we can instead do this by directly typing the props passed to </span><span><span class="kobospan" id="kobo.309.1">the component.</span></span></p>
<ol class="calibre15">
<li value="6" class="calibre11"><span class="kobospan" id="kobo.310.1">Let’s test out our </span><a id="_idIndexMarker260" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.311.1">component by </span><em class="italic"><span class="kobospan" id="kobo.312.1">replacing</span></em><span class="kobospan" id="kobo.313.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.314.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.315.1"> file with the </span><span><span class="kobospan" id="kobo.316.1">following contents:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.317.1">
import { Post } from './components/Post.jsx'
export function App() {
  return (
    &lt;Post
      title='Full-Stack React Projects'
      contents="Let's become full-stack developers!"
</span><span class="kobospan1" id="kobo.317.2">      author='Daniel Bugl'
    /&gt;
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.318.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.319.1">src/main.jsx</span></strong><span class="kobospan" id="kobo.320.1"> and update the import of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.321.1">App</span></strong><span class="kobospan" id="kobo.322.1"> component, because we are now not using </span><strong class="source-inline1"><span class="kobospan" id="kobo.323.1">export </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.324.1">default</span></strong></span><span><span class="kobospan" id="kobo.325.1"> anymore:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.326.1">
import </span><strong class="bold1"><span class="kobospan1" id="kobo.327.1">{ App }</span></strong><span class="kobospan1" id="kobo.328.1"> from './App.jsx'</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.329.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.330.1">I personally tend to prefer not using default exports, as they make it harder to re-group and re-export components and functions from other files. </span><span class="kobospan" id="kobo.330.2">Also, they allow us to change the names of the components, which could be confusing. </span><span class="kobospan" id="kobo.330.3">For example, if we change the name of a component, the name when importing it is not </span><span><span class="kobospan" id="kobo.331.1">changed automatically.</span></span></p>
<ol class="calibre15">
<li value="8" class="calibre11"><span class="kobospan" id="kobo.332.1">Also, </span><em class="italic"><span class="kobospan" id="kobo.333.1">remove</span></em><span class="kobospan" id="kobo.334.1"> the following line </span><span><span class="kobospan" id="kobo.335.1">from </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.336.1">src/main.jsx</span></strong></span><span><span class="kobospan" id="kobo.337.1">:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.338.1">import './index.css'</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.339.1">Finally, we</span><a id="_idIndexMarker261" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.340.1"> can </span><em class="italic"><span class="kobospan" id="kobo.341.1">delete</span></em><span class="kobospan" id="kobo.342.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.343.1">index.css</span></strong><span class="kobospan" id="kobo.344.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.345.1">App.css</span></strong><span class="kobospan" id="kobo.346.1"> files, as they are not </span><span><span class="kobospan" id="kobo.347.1">needed anymore.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.348.1">Now that our static </span><strong class="source-inline"><span class="kobospan" id="kobo.349.1">Post</span></strong><span class="kobospan" id="kobo.350.1"> component has been implemented, we can move on to the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.351.1">CreatePost</span></strong></span><span><span class="kobospan" id="kobo.352.1"> component.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.353.1">The CreatePost component</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.354.1">We’ll now </span><a id="_idIndexMarker262" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.355.1">implement a form to allow for the creation of new posts. </span><span class="kobospan" id="kobo.355.2">Here, we provide fields for </span><strong class="source-inline"><span class="kobospan" id="kobo.356.1">author</span></strong><span class="kobospan" id="kobo.357.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.358.1">title</span></strong><span class="kobospan" id="kobo.359.1"> and a </span><strong class="source-inline"><span class="kobospan" id="kobo.360.1">&lt;textarea&gt;</span></strong><span class="kobospan" id="kobo.361.1"> element for the contents of the </span><span><span class="kobospan" id="kobo.362.1">blog post.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.363.1">Let’s implement the </span><strong class="source-inline"><span class="kobospan" id="kobo.364.1">CreatePost</span></strong> <span><span class="kobospan" id="kobo.365.1">component now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.366.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.367.1">src/components/CreatePost.jsx</span></strong></span><span><span class="kobospan" id="kobo.368.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.369.1">Define the following component, which contains a form to enter the title, author, and contents of a </span><span><span class="kobospan" id="kobo.370.1">blog post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.371.1">
export function CreatePost() {
  return (
    &lt;form onSubmit={(e) =&gt; e.preventDefault()}&gt;
      &lt;div&gt;
        &lt;label htmlFor='create-title'&gt;Title: &lt;/label&gt;
        &lt;input type='text' name='create-title' id='create-title' /&gt;
      &lt;/div&gt;
      &lt;br /&gt;
      &lt;div&gt;
        &lt;label htmlFor='create-author'&gt;Author: &lt;/label&gt;
        &lt;input type='text' name='create-author' id='create-author' /&gt;
      &lt;/div&gt;
      &lt;br /&gt;
      &lt;textarea /&gt;
      &lt;br /&gt;
      &lt;br /&gt;
      &lt;input type='submit' value='Create' /&gt;
    &lt;/form&gt;
  )
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.372.1">In the preceding code block, we defined an </span><strong class="source-inline"><span class="kobospan" id="kobo.373.1">onSubmit</span></strong><span class="kobospan" id="kobo.374.1"> handler and called </span><strong class="source-inline"><span class="kobospan" id="kobo.375.1">e.preventDefault()</span></strong><span class="kobospan" id="kobo.376.1"> on the event object to avoid a page refresh when the form </span><span><span class="kobospan" id="kobo.377.1">is submitted.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.378.1">Let’s test the </span><a id="_idIndexMarker263" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.379.1">component out by </span><em class="italic"><span class="kobospan" id="kobo.380.1">replacing</span></em><span class="kobospan" id="kobo.381.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.382.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.383.1"> file with the </span><span><span class="kobospan" id="kobo.384.1">following contents:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.385.1">
import { CreatePost } from './components/CreatePost.jsx'
export function App() {
  return &lt;CreatePost /&gt;
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.386.1">As you can see, the </span><strong class="source-inline"><span class="kobospan" id="kobo.387.1">CreatePost</span></strong><span class="kobospan" id="kobo.388.1"> component renders fine. </span><span class="kobospan" id="kobo.388.2">We can now move on to the </span><strong class="source-inline"><span class="kobospan" id="kobo.389.1">PostFilter</span></strong><span class="kobospan" id="kobo.390.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.391.1">PostSorting</span></strong></span><span><span class="kobospan" id="kobo.392.1"> components.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.393.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.394.1">If you want to test out multiple components at once and keep the tests around for later, or build a style guide for your own component library, you should look into Storybook (</span><a href="https://storybook.js.org" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.395.1">https://storybook.js.org</span></a><span class="kobospan" id="kobo.396.1">), which is a useful tool to build, test, and document UI components </span><span><span class="kobospan" id="kobo.397.1">in isolation.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.398.1">The PostFilter and PostSorting components</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.399.1">Similar to the </span><strong class="source-inline"><span class="kobospan" id="kobo.400.1">CreatePost</span></strong><span class="kobospan" id="kobo.401.1"> component, we will be creating two components that provide input fields to filter and sort posts. </span><span class="kobospan" id="kobo.401.2">Let’s</span><a id="_idIndexMarker264" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.402.1"> start </span><span><span class="kobospan" id="kobo.403.1">with </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.404.1">PostFilter</span></strong></span><span><span class="kobospan" id="kobo.405.1">:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.406.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.407.1">src/components/PostFilter.jsx</span></strong></span><span><span class="kobospan" id="kobo.408.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.409.1">In this file, we </span><span><span class="kobospan" id="kobo.410.1">import </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.411.1">PropTypes</span></strong></span><span><span class="kobospan" id="kobo.412.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.413.1">
import PropTypes from 'prop-types'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.414.1">Now, we define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.415.1">PostFilter</span></strong><span class="kobospan" id="kobo.416.1"> component and make use of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.417.1">field</span></strong></span><span><span class="kobospan" id="kobo.418.1"> prop:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.419.1">
export function PostFilter({ field }) {
  return (
    &lt;div&gt;
      &lt;label htmlFor={`filter-${field}`}&gt;{field}: &lt;/label&gt;
      &lt;input
        type='text'
        name={`filter-${field}`}
        id={`filter-${field}`}
      /&gt;
    &lt;/div&gt;
  )
}
PostFilter.propTypes = {
  field: PropTypes.string.isRequired,
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.420.1">Next, we are going to </span><a id="_idIndexMarker265" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.421.1">define the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.422.1">PostSorting</span></strong></span><span><span class="kobospan" id="kobo.423.1"> component.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.424.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.425.1">src/components/PostSorting.jsx</span></strong></span><span><span class="kobospan" id="kobo.426.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.427.1">In this file, we create a </span><strong class="source-inline1"><span class="kobospan" id="kobo.428.1">select</span></strong><span class="kobospan" id="kobo.429.1"> input to select which field to sort by. </span><span class="kobospan" id="kobo.429.2">We also create another </span><strong class="source-inline1"><span class="kobospan" id="kobo.430.1">select</span></strong><span class="kobospan" id="kobo.431.1"> input to select the </span><span><span class="kobospan" id="kobo.432.1">sort order:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.433.1">
import PropTypes from 'prop-types'
export function PostSorting({ fields = [] }) {
  return (
    &lt;div&gt;
      &lt;label htmlFor='sortBy'&gt;Sort By: &lt;/label&gt;
      &lt;select name='sortBy' id='sortBy'&gt;
        {fields.map((field) =&gt; (
          &lt;option key={field} value={field}&gt;
            {field}
          &lt;/option&gt;
        ))}
      &lt;/select&gt;
      {' / '}
      &lt;label htmlFor='sortOrder'&gt;Sort Order: &lt;/label&gt;
      &lt;select name='sortOrder' id='sortOrder'&gt;
        &lt;option value={'ascending'}&gt;ascending&lt;/option&gt;
        &lt;option value={'descending'}&gt;descending&lt;/option&gt;
      &lt;/select&gt;
    &lt;/div&gt;
  )
}
PostSorting.propTypes = {
  fields: PropTypes.arrayOf(PropTypes.string).isRequired,
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.434.1">Now we have successfully defined UI components to filter and sort posts. </span><span class="kobospan" id="kobo.434.2">In the next step, we are going to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.435.1">PostList</span></strong><span class="kobospan" id="kobo.436.1"> component to combine the filter and sorting with a list </span><span><span class="kobospan" id="kobo.437.1">of posts.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.438.1">The PostList component</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.439.1">After implementing the other </span><a id="_idIndexMarker266" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.440.1">post-related components, we can now implement the most important part of our blog app, that is, the feed of blog posts. </span><span class="kobospan" id="kobo.440.2">For now, the feed is simply going to show a list of </span><span><span class="kobospan" id="kobo.441.1">blog posts.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.442.1">Let’s start implementing the </span><strong class="source-inline"><span class="kobospan" id="kobo.443.1">PostList</span></strong> <span><span class="kobospan" id="kobo.444.1">component now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.445.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.446.1">src/components/PostList.jsx</span></strong></span><span><span class="kobospan" id="kobo.447.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.448.1">First, we import </span><strong class="source-inline1"><span class="kobospan" id="kobo.449.1">Fragment</span></strong><span class="kobospan" id="kobo.450.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.451.1">PropTypes</span></strong><span class="kobospan" id="kobo.452.1">, and the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.453.1">Post</span></strong></span><span><span class="kobospan" id="kobo.454.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.455.1">
import { Fragment } from 'react'
import PropTypes from 'prop-types'
import { Post } from './Post.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.456.1">Then, we define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.457.1">PostList</span></strong><span class="kobospan" id="kobo.458.1"> function component, accepting a </span><strong class="source-inline1"><span class="kobospan" id="kobo.459.1">posts</span></strong><span class="kobospan" id="kobo.460.1"> array as a prop. </span><span class="kobospan" id="kobo.460.2">If </span><strong class="source-inline1"><span class="kobospan" id="kobo.461.1">posts</span></strong><span class="kobospan" id="kobo.462.1"> is not defined, we set it to an empty array, </span><span><span class="kobospan" id="kobo.463.1">by default:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.464.1">
export function PostList({ posts = [] }) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.465.1">Next, we render all posts by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.466.1">.map</span></strong><span class="kobospan" id="kobo.467.1"> function and the </span><span><span class="kobospan" id="kobo.468.1">spread syntax:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.469.1">
  return (
    &lt;div&gt;
      {posts.map((post) =&gt; (
        &lt;Post {...post} key={post._id} /&gt;
      ))}
    &lt;/div&gt;
  )
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.470.1">We return the </span><strong class="source-inline"><span class="kobospan" id="kobo.471.1">&lt;Post&gt;</span></strong><span class="kobospan" id="kobo.472.1"> component for each post, and pass all the keys from the </span><strong class="source-inline"><span class="kobospan" id="kobo.473.1">post</span></strong><span class="kobospan" id="kobo.474.1"> object to the component as</span><a id="_idIndexMarker267" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.475.1"> props. </span><span class="kobospan" id="kobo.475.2">We do this by using the spread syntax, which has the same effect as listing all the keys from the object manually as props, </span><span><span class="kobospan" id="kobo.476.1">like so:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.477.1">&lt;Post
  title={post.title}
  author={post.author}
  contents={post.contents}
/&gt;</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.478.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.479.1">If we are rendering a list of elements, we have to give each element a unique </span><strong class="source-inline1"><span class="kobospan" id="kobo.480.1">key</span></strong><span class="kobospan" id="kobo.481.1"> prop. </span><span class="kobospan" id="kobo.481.2">React uses this </span><strong class="source-inline1"><span class="kobospan" id="kobo.482.1">key</span></strong><span class="kobospan" id="kobo.483.1"> prop to efficiently compute the difference between two lists when the data </span><span><span class="kobospan" id="kobo.484.1">has changed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.485.1">We used the </span><strong class="source-inline"><span class="kobospan" id="kobo.486.1">map</span></strong><span class="kobospan" id="kobo.487.1"> function, which applies a function to all the elements of an array. </span><span class="kobospan" id="kobo.487.2">This is similar to using a </span><strong class="source-inline"><span class="kobospan" id="kobo.488.1">for</span></strong><span class="kobospan" id="kobo.489.1"> loop and storing all the results, but it is more concise, declarative, and easier to</span><a id="_idIndexMarker268" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.490.1"> read! </span><span class="kobospan" id="kobo.490.2">Alternatively, we could do the following instead of using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.491.1">map</span></strong></span><span><span class="kobospan" id="kobo.492.1"> function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.493.1">
let renderedPosts = []
let index = 0
for (let post of posts) {
  renderedPosts.push(&lt;Post {...post} key={post._id} /&gt;)
  index++
}
return (
  &lt;div&gt;
    {renderedPosts}
  &lt;/div&gt;
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.494.1">However, using this style is </span><em class="italic"><span class="kobospan" id="kobo.495.1">not</span></em><span class="kobospan" id="kobo.496.1"> recommended </span><span><span class="kobospan" id="kobo.497.1">with React.</span></span></p>
<ol class="calibre15">
<li value="5" class="calibre11"><span class="kobospan" id="kobo.498.1">We also still need to define the prop types. </span><span class="kobospan" id="kobo.498.2">Here, we can make use of the prop types from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.499.1">Post</span></strong><span class="kobospan" id="kobo.500.1"> component, by wrapping it inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.501.1">PropTypes.shape()</span></strong><span class="kobospan" id="kobo.502.1"> function, which defines an object </span><span><span class="kobospan" id="kobo.503.1">prop type:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.504.1">
PostList.propTypes = {
  posts: PropTypes.arrayOf(PropTypes.shape(Post.propTypes)).isRequired,
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.505.1">In the mock-up, we have a horizontal line after each blog post. </span><span class="kobospan" id="kobo.505.2">We can implement this without</span><a id="_idIndexMarker269" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.506.1"> an additional </span><strong class="source-inline1"><span class="kobospan" id="kobo.507.1">&lt;div&gt;</span></strong><span class="kobospan" id="kobo.508.1"> container element, by using </span><strong class="source-inline1"><span class="kobospan" id="kobo.509.1">Fragment</span></strong><span class="kobospan" id="kobo.510.1">, </span><span><span class="kobospan" id="kobo.511.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.512.1">
      {posts.map((post) =&gt; (
</span><strong class="bold1"><span class="kobospan1" id="kobo.513.1">        &lt;Fragment key={post._id}&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.514.1">          &lt;Post {...post} /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.515.1">          &lt;hr /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.516.1">        &lt;/Fragment&gt;</span></strong><span class="kobospan1" id="kobo.517.1">
      ))}</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.518.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.519.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.520.1">key</span></strong><span class="kobospan" id="kobo.521.1"> prop always has to be added to the uppermost parent element that is rendered within the </span><strong class="source-inline1"><span class="kobospan" id="kobo.522.1">map</span></strong><span class="kobospan" id="kobo.523.1"> function. </span><span class="kobospan" id="kobo.523.2">In this case, we had to move the </span><strong class="source-inline1"><span class="kobospan" id="kobo.524.1">key</span></strong><span class="kobospan" id="kobo.525.1"> prop from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.526.1">Post</span></strong><span class="kobospan" id="kobo.527.1"> component </span><span><span class="kobospan" id="kobo.528.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.529.1">Fragment</span></strong></span><span><span class="kobospan" id="kobo.530.1">.</span></span></p>
<ol class="calibre15">
<li value="7" class="calibre11"><span class="kobospan" id="kobo.531.1">Again, we test our component by editing the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.532.1">src/App.jsx</span></strong></span><span><span class="kobospan" id="kobo.533.1"> file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.534.1">
import { PostList } from './components/PostList.jsx'
const posts = [
  {
    title: 'Full-Stack React Projects',
    contents: "Let's become full-stack developers!",
    author: 'Daniel Bugl',
  },
  { title: 'Hello React!' </span><span class="kobospan1" id="kobo.534.2">},
]
export function App() {
  return &lt;PostList posts={posts} /&gt;
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.535.1">Now we can see that our app lists all the posts that we defined in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.536.1">posts</span></strong></span><span><span class="kobospan" id="kobo.537.1"> array.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.538.1">As you can see, listing multiple posts via the </span><strong class="source-inline"><span class="kobospan" id="kobo.539.1">PostList</span></strong><span class="kobospan" id="kobo.540.1"> component works fine. </span><span class="kobospan" id="kobo.540.2">We can now move on to putting the </span><span><span class="kobospan" id="kobo.541.1">app together.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.542.1">Putting the app together</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.543.1">After</span><a id="_idIndexMarker270" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.544.1"> implementing all the components, we now have to put everything together in the </span><strong class="source-inline"><span class="kobospan" id="kobo.545.1">App</span></strong><span class="kobospan" id="kobo.546.1"> component. </span><span class="kobospan" id="kobo.546.2">Then, we will have successfully reproduced </span><span><span class="kobospan" id="kobo.547.1">the mock-up!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.548.1">Let’s start modifying the </span><strong class="source-inline"><span class="kobospan" id="kobo.549.1">App</span></strong><span class="kobospan" id="kobo.550.1"> component and putting our blog </span><span><span class="kobospan" id="kobo.551.1">app together:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.552.1">Open </span><strong class="source-inline1"><span class="kobospan" id="kobo.553.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.554.1"> and add imports for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.555.1">CreatePost</span></strong><span class="kobospan" id="kobo.556.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.557.1">PostFilter</span></strong><span class="kobospan" id="kobo.558.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.559.1">PostSorting</span></strong></span><span><span class="kobospan" id="kobo.560.1"> components:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.561.1">
import { PostList } from './components/PostList.jsx'
</span><strong class="bold1"><span class="kobospan1" id="kobo.562.1">import { CreatePost } from './components/CreatePost.jsx'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.563.1">import { PostFilter } from './components/PostFilter.jsx'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.564.1">import { PostSorting } from './components/PostSorting.jsx'</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.565.1">Adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.566.1">App</span></strong><span class="kobospan" id="kobo.567.1"> component to contain all </span><span><span class="kobospan" id="kobo.568.1">the components:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.569.1">
export function App() {
</span><strong class="bold1"><span class="kobospan1" id="kobo.570.1">  return (</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.571.1">    &lt;div style={{ padding: 8 }}&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.572.1">      &lt;CreatePost /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.573.1">      &lt;br /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.574.1">      &lt;hr /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.575.1">      Filter by:</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.576.1">      &lt;PostFilter field='author' /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.577.1">      &lt;br /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.578.1">      &lt;PostSorting fields={['createdAt', 'updatedAt']} /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.579.1">      &lt;hr /&gt;</span></strong><span class="kobospan1" id="kobo.580.1">
      &lt;PostList posts={posts} /&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.581.1">    &lt;/div&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.582.1">  )</span></strong><span class="kobospan1" id="kobo.583.1">
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.584.1">After saving</span><a id="_idIndexMarker271" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.585.1"> the file, the browser should automatically refresh, and we can now see the </span><span><span class="kobospan" id="kobo.586.1">full UI:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer050">
<span class="kobospan" id="kobo.587.1"><img alt="Figure 4.3 – Full implementation of our static blog app, according to the mock-up" src="image/B19385_04_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.588.1">Figure 4.3 – Full implementation of our static blog app, according to the mock-up</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.589.1">As we can see, all of the static components that we defined earlier are rendered together in one </span><strong class="source-inline"><span class="kobospan" id="kobo.590.1">App</span></strong><span class="kobospan" id="kobo.591.1"> component. </span><span class="kobospan" id="kobo.591.2">Our app now looks just like a mock-up. </span><span class="kobospan" id="kobo.591.3">Next, we can move on to integrating our components with the </span><span><span class="kobospan" id="kobo.592.1">backend service.</span></span></p>
<h1 id="_idParaDest-83" class="calibre5"><a id="_idTextAnchor084" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.593.1">Integrating the backend service using TanStack Query</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.594.1">After finishing </span><a id="_idIndexMarker272" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.595.1">creating all the UI components, we can now move on to integrating them with the backend we created in the previous chapter. </span><span class="kobospan" id="kobo.595.2">For the integration, we are going to use TanStack Query (previously called React Query), which is a data fetching library that can also help us with caching, synchronizing, and updating data from </span><span><span class="kobospan" id="kobo.596.1">a backend.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.597.1">TanStack Query specifically focuses on managing the state of fetched data (server state). </span><span class="kobospan" id="kobo.597.2">While other state management libraries can also deal with server state, they specialize in managing client state instead. </span><span class="kobospan" id="kobo.597.3">Server state has some stark differences from client state, such as </span><span><span class="kobospan" id="kobo.598.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.599.1">Being persisted remotely in a location the client does not </span><span><span class="kobospan" id="kobo.600.1">control directly</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.601.1">Requiring asynchronous APIs to fetch and </span><span><span class="kobospan" id="kobo.602.1">update state</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.603.1">Having to deal with shared ownership, which means that other people can change the state without </span><span><span class="kobospan" id="kobo.604.1">your knowledge</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.605.1">State becoming stale (“out of date”) at some point when changed by the server or </span><span><span class="kobospan" id="kobo.606.1">other people</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.607.1">These challenges with server state result in issues such as having to cache, deduplicate multiple requests, update “out of date” state in the background, and </span><span><span class="kobospan" id="kobo.608.1">so on.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.609.1">TanStack Query provides solutions to these issues out of the box and thus makes dealing with server state simple. </span><span class="kobospan" id="kobo.609.2">You can always combine it with other state management libraries that focus on client state as well. </span><span class="kobospan" id="kobo.609.3">For use cases where the client state essentially just reflects the server state though, TanStack Query on its own can be good enough as a state </span><span><span class="kobospan" id="kobo.610.1">management solution!</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.611.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.612.1">The reason why React Query got renamed to TanStack Query is that the library now also supports other frameworks, such as Solid, Vue, </span><span><span class="kobospan" id="kobo.613.1">and Svelte!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.614.1">Now that you know why and how TanStack Query can help us integrate our frontend with the backend, let’s get started </span><span><span class="kobospan" id="kobo.615.1">using it!</span></span></p>
<h2 id="_idParaDest-84" class="calibre7"><a id="_idTextAnchor085" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.616.1">Setting up TanStack Query for React</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.617.1">To</span><a id="_idIndexMarker273" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.618.1"> set up TanStack Query, we first have to install the</span><a id="_idIndexMarker274" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.619.1"> dependency and set up a query client. </span><span class="kobospan" id="kobo.619.2">The query client is provided to React through a context and will store information about active requests, cached results, when to periodically re-fetch data, and everything needed for TanStack Query </span><span><span class="kobospan" id="kobo.620.1">to function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.621.1">Let’s get started setting it </span><span><span class="kobospan" id="kobo.622.1">up now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.623.1">Open a new Terminal (do not quit Vite!) and install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.624.1">@tanstack/react-query</span></strong><span class="kobospan" id="kobo.625.1"> dependency by running the following command in the root of </span><span><span class="kobospan" id="kobo.626.1">our project:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.627.1">$ npm install @tanstack/react-query@5.12.2</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.628.1">We are now going to move our current </span><strong class="source-inline"><span class="kobospan" id="kobo.629.1">App</span></strong><span class="kobospan" id="kobo.630.1"> component to a new </span><strong class="source-inline"><span class="kobospan" id="kobo.631.1">Blog</span></strong><span class="kobospan" id="kobo.632.1"> component, as we are going to use the </span><strong class="source-inline"><span class="kobospan" id="kobo.633.1">App</span></strong><span class="kobospan" id="kobo.634.1"> component for setting up libraries and </span><span><span class="kobospan" id="kobo.635.1">contexts instead.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.636.1">Rename the </span><strong class="source-inline1"><span class="kobospan" id="kobo.637.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.638.1"> file </span><span><span class="kobospan" id="kobo.639.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.640.1">src/Blog.jsx</span></strong></span><span><span class="kobospan" id="kobo.641.1">.</span></span><p class="calibre3"><span class="kobospan" id="kobo.642.1">Do not update imports yet. </span><span class="kobospan" id="kobo.642.2">If VS Code asks you to update imports, </span><span><span class="kobospan" id="kobo.643.1">click </span></span><span><strong class="bold"><span class="kobospan" id="kobo.644.1">No</span></strong></span><span><span class="kobospan" id="kobo.645.1">.</span></span></p></li>
<li class="calibre11"><span class="kobospan" id="kobo.646.1">Now, in </span><strong class="source-inline1"><span class="kobospan" id="kobo.647.1">src/Blog.jsx</span></strong><span class="kobospan" id="kobo.648.1">, change the function name from </span><strong class="source-inline1"><span class="kobospan" id="kobo.649.1">App</span></strong> <span><span class="kobospan" id="kobo.650.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.651.1">Blog</span></strong></span><span><span class="kobospan" id="kobo.652.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.653.1">
export function </span><strong class="bold1"><span class="kobospan1" id="kobo.654.1">Blog</span></strong><span class="kobospan1" id="kobo.655.1">() {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.656.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.657.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.658.1"> file. </span><span class="kobospan" id="kobo.658.2">In this file, import </span><strong class="source-inline1"><span class="kobospan" id="kobo.659.1">QueryClient</span></strong><span class="kobospan" id="kobo.660.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.661.1">QueryClientProvider</span></strong><span class="kobospan" id="kobo.662.1"> from TanStack </span><span><span class="kobospan" id="kobo.663.1">React Query:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.664.1">
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.665.1">Also, import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.666.1">Blog</span></strong></span><span><span class="kobospan" id="kobo.667.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.668.1">
import { Blog } from './Blog.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.669.1">Now, create a new </span><span><span class="kobospan" id="kobo.670.1">query client:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.671.1">
const queryClient = new QueryClient()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.672.1">Define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.673.1">App</span></strong><span class="kobospan" id="kobo.674.1"> component and</span><a id="_idIndexMarker275" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.675.1"> render the </span><strong class="source-inline1"><span class="kobospan" id="kobo.676.1">Blog</span></strong><span class="kobospan" id="kobo.677.1"> component </span><a id="_idIndexMarker276" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.678.1">wrapped </span><span><span class="kobospan" id="kobo.679.1">inside </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.680.1">QueryClientProvider</span></strong></span><span><span class="kobospan" id="kobo.681.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.682.1">
export function App() {
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;Blog /&gt;
    &lt;/QueryClientProvider&gt;
  )
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.683.1">That’s all there is to setting up TanStack Query! </span><span class="kobospan" id="kobo.683.2">We can now make use of it inside our </span><strong class="source-inline"><span class="kobospan" id="kobo.684.1">Blog</span></strong><span class="kobospan" id="kobo.685.1"> component (and </span><span><span class="kobospan" id="kobo.686.1">its children).</span></span></p>
<h2 id="_idParaDest-85" class="calibre7"><a id="_idTextAnchor086" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.687.1">Fetching blog posts</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.688.1">The first thing we should do is fetch</span><a id="_idIndexMarker277" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.689.1"> the list of blog posts from our backend. </span><span class="kobospan" id="kobo.689.2">Let’s implement </span><span><span class="kobospan" id="kobo.690.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.691.1">First of all, in the second Terminal window opened (not where Vite is running), run the backend server (do not quit Vite!), </span><span><span class="kobospan" id="kobo.692.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.693.1">$ cd backend/</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.694.1">$ npm start</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.695.1">If you get an error, make sure Docker and MongoDB are </span><span><span class="kobospan" id="kobo.696.1">running properly!</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.697.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.698.1">If you want to develop the backend and frontend at the same time, you can start the backend using </span><strong class="source-inline1"><span class="kobospan" id="kobo.699.1">npm run dev</span></strong><span class="kobospan" id="kobo.700.1"> to make sure it hot reloads when you change </span><span><span class="kobospan" id="kobo.701.1">the code.</span></span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.702.1">Create a </span><strong class="source-inline1"><span class="kobospan" id="kobo.703.1">.env</span></strong><span class="kobospan" id="kobo.704.1"> file in the root of the project, and enter the following contents </span><span><span class="kobospan" id="kobo.705.1">into it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.706.1">
VITE_BACKEND_URL="http://localhost:3001/api/v1"</span></pre><p class="calibre3"><span class="kobospan" id="kobo.707.1">Vite supports </span><strong class="source-inline"><span class="kobospan" id="kobo.708.1">dotenv</span></strong><span class="kobospan" id="kobo.709.1"> out of the box. </span><span class="kobospan" id="kobo.709.2">All environment variables that should be available to be accessed within the frontend need to be prefixed with </span><strong class="source-inline"><span class="kobospan" id="kobo.710.1">VITE_</span></strong><span class="kobospan" id="kobo.711.1">. </span><span class="kobospan" id="kobo.711.2">Here, we set an environment variable to point to our </span><span><span class="kobospan" id="kobo.712.1">backend server.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.713.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.714.1">src/api/posts.js</span></strong><span class="kobospan" id="kobo.715.1"> file. </span><span class="kobospan" id="kobo.715.2">In this file, we are going to define a function to fetch posts, which accepts the query params for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.716.1">/posts</span></strong><span class="kobospan" id="kobo.717.1"> endpoint as an argument. </span><span class="kobospan" id="kobo.717.2">These query params are used to filter by author and tag and define sorting using </span><strong class="source-inline1"><span class="kobospan" id="kobo.718.1">sortBy</span></strong> <span><span class="kobospan" id="kobo.719.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.720.1">sortOrder</span></strong></span><span><span class="kobospan" id="kobo.721.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.722.1">
export const getPosts = async (queryParams) =&gt; {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.723.1">Remember that we</span><a id="_idIndexMarker278" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.724.1"> can use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.725.1">fetch</span></strong><span class="kobospan" id="kobo.726.1"> function to make a request to a server. </span><span class="kobospan" id="kobo.726.2">We need to pass the environment variable to it and add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.727.1">/posts</span></strong><span class="kobospan" id="kobo.728.1"> endpoint. </span><span class="kobospan" id="kobo.728.2">After the path, we add query params, which are prefixed with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.729.1">?</span></strong> <span><span class="kobospan" id="kobo.730.1">symbol:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.731.1">
  const res = await fetch(
    `${import.meta.env.VITE_BACKEND_URL}/posts?` +</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.732.1">Now we need to use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.733.1">URLSearchParams</span></strong><span class="kobospan" id="kobo.734.1"> class to turn an object into query params. </span><span class="kobospan" id="kobo.734.2">That class will automatically escape the input for us and turn it into valid </span><span><span class="kobospan" id="kobo.735.1">query params:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.736.1">
      new URLSearchParams(queryParams),</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.737.1">Like we did before in the browser, we need to parse the response </span><span><span class="kobospan" id="kobo.738.1">as JSON:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.739.1">
  )
  return await res.json()
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.740.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.741.1">src/Blog.jsx</span></strong><span class="kobospan" id="kobo.742.1"> and </span><em class="italic"><span class="kobospan" id="kobo.743.1">remove</span></em><span class="kobospan" id="kobo.744.1"> the sample </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.745.1">posts</span></strong></span><span><span class="kobospan" id="kobo.746.1"> array:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.747.1">const posts = [</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.748.1">  {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.749.1">    title: 'Full-Stack React Projects',</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.750.1">    contents: "Let's become full-stack developers!",</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.751.1">    author: 'Daniel Bugl',</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.752.1">  },</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.753.1">  { title: 'Hello React!' </span><span class="kobospan1" id="kobo.753.2">},</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.754.1">]</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.755.1">Also, import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.756.1">useQuery</span></strong><span class="kobospan" id="kobo.757.1"> function from </span><strong class="source-inline1"><span class="kobospan" id="kobo.758.1">@tanstack/react-query</span></strong><span class="kobospan" id="kobo.759.1"> and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.760.1">getPosts</span></strong><span class="kobospan" id="kobo.761.1"> function </span><a id="_idIndexMarker279" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.762.1">from our </span><strong class="source-inline1"><span class="kobospan" id="kobo.763.1">api</span></strong><span class="kobospan" id="kobo.764.1"> folder in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.765.1">src/Blog.jsx</span></strong></span><span><span class="kobospan" id="kobo.766.1"> file:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.767.1">import { useQuery } from '@tanstack/react-query'</span></strong><span class="kobospan1" id="kobo.768.1">
import { PostList } from './components/PostList.jsx'
import { CreatePost } from './components/CreatePost.jsx'
import { PostFilter } from './components/PostFilter.jsx'
import { PostSorting } from './components/PostSorting.jsx'
</span><strong class="bold1"><span class="kobospan1" id="kobo.769.1">import { getPosts } from './api/posts.js'</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.770.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.771.1">Blog</span></strong><span class="kobospan" id="kobo.772.1"> component, define a </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.773.1">useQuery</span></strong></span><span><span class="kobospan" id="kobo.774.1"> hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.775.1">
export function Blog() {
</span><strong class="bold1"><span class="kobospan1" id="kobo.776.1">  const postsQuery = useQuery({</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.777.1">    queryKey: ['posts'],</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.778.1">    queryFn: () =&gt; getPosts(),</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.779.1">  })</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.780.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.781.1">queryKey</span></strong><span class="kobospan" id="kobo.782.1"> is very important in TanStack Query, as it is used to uniquely identify a request, among other things, for caching purposes. </span><span class="kobospan" id="kobo.782.2">Always make sure to use unique query keys. </span><span class="kobospan" id="kobo.782.3">Otherwise, you might see requests not </span><span><span class="kobospan" id="kobo.783.1">triggering properly.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.784.1">For the </span><strong class="source-inline"><span class="kobospan" id="kobo.785.1">queryFn</span></strong><span class="kobospan" id="kobo.786.1"> option, we just call the </span><strong class="source-inline"><span class="kobospan" id="kobo.787.1">getPosts</span></strong><span class="kobospan" id="kobo.788.1"> function, without query params </span><span><span class="kobospan" id="kobo.789.1">for now.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.790.1">After the </span><strong class="source-inline1"><span class="kobospan" id="kobo.791.1">useQuery</span></strong><span class="kobospan" id="kobo.792.1"> hook, we get the posts from our query and fall back to an empty array if the posts are not </span><span><span class="kobospan" id="kobo.793.1">loaded yet:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.794.1">
const posts = postsQuery.data ?? </span><span class="kobospan1" id="kobo.794.2">[]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.795.1">Check your</span><a id="_idIndexMarker280" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.796.1"> browser, and you will see that the posts are now loaded from </span><span><span class="kobospan" id="kobo.797.1">our backend!</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.798.1">Now that we have successfully fetched blog posts, let’s get the filters and </span><span><span class="kobospan" id="kobo.799.1">sorting working!</span></span></p>
<h2 id="_idParaDest-86" class="calibre7"><a id="_idTextAnchor087" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.800.1">Implementing filters and sorting</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.801.1">To implement </span><a id="_idIndexMarker281" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.802.1">filters and </span><a id="_idIndexMarker282" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.803.1">sorting, we need to handle some local state and pass it as query params to </span><strong class="source-inline"><span class="kobospan" id="kobo.804.1">postsQuery</span></strong><span class="kobospan" id="kobo.805.1">. </span><span class="kobospan" id="kobo.805.2">Let’s do </span><span><span class="kobospan" id="kobo.806.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.807.1">We start by editing the </span><strong class="source-inline1"><span class="kobospan" id="kobo.808.1">src/Blog.jsx</span></strong><span class="kobospan" id="kobo.809.1"> file and importing the </span><strong class="source-inline1"><span class="kobospan" id="kobo.810.1">useState</span></strong><span class="kobospan" id="kobo.811.1"> hook </span><span><span class="kobospan" id="kobo.812.1">from React:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.813.1">
import { useState } from 'react'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.814.1">Then we add state hooks for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.815.1">author</span></strong><span class="kobospan" id="kobo.816.1"> filter and the sorting options inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.817.1">Blog</span></strong><span class="kobospan" id="kobo.818.1"> component, before the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.819.1">useQuery</span></strong></span><span><span class="kobospan" id="kobo.820.1"> hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.821.1">
  const [author, setAuthor] = useState('')
  const [sortBy, setSortBy] = useState('createdAt')
  const [sortOrder, setSortOrder] = useState('descending')</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.822.1">Then, we adjust </span><strong class="source-inline1"><span class="kobospan" id="kobo.823.1">queryKey</span></strong><span class="kobospan" id="kobo.824.1"> to contain the query params (so that whenever a query param changes, TanStack Query will re-fetch unless the request is already cached). </span><span class="kobospan" id="kobo.824.2">We also adjust </span><strong class="source-inline1"><span class="kobospan" id="kobo.825.1">queryFn</span></strong><span class="kobospan" id="kobo.826.1"> to call </span><strong class="source-inline1"><span class="kobospan" id="kobo.827.1">getPosts</span></strong><span class="kobospan" id="kobo.828.1"> with the relevant </span><span><span class="kobospan" id="kobo.829.1">query params:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.830.1">
  const postsQuery = useQuery({
    queryKey: ['posts', </span><strong class="bold1"><span class="kobospan1" id="kobo.831.1">{ author, sortBy, sortOrder }],</span></strong><span class="kobospan1" id="kobo.832.1">
    queryFn: () =&gt; getPosts(</span><strong class="bold1"><span class="kobospan1" id="kobo.833.1">{ author, sortBy, sortOrder }</span></strong><span class="kobospan1" id="kobo.834.1">),
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.835.1">Now pass the </span><a id="_idIndexMarker283" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.836.1">values and relevant </span><strong class="source-inline1"><span class="kobospan" id="kobo.837.1">onChange</span></strong><span class="kobospan" id="kobo.838.1"> handlers to the </span><a id="_idIndexMarker284" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.839.1">filter and </span><span><span class="kobospan" id="kobo.840.1">sorting components:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.841.1">
      &lt;PostFilter
        field='author'
</span><strong class="bold1"><span class="kobospan1" id="kobo.842.1">        value={author}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.843.1">        onChange={(value) =&gt; setAuthor(value)}</span></strong><span class="kobospan1" id="kobo.844.1">
      /&gt;
      &lt;br /&gt;
      &lt;PostSorting
        fields={['createdAt', 'updatedAt']}
</span><strong class="bold1"><span class="kobospan1" id="kobo.845.1">        value={sortBy}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.846.1">        onChange={(value) =&gt; setSortBy(value)}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.847.1">        orderValue={sortOrder}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.848.1">        onOrderChange={(orderValue) =&gt; setSortOrder(orderValue)}</span></strong><span class="kobospan1" id="kobo.849.1">
      /&gt;</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.850.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.851.1">For simplicity’s sake, we are only using state hooks for now. </span><span class="kobospan" id="kobo.851.2">A state management solution or context could make dealing with filters and sorting much easier, especially for larger applications. </span><span class="kobospan" id="kobo.851.3">For our small blog application, it is fine to use state hooks though, as we are focusing mostly on the integration of the backend </span><span><span class="kobospan" id="kobo.852.1">and frontend.</span></span></p>
<ol class="calibre15">
<li value="5" class="calibre11"><span class="kobospan" id="kobo.853.1">Now, edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.854.1">src/components/PostFilter.jsx</span></strong><span class="kobospan" id="kobo.855.1"> and </span><a id="_idIndexMarker285" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.856.1">add</span><a id="_idIndexMarker286" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.857.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.858.1">value</span></strong><span class="kobospan" id="kobo.859.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.860.1">onChange</span></strong></span><span><span class="kobospan" id="kobo.861.1"> props:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.862.1">
export function PostFilter({ field</span><strong class="bold1"><span class="kobospan1" id="kobo.863.1">, value, onChange</span></strong><span class="kobospan1" id="kobo.864.1"> }) {
  return (
    &lt;div&gt;
      &lt;label htmlFor={`filter-${field}`}&gt;{field}: &lt;/label&gt;
      &lt;input
        type='text'
        name={`filter-${field}`}
        id={`filter-${field}`}
</span><strong class="bold1"><span class="kobospan1" id="kobo.865.1">        value={value}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.866.1">        onChange={(e) =&gt; onChange(e.target.value)}</span></strong><span class="kobospan1" id="kobo.867.1">
      /&gt;
    &lt;/div&gt;
  )
}
PostFilter.propTypes = {
  field: PropTypes.string.isRequired,
</span><strong class="bold1"><span class="kobospan1" id="kobo.868.1">  value: PropTypes.string.isRequired,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.869.1">  onChange: PropTypes.func.isRequired,</span></strong><span class="kobospan1" id="kobo.870.1">
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.871.1">We </span><a id="_idIndexMarker287" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.872.1">also do the </span><a id="_idIndexMarker288" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.873.1">same </span><span><span class="kobospan" id="kobo.874.1">for </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.875.1">src/components/PostSorting.jsx</span></strong></span><span><span class="kobospan" id="kobo.876.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.877.1">
export function PostSorting({
  fields = [],
</span><strong class="bold1"><span class="kobospan1" id="kobo.878.1">  value,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.879.1">  onChange,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.880.1">  orderValue,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.881.1">  onOrderChange,</span></strong><span class="kobospan1" id="kobo.882.1">
}) {
  return (
    &lt;div&gt;
      &lt;label htmlFor='sortBy'&gt;Sort By: &lt;/label&gt;
      &lt;select
        name='sortBy'
        id='sortBy'
</span><strong class="bold1"><span class="kobospan1" id="kobo.883.1">        value={value}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.884.1">        onChange={(e) =&gt; onChange(e.target.value)}</span></strong><span class="kobospan1" id="kobo.885.1">
      &gt;
        {fields.map((field) =&gt; (
          &lt;option key={field} value={field}&gt;
            {field}
          &lt;/option&gt;
        ))}
      &lt;/select&gt;
      {' / '}
      &lt;label htmlFor='sortOrder'&gt;Sort Order: &lt;/label&gt;
      &lt;select
        name='sortOrder'
        id='sortOrder'
</span><strong class="bold1"><span class="kobospan1" id="kobo.886.1">        value={orderValue}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.887.1">        onChange={(e) =&gt; onOrderChange(e.target.value)}</span></strong><span class="kobospan1" id="kobo.888.1">
      &gt;
        &lt;option value={'ascending'}&gt;ascending&lt;/option&gt;
        &lt;option value={'descending'}&gt;descending&lt;/option&gt;
      &lt;/select&gt;
    &lt;/div&gt;
  )
}
PostSorting.propTypes = {
  fields: PropTypes.arrayOf(PropTypes.string).isRequired,
</span><strong class="bold1"><span class="kobospan1" id="kobo.889.1">  value: PropTypes.string.isRequired,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.890.1">  onChange: PropTypes.func.isRequired,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.891.1">  orderValue: PropTypes.string.isRequired,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.892.1">  onOrderChange: PropTypes.func.isRequired,</span></strong><span class="kobospan1" id="kobo.893.1">
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.894.1">In your</span><a id="_idIndexMarker289" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.895.1"> browser, enter </span><strong class="source-inline1"><span class="kobospan" id="kobo.896.1">Daniel Bugl</span></strong><span class="kobospan" id="kobo.897.1"> as the author. </span><span class="kobospan" id="kobo.897.2">You</span><a id="_idIndexMarker290" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.898.1"> should see TanStack Query re-fetch the posts from the backend as you type, and once a match is found, the backend will return all posts by </span><span><span class="kobospan" id="kobo.899.1">that author!</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.900.1">After testing it out, make sure to clear the filter again, so that newly created posts are not filtered by the author anymore </span><span><span class="kobospan" id="kobo.901.1">later on.</span></span></li>
</ol>
<p class="callout-heading"><span class="kobospan" id="kobo.902.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.903.1">If you do not want to make that many requests to the backend, make sure to use a debouncing state hook, such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.904.1">useDebounce</span></strong><span class="kobospan" id="kobo.905.1">, and then pass only the debounced value to the query param.  </span><span class="kobospan" id="kobo.905.2">If you are interested in gaining further knowledge about the </span><strong class="source-inline1"><span class="kobospan" id="kobo.906.1">useDebounce</span></strong><span class="kobospan" id="kobo.907.1"> hook and other useful hooks, I recommend checking out my book titled </span><em class="italic"><span class="kobospan" id="kobo.908.1">Learn </span></em><span><em class="italic"><span class="kobospan" id="kobo.909.1">React Hooks</span></em></span><span><span class="kobospan" id="kobo.910.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.911.1">The application should now look as follows, with the posts being filtered by the author entered in the field, and sorted by the selected field, in the </span><span><span class="kobospan" id="kobo.912.1">selected order:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer051">
<span class="kobospan" id="kobo.913.1"><img alt="Figure 4.4 – Our first full-stack application – a frontend fetching posts from a backend!" src="image/B19385_04_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.914.1">Figure 4.4 – Our first full-stack application – a frontend fetching posts from a backend!</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.915.1">Now that sorting and filtering are working properly, let’s learn about mutations, which allow us to make requests to the server that change the state of the backend (for example, inserting or updating entries in </span><span><span class="kobospan" id="kobo.916.1">the database).</span></span></p>
<h2 id="_idParaDest-87" class="calibre7"><a id="_idTextAnchor088" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.917.1">Creating new posts</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.918.1">We are now going to implement a feature to </span><a id="_idIndexMarker291" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.919.1">create posts. </span><span class="kobospan" id="kobo.919.2">To do this, we need to use the </span><strong class="source-inline"><span class="kobospan" id="kobo.920.1">useMutation</span></strong><span class="kobospan" id="kobo.921.1"> hook from TanStack Query. </span><span class="kobospan" id="kobo.921.2">While queries are meant to be idempotent (meaning that calling them multiple times should not affect the result), mutations are used to create/update/delete data or perform operations on the server. </span><span class="kobospan" id="kobo.921.3">Let’s get started using mutations to create new </span><span><span class="kobospan" id="kobo.922.1">posts now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.923.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.924.1">src/api/posts.js</span></strong><span class="kobospan" id="kobo.925.1"> and define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.926.1">createPost</span></strong><span class="kobospan" id="kobo.927.1"> function, which accepts a </span><strong class="source-inline1"><span class="kobospan" id="kobo.928.1">post</span></strong><span class="kobospan" id="kobo.929.1"> object as </span><span><span class="kobospan" id="kobo.930.1">an argument:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.931.1">
export const createPost = async (post) =&gt; {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.932.1">We also make a request to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.933.1">/posts</span></strong><span class="kobospan" id="kobo.934.1"> endpoint, like we did </span><span><span class="kobospan" id="kobo.935.1">for </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.936.1">getPosts</span></strong></span><span><span class="kobospan" id="kobo.937.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.938.1">
  const res = await fetch(`${import.meta.env.VITE_BACKEND_URL}/posts`, {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.939.1">However, now we also set </span><strong class="source-inline1"><span class="kobospan" id="kobo.940.1">method</span></strong><span class="kobospan" id="kobo.941.1"> to a </span><strong class="source-inline1"><span class="kobospan" id="kobo.942.1">POST</span></strong><span class="kobospan" id="kobo.943.1"> request, pass a header to tell the backend that we will be sending a JSON body, and then send our </span><strong class="source-inline1"><span class="kobospan" id="kobo.944.1">post</span></strong><span class="kobospan" id="kobo.945.1"> object as a </span><span><span class="kobospan" id="kobo.946.1">JSON string:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.947.1">
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(post),</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.948.1">Like with </span><strong class="source-inline1"><span class="kobospan" id="kobo.949.1">getPosts</span></strong><span class="kobospan" id="kobo.950.1">, we also need to parse the response </span><span><span class="kobospan" id="kobo.951.1">as JSON:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.952.1">
  })
  return await res.json()
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.953.1">After defining the </span><strong class="source-inline"><span class="kobospan" id="kobo.954.1">createPost</span></strong><span class="kobospan" id="kobo.955.1"> API function, let’s use it in the </span><strong class="source-inline"><span class="kobospan" id="kobo.956.1">CreatePost</span></strong><span class="kobospan" id="kobo.957.1"> component by creating a new mutation </span><span><span class="kobospan" id="kobo.958.1">hook there.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.959.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.960.1">src/components/CreatePost.jsx</span></strong><span class="kobospan" id="kobo.961.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.962.1">useMutation</span></strong><span class="kobospan" id="kobo.963.1"> hook from </span><strong class="source-inline1"><span class="kobospan" id="kobo.964.1">@tanstack/react-query</span></strong><span class="kobospan" id="kobo.965.1">, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.966.1">useState</span></strong><span class="kobospan" id="kobo.967.1"> hook from React, and our </span><strong class="source-inline1"><span class="kobospan" id="kobo.968.1">createPost</span></strong> <span><span class="kobospan" id="kobo.969.1">API function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.970.1">
import { useMutation } from '@tanstack/react-query'
import { useState } from 'react'
import { createPost } from '../api/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.971.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.972.1">CreatePost</span></strong><span class="kobospan" id="kobo.973.1"> component, define state hooks for </span><strong class="source-inline1"><span class="kobospan" id="kobo.974.1">title</span></strong><span class="kobospan" id="kobo.975.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.976.1">author</span></strong><span class="kobospan" id="kobo.977.1">, </span><span><span class="kobospan" id="kobo.978.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.979.1">contents</span></strong></span><span><span class="kobospan" id="kobo.980.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.981.1">
  const [title, setTitle] = useState('')
  const [author, setAuthor] = useState('')
  const [contents, setContents] = useState('')</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.982.1">Now, define a mutation </span><a id="_idIndexMarker292" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.983.1">hook. </span><span class="kobospan" id="kobo.983.2">Here, we are going to call our </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.984.1">createPost</span></strong></span><span><span class="kobospan" id="kobo.985.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.986.1">
  const createPostMutation = useMutation({
    mutationFn: () =&gt; createPost({ title, author, contents }),
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.987.1">Next, we are going to define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.988.1">handleSubmit</span></strong><span class="kobospan" id="kobo.989.1"> function, which will prevent the default submit action (which refreshes the page), and instead call </span><strong class="source-inline1"><span class="kobospan" id="kobo.990.1">.mutate()</span></strong><span class="kobospan" id="kobo.991.1"> to execute </span><span><span class="kobospan" id="kobo.992.1">the mutation:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.993.1">
  const handleSubmit = (e) =&gt; {
    e.preventDefault()
    createPostMutation.mutate()
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.994.1">We add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.995.1">onSubmit</span></strong><span class="kobospan" id="kobo.996.1"> handler to </span><span><span class="kobospan" id="kobo.997.1">our form:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.998.1">
    &lt;form onSubmit={</span><strong class="bold1"><span class="kobospan1" id="kobo.999.1">handleSubmit</span></strong><span class="kobospan1" id="kobo.1000.1">}&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1001.1">We also add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1002.1">value</span></strong><span class="kobospan" id="kobo.1003.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.1004.1">onChange</span></strong><span class="kobospan" id="kobo.1005.1"> props to our fields, as we did before for the sorting </span><span><span class="kobospan" id="kobo.1006.1">and filters:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1007.1">
      &lt;div&gt;
        &lt;label htmlFor='create-title'&gt;Title: &lt;/label&gt;
        &lt;input
          type='text'
          name='create-title'
          id='create-title'
</span><strong class="bold1"><span class="kobospan1" id="kobo.1008.1">          value={title}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1009.1">          onChange={(e) =&gt; setTitle(e.target.value)}</span></strong><span class="kobospan1" id="kobo.1010.1">
        /&gt;
      &lt;/div&gt;
      &lt;br /&gt;
      &lt;div&gt;
        &lt;label htmlFor='create-author'&gt;Author: &lt;/label&gt;
        &lt;input
          type='text'
          name='create-author'
          id='create-author'
</span><strong class="bold1"><span class="kobospan1" id="kobo.1011.1">          value={author}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1012.1">          onChange={(e) =&gt; setAuthor(e.target.value)}</span></strong><span class="kobospan1" id="kobo.1013.1">
        /&gt;
      &lt;/div&gt;
      &lt;br /&gt;
      &lt;textarea
        </span><strong class="bold1"><span class="kobospan1" id="kobo.1014.1">value={contents}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1015.1">        onChange={(e) =&gt; setContents(e.target.value)}</span></strong><span class="kobospan1" id="kobo.1016.1">
      /&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1017.1">For the submit button, we make sure it says </span><strong class="source-inline1"><span class="kobospan" id="kobo.1018.1">Creating…</span></strong><span class="kobospan" id="kobo.1019.1"> instead of </span><strong class="source-inline1"><span class="kobospan" id="kobo.1020.1">Create</span></strong><span class="kobospan" id="kobo.1021.1"> while we are waiting for the </span><a id="_idIndexMarker293" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1022.1">mutation to finish, and we also disable the button if no title was set (as it is required), or if the mutation is </span><span><span class="kobospan" id="kobo.1023.1">currently pending:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1024.1">
      &lt;br /&gt;
      &lt;br /&gt;
      &lt;input
        type='submit'
</span><strong class="bold1"><span class="kobospan1" id="kobo.1025.1">        value={createPostMutation.isPending ? </span><span class="kobospan1" id="kobo.1025.2">'Creating...' </span><span class="kobospan1" id="kobo.1025.3">: 'Create'}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1026.1">        disabled={!title || createPostMutation.isPending}</span></strong><span class="kobospan1" id="kobo.1027.1">
      /&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1028.1">Lastly, we add a message below the submit button, which will be shown if the mutation </span><span><span class="kobospan" id="kobo.1029.1">is successful:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1030.1">
      {createPostMutation.isSuccess ? </span><span class="kobospan1" id="kobo.1030.2">(
        &lt;&gt;
          &lt;br /&gt;
          Post created successfully!
</span><span class="kobospan1" id="kobo.1030.3">        &lt;/&gt;
      ) : null}
    &lt;/form&gt;</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.1031.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1032.1">In addition to </span><strong class="source-inline1"><span class="kobospan" id="kobo.1033.1">isPending</span></strong><span class="kobospan" id="kobo.1034.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.1035.1">isSuccess</span></strong><span class="kobospan" id="kobo.1036.1">, mutations also return </span><strong class="source-inline1"><span class="kobospan" id="kobo.1037.1">isIdle</span></strong><span class="kobospan" id="kobo.1038.1"> (when the mutation is idle or in a fresh/reset state) and </span><strong class="source-inline1"><span class="kobospan" id="kobo.1039.1">isError</span></strong><span class="kobospan" id="kobo.1040.1"> states. </span><span class="kobospan" id="kobo.1040.2">The same states can also be accessed from queries, for example, to show a loading animation while posts </span><span><span class="kobospan" id="kobo.1041.1">are fetching.</span></span></p>
<ol class="calibre15">
<li value="13" class="calibre11"><span class="kobospan" id="kobo.1042.1">Now we can try adding a</span><a id="_idIndexMarker294" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1043.1"> new post, and it seems to work fine, but the post list is not updating automatically, only after </span><span><span class="kobospan" id="kobo.1044.1">a refresh!</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.1045.1">The issue is that the query key did not change, so TanStack Query does not refresh the list of posts. </span><span class="kobospan" id="kobo.1045.2">However, we also want to refresh the list when a new post is created. </span><span class="kobospan" id="kobo.1045.3">Let’s fix </span><span><span class="kobospan" id="kobo.1046.1">that now.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1047.1">Invalidating queries</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1048.1">To ensure that the </span><a id="_idIndexMarker295" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1049.1">post list is refreshed after creating a new post, we need to invalidate the query. </span><span class="kobospan" id="kobo.1049.2">We can make use of the query client to do this. </span><span class="kobospan" id="kobo.1049.3">Let’s do </span><span><span class="kobospan" id="kobo.1050.1">it now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1051.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1052.1">src/components/CreatePost.jsx</span></strong><span class="kobospan" id="kobo.1053.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1054.1">useQueryClient</span></strong></span><span><span class="kobospan" id="kobo.1055.1"> hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1056.1">
import { useMutation</span><strong class="bold1"><span class="kobospan1" id="kobo.1057.1">, useQueryClient</span></strong><span class="kobospan1" id="kobo.1058.1"> } from '@tanstack/react-query'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1059.1">Use the query client to invalidate all queries starting with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1060.1">'posts'</span></strong><span class="kobospan" id="kobo.1061.1"> query key. </span><span class="kobospan" id="kobo.1061.2">This will work with any query params to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1062.1">getPosts</span></strong><span class="kobospan" id="kobo.1063.1"> request, as it matches all queries starting with </span><strong class="source-inline1"><span class="kobospan" id="kobo.1064.1">'posts'</span></strong><span class="kobospan" id="kobo.1065.1"> in </span><span><span class="kobospan" id="kobo.1066.1">the array:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1067.1">  const queryClient = useQueryClient()</span></strong><span class="kobospan1" id="kobo.1068.1">
  const createPostMutation = useMutation({
    mutationFn: () =&gt; createPost({ title, author, contents }),
</span><strong class="bold1"><span class="kobospan1" id="kobo.1069.1">    onSuccess: () =&gt; queryClient.invalidateQueries(['posts']),</span></strong><span class="kobospan1" id="kobo.1070.1">
  })</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1071.1">Try creating a new post, and you will see that it works now, even with active filters and sorting! </span><span class="kobospan" id="kobo.1071.2">As we can see, TanStack Query is great for handling server state </span><span><span class="kobospan" id="kobo.1072.1">with ease.</span></span></p>
<h1 id="_idParaDest-88" class="calibre5"><a id="_idTextAnchor089" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1073.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1074.1">In this chapter, we learned how to create a React frontend and integrate it with our backend using TanStack Query. </span><span class="kobospan" id="kobo.1074.2">We have covered the main functionality of our backend: listing posts with sorting, creating posts, and filtering by author. </span><span class="kobospan" id="kobo.1074.3">Dealing with tags and deleting and editing posts are similar to the already explained functionalities and are left as an exercise </span><span><span class="kobospan" id="kobo.1075.1">for you.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1076.1">In the next chapter, </span><a href="B19385_05.xhtml#_idTextAnchor090" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1077.1">Chapter 5</span></em></span></a><span class="kobospan" id="kobo.1078.1">, </span><em class="italic"><span class="kobospan" id="kobo.1079.1">Deploying the Application with Docker and CI/CD</span></em><span class="kobospan" id="kobo.1080.1">, we are going to deploy our application with Docker and set up CI/CD pipelines to automate the deployment of </span><span><span class="kobospan" id="kobo.1081.1">our application.</span></span></p>
</div>
</body></html>