- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: State Management in React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React中的状态管理
- en: 'In the previous chapters, we explored the concept of state in React and mastered
    the basics of working with it using the `useState` hook. Now it’s time to delve
    deeper into the **global state management** of applications. In this chapter,
    we will focus on the global state: we’ll define what it is, its key advantages,
    and the strategies for its effective management.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了React中的状态概念，并掌握了使用`useState`钩子与之交互的基础。现在，我们需要深入探讨应用的**全局状态管理**。在本章中，我们将关注全局状态：我们将定义它是什么，它的关键优势以及有效管理的策略。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is global state?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是全局状态？
- en: React Context API and useReducer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React上下文API和useReducer
- en: Redux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux
- en: Mobx
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mobx
- en: What is global state?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是全局状态？
- en: In developing React applications, one of the key aspects that requires special
    attention is **state management**. We are already familiar with the `useState`
    hook, which allows us to create and manage state within a component. This type
    of state is often referred to as **local**, and it is very effective within a
    single component and very simple and easy to use.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发React应用程序时，需要特别注意的一个关键方面是**状态管理**。我们已经熟悉了`useState`钩子，它允许我们在组件内部创建和管理状态。这种类型的状态通常被称为**局部**，它在一个组件内部非常有效，简单且易于使用。
- en: 'For a clearer illustration, consider an example with a small form component,
    where we have two **input** elements and have created two states for each **input**:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地说明，考虑一个具有小型表单组件的例子，其中我们有两个**输入**元素，并为每个**输入**创建了两个状态：
- en: '![](img/B19636_12_01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_12_01.png)'
- en: 'Figure 12.1: Form component with local state'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：带有局部状态的表单组件
- en: 'In this example, everything is simple: the user enters something into the `input`,
    which triggers an `onChange` event, where we usually change our `state`, causing
    a full re-render of the form, and then we see the result of the input on the screen.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一切都很简单：用户在`input`中输入一些内容，这会触发一个`onChange`事件，我们通常在这里改变我们的`state`，导致表单的全局重新渲染，然后我们在屏幕上看到输入的结果。
- en: 'However, as the complexity and size of your application increase, there will
    inevitably be a need for a more scalable and flexible approach to state management.
    Let’s further consider our example and imagine that after entering information
    into the form, we need to make a request to the server for user authorization
    and obtain a **session key**. Then, with this key, we need to request user data:
    name, surname, and avatar.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着应用程序的复杂性和规模的增加，不可避免地需要一种更可扩展和灵活的状态管理方法。让我们进一步考虑我们的例子，并想象在填写表单信息后，我们需要向服务器发送用户授权请求并获取**会话键**。然后，使用这个键，我们需要请求用户数据：姓名、姓氏和头像。
- en: 'Here, we immediately encounter difficulties: where do we store the session
    key and user data? Perhaps we can retrieve the data right inside the form and
    then pass it up to the parent component, as it is more global and responsible.
    Alright, let’s illustrate this and take a look:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们立即遇到了困难：会话键和用户数据应该存储在哪里？也许我们可以在表单内部直接检索数据，然后将其传递给父组件，因为它是更全局的并且负责。好吧，让我们来展示这一点并看看：
- en: '![](img/B19636_12_02.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_12_02.png)'
- en: 'Figure 12.2: Login page with form component'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：带有表单组件的登录页面
- en: So, now we have a login page, where we have local states for **session** and
    **user** objects. Using props, we can pass functions like `onSessionChange` and
    `onUserChange` to the form component, which ultimately allows us to transfer data
    from the form to the login page. Also, in the form, we now have the functions
    `getSessionKey` and `getUser`. These methods interact with the server, and upon
    successful response, they don’t store data locally but call the aforementioned
    `onSessionChange` and `onUserChange`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们有一个登录页面，其中我们为**会话**和**用户**对象创建了局部状态。使用props，我们可以将像`onSessionChange`和`onUserChange`这样的函数传递给表单组件，这最终使我们能够将数据从表单传输到登录页面。此外，在表单中，我们现在有`getSessionKey`和`getUser`这样的函数。这些方法与服务器交互，在成功响应后，它们不会在本地存储数据，而是调用上述的`onSessionChange`和`onUserChange`。
- en: One might think that the data storage problem is solved, but likely after user
    authorization and obtaining their data, we need to redirect the user to some homepage
    of our application. We could repeat our trick of lifting the data higher once
    again, but before doing that, let’s think ahead and imagine that obtaining user
    data is probably not just the job of the authorization form, and such a function
    might be needed on other pages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会认为数据存储问题已经解决，但很可能在用户授权并获得他们的数据后，我们需要将用户重定向到我们应用程序的某个主页。我们可能再次重复将数据提升到更高层次的小把戏，但在这样做之前，让我们提前思考并想象获取用户数据可能不仅仅是授权表单的工作，这种功能可能在其他页面上也需要。
- en: 'Ultimately, we come to understand that in addition to the data itself, we also
    need to keep the logic for working with the data higher up in the component tree:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们理解到，除了数据本身之外，我们还需要将处理数据的逻辑保持在组件树的上层：
- en: '![](img/B19636_12_03.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_12_03.png)'
- en: 'Figure 12.3: App root component'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：应用程序根组件
- en: This image clearly demonstrates how the application becomes more complicated
    when we need to pass down all the necessary data and methods from the topmost
    component of the application to all its pages and components.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片清楚地展示了当我们需要将所有必要的数据和方法从应用程序的最顶层组件传递到所有页面和组件时，应用程序如何变得更加复杂。
- en: In addition to the complexity of implementing and maintaining such an approach
    to organizing the application’s state, there is also a significant performance
    problem. For example, having a state in the root component created through `useState`,
    every time we update it, the entire application will be re-rendered because the
    app root component will be redrawn.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实现和维护这种组织应用程序状态的方法的复杂性之外，还存在一个重大的性能问题。例如，在根组件中通过`useState`创建的状态，每次我们更新它时，整个应用程序都会重新渲染，因为应用程序的根组件将被重新绘制。
- en: 'So, we have identified the main problems with organizing local state in the
    components of a large application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经识别出在大型应用程序的组件中组织本地状态的主要问题：
- en: Overcomplicated component tree, where all important data must be passed down
    from top to bottom using props. This tightly couples the components, complicating
    the code and its maintenance.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件树过于复杂，所有重要数据都必须通过props从上到下传递。这紧密耦合了组件，使代码及其维护变得复杂。
- en: Performance issue, where the application may re-render unnecessarily when it’s
    not required.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能问题，当应用程序不需要时，可能会不必要地重新渲染。
- en: Looking at the last image, one can think of whether it is possible to break
    the connection of our components and extract all the data and logic somewhere
    outside of the components. This is where the concept of global state comes into
    play.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看到最后一张图，人们可能会想是否可以切断我们组件的连接，并将所有数据和逻辑提取到组件之外。这就是全局状态概念发挥作用的地方。
- en: '**Global state** is a data management approach that allows state to be accessible
    and modifiable across different levels and components of your application. This
    solution overcomes the limitations of local state, facilitating data exchange
    between components and improving state manageability in large-scale projects.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局状态**是一种数据管理方法，它允许状态在应用程序的不同层次和组件之间可访问和可修改。这种解决方案克服了本地状态的局限性，促进了组件之间的数据交换，并提高了大规模项目中的状态可管理性。'
- en: 'To clearly understand how global state would look in our example, take a look
    at the image below:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地了解全局状态在我们例子中的样子，请看下面的图片：
- en: '![](img/B19636_12_04.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_12_04.png)'
- en: 'Figure 12.4: App root component and global state'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：应用程序根组件和全局状态
- en: In this example, we have a global state that is located outside of the components
    and the entire tree. Only the components that actually need any data from the
    state can directly access it and subscribe to its changes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个位于组件和整个树之外的全局状态。只有那些实际上需要从状态中获取数据的组件可以直接访问它并订阅其变化。
- en: 'By implementing global state, we can solve both problems at once:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现全局状态，我们可以一次解决两个问题：
- en: Simplifies the component tree and dependencies, thereby scaling and supporting
    the application.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化了组件树和依赖关系，从而扩展并支持了应用程序。
- en: Increases application performance because now, only those components that were
    subscribed to data from the global state are re-rendered when the state changes.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高了应用程序的性能，因为现在，只有订阅了全局状态数据的组件在状态变化时才会重新渲染。
- en: However, it’s important to understand that the local state remains a very powerful
    tool and should not be abandoned in favor of the global state. We only gain advantages
    when the state needs to be used across different levels of application components.
    Otherwise, if we start transferring all variables and states to the global state,
    we will only complicate the application without gaining any benefits.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要理解，局部状态仍然是一个非常强大的工具，不应该为了全局状态而放弃。我们只有在状态需要在应用组件的不同层级之间使用时才能获得优势。否则，如果我们开始将所有变量和状态转移到全局状态，我们只会使应用复杂化而不会获得任何好处。
- en: Now that we know that the global state is merely a way of organizing data, how
    do we manage the global state? A **state manager** is a tool that helps organize
    and manage state in an application, especially when it comes to complex interactions
    and extensive data. It provides a **centralized repository** for all your application’s
    state and manages its updates in an orderly and predictable manner. In practice,
    state managers are often represented as npm packages installed as project dependencies.
    However, it is also possible to manage the global state independently without
    any libraries using React’s API. We will explore one such approach later on.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道全局状态仅仅是组织数据的一种方式，我们该如何管理全局状态呢？**状态管理器** 是一个帮助组织和管理应用状态的工具，尤其是在处理复杂交互和大量数据时。它为应用的所有状态提供了一个**集中式存储库**，并以有序和可预测的方式管理其更新。在实践中，状态管理器通常以
    npm 包的形式表示，作为项目依赖项安装。然而，也可以使用 React 的 API 独立管理全局状态，而不使用任何库。我们将在稍后探讨这种方法。
- en: React Context API and useReducer
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Context API 和 useReducer
- en: To organize the global state on your own, you can use tools that already exist
    in the React ecosystem, namely the **Context API** and `useReducer`. They represent
    a powerful duo for managing state, especially in situations where using third-party
    state managers seems excessive. These tools are ideal for creating and managing
    global states in more compact applications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要自己组织全局状态，你可以使用 React 生态系统中的现有工具，即 **Context API** 和 `useReducer`。它们是一对强大的状态管理工具，尤其是在使用第三方状态管理器显得过多的情况下。这些工具非常适合在更紧凑的应用中创建和管理全局状态。
- en: The **React Context API** is designed to pass data through the component tree
    without the need to pass props at every level. This simplifies access to data
    in deeply nested components and reduces **prop drilling** (passing props through
    many levels), as illustrated in *Figure 12.4*. The React Context API is particularly
    useful for data such as theme settings, language preferences, or user information.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Context API** 的设计是为了在组件树中传递数据，而不需要在每个层级传递 props。这简化了深层嵌套组件中数据的访问，并减少了
    **prop 传递**（通过多个层级传递 props），如图 *12.4* 所示。React Context API 对于像主题设置、语言偏好或用户信息这样的数据尤其有用。'
- en: 'Here’s an example of how to store theme settings using context:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个如何使用上下文来存储主题设置的示例：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, we created `ThemeContext` using the `createContext` function.
    Then, we made a `ThemeProvider` component, which should wrap the root component
    of the application. This will later allow access at any level of nested components
    using the `useTheme` hook, which was created with the `useContext` hook:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `createContext` 函数创建了 `ThemeContext`。然后，我们创建了一个 `ThemeProvider`
    组件，它应该包裹应用的根组件。这将允许使用 `useTheme` 钩子在任何嵌套组件的层级上访问，该钩子是用 `useContext` 钩子创建的：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On any level of the component tree, we can access the current theme using the
    `useTheme` hook.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件树的任何层级上，我们都可以使用 `useTheme` 钩子访问当前的主题。
- en: 'Next let’s take a look at the next one of the duo, the special hook that will
    help us to build the global state. `useReducer` is a hook that allows you to manage
    complex states with reducers: functions that take the current state and an action,
    and then return a new state. `useReducer` is ideal for managing states that require
    complex logic or multiple sub-states. Let’s consider a small example of a counter
    using `useReducer`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这对中的一员，即那个将帮助我们构建全局状态的特殊钩子。`useReducer` 是一个钩子，允许你使用还原器（reducer）来管理复杂的状态：还原器是接受当前状态和动作，然后返回新状态的函数。`useReducer`
    对于需要复杂逻辑或多个子状态的状态管理来说非常理想。让我们考虑一个使用 `useReducer` 的简单计数器示例：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example, a reducer is implemented that has two actions: `increasing`
    and `decreasing` the counter.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，实现了一个具有两个动作的还原器：`增加` 和 `减少` 计数器。
- en: The combination of the Context API and `useReducer` provides a powerful mechanism
    for creating and managing the global state of an application. This approach is
    convenient for small applications, where ready-made and larger state management
    solutions might be redundant. However, it’s also worth noting that this solution
    doesn’t completely solve the performance issue, as any change in the theme in
    the `useTheme` example or the counter in the counter example will cause the provider,
    and thus the entire component tree, to re-render. This can be avoided, but it
    requires additional logic and coding.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Context API和`useReducer`的组合为创建和管理应用程序的全局状态提供了一个强大的机制。这种方法对于小型应用程序来说很方便，因为现成的和更大的状态管理解决方案可能显得多余。然而，也值得注意，这种解决方案并没有完全解决性能问题，因为在`useTheme`示例中的主题更改或计数器示例中的计数器更改都会导致提供者，进而导致整个组件树重新渲染。这可以通过额外的逻辑和编码来避免。
- en: Therefore, more complex applications require a more powerful tool. For this,
    there are several ready-made and popular solutions for working with state, each
    with its unique features and suitable for different use cases.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更复杂的应用程序需要更强大的工具。为此，有几个现成的和流行的解决方案用于处理状态，每个解决方案都有其独特的功能和适用于不同的用例。
- en: Redux
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux
- en: The first of such tools is, of course, **Redux**. It is one of the most popular
    tools for managing state in complex JavaScript applications, especially when used
    with React. Redux provides predictable state management by maintaining the application’s
    state in a single global object, simplifying the tracking of changes and data
    management.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中的第一个当然是**Redux**。它是管理复杂JavaScript应用程序状态最受欢迎的工具之一，尤其是在与React一起使用时。Redux通过维护单个全局对象中的应用程序状态来提供可预测的状态管理，简化了更改跟踪和数据管理。
- en: 'Redux is based on three core principles: a single source of truth (one global
    state), the state is read-only (immutable), and changes are made using pure functions
    (reducers). These principles ensure an orderly and controlled data flow.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Redux基于三个核心原则：单一事实来源（一个全局状态）、状态是只读的（不可变）和更改是通过纯函数（还原器）进行的。这些原则确保了有序和受控的数据流。
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the state of the application has been implemented from the
    counter example. We have a `counterReducer`, which is a regular function that
    takes the current state and the action to be performed on it. The reducer always
    returns a new state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，应用程序的状态是从计数器示例实现的。我们有一个`counterReducer`，它是一个常规函数，它接受当前状态和要对其执行的操作。还原器始终返回一个新的状态。
- en: Implementing asynchronous operations in the Redux world is a complex issue,
    as out of the box it offers nothing but middleware, which is used by third-party
    solutions. One such solution is `redux-thunk`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redux世界中实现异步操作是一个复杂的问题，因为默认情况下它只提供了中间件，这是第三方解决方案使用的。其中一个解决方案是`redux-thunk`。
- en: '`redux-thunk` is a middleware that allows you to call action creator functions
    that return a function instead of an action object. This provides the ability
    to delay the dispatch of an action or dispatch multiple actions by making asynchronous
    requests.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`redux-thunk`是一个中间件，允许你调用返回函数而不是动作对象的动作创建函数。这提供了通过异步请求延迟动作分发或分发多个动作的能力。'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in the example, we create a function, `fetchUserData`, that doesn’t
    immediately change the state. Instead, it returns another function with a `dispatch`
    argument. This `dispatch` can be used as many times as needed to change the state.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在示例中所见，我们创建了一个函数`fetchUserData`，它不会立即改变状态。相反，它返回另一个带有`dispatch`参数的函数。这个`dispatch`可以根据需要多次使用来改变状态。
- en: There are also other more powerful but more complex solutions for asynchronous
    operations. We will not discuss these here.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他更强大但更复杂的异步操作解决方案。我们在这里不会讨论这些。
- en: Redux is well suited for managing complex global state in applications. It offers
    powerful debugging tools, such as time travel. Redux also facilitates the testing
    of state and logic due to the clear separation between data and its processing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Redux非常适合在应用程序中管理复杂的全局状态。它提供了强大的调试工具，例如时间旅行。由于数据与其处理之间的清晰分离，Redux还简化了状态和逻辑的测试。
- en: To integrate Redux with React, the `React-Redux` library is used. It provides
    `Provider` components, and the `useSelector` and `useDispatch` hooks, which allow
    easy connection of the Redux store to your React application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Redux与React集成，使用`React-Redux`库。它提供了`Provider`组件，以及`useSelector`和`useDispatch`钩子，这些钩子允许轻松地将Redux存储连接到你的React应用程序。
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the example above, the `Counter` component works with the Redux state by
    subscribing to changes through `useSelector`. This subscription is more granular,
    and changing the counter does not lead to the re-rendering of the entire application,
    but only of the specific component that invokes this hook.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`Counter`组件通过`useSelector`订阅变化来与Redux状态交互。这种订阅更为细致，改变计数器不会导致整个应用的重新渲染，而只会导致调用此钩子的特定组件重新渲染。
- en: 'However, it’s important to note the drawbacks of Redux. Although it is the
    most popular solution, it has significant issues that affect my personal choice
    against this solution:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是Redux的缺点。尽管它是最受欢迎的解决方案，但它存在一些重大问题，这些问题影响了我个人对这个解决方案的选择：
- en: Redux is verbose. Implementing a large global state requires writing a lot of
    boilerplate code in the form of reducers, actions, selectors, etc.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux的语法较为繁琐。实现一个大型全局状态需要编写大量的样板代码，例如reducers、actions、selectors等。
- en: With the growth of the project, the complexity of maintaining and scaling the
    Redux state increases disproportionately.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着项目的增长，维护和扩展Redux状态复杂性的增加是不成比例的。
- en: As the project and global state grow, application performance significantly
    decreases. This happens due to the need for a large number of computations, even
    if you simply change the state of one value from `false` to `true`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目和全局状态的增长，应用性能显著下降。这发生是因为需要大量计算，即使只是将一个值的状态从`false`改为`true`。
- en: Implementation of asynchronous operations is not supported out of the box by
    Redux and requires additional solutions, further complicating the understanding
    and maintenance of the project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Redux不支持开箱即用的异步操作，需要额外的解决方案，这进一步增加了项目理解和维护的复杂性。
- en: Dividing state and business logic into chunks for lazy loading requires a lot
    of effort. As a result, the application’s size and therefore its initial loading
    speed are affected.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态和业务逻辑分割成块以实现懒加载需要大量的工作。因此，应用的大小及其初始加载速度受到影响。
- en: Despite these drawbacks, many companies and developers still use this solution,
    as it suits most business tasks, so I believe it is important to know this tool
    and be able to work with it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些缺点，许多公司和开发者仍然使用这个解决方案，因为它适合大多数业务任务，因此我认为了解这个工具并能够使用它非常重要。
- en: MobX
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MobX
- en: The next popular solution for managing the global state is the **MobX** library.
    This library differs significantly from Redux, with a concept that is in some
    ways even the opposite.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 管理全局状态的下一个流行解决方案是**MobX**库。这个库与Redux有显著的不同，在某些方面甚至可以说是相反的。
- en: MobX is a state management library that provides reactive and flexible interaction
    with data. Its main idea is to make the application state as simple and transparent
    as possible, working through small objects and classes that can be created as
    many times as desired and nested within each other.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: MobX是一个状态管理库，它提供了对数据的反应性和灵活的交互。其主要思想是将应用状态尽可能简化并透明化，通过创建尽可能多次的小对象和类来实现，这些对象和类可以嵌套在一起。
- en: 'Technically, the library allows for creating not just one global state but
    many small objects directly linked to some functionality of the application, which
    gives a significant advantage when working with large applications. To get the
    difference between one global state and MobX states, you can look at the following
    diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，这个库允许创建不仅是一个全局状态，还可以直接与某些应用功能相关联的多个小对象，这在处理大型应用时提供了显著的优势。要了解一个全局状态和MobX状态之间的区别，可以查看以下图表：
- en: '![](img/B19636_12_05.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_12_05.png)'
- en: 'Figure 12.5: MobX state'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：MobX状态
- en: In MobX, the state of the application is managed using `observable` method,
    which automatically track changes and inform related computed values and reactions.
    This allows the application to automatically update in response to state changes,
    simplifying the data flow and increasing flexibility.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在MobX中，应用状态是通过`observable`方法管理的，该方法自动跟踪变化并通知相关的计算值和反应。这使得应用能够自动根据状态变化更新，简化数据流并增加灵活性。
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the example, the same counter is implemented using MobX. In one class, both
    the actual data and computed data are present, along with actions to change the
    state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，相同的计数器使用MobX实现。在一个类中，既有实际数据，也有计算数据，以及用于改变状态的操作。
- en: Speaking about asynchronous operations, MobX doesn’t have any issues with that,
    as you can work in a regular class and add a new method that returns a promise.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 谈及异步操作，MobX在这方面没有任何问题，因为你可以在一个常规类中工作，并添加一个返回Promise的新方法。
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: MobX is well suited for applications that require high performance and simplicity
    in managing complex data dependencies. It offers an elegant and intuitive way
    to handle complex state, allowing developers to focus on business logic rather
    than state management.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: MobX非常适合需要高性能和简单管理复杂数据依赖的应用程序。它提供了一种优雅直观的方式来处理复杂的状态，使开发者能够专注于业务逻辑而不是状态管理。
- en: One drawback of this library is the considerable freedom it provides in organizing
    state, which can lead to difficulties and scalability issues in inexperienced
    hands. For example, MobX allows direct manipulation of object data, which can
    trigger component updates, but this can also lead to unexpected state changes
    in large projects and debugging challenges. Similarly, this freedom often results
    in small, clean MobX classes becoming tightly coupled, making testing and project
    development more challenging.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的一个缺点是它在组织状态方面提供了相当大的自由度，这可能导致在不熟练的手中遇到困难和可扩展性问题。例如，MobX允许直接操作对象数据，这可以触发组件更新，但这也可能导致大型项目中的意外状态变化和调试挑战。同样，这种自由度往往导致小的、干净的MobX类变得紧密耦合，使得测试和项目开发更具挑战性。
- en: To integrate MobX with React, the `mobx-react` library is used, which provides
    the `observer` function. This allows React components to automatically react to
    changes in observed data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要将MobX与React集成，使用`mobx-react`库，它提供了`observer`函数。这允许React组件自动响应观察数据的变化。
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the example, the same counter is implemented using MobX. As you can see,
    we don’t use hooks to access the state or providers to store it in the application
    context. We simply import the variable from the file and use it. The `myStore`
    created from the `Store` class is the state itself. It’s easy to use the observed
    value of an object in a component because the component immediately subscribes
    to all changes of that value and will re-render every time it changes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，使用MobX实现了相同的计数器。正如你所见，我们不需要使用hooks来访问状态或使用providers将其存储在应用程序上下文中。我们只需从文件中导入变量并使用它。从`Store`类创建的`myStore`本身就是状态。在组件中使用对象的观察值非常简单，因为组件会立即订阅该值的所有变化，并且每次它变化时都会重新渲染。
- en: Just from the examples, you can already see how simple and convenient MobX is
    for managing state. Since it’s just an object, there are no complexities in lazily
    loading it when needed and clearing the cache and memory of the application when
    the data is no longer needed. I consider it a powerful tool for state management
    and highly recommend trying it in a real project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 只从示例中，你就可以看到MobX在管理状态方面的简单和方便。由于它只是一个对象，当需要时可以轻松地懒加载它，当数据不再需要时，可以清除应用程序的缓存和内存。我认为它是状态管理的一个强大工具，并强烈推荐在实际项目中尝试使用它。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve learned about global state and how to manage it. Using
    the example of limited local state, we’ve discussed why it’s important to have
    global state in cases where shared data is needed across different components
    at different levels of the application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了全局状态及其管理方法。以有限局部状态为例，我们讨论了为什么在应用程序的不同层级需要共享数据时，拥有全局状态很重要。
- en: We’ve explored an example using the React Context API and identified when to
    use it and when to prefer more powerful state management solutions. Next, we looked
    at two such solutions in the form of Redux and MobX.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用React Context API的示例，确定了何时使用它以及何时更倾向于更强大的状态管理解决方案。接下来，我们探讨了两种这样的解决方案，即Redux和MobX。
- en: In the next chapter, we will discuss server-side rendering and the benefits
    it can bring to our applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论服务器端渲染及其对我们应用程序可能带来的好处。
