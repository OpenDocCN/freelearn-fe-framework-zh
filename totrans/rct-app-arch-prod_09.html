<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer043">
<h1 class="chapter-number" id="_idParaDest-143"><a id="_idTextAnchor142"/>9</h1>
<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Configuring CI/CD for Testing and Deployment</h1>
<p>Our application is finally ready to go to production and meet its first users. We have built its features and implemented all the required checks, such as linting, testing, and so on, which will give us the confidence that the application code is <span class="No-Break">working correctly.</span></p>
<p>However, currently, all those checks must be executed on our local machine. Whenever we want to push a new feature to production, we need to run all the scripts and then redeploy the application manually, which is a very <span class="No-Break">tedious process.</span></p>
<p>In this chapter, we will learn what CI/CD is. Then, we will learn what GitHub Actions is and what are the main parts of a GitHub Actions pipeline. We will then learn how to create a CI/CD pipeline that will automate the verification and deployment of the application <span class="No-Break">to Vercel.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>What <span class="No-Break">is CI/CD?</span></li>
<li>Using <span class="No-Break">GitHub Actions</span></li>
<li>Configuring the pipeline <span class="No-Break">for testing</span></li>
<li>Configuring the pipeline for deploying <span class="No-Break">to Vercel</span></li>
</ul>
<p>By the end of this chapter, we will know how to configure the CI/CD pipeline with GitHub Actions and deploy the application <span class="No-Break">to Vercel.</span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor144"/>Technical requirements</h1>
<p>Before we get started, we need to set up our project. To be able to develop our project, we will need the following things installed on <span class="No-Break">our computer:</span></p>
<ul>
<li><strong class="bold">Node.js</strong> version 16 or above and <strong class="bold">npm</strong> version 8 <span class="No-Break">or above.</span></li>
<li>There are multiple ways to install Node.js and npm. Here is a great article that goes into more <span class="No-Break">detail: </span><a href="https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js"><span class="No-Break">https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js</span></a><span class="No-Break">.</span></li>
<li><strong class="bold">VSCode</strong> (optional) is currently the most popular editor/IDE for JavaScript/TypeScript, so we will be using it. It is open source, has great integration with TypeScript, and we can extend its features via extensions. It can be downloaded <span class="No-Break">from </span><a href="https://code.visualstudio.com/"><span class="No-Break">https://code.visualstudio.com/</span></a><span class="No-Break">.</span></li>
</ul>
<p>The code files for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/React-Application-Architecture-for-Production"><span class="No-Break">https://github.com/PacktPublishing/React-Application-Architecture-for-Production</span></a><span class="No-Break">.</span></p>
<p>The repository can be cloned locally with the <span class="No-Break">following command:</span></p>
<pre class="console">
git clone https://github.com/PacktPublishing/React-Application-Architecture-for-Production.git</pre>
<p>Once the repository has been cloned, we need to install the <span class="No-Break">application’s dependencies:</span></p>
<pre class="console">
npm install</pre>
<p>We can provide the environment variables using the <span class="No-Break">following command:</span></p>
<pre class="console">
cp .env.example .env</pre>
<p>Once the dependencies have been installed, we need to select the right stage of the code base that matches this chapter. We can do that by executing the <span class="No-Break">following command:</span></p>
<pre class="console">
npm run stage:switch</pre>
<p>This command will prompt us with a list of stages for <span class="No-Break">each chapter:</span></p>
<pre class="console">
? What stage do you want to switch to? (Use arrow
 keys)
❯ chapter-02
  chapter-03
  chapter-03-start
  chapter-04
  chapter-04-start
  chapter-05
  chapter-05-start
(Move up and down to reveal more choices)</pre>
<p>This is the ninth chapter, so we can select <strong class="source-inline">chapter-09-start</strong> if we want to follow along, or <strong class="source-inline">chapter-09</strong> to see the final results of <span class="No-Break">this chapter.</span></p>
<p>Once the chapter has been selected, all the files required to follow along with this chapter <span class="No-Break">will appear.</span></p>
<p>For more information about the setup details, check out the <span class="No-Break"><strong class="source-inline">README.md</strong></span><span class="No-Break"> file.</span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/>What is CI/CD?</h1>
<p><strong class="bold">Continuous integration/continuous deployment</strong> (<strong class="bold">CI/CD</strong>) is a method of delivering application changes to its users in an automated way. CI/CD should usually consist <a id="_idIndexMarker407"/>of the <span class="No-Break">following parts:</span></p>
<ul>
<li><strong class="bold">Continuous Integration</strong> is the automated process of verifying that the code has been built, tested, and merged into <span class="No-Break">a repository</span></li>
<li><strong class="bold">Continuous Delivery</strong> means delivering changes to <span class="No-Break">the repository</span></li>
<li><strong class="bold">Continuous Deployment</strong> means publishing the changes to the production server, where the changes are made available to <span class="No-Break">the users</span></li>
</ul>
<p>Now, let’s think about how we could implement CI/CD for our application. We already have all the parts – we just need to put them together. The process would work <span class="No-Break">like this:</span></p>
<ul>
<li>Run all code checks for the application (unit and integration testing, linting, type checking, format checking, and <span class="No-Break">so on)</span></li>
<li>Build the application and run <span class="No-Break">end-to-end tests</span></li>
<li>If both processes finish successfully, we can deploy <span class="No-Break">our application</span></li>
</ul>
<p>Here is how the process can <span class="No-Break">be visualized:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<img alt="Figure 9.1 – Pipeline overview " height="534" src="image/B17297_09_01.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Pipeline overview</p>
<p>This process will <a id="_idIndexMarker408"/>ensure our application is always in the best condition possible and that the changes get frequently and easily released to production. This is especially useful when working in larger teams where many changes are being introduced to the application on a <span class="No-Break">daily basis.</span></p>
<p>To run the CI/CD pipeline, we need proper infrastructure. Since we keep the repository on GitHub, we can use GitHub Actions to <span class="No-Break">handle CI/CD.</span></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/>Using GitHub Actions</h1>
<p><strong class="bold">GitHub Actions</strong> is a CI/CD tool that<a id="_idIndexMarker409"/> allows us to automate, build, test, and deploy pipelines. We can create workflows that run on a specific event in <span class="No-Break">the repository.</span></p>
<p>To understand how it works, let’s have a look at some of its components in the <span class="No-Break">following sections.</span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>Workflows</h2>
<p>A <strong class="bold">workflow</strong> is a process that can run one or more jobs. We can define them in YAML format within the <strong class="source-inline">.github/workflows</strong> folder. Workflows can be run when a specified event is <a id="_idIndexMarker410"/>triggered. We <a id="_idIndexMarker411"/>can also re-run workflows manually directly from GitHub. A repository can have as many workflows as <span class="No-Break">we want.</span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/>Events</h2>
<p>An <strong class="bold">event</strong>, when fired, will cause the <a id="_idIndexMarker412"/>workflow to run. GitHub activities can trigger <a id="_idIndexMarker413"/>events, such as pushing to the repository or creating a pull request. Besides that, they can also be started on a schedule or via HTTP <span class="No-Break">POST requests.</span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>Jobs</h2>
<p>A <strong class="bold">job</strong> defines a series of<a id="_idIndexMarker414"/> steps that will be executed in a workflow. A step can be either an<a id="_idIndexMarker415"/> action or a script that can <span class="No-Break">be executed.</span></p>
<p>A workflow can have many jobs that can run in parallel, or they can wait for dependent jobs to finish <span class="No-Break">before starting.</span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>Actions</h2>
<p>An <strong class="bold">action</strong> is an application that runs on<a id="_idIndexMarker416"/> GitHub Actions to perform a repetitive task. We<a id="_idIndexMarker417"/> can use already built actions available on <a href="https://github.com/marketplace?type=actions">https://github.com/marketplace?type=actions</a>, or we can create our own. We will be using a couple of pre-made actions in <span class="No-Break">our pipeline.</span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>Runners</h2>
<p>A runner is a server that runs workflows<a id="_idIndexMarker418"/> when they get triggered. It can be hosted on<a id="_idIndexMarker419"/> GitHub, but it can also <span class="No-Break">be self-hosted.</span></p>
<p>Now that we are familiar with the basics of GitHub Actions, we can start working on creating the workflow for <span class="No-Break">our application.</span></p>
<p>Let’s create the <strong class="source-inline">.github/workflows/main.yml</strong> file and the <span class="No-Break">initial code:</span></p>
<pre class="source-code">
name: CI/CD
on:
  - push
jobs:
# add jobs here</pre>
<p>In the preceding code, we are providing the name of the workflow. If we omit it, the name will be assigned to the <a id="_idIndexMarker420"/>name of the workflow file. Here, we are defining the <strong class="source-inline">push</strong> event, which will cause<a id="_idIndexMarker421"/> the workflow to run whenever code changes get pushed to <span class="No-Break">the repository.</span></p>
<p>We will define the jobs in the <span class="No-Break">following sections.</span></p>
<p>For every job we define, we will provide <span class="No-Break">the following:</span></p>
<pre class="source-code">
name: Name of the job
runs-on: ubuntu-latest</pre>
<p>These properties will be common for all <span class="No-Break">the jobs:</span></p>
<ul>
<li><strong class="source-inline">name</strong> sets the name of the <span class="No-Break">running job</span></li>
<li><strong class="source-inline">runs-on</strong> sets the runner, which will run <span class="No-Break">the job</span></li>
</ul>
<p>Now that we learned what GitHub Actions is and what are the main parts of a pipeline, we can now start working on the pipelines for <span class="No-Break">our application.</span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Configuring the pipeline for testing</h1>
<p>Our testing pipeline will <a id="_idIndexMarker422"/>consist of two jobs that should do <span class="No-Break">the following:</span></p>
<ul>
<li>Run all code checks such as linting, type checking, unit and integration testing, and <span class="No-Break">so on</span></li>
<li>Build the application and run <span class="No-Break">end-to-end tests</span></li>
</ul>
<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Code checks job</h2>
<p>The code checks job should work <a id="_idIndexMarker423"/>as shown in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<img alt="Figure 9.2 – Code checks job overview " height="1002" src="image/B17297_09_02.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Code checks job overview</p>
<p>As we can see, the job should <span class="No-Break">be straightforward:</span></p>
<ol>
<li>First, we need to provide environment variables to <span class="No-Break">the application.</span></li>
<li>Then, we need to install <span class="No-Break">the dependencies.</span></li>
<li>Next, we must run unit and <span class="No-Break">integration tests.</span></li>
<li>Then, we must <span class="No-Break">run linting.</span></li>
<li>After, we must check the <span class="No-Break">code format.</span></li>
<li>Finally, we must run <span class="No-Break">type checking.</span></li>
</ol>
<p>Within <strong class="source-inline">jobs</strong>, let’s add <a id="_idIndexMarker424"/>the job that runs <span class="No-Break">these tasks:</span></p>
<pre class="source-code">
jobs:
  code-checks:
    name: Code Checks
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 16
      - run: mv .env.example .env
      - run: npm install
      - run: npm run test
      - run: npm run lint
      - run: npm run format:check
      - run: npm run types:check</pre>
<p>There are a couple of things worth mentioning about <span class="No-Break">the job:</span></p>
<ul>
<li>We use the <strong class="source-inline">actions/checkout@v3</strong> action from the marketplace to allow the job to access <span class="No-Break">the repository</span></li>
<li>We use the <strong class="source-inline">actions/setup-node</strong> action to configure which node version <span class="No-Break">to run</span></li>
<li>We execute the scripts to verify that everything works <span class="No-Break">as expected</span></li>
</ul>
<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>End-to-end testing job</h2>
<p>Our second job related<a id="_idIndexMarker425"/> to testing is the end-to-end job, where we want to build the application and run the end-to-end tests we defined in the <span class="No-Break">previous chapter.</span></p>
<p>It should work as shown in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<img alt="Figure 9.3 – E2E testing job " height="1002" src="image/B17297_09_03.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – E2E testing job</p>
<p>As we can see, the job will work <span class="No-Break">as follows:</span></p>
<ol>
<li value="1">First, we need to add the <span class="No-Break">environment variables.</span></li>
<li>Then, the dependencies for the applications need to <span class="No-Break">be installed.</span></li>
<li>Then, we need to create the production build of <span class="No-Break">the application.</span></li>
<li>Finally, the production code gets <span class="No-Break">end-to-end tested.</span></li>
</ol>
<p>To implement this job, let’s add <a id="_idIndexMarker426"/>the <span class="No-Break">following code:</span></p>
<pre class="source-code">
jobs:
  # previous jobs
  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: mv .env.example .env
      - uses: cypress-io/github-action@v4
        with:
          build: npm run build
          start: npm run start</pre>
<p>There are a couple of things worth mentioning about <span class="No-Break">the job:</span></p>
<ul>
<li>We use the <strong class="source-inline">actions/checkout@v3</strong> action to check out <span class="No-Break">the repository.</span></li>
<li>We use the <strong class="source-inline">cypress-io/github-action@v4</strong> action, which will abstract away the end-to-end testing. It will install all dependencies, build the application, and then start and run all <span class="No-Break">Cypress tests.</span></li>
</ul>
<p>Now that we configured the pipeline for running code checks such as linting, formatting, type checking, and testing, we can start working on deploying <span class="No-Break">the application.</span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor155"/>Configuring the pipeline for deploying to Vercel</h1>
<p>When our testing jobs finish, we <a id="_idIndexMarker427"/>want to deploy the application to Vercel. To start deploying to Vercel from GitHub Actions, we need to do a<a id="_idIndexMarker428"/> couple <span class="No-Break">of things:</span></p>
<ul>
<li>Have a <span class="No-Break">Vercel account</span></li>
<li>Disable GitHub integration <span class="No-Break">for Vercel</span></li>
<li>Link the project <span class="No-Break">to Vercel</span></li>
<li>Provide environment variables to <span class="No-Break">GitHub Actions</span></li>
<li>Create the job that will deploy <span class="No-Break">the application</span></li>
</ul>
<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>Having a Vercel account</h2>
<p>Vercel is straightforward to<a id="_idIndexMarker429"/> get started with. Visit <a href="https://vercel.com/signup">https://vercel.com/signup</a> and create an account if you don’t <span class="No-Break">have one.</span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Disabling GitHub integration for Vercel</h2>
<p><strong class="bold">Vercel</strong> is a platform that has<a id="_idIndexMarker430"/> excellent integration with GitHub out of the box. This means that whenever we push changes to the repository, a new version of the application will be deployed to Vercel automatically. However, in our case, we want to verify that our application works as expected before the deployment step so that we can perform this task from the <span class="No-Break">CI/CD pipeline.</span></p>
<p>To do this, we need to disable GitHub integration in Vercel. This can be done by creating the <strong class="source-inline">vercel.json</strong> file with the <span class="No-Break">following content:</span></p>
<pre class="source-code">
{
  "version": 2,
  "github": {
    "enabled": false
  }
}</pre>
<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/>Linking the project to Vercel</h2>
<p>Since we have disabled <a id="_idIndexMarker431"/>GitHub integration, we need to link the project in Vercel to our repository. This can be done by using the <span class="No-Break">Vercel CLI.</span></p>
<p>Let’s execute the <span class="No-Break">following command:</span></p>
<pre class="console">
npx vercel</pre>
<p>The CLI will ask us a series of questions, <span class="No-Break">as follows:</span></p>
<pre class="console">
? Set up and deploy "~/web/project-name"? [Y/n] y
? Which scope do you want to deploy to? org-name
? Link to existing project? [y/N] n
? What's your project's name? project-name
? In which directory is your code located? ./</pre>
<p>Once the CLI process finishes, the <strong class="source-inline">.vercel</strong> folder will be generated. It is a folder that should never be tracked by the repository. Inside the <strong class="source-inline">.vercel/project.json</strong> file, we will find our project credentials, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
{"orgId":"example_org_id","projectId":"example_project_id"}</pre>
<p>We will need to provide these values to GitHub Actions in a <span class="No-Break">few moments.</span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor159"/>Providing environment variables to GitHub Actions</h2>
<p>For our pipeline, we need a <a id="_idIndexMarker432"/>couple of <span class="No-Break">environment variables:</span></p>
<ul>
<li><strong class="source-inline">VERCEL_ORG_ID</strong>, which we can get from the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">vercel/project.json</strong></span><span class="No-Break"> file</span></li>
<li><strong class="source-inline">VERCEL_PROJECT_ID</strong>, which we can also get from the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">vercel/project.json</strong></span><span class="No-Break"> file</span></li>
<li><strong class="source-inline">VERCEL_TOKEN</strong> which we can get <span class="No-Break">from </span><a href="https://vercel.com/account/tokens%20"><span class="No-Break">https://vercel.com/account/tokens</span></a></li>
</ul>
<p>Once we have these values, we can add them to GitHub Actions for <span class="No-Break">our project:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<img alt="Figure 9.4 – Adding environment variables to GitHub Actions " height="602" src="image/B17297_09_04.jpg" width="1148"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Adding environment variables to GitHub Actions</p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>Creating the job that will deploy the application</h2>
<p>Now that everything has<a id="_idIndexMarker433"/> been set, we can start working on the job that will do all the work. We can see how it should work in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<img alt="Figure 9.5 – Deploy job overview " height="563" src="image/B17297_09_05.jpg" width="680"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Deploy job overview</p>
<p>As we can see, it will go through a couple <span class="No-Break">of steps:</span></p>
<ol>
<li value="1">Check the repository owner since we do not want to deploy if the workflow is triggered from a <span class="No-Break">repository fork.</span></li>
<li>Set the deployment status <span class="No-Break">to </span><span class="No-Break"><em class="italic">start</em></span><span class="No-Break">.</span></li>
<li>Deploy <span class="No-Break">to Vercel.</span></li>
<li>Set the deployment status <span class="No-Break">to </span><span class="No-Break"><em class="italic">finish</em></span><span class="No-Break">.</span></li>
</ol>
<p>Let’s add the <strong class="source-inline">deploy</strong> job to<a id="_idIndexMarker434"/> the workflow file, below the other jobs we <span class="No-Break">defined previously:</span></p>
<pre class="source-code">
jobs:
  # previous jobs
  deploy:
    name: Deploy To Vercel
    runs-on: ubuntu-latest
    needs: [code-checks, e2e]
    if: github.repository_owner == 'my-username'
    permissions:
      contents: read
      deployments: write
    steps:
      - name: start deployment
        uses: bobheadxi/deployments@v1
        id: deployment
        with:
          step: start
          token: ${{ secrets.GITHUB_TOKEN }}
          env: ${{ fromJSON('["Production", "Preview"]')
            [github.ref != 'refs/heads/master'] }}
      - uses: actions/checkout@v3
      - run: mv .env.example .env
      - uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-args: ${{ fromJSON('["--prod", ""]')
            [github.ref != 'refs/heads/master'] }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID}}
          vercel-project-id: ${{ secrets.
            VERCEL_PROJECT_ID}}
          scope: ${{ secrets.VERCEL_ORG_ID}}
          working-directory: ./
      - name: update deployment status
        uses: bobheadxi/deployments@v1
        if: always()
        with:
          step: finish
          token: ${{ secrets.GITHUB_TOKEN }}
          status: ${{ job.status }}
          env: ${{ steps.deployment.outputs.env }}
          deployment_id: ${{ steps.deployment.outputs.
            deployment_id }}</pre>
<p>There are a couple of things <a id="_idIndexMarker435"/>worth mentioning about <span class="No-Break">the job:</span></p>
<ul>
<li>We set this job to depend on the previous two by adding <strong class="source-inline">needs: [code-checks, e2e]</strong>. This means that this job will wait until those jobs complete successfully before starting. If some of those jobs fail, this job will <span class="No-Break">never run.</span></li>
<li>With <strong class="source-inline">if: github.repository_owner == 'my-username'</strong>, we check if the repository owner is the owner of the project. This check should prevent<a id="_idIndexMarker436"/> repository forks from deploying <span class="No-Break">the application.</span></li>
<li>We are using the <strong class="source-inline">bobheadxi/deployments@v1</strong> action before and after the deploying task to update the deployment status <span class="No-Break">in GitHub.</span></li>
<li>We are using the <strong class="source-inline">amondnet/vercel-action@v25</strong> action to deploy to Vercel. Depending on which branch got updated, it will be deployed either to a preview or <span class="No-Break">production environment.</span></li>
</ul>
<p>Our pipeline should look <span class="No-Break">like this:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<img alt="Figure 9.6 – Pipeline " height="292" src="image/B17297_09_06.jpg" width="645"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Pipeline</p>
<p>We can track the deployment status of each environment in the bottom-right corner of the <span class="No-Break">repository page:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<img alt="Figure 9.7 – Deployment statuses " height="281" src="image/B17297_09_07.jpg" width="377"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Deployment statuses</p>
<p>Awesome! Our application is<a id="_idIndexMarker437"/> now in production and available for users. Configuring the pipeline might take a bit more effort initially, but it saves a lot of time in the long run as we don’t have to worry about all these steps. They all just <span class="No-Break">got automated.</span></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor161"/>Summary</h1>
<p>In this chapter, we learned that a CI/CD pipeline is a process that allows the automation of code changes and delivery. We also got introduced to GitHub Actions and the parts that allow us to create the CI/CD pipeline to automate testing and deploying <span class="No-Break">our application.</span></p>
<p>After that, we defined three jobs for the workflow. With these jobs, we automated the process of running all the required checks, tests, and deployments. Finally, we learned how to deploy to Vercel from the CI/CD pipeline and deliver the application to <span class="No-Break">the users.</span></p>
<p>This concludes the MVP version of our application. In the next chapter, we will cover some of the potential features and improvements we can make to <span class="No-Break">the application.</span></p>
</div>
</div></body></html>