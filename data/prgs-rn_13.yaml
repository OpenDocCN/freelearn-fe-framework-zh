- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Tips and Outlook
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技巧与展望
- en: This chapter is divided into two parts. In the first part, I collected the most
    useful tips on how to make your React Native project a success. These tips come
    the things I have learned through a lot of different React Native projects I have
    worked on as a developer, consultant, software architect, or product owner. I
    also use React Native as a tech stack in my own companies, where I’m responsible
    for the business side, so I also know the requirements and pain points of this
    side.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两部分。在第一部分，我收集了关于如何使你的React Native项目成功的最有用的技巧。这些技巧来自于我在作为开发者、顾问、软件架构师或产品所有者参与的大量不同的React
    Native项目中所学到的知识。我还将React Native作为我自己的公司中的技术栈，我负责业务方面，因此我也了解这一方面的需求和痛点。
- en: The second part is an outlook on how I think React Native, its community, and
    its ecosystem will develop in the future. This is based on its technical development
    as well as the commitment from different big players in the community.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是对我认为React Native、其社区及其生态系统未来如何发展的展望。这是基于其技术发展以及社区中不同大玩家的承诺。
- en: 'This means you will learn the following things in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你将在本章学习以下内容：
- en: Understanding the most important things to make your React Native project a
    success
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解使你的React Native项目成功的重要因素
- en: Understanding the bright future of React Native
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光明的未来
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Since this is a completely theoretical chapter, there are no technical requirements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个完全理论性的章节，因此没有技术要求。
- en: Understanding the most important things to make your React Native project a
    success
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解使你的React Native项目成功的重要因素
- en: In this book, you learned a lot about the technical basics of how to ensure
    a successful React Native project. But if you already worked on production projects,
    you know that a software project never works as described in the books. There
    are always obstacles and problems that occur out of the blue and deadlines that
    seem impossible to meet.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你学到了很多关于如何确保React Native项目成功的专业技术基础。但如果你已经参与过生产项目，你知道软件项目永远不会像书中描述的那样工作。总会有突如其来的障碍和问题，以及看似不可能实现的截止日期。
- en: These tips will ensure that you are able to overcome these obstacles, solve
    these problems, and finally succeed in a real-world software project. So, let’s
    start right away with the tips.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技巧将确保你能够克服这些障碍，解决问题，并在现实世界的软件项目中最终取得成功。所以，让我们立即开始介绍这些技巧。
- en: Tip 1 – Find a process you never have to work around
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技巧1 – 找到一个你永远不需要绕过的流程
- en: 'A lot of projects I worked on had clearly defined processes from the beginning,
    but often, there occurred scenarios where someone worked around the process. A
    very common example of that is the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我参与过的许多项目一开始都有明确的过程定义，但通常会出现有人绕过流程的情况。一个非常常见的例子如下：
- en: '*The business side needs a feature or bugfix to be included in today’s release,
    leading to reduced testing, less detailed reviews, or even direct commits to release
    branches.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*业务方面需要将功能或错误修复包含在今天的版本中，导致测试减少，审查不够详细，甚至直接提交到发布分支。*'
- en: This is something I have experienced in a lot of projects. The problem with
    this is that in nearly all cases I experienced, it led to a lot more work in the
    end. The testing has to be done later, bugs that are found have to be fixed anyway,
    direct commits have to be merged or cherry-picked later, most of the time the
    code has to be refactored, and in the worst case, a bug can lead to corrupt data
    that has to be fixed later. So, the work you have with this behavior can easily
    multiply the work you would have when sticking by the process by 10 times or more.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在很多项目中都经历过的事情。问题是，在几乎所有我经历的情况中，这最终导致了更多的工作。测试必须延后进行，发现的错误必须修复，直接的提交必须稍后合并或选择，大多数时候代码必须重构，在最坏的情况下，一个错误可能导致需要稍后修复的数据损坏。因此，这种行为的额外工作可能会使你按照流程进行的工作量增加10倍或更多。
- en: So, the simple answer would be to say no to the business side, but that’s not
    always possible, because the business side may have a valid concern. Imagine the
    **chief executive officer** (**CEO**) promised a feature to an important customer
    and fears not being able to deliver in time because the next release is only in
    2 weeks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，简单的回答可能是对业务方面说“不”，但这种情况并不总是可能的，因为业务方面可能有一个合理的担忧。想象一下，**首席执行官**（CEO）向一个重要客户承诺了一个功能，并担心由于下一个版本只在一周后发布，他们可能无法按时交付。
- en: This is an example where you have to adapt your process to be able to have faster
    release cycles or allow urgent releases, to take away the CEO’s fears.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你必须调整你的流程以实现更快的发布周期或允许紧急发布的例子，以消除CEO的担忧。
- en: This is just an example and a concrete solution for exactly this example. There
    are multiple other scenarios where team members can lose faith in the process
    and try to work around it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个例子，也是针对这个具体例子的一个具体解决方案。还有许多其他场景，团队成员可能会对流程失去信心，并试图绕过它。
- en: 'Sometimes, it’s enough to explain the *why* behind the process; at other times,
    adaption is needed. But the key takeaway of this subsection is this: *Find a process
    you trust in and never work around it.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，解释过程背后的**原因**就足够了；在其他时候，则需要适应。但本小节的要点是：*找到你信任的过程，永远不要绕过它*。
- en: Tip 2 – Plan to be as flexible as possible with strategies to update without
    store releases
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示2 – 计划尽可能灵活，使用无存储发布更新的策略
- en: The bigger the project team is, the more likely it is that something happens
    that messes up your release planning. Again, I want to start this tip with an
    example. One application I was working on was translated into 36 languages. This
    meant that before every release, all texts that were introduced to the **user
    interface** (**UI**) were passed to translators.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 项目团队越大，出现影响发布计划的问题的可能性就越大。再次强调，我想用一个例子来开始这个提示。我正在开发的一个应用程序被翻译成了36种语言。这意味着在每次发布之前，所有引入到**用户界面**（**UI**）的文本都会被传递给翻译人员。
- en: They had 36 hours to translate and verify these texts and upload them to our
    translation service. After these 36 hours, we ran the release pipeline and released
    the app with the translations bundled into the binary.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 他们有36小时的时间翻译和验证这些文本，并将它们上传到我们的翻译服务。在这36小时之后，我们运行了发布管道，并将包含翻译的二进制文件发布的应用程序发布出去。
- en: This led to two problems. First, we had to wait 36 hours to be able to pass
    the release to Apple/Google for review. Second, most of the time, at least one
    translator was late, resulting in the new texts not being available in that language
    until the next release.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了两个问题。首先，我们必须等待36小时才能将发布版本提交给苹果/谷歌进行审查。其次，大多数时候，至少有一位翻译人员迟到，导致新文本在该语言中直到下一次发布才可用。
- en: 'We solved this problem by adding an update feature for all translations to
    our application. This feature is illustrated in the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过为我们的应用程序添加所有翻译的更新功能来解决此问题。此功能在下图中展示：
- en: '![Figure 13.1 – Updating without store release'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1 – 无存储发布更新'
- en: '](img/B16694_13_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片/B16694_13_01.jpg]'
- en: Figure 13.1 – Updating without store release
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 无存储发布更新
- en: 'We still bundle the translation files into the binary and ship the release
    with these translations, but on app start, we search for updated translations
    on our server. If we find any, we fetch and persist them locally, to always have
    the latest version available on the user’s device. A more detailed explanation
    can be found here: [https://bit.ly/prn-update-translations](https://bit.ly/prn-update-translations).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然将翻译文件打包到二进制文件中，并带有这些翻译的发布版本发送出去。但在应用程序启动时，我们会在我们的服务器上搜索更新的翻译。如果我们找到任何，我们会获取并持久化它们，以确保用户设备上始终有最新版本可用。更详细的解释可以在这里找到：[https://bit.ly/prn-update-translations](https://bit.ly/prn-update-translations)。
- en: This process not only works for translations but also for any type of data that
    should be locally available and changes very frequently.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流程不仅适用于翻译，也适用于任何应本地可用且频繁更改的数据类型。
- en: You could even go one step further by using over-the-air update tools such as
    Microsoft CodePush or Expo Updates. These tools leverage the fact that a React
    Native app is a native app containing a JavaScript bundle by providing a solution
    to update the whole JavaScript bundle *over the air*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以更进一步，使用如Microsoft CodePush或Expo Updates之类的空中更新工具。这些工具利用了React Native应用程序是一个包含JavaScript包的原生应用程序的事实，通过提供一种在空中更新整个JavaScript包的解决方案。
- en: Basically, your application connects to the tool’s server and searches for an
    updated JavaScript bundle. If an updated bundle is found, it gets downloaded and
    your app will start/restart.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你的应用程序连接到工具的服务器并搜索更新的JavaScript包。如果找到更新包，它将被下载，你的应用程序将启动/重启。
- en: While these tools can be very helpful to fix bugs or even improve functionality,
    it is not allowed to use them to introduce new features due to App Store and Google
    Play guidelines. Also, you have to keep in mind that they are limited to the JavaScript
    bundle.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些工具对于修复bug甚至改进功能非常有帮助，但根据App Store和Google Play的指南，不允许使用它们来引入新功能。此外，你必须记住，它们仅限于JavaScript包。
- en: As soon as you introduce new native functionality, assets, or other things,
    it is not possible to provide such an update with these tools. Even worse, if
    you try to provide such an update with these tools, you can break your app on
    the users’ devices, because you try to access native functionality that doesn’t
    exist.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你引入了新的原生功能、资产或其他内容，这些工具就无法提供此类更新。更糟糕的是，如果你尝试使用这些工具提供此类更新，你可能会在用户的设备上破坏你的应用程序，因为你试图访问不存在的原生功能。
- en: So, if you use these tools, be careful. Here, you can read more on CodePush
    ([https://bit.ly/prn-ms-code-push](https://bit.ly/prn-ms-code-push)), and here,
    you can find further details of Expo Updates ([https://bit.ly/prn-expo-updates](https://bit.ly/prn-expo-updates)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你使用这些工具，请务必小心。在这里，你可以阅读更多关于CodePush的信息（[https://bit.ly/prn-ms-code-push](https://bit.ly/prn-ms-code-push)），而在这里，你可以找到关于Expo更新的更多详细信息（[https://bit.ly/prn-expo-updates](https://bit.ly/prn-expo-updates)）。
- en: 'All these ideas have only one goal: to be as flexible as possible to be able
    to react to any requirements that may occur. Although native releases to App Store
    or Google Play are no longer a big problem today with Apple and Google getting
    reviews done in less than 1 day most of the time, it is good to know to be able
    to deliver updates even if Apple or Google delay the review process.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些想法只有一个目标：尽可能灵活，以便能够应对可能出现的任何要求。尽管苹果和谷歌通常在不到1天内完成审查，使得原生发布到App Store或Google
    Play不再是一个大问题，但了解即使苹果或谷歌延迟审查流程，也能提供更新是很好的。
- en: 'So, the takeaway of this subsection is this: *Implement a strategy to be able
    to update your application as fast and flexible as possible.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，本小节的要点是：*制定一个策略，以便尽可能快和灵活地更新你的应用程序*。
- en: Tip 3 – Always be aware of what’s happening in your app with stability monitoring
    tools
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小贴士3 – 总是使用稳定性监控工具关注你的应用程序中发生的事情
- en: 'There is only one thing that’s for sure in software development, and that is
    that there is no software without bugs. So, your application will contain bugs
    and users will experience problems with it. The only question is: When will you
    notice it?'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，唯一确定的事情是，没有没有bug的软件。所以，你的应用程序将包含bug，用户可能会遇到问题。唯一的问题是：你何时会注意到它？
- en: One of the most important things I learned during the last years is that the
    better you know what’s happening in your application, the faster you can respond.
    The worst case is when you realize a bug only because users write bad reviews
    about your application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，我学到的最重要的事情之一是，你对应用程序中发生的事情了解得越多，你就能越快地做出反应。最糟糕的情况是，你只是在用户对你的应用程序写差评后才发现了一个bug。
- en: There are a lot of different stability monitoring tools available as **software-as-a-service**
    (**SaaS**) products. The most widely used when it comes to React Native apps are
    Bugsnag and Sentry. Both have excellent support for React Native by providing
    React Native **software development kits** (**SDKs**).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的稳定性监控工具作为**软件即服务**（**SaaS**）产品可用。在React Native应用程序中，最广泛使用的是Bugsnag和Sentry。两者都提供了出色的React
    Native支持，通过提供React Native **软件开发工具包**（**SDKs**）。
- en: These SDKs collect native crashes as well as JavaScript errors, add useful information
    about device type and state, and send them to a server. The server consolidates
    the data, and the tools provide a web dashboard where you can get information
    about the stability of your app.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些SDK收集原生崩溃以及JavaScript错误，添加有关设备类型和状态的有用信息，并将它们发送到服务器。服务器整合数据，这些工具提供了一个网络仪表板，你可以从中获取有关应用程序稳定性的信息。
- en: You can have a look at every crash and error and even trace the error back to
    specific lines in your code by providing source maps.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看每一个崩溃和错误，甚至通过提供源映射来追踪错误回溯到代码中的特定行。
- en: You can also connect these tools to automatically create issues in your project
    management tool when a previously unseen bug occurs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现以前未见过的bug时，你还可以将这些工具连接到你的项目管理工具，以自动创建问题。
- en: 'There are other solutions available as well, and you could even write your
    own, but you should definitely implement any solution to track the stability of
    your app. So, the takeaway of this tip is this: *Use a stability monitoring tool.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他解决方案可供选择，你甚至可以自己编写，但你应该确保实施任何解决方案来跟踪你应用的稳定性。所以，这个技巧的要点是：*使用稳定性监控工具*。
- en: Tip 4 – Let the user test with A/B testing
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示 4 – 让用户通过 A/B 测试进行测试
- en: '**A/B testing** is something that is used in many areas of mobile app development
    nowadays, and you should definitely use it too. It means that you divide your
    users into two groups and provide them with slightly different parts of your application.
    Then, you wait for a certain time and look at the metrics to see which user group
    behaves better in the metrics that are important for you.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**A/B 测试**是现在在移动应用开发的许多领域都使用的一种方法，你绝对应该使用它。这意味着你将你的用户分成两组，并向他们提供应用的不同部分。然后，你等待一段时间，查看指标，以查看哪个用户组在你关心的指标中表现更好。'
- en: The most common use case for A/B testing in mobile development is testing new
    features. If you are not sure if a new feature helps you improve your goal metrics
    (such as improving retention), you will provide the new feature only to half of
    your users.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动开发中，A/B 测试最常见的使用案例是测试新功能。如果你不确定新功能是否有助于提高你的目标指标（例如提高留存率），你将只向一半的用户提供新功能。
- en: You would tag these users as group *A*. The other users, who have no access
    to the new feature, would be tagged as group *B*. Then, you would wait and collect
    data. After some time, you can compare which user group performed better regarding
    your goal metrics.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你将这些用户标记为组 *A*。其他没有访问新功能的用户将被标记为组 *B*。然后，你会等待并收集数据。一段时间后，你可以比较哪个用户组在目标指标方面表现更好。
- en: This can be done with features, designs, wording, images, and much more. But
    A/B testing can also be used in completely different cases.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过功能、设计、措辞、图片等等来实现。但 A/B 测试也可以用于完全不同的案例。
- en: One other example of using A/B testing is releasing an app update to only a
    group of people. This can be a beta test group, or on Google Play, you can even
    decide to only roll out your update to a certain percent of your users. You can
    then compare the stability metrics of the old release and the new release to roll
    it out to all users.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 A/B 测试的另一个例子是将应用更新仅发布给一组人。这可能是一个测试组，或者在 Google Play 上，你甚至可以决定只将更新推广到你用户的一定百分比。然后，你可以比较旧版本和新版本的老化稳定性指标，以将更新推广给所有用户。
- en: 'So, A/B testing can help you get the answers you need in a real-world environment,
    which is the only environment that counts. So, the key takeaway of this tip is
    this: *Use A/B testing to collect information to be able to make better decisions.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，A/B 测试可以帮助你在真实世界环境中获得所需的答案，这是唯一重要的环境。所以，这个技巧的关键要点是：*使用 A/B 测试收集信息，以便能够做出更好的决策*。
- en: Tip 5 – Use TypeScript as a single language stack
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示 5 – 使用 TypeScript 作为单一语言栈
- en: TypeScript is a typed language that works on mobile, web, and backend. This
    is a huge advantage when you set up your project with this single language stack.
    Your whole team is at least able to read and understand the code of the whole
    project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是一种在移动、网页和后端上工作的类型化语言。当你使用这种单一语言栈设置项目时，这是一个巨大的优势。你的整个团队至少能够阅读和理解整个项目的代码。
- en: Talented software developers can also transfer from backend to frontend or the
    other way round if needed, and you can even share code between client and server.
    This is especially interesting when you have shared data types or business logic
    that runs on the client for mobile and on the server for web.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，有才华的软件开发人员也可以从后端转移到前端或相反方向，你甚至可以在客户端和服务器之间共享代码。这在你有共享的数据类型或业务逻辑时尤其有趣，这些逻辑在移动客户端上运行，在网页服务器上运行。
- en: Having one shared base for this code guarantees that data types and business
    logic behavior won’t differ between mobile, web, and server.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为此代码有一个共享的基础可以保证数据类型和业务逻辑行为在移动、网页和服务器之间不会有所不同。
- en: 'I experienced the best results, fastest **time to market** (**TTM**), and best
    teamwork in projects with this single language stack. So, the takeaway from this
    tip is this: *Use TypeScript as a single language stack.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我在单一语言栈项目中经历了最佳的结果，最快的**上市时间**（**TTM**），以及最好的团队合作。所以，这个技巧的要点是：*使用 TypeScript
    作为单一语言栈*。
- en: Tip 6 – Keep your code simple and clean
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示 6 – 保持你的代码简单和清晰
- en: This tip seems to be obvious but let me explain what I mean. There are some
    simple ideas that keep your code simple and clean.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧看似明显，但让我解释一下我的意思。有一些简单的想法可以使你的代码保持简单和清晰。
- en: When working with React and React Native, you often have a lot of different
    options as to how to solve a specific problem. The first choice you have to make
    is between functional components or class components.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React 和 React Native 时，你通常有很多不同的选项来解决特定的问题。你必须做出的第一个选择是在功能组件和类组件之间。
- en: But there are a lot of other choices to make. Which state management solution
    do you use? How will you connect your backend? Do you write your own native solutions?
    If so, which language do you use?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有许多其他的选择要做。你将使用哪种状态管理解决方案？你将如何连接你的后端？你会编写自己的原生解决方案吗？如果是这样，你将使用哪种语言？
- en: If you make these choices, you should stick to your chosen option. It makes
    the application more complex if you use functional components and class components
    for your stateful components. The same applies to all the other options. Make
    a choice and stick to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做出了这些选择，你应该坚持你的选择。如果你为状态组件同时使用功能组件和类组件，这会使应用程序更加复杂。同样适用于所有其他选项。做出选择并坚持下去。
- en: Next, you should always extract code into components, if you can reuse it anywhere
    else. Most of the time, it’s much easier to create a component with some configuration
    options instead of writing nearly the same code multiple times.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你应该始终将可重用的代码提取到组件中。大多数情况下，创建一个带有一些配置选项的组件，而不是多次编写几乎相同的代码，要容易得多。
- en: And most importantly, never duplicate code. This will not only increase the
    risk of introducing bugs or inconsistencies, but it also will take more time in
    the long run. Maintaining a lean code base where everything is extracted into
    components is much easier.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，永远不要重复代码。这不仅会增加引入错误或不一致的风险，而且在长期来看也会花费更多的时间。维护一个精简的代码库，其中所有内容都提取到组件中，要容易得多。
- en: Last, try to write readable code. When completing a feature, always have a look
    at your code and ask yourself if another developer can understand what you have
    written without reading any documentation or running the app. If not, try to rename
    and refactor your code until it’s understandable. Write comments if the code doesn’t
    work without these.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽量编写可读的代码。在完成一个功能后，总是看看你的代码，问问自己是否有其他开发者可以在不阅读任何文档或运行应用的情况下理解你所写的内容。如果不能，尝试重命名和重构你的代码，直到它变得可理解。如果代码没有这些注释就无法工作，那么请添加注释。
- en: 'The goal is that a new member of your development team can start to be productive
    as fast as possible. So, the key takeaway here is this: *Write simple, clean,
    and understandable code with as few different libraries as possible.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是让新加入的开发团队能够尽可能快地开始产生效益。所以，这里的关键要点是：*尽可能使用简单、清晰、易懂的代码，并尽量少使用不同的库。*
- en: With these tips, you should be able to not only survive but also succeed in
    your next React Native project.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些技巧，你应该不仅能够生存，而且能够在你的下一个 React Native 项目中取得成功。
- en: As the last part of this book, I want to take a brief glimpse into the future
    of React Native.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这本书的最后一部分，我想简要地展望一下 React Native 的未来。
- en: Understanding the bright future of React Native
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 React Native 的光明未来
- en: When deciding which technology to use, it always plays an important role in
    how future-proof this technology is. This is especially important in long-running
    large-scale enterprise projects. So, I decided to end this book with some arguments
    as to why you can be absolutely sure that React Native is a good choice.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用哪种技术时，它总是对未来技术的长期适用性起着重要作用。这在长期运行的大型企业项目中尤为重要。因此，我决定以一些论据结束这本书，以证明你可以绝对确信
    React Native 是一个好的选择。
- en: This is particularly interesting because the last years haven’t always been
    easy for React Native developers. With Flutter, which is based on the very performant
    **two-dimensional** (**2D**) graphics engine Skia, a new solution for cross-platform
    development emerged and created a huge hype.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这尤其有趣，因为过去几年对 React Native 开发者来说并不总是容易。基于非常高效的二维（**2D**）图形引擎 Skia 的 Flutter，为跨平台开发提供了一种新的解决方案，并引发了巨大的炒作。
- en: Native development got more and more comfortable with the rise of Kotlin and
    Swift. React Native in the meantime didn’t evolve much. The long-promised refactoring
    (new architecture), first announced for 2020, took much more time than expected.
    Some developers started losing faith in React Native.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Kotlin和Swift的兴起，原生开发变得越来越舒适。与此同时，React Native并没有太多的发展。长期承诺的重构（新架构），最初宣布于2020年，比预期的花费了更多的时间。一些开发者开始对React
    Native失去信心。
- en: But this changed in 2022\. Now, the future of React Native couldn’t be brighter.
    This is for multiple reasons, which I want to explain in this last section of
    the book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但这一切在2022年发生了变化。现在，React Native的未来前所未有的光明。这有多个原因，我将在本书的最后一节中解释。
- en: Reason 1 – The new architecture has finally landed
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原因1 – 新架构终于落地
- en: 'As described in [*Chapter 3*](B16694_03.xhtml#_idTextAnchor061), *Hello React
    Native*, the new architecture brings a huge boost to React Native applications
    and the React Native community. These are the most important improvements that
    come with the new architecture:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第3章*](B16694_03.xhtml#_idTextAnchor061)中所述，*Hello React Native*，新架构为React
    Native应用程序和React Native社区带来了巨大的推动。以下是新架构带来的最重要的改进：
- en: '**General performance**: The replacement of the old React Native bridge with
    **JavaScript Interface** (**JSI**) eliminates the biggest performance bottleneck
    of React Native. There is no more serialization/deserialization needed when passing
    data between JavaScript and the native part of your application. This and a lot
    of other optimizations allow closing the performance gap to Flutter apps or native
    applications.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用性能**：用**JavaScript接口**（**JSI**）替换旧的React Native桥接消除了React Native最大的性能瓶颈。在JavaScript和应用程序的本地部分之间传递数据时不再需要序列化/反序列化。这以及其他许多优化使得缩小与Flutter应用或原生应用的性能差距成为可能。'
- en: '**Startup time**: The new architecture allows lazy loading of the native modules
    of an application, which improves startup time a lot.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动时间**：新架构允许应用程序的原生模块进行懒加载，这大大提高了启动时间。'
- en: '**Synchronous communication**: With the new architecture, it is now possible
    to make synchronous calls to native functions from within the JavaScript thread.
    This can lead to easier and cleaner code.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步通信**：随着新架构的引入，现在可以从JavaScript线程内部调用原生函数，这可以使得代码更加简洁和易于编写。'
- en: '**Writing native modules**: CodeGen and the new architecture in general make
    writing native modules a lot easier. With built-in type safety, it also supports
    one of the most important features in development.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写原生模块**：CodeGen和新的架构总体上使得编写原生模块变得更加容易。内置的类型安全还支持开发中最重要的功能之一。'
- en: I expect that the full rollout of the new architecture will be completed by
    the beginning of 2023\. This means that most of the community libraries will be
    adapted, and you can benefit from all the improvements with your app in a stable
    environment.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计新架构的全面推广将在2023年初完成。这意味着大多数社区库都将进行适配，你可以在一个稳定的环境中从所有改进中受益。
- en: Again, this new architecture is a really big thing because it refutes most of
    the arguments against using React Native.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个新架构真的是一个很大的事情，因为它反驳了大多数反对使用React Native的论点。
- en: The next reason is that there is a new architectural approach to React Native.
    A community project makes it possible to use Skia in React Native, which is also
    a huge step forward.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个原因是React Native有一个新的架构方法。一个社区项目使得在React Native中使用Skia成为可能，这同样是一个巨大的进步。
- en: Reason 2 – React Native Skia
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原因2 – React Native Skia
- en: As I explained before, Skia is the graphics engine that not only powers Flutter
    but also Google Chrome, Android, Firefox, and a lot more. Skia is one of the reasons
    these products have become so popular because it is an extremely powerful and
    highly performant graphics engine.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所解释的，Skia是不仅为Flutter提供动力，也为Google Chrome、Android、Firefox以及更多产品提供动力的图形引擎。Skia是这些产品之所以如此受欢迎的原因之一，因为它是一个极其强大且性能卓越的图形引擎。
- en: There have been some attempts in the past to leverage the power of Skia in React
    Native, but only with the new architecture was it possible to create a working
    React Native Skia library. This is another huge boost for React Native because
    it opens a whole new world when it comes to drawing on your screen.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 过去曾有一些尝试利用Skia在React Native中的力量，但只有在新架构下才可能创建一个可工作的React Native Skia库。这对于React
    Native来说又是一个巨大的推动，因为它在屏幕绘制方面开辟了一个全新的世界。
- en: To understand the extent of the new opportunities with React Native Skia, you
    have to take a look at how rendering elements in React Native works. As explained
    in [*Chapter 3*](B16694_03.xhtml#_idTextAnchor061), *Hello React Native*, every
    component used in the JavaScript code will be mapped to a native component. This
    also means you can only use the elements and properties that are available on
    the native side and that have been mapped to React Native components.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解React Native Skia带来的新机会的广度，你必须看看React Native中渲染元素是如何工作的。正如在[*第3章*](B16694_03.xhtml#_idTextAnchor061)“Hello
    React Native”中解释的那样，每个在JavaScript代码中使用的组件都将映射到一个原生组件。这也意味着你只能使用在原生端可用并且已映射到React
    Native组件的元素和属性。
- en: React Native Skia uses the same concept but creates a native canvas that can
    be drawn on with the Skia graphics engine. It then doesn’t make native components
    available in React Native but instead in the Skia **application programming interface**
    (**API**).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: React Native Skia使用相同的概念，但创建了一个可以使用Skia图形引擎绘制的原生画布。然后它不在React Native中提供原生组件，而是在Skia**应用程序编程接口**（**API**）中提供。
- en: This means in the future, you don’t have to go with Flutter anymore if you prefer
    to draw your UI to the screen using your own graphics engine instead of using
    native components. This is also possible using React Native. You can even use
    both concepts in the same application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在未来，如果你更喜欢使用自己的图形引擎将UI绘制到屏幕上而不是使用原生组件，你不必再选择Flutter。这也可以使用React Native实现。你甚至可以在同一个应用程序中使用这两个概念。
- en: 'You should definitely have a look at the project. It is hosted on GitHub; you
    can find all information here: [https://bit.ly/prn-rn-skia](https://bit.ly/prn-rn-skia).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你绝对应该看看这个项目。它在GitHub上托管；你可以在这里找到所有信息：[https://bit.ly/prn-rn-skia](https://bit.ly/prn-rn-skia)。
- en: The next reason why React Native has a bright future is as simple as it is important.
    The community behind the framework is still growing and includes a lot of huge
    companies that bet big on React Native.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: React Native拥有光明未来的下一个原因既简单又重要。该框架背后的社区仍在增长，包括许多对React Native下大注的大公司。
- en: Reason 3 – The community
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原因3 – 社区
- en: Even if React Native was initially created by Facebook, React Native is no longer
    only Meta (formerly Facebook). It is also Microsoft, Shopify, Tesla, Salesforce,
    Bloomberg, Discord, Coinbase, Pinterest, and a lot more companies.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 即使React Native最初是由Facebook创建的，但React Native已不再仅仅是Meta（前身为Facebook）。它还包括微软、Shopify、特斯拉、Salesforce、彭博社、Discord、Coinbase、Pinterest以及许多其他公司。
- en: And these companies are betting big on React Native. Meta is using it in more
    than 1,000 screens in the Facebook app, which still is one of the most widely
    used apps in the world. Microsoft uses React Native in some of their most well-known
    products such as Microsoft Office or Microsoft Teams. The Shopify team rewrote
    all of their apps in React Native.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些公司也在大力押注React Native。Meta在Facebook应用中使用了超过1,000个屏幕，这仍然是世界上使用最广泛的应用之一。微软在他们的许多知名产品中使用React
    Native，如Microsoft Office或Microsoft Teams。Shopify团队将他们的所有应用都重写为React Native。
- en: And even better, most of these companies not only use React Native, but they
    are also actively contributing. For example, Microsoft created and maintains React
    Native for Windows and macOS. Shopify sponsors React Native Skia and supports
    multiple other community projects such as React Native FlashList.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，这些公司中的大多数不仅使用React Native，而且还在积极贡献。例如，微软为Windows和macOS创建了并维护React Native。Shopify赞助React
    Native Skia，并支持多个其他社区项目，如React Native FlashList。
- en: And it’s not only these companies. It is tens of thousands of contributors worldwide.
    This results in one of the most active developer communities in the world, creating
    useful, high-quality open source libraries and solutions every day.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 而不仅仅是这些公司。这是全球成千上万的贡献者。这导致世界上最具活力的开发者社区之一，每天都在创建有用、高质量的开放源代码库和解决方案。
- en: Reason 4 – TypeScript and React
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原因4 – TypeScript和React
- en: While it may not be the right choice for high-performance computing tasks, using
    TypeScript as the language for your mobile application is absolutely the right
    choice. You can run it on mobile, web, and server, to share code between these
    platforms. It is easy to learn and start with, and new developers can get productive
    very fast.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它可能不是高性能计算任务的正确选择，但使用TypeScript作为移动应用程序的语言绝对是正确的选择。你可以在移动、Web和服务器上运行它，以在这些平台之间共享代码。它易于学习和开始，新开发者可以非常快地变得高效。
- en: With TypeScript as your single language stack, you have access to one of the
    largest talent markets around, much larger than the talent market for Dart (Flutter),
    Kotlin (native Android), or Swift (native iOS) developers. This is especially
    important in these times, where **information technology** (**IT**) talents are
    very rare.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用TypeScript作为你的单一语言栈，你将能够接触到最大的人才市场之一，这比Dart（Flutter）、Kotlin（原生Android）或Swift（原生iOS）开发者的市场要大得多。在信息技术人才非常稀缺的这些日子里，这一点尤为重要。
- en: The same is true for React. It is by far the most used web framework. Every
    React developer is able to work on React Native projects and can be very productive
    even after only some days of training. This means you have a really huge talent
    pool from which you can hire your developing team.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于React来说，也是如此。它到目前为止是最受欢迎的Web框架。每一位React开发者都能够参与React Native项目，并且经过短短几天的培训后，也能非常高效地工作。这意味着你有一个非常大的人才库，你可以从中雇佣你的开发团队。
- en: So, you can see that there is nothing to fear when deciding to use React Native
    in your project. There is a huge commitment to further develop the framework,
    and you can be absolutely sure that it will be actively maintained for a very
    long time. Many huge companies are depending on React Native, and they do it for
    good reasons. So, in my opinion, it is the best choice available to write mobile
    apps.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你决定在你的项目中使用React Native时，你不必感到害怕。对进一步开发这个框架有着巨大的承诺，你可以绝对确信它将会被长期积极地维护。许多大型公司都依赖于React
    Native，他们这样做有很好的理由。所以，在我看来，它是编写移动应用的最佳选择。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: After this outlook, it’s time for a short conclusion to this chapter. In the
    first part of this chapter, you learned how important a good development process
    is, tips to be as flexible as possible with your releases, how to monitor your
    apps’ stability, how to leverage A/B testing, how to use TypeScript in your mobile
    application, and how to keep your code simple and clean. In the second part, you
    got to know the most important reasons why React Native has a bright future and
    discovered that you can be absolutely sure that it is a good choice for your mobile
    application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在展望了这些之后，现在是时候对这个章节做一个简短的总结了。在本章的第一部分，你学习了良好的开发过程是多么重要，如何尽可能灵活地发布，如何监控你应用的稳定性，如何利用A/B测试，如何在你的移动应用中使用TypeScript，以及如何保持你的代码简单和整洁。在第二部分，你了解了React
    Native拥有光明未来的最重要的原因，并发现你可以绝对确信它是你移动应用的一个很好的选择。
- en: Now, it’s time for final congratulations. You are at the end of this book, and
    I hope you learned a lot of new and useful things. You should now understand how
    React Native works and how to use it in large-scale projects to build high-performance
    apps for multiple platforms, helping you save both time and money.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候给予最后的祝贺了。你已经完成了这本书的阅读，我希望你学到了许多新的、有用的东西。你现在应该已经理解了React Native是如何工作的，以及如何在大规模项目中使用它来构建适用于多个平台的高性能应用，这可以帮助你节省时间和金钱。
