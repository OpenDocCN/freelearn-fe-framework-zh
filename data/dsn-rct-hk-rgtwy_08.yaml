- en: '*Chapter 8*: Use Ref to Hide Stuff'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：使用Ref隐藏内容'
- en: In the previous chapter, we learned how the *React* context is designed and
    how to use a `useContext` hook to make an update for an area. In this chapter,
    we will introduce another *React* entity, a ref. We will learn how to access a
    *DOM* element via a ref and walk through the design and source code behind the
    `useRef` hook. We will also describe how to work with a persistent value without
    dispatching an update. In the end, we'll apply refs to a couple of practical problems,
    such as clicking outside of the menu, avoiding memory leaks, setting up a mule,
    and locating the current value. And we'll also reveal two bonus topics in the
    *Appendix* section, the callback ref and forward ref.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了*React*上下文的设计以及如何使用`useContext`钩子来更新一个区域。在本章中，我们将介绍另一个*React*实体，即ref。我们将学习如何通过ref访问*DOM*元素，并探讨`useRef`钩子背后的设计和源代码。我们还将描述如何在不触发更新的情况下与持久值一起工作。最后，我们将把refs应用到一些实际问题中，例如点击菜单外部、避免内存泄漏、设置中继和定位当前值。我们还会在*附录*部分揭示两个额外主题，即回调ref和forward
    ref。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Accessing *DOM* elements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问*DOM*元素
- en: Understanding `useRef` design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`useRef`设计
- en: State without an update
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未更新状态
- en: Test driving `useRef`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`useRef`
- en: '`useRef` examples'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useRef`示例'
- en: Questions and answers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问答环节
- en: Appendix
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录
- en: Accessing DOM elements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问DOM元素
- en: 'Before a modern *UI* framework is introduced, to make a change to the screen,
    we work directly with a *DOM* element:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代*UI*框架引入之前，为了改变屏幕，我们直接与*DOM*元素工作：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding *HTML* file defines an `h1` element tagged with a specific `id`
    value. So we can use the `id` value to find the `el` element and make a change
    to its `textContent`. This is how a *DOM* element gets updated:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的*HTML*文件定义了一个带有特定`id`值的`h1`元素。因此，我们可以使用`id`值来找到`el`元素并更改其`textContent`。这就是*DOM*元素更新的方式：
- en: '![Figure 8.1 – HTML displaying the Hello World title'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.1 – HTML displaying the Hello World title'
- en: '](img/Figure_8.01_B17963.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.01_B17963.jpg](img/Figure_8.01_B17963.jpg)'
- en: Figure 8.1 – HTML displaying the Hello World title
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 显示Hello World标题的HTML
- en: 'With React, we can achieve the preceding functionality by wrapping elements
    in a component, such as a function component:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React，我们可以通过将元素包裹在组件中来实现前面的功能，例如函数组件：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The benefits of using the preceding functional approach are that it provides
    an abstraction on top of the physical *DOM* and allows us to focus our development
    in a localized space. This way, we can safely put our logic and design without
    worrying that other code might accidentally touch this space. It makes our development
    more productive.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面提到的函数式方法的好处是，它提供了一个在物理*DOM*之上的抽象，并允许我们专注于局部开发空间。这样，我们可以安全地放置我们的逻辑和设计，而不必担心其他代码可能会意外地触摸这个空间。这使得我们的开发更加高效。
- en: 'This is a good thing, and here''s a question. Can we still get hold of the
    *DOM* element using `id` as it used to be? Because the job of *React* isn''t to
    reinvent all *DOM* functionalities, and sometimes we do need to work with the
    elements directly:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件好事，这里有一个问题。我们是否还能像以前一样使用`id`来获取*DOM*元素？因为*React*的工作并不是重新发明所有的*DOM*功能，有时我们确实需要直接与元素工作：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we add `id` to the `h1` element. But we run into some
    problems quickly. First, the `Title` component is made to be reused. This means
    we can have multiple `<Title />` instances on the current screen. Suppose we want
    to operate on one of them – how do know which instance to find by using `id`?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们给`h1`元素添加了`id`。但很快我们就遇到了一些问题。首先，`Title`组件被设计成可重用的。这意味着我们可以在当前屏幕上拥有多个`<Title
    />`实例。假设我们想要操作其中一个——我们如何通过`id`知道要找到哪个实例？
- en: Secondly, and more importantly, say we find the element we want. Since it's
    wrapped in a component now, *React* manages its life cycle, so how do we know
    the moment when it gets mounted and unmounted precisely? If we're not sure about
    this, how can we safely operate on it?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，更重要的是，假设我们找到了我们想要的元素。由于它现在被包裹在组件中，*React*管理其生命周期，那么我们如何精确地知道它在何时挂载和卸载？如果我们不确定这一点，我们如何安全地操作它？
- en: Both problems are tricky but need to be addressed before we can directly work
    with an element under a component. Let's see how *React* solves them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题都很棘手，但在我们能够直接在组件下操作元素之前，我们需要解决这些问题。让我们看看*React*是如何解决它们的。
- en: Attach and de-attach
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接和断开连接
- en: 'So, when exactly does the element in a component mount and unmount? To answer
    this question, we need to first look at the element returned from a component
    closely:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，组件中的元素何时挂载和卸载呢？要回答这个问题，我们首先需要仔细查看从组件返回的元素：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What does the preceding statement return? Is it a *DOM* element, as we put
    in the *HTML* file? Though it looks quite like one, the compiler says otherwise:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句返回了什么？它是一个 *DOM* 元素，就像我们在 *HTML* 文件中放入的那样吗？虽然看起来很像，但编译器却给出了不同的说法：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Actually, what the compiler sees is a *JavaScript* statement with a `createElement`
    function returning a *React* element. It takes three input arguments, the element
    type (`h1`), the props (`null`), and the children (`title`), and the returned
    element is commonly referred to as a virtual *DOM*. If you are interested in learning
    more about `createElement` usage, check out the *Adopting CSS-in-JS approach*
    section of [*Chapter 10*](B17963_10_Epub.xhtml#_idTextAnchor363), *Building a
    Website with React*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，编译器看到的是一个带有 `createElement` 函数的 *JavaScript* 语句，它返回一个 *React* 元素。它接受三个输入参数，元素类型（`h1`），属性（`null`），和子元素（`title`），返回的元素通常被称为虚拟
    *DOM*。如果您想了解更多关于 `createElement` 的使用方法，请查看 [*第10章*](B17963_10_Epub.xhtml#_idTextAnchor363)
    的 *Adopting CSS-in-JS approach* 部分，*Building a Website with React*。
- en: When the first update starts, *React* takes this element, reconciles it into
    a fiber, and appends it to the tree. It then moves on to its children. For all
    child elements, it reconciles them and appends them as children fibers. This continues
    until all elements are reconciled into the tree.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次更新开始时，*React* 会取这个元素，将其与纤维进行协调，并将其附加到树上。然后它继续处理其子元素。对于所有子元素，它将它们协调并作为子纤维附加。这个过程会一直持续到所有元素都被协调到树中。
- en: 'After all the fibers are prepared, *React* performs a one-time commit to create
    all *DOM* elements on the screen. So, essentially, the physical *DOM* elements
    aren''t created until the full tree is updated in memory. So, only by then, *React*
    hands us the element instance if we ask for it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有纤维都准备就绪后，*React* 执行一次提交操作，在屏幕上创建所有 *DOM* 元素。所以，本质上，物理 *DOM* 元素直到整个树在内存中更新完毕才被创建。因此，只有到那时，*React*
    才会根据我们的请求提供元素实例：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, a `ref` object is passed to the `h1` element as a prop
    and it behaves as a storage container, asking *React* to store the element instance
    once available. This `ref` container takes a specific format:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，一个 `ref` 对象被作为属性传递给 `h1` 元素，并作为一个存储容器，要求 *React* 一旦可用就存储元素实例。这个 `ref`
    容器采用特定的格式：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the instance of the *DOM* element is created, the preceding `ref` is
    populated in the `commitAttachRef` function during the **Commit** phase:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *DOM* 元素实例创建后，前面的 `ref` 在 **提交** 阶段的 `commitAttachRef` 函数中被填充：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding `commitAttachRef` function, when `ref` is provided and initialized,
    its `current` property gets assigned from the *DOM* instance. This is for the
    mount. Similarly, when the *DOM* element is about to be removed, `current` gets
    assigned back to `null` in the `commitDetachRef` function during the **Commit**
    phase:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `commitAttachRef` 函数中，当 `ref` 被提供并初始化时，其 `current` 属性从 *DOM* 实例中分配。这是为了挂载。同样，当
    *DOM* 元素即将被移除时，`current` 在 **提交** 阶段的 `commitDetachRef` 函数中重新分配回 `null`：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this capability, as long as we provide `ref` to an element, React assigns
    the element's instance into `ref.current` upon the mount and unmount. We can use
    `ref.current` to work on the element as it used to be. This is the *React* way
    of accessing *DOM* elements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个功能，只要我们提供一个指向元素的 `ref`，React 就会在挂载和卸载时将元素的实例分配给 `ref.current`。我们可以使用 `ref.current`
    来处理元素，就像它过去一样。这是 *React* 访问 *DOM* 元素的 *React* 方式。
- en: There's a subtlety here. Note that when passing the element's instance over
    when it's ready, the assignment is done with `ref.current = instance` instead
    of `ref = instance`. This is because *React* designs `ref` as a container to be
    available during the life cycle of the component. Put simply, the container is
    always valid, whereas the value under the `current` property can change along
    the way.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个细微之处。请注意，当元素准备好时传递元素实例时，赋值是通过 `ref.current = instance` 而不是 `ref = instance`
    来完成的。这是因为 *React* 将 `ref` 设计为一个在组件生命周期中可用的容器。简单来说，容器始终有效，而 `current` 属性下的值可能会在过程中发生变化。
- en: The `ref` prop we used so far is a ref in an object format, which is the most
    popular and easy-to-use format. Other than this, *React* supports one more format
    in other situations. If you are interested, you can check out *Appendix A – Callback
    ref* at the end of this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止使用的 `ref` 属性是一个对象格式的 ref，这是最流行且易于使用的格式。除此之外，*React* 在其他情况下还支持一种其他格式。如果你感兴趣，可以查看本章末尾的
    *附录 A – 回调 ref*。
- en: Now we know what a *React* ref is, let's take a look at how to create one under
    a function component with a `useRef` hook.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了什么是 *React* ref，让我们看看如何在函数组件中使用 `useRef` 钩子创建一个。
- en: Understanding useRef design
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 useRef 设计
- en: '*React* provides a `useRef` hook to create a ref:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*React* 提供了一个 `useRef` 钩子来创建 ref：'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `useRef` hook takes an initial value as its only input argument and returns
    a `ref` object, putting that initial value under the `current` property.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef` 钩子只接受一个初始值作为其唯一的输入参数，并返回一个 `ref` 对象，将初始值放在 `current` 属性下。'
- en: 'There''s no additional data structure required for `useRef`, other than the
    basic fiber hook support:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的 fiber 钩子支持之外，不需要额外的数据结构用于 `useRef`：
- en: '![Figure 8.2 – useRef design'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – useRef 设计](img/Figure_8.02_B17963.jpg)'
- en: '](img/Figure_8.02_B17963.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.02_B17963.jpg](img/Figure_8.02_B17963.jpg)'
- en: Figure 8.2 – useRef design
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – useRef 设计
- en: Just like `useState` and `useEffect` uses `state` to store state and the effect,
    `useRef` uses `state` to store the ref. Next, let's take a look at how it's implemented.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `useState` 和 `useEffect` 使用 `state` 来存储状态和副作用一样，`useRef` 使用 `state` 来存储 ref。接下来，让我们看看它是如何实现的。
- en: 'The `useRef` hook follows a typical hook setup where it takes a path of either
    `mountRef` or `updateRef`, depending on whether the fiber is under mount or update
    via the `isFiberMounting` flag, as explained in [*Chapter 3*](B17963_03_Epub.xhtml#_idTextAnchor080),
    *Hooking into React*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef` 钩子遵循典型的钩子设置，它根据 `isFiberMounting` 标志是否表示纤维正在挂载或通过更新进行，选择 `mountRef`
    或 `updateRef` 的路径，如 [第 3 章](B17963_03_Epub.xhtml#_idTextAnchor080) 中所述，*Hooking
    into React*：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When under mount, it first gets the hook by creating one:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载期间，它首先通过创建一个来获取钩子：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Before returning the `ref` object, the initial value is stored under the `current`
    property and `ref` is stored under `state` of the hook.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回 `ref` 对象之前，初始值被存储在 `current` 属性下，而 `ref` 被存储在钩子的 `state` 中。
- en: 'After the component is mounted, the next time it gets updated and arrives at
    the `useRef` hook, it gets the hook by cloning one:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 组件挂载后，下次它被更新并到达 `useRef` 钩子时，它会通过克隆一个来获取钩子：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once we have the hook, we can get `ref` from `state` and return it. Also, note
    that the hook doesn't accept any input argument after the mount.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了钩子，我们就可以从 `state` 中获取 `ref` 并返回它。此外，请注意，钩子在挂载后不接受任何输入参数。
- en: 'By far, this is the shortest hook implementation we have seen. The following
    diagram shows the workflow:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这是我们见过的最短的钩子实现。以下图表显示了工作流程：
- en: '![Figure 8.3 – useRef workflow'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – useRef 工作流程](img/Figure_8.3_B17963.jpg)'
- en: '](img/Figure_8.03_B17963.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.03_B17963.jpg](img/Figure_8.03_B17963.jpg)'
- en: Figure 8.3 – useRef workflow
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – useRef 工作流程
- en: In short, the `useRef` hook provides the basic storage for persisting a ref.
    A `ref` stored in the hook never gets updated after the mount where the `current`
    value is initialized. Basically, the `useRef` hook essentially lets us manage
    the state out of the box.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`useRef` 钩子提供了持久化 ref 的基本存储。存储在钩子中的 ref 在挂载后永远不会更新，其中 `current` 值被初始化。基本上，`useRef`
    钩子本质上让我们能够开箱即用地管理状态。
- en: If `ref` is wired as a prop to an element, when the element gets mounted or
    unmounted, its *DOM* instance gets updated in the `current` property.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `ref` 被连接为一个元素的属性，当元素挂载或卸载时，其 *DOM* 实例会在 `current` 属性中更新。
- en: Now we know the design of the `useRef` hook. If the ref created is used to hold
    a value, how is it different from the `useState` hook? Since they both can hold
    a value, let's spend some time comparing them to understand more about the `useRef`
    hook.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 `useRef` 钩子的设计。如果创建的 ref 用于持有值，它与 `useState` 钩子有何不同？由于它们都可以持有值，让我们花些时间比较它们，以更好地了解
    `useRef` 钩子。
- en: State without an update
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无更新的状态
- en: 'The `ref` created via `useRef` can be used to hold not only a DOM instance
    but also any value. At any time, we can change its `current` property with a new
    assignment:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `useRef` 创建的 ref 可以用来持有不仅仅是 DOM 实例，还可以是任何值。在任何时候，我们都可以通过新的赋值来更改它的 `current`
    属性：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The assignment can be a *JavaScript* expression. What''s special about this
    is that *the ref assignment doesn''t do anything more than an assignment*. This
    implies that it does not trigger an update. Let''s take a look at how it impacts
    the UI when we wire it to a user action:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值可以是一个*JavaScript*表达式。特别之处在于，*引用赋值除了赋值之外不做任何其他事情*。这意味着它不会触发更新。让我们看看当我们将它连接到用户操作时，它对UI的影响：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, an event handler is wired with the `Child` component,
    and when the user clicks, it assigns a color into `ref.current`. It looks pretty
    similar to the case using a `useState` hook. If we were using a `useState` hook,
    the code would look like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，一个事件处理器被连接到`Child`组件上，当用户点击时，它将一个颜色赋值给`ref.current`。这看起来与使用`useState`钩子的情况非常相似。如果我们使用`useState`钩子，代码将如下所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When comparing these two cases, we can see that the main difference is the
    following line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较这两个案例时，我们可以看到主要的不同之处在于以下这一行：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the ref case, it is a plain assignment, whereas in the state case, it dispatches
    an update to schedule the state change. This means that the state case is a lot
    more complicated than the ref case. We can even simulate the ref case with a state:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用的情况下，它是一个简单的赋值，而在状态的情况下，它调度了一个更新来安排状态变化。这意味着状态情况比引用情况要复杂得多。我们甚至可以用状态来模拟引用情况：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding experiment, we made the state an `obj` with a `color` property.
    And this `obj` is quite comparable to `ref` from `useRef`, because `obj.color
    =` is also a plain assignment:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实验中，我们使状态成为一个具有`color`属性的`obj`。这个`obj`与`useRef`中的`ref`相当相似，因为`obj.color
    =`也是一个简单的赋值：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You might wonder, for plain assignments, what happens to the `color` prop wired
    with either `ref` or `obj`? Interestingly, in both cases, nothing happens. Because
    with a plain assignment, there's no dispatch to the `Title` component, thus there
    isn't any update to the `Child` component. Therefore, even though the content
    gets changed, *React* wouldn't respond to that.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，对于普通的赋值，与`ref`或`obj`连接的`color`属性会发生什么？有趣的是，在这两种情况下，都没有发生任何事情。因为对于普通的赋值，没有向`Title`组件发送任何消息，因此没有对`Child`组件进行更新。因此，即使内容发生了变化，*React*也不会对此做出响应。
- en: So, essentially, a ref can be taken to hold a value without the update capability.
    This also explains why the source code of `useRef` is so compact, because it doesn't
    do much other than returning a persistent value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本质上，一个引用（ref）可以用来存储一个值，但没有更新能力。这也解释了为什么`useRef`的源代码如此紧凑，因为它除了返回一个持久值之外，没有做太多其他的事情。
- en: Now that we've gone over the design of a ref and the `useRef` hook, let's take
    it for a test drive.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了引用（ref）和`useRef`钩子的设计，让我们来实际测试一下。
- en: Test driving useRef
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动`useRef`
- en: 'There''s always a chance that *React* runs short in terms of controlling the
    internals of a *DOM* element. Say there''s an input and a button, as in *Figure
    8.4*. Upon a button click, we want to manually focus on the input:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有可能*React*在控制*DOM*元素内部方面显得力不从心。比如说，有一个输入框和一个按钮，如图8.4所示。当按钮被点击时，我们希望手动将焦点放在输入框上：
- en: '![Figure 8.4 – Focus input'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.4 – 焦点输入'
- en: '](img/Figure_8.04_B17963.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.04_B17963.jpg]'
- en: Figure 8.4 – Focus input
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 焦点输入
- en: Normally, if we click the button, it gets focused, and if we click somewhere
    else, it loses focus. But in this case, after we click the **Focus** button, we
    want to focus the input instead of the button so that the user can type right
    away.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果我们点击按钮，它会获得焦点，如果我们点击其他地方，它会失去焦点。但在这个例子中，在我们点击**焦点**按钮之后，我们希望将焦点放在输入框上而不是按钮上，这样用户就可以立即开始输入。
- en: 'Let''s see how we can apply `useRef` to make this happen:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何应用`useRef`来实现这一点：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, after `input` is mounted, its instance is stored in
    `ref.current`. When we click the button, the event handler uses the ref to invoke
    a native *DOM* `focus` method to make the input focused. That's it!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当`input`被挂载后，它的实例被存储在`ref.current`中。当我们点击按钮时，事件处理器使用引用来调用原生的*DOM* `focus`方法，使输入框获得焦点。就是这样！
- en: 'Though the `ref` object is always valid, the `current` property is not necessarily
    valid all the time. Before the mount finishes, it can store a `null` value. After
    the unmount, it can store a `null` value as well. So, to make sure that we don''t
    run into any runtime error, we normally add a check before using it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然引用对象始终是有效的，但`current`属性并不总是有效的。在挂载完成之前，它可以存储一个`null`值。在卸载之后，它也可以存储一个`null`值。因此，为了确保我们不遇到任何运行时错误，我们通常在使用它之前添加一个检查：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Sometimes, you see the following short-circuit way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你会看到以下短路方式：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It''s important to note that, although we get to use `ref` to control the *DOM*
    element, React wouldn''t know the impact of your code. For instance, in our example,
    *React* can''t tell whether the input gets focused or not. In order for React
    to know that, we still need to add a state to keep track of this change:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，尽管我们可以使用`ref`来控制*DOM*元素，但React不会知道你代码的影响。例如，在我们的例子中，*React*无法判断输入是否被聚焦。为了使React知道这一点，我们仍然需要添加一个状态来跟踪这种变化：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In a way, getting hold of the raw DOM elements gives us the extra capability
    to manipulate the element behind React's back.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，获取原始DOM元素使我们能够绕过React来操作元素。
- en: Playground – Focusing Input
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 聚焦输入
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/WNZwoje](https://codepen.io/windmaomao/pen/WNZwoje)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由地在这个在线示例中玩耍：[https://codepen.io/windmaomao/pen/WNZwoje](https://codepen.io/windmaomao/pen/WNZwoje)
- en: Controlling a child ref
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制子组件引用
- en: 'Since a ref is basically an object, it can be passed around as a prop to a
    child component. Therefore, a passed-in `ref` object can be attached to a DOM
    element inside a child:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引用基本上是一个对象，它可以作为属性传递给子组件。因此，传入的`ref`对象可以附加到子组件内部的DOM元素上：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Utilizing this `childRef`, the `Child` component allows the parent to operate
    on it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个`childRef`，`Child`组件允许父组件对其操作：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, the `Title` component creates a `ref` object via `useRef`
    and passes it to `Child` via a `childRef` prop. When `Child` mounts, it populates
    the `input` instance into `ref.current`. And when we click on the button, it invokes
    the `focus` method of the input element of `Child`. This allows a parent component
    to control a *DOM* element of `Child`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Title`组件通过`useRef`创建了一个`ref`对象，并通过`childRef`属性将其传递给`Child`。当`Child`挂载时，它将`input`实例填充到`ref.current`中。当我们点击按钮时，它调用`Child`输入元素的`focus`方法。这允许父组件控制`Child`的*DOM*元素。
- en: 'Note that the prop we used is named `childRef` instead of `ref` because `ref`
    is a reserved prop name to attach a *DOM* instance, whereas `childRef` is merely
    a regular prop to pass in an object. Although both are props, the `ref` prop is
    a special one. It would be wrong if we mistakenly used `ref` instead of `childRef`
    in this example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的属性名为`childRef`而不是`ref`，因为`ref`是一个保留的属性名，用于附加*DOM*实例，而`childRef`只是一个普通的属性，用于传递一个对象。尽管两者都是属性，但`ref`属性是特殊的。如果我们在这个例子中错误地使用了`ref`而不是`childRef`，那就错了：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding line would ask the `Child` function component to assign its instance
    to `ref`. But a function component cannot have a ref by default. Therefore, avoid
    using the ref name when passing it around. There's actually a way to attach a
    ref to a function component with some work; if you are interested, you can find
    out more in the *Appendix B – Forward ref* section at the end of this chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行会要求`Child`函数组件将其实例分配给`ref`。但是，函数组件默认情况下没有引用。因此，在传递时避免使用引用名称。实际上，有一种方法可以将引用附加到函数组件上，如果你感兴趣，你可以在本章末尾的*附录B
    – 传递引用*部分找到更多信息。
- en: Now that we have used a ref to control the element in the component, let's take
    a look at more examples of using `useRef`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用引用来控制组件中的元素，让我们看看更多使用`useRef`的例子。
- en: useRef examples
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useRef`示例'
- en: A ref is powerful. Because *React* makes things very reactive, if we want to
    either disable this reactiveness or add a tweak to it, the ref gives us the opportunity
    to do that. In this section, we'll look into more examples of how it can be used
    to solve interesting problems in *React*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 引用非常强大。因为*React*使事物非常具有反应性，如果我们想禁用这种反应性或对其进行调整，引用就给我们提供了这样做的机会。在本节中，我们将探讨更多如何使用它来解决*React*中有趣问题的例子。
- en: Clicking outside the menu
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点击菜单外部
- en: 'Say you have a component, and you want to know when the user clicks outside
    of it. This is a very popular feature for a popup menu or a modal. Once the menu
    is visible, we want to dismiss it when the user clicks anywhere outside of it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个组件，并且你想知道当用户点击组件外部时。这是一个非常受欢迎的弹出菜单或模态窗口的功能。一旦菜单可见，我们希望在用户点击任何外部位置时将其关闭：
- en: '![Figure 8.5 – Click outside to dismiss'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 – 点击外部关闭'
- en: '](img/Figure_8.05_B17963.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.05_B17963.jpg)'
- en: Figure 8.5 – Click outside to dismiss
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 点击外部关闭
- en: 'Let''s say we have a `Menu` component displaying a list of menu items:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个显示菜单项列表的`Menu`组件：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, an `on` state is created and set to `true` initially,
    thus making a list of the menu items visible. But when we click outside of this
    list, we'd want to set `on` to `false` to hide it. For simplicity, here we define
    the `on` flag inside the `Menu` component, but in practice, it could be passed
    from the parent as a prop.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，创建了一个 `on` 状态并将其初始值设置为 `true`，从而使菜单项可见。但当我们点击列表外部时，我们希望将 `on` 设置为 `false`
    来隐藏它。为了简单起见，这里我们在 `Menu` 组件内部定义了 `on` 标志，但在实际应用中，它可能作为属性从父组件传递过来。
- en: We know how to find out when the user clicks the `Menu` component using an event
    handler, but how do we know when the user clicks somewhere outside? Do we need
    to know the location of all the components on the entire screen?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何使用事件处理器找出用户何时点击了 `Menu` 组件，但我们如何知道用户何时点击了屏幕外的某个地方？我们需要知道整个屏幕上所有组件的位置吗？
- en: 'This is the place we can attach a `ref` to the `ul` element:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以将引用（ref）附加到 `ul` 元素上的地方：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Instead of attaching the click event handler to one element, we can listen
    to a `mousedown` window event. This way, we are aware of any user click, regardless
    of whether it''s inside or outside the `Menu` component:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以监听一个 `mousedown` 窗口事件，而不是将点击事件处理器附加到一个元素上。这样，我们就能意识到任何用户点击，无论它是在 `Menu`
    组件内部还是外部：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, we registered an event handler for a `mousedown` window
    event, so with any mouse click, it'll invoke our `listener` function. Upon the
    unmount, we also make sure that we remove this event handler via a `destroy` function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为 `mousedown` 窗口事件注册了一个事件处理器，因此任何鼠标点击都会调用我们的 `listener` 函数。在卸载时，我们也确保通过一个
    `destroy` 函数移除这个事件处理器。
- en: 'When the `mousedown` handler is fired, we can use `ref` to find out whether
    the mouse location is contained inside the boundary of the `ul` element:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `mousedown` 处理器被触发时，我们可以使用 `ref` 来找出鼠标位置是否包含在 `ul` 元素的边界内：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding `listener` handler, upon each `mousedown` event, we check whether
    the element has been mounted via `ref.current`, and then we check whether the
    element under the mouse, via `e.target`, is a child of the `ul` element. If the
    user clicks any children inside the `ul`, then we know they have clicked inside.
    And if not, we know the user has clicked outside, and then we can dispatch to
    set the `on` state to be `false`, thus dismissing the display of the menu.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `listener` 处理程序中，每次 `mousedown` 事件发生时，我们通过 `ref.current` 检查元素是否已经挂载，然后通过
    `e.target` 检查鼠标下的元素是否是 `ul` 元素的子元素。如果用户点击 `ul` 内的任何子元素，那么我们知道他们点击了内部。如果没有，我们知道用户点击了外部，然后我们可以分派以将
    `on` 状态设置为 `false`，从而关闭菜单的显示。
- en: Playground – Click Outside of Menu
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 点击菜单外部
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/XWaerGm](https://codepen.io/windmaomao/pen/XWaerGm).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎免费尝试这个在线示例：[https://codepen.io/windmaomao/pen/XWaerGm](https://codepen.io/windmaomao/pen/XWaerGm)。
- en: In short, with the help of the ref, we can invoke `contains` functions to find
    out whether an element is inside another element.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，借助引用（ref），我们可以调用 `contains` 函数来找出一个元素是否在另一个元素内部。
- en: Avoiding memory leaks
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免内存泄漏
- en: Historically speaking, a ref was created to hold a DOM element, but people later
    found it very effective in addressing tricky problems. One problem is memory leaks,
    which happen when performing an async action. The thing about an async operation
    is that the callback function gets invoked later. By the time the callback is
    handled, there's a chance the component (or any variable associated with the component)
    is not valid anymore.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史的角度来看，引用（ref）最初是用来持有 DOM 元素的，但后来人们发现它在解决棘手问题方面非常有效。一个问题就是内存泄漏，它发生在执行异步操作时。关于异步操作，回调函数会在稍后调用。当回调被处理时，组件（或与组件相关的任何变量）可能已经不再有效。
- en: 'Let''s say we fetch an API and display the result as `text`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们获取一个 API 并将结果显示为 `text`：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code is a common fetch process, but there''s a memory leak lurking
    out there. When it happens, the browser outputs the following message:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一个常见的获取过程，但其中隐藏着一个内存泄漏。当它发生时，浏览器会输出以下信息：
- en: '![Figure 8.6 – Memory leak warning message'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 内存泄漏警告信息'
- en: '](img/Figure_8.06_B17963.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.06_B17963.jpg)'
- en: Figure 8.6 – Memory leak warning message
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 内存泄漏警告信息
- en: Although *React* is nice enough to display it as a warning message under development
    build, it's actually an error, as it says **indicates a memory leak** in the message.
    The strange thing about this leak is that most of time, the *UI* continues to
    function even after the message. So, shall we ignore this message? Absolutely
    not.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在开发构建中，*React*足够友好地将其显示为警告信息，但实际上这是一个错误，因为它在信息中提到**表明存在内存泄漏**。这个泄漏的奇怪之处在于，大多数时候，即使在消息出现后，*UI*仍然可以继续工作。那么，我们应该忽略这个消息吗？绝对不行。
- en: 'Let''s build the crime scene and try to understand what exactly happens under
    this message:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建犯罪现场，并尝试理解在这个消息下到底发生了什么：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Say you have an `App` parent component that displays `Title` based on a `flag`.
    For one update, the `flag` becomes `false`, thus `Title` gets unmounted and the
    screen turns blank. This is valid business logic, so why is it a problem?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个`App`父组件，它根据`flag`显示`Title`。对于一次更新，`flag`变为`false`，因此`Title`被卸载，屏幕变空白。这是有效的业务逻辑，那么为什么它是个问题呢？
- en: The problem lies inside the `Title` component instead of `App`. Precisely, when
    `Title` mounts, the *API* fetch starts, but the fetch might not finish soon enough
    before the unmount. The `flag` and the fetch are two independent things. Therefore,
    `Title` can have unfinished business after the unmount. Say the time arrives to
    handle the unfinished business, such as the callback function – what happens to
    the `setText` statement? Should it raise another update when the component has
    gone?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在`Title`组件内部，而不是`App`组件。确切地说，当`Title`组件挂载时，API获取开始，但获取可能不会在卸载之前很快完成。`flag`和获取是两件独立的事情。因此，`Title`组件在卸载后可能会有未完成的事务。比如说，到了处理未完成事务的时间，比如回调函数——`setText`语句会发生什么？当组件已经消失时，它应该引发另一个更新吗？
- en: Technically, if the component is unmounted, it can't be updated anymore. Moreover,
    every hook is registered under the fiber, and if the fiber has been removed, then
    nothing registered under it should be accessed anymore. Otherwise, inconsistency
    would emerge, such as a memory leak.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上讲，如果组件被卸载，它就不再可以被更新了。此外，每个钩子都在纤维下注册，如果纤维被移除，那么其下注册的任何内容都不应该再被访问。否则，会出现不一致的情况，例如内存泄漏。
- en: So back to our case, when an async call returns after the unmount – this becomes
    a solid bug that we can't just ignore. This bug happens quite often in situations
    when a conditional statement makes the code to switch to another branch of update,
    such as a route switch. Most of the memory leaks are difficult to debug, so we
    should try to avoid them at all costs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所以回到我们的案例，当一个异步调用在卸载后返回——这成为一个我们不能忽视的明确错误。这个错误在代码切换到另一个更新分支的情况中很常见，比如路由切换。大多数内存泄漏都很难调试，所以我们应不惜一切代价避免它们。
- en: Playground – Memory Leak
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 - 内存泄漏
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/VwzMYNL](https://codepen.io/windmaomao/pen/VwzMYNL).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎您在这个在线示例[https://codepen.io/windmaomao/pen/VwzMYNL](https://codepen.io/windmaomao/pen/VwzMYNL)中尝试。
- en: In order to see the memory leak message, you need to open the **Browser developer**
    panel and switch to the **Console** tab.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看内存泄漏信息，您需要打开**浏览器开发者**面板并切换到**控制台**标签页。
- en: 'To resolve this bug, what we need to do is to carefully guard the content of
    the callback function, based on whether the `Title` component is still mounted
    or not:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要做的事情是，根据`Title`组件是否仍然挂载，仔细保护回调函数的内容：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we add `mountedRef` to indicate whether `Title` is mounted
    or not. We initially set it to `true`, because when the component gets updated,
    we assume it's safe to dispatch more updates. And after the unmount via `useEffect`,
    we set the `mountedRef` flag to be `false` in the `destroy` function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了`mountedRef`来指示`Title`是否挂载。我们最初将其设置为`true`，因为当组件被更新时，我们假设可以安全地分派更多更新。在通过`useEffect`卸载后，我们在`destroy`函数中将`mountedRef`标志设置为`false`。
- en: Now, in the callback handler of the fetch, we check if it's still mounted by
    reading `mountedRef`. And if it's `false`, we cancel the handler operation without
    moving forward to access any internal method, such as `setText`. This means even
    when the *API* is successful, there's no update to bring this value to the screen
    anymore.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在获取的回调处理程序中，我们通过读取`mountedRef`来检查它是否仍然挂载。如果它是`false`，我们取消处理程序操作，而不前进到访问任何内部方法，比如`setText`。这意味着即使*API*成功，也不会有更新将这个值带到屏幕上。
- en: Playground – Avoid Memory Leaks
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 - 避免内存泄漏
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/wvqraKP](https://codepen.io/windmaomao/pen/wvqraKP).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎尝试这个在线示例：[https://codepen.io/windmaomao/pen/wvqraKP](https://codepen.io/windmaomao/pen/wvqraKP)。
- en: 'You might wonder why we can''t use a state instead of a ref for the `mountRef`
    purpose. Let''s say we replace `mountRef` with a `mounted` state:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们不能用状态而不是引用（ref）来为`mountRef`目的。让我们假设我们用`mounted`状态替换`mountRef`：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Although creative, the preceding code wouldn't work. Because, essentially, you
    ask to dispatch a new update after the unmount, it's the exact memory leak we
    want to avoid. In [*Chapter 5*](B17963_05_Epub.xhtml#_idTextAnchor157), *Use Effect
    to Handle Side Effects*, we learned that the `destroy` function of a passive effect
    is last called after all DOM elements settle, so by then, we shouldn't be allowed
    to access any internal method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然很有创意，但前面的代码不会工作。因为本质上，你在卸载后要求分发一个新的更新，这正是我们想要避免的内存泄漏。在[*第5章*](B17963_05_Epub.xhtml#_idTextAnchor157)，“使用Effect处理副作用”中，我们学习了被动效果的`destroy`函数是在所有DOM元素稳定后最后被调用的，所以到那时，我们不应该被允许访问任何内部方法。
- en: This example also tells us that a change from a ref is not meant to be reflected
    in the UI, whereas a state is designed to be in sync with the UI at all times.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也告诉我们，从引用（ref）的变化不应该反映在用户界面（UI）中，而状态（state）的设计是为了始终与UI保持同步。
- en: Setting up a mule
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置骡子
- en: When we design a web application, we tend not to have a global variable, because
    we know it's so easy that their usage can lead to some unmanageable side effects.
    On the other hand, if we have some global information that is valid for the entire
    site, it's still handy if we want to share it with the rest of the app behind
    the scenes. So, what kind of compromise can we have in this situation?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计一个Web应用程序时，我们往往不使用全局变量，因为我们知道它们的用法很容易导致一些难以管理的副作用。另一方面，如果我们有一些对整个站点都有效的全局信息，如果我们想在幕后与整个应用程序的其他部分共享它，那么这仍然很方便。那么，在这种情况下，我们可以有什么妥协呢？
- en: 'In [*Chapter 7*](B17963_07_Epub.xhtml#_idTextAnchor237), *Use Context to Cover
    an Area*, we learned to create a context to share info for a site. We can provide
    the info at the very top of the tree, the `App` component:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B17963_07_Epub.xhtml#_idTextAnchor237)，“使用上下文覆盖区域”，我们学习了如何创建上下文以共享站点的信息。我们可以在树的顶部提供信息，即`App`组件：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A fact of using the state in the preceding code is that, when changing a value
    through the `setValue` dispatch function, it causes the whole site to update,
    which can be a very expensive operation. If we don''t need to notify the user
    of this change, we can use a ref instead:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中使用状态的一个事实是，通过`setValue`分发函数更改值会导致整个站点更新，这可能是一个非常昂贵的操作。如果我们不需要通知用户这个更改，我们可以使用引用（ref）来代替：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, a ref is created with `useRef` to hold a custom `count`
    value under the `current` property. We can increment it as used to be with a button
    click via `onIncrement`. We also add a `Title` component underneath to consume
    this `count` value:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用`useRef`创建了一个引用（ref），用于在`current`属性下持有自定义的`count`值。我们可以通过`onIncrement`点击按钮来增加它。我们还添加了一个`Title`组件来消费这个`count`值：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding `Title` component, it consumes `current` from `AppContext`,
    and displays the stored `count` value. With this setup, if you click `onIncrement`
    in the `App` component, the `number` value always stays at `0`. It seems our `count`
    is broken.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`Title`组件中，它从`AppContext`中消费`current`，并显示存储的`count`值。在这种设置下，如果你在`App`组件中点击`onIncrement`，`number`值始终保持在`0`。看起来我们的`count`出了问题。
- en: 'To reveal what''s happened, let''s add a manual update to the `Title` component
    with a button:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了揭示发生了什么，让我们在`Title`组件中添加一个带有按钮的手动更新：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding code, we put the `count` value into a local `number` state,
    so we can use `setNumber` to make an update. Now, upon clicking `number` via `onClick`,
    you will see the latest `current.count` value on the screen, as shown in *Figure
    8.7*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`count`值放入一个本地的`number`状态中，这样我们就可以使用`setNumber`来进行更新。现在，当你通过`onClick`点击`number`时，你将在屏幕上看到最新的`current.count`值，如图*图8.7*所示：
- en: '![Figure 8.7 – A count state with a separate update'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – 具有单独更新的计数状态'
- en: '](img/Figure_8.07_B17963.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.07_B17963.jpg)'
- en: Figure 8.7 – A count state with a separate update
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 具有单独更新的计数状态
- en: It's a bit intriguing here to see the process of how the number got displayed
    on the screen. First, we incremented it, and then we revealed it. Therefore, `current.count`
    isn't broken; it's just not in sync with the screen.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里看到数字如何在屏幕上显示的过程有点引人入胜。首先，我们增加它，然后我们揭示它。因此，`current.count`并没有损坏；它只是没有与屏幕同步。
- en: Playground – Mule Context
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – Mule上下文
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/YzxrXQN](https://codepen.io/windmaomao/pen/YzxrXQN).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 随意在这个在线示例中玩耍：[https://codepen.io/windmaomao/pen/YzxrXQN](https://codepen.io/windmaomao/pen/YzxrXQN)。
- en: With a context like `AppContext`, we can store the value and use it freely decoupled
    from the display. In a way, the ref context becomes a mule that can move any data
    (or functionalities) from one component to another one under *React*'s nose. Practically,
    this kind of context is an effective approach when you need to bring in a third-party
    library that does not necessarily wire with *React* that tightly but that you
    want to be operational along with *React*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在像`AppContext`这样的上下文中，我们可以存储值并自由地使用它，而不与显示解耦。从某种意义上说，ref上下文变成了一个可以绕过*React*在组件之间移动任何数据（或功能）的“驮马”。实际上，当你需要引入一个第三方库，这个库不一定与*React*紧密连接，但你希望它能够与*React*一起运行时，这种上下文是一种有效的方法。
- en: Locating the current value
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位当前值
- en: The `current` property being current is the unique thing about a ref. The property
    name *current* under the ref is given for a reason because, technically, there's
    nothing more current than a ref in React.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`current`属性是ref的独特之处。ref下的`current`属性名称给出是有原因的，因为从技术上讲，在React中没有什么比ref更“当前”的了。'
- en: When we use a `useState` hook, we want to find out the current updated value
    of a state. Although we use the same word, current, the state can't be that current
    in some situations. We will use an example to demonstrate that.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`useState`钩子时，我们想知道状态的当前更新值。尽管我们使用了相同的词，但在某些情况下，状态并不一定是“当前”的。我们将通过一个例子来演示这一点。
- en: 'Let''s say we have a button to increment a count, but instead of incrementing
    it right away, it waits for 3 seconds after the click:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个按钮用来增加计数，但不是立即增加，而是在点击后等待3秒钟：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code, `setTimeout` is used in the event handler to deliberately
    delay the `setCount` function by 3 seconds. What we expect to see is that each
    click should behave like a delayed click where the `count` value increments to
    `1`, `2`, and `3` on the screen 3 seconds later.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在事件处理程序中使用了`setTimeout`来故意延迟`setCount`函数3秒钟。我们期望看到的是每次点击都应该像延迟点击一样，屏幕上的`count`值在3秒后增加到`1`、`2`和`3`。
- en: 'When we run the code, it shows differently, as shown in the next timeline:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，它显示的结果不同，如下一个时间线所示：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After we clicked the buttons three times in a row and waited for 3 seconds,
    we didn't see `count` incremented to `3` on screen. Instead, we saw it incremented
    to `1`. Quite surprising?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在连续点击按钮三次并等待3秒后，我们没有在屏幕上看到`count`增加到`3`。相反，我们看到它只增加到`1`。这很令人惊讶吗？
- en: Playground – Where is the Current Value?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 当前值在哪里？
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/ZEJXbEG](https://codepen.io/windmaomao/pen/ZEJXbEG).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 随意在这个在线示例中玩耍：[https://codepen.io/windmaomao/pen/ZEJXbEG](https://codepen.io/windmaomao/pen/ZEJXbEG)。
- en: 'How could three dispatches end up with one dispatch? Let''s debug by adding
    two more series to the timeline, the `"x"` click and the `"R"` update:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 三个分发如何最终只导致一个分发？让我们通过在时间线上添加两个更多系列来调试，即“x”点击和“R”更新：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When we clicked the button for the first time (at about `t=0.5s`), what was
    the `count` value from the event handler? It was `0`, our initial state. Then,
    when we clicked the button the second time, what was the `count` value from the
    event handler? You would say, it's got to be `1`, right, since I clicked it? But
    unfortunately, it wasn't the case.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次点击按钮（大约在`t=0.5s`时），事件处理程序中的`count`值是多少？它是`0`，我们的初始状态。然后，当我们第二次点击按钮时，事件处理程序中的`count`值是多少？你会说，它一定是`1`，对吧，因为我点击了它？但不幸的是，情况并非如此。
- en: 'Looking at the `"updated"` series, the second update didn''t arrive right away
    after the click. If there was no new update, `count` continued to hold an old
    state. Since the new update didn''t arrive until three seconds later (at about
    `t=3.5s`), during this period, any event handler would still carry the same `count`.
    Okay, that explains why the `"clicked"` series printed `0` upon each click. It
    was almost like all the three clicks performed the same dispatch statement:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到`"updated"`序列，点击后并没有立即接收到第二次更新。如果没有新的更新，`count`将继续保持旧状态。由于新的更新直到三秒后（大约在`t=3.5s`）才到达，在这段时间内，任何事件处理程序都会携带相同的`count`。好吧，这就解释了为什么在每次点击时`"clicked"`序列打印了`0`。这几乎就像是所有的三次点击都执行了相同的派发语句：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Essentially, we dispatched to request a change to `1` three times. In our case,
    all clicks happened before the second update. This created an out-of-sync moment.
    This is not a design flaw, since `count` is only designed for pointing to a copy
    in the current update. Unless it's made of a pointer pointing to the same memory
    space, it can't be pointing to the current value.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们派发了三次请求来更改`1`。在我们的案例中，所有点击都在第二次更新之前发生。这造成了一个不同步的时刻。这并不是设计缺陷，因为`count`只被设计用来指向当前更新中的一个副本。除非它是由指向相同内存空间的指针组成，否则它不能指向当前值。
- en: A common misconception is to refer to `setState` as an assignment. By now, you
    should see that it's incorrect, since it actually requests an assignment instead
    of executing the assignment. The request takes time to be handled and executed,
    and moreover, the assignment can be revoked due to optimization. The fate of this
    assignment from `setState` isn't crystal clear, whereas in the ref case, the assignment
    is plain, instant, and can't be missed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是将`setState`称为一个赋值操作。到现在为止，你应该看到这是不正确的，因为它实际上请求一个赋值而不是执行赋值。请求需要时间来处理和执行，而且，赋值可以被优化撤销。从`setState`来的这个赋值的命运并不明朗，而在引用案例中，赋值是明确、即时且不可错过的。
- en: 'Let''s apply a ref to fix this problem:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用一个引用来解决这个问题：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can confirm this via the following timeline sketch:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下时间线草图来确认这一点：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Okay, now everything works after we used a ref to store the number along with
    the `count` state. The `ref.count++` statement increments the current number and
    continues to store the updated number. Here, we used both a state and a ref to
    keep track of a single number. It's overkill, and we do it here to merely demonstrate
    the solution. In the *useCurrent hook* section of [*Chapter 9*](B17963_09_Epub.xhtml#_idTextAnchor314),
    *Use Custom Hooks to Reuse Logic*, we will refine this approach into something
    more practical.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在我们使用引用来存储数字和`count`状态后，一切工作正常。`ref.count++`语句增加了当前数字，并继续存储更新的数字。在这里，我们使用了状态和引用来跟踪一个单一的数字。这有点过度，我们在这里做这个演示只是为了展示解决方案。在[*第9章*](B17963_09_Epub.xhtml#_idTextAnchor314)的*使用自定义钩子重用逻辑*部分，*useCurrent钩子*，我们将把这个方法精炼成更实用的东西。
- en: Playground – Locate the Current Value
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 定位当前值
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/eYEGpJJ](https://codepen.io/windmaomao/pen/eYEGpJJ).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 随意在这个在线示例中玩耍：[https://codepen.io/windmaomao/pen/eYEGpJJ](https://codepen.io/windmaomao/pen/eYEGpJJ)。
- en: 'There''s a simpler solution to this problem and it doesn''t involve a ref.
    Remember, a `useState` hook supports another functional format:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题有一个更简单的解决方案，而且它不涉及引用。记住，`useState`钩子支持另一种函数式格式：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding code, a functional format setter is used so that we can read
    out the current state through `v`, because we want to know exactly what the current
    state is before committing it. The `v => v + 1` statement becomes essential, and
    sometimes we can even put some logic inside this function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用了函数式格式设置器，这样我们就可以通过`v`读取当前状态，因为我们想在提交之前确切地知道当前状态是什么。`v => v + 1`语句变得至关重要，有时我们甚至可以在这个函数内部放置一些逻辑：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It doesn't seem like the preceding location is the right place to perform other
    business logic than the value update; however, based on the `useState` design,
    this actually is the only supported location where you can read the current state
    consistently. We even returned the current `v` value back, which implies that
    we only want to get the current value but are not interested in a new update.
    You can take this as a made-up `getCount` access function for a state.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来前面的位置不是执行除了值更新之外的其他业务逻辑的正确地方；然而，根据`useState`的设计，这实际上是唯一一个你可以一致读取当前状态的位置。我们甚至返回了当前的`v`值，这意味着我们只想获取当前值，而不关心新的更新。你可以把这当作一个虚构的`getCount`访问函数来访问状态。
- en: All in all, both solutions reveal the fact that in the current update, the state
    value can get out of sync with its underlying current value.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这两种解决方案都揭示了这样一个事实：在当前的更新中，状态值可能会与其底层当前值不同步。
- en: You might have a question at this point – if a ref is that powerful and flexible,
    why don't we just use it to replace the state? The answer to this question lies
    in the dilemma that the state that *React* wants developers to use is a managed
    state that takes care of the dispatch upon any state change. However, a ref is
    a raw state with which the developers still have to manage every other aspect
    of the *UI* update. In a way, if we were using refs for everything, then we would
    not need to use *React* at all because the point of a ref is to hide stuff without
    catching the engine's attention.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能现在会有一个疑问——如果引用如此强大且灵活，为什么我们不直接用它来替换状态？这个问题的答案在于这样一个困境：*React*希望开发者使用的状态是一个受管理的状态，它在任何状态变化时都会负责分发。然而，引用是一个原始状态，开发者仍然需要管理*UI*更新的其他各个方面。从某种意义上说，如果我们用引用来做所有的事情，那么我们甚至不需要使用*React*，因为引用的目的就是隐藏东西，而不引起引擎的注意。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first learned what a *React* ref is. We then went over how
    to access a *DOM* element by using a ref and went through the design of the `useRef`
    hook, and saw how to persist a value without triggering a *UI* update. We also
    gave `useRef` a test drive by walking through an input focus example. In the end,
    we went through how special it is by showing more examples of its use, including
    clicking outside of a menu, avoiding memory leaks, setting up a mule, and locating
    the current value.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了什么是*React*引用。然后我们介绍了如何使用引用访问*DOM*元素，并探讨了`useRef`钩子的设计，以及如何持久化一个值而不触发*UI*更新。我们还通过一个输入焦点示例对`useRef`进行了测试。最后，我们通过展示更多使用示例，包括在菜单外点击、避免内存泄漏、设置中转站和定位当前值，来展示了它的特殊性。
- en: In the next chapter, we will put all the hooks we have learned so far together
    and see how to finally create your custom hook, tailored to solve your own problems.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把迄今为止学到的所有钩子放在一起，看看如何最终创建你定制的钩子，以解决你自己的问题。
- en: Questions and answers
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案
- en: 'Here are some questions and answers to refresh your knowledge:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题和答案来刷新你的知识：
- en: What is a ref?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是引用？
- en: A *React* ref is a container to hold a persistent value. In general, you can
    use the value as a raw state with no update capability.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*React*引用是一个用于持有持久值的容器。通常，你可以将值用作没有更新能力的原始状态。'
- en: What is `useRef`?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`useRef`？
- en: A `useRef` hook can be used to create a ref in a function component. Once created,
    it can be used as a persistent container during the life cycle of the component.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useRef`钩子可以在函数组件中创建一个引用。一旦创建，它就可以在组件的生命周期内用作持久容器。'
- en: What are the common usages of `useRef`?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useRef`的常见用法有哪些？'
- en: One major usage of `useRef` is to hold a *DOM* instance that can be used to
    invoke native *DOM* functionalities. Another major usage of `useRef` is to sneak
    behind React to do something without kicking off the engine accidentally.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useRef`的一个主要用途是持有可以用来调用原生*DOM*功能的*DOM*实例。另一个主要用途是绕过React做一些事情，而不会意外地启动引擎。'
- en: Appendix
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: Appendix A – Callback ref
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录A – 回调引用
- en: 'React comes with two ways of receiving an element instance via the `ref` prop.
    The easiest one is the one we introduced, the object format. But there''s another
    one called a callback ref that takes a functional format:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了两种通过`ref`属性接收元素实例的方式。最简单的一种是我们介绍的方式，即对象格式。但还有一种叫做回调引用，它采用函数格式：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Similarly, this functional format is supported when the *DOM* element is unmounted:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当*DOM*元素卸载时，这种功能格式也得到支持：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'During the DOM attachment or de-attachment, if it finds out the `ref` prop
    is provided as a functional format, it invokes it and passes the instance to it.
    Here''s the usage:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在DOM附加或分离期间，如果它发现`ref`属性以函数格式提供，它将调用它并将实例传递给它。这里的使用方法：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding code, an `onRef` function is wired to the `ref` prop. Both
    ways of setting the ref, either object or callback, are comparable. And the functional
    way seems to involve more work. So how is this functional format any more useful?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，一个`onRef`函数被连接到`ref`属性。设置引用的两种方式，无论是对象还是回调，都是可比较的。而且函数方式似乎涉及更多的工作。那么这种函数格式有什么更实用的地方？
- en: 'Although the `ref` object gives us the assigned *DOM* element, it doesn''t
    tell us exactly when the *DOM* element is attached or de-attached. So, to capture
    these moments, we can use a ref callback:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管引用对象给我们分配了 *DOM* 元素，但它并没有告诉我们 *DOM* 元素何时被附加或移除。因此，为了捕捉这些时刻，我们可以使用引用回调：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, based on a condition, we could decide where we want to
    store this ref or which ref we want to store. The example only gives a very naïve
    implementation, but you can see that this provides us more room for custom logic
    in terms of managing the DOM instance.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，基于一个条件，我们可以决定在哪里存储这个引用或存储哪个引用。示例只提供了一个非常简单的实现，但你可以看到这为我们提供了更多在管理 DOM
    实例方面的自定义逻辑空间。
- en: Appendix B – Forward ref
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 B – Forward ref
- en: 'A ref is created to store an instance of a class, whether the class is a *DOM*
    element or a class component. But not all components are written using a class,
    such as a function component:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 引用用于存储类的实例，无论这个类是 *DOM* 元素还是类组件。但并非所有组件都是使用类编写的，例如函数组件：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, we have declared `Title` as a function component. But
    since it's not declared with a class, we do not use `new` to create an instance.
    Instead, we invoke it via `Title()` at the update. Similarly, because of that,
    there's no way we can access the internal variables with an instance method such
    as `ATitle.dosomething()`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `Title` 声明为一个函数组件。但由于它没有用类声明，我们不需要使用 `new` 来创建实例。相反，我们在更新时通过 `Title()`
    调用它。同样，由于这个原因，我们无法通过实例方法（如 `ATitle.dosomething()`）访问内部变量。
- en: 'This is why we mentioned earlier that we can''t attach a ref to a function
    component; by default, it''s not what a function component can provide:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们之前提到我们不能将引用附加到函数组件上；默认情况下，这不是函数组件可以提供的：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, from a practical point of view, it does make sense for the developer
    to get hold of the `Title` instance and perform some action toward it. So, to
    address this need and to apply the ref idea consistently to all components, React
    provides one option called the forward ref:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从实际的角度来看，对于开发者来说，获取 `Title` 实例并对其实施一些操作是有意义的。因此，为了满足这一需求，并将引用的概念一致地应用于所有组件，React
    提供了一个名为 forward ref 的选项：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the preceding setup, by using a `fowardRef` function provided by *React*,
    we can promote `ref` defined for an `h1` element as the ref of the `Title` component.
    What does this mean? Let''s take a look at one usage:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设置中，通过使用 *React* 提供的 `forwardRef` 函数，我们可以将定义在 `h1` 元素上的引用提升为 `Title` 组件的引用。这意味着什么？让我们看看一个用法示例：
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding `App` component, we can now treat `Title` similar to an `h1`
    element; when we change its content, it literally changes the `h1` text content
    inside `Title`. Essentially, a ref is passed from the child to the parent.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `App` 组件中，我们现在可以将 `Title` 类似于一个 `h1` 元素来处理；当我们更改其内容时，它实际上会改变 `Title` 内部的
    `h1` 文本内容。本质上，一个引用从子组件传递给了父组件。
- en: 'A function component, unlike a class component, does not have an instance method
    in *React*, so even when we have a ref now, we need to set up a custom method
    if we want to support one:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件与类组件不同，在 *React* 中没有实例方法，所以即使我们现在有了引用，如果我们想支持它，也需要设置一个自定义方法：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the preceding code, React provides a built-in hook called `useImperativeHandle`
    to allow us to customize the instance value. In this example, we add a `go` custom
    method for ref:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，React 提供了一个内置的钩子 `useImperativeHandle`，允许我们自定义实例值。在这个例子中，我们为引用添加了一个
    `go` 自定义方法：
- en: '[PRE55]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This way, when we ask the `Title` instance to go, it focuses on the `h1` element.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们要求 `Title` 实例移动时，它会聚焦到 `h1` 元素上。
- en: So, with `forwardRef` and `useImperativeHandle`, we add a ref to a function
    component. This provides more opportunity for the developer to add manual control
    to the function component. However, we need to understand that a ref passed from
    the child to the parent originates from a single element, so technically speaking,
    a ref done this way is still a ref of that element, not a real ref for the function
    component.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过 `forwardRef` 和 `useImperativeHandle`，我们向函数组件添加了一个引用。这为开发者提供了更多手动控制函数组件的机会。然而，我们需要理解，从子组件传递给父组件的引用来自单个元素，所以从技术上讲，这种方式完成的引用仍然是该元素的引用，而不是函数组件的真实引用。
