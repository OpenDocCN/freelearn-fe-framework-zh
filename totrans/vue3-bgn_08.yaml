- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Testing Your App with Vitest and Cypress
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vitest和Cypress测试你的应用程序
- en: No matter how much experience you have under your belt in writing code, testing
    your app is a must to produce a high-quality code base. There are different testing
    tools out there, but in this book, we are going to learn Vitest for unit tests
    and Cypress for end-to-end testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在编写代码方面有多少经验，测试你的应用程序都是必须的，以确保代码库的质量。市面上有各种各样的测试工具，但在这本书中，我们将学习Vitest用于单元测试和Cypress用于端到端测试。
- en: Testing is a large topic, and in this chapter, we will learn the basics of both
    testing methodologies, leaving out advanced techniques for future reading and
    training that you will encounter in the course of your career.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个很大的主题，在本章中，我们将学习两种测试方法的基础，省略了你在职业生涯过程中可能遇到的更高级的技术。
- en: First, we are going to learn the different testing methods and how they each
    contribute to producing quality software. We will then introduce unit tests by
    learning how to use Vitest and Vue Test Utils to test individual components in
    our application. Then, we will move our focus away from the individual components
    and concentrate on our application, by introducing **E2E** (**end-to-end**) tests
    with Cypress. We will then write an E2E test to cover a small user journey before
    moving on to the last section, which will be used to introduce advanced topics
    such as mocking and spies.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将学习不同的测试方法以及它们各自如何有助于产生高质量的软件。然后，我们将通过学习如何使用Vitest和Vue Test Utils来测试应用程序中的单个组件来介绍单元测试。接着，我们将把注意力从单个组件转移到整个应用程序上，通过引入使用Cypress的**E2E**（**端到端**）测试来实现。然后，我们将编写一个端到端测试来覆盖一个小用户旅程，在进入最后一部分之前，这部分将用于介绍诸如模拟和间谍等高级主题。
- en: 'This chapter consists of the following sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下部分：
- en: Testing pyramids
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: Unit testing with Vitest
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vitest进行单元测试
- en: E2E tests with Cypress
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cypress进行端到端测试
- en: Introducing advanced testing techniques
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍高级测试技术
- en: By the end of this chapter, you will have gained a basic understanding of testing
    in general. You will be able to set up both Vitest and Cypress on your future
    projects and know how to write basic tests in both unit tests and E2E tests. Finally,
    you will also be exposed to future testing techniques that you may encounter in
    your career.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将获得对测试的一般基本理解。你将能够在你未来的项目中设置Vitest和Cypress，并知道如何在单元测试和端到端测试中编写基本测试。最后，你还将接触到你在职业生涯中可能遇到的未来测试技术。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, the branch is called `CH08`. To pull this branch, run the
    following command or use your GUI of choice to support you in this operation:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，分支被命名为`CH08`。要拉取这个分支，请运行以下命令或使用你选择的GUI来支持你进行此操作：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The branch includes all the files updated from the previous chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该分支包含从上一章更新的所有文件。
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners)找到。
- en: The testing pyramids
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: Clean code, coding standards, and peer reviews are essential parts of a good
    application, but they are not the only ones. In fact, a good and reliable application
    is not only the source of good development but also the result of a good level
    of testing coverage available within the application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁代码、编码标准和同行评审是良好应用程序的重要组成部分，但它们并不是唯一的。事实上，一个良好且可靠的应用程序不仅是良好开发的来源，也是应用程序内良好测试覆盖率的结果。
- en: Testing covers a very large spectrum. Some companies do very minimal tests,
    letting their end users be the actual testers by shipping them new code to look
    for bugs and errors, while others invest time and budgets in developing comprehensive
    sets of tests and adding them to their processes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 测试覆盖范围非常广泛。一些公司进行非常少的测试，通过向最终用户发布新代码以寻找错误和错误，让他们成为实际的测试者，而其他公司则投入时间和预算来开发全面的测试集，并将它们添加到他们的流程中。
- en: Even if companies invest different amounts of time in testing, all developers
    can at least agree that increased testing can, on average, result in fewer bugs
    being shipped to the user and a more flexible application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 即使公司在测试上投入的时间不同，所有开发者至少可以同意，增加测试通常会导致向用户发布的错误更少，并且应用程序更加灵活。
- en: Multiple levels of testing can be developed for an application, and they are
    divided into layers that together form a pyramid (hence the name *testing pyramid*).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为应用程序开发多个测试级别，并且它们被分为层，这些层共同形成一个金字塔（因此得名*测试金字塔*）。
- en: '![Figure 8.1: The testing pyramid](img/B21130_08_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：测试金字塔](img/B21130_08_01.jpg)'
- en: 'Figure 8.1: The testing pyramid'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：测试金字塔
- en: The bottom of the pyramid is where **unit tests** are found. Unit tests look
    at a single unit, which is usually a component or a helper file. These tests are
    very fast to run and, therefore, are usually produced in large quantities. Then,
    we have **integration tests**, which are where different parts of the system are
    connected to ensure that all parts work together. An integration test could test
    that the method successfully adds an entry to a database, by integrating the code
    and the database together, hence the name *integration test*. These tests take
    longer to run and require a bigger architecture, so they are expected to be used
    less than unit tests. Moving up in the pyramid, we find E2E tests. E2E testing
    encapsulates both manual tests, that are run by a quality assurance team, and
    automatic E2E tests that makes use of tools such as Cypress or Playwright. which
    are run manually by a quality assurance team, and automatic E2E tests are run
    by a tool such as Cypress or Playwright. An individual E2E test spans a full user
    journey and, due to its large scope, you will just require a few tests needed
    to cover your full application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔的底部是单元测试所在的位置。单元测试检查单个单元，这通常是一个组件或辅助文件。这些测试运行非常快，因此通常以大量产生。然后，我们有集成测试，这是系统不同部分连接在一起以确保所有部分都能协同工作的地方。集成测试可以通过将代码和数据库集成在一起来测试方法是否成功地将条目添加到数据库中，因此得名*集成测试*。这些测试运行时间更长，需要更大的架构，因此预计它们的使用频率将低于单元测试。在金字塔中向上移动，我们发现端到端测试。端到端测试封装了由质量保证团队运行的手动测试，以及使用Cypress或Playwright等工具运行的自动端到端测试。手动端到端测试由质量保证团队手动运行，而自动端到端测试由Cypress或Playwright等工具运行。单个端到端测试覆盖整个用户旅程，由于其范围很大，你只需要少量测试来覆盖你的整个应用程序。
- en: For the scope of this book, we are going to cover unit tests and E2E tests.
    Integration tests will not be covered because their usefulness is gradually decreasing,
    due to the advancement of E2E tools.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的范围，我们将涵盖单元测试和端到端测试。由于端到端工具的进步，集成测试将不会涉及，因为它们的有用性正在逐渐降低。
- en: 'The difference in the test types is not only defined by the different bugs
    that they can catch but also by their “development cost” and “speed to run.” Let’s
    see how different tests perform in the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类型之间的差异不仅由它们可以捕获的不同错误定义，还由它们的“开发成本”和“运行速度”定义。让我们看看以下图表中不同测试的表现：
- en: '![Figure 8.2: A comparison between the different test types](img/B21130_08_02_BW.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：不同测试类型的比较](img/B21130_08_02_BW.jpg)'
- en: 'Figure 8.2: A comparison between the different test types'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：不同测试类型的比较
- en: If an application only did E2E tests, it would catch bugs too late in development,
    slowing down the development process. Conversely, if an application only did unit
    tests, it would not pick up bugs and inconsistencies produced by different parts
    of the system working together, due to the fact that Unit Tests focus on a single
    unit and therefore cannot ensure that different part of the application work as
    expected.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序只做端到端测试，它会在开发后期才捕获到错误，从而减慢开发过程。相反，如果一个应用程序只做单元测试，它将无法捕捉到由系统不同部分协同工作产生的错误和不一致性，因为单元测试专注于单个单元，因此不能确保应用程序的不同部分按预期工作。
- en: Tests also exhibit differences in costs. A test cost is measured in the amount
    of time and effort that it takes to write the test, as well as its “speed to run,”
    which refers to the amount of time a single test takes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在成本上也有差异。测试成本是以编写测试所需的时间和努力来衡量的，以及它的“运行速度”，这指的是单个测试所需的时间。
- en: In an ideal world, all aspects of tests would be performed as part of your development
    process. But this is far from the truth. I have worked on many projects in my
    career, and I can count just a handful of businesses that really took ownership
    of their tests, implementing the whole pyramid. Unfortunately, for many businesses,
    tests are seen as an overhead (i.e, a cost that does not directly produce revenue).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，测试的所有方面都应该是您开发过程的一部分。但这远非事实。在我的职业生涯中，我参与了许多项目，我可以数出只有少数企业真正拥有了自己的测试，实施了整个金字塔。不幸的是，对于许多企业来说，测试被视为一种额外负担（即，一种不直接产生收入的成本）。
- en: Before moving forward to the next chapter and starting to develop our first
    test, it is important to try and define what makes tests worthwhile. We have already
    discussed the ability of tests to catch bugs early before they reach your clients.
    But this is not the only benefit; in fact, when asked by upper management why
    they should invest in tests, I usually prove my point by introducing the topic
    of “Increased flexibility and the reduced risk of change.”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到下一章并开始开发我们的第一个测试之前，尝试定义使测试有价值的内容是很重要的。我们已经讨论了测试在客户端之前早期捕获bug的能力。但这并非唯一的好处；事实上，当被上级管理层问及为什么他们应该投资于测试时，我通常会通过引入“增加灵活性和降低变更风险”这一主题来证明我的观点。
- en: Increased flexibility and the reduced risk of change
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加灵活性和降低变更风险
- en: When working on a big migration, the first task is ensuring that all E2E tests
    are set. Likewise, when developing a redesign, unit tests on the components are
    a must-have. A well-tested application does not only experience a lower level
    of bugs reaching the client but is also more flexible with updates. Knowing that
    you can easily test the major features of your application and quickly be informed
    if something has regressed or broken is a key aspect of agile development, setting
    your application for success and making it less risky to make changes to the code
    base.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行大型迁移时，首要任务是确保所有端到端测试都已设置。同样，在开发重设计时，组件的单元测试是必不可少的。经过良好测试的应用程序不仅会降低达到客户端的bug级别，而且在更新时也更加灵活。知道您可以轻松测试应用程序的主要功能，并且如果有什么东西退步或损坏，可以迅速得到通知，这是敏捷开发的关键方面，有助于使应用程序成功并降低对代码库进行更改的风险。
- en: I hope this is enough to convince you to understand the importance of testing.
    It is now time to move forward and learn how to write tests within our application.
    Tests can be quite tricky to implement on existing applications, and they also
    have a higher initial learning curve before you get started, but the payback of
    this investment is invaluable for your career and your code quality.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这足以让您理解测试的重要性。现在是时候继续前进，学习如何在我们的应用程序中编写测试了。在现有应用程序中实施测试可能相当棘手，而且在开始之前，您还需要克服更高的学习曲线，但这一投资的回报对于您的职业生涯和代码质量是无价的。
- en: Let’s see how Vitest can be set up and implemented to test some components of
    our Companion App.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Vitest 如何设置和实施，以测试我们伴侣应用程序的一些组件。
- en: Unit testing with Vitest
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vitest 进行单元测试
- en: Vitest is one of the main unit test frameworks in the JavaScript ecosystem,
    and it has a syntax very similar to Jest. Most of the knowledge you will gain
    in this chapter is transferrable to other testing frameworks, as they all follow
    a very similar structure.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest 是 JavaScript 生态系统中的主要单元测试框架之一，其语法与 Jest 非常相似。在本章中，您将获得的大部分知识都可以转移到其他测试框架，因为它们都遵循一个非常相似的结构。
- en: Vitest is already set up in our application, but we will cover the basic steps
    required to add it to your new or existing applications.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest 已经在我们的应用程序中设置好了，但我们将介绍添加到您的新或现有应用程序所需的基本步骤。
- en: Installing Vitest in your application
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的应用程序中安装 Vitest
- en: 'The first step required is the package for **Vitest** and **Vue Test Utils**,
    which are, respectively, the test runner and the Vue components testing framework.
    We can achieve this by opening the terminal and running the following command
    in the root folder of our application:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的第一步是安装 **Vitest** 和 **Vue Test Utils** 包，它们分别是测试运行器和 Vue 组件测试框架。我们可以在应用程序的根目录中打开终端并运行以下命令来实现：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that the packages are installed, we just need to add a script to the `package.json`
    file so that we can simply run it in the future:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在包已经安装，我们只需要将一个脚本添加到 `package.json` 文件中，这样我们就可以在将来简单地运行它：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The command string used is arbitrary, but it is common practice to name it `"test:unit"`.
    This will allow us later to also define `"test:e2e"` and clearly define the two
    different test procedures.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的命令字符串是任意的，但命名它为`"test:unit"`是常见的做法。这将允许我们稍后定义`"test:e2e"`，并清楚地定义两种不同的测试过程。
- en: 'To run Vitest, we can just run the newly created script in our terminal with
    `npm run test:unit.` The result should be the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Vitest，我们只需在终端中运行新创建的脚本，使用`npm run test:unit.`。结果应该是这样的：
- en: '![Figure 8.3: A terminal screenshot of the test results](img/B21130_08_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：测试结果的终端截图](img/B21130_08_03.jpg)'
- en: 'Figure 8.3: A terminal screenshot of the test results'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：测试结果的终端截图
- en: The console terminal should show an error message, `theButton.vue`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台终端应该显示错误消息，“theButton.vue”。
- en: Writing our first unit test
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的第一个单元测试
- en: Now that everything is set, it is time to start and write our first test using
    our base button component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，是时候开始使用我们的基础按钮组件编写第一个测试了。
- en: A unit test has a very important goal – test a single unit of your application.
    In a framework such as Vue.js, a unit is defined as a component, a composable,
    or a store file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试有一个非常重要的目标——测试你应用程序的单个单元。在Vue.js这样的框架中，单元被定义为组件、组合式或存储文件。
- en: When testing a unit of logic, you should focus on its functionality and not
    its static content, such as text.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试一个逻辑单元时，你应该关注其功能，而不是其静态内容，如文本。
- en: Creating a text-focused test that just compare text values, such as headings
    and buttons, will not only provide any benefits to our application, but will also
    be hard to maintain , due to its flakiness (produced by the fact that the tests
    will have to change every time we change the copy of our component).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个仅比较文本值的文本焦点测试，不仅不会为我们的应用程序提供任何好处，而且由于其易变性（由于测试将不得不每次我们更改组件的副本时都进行更改）而难以维护。
- en: 'Before creating our test file, let’s open `TheButton.vue` and see what part
    of this component could be tested:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建测试文件之前，让我们打开`TheButton.vue`并看看这个组件的哪个部分可以被测试：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our component is a standard button and, as such, includes all the basic functionality
    that we would expect from one. A few test scenarios for this component could be
    the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件是一个标准的按钮，因此它包括我们期望的所有基本功能。这个组件的一些测试场景可能如下：
- en: Checking that the component renders successfully, ensuring that there are no
    mistakes in the component structure
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查组件是否成功渲染，确保组件结构没有错误
- en: Checking that the default styles load by default
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查默认样式是否默认加载
- en: Checking that the theme props work to change the theme
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查主题属性是否可以更改主题
- en: These three initial tests are great for us to get started on this topic. As
    I said before, tests can have quite a steep learning curve, so it is good to start
    small and slowly build on that knowledge.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个初始测试对我们开始这个主题非常有帮助。正如我之前所说，测试可能有一个相当陡峭的学习曲线，所以从小处开始，并逐渐建立知识是很好的。
- en: It is now time to create our test files. Test files are named in the nameOfFileTested.spec.js
    format, so in our case, it would be TheButton.spec.js.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们的测试文件了。测试文件按照`nameOfFileTested.spec.js`的格式命名，所以在我们这个例子中，它将是TheButton.spec.js。
- en: 'We can create a test file in any folder we want, but it is good practice to
    decide a standard for the project and consistently follow it. In our case, we
    are going to create this file in the `__tests__` folder. The full path of the
    file should look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何我们想要的文件夹中创建测试文件，但遵循项目标准并始终如一地遵循它是良好的实践。在我们的例子中，我们将在`__tests__`文件夹中创建这个文件。文件的完整路径应该是这样的：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before we start discussing the test structure, we need to import a few modules
    that will allow us to create the test. We are going to import the `expect`, `describe`,
    and `it``mount` method from `@vue/test-utils`, and finally, the component itself.
    The `import` statement at the top of our test should look like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论测试结构之前，我们需要导入一些模块，这将允许我们创建测试。我们将从`@vue/test-utils`导入`expect`、`describe`和`it`的`mount`方法，最后是组件本身。我们的测试文件顶部的`import`语句应该看起来像这样：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that our imports are set, it is time to start to learn how to structure
    a test. The structure of tests follows a callback approach, where each method
    has a callback to another method, and so on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了导入，是时候开始学习如何构建测试结构了。测试的结构遵循回调方法，其中每个方法都有一个回调到另一个方法，依此类推。
- en: Even if this approach, also referred to as callback hell, is usually a sign
    of bad practice in JS, it is the best way to provide structure for your tests.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这种做法，也被称为回调地狱，通常是JS中的不良实践，但它为你的测试提供了最佳的结构。
- en: 'To write a well-structured unit test, we can use the Given, When, and Then
    syntax that answers the following three questions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个结构良好的单元测试，我们可以使用Given、When和Then语法来回答以下三个问题：
- en: What are we testing (Given)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在测试什么（Given）？
- en: What is the scenario (When)?
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在测试什么场景（When）？
- en: What is the expected outcome (Then)?
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期结果是什么（Then）？
- en: 'We can then use `Given`, `When`, and `Then` to create our own test cases by
    creating a simple sentence. So, in the case of our button, the sentence could
    be as follows: “Given `TheButton.vue`, when *it is mounted*, then it *should*
    *render properly*.”'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过创建一个简单的句子来使用`Given`、`When`和`Then`来创建自己的测试用例。所以，在我们的按钮例子中，句子可以是这样的：“Given
    `TheButton.vue`，when *它被挂载*，then *它应该* *正确渲染*。”
- en: With the preceding sentence. we can now go and write our first unit test.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的句子，我们现在可以编写我们的第一个单元测试。
- en: Write your test in words first
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先用文字编写你的测试
- en: It is beneficial to break down your tests by writing them in sentences first.
    Being able to write down all the tests by just defining a single sentence for
    each test will help you define better tests and ensure that you cover your components
    fully. Reading and comparing a couple of sentences is simpler than doing the same
    after the tests are written.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先用句子来编写测试，将有助于你更好地定义测试并确保你完全覆盖了组件。阅读和比较几个句子比在测试编写后做同样的事情要简单。
- en: 'To structure our tests, we will make use of the `describe` and `it` methods
    provided by Vitest:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结构化我们的测试，我们将利用Vitest提供的`describe`和`it`方法：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A test uses the `describe` method to define the aforementioned Given and When
    syntax, and the `it` method to define the actual test (`Then`). A test can have
    multiple nested descriptions. Test names are very important because they are used
    by a testing framework in error messages, triggered when a test fails. Having
    a very well-structured name will help you save time if something breaks and your
    test fails. Let’s try to run our empty test for the first time and see what the
    output is. To run our tests, we need to open the terminal, access the `project`
    folder, and run the following **npm** command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用`describe`方法来定义上述Given和When语法，使用`it`方法来定义实际的测试（Then）。一个测试可以有多个嵌套描述。测试名称非常重要，因为测试框架在测试失败时会在错误消息中使用它们。拥有一个非常结构化的名称将有助于你在测试失败时节省时间。让我们尝试第一次运行我们的空测试并查看输出。要运行我们的测试，我们需要打开终端，访问`project`文件夹，并运行以下**npm**命令：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the preceding command should be the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出应该是以下内容：
- en: '![Figure 8.4: The terminal output of Vitest](img/B21130_08_04.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：Vitest的终端输出](img/B21130_08_04.jpg)'
- en: 'Figure 8.4: The terminal output of Vitest'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：Vitest的终端输出
- en: The test results follow the same nested structure that we defined in our test.
    The words used within the `describe` and `it` methods form a readable word. If
    an error is triggered locally or in any deployment environment, the log will display
    the file name, followed by the different words we used to declare our test. In
    our case it would be *TheButton.vue when mounted* *renders properly.*
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果遵循我们在测试中定义的相同嵌套结构。在`describe`和`it`方法中使用的单词形成一个可读的单词。如果错误在本地或任何部署环境中触发，日志将显示文件名，然后是我们用来声明测试的不同单词。在我们的例子中将是*TheButton.vue
    when mounted* *渲染正确*。
- en: Vitest is fast – very fast
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest速度快——非常快
- en: In the previous section, we mentioned that unit tests are fast, but we have
    not mentioned that among all unit test frameworks, Vitest is the fastest of all
    unit test frameworks. Its speed is to be attributed to the Vite server on which
    Vitest is built.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到单元测试速度快，但尚未提到在所有单元测试框架中，Vitest是最快的。其速度应归因于Vite服务器，Vitest就是基于这个服务器构建的。
- en: Our first test has not tested anything yet, as it has an empty body. Let’s go
    back and see how we can test our component. To complete this task, we will use
    the `mount` method offered by Vue Test Utils and the `expect` method, used to
    tell the Unit Test engine what we want to test.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个测试还没有测试任何东西，因为它有一个空的主体。让我们回到去看我们如何测试我们的组件。为了完成这个任务，我们将使用Vue Test Utils提供的`mount`方法和`expect`方法，后者用来告诉单元测试引擎我们想要测试的内容。
- en: The `mount` method is used to initialize a component by rendering it within
    the test framework, while `expect` is used to define our test cases.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount` 方法用于通过在测试框架中渲染组件来初始化组件，而 `expect` 用于定义我们的测试用例。'
- en: 'In every test, we start by setting out our component and any state that this
    may require. In our case, we just need to mount it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试中，我们首先设置我们的组件和可能需要的任何状态。在我们的例子中，我们只需要挂载它：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will assert that our component rendered successfully by checking whether
    it includes a `button` element:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过检查它是否包含一个 `button` 元素来断言我们的组件已成功渲染：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `expect` method accepts the value being tested as its argument and is then
    chained to the test performed on the given value. Vitest comes with a huge list
    of assertions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect` 方法接受被测试的值作为其参数，然后将其链接到对给定值的测试。Vitest 随带大量断言。'
- en: 'For example, if we wanted to create a test that checks if two number are equals,
    we would do the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想创建一个检查两个数字是否相等的测试，我们会这样做：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The full test file should look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的测试文件应该看起来像这样：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, to recap, we learned that tests follow a very structured approach. They
    require us to define what we are testing, and the scenario and assertion that
    we are considering.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，我们了解到测试遵循一个非常结构化的方法。它们要求我们定义我们要测试的内容，以及我们正在考虑的场景和断言。
- en: 'Let’s add another test that would create the following test sentence: “Given
    `TheButton.vue`, when *it is mounted*, then it *defaults to the* *light theme*.”'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个测试，以创建以下测试句子：“Given `TheButton.vue`，when *it is mounted*，then it *defaults
    to the* *light theme*。”
- en: As you can see from the first two parts of the sentence, `Given` and `When`
    are the same, so this means that we can reuse the existing code blocks and just
    add another test.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从句子的前两部分中可以看到，`Given` 和 `When` 是相同的，这意味着我们可以重用现有的代码块，只需再添加另一个测试。
- en: To check whether the correct theme is applied, we will check whether the CSS
    class `light` has been applied to the component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查是否应用了正确的主题，我们将检查 CSS 类 `light` 是否已应用于组件。
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As shown by the highlighted text in the preceding code block, adding extra tests
    that follow the same setup is quite simple. To complete the new test, we used
    `mount` again to initialize a version of our component. We then used `wrapper.classes()`
    to extract all the classes of the component and asserted this to contain `light`
    using `expect().toContain().`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码块中突出显示的文本所示，添加遵循相同设置的额外测试相当简单。为了完成新的测试，我们再次使用 `mount` 来初始化组件的一个版本。然后我们使用
    `wrapper.classes()` 提取组件的所有类，并使用 `expect().toContain()` 断言这包含 `light`。
- en: Due to the fact that both of the tests have the same When, we were able to reuse
    the describe method `describe('when mounted'..)`. Doing so will help us break
    up tests logically.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个测试都有相同的 When，我们能够重用 `describe` 方法 `describe('when mounted'..)`。这样做将帮助我们逻辑上分割测试。
- en: 'The tests are automatically updated, so when the file is saved, our terminal
    should output the new result with two passing tests:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 测试会自动更新，所以当文件保存时，我们的终端应该输出新的结果，显示两个通过测试：
- en: '![Figure 8.5: The Vitest test results showing two passing tests](img/B21130_08_05.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5：Vitest 测试结果显示两个通过测试](img/B21130_08_05.jpg)'
- en: 'Figure 8.5: The Vitest test results showing two passing tests'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：Vitest 测试结果显示两个通过测试
- en: Your turn
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你的回合
- en: Write the last unit test to complete the testing of `TheButton.vue`. The last
    test should test that the component renders the dark theme when the correct properties
    are passed. Research Vue Test Utils and the Vitest documentation to learn how
    to define properties when mounting a component. Next chapter branch will include
    the test for you, so that you can check if your test was written correctly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 编写最后一个单元测试来完成 `TheButton.vue` 的测试。最后一个测试应该测试当传递正确的属性时，组件是否渲染了深色主题。研究 Vue Test
    Utils 和 Vitest 文档，了解如何在挂载组件时定义属性。下一章分支将包括为你准备的测试，这样你可以检查你的测试是否编写正确。
- en: Unit tests are a big topic, and this was just a very simple introduction to
    give you some necessary initial information. Each project will create tests that
    are slightly different, either because of the project structure, the breakdown
    of components, or even the naming convention used. For this reason, the best way
    to truly learn how to write tests is to practice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一个很大的主题，这只是一个非常简单的介绍，以提供一些必要的基本信息。每个项目都会创建略有不同的测试，这可能是由于项目结构、组件的分解，甚至是使用的命名约定。因此，真正学习如何编写测试的最佳方式是实践。
- en: Before we move forward, I want to share one more tip to ensure you test your
    code correctly. In fact, it is common when writing unit tests to make them too
    dependent on the inside of a component. A unit test is expected to test what a
    single unit of code would **output** when given a specific **input**. What this
    means is that you should be able to test a component without the need to open
    the file, just by knowing the properties it accepts and the UI/events that it
    emits. When writing your unit tests, always focus on the input and output, and
    leave the implementation details out of your test.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，我想分享一个额外的技巧，以确保你正确地测试你的代码。实际上，在编写单元测试时，让它们过于依赖组件的内部结构是很常见的。单元测试的预期是测试当给定特定输入时，单个代码单元会**输出**什么。这意味着你应该能够测试一个组件，而无需打开文件，只需知道它接受的属性和它发出的
    UI/事件即可。在编写你的单元测试时，始终关注输入和输出，并将实现细节排除在测试之外。
- en: In this section, we introduced unit tests and discussed how to use Vitest to
    test our component. We learned the syntax required to write a unit test and introduced
    Vue Test Utils to help us work with our Vue component. Then, we covered the importance
    of the test name and how this follows the Given, When, and Then methodology.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了单元测试，并讨论了如何使用 Vitest 来测试我们的组件。我们学习了编写单元测试所需的语法，并介绍了 Vue Test Utils
    以帮助我们处理 Vue 组件。然后，我们讨论了测试名称的重要性，以及它是如何遵循“给定、当、然后”方法的。
- en: In the next section, we will ascend the pyramid and learn to write E2E tests.
    We will be able to reuse some of the knowledge we learned in this section and
    continue to learn how to make our code more reliable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将攀登金字塔，学习如何编写端到端测试。我们将能够重用本节学到的部分知识，并继续学习如何使我们的代码更加可靠。
- en: E2E tests with Cypress
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cypress 进行端到端测试
- en: It is time to move our testing focus from a micro level, offered by unit tests,
    to a macro level, provided by E2E tests. If unit tests focus on a single state
    of a single component, E2E will help us test a complete user journey.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将我们的测试焦点从单元测试提供的微观层面，转移到端到端测试提供的宏观层面了。如果单元测试关注单个组件的单个状态，端到端测试将帮助我们测试完整的用户旅程。
- en: As I mentioned previously, we will be able to use some of the knowledge that
    we learned in the previous section, since E2E tests follow a similar structure
    to the ones we learned about in Vitest.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，我们将能够使用之前章节中学到的知识，因为端到端测试的结构与我们在 Vitest 中学到的类似。
- en: Let’s break down this section into three different parts. First, we are going
    to learn how to install **Cypress** in your application. Then, we will learn the
    basic structure of an E2E test file and its placement within a project. Lastly,
    we will end the section by writing an E2E test for our application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这一节分解为三个不同的部分。首先，我们将学习如何在你的应用程序中安装 **Cypress**。然后，我们将学习端到端测试文件的基礎结构和它在项目中的位置。最后，我们将通过为我们的应用程序编写端到端测试来结束这一节。
- en: The most used E2E tools within the JS industry are Cypress and Playwright. Cypress
    has been around for quite a few years, and it currently holds a very large section
    of the market. Playwright is a little newer, but it is gaining a lot of market
    share due to its integration with IDEs and extensive browser emulation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JS 行业中最常用的端到端（E2E）工具是 Cypress 和 Playwright。Cypress 已经存在了相当长的时间，并且目前占据了很大的市场份额。Playwright
    相对较新，但由于它与 IDE 的集成以及广泛的浏览器模拟，它正在迅速增加市场份额。
- en: Just like unit tests, the syntax of the different players on the market is very
    similar, so most of the features and syntax that you learn in one could be used
    in another one if you later decide to switch.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像单元测试一样，市场上不同工具的语法非常相似，所以你在一个中学习的多数功能和语法，如果你后来决定切换，也可以用在另一个中。
- en: Let’s start by installing Cypress into your project.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将 Cypress 安装到你的项目中开始。
- en: Installing Cypress into your project
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Cypress 安装到你的项目中
- en: Today’s JS ecosystem offers us tools with amazing user experiences that offer
    very simple installation processes, and Cypress is one of those.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的 JS 生态系统为我们提供了具有惊人用户体验的工具，它们提供了非常简单的安装过程，而 Cypress 就是其中之一。
- en: Our Companion App already includes a set of tests, and they are installed by
    the Vue project initialization that we introduced in [*Chapter 3*](B21130_03.xhtml#_idTextAnchor039).
    However, it is helpful to learn how to add Cypress to your new or existing project.
    Due to the fact that Cypress is already part of the Companion App, you would have
    to follow the following steps in a new folder.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Companion App已经包含了一组测试，它们是通过我们介绍的Vue项目初始化安装的。然而，了解如何将Cypress添加到您的新项目或现有项目中有助于学习。由于Cypress已经是Companion
    App的一部分，您将不得不在新的文件夹中遵循以下步骤。
- en: The official documentation provided at [cypress.io](http://cypress.io) offers
    two installation methods, a **direct download** and an **npm installation**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[cypress.io](http://cypress.io)提供的官方文档中提供了两种安装方法，一种是**直接下载**，另一种是**npm安装**。
- en: 'We are going to follow the installation using the `npm` package manager. To
    initialize this, access the root folder of your project in your preferred terminal
    and type the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`npm`包管理器来跟随安装。为此，在您首选的终端中访问您项目的根目录，并输入以下命令：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next step is to run Cypress. This can be achieved with the following `npx`
    command (note that the command is `npx` and not `npm`):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是运行Cypress。这可以通过以下`npx`命令实现（注意命令是`npx`而不是`npm`）：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After a few seconds, you should be presented with a welcome screen.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，您应该会看到一个欢迎屏幕。
- en: '![Figure 8.6: Cypress’s opening dashboard](img/B21130_08_06.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6：Cypress的启动仪表板](img/B21130_08_06.jpg)'
- en: 'Figure 8.6: Cypress’s opening dashboard'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：Cypress的启动仪表板
- en: Cypress can be set up for E2E and component testing. The wizard in *Figure 8**.6*
    marks our test as **Not Configured**. Let’s begin the configuration of the E2E
    testing by clicking on the left block. Doing so will generate a set of example
    files that we will need to run our first test.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress可以设置为端到端和组件测试。*图8.6*中的向导将我们的测试标记为**未配置**。让我们通过点击左侧块开始配置端到端测试。这样做将生成一组示例文件，我们需要运行我们的第一个测试。
- en: '![Figure 8.7: The Cypress wizard test file creation](img/B21130_08_07.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：Cypress向导测试文件创建](img/B21130_08_07.jpg)'
- en: 'Figure 8.7: The Cypress wizard test file creation'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：Cypress向导测试文件创建
- en: The wizard has created four files. The first is the main configuration file
    that is hosted in the root of our project under the name `cypress.config.js`,
    which includes all the settings related to Cypress. The second and third are example
    files for support that are used to create reusable commands; commands are for
    more advanced users and are not covered in this book. The last file is a fixture
    example JSON, accessible at `cypress/fixtures/example.json`. Fixture files are
    used to save reusable information, such as text input or an API response.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 向导创建了四个文件。第一个是主配置文件，位于我们项目的根目录下，文件名为`cypress.config.js`，其中包含所有与Cypress相关的设置。第二个和第三个是支持示例文件，用于创建可重用的命令；命令是为更高级的用户准备的，本书没有涉及。最后一个文件是一个可访问于`cypress/fixtures/example.json`的固定示例JSON文件。固定文件用于保存可重用的信息，例如文本输入或API响应。
- en: If we continue our journey within the installation wizard, we will be presented
    with the browser selector screen. This screen will be displayed every time you
    run Cypress and allows you to select which browser you want to use.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在安装向导中继续前进，我们将看到一个浏览器选择屏幕。这个屏幕将在每次运行Cypress时显示，并允许您选择您想要使用的浏览器。
- en: '![Figure 8.8: Cypress’s Choose a browser screen](img/B21130_08_08.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8：Cypress的“选择浏览器”屏幕](img/B21130_08_08.jpg)'
- en: 'Figure 8.8: Cypress’s Choose a browser screen'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：Cypress的“选择浏览器”屏幕
- en: Let’s open the test runner by clicking on Chrome.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过点击Chrome打开测试运行器。
- en: '![Figure 8.9: The first instance of Cypress’s chrome test runner](img/B21130_08_09.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9：Cypress的chrome测试运行器的第一个实例](img/B21130_08_09.jpg)'
- en: 'Figure 8.9: The first instance of Cypress’s chrome test runner'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：Cypress的chrome测试运行器的第一个实例
- en: Since we chose Chrome as our test runner, we will start in a new Chrome window.
    This runner will offer us the ability to create example tests or generate a test
    template.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们选择了Chrome作为测试运行器，我们将在一个新的Chrome窗口中开始。这个运行器将提供创建示例测试或生成测试模板的能力。
- en: We are going to stop at this point in the installation wizard; it is time to
    return to our Companion App and continue our journey there to learn more about
    E2E tests and Cypress.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在安装向导的这个点上停止；是时候回到我们的Companion App，继续我们的旅程，了解更多关于端到端测试和Cypress的信息了。
- en: Installing and reading the example tests
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和阅读示例测试
- en: The tests provided by the “scaffold example specs” are very extensive and well-written.
    These sample tests provide you with an amazing insight into what E2E tests can
    achieve. Spend a few minutes installing and reading through these tests before
    moving on to the next chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: “scaffold example specs” 提供的测试非常广泛且编写良好。这些示例测试为您提供了对 E2E 测试可以实现的惊人洞察。在进入下一章之前，花几分钟安装并阅读这些测试。
- en: Learning the E2E tests’ file format and file location
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习 E2E 测试的文件格式和文件位置
- en: In the previous section, we learned how to install Cypress into our projects.
    In this section, we will learn the file location and format of these E2E test
    files before moving on to create our first test. Remember that we are now working
    within our Companion App, so you should go and open it with your IDE of choice.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何将 Cypress 安装到我们的项目中。在本节中，我们将在创建第一个测试之前学习这些 E2E 测试文件的文件位置和格式。请记住，我们现在正在我们的
    Companion App 中工作，所以你应该用你选择的 IDE 打开它。
- en: 'The location of our E2E tests is defined within the Cypress configuration file.
    As we learned from the previous section, this is located at the root of our application
    and is called `cypress.config.js`. This file includes a couple of settings, one
    of which is called `specPattern`. This configuration setting informs Cypress where
    to find the tests:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 E2E 测试的位置在 Cypress 配置文件中定义。正如我们在上一节中学到的，这个文件位于我们应用程序的根目录，称为 `cypress.config.js`。此文件包含一些设置，其中之一被称为
    `specPattern`。此配置设置告知 Cypress 在哪里找到测试：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This pattern expects the E2E files to be located within the `cypress/e2e` folder
    and for the filename to end with a combination of `cy,spec` and `js, jsx, ts`
    `and tsx`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式期望 E2E 文件位于 `cypress/e2e` 文件夹中，并且文件名以 `cy,spec` 和 `js,jsx,ts` 以及 `tsx` 的组合结尾。
- en: So, a test file could be called `mytest.spec.ts` or `mytest.cy.js`, and if it
    is within the `cypress/e2e` folder, the Cypress test runner will be able to see
    and utilize it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个测试文件可以命名为 `mytest.spec.ts` 或 `mytest.cy.js`，如果它位于 `cypress/e2e` 文件夹中，Cypress
    测试运行器将能够看到并利用它。
- en: 'Let’s go and create our first test, called `homepage`. Because I want to distinguish
    between unit tests and E2E tests, I will end this file with `cy.js` (the unit
    tests end in `spec.js`). The full location of the new file would be as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建第一个测试，命名为 `homepage`。因为我想要区分单元测试和 E2E 测试，所以我会以 `cy.js` 结尾这个文件（单元测试以 `spec.js`
    结尾）。新文件的完整位置如下：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that the file has been created, it is time to learn how to structure these
    files. As I previously mentioned, there are some similarities between E2E and
    unit tests’ structures. In fact, both tests follow the same syntax, with a structure
    based on callbacks and methods called `describe` and `it`, respectively.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件已经创建，是时候学习如何构建这些文件了。正如我之前提到的，E2E 测试和单元测试的结构有一些相似之处。事实上，这两个测试都遵循相同的语法，分别以回调和
    `describe`、`it` 方法为基础的结构。
- en: 'A Test scaffold should look like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚手架应该看起来像这样：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the code structure is noticeable, like the one offered by Vitest,
    with the only difference being that, in this case, we do not need to import the
    `describe` and `it` methods, as they are automatically imported for us.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码结构非常明显，就像 Vitest 提供的那样，唯一的区别是，在这种情况下，我们不需要导入 `describe` 和 `it` 方法，因为它们会自动为我们导入。
- en: Another small difference is the name of the test. When we defined a name in
    a unit test, it was a very important part of the test, with the well-defined `Given`,
    `When`, and `Then` methodology. In E2E tests, names are a little less important,
    mainly because these tests can have a large scope, such as a full check of the
    home page, and providing a single sentence to define what we are testing is not
    always possible.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个小的不同之处在于测试的名称。当我们在一个单元测试中定义一个名称时，它是测试的一个重要部分，具有定义良好的 `Given`、`When` 和 `Then`
    方法。在 E2E 测试中，名称的重要性略低，主要是因为这些测试可以具有很大的范围，例如对主页的全面检查，并且提供一句话来定义我们正在测试的内容并不总是可能的。
- en: Before we move forward, we are going to try and run E2E tests in our application
    and learn the steps required to do so.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，我们将尝试在我们的应用程序中运行 E2E 测试，并学习执行此操作所需的步骤。
- en: 'In the previous section, we used `npx cypress open` to start Cypress. This
    can still be used, but our `package.json` has a couple of scripts ready for us
    to use that come with extra configurations, simplifying our development experience:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了 `npx cypress open` 来启动 Cypress。这仍然可以使用，但我们的 `package.json` 中有一些脚本供我们使用，这些脚本带有额外的配置，简化了我们的开发体验：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The application offers two scripts, `"test:e2e"` and `"test:e2e:dev"`. The first
    is used to run E2E on a preview build, while the second is used to run the test
    on a development build with **hot reload**. This will allow us to make modifications
    to our application while the E2E test runner is ready to run.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序提供了两个脚本，`"test:e2e"`和`"test:e2e:dev"`。第一个用于在预览构建上运行E2E，而第二个用于在带有**热重载**的开发构建上运行测试。这将允许我们在E2E测试运行器准备运行的同时对我们的应用程序进行修改。
- en: 'Try to run the development E2E test environment by running the following command
    in the terminal:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过在终端中运行以下命令来运行开发E2E测试环境：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The result of this command should be the Cypress dashboard that we saw before.
    Just like before, you should click on **E2E tests** and choose **Chrome** as the
    browser to run our tests.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的结果应该是我们之前看到的Cypress仪表板。就像之前一样，你应该点击**E2E测试**，并选择**Chrome**作为运行测试的浏览器。
- en: 'The result should be a Chrome browser, as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个Chrome浏览器，如下面的截图所示：
- en: '![Figure 8.10: The Cypress test dashboard in Chrome](img/B21130_08_10.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10：Chrome中的Cypress测试仪表板](img/B21130_08_10.jpg)'
- en: 'Figure 8.10: The Cypress test dashboard in Chrome'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：Chrome中的Cypress测试仪表板
- en: Browse around
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览一下
- en: Before continuing the chapter, you should spend a couple of minutes to familiarize
    yourself with the test runner. Knowing what it has to offer and how it works will
    be very beneficial for what you learn in the future and your usage of E2E tests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章之前，你应该花几分钟时间熟悉测试运行器。了解它提供的内容以及它是如何工作的，将非常有利于你未来的学习和E2E测试的使用。
- en: 'To run our test, click on the test name, `homepage.cy.js`. This will load the
    Cypress test runner:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的测试，点击测试名称`homepage.cy.js`。这将加载Cypress测试运行器：
- en: '![Figure 8.11: The Cypress test runner](img/B21130_08_11.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11：Cypress测试运行器](img/B21130_08_11.jpg)'
- en: 'Figure 8.11: The Cypress test runner'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：Cypress测试运行器
- en: Currently, the test runner is not very useful, as the only test we have is empty.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，测试运行器并不十分有用，因为我们唯一的测试是空的。
- en: Now, it’s time to move on to the next section, where we will write our first
    test in Cypress.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进入下一节了，我们将要在Cypress中编写我们的第一个测试。
- en: Writing your first E2E test
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写你的第一个E2E测试
- en: E2E tests are usually referred to as a **journey**. The name is derived from
    the fact that it encapsulates a specific user’s journey. These could be the steps
    required to complete a **contact us** form, or the ones required to buy a product.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: E2E测试通常被称为**旅程**。这个名字来源于它封装了特定用户的旅程。这些可能包括完成**联系我们**表单所需的步骤，或者购买产品所需的步骤。
- en: Due to the size of our current application, the journey will be quite small,
    but it can still be useful to ensure we build a stable application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们当前应用程序的大小，这个旅程将会相当小，但仍然可以确保我们构建一个稳定的程序。
- en: 'Our test will complete the following aspects:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试将完成以下方面：
- en: Accessing the site
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问网站
- en: Displaying the app title
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示应用程序标题
- en: Ensuring that posts are loaded
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保帖子被加载
- en: Checking whether a post that has no comments, show the correct empty message
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查没有评论的帖子是否显示正确的空消息
- en: Checking whether a post that has comments displays them correctly.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查带有评论的帖子是否正确显示评论。
- en: 'E2E tests are written sequentially, in the same way that you would complete
    the same journey manually. So, we are going to start our test by accessing the
    site on the main page. This is done by using the `cy.visit` command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: E2E测试是按顺序编写的，就像你手动完成相同的旅程一样。因此，我们将从使用`cy.visit`命令访问主页开始我们的测试：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When using the `visit` command, you can pass any relative URL. In our scenario,
    we will just pass a forward slash, as we are going to visit the home page.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`visit`命令时，你可以传递任何相对URL。在我们的场景中，我们只需传递一个正斜杠，因为我们将要访问主页。
- en: A base URL preset
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 基础URL预设
- en: Note that we were able to visit the home page by using a single forward slash
    because we have set a `baseUrl` preset within `cypress.config.js`. Without the
    `baseUrl` setting, you would have had to insert the full URL within the `cy.visit`
    command.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们能够通过使用单个正斜杠来访问主页，因为我们已经在`cypress.config.js`中设置了一个`baseUrl`预设。如果没有`baseUrl`设置，你将不得不在`cy.visit`命令中插入完整的URL。
- en: 'Next, we are going to check for the presence of the title `Companion App`.
    This is achieved using two new methods, `get` and `should`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查是否存在标题`Companion App`。这是通过使用两个新方法`get`和`should`实现的：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `get` method is just like `document.querySelector` and allows you to select
    a given element on a page. The `should` method allows you to set an expectation
    – that is, what defines a test as a pass or a fail. The `should` method accepts
    a parameter that is the logic by which we test our selector. These parameters
    are called **chainers** and have hundreds of different possibilities. The best
    way to learn all the available **chainers** is to either access the documentation
    ([https://docs.cypress.io/guides/references/assertions](https://docs.cypress.io/guides/references/assertions))
    or use the IntelliSense IDE.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法就像`document.querySelector`一样，允许你在页面上选择一个给定的元素。`should`方法允许你设置一个预期——也就是说，它定义了测试是成功还是失败。`should`方法接受一个参数，这是我们测试选择器的逻辑。这些参数被称为**链式调用器**，有数百种不同的可能性。学习所有可用**链式调用器**的最好方法是查阅文档([https://docs.cypress.io/guides/references/assertions](https://docs.cypress.io/guides/references/assertions))或使用IntelliSense
    IDE。'
- en: '![Figure 8.12: An IntelliSense pop-up of chainers](img/B21130_08_12.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12：链式调用器的IntelliSense弹出窗口](img/B21130_08_12.jpg)'
- en: 'Figure 8.12: An IntelliSense pop-up of chainers'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：链式调用器的IntelliSense弹出窗口
- en: A list of chainers is displayed automatically within your IDE while you write
    your test expectation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写测试预期时，链式调用器列表会自动显示在你的IDE中。
- en: Whether you use the documentation or the IDE, as shown in *Figure 8**.12*, all
    that really matters is that you familiarize yourself with these different chainers
    and understand what you can and cannot use.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用文档还是IDE，如图*图8**.12*所示，真正重要的是你要熟悉这些不同的链式调用器，并了解你可以使用什么，不能使用什么。
- en: 'In the preceding example, we just passed a single argument when calling the
    `should` method, but it can also accept two arguments. The second argument is
    used to pass a value when the condition defined in the first argument requires
    one. For example, we could be comparing the number of elements on screen with
    a variable, comparing two strings, or ensuring that the value returned by the
    API matches a specific object. In our current test, we just check that `<H1>`
    exists, but we are not really checking whether it is the correct heading, so we
    could change our implementation to use two arguments:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只是在调用`should`方法时传递了一个参数，但它也可以接受两个参数。第二个参数用于在第一个参数定义的条件需要传递值时传递一个值。例如，我们可能需要比较屏幕上元素的数量与一个变量，比较两个字符串，或者确保API返回的值与特定对象匹配。在我们的当前测试中，我们只是检查`<H1>`是否存在，但我们并没有真正检查它是否是正确的标题，因此我们可以将我们的实现更改为使用两个参数：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When using `contain.text`, we compare the `innerText` string of the element
    we selected with an arbitrary value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`contain.text`时，我们比较我们选择的元素的`innerText`字符串与一个任意值。
- en: 'The next step of our E2E test will be to ensure that the posts load successfully,
    by using the `get` method to fetch the element and the `have.length` chainer to
    ensure that the result value is what we expected:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们端到端（E2E）测试的下一步将是确保帖子成功加载，通过使用`get`方法获取元素和`have.length`链式调用器来确保结果值是我们预期的：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the application loads correctly, it will load five posts, and to check
    this in our test, we select all the elements that have a class of `SocialPost`
    and compare their lengths, using the `should('have.length',` `value)` syntax.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序正确加载时，它将加载五个帖子，为了在我们的测试中检查这一点，我们选择所有具有`SocialPost`类的元素，并使用`should('have.length',`
    `value)`语法比较它们的长度。
- en: Next, we will need to test the comment component. We will achieve this by clicking
    the `SocialPost.vue` component, we would find out that the best way to find the
    button is to use a large selector, `.SocialPost .interactions button`. This selector
    is not an optimal solution, not only because it is very verbose, but also because
    it is too dependent on the structure of the component and, therefore, very fragile.
    To avoid using complex selection, we can add an E2E attribute. This is usually
    defined by adding a `data-cy` attribute to an element and using it for testing
    purposes (`cy` in the data stands for cypress).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要测试评论组件。我们将通过点击`SocialPost.vue`组件来实现这一点，我们会发现找到按钮的最佳方式是使用一个大的选择器，`.SocialPost
    .interactions button`。这个选择器不是一个最佳解决方案，不仅因为它非常冗长，而且还因为它过于依赖于组件的结构，因此非常脆弱。为了避免使用复杂的选择器，我们可以添加一个端到端（E2E）属性。这通常是通过给一个元素添加一个`data-cy`属性并用于测试目的来定义的（`cy`在数据中代表cypress）。
- en: Adding a data attribute to your code will make your test more robust, avoiding
    the creation of flaky tests associated with changes in CSS classes and HTML element
    structure.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中添加一个数据属性将使你的测试更加健壮，避免与CSS类和HTML元素结构变化相关的易变测试的创建。
- en: 'Before continuing with our test, let’s open `SocialPost.vue` and add the required
    attribute:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续我们的测试之前，让我们打开 `SocialPost.vue` 并添加所需的属性：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`data-cy` is just a simple data attribute, but it is industry-standard and
    is used by many developers to provide a direct selector for E2E tests. We are
    now able to update our test to use the newly declared `showCommentButton` attributeto
    select our button:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-cy` 只是一个简单的数据属性，但它已成为行业标准，并被许多开发者用于为端到端测试提供直接选择器。我们现在能够更新我们的测试以使用新声明的
    `showCommentButton` 属性来选择我们的按钮：'
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since we have five posts on the page but just want to click on the first one,
    we will use a helper method called `first` that is used to retrieve just the first
    element returned by `get()`. Then, we end the chain by calling a `click` method
    to emulate a mouse click on the button. The result should be the comment component
    loaded.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们页面上有五篇帖子，但我们只想点击第一篇，我们将使用一个名为 `first` 的辅助方法来检索 `get()` 返回的第一个元素。然后，我们通过调用
    `click` 方法来结束链，模拟在按钮上点击鼠标。结果应该是加载的评论组件。
- en: If you check the browser window displaying our test runner, you should be able
    to see the `comment` component loaded in the first element.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查显示我们的测试运行器的浏览器窗口，你应该能够看到加载在第一个元素中的 `comment` 组件。
- en: '![Figure 8.13: A Cypress test showing the Companion App with the comments loaded](img/B21130_08_13.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13：Cypress测试显示已加载评论的Companion App](img/B21130_08_13.jpg)'
- en: 'Figure 8.13: A Cypress test showing the Companion App with the comments loaded'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：Cypress测试显示已加载评论的Companion App
- en: Next, we are going to use the knowledge we learned in the last section to test
    the correct rendering of posts with comments. As shown in *Figure 8**.13*, the
    first post has no comments. To better increase our coverage, we should also find
    a post with comments. A post with a comment is found in the last post (number
    5), so we can use that to ensure that the comments are correctly displayed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用上一节学到的知识来测试带有评论的帖子的正确渲染。如图 *图8.13* 所示，第一篇帖子没有评论。为了更好地提高我们的覆盖率，我们还应该找到一个带有评论的帖子。一个带有评论的帖子在最后一篇帖子（编号5）中找到，因此我们可以使用它来确保评论被正确显示。
- en: 'Based on what we have learned, we should be able to write a test that looks
    like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们所学的，我们应该能够编写一个看起来像这样的测试：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code displays three commands. The first checks the content of the social
    post comment component. We are using the main class, `.SocialPostComments`, to
    select the component and the `contain.text` command. This command checks the `innerText`
    string of that selector and compares it with a string that is passed as an argument.
    In our case, we passed `There are no comments for this post!`. Then, we clicked
    the last post by replicating the command we previously used and replaced `first()`
    with `last()`. Lastly, we again replicated the command we recently used to check
    the content of the string, and we checked the opposite by adding the word `not`
    in front of the chainer. It is common when creating E2E tests to have commands
    that test something (e.g., a string or a number), and then a command that tests
    that that assertion does not happen again. Because of this recurring scenario,
    the E2E framework provides you the ability to add the word `not` in front of the
    chainer to check for the opposite. So, if this `should('contain.text', 'hello')`
    checks whether the element includes the word `hello`, then `should('not.contain.text',
    'hello')` checks for the opposite – that is, to make sure that the element selected
    does not contain the word `hello`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显示了三个命令。第一个检查社交帖子评论组件的内容。我们使用主类 `.SocialPostComments` 来选择组件，并使用 `contain.text`
    命令。此命令检查该选择器的 `innerText` 字符串，并将其与作为参数传递的字符串进行比较。在我们的情况下，我们传递了 `There are no comments
    for this post!`。然后，我们通过复制之前使用的命令并替换 `first()` 为 `last()` 来点击最后一篇帖子。最后，我们再次复制我们最近使用的命令来检查字符串的内容，并通过在链式调用前添加单词
    `not` 来检查相反的情况。在创建端到端测试时，通常会有测试某个东西（例如，一个字符串或一个数字）的命令，然后是一个测试该断言不再发生的命令。由于这种重复出现的场景，端到端框架为您提供了在链式调用前添加单词
    `not` 的能力来检查相反的情况。因此，如果这个 `should('contain.text', 'hello')` 检查元素是否包含单词 `hello`，那么
    `should('not.contain.text', 'hello')` 就检查相反的情况——即确保选定的元素不包含单词 `hello`。
- en: This is the end of our E2E journey. In the next section, we are going to introduce
    advanced techniques that have not yet been covered in this chapter but may turn
    out to be very useful for your future testing experience.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们端到端旅程的结束。在下一节中，我们将介绍本章尚未涵盖但可能对您的未来测试体验非常有用的高级技术。
- en: Introducing advanced testing techniques
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍高级测试技术
- en: In this closing section, we will introduce a couple of extra topics that are
    part of testing but have not been covered in this chapter. As I mentioned at the
    start of this chapter, testing is a very large subject, and this was just a quick
    introduction to ensure that you will know how to get started and create simple
    tests. However, it is by no means a complete guide, and further learning is required.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的结尾，我们将介绍几个属于测试但在此章节中未涉及的主题。正如我在本章开头提到的，测试是一个非常大的主题，这只是一个快速介绍，以确保你知道如何开始并创建简单的测试。然而，这绝对不是一本完整的指南，还需要进一步的学习。
- en: The aim of this section is to explain a few aspects of testing that you may
    find in your future experience when creating E2E testing or unit testing. Some
    of this applies to both E2E and unit testing, while others are unique to a single
    testing methodology.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是解释一些你在未来创建端到端测试或单元测试时可能会遇到测试的方面。其中一些适用于端到端和单元测试，而其他则是单一测试方法的独特之处。
- en: Testing is a very interesting subject because what you learn about it is driven
    entirely by which you work. So, some people may have to learn how to write tests
    that heavily rely on external APIs and therefore focus on implementing stubs and
    mocks, while other developers may work on application that rely heavily on state
    management and may have to learn the ins and out of testing components that use
    state.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个非常有趣的主题，因为你所学到的关于测试的知识完全取决于你所从事的工作。因此，有些人可能需要学习如何编写高度依赖外部API的测试，因此专注于实现存根和模拟，而其他开发者可能从事依赖于状态管理的应用程序，可能需要学习使用状态测试组件的方方面面。
- en: 'Let’s dive in and share a few words on these three topics:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨，分享一些关于这三个主题的讨论：
- en: Mocking
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟
- en: Spying
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视
- en: '`shallowMount`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`浅层挂载`'
- en: We will start with mocking.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从模拟开始。
- en: Mocking
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟
- en: 'Mocking is a method used in both unit tests and E2E tests. The definition of
    mocking is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是单元测试和端到端测试中使用的两种方法。模拟的定义如下：
- en: “Mocking is a process used in testing to isolate and focus on the code being
    tested and not on the behavior or state of external dependencies, by emulating
    a method or object.”
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: “模拟是测试过程中用来隔离并集中关注被测试代码，而不是外部依赖的行为或状态，通过模拟方法或对象来实现。”
- en: There are some cases, when writing a test, where you may want to avoid the use
    of real services (methods or objects). For example, you may want to avoid creating
    an order at every test run or having to use a paid API to fetch some dummy data.
    Another example would be mocking native APIs like fetch and IntersectionObserver.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，有些情况下你可能想避免使用真实服务（方法或对象）。例如，你可能想在每次测试运行时避免创建订单，或者不得不使用付费API来获取一些模拟数据。另一个例子是模拟原生的API，如fetch和IntersectionObserver。
- en: To avoid these external dependencies, we can create a fake method or object
    that emulates the real third-party app or service. This is called **mocking**.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些外部依赖，我们可以创建一个模拟方法或对象来模拟真实的第三方应用或服务。这被称为**模拟**。
- en: Mocking is an essential technique used to ensure that your tests are scoped
    and do not rely on external factors.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是确保你的测试范围明确且不依赖于外部因素的一种基本技术。
- en: Spying
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视
- en: '**Spies** are very similar to mocking; in fact, they give you the ability to
    analyze the use of a specific method. This information can then be used in testing
    expectations – for example, being able to assert that a method was called *X*
    number of times. The main difference from mocking is that spies do not actually
    change the original method and just listen to its usage.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**间谍**与模拟非常相似；实际上，它们赋予你分析特定方法使用情况的能力。然后，这些信息可以用于测试预期——例如，能够断言一个方法被调用了*X*次。与模拟的主要区别在于，间谍实际上不会改变原始方法，只是监听其使用情况。'
- en: '**Spying** is very useful to ensure the correct execution of an application,
    without interfering with the actual methods. Adding a spy is very similar to using
    a proxy, where all requests for a spied method would first pass through the test
    framework.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**监视**对于确保应用程序的正确执行非常有用，而不会干扰实际的方法。添加监视器与使用代理非常相似，所有对监视方法的请求都会首先通过测试框架。'
- en: You may need to spy on an action in a store to ensure that it is called during
    the execution of your test, spy on a log method to ensure that the correct values
    are passed to it, or keep an eye on a global method within the window object.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要监视存储中的某个操作以确保它在测试执行期间被调用，监视日志方法以确保正确的值传递给它，或者关注窗口对象中的全局方法。
- en: While mocking is done to prevent us from using external services, spying is
    more aimed at providing us with a tool to make the correct assumption and assertion
    within a test.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化是为了防止我们使用外部服务，而监视（spying）则更多地旨在为我们提供一个工具，以便在测试中进行正确的假设和断言。
- en: Just like mocking, we can spy on methods and modules using tools provided by
    testing frameworks.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 就像虚拟化一样，我们可以使用测试框架提供的工具来监视方法和模块。
- en: shallowMount (unit tests only)
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: shallowMount（仅限单元测试）
- en: This last feature is available only in unit testing and, more precisely, to
    test components. In the *Unit testing with Vitest section*, we used the `mount`
    method to create an instance of our component, but there is another method available,
    called `shallowMount`, and in this section, we will explain the main difference
    between them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的功能仅适用于单元测试，更确切地说，是用于测试组件。在*使用 Vitest 进行单元测试*部分，我们使用了`mount`方法来创建组件的实例，但还有一个可用的方法，称为`shallowMount`，在本节中，我们将解释它们之间的主要区别。
- en: Unit testing is all about speed, and it is essential when writing a unit test
    to always choose the faster approach that uses fewer resources and completes the
    test quicker. One of these economies can come from how we initialize our components.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试全部关乎速度，在编写单元测试时，始终选择使用更少资源并更快完成测试的更快方法至关重要。这些经济性之一可能来自于我们初始化组件的方式。
- en: When using `mount`, Vue Test Utils renders the component and any other component
    included in it. So, running mount on `app.vue` would render the complete application
    within it. Because a unit test is expected to be focused on a specific unit, you
    may need to render only the component you are testing and not its children.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`mount`时，Vue Test Utils 会渲染组件及其包含的任何其他组件。因此，在`app.vue`上运行`mount`将渲染其中的完整应用程序。由于单元测试预期将专注于特定的单元，你可能只需要渲染你正在测试的组件，而不是其子组件。
- en: To achieve this, we can use `shallowMount`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以使用`shallowMount`。
- en: '`shallowMount` will render the component but then **stub** the children component
    by just rendering placeholder HTML. Doing so will reduce the resources needed
    by the test and make it more performant.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`shallowMount`将渲染组件，但随后通过仅渲染占位符HTML来**模拟**子组件。这样做将减少测试所需的资源，并使其性能更优。'
- en: Choosing which one to use is due to your preferences and the overall architecture
    of your app. I personally prefer to use `mount` for most of the components, ensuring
    that they load correctly even with their dependencies, and I rely on `shallowMount`
    for complex components with several children.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用哪一个取决于你的偏好和应用程序的整体架构。我个人更喜欢为大多数组件使用`mount`，以确保它们即使在依赖项的情况下也能正确加载，而对于具有多个子组件的复杂组件，我则依赖`shallowMount`。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the testing pyramid, covering the importance
    of tests and the different testing practices available within software development.
    We then moved on to unit tests and learned how to test our application using Vitest
    and Vue Test Utils. We then moved up to the testing pyramid and introduced E2E
    testing with Cypress. We created a small test that covered a simple user journey
    and learned a couple of techniques to select and test our application. Lastly,
    we closed the chapter with the introduction of future testing features that are
    part of the testing ecosystem and could be useful for future learning.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了测试金字塔，涵盖了测试的重要性以及软件开发中可用的不同测试实践。然后，我们转向单元测试，学习了如何使用 Vitest 和 Vue Test
    Utils 测试我们的应用程序。接着，我们上升到了测试金字塔，并介绍了使用 Cypress 的端到端测试。我们创建了一个覆盖简单用户旅程的小测试，并学习了一些选择和测试应用程序的技术。最后，我们通过介绍测试生态系统中的未来测试功能来结束本章，这些功能可能对未来的学习有所帮助。
- en: Your turn
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 轮到你了
- en: Spend a couple of hours trying and testing more components to learn more about
    unit tests and expand the user journey of our E2E tests. Make sure to read the
    official documentation that includes all the available commands for both testing
    frameworks and is the best resource to find what you need.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 花几个小时尝试和测试更多组件，以了解更多关于单元测试的知识，并扩展我们的端到端测试的用户旅程。确保阅读官方文档，其中包含了两个测试框架的所有可用命令，并且是查找所需信息的最佳资源。
- en: In the next chapter, we are going to introduce two advanced techniques called
    `slot` and `Refs`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍两个高级技术，称为`slot`和`Refs`。
