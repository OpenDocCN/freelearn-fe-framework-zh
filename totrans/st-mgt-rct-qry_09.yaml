- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: What Changes in React Query v5?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Query v5 的变更有哪些？
- en: At the time of writing, version 5.0.0-alpha.1 of @tanstack/react-query has just
    been released. While it might take a couple of weeks for the stable version to
    be released, when this book is published, it might already be the version that
    installs by default every time you add React Query to your project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，@tanstack/react-query 的 5.0.0-alpha.1 版本刚刚发布。虽然稳定版本可能需要几周时间才能发布，但本书出版时，它可能已经成为了每次将
    React Query 添加到您的项目时默认安装的版本。
- en: To make sure you understand the changes that the content of this book may undergo
    after v5 is released, this bonus chapter was added.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您理解在 v5 发布后本书内容可能经历的变化，我们添加了这一章作为额外内容。
- en: This chapter might also serve as a helper to guide you when migrating from v4
    to v5.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也可能作为从 v4 迁移到 v5 的辅助指南。
- en: Once again, as a disclaimer, *the snippets of this chapter were tested on version
    5.0.0-alpha.1 of @tanstack/react-query. Some of these things might still change,
    or some new ones might show up*. Either way, the snippets will be kept updated
    online in the next couple of months until a stable version is released. You can
    find them on the GitHub repository mentioned in the *Technical* *requirements*
    section.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 再次声明，*本章的代码片段是在 @tanstack/react-query 的 5.0.0-alpha.1 版本上测试的。其中一些内容可能仍然会发生变化，或者可能出现一些新的内容。无论如何，这些代码片段将在未来几个月内保持在线更新，直到稳定版本发布。您可以在
    *技术要求* 部分提到的 GitHub 仓库中找到它们。
- en: By the end of this chapter, you will be aware of all the changes in React Query
    v5 that will have an impact on some of the things in this book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解 React Query v5 中所有对本书中某些内容有影响的变化。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are the support changes?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持变更有哪些？
- en: Using only the object format
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用对象格式
- en: Removing the logger
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除记录器
- en: Renaming `loading` to `pending`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `loading` 重命名为 `pending`
- en: Renaming `cacheTime` to `gcTime`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `cacheTime` 重命名为 `gcTime`
- en: Renaming `Hydrate` to `HydrationBoundary`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Hydrate` 重命名为 `HydrationBoundary`
- en: Removing `keepPreviousData` and using `placeholderData`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除 `keepPreviousData` 并使用 `placeholderData`
- en: Introducing a new way to do optimistic updates
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入了一种新的乐观更新方式
- en: Introducing `maxPages` to infinite queries
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向无限查询引入 `maxPages`
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_9](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_9).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到：[https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_9](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_9)。
- en: What are the support changes?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持变更有哪些？
- en: 'The first thing to be aware of here is that the browser support has changed.
    From v5, your browser needs to be compatible with the following configurations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的第一件事是浏览器支持已发生变化。从 v5 开始，您的浏览器需要与以下配置兼容：
- en: The Google Chrome version needs to be at least version 84
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Chrome 版本需要至少为版本 84
- en: The Mozilla Firefox version needs to be at least version 90
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla Firefox 版本需要至少为版本 90
- en: The Microsoft Edge version needs to be at least version 84
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Edge 版本需要至少为版本 84
- en: The Safari version needs to be at least version 15
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Safari 版本需要至少为版本 15
- en: The Opera version needs to be at least version 70
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Opera 版本需要至少为版本 70
- en: Now that we know the support changes, let's see what features changed from v4
    to v5, starting with the object format for custom hooks and functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了支持变更，让我们看看从 v4 到 v5 的哪些功能发生了变化，首先是自定义钩子和函数的对象格式。
- en: Using only the object format
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅使用对象格式
- en: 'In v4 of React Query, most custom hooks and functions were overloaded to support
    previous patterns. This means that in your code, both of the `useQuery` hooks
    in the following snippet would be the same thing:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Query 的 v4 版本中，大多数自定义钩子和函数都被重载以支持之前的模式。这意味着在您的代码中，以下代码片段中的两个 `useQuery`
    钩子将是同一件事：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see from the preceding snippet, we create a query with `queryKey`
    `["api"]` and `queryFn` `fetchData` twice. This is because the second and first
    examples are just instances of the same hook that has been overloaded.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，我们两次创建了一个带有 `queryKey` `["api"]` 和 `queryFn` `fetchData` 的查询。这是因为第二个和第一个示例只是同一个被重载的钩子的实例。
- en: 'With the introduction of v5, the second example shown in the preceding snippet
    is no longer supported; therefore, you can only use your hooks by passing them
    a single object with the needed options. Here is the syntax that you need to follow
    from now on:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着v5的引入，前面代码片段中显示的第二个示例不再受支持；因此，您只能通过传递一个包含所需选项的单个对象来使用您的钩子。以下是您现在需要遵循的语法：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see from the preceding snippet, we have three React Query hooks,
    and each one of them receives a couple of things:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，我们有三组React Query钩子，并且每个钩子都接收一些东西：
- en: The `useQuery` and `useInfiniteQuery` hooks need to receive `queryKey` and `queryFn`
    as required parameters. These hooks allow you to pass them some of the options
    you should already know from the previous chapters.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useQuery`和`useInfiniteQuery`钩子需要接收`queryKey`和`queryFn`作为必需参数。这些钩子允许您传递一些您应该已经从上一章中了解到的选项。'
- en: The `useMutation` hook needs to receive `mutationFn` as a required parameter.
    It also allows you to pass it some of the options we learned about in [*Chapter
    6*](B18501_06.xhtml#_idTextAnchor159) when we saw what options our `useMutation`
    hook receives.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useMutation`钩子需要接收`mutationFn`作为必需参数。它还允许您传递一些我们在[*第6章*](B18501_06.xhtml#_idTextAnchor159)中了解到的选项，当时我们看到了`useMutation`钩子接收到的选项。'
- en: Luckily, throughout the book, we followed the object approach right from the
    beginning, so you should have followed the right approach from the start and won’t
    suffer much from the change.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在整个书中，我们从一开始就遵循了对象方法，所以您应该从一开始就遵循正确的做法，不会因为变化而受到太大影响。
- en: Another thing to be aware of is that this change applies to the `queryClient`
    functions. Functions such as `invalidateQueries`, `refetchQueries`, and `prefetchQuery`
    must also receive the expected object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意是，这个更改适用于`queryClient`函数。例如`invalidateQueries`、`refetchQueries`和`prefetchQuery`等函数也必须接收预期的对象。
- en: Now that you know about the single object format, we can look at one thing that
    was removed in v5 – `logger`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了单对象格式，我们可以看看v5中移除的一个东西——`logger`。
- en: Removing the logger
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除日志记录器
- en: Previously, React Query logged failed queries to the console in the production
    environment. This quickly became an issue because our application users could
    see implementation detail errors that they shouldn’t be aware of. To deal with
    this issue, the ability to create a custom logger was added, where you could override
    what React Query used for logging.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，React Query在生产环境中将失败的查询记录到控制台。这很快成为一个问题，因为我们的应用程序用户能看到他们不应该知道的实现细节错误。为了解决这个问题，添加了创建自定义日志记录器的功能，您可以通过它覆盖React
    Query用于日志记录的内容。
- en: Recently, React Query removed all logging in production and improved their development
    logs. Given this scenario, in v5, `logger` was no longer needed and was removed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，React Query在生产环境中移除了所有日志记录，并改进了开发日志。考虑到这种情况，在v5中，`logger`不再需要，已被移除。
- en: From now on, `console` will be used as the default logger.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，`console`将用作默认日志记录器。
- en: Now that you know this change, let's see the first renaming of v5 – `loading`
    to `pending`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道了这个更改，让我们看看v5的第一个重命名——将`loading`重命名为`pending`。
- en: Renaming loading to pending
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重命名loading为pending
- en: The `loading` status has caused some confusion. This is because most people
    associate it with data loading; secondly, if your query is disabled due to having
    the `enabled` option as `false`, it will show up as `loading`. To avoid more confusion
    and have a clearer name, the `loading` status has been renamed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`loading`状态引起了一些混淆。这是因为大多数人将其与数据加载相关联；其次，如果您的查询由于`enabled`选项设置为`false`而被禁用，它将显示为`loading`。为了避免更多的混淆并有一个更清晰的名字，`loading`状态已被重命名。'
- en: 'Here are the changes that have been applied:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是已应用的变化：
- en: The `loading` status has been renamed `pending`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading`状态已被重命名为`pending`'
- en: The derived `isLoading` status has been renamed `isPending`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生的`isLoading`状态已被重命名为`isPending`
- en: A new derived `isLoading` flag has been added, which basically translates as
    the `isPending &&` `isFetching` expression
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增了一个派生的`isLoading`标志，它基本上等同于`isPending && isFetching`表达式
- en: Considering that there was already a flag doing the same thing called `isInitialLoading`,
    the `isInitialLoading` flag has been deprecated
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到已经有一个名为`isInitialLoading`的标志在做同样的事情，`isInitialLoading`标志已被弃用
- en: 'Let us now review `ComponentA`, which we saw in [*Chapter 4*](B18501_04.xhtml#_idTextAnchor091),
    and apply these changes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在回顾一下在[*第4章*](B18501_04.xhtml#_idTextAnchor091)中看到的`ComponentA`，并应用这些更改：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see from the preceding snippet, all we have to do is rename `isLoading`
    `isPending`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，我们只需要将`isLoading`重命名为`isPending`。
- en: As for the behavior, it is also the same. What we have to be aware of here is
    that after the first query mounts when we don’t have data, our `status` query
    will be `pending` instead of `loading`, as it was previously.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 至于行为，也是一样的。我们需要注意的地方是，在第一次查询挂载后我们没有数据时，我们的`status`查询将是`pending`而不是`loading`，就像之前一样。
- en: With this in mind, we can move to the next renaming of v5 – `cacheTime` is now
    `gcTime`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以转向v5的下一个重命名——`cacheTime`现在变为`gcTime`。
- en: Renaming cacheTime to gcTime
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`cacheTime`重命名为`gcTime`
- en: This was one of the changes I’m most personally happy about because it is probably
    the most misunderstood option in React Query. Most often, it is assumed that `cacheTime`
    means the length of time that data will be cached instead of what it really means,
    which is the time that inactive data in the cache will remain in memory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我个人最开心的变化之一，因为它可能是React Query中最被误解的选项。通常，人们认为`cacheTime`意味着数据将被缓存的时间长度，而不是它真正代表的含义，即缓存中不活跃数据在内存中保持的时间。
- en: To stop this misconception, the `cacheTime` option has been renamed `gcTime`.
    This is because `gc` is often a shortened way to refer to the garbage collector.
    Therefore, from now on, we explicitly declare the time until our data is garbage-collected.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除这种误解，`cacheTime`选项已被重命名为`gcTime`。这是因为`gc`通常是垃圾回收器的缩写。因此，从现在起，我们明确声明数据被垃圾回收的时间。
- en: 'To use it, all you need to do is add the `gcTime` option to your `useQuery`/`useMutation`
    hook, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，你只需要将`gcTime`选项添加到你的`useQuery`/`useMutation`钩子中，如下所示：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the snippet, we define that after our query is inactive for one minute, the
    data will be garbage-collected.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我们定义了在查询不活跃一分钟之后，数据将被垃圾回收。
- en: To wrap up the renaming spree, let us see how our `Hydrate` component changed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结重命名狂潮，让我们看看我们的`Hydrate`组件是如何变化的。
- en: Renaming Hydrate to HydrationBoundary
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`Hydrate`重命名为`HydrationBoundary`
- en: When using the hydrate pattern in SSR, the `Hydrate` component was not fully
    descriptive about what it meant. To make it more concise and match other boundaries
    defined in TanStack Query, it was renamed `HydrationBoundary`. Due to this, you
    now have to rename it in your Next.js or Remix code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当在SSR中使用hydrate模式时，`Hydrate`组件并没有完全描述其含义。为了使其更加简洁并与其他在TanStack Query中定义的边界匹配，它被重命名为`HydrationBoundary`。因此，你现在需要在你的Next.js或Remix代码中将它重命名。
- en: Let us now see how the snippets change.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看代码片段是如何变化的。
- en: Next.js hydrate pattern renaming
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Next.js hydrate模式重命名
- en: 'This is what our Next.js `_app` component will look like now:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的Next.js `_app`组件现在的样子：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see from the preceding snippet, all we have to do is rename `Hydrate`
    to `HydrationBoundary`. Everything else remains the same.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，我们只需要将`Hydrate`重命名为`HydrationBoundary`。其他一切保持不变。
- en: Remix hydrate pattern changes
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Remix hydrate模式更改
- en: 'This is what our Remix root component will look like now:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的Remix根组件现在的样子：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see from the preceding snippet, and just as we saw in the Next.js
    example, all we have to do is rename `Hydrate` to `HydrationBoundary`. Everything
    else remains the same.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，就像我们在Next.js示例中看到的那样，我们只需要将`Hydrate`重命名为`HydrationBoundary`。其他一切保持不变。
- en: Now that you know this change, let us look at something that impacted how we
    do paginated queries.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了这个变化，让我们看看影响我们进行分页查询的方式的一些变化。
- en: Removing keepPreviousData and using placeholderData
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除`keepPreviousData`并使用`placeholderData`
- en: The `keepPreviousData` option and the `isPreviousData` flags have been removed.
    This is because they did almost the same task as the `placeholderData` option
    and the `isPlaceholderData` flag.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`keepPreviousData`选项和`isPreviousData`标志已被移除。这是因为它们几乎与`placeholderData`选项和`isPlaceholderData`标志执行相同的任务。'
- en: So that `placeholderData` can fully do exactly the same thing as `keepPreviousData`,
    the previous query data was added as an argument to the `placeholderData` function.
    This now means that by leveraging the `keepPreviousData` custom function from
    React Query, `useQuery` will allow `placeholderData` to work the same way as `keepPreviousData`
    did previously.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`placeholderData`能够完全执行与`keepPreviousData`完全相同的功能，之前的查询数据被添加为`placeholderData`函数的参数。这意味着通过利用React
    Query中的`keepPreviousData`自定义函数，`useQuery`将允许`placeholderData`以与之前`keepPreviousData`相同的方式工作。
- en: 'Let us see how our `PaginatedQuery` code changes in v5:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的`PaginatedQuery`代码在v5中的变化：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding snippet, we changed our `PaginatedQuery` component to adapt
    to the changes necessary due to the removal of the `keepPreviousData` option.
    This is what we do:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将我们的`PaginatedQuery`组件更改为适应由于删除`keepPreviousData`选项而必要的更改。这是我们所做的：
- en: We import our `keepPreviousData` helper from React Query.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从React Query导入我们的`keepPreviousData`辅助函数。
- en: Since we need to refactor the component, we rename `isLoading` to `isPending`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要重构组件，我们将`isLoading`重命名为`isPending`。
- en: We rename `isPreviousData` to `isPlaceholderData`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`isPreviousData`重命名为`isPlaceholderData`。
- en: We rename the `keepPreviousData` option to `placeholderData` and pass it the
    `keepPreviousData` helper.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`keepPreviousData`选项重命名为`placeholderData`，并传递`keepPreviousData`辅助函数。
- en: Now, v5 did not only remove and rename things. It also added some new things,
    including a new way to perform optimistic updates.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，v5不仅删除和重命名了一些东西，还增加了一些新功能，包括一种新的执行乐观更新的方法。
- en: Introducing a new way to perform optimistic updates
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍一种新的执行乐观更新的方法
- en: When performing optimistic updates, you must always be careful about the changes
    you make to your cache. One typo or mistake might accidentally impact other queries
    outside of the one you want to change initially.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行乐观更新时，你必须始终小心你对缓存所做的更改。一个打字错误或错误可能会意外影响你最初想要更改之外的其他查询。
- en: Fortunately, with v5, TanStack Query has introduced a way to perform optimistic
    updates where you can fully rely on your UI and stop changing your cache.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，随着v5的发布，TanStack Query引入了一种执行乐观更新的方法，你可以完全依赖你的UI并停止更改你的缓存。
- en: 'Let us see how:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding snippet, we can see the new way React Query allows us to perform
    optimistic updates. This is what we do:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到React Query允许我们执行乐观更新的新方法。这是我们所做的：
- en: Create state variables and respective setters for the name and age inputs.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建姓名和年龄输入的状态变量及其相应的设置器。
- en: Get access to our `queryClient`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取我们的`queryClient`访问权限。
- en: Create our query, using the query factory `all` function to give us the query
    key and `fetchAllData` as the `query` function.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用查询工厂`all`函数创建我们的查询，以提供查询键和`fetchAllData`作为`query`函数。
- en: Create our mutation, using `createUser` as the mutation function. Inside this
    mutation, we leverage the `onSettled` callback to invalidate our query.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的突变，使用`createUser`作为突变函数。在这个突变内部，我们利用`onSettled`回调来使我们的查询无效。
- en: 'In our component return, we create `div` with the following:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的组件返回中，我们创建以下`div`：
- en: We use `data` from our query to display our users’ data.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用查询的`data`来显示用户的资料。
- en: We use our mutation `isPending` flag to let us know whether we have any mutation
    currently being performed. If this flag is `true`, we can access and render our
    `mutation` variables on the DOM.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用我们的突变`isPending`标志来告诉我们是否当前有任何突变正在执行。如果这个标志是`true`，我们就可以访问和渲染我们的`mutation`变量在DOM上。
- en: We create our controlled form with our name and age inputs.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用我们的姓名和年龄输入创建我们的受控表单。
- en: We also create a button that, upon `onClick`, will trigger our mutation with
    our name and age values.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还创建了一个按钮，当点击时，将触发我们的突变，并带上我们的姓名和年龄值。
- en: As you can see now, we can perform mutations without changing our query cache
    data. This is super powerful and can save you a lot of unintentional headaches
    caused by messing up your cache.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如你现在所看到的，我们可以执行突变而不改变我们的查询缓存数据。这非常强大，可以节省你因搞乱缓存而造成的许多无意中的头疼。
- en: By checking the code of the preceding snippet, one thing you might wonder is
    whether the mutation lives on the same component as the query. Does this mean
    that if you have a mutation that lives outside of the same place of your query,
    you won’t be able to perform optimistic updates this way? It does not.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查前面的代码片段，你可能想知道突变是否与查询位于同一组件上。这意味着如果你有一个位于查询不同位置的突变，你将无法以这种方式执行乐观更新吗？不是的。
- en: If you have a mutation performing somewhere else and want to perform an optimistic
    update, you can leverage the `useMutationState` custom hook.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在别处执行一个突变并执行乐观更新，你可以利用`useMutationState`自定义钩子。
- en: 'Here is how:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何做的：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding snippet, we have the `NewOptimisticMutationV2` component. In
    this component, we perform an optimistic update outside the component where your
    mutation lives. In this component, we render our query data and have the component
    where our mutation happens, called `MutationForm`, rendered as a child component.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有`NewOptimisticMutationV2`组件。在这个组件中，我们在突变所在的组件外部执行乐观更新。在这个组件中，我们渲染我们的查询数据，并将我们的突变发生的组件`MutationForm`作为子组件渲染。
- en: 'Here is what we do in the `NewOptimisticMutationV2` component:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NewOptimisticMutationV2`组件中，我们这样做：
- en: Create our query, using our query factory `all` function to give us the query
    key and `fetchAllData` as the `query` function.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的查询工厂`all`函数创建我们的查询，以提供查询键，并将`fetchAllData`作为`query`函数。
- en: Get access to our mutation by using the `useMutationState` hook.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`useMutationState`钩子来获取我们的突变。
- en: With this hook, we access a mutation currently with the pending status and the
    `mutationKey` `userKeys.userMutation()` that comes from our query factory.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过此钩子，我们访问当前具有挂起状态的突变，以及来自查询工厂的`mutationKey` `userKeys.userMutation()`。
- en: Then, leverage the `select` option from the `useMutationState` hook to get the
    `mutation` variables and the `submittedAt` property.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，利用`useMutationState`钩子的`select`选项来获取`mutation`变量和`submittedAt`属性。
- en: 'In our component return, we create a `div` with the following:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的组件返回中，我们创建了一个`div`，如下所示：
- en: We use `data` from our query to display our users’ data.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用查询的`data`来显示我们的用户数据。
- en: If we have any mutation currently being performed, we can access and render
    our `mutation` variables on the DOM.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在有任何正在执行的突变，我们可以访问和渲染DOM上的`mutation`变量。
- en: 'I mentioned in the previous description that the mutation needs to have `mutationKey`
    to be able to be found. This is how to add it to your mutation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的描述中，我提到突变需要`mutationKey`才能被找到。这就是如何将其添加到您的突变中的方法：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see from the preceding snippet, we added the `userKeys.userMutation()`
    key from our query factory and added it to our `useMutation` hook’s `mutationKey`
    property.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中可以看到，我们从查询工厂添加了`userKeys.userMutation()`键，并将其添加到`useMutation`钩子的`mutationKey`属性中。
- en: Now that you know about the new way to perform optimistic updates, let us see
    what changed in our infinite queries.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了执行乐观更新的新方法，让我们看看我们的无限查询发生了什么变化。
- en: Introducing maxPages to infinite queries
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍无限查询的最大页面数
- en: Infinite queries is an amazing pattern that helps you build infinite lists.
    However, there is one issue with it before v5 – all the fetched pages are cached
    in memory; therefore, the more pages you see, the more memory you consume.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 无限查询是一个帮助您构建无限列表的惊人模式。然而，在v5版本之前，它有一个问题——所有获取的页面都缓存在内存中；因此，您看到的页面越多，消耗的内存就越多。
- en: To prevent this from happening and improve your user experience, the `maxPages`
    option was added to the `useInfiniteQuery` hook. This option limits the number
    of pages that will be stored in the query cache.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生并提高用户体验，`maxPages`选项被添加到`useInfiniteQuery`钩子中。此选项限制了将存储在查询缓存中的页面数。
- en: 'This is what our infinite query example, seen in [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140),
    would look like now:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的无限查询示例，如[*第五章*](B18501_05.xhtml#_idTextAnchor140)中所示，现在的样子：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding snippet, we can see our infinite query code refactor after
    v5 and leverage the `maxPages` option. Here is what changed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个代码片段中，我们可以看到v5之后的无限查询代码重构，并利用了`maxPages`选项。以下是变化的内容：
- en: We use `isPending` instead of `isLoading`
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`isPending`而不是`isLoading`
- en: The `defaultPageParam` option indicates which is the default page that React
    Query will use to fetch the first page. This option is now required, so it was
    added.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`defaultPageParam`选项指示React Query将使用哪个默认页面来获取第一页。此选项现在是必需的，因此已添加。'
- en: We add `5` as our `maxPages` option. This means that only five pages will be
    stored in memory. Since we use this option, the `getPreviousPageParam` option
    is now required so that React Query can fetch pages in both directions if needed.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`5`作为`maxPages`选项。这意味着只有五页将被存储在内存中。由于我们使用了此选项，因此现在需要`getPreviousPageParam`选项，以便React
    Query在需要时可以双向获取页面。
- en: With this, we have now wrapped up all the relevant changes in React Query v5
    that might impact this book.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在已经封装了所有可能影响这本书的React Query v5的相关更改。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about all the changes v5 might bring to React Query.
    By now, you should know about the support changes you will need to be aware of
    in your browser and understand why we’ve always followed the object format throughout
    the book.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了v5可能给React Query带来的所有变化。到现在为止，您应该知道您需要在浏览器中注意的支持更改，并理解为什么我们一直在整本书中遵循对象格式。
- en: You’ve seen why `logger` was removed and understand why renaming `loading` to
    `pending` makes more sense.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了为什么移除`logger`，并理解为什么将`loading`重命名为`pending`更有意义。
- en: Speaking of renaming, you won’t be confused again because `gcTime` is a more
    accurate word than `cacheTime`, and `HydrationBoundary` represents better what
    it does than `Hydrate`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 说到重命名，您不会再感到困惑了，因为 `gcTime` 比 `cacheTime` 更准确，而 `HydrationBoundary` 更好地代表了它的功能，比
    `Hydrate` 更为恰当。
- en: You’ve learned that for paginated queries, the `placeholderData` option is the
    way to go and that `keepPreviousData` was removed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解到，对于分页查询，`placeholderData` 选项是最佳选择，而 `keepPreviousData` 已被移除。
- en: Finally, you were introduced to a new way to perform optimistic updates without
    updating your cache and found a way to save memory in your infinite queries, by
    leveraging the `maxPages` option.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您了解了一种新的执行乐观更新而不更新缓存的方法，通过利用 `maxPages` 选项，您还找到了在无限查询中节省内存的方法。
- en: As you may recall from what I said previously, this was tested in an alpha version
    of React Query, so some of these things might still change.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从之前我说的话中回忆起来，这是在 React Query 的 alpha 版本中进行的测试，所以其中一些事情可能仍然会改变。
- en: It is exciting to see some of these changes, as they progressively improve the
    library.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这些变化真是令人兴奋，因为它们逐渐改进了这个库。
- en: Personally, I can’t wait to see what comes next to TanStack Query. With every
    new version, it always finds a new way to make my life easier when dealing with
    server state. Hopefully, it will do the same for you from now on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我迫不及待地想看到 TanStack Query 接下来的发展。随着每个新版本的推出，它总是找到一种新的方法让我的服务器状态处理变得更简单。希望从现在开始，它也能为您做到同样的事情。
