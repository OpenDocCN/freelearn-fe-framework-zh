- en: Applying Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用依赖注入
- en: In this chapter, you will learn about Angular Dependency Injection. Dependency
    Injection is one of the most striking features in Angular; it allows us to create
    injectables that can be used as shared resources between various components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习关于Angular依赖注入。依赖注入是Angular中最引人注目的特性之一；它允许我们创建可注入对象，可以在各种组件之间作为共享资源使用。
- en: 'In this chapter, we will discuss the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: Exploring Dependency Injection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索依赖注入
- en: Learning about provider classes in detail
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细了解提供者类
- en: Understanding hierarchical Dependency Injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解分层依赖注入
- en: Creating an Injectable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可注入对象
- en: Learning to inject providers into services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习将提供者注入到服务中
- en: Learning to inject providers inside the components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习将提供者注入到组件中
- en: Learning to resolve dependencies for a provider class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习为提供者类解析依赖项
- en: Creating examples using the `@Inject`, `provide`, and `useValue` decorators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Inject`、`provide`和`useValue`装饰器创建示例
- en: Applications without Dependency Injection
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有依赖注入的应用程序
- en: 'Without the Dependency Injection framework, the life of a developer would be
    very tough. Take a look at the following drawbacks of not using Dependency Injection:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有依赖注入框架，开发人员的生活将非常艰难。看看不使用依赖注入的以下缺点：
- en: Every time a constructor parameter needs to be passed, we will need to edit
    the constructor definition of the class in all instances
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次需要传递构造函数参数时，我们都需要编辑类的构造函数定义
- en: We will need to create constructors and inject each of the required dependency
    classes individually
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要创建构造函数，并单独注入每个所需的依赖类
- en: 'Let''s take a look at an application without Dependency Injection to understand
    the challenges and shortfalls:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个没有依赖注入的应用程序，以了解其中的挑战和不足之处：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s analyze the preceding code snippet to understand better:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析前面的代码片段以更好地理解：
- en: We created a `class` named `products`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`products`的`class`。
- en: In the `constructor` method, we instantiated the dependent classes, `warehouse`
    and `category`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`constructor`方法中，我们实例化了依赖类`warehouse`和`category`。
- en: Note that, if the `warehouse` or `category` class constructor definition changes,
    we will need to update manually all the instances of the classes.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，如果`warehouse`或`category`类的构造函数定义发生更改，我们将需要手动更新所有类的实例。
- en: The preceding code is not fully testable and maintainable since as a developer
    our task would be to manually define all the dependencies. That's where Angular
    Dependency Injection comes for our rescue.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于作为开发人员，我们的任务是手动定义所有依赖项，因此前面的代码并不完全可测试和可维护。这就是Angular依赖注入的用武之地。
- en: Dependency Injection - Introduction
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入 - 介绍
- en: '**Dependency Injection**(**DI**) is a coding pattern in which a class receives
    dependencies rather than creating them itself. Some developers and technology
    mavericks also refer to this as a design pattern.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）是一种编码模式，其中一个类接收依赖项而不是自己创建它们。一些开发人员和技术狂人也将其称为设计模式。'
- en: It's widely used and is often called DI. We will refer to the Dependency Injection
    system as DI in all our sections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它被广泛使用，通常被称为DI。我们将在所有章节中将依赖注入系统称为DI。
- en: 'Here''s why we absolutely need DI:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们绝对需要DI的原因：
- en: DI is a software design pattern in which a class receives its dependencies rather
    than creating the object itself
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DI是一种软件设计模式，其中一个类接收其依赖项而不是创建对象本身
- en: DI creates and delivers objects, which are required dynamically just-in-time
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DI创建并提供动态所需的对象
- en: We can consider the injectables as our application's reusable repository
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将可注入对象视为应用程序的可重用存储库
- en: DI allows independent development of dependency modules for remote development
    teams.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DI允许远程开发团队独立开发依赖模块。
- en: 'No Angular apps can be completely written without using DI.Now, let''s revisit
    the preceding code we wrote without DI and write it with Angular DI:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用DI，无法完全编写任何Angular应用程序。现在，让我们重新审视一下之前没有使用DI编写的代码，并使用Angular DI编写它：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s what is happening in the preceding code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中发生了什么：
- en: We have created a `products` class.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`products`类。
- en: In the `constructor`, we passed the dependent classes--`warehouse` and `category`--as
    parameters.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`constructor`中，我们将依赖类--`warehouse`和`category`--作为参数传递。
- en: We can now use the instances, `_warehouse` and `_category` throughout the class.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在整个类中使用实例`_warehouse`和`_category`。
- en: Note that we have not created the objects of the dependent classes; instead
    we just receive them through the DI system.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们没有创建依赖类的对象；相反，我们只是通过DI系统接收它们。
- en: We don't have to worry about the dependencies required by `warehouse` or `category`;
    that will be internally resolved by Angular DI.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不必担心`warehouse`或`category`所需的依赖关系；这将由Angular DI在内部解决。
- en: Now that we know what Angular DI is, let's focus on how it's implemented and
    used in our Angular applications. Before we jump into learning about provider
    classes and more, we should know some of the basic things about the Angular DI
    framework.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了什么是Angular DI，让我们专注于它是如何在我们的Angular应用程序中实现和使用的。在学习提供者类和更多内容之前，我们应该了解一些关于Angular
    DI框架的基本知识。
- en: 'We will, of course, cover these in detail in the next few sections. It''s good
    to have a basic understanding:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将在接下来的几节中详细介绍这些。了解基本概念是很好的：
- en: '`@Injectable`: This decorator marks a class as available to an injector for
    instantiation.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Injectable`：这个装饰器标记一个类可供注入器实例化。'
- en: '`@Inject:` Using the `@Inject` decorator, we can inject the configuration object
    into any constructor that needs it.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Inject`：使用`@Inject`装饰器，我们可以将配置对象注入到任何需要它的构造函数中。'
- en: '`Provider:` A Provider is a way by which we register our dependencies that
    need to be injected.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Provider`：提供者是我们注册需要注入的依赖项的方式。'
- en: Now let's jump into learning about provider classes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始学习提供者类。
- en: Understanding provider classes
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解提供者类
- en: To start using DI in our applications, we will need to understand the concept
    of Providers. Providers configuration in the component decorator tells Angular
    which classes need to be provided to the component.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中开始使用DI，我们需要了解提供者的概念。组件装饰器中的提供者配置告诉Angular需要提供哪些类给组件。
- en: In the provider configuration, DI takes an array of all the classes i.e injection
    tokens, we want to provide to the component. We can also specify the `class` using
    `useClass` to instantiate for the registered token.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供者配置中，DI接受一个类的数组，即我们要提供给组件的注入标记。我们还可以使用`useClass`指定要为注册的标记实例化的`class`。
- en: 'Take a quick look at the syntax for using the providers configuration:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看使用提供者配置的语法：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we are telling Angular that the preceding component needs
    to be provided by the `MyTax` class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们告诉Angular前面的组件需要由`MyTax`类提供。
- en: 'The following are the advantages of using the provider classes:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用提供者类的优点：
- en: Providers are maintained per injector
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者是每个注入器维护的
- en: Each `provider` provides a single instance of an Injectable
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`provider`提供一个Injectable的单个实例
- en: The provider class provides the return value of the method invoked
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者类提供了调用方法的返回值
- en: We can also explicitly mention the class that should be used from the service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以明确提到应该从服务中使用的类。
- en: 'Here''s the general syntax:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一般的语法：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, we are explicitly telling Angular to inject the
    `MyTax` provider and use the `MyTax` class using the `useClass` configuration.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们明确告诉Angular注入`MyTax`提供者并使用`useClass`配置使用`MyTax`类。
- en: 'Let''s learn more about how the provider classes can be registered and used;
    let''s take a look at the following diagram:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更多地了解提供者类如何注册和使用；让我们看一下以下的图表：
- en: '![](assets/83f23e5f-5248-4111-8acf-78d7a2cf2e18.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/83f23e5f-5248-4111-8acf-78d7a2cf2e18.png)'
- en: 'Let''s analyze the preceding diagram in detail to learn the key take-away:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的图表，以了解关键要点：
- en: Components shared resources are provided via the provider class
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件共享资源是通过提供者类提供的
- en: Provider classes can be registered into multiple components(one or more)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者类可以注册到多个组件中（一个或多个）
- en: We can also register a provider class into other provider classes
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以将提供者类注册到其他提供者类中
- en: 'In the preceding diagram, `Component #1` has a dependency on ``Provider Class
    #1``'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的图表中，`组件＃1`依赖于`提供者类＃1`
- en: 'In the preceding diagram, `Component #2` has a dependency on `Provider Class
    #1` and `Provider Class #2`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的图表中，`组件＃2`依赖于`提供者类＃1`和`提供者类＃2`
- en: 'In the preceding diagram, `Component #3` has a dependency on `Provider Class
    #2` and `Provider Class #3`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的图表中，`组件＃3`依赖于`提供者类＃2`和`提供者类＃3`
- en: By now, we understand how critical DI is for our applications. DI really helps
    in organizing data and is the most suitable design pattern for implementing individual
    independent modules or components.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们了解了DI对我们的应用程序有多么关键。DI确实有助于组织数据，并且是实现独立模块或组件的最合适的设计模式。
- en: The idea is to keep components developed independently and write more generic
    shared or commonly used functionality in providers or injectables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是保持组件独立开发，并在提供者或可注入的地方编写更通用的共享或常用功能。
- en: 'Let''s create a quick example of a provider class, which can be injected in
    a component. We create a provider class--the `MyTax.ts` file--and add the following
    code snippet to it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速创建一个提供者类的示例，它可以被注入到一个组件中。我们创建一个提供者类--`MyTax.ts`文件--并添加以下代码片段：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s analyze the preceding code snippet in detail:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码片段：
- en: We created a provider class named `MyTax`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`MyTax`的提供者类。
- en: We defined a `taxValue` variable as number.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将一个`taxValue`变量定义为数字。
- en: We created a `getTaxes` method, which will return a random number.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`getTaxes`方法，它将返回一个随机数。
- en: We assigned a value to the `taxValue` variable and returned the value via the
    `getTaxes` method.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们给`taxValue`变量赋值，并通过`getTaxes`方法返回值。
- en: Now, we need to register this provider class in our component's providers array
    configuration and display the value of `taxValue`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们组件的提供者数组配置中注册这个提供者类，并显示`taxValue`的值。
- en: 'We will need to create a `component` class--`calculate-tax.component.ts` and
    add the following lines of code to it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个`component`类--`calculate-tax.component.ts`，并添加以下代码行：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s analyze the preceding code in detail :'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码：
- en: We imported the recently created provider class--`MyTax`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入了最近创建的提供者类--`MyTax`。
- en: We created and defined the `CalculateTax` component.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建并定义了`CalculateTax`组件。
- en: We defined a `taxName` variable and mapped the variable in the template using
    data binding.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`taxName`变量，并使用数据绑定在模板中映射了这个变量。
- en: In the constructor, we registered `MyTax` in the providers array of the application
    module, `MyTax`, and Angular DI will create an instance of the provider class
    and assign it to `_myTax`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们在应用程序模块的提供者数组中注册了`MyTax`，Angular DI将创建提供者类的实例并将其分配给`_myTax`。
- en: Using the instance of the provide class, we called the `getTaxes` method.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供类的实例，我们调用了`getTaxes`方法。
- en: 'Run the app, and we should see the output shown in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，我们应该看到以下截图中显示的输出：
- en: '![](assets/f9a54e14-86e4-487f-ad91-483d138c8b83.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f9a54e14-86e4-487f-ad91-483d138c8b83.png)'
- en: In this section, you learned how to create provider classes and register them
    in components to use them. You can register the same provider class into multiple
    components; this is certainly ideal in cases where we want to share multiple reusable
    methods.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何创建提供程序类并在组件中注册它们以供使用。您可以将相同的提供程序类注册到多个组件中；在我们想要共享多个可重用方法的情况下，这无疑是理想的。
- en: In the next section, you will learn about hierarchical DI--when we have multiple
    nested components.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习有关分层DI的知识--当我们有多个嵌套组件时。
- en: Understanding hierarchical DI
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解分层DI
- en: In the preceding section, we covered DI through provider classes and also sharing
    the provider classes between various individual components. In this section, you
    will learn how to use provider classes with DI between hierarchical components.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们介绍了通过提供程序类进行DI，还介绍了在各个独立组件之间共享提供程序类。在本节中，您将学习如何在分层组件之间使用带有DI的提供程序类。
- en: Angular internally creates an index tree tracing all the components and tree
    structure being created and also maintaining its dependency matrix, which gets
    loaded in real time to provide all the necessary modules, services, and components.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在内部创建了一个索引树，跟踪所有组件和正在创建的树结构，并维护其依赖矩阵，该矩阵在实时加载以提供所有必要的模块、服务和组件。
- en: The best part about hierarchical components and DI among the various components
    is that we don't have to worry about how those dependencies are created, or what
    dependencies they need themselves internally.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 分层组件和各种组件之间的DI最好的部分是，我们不必担心这些依赖项是如何创建的，或者它们自身内部需要什么依赖项。
- en: Overview - Hierarchical components and DI
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述-分层组件和DI
- en: It's an open secret that Angular internally maintains the tree structure of
    components. It also maintains the tree index of dependencies.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Angular内部维护组件的树结构是一个公开的秘密。它还维护依赖项的树索引。
- en: In any real-world Angular application, we will work with many components and
    services. The components will have a tree structure ranging from a root component
    to child components and inner child components, and so on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何真实的Angular应用程序中，我们将使用许多组件和服务。这些组件将具有从根组件到子组件和内部子组件等的树结构。
- en: That forms a component tree structure internally. Since our components will
    also have dependencies and injectables, Angular will internally form a dependency
    tree matrix to track and resolve all the dependencies required for a service or
    component.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这在内部形成了一个组件树结构。由于我们的组件也将具有依赖项和可注入项，Angular将在内部形成一个依赖项树矩阵，以跟踪和解析服务或组件所需的所有依赖项。
- en: 'The following are the key things you need to know about hierarchical DI:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您需要了解有关分层DI的关键事项：
- en: The Angular framework internally creates a hierarchical tree structure for DI
    for components
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular框架在内部为组件创建了一个分层树结构的DI
- en: The provider class needs to be registered into the component
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供程序类需要注册到组件中
- en: We can register a provider class to be registered into other provider classes
    as well
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将提供程序类注册到其他提供程序类中
- en: In the next section, you will create injectable services and also use them in
    your components.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将创建可注入的服务，并在组件中使用它们。
- en: Creating an injectable
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可注入项
- en: We don't have to create an Angular injector, it's injected by default. Angular
    creates an application-wide injector during the bootstrap process.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必创建Angular注入器，它是默认注入的。Angular在引导过程中创建了一个应用程序范围的注入器。
- en: We define an injectable using the `@Injectable` decorator and define the methods
    in the class. `@Injectable` makes a class available to an injector for instantiation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@Injectable`装饰器定义可注入的类，并在类中定义方法。`@Injectable`使得一个类可以被注入器实例化。
- en: 'The following is sample code to create an `@Injectable` service:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建`@Injectable`服务的示例代码：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s analyze the code snippet in detail:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析代码片段：
- en: We have imported `Injectable` from the Angular core module.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从Angular核心模块中导入了`Injectable`。
- en: We used the `@Injectable` decorator to tell Angular that the following class
    can be injected and is available to an injector for instantiation.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`@Injectable`装饰器告诉Angular以下类可以被注入，并且可以被注入器实例化。
- en: We have created a class called `ListService`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`ListService`的类。
- en: We implemented a method called `getList`, which at this point is just print
    a message in `console.log`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个名为`getList`的方法，目前只是在`console.log`中打印一条消息。
- en: Registering providers
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册提供者
- en: An injector creates dependencies using providers. Providers are required to
    be registered into the consuming services or components. By registering them,
    the provider class allows us to create independent reusable features and functionalities
    by individual team members.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注入器使用提供者创建依赖项。提供者需要在消费服务或组件中注册。通过注册它们，提供者类允许我们创建独立的可重用功能，可以由各个团队成员使用。
- en: 'Configuring and registering provider classes also allows to break down functionalities
    into smaller modules, which are easy to maintain and modify. We can register provider
    classes into services and components in different ways. Important points to always
    keep in mind about injectors are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 配置和注册提供者类还可以将功能分解为更小的模块，这样更容易维护和修改。我们可以以不同的方式将提供者类注册到服务和组件中。关于注入器，始终要牢记的重要点如下：
- en: We have to create a provider in our `NgModule`, component constructor, or in
    a directive
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须在我们的`NgModule`、组件构造函数或指令中创建一个提供者
- en: Register the service in the component's constructor
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件的构造函数中注册服务
- en: 'We have created a `ListService` service in the preceding section, which has
    a method and can now be registered and used in multiple components:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分创建了一个`ListService`服务，它有一个方法，现在可以被注册并在多个组件中使用：
- en: '![](assets/c704df8b-daba-4919-a49d-651c9aac5750.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c704df8b-daba-4919-a49d-651c9aac5750.png)'
- en: 'Let''s analyze the preceding diagram in detail to understand the use case we
    are building:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的图表，以了解我们正在构建的用例：
- en: We will create an `Injectable` service class, `ListService`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个`@Injectable`服务类`ListService`。
- en: We will create a component, `TestDiComponent`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`TestDiComponent`的组件。
- en: We will need to register `ListService` into `TestDiComponent`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`ListService`注册到`TestDiComponent`中。
- en: 'So, now let''s jump right into learning how to register a provider in `ngModule`.
    Take a look at the `ngModule` file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在让我们立即开始学习如何在`ngModule`中注册提供者。看一下`ngModule`文件：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In shorthand, the preceding code is often written as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，上面的代码通常写成如下形式：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s analyze the preceding code snippet in detail:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码片段：
- en: We have imported the `ListService` service class into the `ngModule`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经将`ListService`服务类导入到`ngModule`中。
- en: Note that we registered the `ListService` in providers. Angular will internally
    resolve and create an injector at runtime.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们在提供者中注册了`ListService`。Angular将在运行时内部解析并创建一个注入器。
- en: In the shorthand notation, we just mention the name of the provider, and Angular
    will map the `provide` property to register and use the value of `useClass`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在简写表示法中，我们只提到提供者的名称，Angular将`provide`属性映射到`useClass`的值以进行注册和使用。
- en: In the preceding section, you learned how to register services in the provider's
    configuration array in `ngModule`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您学会了如何在`ngModule`的提供者配置数组中注册服务。
- en: The main difference between registering a provider in AppModule versus registering
    it in a component is the visibility of the service. Services registered in AppModule
    are available throughout the application, and services registered inside a specific
    component will be available only inside the component.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在AppModule中注册提供者与在组件中注册提供者的主要区别在于服务的可见性。在AppModule中注册的服务在整个应用程序中都可用，而在特定组件内注册的服务只在该组件内可用。
- en: Registering providers inside the component
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组件内注册提供者
- en: Now, you will learn how to register a provider in a component and use the injectable
    service class inside a component.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将学习如何在组件中注册提供者并在组件内使用可注入的服务类。
- en: 'First, let''s quickly generate a component and service using the Angular CLI
    `ng` command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用Angular CLI的`ng`命令快速生成一个组件和服务：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will generate the component and the required files. The output of the
    command is shown in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成组件和所需的文件。命令的输出如下所示：
- en: '![](assets/595fdc54-26b2-479d-b3ac-fe37cd602dbc.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/595fdc54-26b2-479d-b3ac-fe37cd602dbc.png)'
- en: 'Now, we have to generate an Angular service in the same folder:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在同一文件夹中生成一个Angular服务。
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](assets/780cb6e8-5539-4bf4-b567-1c59b36c5e47.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/780cb6e8-5539-4bf4-b567-1c59b36c5e47.png)'
- en: We see that Angular CLI generates a warning message that the service is generated
    but not provided.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到Angular CLI生成了一个警告消息，指出服务已生成但未提供。
- en: So far, we have created our component and service separately, but now we need
    to register the providers in our component so that we can use the service.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经分别创建了组件和服务，但现在我们需要在组件中注册提供者，以便我们可以使用该服务。
- en: Before we proceed to register the providers in our component, let's take a quick
    look at the service code generated by the CLI tool.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续在组件中注册提供者之前，让我们快速查看一下CLI工具生成的服务代码。
- en: 'Here''s our `test-di.service.ts` file code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`test-di.service.ts`文件代码：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That''s the default code generated by the scaffolding Angular CLI tool. Let''s
    add a method, which we want to access inside the component:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由脚手架Angular CLI工具生成的默认代码。让我们添加一个我们想在组件内访问的方法：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let''s register the service in the providers array in the component `test-di.component.ts`
    file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在组件`test-di.component.ts`文件的providers数组中注册服务：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s analyze the preceding code in detail:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析上述代码：
- en: We created a component called `TestDiComponent`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`TestDiComponent`的组件。
- en: We imported the newly created service `TestDiService` into the component.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将新创建的服务`TestDiService`导入到组件中。
- en: We registered the `TestDiService` in the providers to tell Angular to create
    an instance of the service dynamically.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在providers中注册了`TestDiService`，告诉Angular动态创建服务的实例。
- en: Angular DI will create a new `private` instance of the `_testDiService` service
    class that we passed inside the `constructor`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Angular DI将创建一个我们在`constructor`中传递的`_testDiService`服务类的新`private`实例。
- en: We used the instance of the `_testDiService` service and called the `getAuthors`
    method to get a list of authors.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了`_testDiService`服务的实例，并调用了`getAuthors`方法来获取作者列表。
- en: 'Run the app, and we should see the output as shown in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，我们应该看到如下截图所示的输出：
- en: '![](assets/63ce8a23-d436-4a54-83ff-dfa814dd9a42.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63ce8a23-d436-4a54-83ff-dfa814dd9a42.png)'
- en: We have made it so far, which is great, as you learned to create an `Injectable`
    service, register the services in the providers array inside the component decorator,
    and use the instance of the service to call methods.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学会了创建一个`Injectable`服务，将服务注册到组件装饰器内的提供者数组中，并使用服务的实例来调用方法，这很棒。
- en: In this section, you learned how to create multiple components using the same
    shared set of provider classes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学会了如何使用相同的一组共享提供者类创建多个组件。
- en: Provider classes with dependencies
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有依赖关系的提供者类
- en: In our previous sections, we discussed registering a service into components,
    but what if our service itself requires some dependencies? In this section, you
    will learn and implement ways to resolve dependencies required for services.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了将服务注册到组件中，但是如果我们的服务本身需要一些依赖怎么办？在本节中，您将学习并实现解决服务所需依赖的方法。
- en: To understand provider classes with dependencies better, let's understand the
    following use case. We have two services--`CityService` and `TestDiService`, and
    a component, that is, `TestDiComponent`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解带有依赖关系的提供者类，让我们了解以下用例。我们有两个服务——`CityService`和`TestDiService`，以及一个组件——`TestDiComponent`。
- en: 'Let''s visualize the dependency tree for these services and components:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化这些服务和组件的依赖树：
- en: '![](assets/abd05c78-6923-48b8-814d-4686bbcc398d.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/abd05c78-6923-48b8-814d-4686bbcc398d.png)'
- en: 'Let''s analyze the preceding diagram in detail to understand the use case we
    are building:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的图表，以了解我们正在构建的用例：
- en: We will create an `Injectable` service--`CityService`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个`Injectable`服务——`CityService`。
- en: We will create an `Injectable` service--`TestDiService`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个`Injectable`服务——`TestDiService`。
- en: We will need to register `CityService` into the `TestDiService` class.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`CityService`注册到`TestDiService`类中。
- en: We will create a `TestDiComponent`
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个`TestDiComponent`。
- en: We will need to register `TestDiService` into `TestDiComponent`
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`TestDiService`注册到`TestDiComponent`中。
- en: We will continue to use the previously created service, `TestDiService`, and
    the component--`TestDiComponent`--in this section as well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续使用之前创建的服务`TestDiService`和组件`TestDiComponent`。
- en: Now, we will create an additional service called `CityService` and save the
    file as `city.service.ts`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为`CityService`的额外服务，并将文件保存为`city.service.ts`。
- en: 'Add the following code snippet to the service file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到服务文件中：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s analyze the preceding code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析前面的代码片段：
- en: We created and exported a new service called `CityService`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建并导出了一个名为`CityService`的新服务。
- en: We implemented a `getCities` method, which returns a list of cities.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个`getCities`方法，该方法返回一个城市列表。
- en: 'After creating a service, we import the file and register the service as a
    provider in the `app.module.ts` file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务后，我们导入文件并在`app.module.ts`文件中将服务注册为提供者：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since we have registered the service in the providers array in the `app.module.ts`
    file, it is now available across the application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`app.module.ts`文件的providers数组中注册了该服务，它现在可以在整个应用程序中使用。
- en: 'To use the service in `TestDiService`, we have to import the service and create
    an instance of `CityService` in the constructor:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`TestDiService`中使用该服务，我们必须导入该服务并在构造函数中创建`CityService`的实例：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the example mentioned in the preceding section, we used the service to display
    a list of authors.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分提到的示例中，我们使用服务来显示作者列表。
- en: 'Now, let''s analyze the preceding code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析前面的代码：
- en: We created a service called `CityService` and imported the class inside `TestDiService`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`CityService`的服务，并在`TestDiService`中导入了该类。
- en: We created an instance of the `CityService` class--`_City` in the constructor
    method.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在构造方法中创建了`CityService`类的一个实例——`_City`。
- en: We defined a method, that is, `getAuthors`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个方法，即`getAuthors`。
- en: Using the `this` operator, we invoked the `getCities` method of the `CityService`
    class inside the `getCityList` method.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `this` 运算符，我们在 `getCityList` 方法中调用了 `CityService` 类的 `getCities` 方法。
- en: The `getCities` method returns the list of cities.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getCities` 方法返回城市列表。'
- en: 'Run the app, and you will see the output of the preceding code as shown in
    the following screenshot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，您将看到前面代码的输出，如下面的屏幕截图所示：
- en: '![](assets/1db00e73-e31d-4f29-9d67-28beda5274d3.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1db00e73-e31d-4f29-9d67-28beda5274d3.png)'
- en: In this section, you learned and implemented how to resolve dependencies of
    providers classes by registering other provider classes using the `@Injectable`
    decorator.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习并实现了如何通过使用 `@Injectable` 装饰器注册其他提供者类来解决提供者类的依赖关系。
- en: Using @Inject, provide, and useValue
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 @Inject、provide 和 useValue
- en: Let's take a quick recap on how things have progressed so far while learning
    DI. We discussed how to write provider classes and Dependency Injection for hierarchical
    components and above all how to write reusable providers using the `@injectable`
    decorator.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下学习 DI 的进展。我们讨论了如何编写提供者类和层次组件的依赖注入，以及如何使用 `@injectable` 装饰器编写可重用的提供者。
- en: In this section, you will learn how to use `@Inject`, `provide`, and `useValue`
    to share data across different components.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用 `@Inject`、`provide` 和 `useValue` 来在不同组件之间共享数据。
- en: To declare that a service can be injected in a class, we need an `@Injectable`
    decorator. The decorator tells Angular to make the class defined with `@Injectable`
    available to an injector for instantiation into other classes, services, or components
    and that the class should be resolved dynamically through DI. We use them mostly
    to write generic services and create our own repository.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个服务可以在类中被注入，我们需要一个 `@Injectable` 装饰器。该装饰器告诉 Angular 将使用 `@Injectable` 定义的类可用于注入器，以便实例化到其他类、服务或组件中，并且该类应通过
    DI 动态解析。我们主要用它们来编写通用服务并创建我们自己的存储库。
- en: Like we mentioned earlier, even if a service requires dependencies to be injected
    in it, we use the `@Injectable` decorator. We can also register a service into
    another service or any component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，即使服务需要在其中注入依赖项，我们也使用 `@Injectable` 装饰器。我们还可以将服务注册到另一个服务或任何组件中。
- en: Whenever we need to inject the type of constructor parameters, we will use the
    `@inject` decorator.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要注入构造函数参数的类型时，我们将使用 `@inject` 装饰器。
- en: 'Take a look at the following sample code for `ngModule` in the `app.module.ts`
    file:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 `app.module.ts` 文件中 `ngModule` 的以下示例代码：
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Quick points to note about the preceding code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码，有一些要注意的要点：
- en: We imported the service we have created earlier, that is, `ListService`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入了之前创建的服务，即 `ListService`。
- en: Now that we have imported the service, we need to add it to the list of `providers`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经导入了服务，我们需要将其添加到 `providers` 列表中。
- en: We are explicitly mentioning that we need to register the service name `ListService`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们明确说明需要注册服务名 `ListService`。
- en: Using `useClass` we will instruct Angular to instantiate and use the `ListService`
    class.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `useClass`，我们将指示 Angular 实例化并使用 `ListService` 类。
- en: If we note carefully, we will see that we are mainly dealing with service/provider
    classes. However, what if we need to inject certain variables so that we can share
    the value across different components and services?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细注意，我们主要处理的是服务/提供者类。但是，如果我们需要注入某些变量，以便我们可以在不同的组件和服务之间共享值呢？
- en: Bingo! That's where we can easily use the `@Inject` decorator and create a variable
    or class name, which we can reuse in other components and services.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这就是我们可以轻松使用 `@Inject` 装饰器并创建一个变量或类名，我们可以在其他组件和服务中重用。
- en: 'Take a look at the `ngModule` file now; we have modified it to accommodate
    our variable, which we want to share between various services and components:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看一下`ngModule`文件；我们已经修改它以适应我们想要在各种服务和组件之间共享的变量：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s analyze the preceding code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析前面的代码：
- en: Inside the providers, we created a new entry, and for `provide`, we applied
    a name, `username`. Remember whatever name you mention here, as we will need to
    use it throughout in other services or components.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供者中，我们创建了一个新的条目，对于`provide`，我们应用了一个名称`username`。请记住，无论您在这里提到的名称是什么，我们都需要在其他服务或组件中始终使用它。
- en: We provided a value for the `username` variable.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为`username`变量提供了一个值。
- en: Note that this value will not be changed or updated; think of it as a constant
    value throughout the application.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，这个值不会被更改或更新；把它想象成应用程序中的一个常量值。
- en: Now that we have created a value constant provider, let's see how we can use
    it in our components.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个值常量提供者，让我们看看如何在我们的组件中使用它。
- en: 'In the `app.component.ts`, add the following code snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.component.ts`中，添加以下代码片段：
- en: '[PRE19]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s analyze the preceding code snippet in detail:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码片段：
- en: We imported the `component` and `Inject` modules from `@angular/core`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`@angular/core`中导入了`component`和`Inject`模块。
- en: We created our component and defined the respective HTML and style sheet for
    the component to HTML and CSS files.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了我们的组件，并为组件的HTML和样式表定义了相应的HTML和CSS文件。
- en: In the `AppComponent` class, we defined a `title` variable and assigned it a
    value.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`类中，我们定义了一个`title`变量并为其赋值。
- en: We created a constructor of the class and passed an `@inject` decorator to pass
    the name, `username`, which we defined in the `app.module.ts` file.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个类的构造函数，并传递了一个`@inject`装饰器来传递我们在`app.module.ts`文件中定义的`username`名称。
- en: Now that we have registered the `username` variable in the provider's array
    configuration, we can use the value of the variable anywhere in the component
    template.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在提供者数组配置中注册了`username`变量，我们可以在组件模板中的任何地方使用该变量的值。
- en: 'Awesome, now let''s run the app; we should the output shown in the following
    screenshot:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，现在让我们运行这个应用程序；我们应该看到以下截图中显示的输出：
- en: '![](assets/f3dc9711-d107-4d3f-afe9-5d0faf8c0d35.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f3dc9711-d107-4d3f-afe9-5d0faf8c0d35.png)'
- en: An important thing to note in the following screenshot is the variable value
    flagged in green, `'Sridhar@gmail.com'` which is getting printed in the template.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中需要注意的一点是，以绿色标记的变量值`'Sridhar@gmail.com'`在模板中被打印出来。
- en: In this section, you learned to define and use a constant provider using the
    `@Inject` decorator.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学会了使用`@Inject`装饰器定义和使用常量提供者。
- en: You learned to use `@Injectable` for our service class; we can register it as
    a provider and use it in other services or in components.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何为我们的服务类使用`@Injectable`；我们可以将其注册为提供者，并在其他服务或组件中使用它。
- en: We can define some constant variables, which can also inject and use the value
    across different components.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一些常量变量，也可以注入和在不同组件中使用该值。
- en: You should be now able to create multiple reusable services, provider classes,
    and also constant variables, which can be used to create our application repository.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够创建多个可重用的服务、提供者类，以及常量变量，这些可以用来创建我们的应用程序存储库。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed Angular DI as we know it now. DI allows us to
    inject the provider class and injectables into components using providers. We
    learned and implemented provider classes and hierarchical Dependency Injection.
    We also learned to register providers in the `NgModule` or inside components directly.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了现在我们所知道的Angular DI。DI允许我们将提供者类和可注入对象注入到组件中使用提供者。我们学习并实现了提供者类和分层依赖注入。我们还学会了在`NgModule`中注册提供者，或者直接在组件内部注册提供者。
- en: We focused on how to create and configure Injectors and also how to register
    services in providers inside the component decorator.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重点关注如何创建和配置注入器，以及如何在组件装饰器中注册服务提供者。
- en: This chapter explained that a provider class can also have dependencies, which
    internally can be injected again into services or components. In the next chapter,
    you will learn about Angular animations. Angular animations is a core library
    that provides a better user experience by applying motions and transitions to
    apps.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了提供者类也可以有依赖项，这些依赖项可以在内部再次注入到服务或组件中。在下一章中，您将学习关于Angular动画。Angular动画是一个核心库，通过将动作和过渡应用到应用程序中，提供更好的用户体验。
- en: We will learn about various transitions and motions, and how to style animations;
    above all, we will create some cool stuff along the way.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习各种过渡和动作，以及如何设计动画；最重要的是，我们将在学习过程中创建一些很酷的东西。
