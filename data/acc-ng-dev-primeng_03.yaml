- en: '*Chapter 7*: Component Harnesses'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：组件连接器'
- en: Testing is a fundamental part of software development. It helps ensure that
    the code that's delivered covers the feature requirements and is free of implementation
    issues. Sometimes, when testing UI code, it is hard to avoid performing tightly
    coupled tests on the DOM structure. However, Angular Ivy brings a new solution
    for this. Component testing harnesses make it possible to develop a testing API
    for our components using the industry-standard Page Object pattern, but on a more
    granular level.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件开发的基本部分。它有助于确保交付的代码覆盖了功能需求且没有实现问题。有时，在测试UI代码时，很难避免在DOM结构上执行紧密耦合的测试。然而，Angular
    Ivy为这个问题带来了一个新的解决方案。组件测试连接器使我们能够使用行业标准页面对象模式为我们的组件开发测试API，但更细粒度。
- en: To top this off, component harnesses for the Angular Material directives and
    components are already included in Angular Ivy. In this chapter, we will learn
    how to use the component testing harnesses in Angular Components and how to implement
    custom component harnesses to make it easier to test our components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，Angular Ivy已经包含了Angular Material指令和组件的组件连接器。在本章中，我们将学习如何使用Angular组件中的组件测试连接器，以及如何实现自定义组件连接器以简化我们的组件测试。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下主题：
- en: Using Angular Material's component harnesses
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular Material的组件连接器
- en: Creating a component harness
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建组件连接器
- en: By the end of this chapter, you should have gained an overview of how and where
    to use component harnesses.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该已经了解了如何以及在哪里使用组件连接器。
- en: Using Angular Material's component harnesses
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular Material的组件连接器
- en: You saw an example of how to use the **Material Button harness** in [*Chapter
    4*](B16295_04_ePub_RK.xhtml#_idTextAnchor055), *Exploring Angular Components Features.*
    Now, let's explore how to test the **theme** component using the material test
    harnesses with a *Test as a user* strategy.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[*第4章*](B16295_04_ePub_RK.xhtml#_idTextAnchor055)“探索Angular组件功能”中看到了如何使用**Material按钮连接器**的示例。现在，让我们探讨如何使用材料测试连接器以及“以用户身份测试”策略来测试**主题**组件。
- en: 'As you might remember, the theme component lets us select the color and size
    settings for Angular Academy. The user can do this by selecting a color by going
    to the `MatInputHarness` with the `#headerBackground` selector:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记，主题组件让我们可以选择Angular Academy的颜色和大小设置。用户可以通过选择颜色并访问具有`#headerBackground`选择器的`MatInputHarness`来完成此操作：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we expect the default setting to be `'#00aa00'`. We retrieve the value
    from the test harness using the `getValue` method.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们期望默认设置为`'#00aa00'`。我们使用`getValue`方法从测试连接器中检索值。
- en: 'In this example, we could also simply find the value in the input field with
    the `''#headerBackground''` ID and check its value. So, let''s build a more complicated
    test where we should be able to change the header background color theme setting:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们也可以简单地通过在具有`'#headerBackground'` ID的输入字段中找到值并检查其值。所以，让我们构建一个更复杂的测试，其中我们应该能够更改标题背景颜色主题设置：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we did earlier, we will use the component harness to interact with the `'#ffbbccc'`
    and check that this setting has been picked up by the theme setting.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，我们将使用组件连接器与`'#ffbbccc'`进行交互，并检查此设置是否已被主题设置所采用。
- en: Did you notice that we did not write `fixture.detectChanges()`in this test?
    We can avoid this because we are using the component harness that will handle
    the DOM operations here. Clicking this input field and interacting with the color
    selector as the user would have done is somewhat complex using DOM operations,
    but here, we are using the operations on the component testing harness instead.
    By doing this, we can avoid brittle changes in the test related to change detection.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们没有在这个测试中编写`fixture.detectChanges()`吗？我们可以避免这样做，因为我们正在使用将处理DOM操作的组件连接器。点击这个输入字段并像用户一样与颜色选择器交互是使用DOM操作相当复杂的，但在这里，我们正在使用组件测试连接器上的操作。通过这样做，我们可以避免与变更检测相关的测试中的脆弱变化。
- en: 'Similarly, we can use `MatSliderHarness` to `MatInputHarness` to avoid performing
    DOM operations when testing the **Video Size** slider setting for the theme component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`MatSliderHarness`到`MatInputHarness`来避免在测试主题组件的**视频大小**滑块设置时执行DOM操作：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we can retrieve the default `videoSize` setting from the theme service
    and the screen component to check that it is `7` by using API operations from
    the test harness. Using the `async`/`await` construct in combination with the
    test harness leads to fairly compact code here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从主题服务和使用屏幕组件检索默认的 `videoSize` 设置，并使用测试 harness 的 API 操作来检查它是否为 `7`。使用
    `async`/`await` 构造与测试 harness 结合使用，这里代码相当紧凑。
- en: By now, you should know how to use the existing material component harnesses.
    Next, let's dive into how to build component harnesses for the Angular Academy
    app.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该知道如何使用现有的材料组件 harness。接下来，让我们深入了解如何为 Angular Academy 应用程序构建组件 harness。
- en: Creating a component harness
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件 harness
- en: Let's imagine that we want to expose our `Video` component so that it can be
    integrated with other applications. Here, it would make sense to write a test
    harness for it – but how should we structure it? Our example of displaying YouTube
    videos using a YouTube Player component inside a `Video` component, which will
    be inside a Course component, turns out to be difficult to test using a "test
    as a user" approach in the DOM directly. So, let's take a layered approach here.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们希望公开我们的 `Video` 组件，以便它可以与其他应用程序集成。在这里，为它编写一个测试 harness 是有意义的——但我们应该如何构建它？我们使用
    YouTube Player 组件在 `Video` 组件内部显示 YouTube 视频的示例，该 `Video` 组件将位于 Course 组件内部，直接在
    DOM 中使用“测试作为用户”的方法进行测试证明是困难的。因此，让我们采取分层的方法。
- en: 'When constructing a component, we should strive to only have a single reference
    point – the DOM – for each page. Taking a layered approach, we start the test
    from the Course component, which knows about the Video component, which, in turn,
    knows about the YouTube Player component. By doing this, we can test from the
    `Course` component by exposing the `Video` harness that encapsulates the `workspace-video`
    selector as a Page Object for each of the instances of the `Video` component,
    like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建组件时，我们应该努力使每个页面只有一个单一参考点——DOM。采用分层方法，我们从 Course 组件开始测试，该组件了解 Video 组件，而 Video
    组件反过来又了解 YouTube Player 组件。通过这样做，我们可以通过暴露封装 `workspace-video` 选择器的 `Video` harness
    作为每个 `Video` 组件实例的 Page Object 来从 `Course` 组件进行测试，如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can display the text for each video by using the `getText()` call from
    the `course.component.spec.ts` file. Then, we can use the supplied `textEquals`
    call to test for equality:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过从 `course.component.spec.ts` 文件中调用 `getText()` 来显示每个视频的文本。然后，我们可以使用提供的
    `textEquals` 调用来测试相等性：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we looped through all the rendered videos for course `'1'` in the course
    component and checked that each of the texts accompanying the rendered videos
    contain the course title we can retrieve via the course service. Note that the
    `textEquals` function is supplied from the test harness here, which means we can
    change that function in a later version of the component library.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历了课程组件中渲染的 `'1'` 课程的所有视频，并检查每个与渲染视频一起出现的文本是否包含我们可以通过课程服务检索的课程标题。请注意，这里的
    `textEquals` 函数是由测试 harness 提供的，这意味着我们可以在组件库的后续版本中更改该函数。
- en: 'We will let the `Video` harness hide the DOM operations related to the videos
    using a Page Object approach. The `Video` harness will then know about the implementation
    that''s specific to the `YouTubePlayer` harness, which encapsulates the `youtube-player`
    selector, like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让 `Video` harness 使用 Page Object 方法隐藏与视频相关的 DOM 操作。然后，`Video` harness 将了解针对
    `YouTubePlayer` harness 的特定实现，该 harness 封装了 `youtube-player` 选择器，如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When rendering videos using the Angular YouTube Player, we expect the video
    IDs to be available. The trick here is that we want to hide the implementation
    details for the Angular YouTube Player from the test for the Course component.
    So, let''s introduce the `getVideoId` function to the `Video` harness so that
    it is available when we test from the Course component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Angular YouTube Player 渲染视频时，我们期望视频 ID 可用。这里的技巧是我们希望隐藏 Angular YouTube Player
    的实现细节，以便于对 Course 组件的测试。因此，让我们在 `Video` harness 中引入 `getVideoId` 函数，以便在从 Course
    组件进行测试时可用：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The full `Video` harness will look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `Video` harness 将看起来像这样：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At this point, we can expose the `Video` test harness, along with the `Video`
    component, to anyone that wants to use our `Video` component in their application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以将 `Video` test harness 以及 `Video` 组件公开给任何希望在其应用程序中使用我们的 `Video` 组件的人。
- en: Summary
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at some examples of how to use some of the existing
    test Material UI test harnesses in the context of the Angular Academy application.
    Additionally, we introduced how to implement a component harness for the `Video`
    component that is used in the Angular Academy application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在 Angular Academy 应用程序的环境中，使用一些现有的测试 Material UI 测试工具的示例。此外，我们还介绍了如何实现
    Angular Academy 应用程序中使用的 `Video` 组件的组件工具。
- en: In the next chapter, we will wrap up our Angular Academy application by showing
    you how to use the new provider scopes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过向您展示如何使用新的提供者作用域来总结我们的 Angular Academy 应用程序。
