<html><head></head><body>
<div id="_idContainer059">
<h1 class="chapter-number" id="_idParaDest-215"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.1.1">15</span></h1>
<h1 id="_idParaDest-216"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.2.1">Advanced Session Management</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Session management is </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.4.1">crucial to building good user experiences. </span><span class="koboSpan" id="kobo.4.2">Persisting session data can increase the user’s experience and productivity by remembering user settings, selections, </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">and preferences.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">We learned how to manage user sessions in </span><a href="B17399_08.xhtml#_idTextAnchor119"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Session Management</span></em><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">In this chapter, we will work on advanced session </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">management patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">This chapter is split into </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">two sections:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">Managing </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">visitor sessions</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Implementing pagination</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">First, we will implement visitor sessions and use Remix’s cookie helper to redirect the user to the right page after login or signup. </span><span class="koboSpan" id="kobo.17.2">Next, we will learn how to add pagination with Remix and Prisma. </span><span class="koboSpan" id="kobo.17.3">We will practice pagination by applying it to the expense and invoice lists </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">in BeeRich.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">After reading this chapter, you will know how to use cookies to persist arbitrary session data in Remix. </span><span class="koboSpan" id="kobo.19.2">You will also understand the difference between Remix’s session cookie and cookie helpers. </span><span class="koboSpan" id="kobo.19.3">Additionally, you'll learn when to store session data in a cookie versus in a database. </span><span class="koboSpan" id="kobo.19.4">Finally, you will understand how to implement pagination </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">with Remix.</span></span></p>
<h1 id="_idParaDest-217"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">You can find the code for this chapter here: </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/15-advanced-session-management"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/15-advanced-session-management</span></a><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">No extra setup is required for </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">this chapter.</span></span></p>
<h1 id="_idParaDest-218"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.26.1">Managing visitor sessions</span></h1>
<p><span class="koboSpan" id="kobo.27.1">In </span><a href="B17399_08.xhtml#_idTextAnchor119"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.28.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.29.1">, </span><em class="italic"><span class="koboSpan" id="kobo.30.1">Session Management</span></em><span class="koboSpan" id="kobo.31.1">, we used Remix’s session cookie helpers to implement a login and signup flow. </span><span class="koboSpan" id="kobo.31.2">In this section, we will use Remix’s cookie helper to persist additional </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">session data.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">You </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.34.1">might remember from </span><a href="B17399_08.xhtml#_idTextAnchor119"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.35.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.36.1">, </span><em class="italic"><span class="koboSpan" id="kobo.37.1">Session Management</span></em><span class="koboSpan" id="kobo.38.1">, that cookies are added on the server to an HTTP response using the </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">Set-Cookie</span></strong><span class="koboSpan" id="kobo.40.1"> header. </span><span class="koboSpan" id="kobo.40.2">Once received, the browser attaches the cookie to all subsequent HTTP requests using the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.41.1">Cookie</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.42.1"> header.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">In Remix, we </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.44.1">can access incoming HTTP requests in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">loader</span></strong><span class="koboSpan" id="kobo.46.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">action</span></strong><span class="koboSpan" id="kobo.48.1"> functions. </span><span class="koboSpan" id="kobo.48.2">In our loaders and actions, we can use Remix’s cookie helper functions to parse the cookie data from the request headers and use it to improve the </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">user experience.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">In BeeRich, we already utilize a cookie to handle the authentication of our users. </span><span class="koboSpan" id="kobo.50.2">However, there are plenty of other use cases </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">for cookies.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Consider the following advanced use case: we aim to offer visitors a taste of our app’s functionality without requiring an account. </span><span class="koboSpan" id="kobo.52.2">Visitors should be able to directly interact with the content. </span><span class="koboSpan" id="kobo.52.3">At some point, the visitor decides to create an account. </span><span class="koboSpan" id="kobo.52.4">Now, we want to ensure that the data associated with the visitor is transferred to the new user account. </span><span class="koboSpan" id="kobo.52.5">How can we make </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">this work?</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">Depending on the use case, session data can be persisted using local storage, cookies, memory, or databases. </span><span class="koboSpan" id="kobo.54.2">We could store all generated data directly in local storage or a cookie and only commit it to the database once the user account has been created. </span><span class="koboSpan" id="kobo.54.3">However, this only works if the data is not meant to be visible to </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">other users.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">What if we want to treat the visitor-generated content like the content of any other user? </span><span class="koboSpan" id="kobo.56.2">First, we must assign the visitor a unique identifier that can be tracked across different page transitions. </span><span class="koboSpan" id="kobo.56.3">Whenever the visitor triggers a mutation, we associate the persisted data with the unique identifier. </span><span class="koboSpan" id="kobo.56.4">Once the visitor signs up, we migrate all data associated with the visitor identifier to the new </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">user account.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">Generating a unique session identifier is a common pattern when handling sessions, and storing it in a cookie is a great way to ensure we have access to the identifier on the server. </span><span class="koboSpan" id="kobo.58.2">This example illustrates how powerful cookies are. </span><span class="koboSpan" id="kobo.58.3">Cookies can be utilized to implement complex user interfaces and features. </span><span class="koboSpan" id="kobo.58.4">However, cookies can also be used to persist short-living </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">session data.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Let’s practice working with Remix’s cookie helpers by implementing a redirect flow after login and signup in BeeRich. </span><span class="koboSpan" id="kobo.60.2">If a user attempts to visit a dashboard page without authorization, we currently redirect to the login page. </span><span class="koboSpan" id="kobo.60.3">Once the user logs in or signs up, we navigate the user to </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">/dashboard</span></strong><span class="koboSpan" id="kobo.62.1">. </span><span class="koboSpan" id="kobo.62.2">We now want to update this logic and navigate the user to </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.63.1">the initially requested </span><a id="_idIndexMarker564"/><span class="No-Break"><span class="koboSpan" id="kobo.64.1">dashboard page.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">We’ll start by creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">visitor cookie:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.67.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">visitors.server.ts</span></strong><span class="koboSpan" id="kobo.69.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">app/modules</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.73.1">Next, import </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">createCookie</span></strong><span class="koboSpan" id="kobo.75.1"> from Remix and create a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">visitorCookie</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.77.1"> object:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.78.1">
import { createCookie } from '@remix-run/node';const visitorCookie = createCookie('visitor-cookie', {  maxAge: 60 * 5, // 5 minutes});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.79.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">createCookie</span></strong><span class="koboSpan" id="kobo.81.1"> function receives a cookie name parameter and a configuration object. </span><span class="koboSpan" id="kobo.81.2">A list of possible configuration options can be found in the Remix </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">documentation: </span></span><a href="https://remix.run/docs/en/2/utils/cookies#createcookie"><span class="No-Break"><span class="koboSpan" id="kobo.83.1">https://remix.run/docs/en/2/utils/cookies#createcookie</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.84.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.85.1">Rember that Remix offers both a cookie helper utility and a session cookie helper utility. </span><span class="koboSpan" id="kobo.85.2">Refer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">session.server.ts</span></strong><span class="koboSpan" id="kobo.87.1">, where we utilize Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">createCookieSessionStorage</span></strong><span class="koboSpan" id="kobo.89.1"> function. </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">createCookieSessionStorage</span></strong><span class="koboSpan" id="kobo.91.1"> provides </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">three functions:</span></span></p><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">getSession</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">commitSession</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">destroySession</span></strong></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.96.1">In comparison, Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">createCookie</span></strong><span class="koboSpan" id="kobo.98.1"> function only provides two functions: </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">parse</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.100.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">serialize</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.103.1">Session </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.104.1">cookies are one of many implementations of Remix’s session abstraction. </span><span class="koboSpan" id="kobo.104.2">On the other hand, </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">createCookie</span></strong><span class="koboSpan" id="kobo.106.1"> provides a simple helper to read (</span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">parse</span></strong><span class="koboSpan" id="kobo.108.1">) and write (</span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">serialize</span></strong><span class="koboSpan" id="kobo.110.1">) a cookie to and from </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">cookie headers.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.112.1">We use Remix’s session helpers to implement user session flows, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">createCookie</span></strong><span class="koboSpan" id="kobo.114.1"> is a utility for reading and writing to and </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">from cookies.</span></span></p></li> <li><span class="koboSpan" id="kobo.116.1">Next, define the type of data that we will store in the </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">visitor cookie:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.118.1">
type VisitorCookieData = {  redirectUrl?: string;};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.119.1">Our goal is to persist the URL the visitor wants to visit before we redirect them to the </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">login page.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.121.1">For</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.122.1"> instance, imagine a user is logged in and working on the dashboard of BeeRich. </span><span class="koboSpan" id="kobo.122.2">The user then returns a few days later and wants to continue managing their finances with BeeRich. </span><span class="koboSpan" id="kobo.122.3">Since the session has expired, BeeRich redirects the user to the login page. </span><span class="koboSpan" id="kobo.122.4">So far, we’ve navigated the user back to the dashboard after a successful login but do not remember where exactly the user left off. </span><span class="koboSpan" id="kobo.122.5">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">change that!</span></span></p></li> <li><span class="koboSpan" id="kobo.124.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">visitors.server.ts</span></strong><span class="koboSpan" id="kobo.126.1">, create a function to get the cookie data from </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">a request:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.128.1">
export async function getVisitorCookieData(request: Request): Promise&lt;VisitorCookieData&gt; {  const cookieHeader = request.headers.get('Cookie');  const cookie = await visitorCookie.parse(cookieHeader);  return cookie &amp;&amp; cookie.redirectUrl ? </span><span class="koboSpan" id="kobo.128.2">cookie : { redirectUrl: undefined };}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.129.1">We use the cookie object to parse the </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">Cookie</span></strong><span class="koboSpan" id="kobo.131.1"> header and extract the visitor </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">cookie data.</span></span></p></li> <li><span class="koboSpan" id="kobo.133.1">Similarly, create </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.134.1">a function to </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.135.1">write the visitor cookie data to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">Set-Cookie</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.137.1"> header:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.138.1">
export async function setVisitorCookieData(data: VisitorCookieData, headers = new Headers()): Promise&lt;Headers&gt; {  const cookie = await visitorCookie.serialize(data);  headers.append('Set-Cookie', cookie);  return headers;}</span></pre></li> <li><span class="koboSpan" id="kobo.139.1">With these utilities in place, we can read the cookie data on incoming requests and write the cookie to the response when the user is redirected </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">to login.</span></span></li>
<li><span class="koboSpan" id="kobo.141.1">Import </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">setVisitorCookieData</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.143.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">app/modules/session/session.server.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.146.1">
import { setVisitorCookieData } from '~/modules/session/session.server.ts';</span></pre></li> <li><span class="koboSpan" id="kobo.147.1">Next, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">requireUserId</span></strong><span class="koboSpan" id="kobo.149.1"> function to add the visitor cookie when redirecting to </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">log in:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.151.1">
export async function requireUserId(request: Request) {  const session = await getUserSession(request);  const userId = session.get('userId');  if (!userId || typeof userId !== 'string') {</span><strong class="bold"><span class="koboSpan" id="kobo.152.1">    const headers = await setVisitorCookieData({ redirectUrl: request.url });</span></strong><strong class="bold"><span class="koboSpan" id="kobo.153.1">    throw redirect('/login', { headers });</span></strong><span class="koboSpan" id="kobo.154.1">  }  return userId;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.155.1">Note that we</span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.156.1"> utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">url</span></strong><span class="koboSpan" id="kobo.158.1"> property on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Request</span></strong><span class="koboSpan" id="kobo.160.1"> object to access the URL the user wanted to visit before </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">the redirect.</span></span></p></li> <li><span class="koboSpan" id="kobo.162.1">Next, open</span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.163.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">_layout.login.tsx</span></strong><span class="koboSpan" id="kobo.165.1"> route module and import the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">getVisitorCookieData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.167.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.168.1">
import { getVisitorCookieData } from '~/modules/visitors.server';</span></pre></li> <li><span class="koboSpan" id="kobo.169.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">_layout.login.tsx</span></strong><span class="koboSpan" id="kobo.171.1"> route module’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">action</span></strong><span class="koboSpan" id="kobo.173.1"> function so that it reads </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">redirectUrl</span></strong><span class="koboSpan" id="kobo.175.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">visitor cookie:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.177.1">
try {  const user = await loginUser({ email, password });  </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">const { redirectUrl } = await getVisitorCookieData(request);</span></strong><span class="koboSpan" id="kobo.179.1">  return redirect(</span><strong class="bold"><span class="koboSpan" id="kobo.180.1">redirectUrl || '/dashboard'</span></strong><span class="koboSpan" id="kobo.181.1">, {    headers: await createUserSession(user),  });} catch (error: any) {  return json({ error: error?.message || 'Something went wrong.' </span><span class="koboSpan" id="kobo.181.2">});}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.182.1">By default, the user is now redirected to the previously requested URL. </span><span class="koboSpan" id="kobo.182.2">If no redirect happened, then the user is navigated to </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">dashboard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.185.1"> instead.</span></span></p></li> <li><span class="koboSpan" id="kobo.186.1">Test the </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.187.1">implementation by running </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">BeeRich locally.</span></span></li>
<li><span class="koboSpan" id="kobo.189.1">Start by logging in and visiting a route on the dashboard. </span><span class="koboSpan" id="kobo.189.2">For instance, navigate to an expense details page. </span><span class="koboSpan" id="kobo.189.3">Copy the URL from the URL bar for easy access and log out from BeeRich. </span></li>
<li><span class="koboSpan" id="kobo.190.1">Now, enter the copied URL into the URL bar. </span><span class="koboSpan" id="kobo.190.2">Since we are logged out, we are redirected to log in. </span></li>
<li><span class="koboSpan" id="kobo.191.1">Next, log in to your account and notice the redirect back to the requested </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">dashboard page.</span></span></li>
<li><span class="koboSpan" id="kobo.193.1">Play around with the implementation a bit more. </span><span class="koboSpan" id="kobo.193.2">Notice that it doesn’t matter how often you leave the login page, close the browser tab, or reload it. </span><span class="koboSpan" id="kobo.193.3">For the five minutes before the cookie expires, the cookie persists and remembers the user’s latest </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">requested URL.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.195.1">Great job! </span><span class="koboSpan" id="kobo.195.2">Would</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.196.1"> the same flow also make sense for signup? </span><span class="koboSpan" id="kobo.196.2">In BeeRich, not as much, as all dashboard URLs are account specific. </span><span class="koboSpan" id="kobo.196.3">However, imagine an application where you can invite your coworkers to collaborate. </span><span class="koboSpan" id="kobo.196.4">You may share an invite link for a project. </span><span class="koboSpan" id="kobo.196.5">A coworker joining for the first time would then be redirected to log in but navigate to sign up to create a new account. </span><span class="koboSpan" id="kobo.196.6">From there, we could take advantage of the visitor cookie to read the invite URL and navigate the new user to the </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">collaborative project.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">Practice working with the visitor cookie by implementing the same flow on the signup page. </span><span class="koboSpan" id="kobo.198.2">Follow the implementation from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">_layout.login.tsx action</span></strong><span class="koboSpan" id="kobo.200.1"> function and read the visitor cookie data in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">_layout.signup.tsx action</span></strong><span class="koboSpan" id="kobo.202.1"> function to navigate the </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">user accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">In this section, you practiced working with Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">createCookie</span></strong><span class="koboSpan" id="kobo.206.1"> helper and learned more about advanced session management implementations. </span><span class="koboSpan" id="kobo.206.2">You now know the difference between Remix’s session cookie and cookie utilities. </span><span class="koboSpan" id="kobo.206.3">Next, we will implement pagination </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">with Remix.</span></span></p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.208.1">Implementing pagination</span></h1>
<p><span class="koboSpan" id="kobo.209.1">Pagination is </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.210.1">an important pattern </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.211.1">when working with large and user-generated lists of objects. </span><span class="koboSpan" id="kobo.211.2">Pagination divides the content into separate pages and thereby limits the number of objects that must be loaded for a given page. </span><span class="koboSpan" id="kobo.211.3">Pagination aims to reduce load times and </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">improve performance.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">In this section, we </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.214.1">will implement pagination in BeeRich for expenses </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">and invoices:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.216.1">First, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.218.1"> route module and define a constant for the </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">page size:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.220.1">
const PAGE_SIZE = 10;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.221.1">The page size defines the number of expenses we will show at once in the expenses overview list. </span><span class="koboSpan" id="kobo.221.2">To see more expenses, the user has to navigate to the </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">next page.</span></span></p></li> <li><span class="koboSpan" id="kobo.223.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">loader</span></strong><span class="koboSpan" id="kobo.225.1"> function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.227.1"> and access a new search parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">page</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.231.1">
const userId = await requireUserId(request);const url = new URL(request.url);const searchString = url.searchParams.get('q');</span><strong class="bold"><span class="koboSpan" id="kobo.232.1">const pageNumberString = url.searchParams.get('page');</span></strong><strong class="bold"><span class="koboSpan" id="kobo.233.1">const pageNumber = pageNumberString ? </span><span class="koboSpan" id="kobo.233.2">Number(pageNumberString) : 1;</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.234.1">We will use a search parameter to track the current page the user is on. </span><span class="koboSpan" id="kobo.234.2">Every time the user clicks </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">Next</span></strong><span class="koboSpan" id="kobo.236.1"> to navigate to the next page, we will increment the page search parameter by 1. </span><span class="koboSpan" id="kobo.236.2">Every time the user clicks </span><strong class="bold"><span class="koboSpan" id="kobo.237.1">Previous</span></strong><span class="koboSpan" id="kobo.238.1">, we will decrement the parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">by 1.</span></span></p></li> <li><span class="koboSpan" id="kobo.240.1">Import Prisma </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">from `</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">@prisma/client</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">`.</span></span><pre class="source-code"><span class="koboSpan" id="kobo.244.1">
import type { Prisma } from '@prisma/client';</span></pre></li> <li><span class="koboSpan" id="kobo.245.1">Now, update the expenses database query so that it only queries a total of 10 expenses for the current page, skipping all </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">previous pages:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.247.1">
const where: Prisma.ExpenseWhereInput = {  userId,  title: {    contains: searchString ? </span><span class="koboSpan" id="kobo.247.2">searchString : '',  },};const [count, expenses] = </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">await db.$transaction</span></strong><span class="koboSpan" id="kobo.249.1">([  db.expense.count({ where }),  db.expense.findMany({    orderBy: { createdAt: 'desc' },    </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">take: PAGE_SIZE,</span></strong><span class="koboSpan" id="kobo.251.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">skip: (pageNumber - 1) * PAGE_SIZE,</span></strong><span class="koboSpan" id="kobo.253.1">    where,  }),]);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.254.1">Note that </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.255.1">we replaced the </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.256.1">expense query with two simultaneous queries: one to fetch the expenses and one to count all user expenses for the current search query. </span><span class="koboSpan" id="kobo.256.2">We will utilize the count of expenses to determine whether we should hide or disable the pagination </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">Next</span></strong><span class="koboSpan" id="kobo.258.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.259.1">Previous</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1"> buttons.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.261.1">We execute the queries with Prisma’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">$transaction</span></strong><span class="koboSpan" id="kobo.263.1"> utility instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">Promise.all</span></strong><span class="koboSpan" id="kobo.265.1"> for the additional performance benefit of making one big call to the database instead </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">of two.</span></span></p></li> <li><span class="koboSpan" id="kobo.267.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">loader</span></strong><span class="koboSpan" id="kobo.269.1"> function’s return statement so that it returns both the expenses list and </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">the count:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.271.1">
return json({ count, expenses });</span></pre></li> <li><span class="koboSpan" id="kobo.272.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">useLoaderData</span></strong><span class="koboSpan" id="kobo.274.1"> call so that it reads the updated </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">loader data:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.276.1">
const </span><strong class="bold"><span class="koboSpan" id="kobo.277.1">{ count, expenses }</span></strong><span class="koboSpan" id="kobo.278.1"> = useLoaderData&lt;typeof loader&gt;();</span></pre></li> <li><span class="koboSpan" id="kobo.279.1">In the </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.280.1">route</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.281.1"> module component, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">useSearchParams</span></strong><span class="koboSpan" id="kobo.283.1"> hook to read the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">page</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.285.1">query parameter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.286.1">
const [searchParams] = useSearchParams();const searchQuery = searchParams.get('q') || '';</span><strong class="bold"><span class="koboSpan" id="kobo.287.1">const pageNumber = searchParams.get('page') ? </span><span class="koboSpan" id="kobo.287.2">Number(searchParams.get('page')) : 1;</span></strong><strong class="bold"><span class="koboSpan" id="kobo.288.1">const isOnFirstPage = pageNumber === 1;</span></strong><strong class="bold"><span class="koboSpan" id="kobo.289.1">const showPagination = count &gt; PAGE_SIZE || !isOnFirstPage;</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.290.1">We utilize </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">showPagination</span></strong><span class="koboSpan" id="kobo.292.1"> to either show or hide the </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">pagination buttons.</span></span></p></li> <li><span class="koboSpan" id="kobo.294.1">Add the following form below the expenses </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">list (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">&lt;ul&gt;…&lt;/ul&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.298.1">
{showPagination &amp;&amp; (  &lt;Form </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">method="GET"</span></strong><span class="koboSpan" id="kobo.300.1"> action={location.pathname}    className="flex justify-between pb-10"&gt;    &lt;input type="hidden" </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">name="q"</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.302.1">value={searchQuery}</span></strong><span class="koboSpan" id="kobo.303.1"> /&gt;    &lt;Button type="submit" </span><strong class="bold"><span class="koboSpan" id="kobo.304.1">name="page"</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.305.1">value={pageNumber - 1}</span></strong><span class="koboSpan" id="kobo.306.1">      disabled={pageNumber === 1}&gt;      Previous    &lt;/Button&gt;    &lt;Button type="submit" </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">name="page"</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.308.1">value={pageNumber + 1}</span></strong><span class="koboSpan" id="kobo.309.1">      disabled={count &lt;= pageNumber * PAGE_SIZE}&gt;      Next    &lt;/Button&gt;  &lt;/Form&gt;)}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.310.1">The</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.311.1"> form submits an HTTP GET request to the current URL path. </span><span class="koboSpan" id="kobo.311.2">This follows the same pattern we already implemented for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">expense-search</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.313.1"> feature.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.314.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">Previous</span></strong><span class="koboSpan" id="kobo.316.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.317.1">Next</span></strong><span class="koboSpan" id="kobo.318.1"> buttons submit the form and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">page</span></strong><span class="koboSpan" id="kobo.320.1"> search parameter. </span><span class="koboSpan" id="kobo.320.2">Since the form uses GET, the route’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">loader</span></strong><span class="koboSpan" id="kobo.322.1"> function is called (not </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">its </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">).</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.326.1">We could </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.327.1">also use anchor tags instead of a form. </span><span class="koboSpan" id="kobo.327.2">Both initiate an HTTP GET request. </span><span class="koboSpan" id="kobo.327.3">The reason we decided to use a form here is so that we can utilize HTML button elements. </span><span class="koboSpan" id="kobo.327.4">We want to show the </span><strong class="bold"><span class="koboSpan" id="kobo.328.1">Previous</span></strong><span class="koboSpan" id="kobo.329.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.330.1">Next</span></strong><span class="koboSpan" id="kobo.331.1"> buttons even if they are disabled. </span><span class="koboSpan" id="kobo.331.2">Disabling anchor tags may require additional effort to ensure screen reader accessibility, while buttons offer a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">disabled</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.333.1"> attribute.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.334.1">Note that we include a hidden input field for the expense search filter parameter called </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">q</span></strong><span class="koboSpan" id="kobo.336.1">. </span><span class="koboSpan" id="kobo.336.2">This is necessary as we would otherwise reset the search filter when navigating between the different pages. </span><span class="koboSpan" id="kobo.336.3">By persisting the filter, the pagination works together with the search functionality and allows us to navigate between different pages of the filtered </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">expenses list.</span></span></p></li> <li><span class="koboSpan" id="kobo.338.1">Finally, update the search form to reset the pagination whenever the search </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">filter changes:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.340.1">
&lt;Form method="get" action={location.pathname}&gt;  </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">&lt;input type="hidden" name="page" value={1} /&gt;</span></strong><span class="koboSpan" id="kobo.342.1">  &lt;SearchInput name="q" type="search" label="Search by title" defaultValue={searchQuery} key={searchQuery} /&gt;&lt;/Form&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.343.1">The number of expenses may change when updating the search filter. </span><span class="koboSpan" id="kobo.343.2">Hence, we need to reset </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">the pagination.</span></span></p></li> <li><span class="koboSpan" id="kobo.345.1">Run BeeRich locally and play around with the implementation. </span><span class="koboSpan" id="kobo.345.2">Notice that the URL is updated on every navigation between </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">the pages.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.347.1">What happens if an expense is created </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">or deleted?</span></span></p></li>
</ol>
<p><span class="koboSpan" id="kobo.349.1">Remix revalidates </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.350.1">all loader data after every </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.351.1">mutation. </span><span class="koboSpan" id="kobo.351.2">When we add an expense, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">loader</span></strong><span class="koboSpan" id="kobo.353.1"> function is called, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">count</span></strong><span class="koboSpan" id="kobo.355.1"> loader data is updated. </span><span class="koboSpan" id="kobo.355.2">This ensures that the pagination buttons are added if the expenses exceed the first page. </span><span class="koboSpan" id="kobo.355.3">It turns out that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">loader</span></strong><span class="koboSpan" id="kobo.357.1"> revalidation fixes stale data issues in almost every chapter of </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">this book!</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">Similarly, the count value is updated on deletion. </span><span class="koboSpan" id="kobo.359.2">However, because we redirect the user back to their current page after deletion, the user may remain on a page without expenses. </span><span class="koboSpan" id="kobo.359.3">For instance, if we have 11 expenses and delete the last remaining expense on the second page, the user ends up on an </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">empty page.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">This is fine if we keep the pagination </span><strong class="bold"><span class="koboSpan" id="kobo.362.1">Previous</span></strong><span class="koboSpan" id="kobo.363.1"> button on the page so that the user can navigate to the previous page. </span><span class="koboSpan" id="kobo.363.2">We ensure this by always showing the pagination buttons if the user is not currently on the </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">first page:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.365.1">const isOnFirstPage = pageNumber === 1;</span></strong><span class="koboSpan" id="kobo.366.1">const showPagination = count &gt; PAGE_SIZE </span><strong class="bold"><span class="koboSpan" id="kobo.367.1">|| !isOnFirstPage;</span></strong></pre>
<p><span class="koboSpan" id="kobo.368.1">It seems like we have all the edge cases covered! </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">Nice work!</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">Let's take a moment to reflect on our development journey with BeeRich. </span><span class="koboSpan" id="kobo.370.2">We have come a long way since kicking off our work on BeeRich. </span><span class="koboSpan" id="kobo.370.3">From the ground up, we've built an extensive feature </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">set, including:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.372.1">A routing hierarchy with </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">nested routes</span></span></li>
<li><span class="koboSpan" id="kobo.374.1">SQLite database integration with </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">multiple schemas</span></span></li>
<li><span class="koboSpan" id="kobo.376.1">Forms for managing expenses </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">and income</span></span></li>
<li><span class="koboSpan" id="kobo.378.1">User login, signup, and </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">logout flows</span></span></li>
<li><span class="koboSpan" id="kobo.380.1">Server-side </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">access authorization</span></span></li>
<li><span class="koboSpan" id="kobo.382.1">File </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">upload capabilities</span></span></li>
<li><span class="koboSpan" id="kobo.384.1">Pending, optimistic, and </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">real-time UIs</span></span></li>
<li><span class="koboSpan" id="kobo.386.1">Various </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">caching techniques</span></span></li>
<li><span class="koboSpan" id="kobo.388.1">Deferred data loading with React streaming and </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">Remix’s `defer`</span></span></li>
<li><span class="koboSpan" id="kobo.390.1">Pagination for expense and </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">invoice lists</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.392.1">Congratulations on completing BeeRich, a full stack web application that fully utilizes Remix and the web platform. </span><span class="koboSpan" id="kobo.392.2">Now is your chance to take over BeeRich and keep practicing. </span><span class="koboSpan" id="kobo.392.3">You could start by adding the two search parameters: `q` and `page` to more links and redirects to persist them across different user actions and navigations. </span><span class="koboSpan" id="kobo.392.4">Or maybe there is something you wanted to change for a while already? </span><span class="koboSpan" id="kobo.392.5">Now is </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">the time!</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">And as always, practice what you have learned in this chapter by implementing the same pagination logic on the income route for the invoices list. </span><span class="koboSpan" id="kobo.394.2">Refer to the Prisma and Remix documentation if you get stuck. </span><span class="koboSpan" id="kobo.394.3">If you need more </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">guidance, refer</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">to the implementation on the </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">expense routes.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">In this section, we implemented pagination in Remix using URL search parameters. </span><span class="koboSpan" id="kobo.398.2">You learned how to carry over search parameters across different form submissions and practiced advanced session management </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">in Remix.</span></span></p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.400.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.401.1">In this chapter, you learned about advanced session management patterns with Remix and wrapped up your work </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">on BeeRich.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">Remix offers a </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">createCookie</span></strong><span class="koboSpan" id="kobo.405.1"> helper function for working with cookie data. </span><span class="koboSpan" id="kobo.405.2">The function returns a cookie abstraction for parsing and serializing cookie data to and from </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">request headers.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">After reading this chapter, you know how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">createCookie</span></strong><span class="koboSpan" id="kobo.409.1"> to store and access arbitrary user session data in a cookie. </span><span class="koboSpan" id="kobo.409.2">You practiced working with cookies by adding a visitor cookie to the login and signup flow in BeeRich that persists the URL the visitor wants </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">to access.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">You also learned how to implement a simple pagination feature with Remix and Prisma. </span><span class="koboSpan" id="kobo.411.2">Pagination is a pattern that can improve performance and avoid long loading times when working with data lists. </span><span class="koboSpan" id="kobo.411.3">Utilizing pagination limits the amount of data that needs to be fetched for each </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">page load.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">In the next chapter, we will learn more about deploying Remix applications on </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">the edge.</span></span></p>
<h1 id="_idParaDest-221"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.415.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.416.1">You can find more information about working with search parameters via MDN Web </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">Docs: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams"><span class="No-Break"><span class="koboSpan" id="kobo.418.1">https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.419.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">You can reference the Remix documentation to learn more about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">createCookie</span></strong><span class="koboSpan" id="kobo.422.1"> helper </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">function: </span></span><a href="https://remix.run/docs/en/2/utils/cookies"><span class="No-Break"><span class="koboSpan" id="kobo.424.1">https://remix.run/docs/en/2/utils/cookies</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.425.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">You can read more about pagination with Prisma in the Prisma </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">documentation: </span></span><a href="https://www.prisma.io/docs/concepts/components/prisma-client/pagination"><span class="No-Break"><span class="koboSpan" id="kobo.428.1">https://www.prisma.io/docs/concepts/components/prisma-client/pagination</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.429.1">.</span></span></p>
</div>
</body></html>