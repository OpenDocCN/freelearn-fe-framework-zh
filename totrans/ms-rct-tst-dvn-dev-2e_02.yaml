- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Rendering Lists and Detail Views
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染列表和详情视图
- en: 'The previous chapter introduced the core TDD cycle: red, green, refactor. You
    had the chance to try it out with two simple tests. Now, it’s time to apply that
    to a bigger React component.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了核心TDD周期：红、绿、重构。你有机会尝试两个简单的测试。现在，是时候将其应用到更大的React组件上了。
- en: 'At the moment, your application displays just a single item of data: the customer’s
    name. In this chapter, you’ll extend it so that you have a view of all appointments
    for the current day. You’ll be able to choose a time slot and see the details
    for the appointment at that time. We will start this chapter by sketching a mock-up
    to help us plan how we’ll build out the component. Then, we’ll begin implementing
    a list view and showing appointment details.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的应用程序只显示一条数据项：客户的姓名。在本章中，你将扩展它，以便查看当天所有的预约。你将能够选择一个时间段，并查看该时间段的预约详情。我们将通过绘制草图来开始本章，以帮助我们规划如何构建组件。然后，我们将开始实现列表视图并显示预约详情。
- en: Once we’ve got the component in good shape, we’ll build the entry point with
    webpack and then run the application in order to do some manual testing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使组件处于良好的状态，我们将使用webpack构建入口点，然后运行应用程序以进行一些手动测试。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Sketching a mock-up
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制草图
- en: Creating the new component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新组件
- en: Specifying list item content
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定列表项内容
- en: Selecting data to view
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择要查看的数据
- en: Manually testing our changes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试我们的更改
- en: By the end of this chapter, you’ll have written a decent-sized React component
    using the TDD process you’ve already learned. You’ll also have seen the app running
    for the first time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将使用你已学到的TDD过程编写一个相当大的React组件。你还将看到应用程序的首次运行。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter02).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter02)找到。
- en: Sketching a mock-up
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制草图
- en: 'Let’s start with a little more up-front design. We’ve got an `Appointment`
    component that takes an appointment and displays it. We will build an `AppointmentsDayView`
    component around it that takes an array of `appointment` objects and displays
    them as a list. It will also display a single `Appointment`: the appointment that
    is currently selected. To select an appointment, the user simply clicks on the
    time of day that they’re interested in.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更多的预先设计开始。我们有一个`Appointment`组件，它接受一个预约并显示它。我们将围绕它构建一个`AppointmentsDayView`组件，该组件接受一个`appointment`对象的数组，并将它们显示为列表。它还将显示一个单独的`Appointment`：当前选定的预约。要选择一个预约，用户只需点击他们感兴趣的一天中的时间。
- en: '![Figure 2.1 – A mock-up of our appointment system UI ](img/Figure_2.01_B18423.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 我们预约系统UI的草图](img/Figure_2.01_B18423.jpg)'
- en: Figure 2.1 – A mock-up of our appointment system UI
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 我们预约系统UI的草图
- en: Up-front design
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 预先设计
- en: When you’re using TDD to build new features, it’s important to do a little up-front
    design so that you have a general idea of the direction your implementation needs
    to take.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用TDD来构建新功能时，进行一点预先设计非常重要，这样你才能对实现的方向有一个大致的了解。
- en: That’s all the design we need for now; let’s jump right in and build the new
    `AppointmentsDayView` component.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们现在需要的所有设计；让我们直接开始构建新的`AppointmentsDayView`组件。
- en: Creating the new component
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新组件
- en: 'In this section, we’ll create the basic form of `AppointmentsDayView`: a list
    of appointment times for the day. We won’t build any interactive behavior for
    it just yet.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建`AppointmentsDayView`的基本形式：一天中的预约时间列表。我们目前不会为它构建任何交互行为。
- en: 'We’ll add our new component into the same file we’ve been using already because
    so far there’s not much code in there. Perform the following steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的新组件添加到我们一直在使用的同一个文件中，因为到目前为止那里没有多少代码。执行以下步骤：
- en: Placing components
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 放置组件
- en: We don’t always need a new file for each component, particularly when the components
    are short functional components, such as our `Appointment` component (a one-line
    function). It can help to group related components or small sub-trees of components
    in one place.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不总是需要为每个组件创建一个新的文件，尤其是当组件是短的功能组件时，比如我们的`Appointment`组件（一个单行函数）。将相关的组件或组件的小子树组合在一个地方可能会有所帮助。
- en: 'In `test/Appointment.test.js`, create a new `describe` block under the first
    one, with a single test. This test checks that we render a `div` with a particular
    ID. That’s important in this case because we load a CSS file that looks for this
    element. The expectations in this test use the DOM method, `querySelector`. This
    searches the DOM tree for a single element with the tag provided:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/Appointment.test.js`中，在第一个`describe`块下面创建一个新的`describe`块，包含一个单独的测试。这个测试检查我们是否渲染了一个具有特定ID的`div`。在这个情况下，这是很重要的，因为我们加载了一个CSS文件，它会查找这个元素。这个测试中的期望使用了DOM方法`querySelector`。这个方法在DOM树中搜索一个带有提供标签的单个元素：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It isn’t usually necessary to wrap your component in a `div` with an ID or a
    class. We tend to do it when we have CSS that we want to attach to the entire
    group of HTML elements that will be rendered by the component, which, as you’ll
    see later, is the case for `AppointmentsDayView`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，没有必要将你的组件包裹在一个带有ID或类的`div`中。我们倾向于这样做，因为我们想将CSS附加到由组件渲染的整个HTML元素组上，正如你稍后将会看到的，对于`AppointmentsDayView`来说就是这样。
- en: This test uses the exact same `render` function from the first `describe` block
    as well as the same `let container` declaration and `beforeEach` block. In other
    words, we’ve introduced duplicated code. By duplicating code from our first test
    suite, we’re making a mess straight after cleaning up our code! Well, we’re allowed
    to do it when we’re in the first stage of the TDD cycle. Once we’ve got the test
    passing, we can think about the right structure for the code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用了第一个`describe`块中的相同的`render`函数，以及相同的`let container`声明和`beforeEach`块。换句话说，我们已经引入了重复的代码。通过从我们的第一个测试套件中复制代码，我们在清理代码后直接制造了一团糟！嗯，在我们处于TDD周期的第一阶段时，我们可以这样做。一旦测试通过，我们就可以考虑代码的正确结构了。
- en: 'Run `npm test` and look at the output:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm test`并查看输出：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s work on getting this test to pass by performing the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来使这个测试通过：
- en: 'To fix this, change the last `import` statement in your test file to read as
    follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，请将测试文件中的最后一个`import`语句更改为以下内容：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In `src/Appointment.js`, add this functional component below `Appointment`
    as shown:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/Appointment.js`中，在`Appointment`下面添加以下功能组件，如图所示：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run your tests again. You''ll see output like this:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行你的测试。你将看到如下输出：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, a test failure! Let’s get that `div` in place as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一个测试失败了！让我们按照以下方式放置那个`div`：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Your test should now be passing. Let’s move on to the next test. Add the following
    text, just below the last test in `test/Appointment.test.js`, still inside the
    `AppointmentsDayView` `describe` block:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的测试现在应该通过了。让我们继续下一个测试。在`test/Appointment.test.js`中，在最后一个测试下面添加以下文本，仍然在`AppointmentsDayView`的`describe`块内：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run your tests again and you''ll see output matching the text shown below:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行你的测试，你将看到以下文本所示的输出：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To make that pass, add the `ol` element as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，添加以下`ol`元素：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alright, now let’s fill that `ol` with an item for each appointment. For that,
    we’ll need (at least) two appointments to be passed as the value of the `appointments`
    prop, as. Add the next test, as shown:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在让我们用每个预约的项目填充那个`ol`列表。为此，我们需要（至少）两个作为`appointments`属性值的预约。添加下一个测试，如图所示：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Testing dates and times
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试日期和时间
- en: In the test, the `today` constant is defined to be `new Date()`. Each of the
    two records then uses this as a base date. Whenever we’re dealing with dates,
    it’s important that we base all events on the same moment in time, rather than
    asking the system for the current time more than once. Doing that is a subtle
    bug waiting to happen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，`today`常量被定义为`new Date()`。两个记录中的每一个都使用这个作为基准日期。当我们处理日期时，非常重要的一点是我们应该基于同一时间点来安排所有事件，而不是多次从系统中获取当前时间。这样做是一个潜在的微妙错误。
- en: 'Run `npm test` again and you''ll see this output:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`npm test`，你将看到以下输出：
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To fix this, we map over the provided `appointments` prop and render an empty
    `li` element:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们遍历提供的`appointments`属性，并渲染一个空的`li`元素：
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Ignoring unused function arguments
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略未使用的函数参数
- en: The `map` function will provide an `appointment` argument to the function passed
    to it. Since we don’t use the argument (yet), we don’t need to mention it in the
    function signature—we can just pretend that our function has no arguments instead,
    hence the empty brackets. Don’t worry, we’ll need the argument for a subsequent
    test, and we’ll add it in then.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数将为传递给它的函数提供一个 `appointment` 参数。由于我们目前还没有使用这个参数，我们不需要在函数签名中提及它——我们只需假装我们的函数没有参数即可，因此括号是空的。别担心，我们将在后续测试中需要这个参数，那时我们会添加它。'
- en: 'Great, let’s see what Jest thinks. Run `npm test` again:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了，让我们看看 Jest 怎么想。再次运行 `npm test`：
- en: '[PRE12]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our test passed, but we got a warning from React. It’s telling us to set a
    key value on each child element. We can use `startsAt` as a key, like this:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的测试通过了，但我们收到了 React 的警告。它告诉我们要在每个子元素上设置一个键值。我们可以使用 `startsAt` 作为键，如下所示：
- en: '[PRE13]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Testing keys
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 测试键值
- en: There’s no easy way for us to test key values in React. To do it, we’d need
    to rely on internal React properties, which would introduce a risk of tests breaking
    if the React team were to ever change those properties.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中测试键值没有简单的方法。为了做到这一点，我们需要依赖于内部 React 属性，这可能会引入风险，即如果 React 团队更改这些属性，测试可能会中断。
- en: The best we can do is set a key to get rid of this warning message. In an ideal
    world, we’d have a test that uses the `startsAt` timestamp for each `li` key.
    Let’s just imagine that we have that test in place.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做的就是设置一个键来消除这个警告信息。在一个理想的世界里，我们会有一个使用每个 `li` 键的 `startsAt` 时间戳的测试。让我们假设我们已经有了那个测试。
- en: This section has covered how to render the basic structure of a list and its
    list items. Next, it’s time to fill in those items.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何渲染列表的基本结构和其列表项。接下来，是时候填充这些项了。
- en: Specifying list item content
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定列表项内容
- en: In this section, you’ll add a test that uses an array of example appointments
    to specify that the list items should show the time of each appointment, and then
    you’ll use that test to support the implementation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将添加一个使用示例预约数组的测试，以指定列表项应显示每个预约的时间，然后你将使用该测试来支持实现。
- en: 'Let’s start with the test:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试开始：
- en: 'Create a fourth test in the new `describe` block as shown:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 `describe` 块中创建第四个测试，如下所示：
- en: '[PRE14]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Jest will show the following error:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 将显示以下错误：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The toEqual matcher
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`toEqual` 匹配器'
- en: This matcher is a stricter version of `toContain`. The expectation only passes
    if the text content is an exact match. In this case, we think it makes sense to
    use `toEqual`. However, it’s often best to be as loose as possible with your expectations.
    Tight expectations have a habit of breaking any time you make the slightest change
    to your code base.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个匹配器是 `toContain` 的更严格版本。期望只有在文本内容是精确匹配的情况下才会通过。在这种情况下，我们认为使用 `toEqual` 是有意义的。然而，通常最好尽可能宽松地设定期望。严格的期望往往会在你对代码库进行最轻微的更改时崩溃。
- en: 'Add the following function to `src/Appointment.js`, which converts a Unix timestamp
    (which we get from the return value from `setHours`) into a time of day. It doesn’t
    matter where in the file you put it; we usually like to define constants before
    we use them, so this would go at the top of the file:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到 `src/Appointment.js` 中，该函数将 Unix 时间戳（我们从 `setHours` 的返回值中获取）转换为一天中的时间。你可以在文件的任何位置放置它；我们通常喜欢在使用之前定义常量，所以这应该放在文件顶部：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Understanding syntax
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 理解语法
- en: This function uses *destructuring assignment* and *template literals*, which
    are language features that you can use to keep your functions concise.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用了 *解构赋值* 和 *模板字符串*，这些是你可以用来使你的函数更简洁的语言特性。
- en: Having good unit tests can help teach advanced language syntax. If we’re ever
    unsure about what a function does, we can look up the tests that will help us
    figure it out.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的单元测试可以帮助我们学习高级语言语法。如果我们对函数的功能不确定，我们可以查找帮助我们弄清楚这些的测试。
- en: 'Use the preceding function to update `AppointmentsDayView` as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的函数按如下方式更新 `AppointmentsDayView`：
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running tests should show everything as green:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试应该显示一切正常：
- en: '[PRE18]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a great chance to refactor. The last two `AppointmentsDayView` tests
    use the same `twoAppointments` prop value. This definition, and the `today` constant,
    can be lifted out into the `describe` scope, the same way we did with `customer`
    in the `Appointment` tests. This time, however, it can remain as `const` declarations
    as they never change.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的重构机会。最后两个 `AppointmentsDayView` 测试使用了相同的 `twoAppointments` 属性值。这个定义和
    `today` 常量可以被提升到 `describe` 范围内，就像我们在 `Appointment` 测试中对 `customer` 做的那样。然而，这次它们可以保持为
    `const` 声明，因为它们永远不会改变。
- en: To do that, move the `today` and `twoAppointments` definitions from one of the
    tests to the top of the `describe` block, above `beforeEach`. Then, delete the
    definitions from both tests.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，将`today`和`twoAppointments`的定义从其中一个测试移动到`describe`块的顶部，在`beforeEach`之上。然后，从两个测试中删除这些定义。
- en: That’s it for this test. Next, it’s time to focus on adding click behavior.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试就到这里。接下来，是时候专注于添加点击行为。
- en: Selecting data to view
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择要查看的数据
- en: Let’s add in some dynamic behavior to our page. We’ll make each of the list
    items a link that the user can click on to view that appointment.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在页面上添加一些动态行为。我们将使每个列表项都成为一个用户可以点击以查看该预约的链接。
- en: 'Thinking through our design a little, there are a few pieces we’ll need:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在思考我们的设计时，我们需要以下几个部分：
- en: A `button` element within our `li`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们`li`中的`button`元素
- en: An `onClick` handler that is attached to that `button` element
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附着到那个`button`元素的`onClick`处理程序
- en: Component state to record which appointment is currently being viewed
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件状态用于记录当前正在查看的预约
- en: When we test React actions, we do it by observing the consequences of those
    actions. In this case, we can click on a button and then check that its corresponding
    appointment is now rendered on the screen.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试React动作时，我们通过观察这些动作的后果来进行。在这种情况下，我们可以点击一个按钮，然后检查相应的预约现在是否已渲染在屏幕上。
- en: 'We’ll break this section into two parts: first, we’ll specify how the component
    should initially appear, and second, we’ll handle a click event for changing the
    content.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个部分分成两部分：首先，我们将指定组件应该如何初始显示，其次，我们将处理一个用于更改内容的点击事件。
- en: Initial selection of data
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始数据选择
- en: 'Let’s start by asserting that each `li` element has a `button` element:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先断言每个`li`元素都有一个`button`元素：
- en: 'We want to display a message to the user if there are no appointments scheduled
    for today. In the `AppointmentsDayView` `describe` block, add the following test:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果今天没有预约，我们希望向用户显示一条消息。在`AppointmentsDayView`的`describe`块中添加以下测试：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Make the test pass by adding in a message at the bottom of the rendered output.
    We don’t need a check for an empty `appointments` array just yet; we’ll need another
    test to triangulate to that. The message is as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在渲染输出的底部添加一条消息来使测试通过。我们目前不需要检查空的`appointments`数组；我们需要另一个测试来验证这一点。消息如下：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the component first loads, we should show the first appointment of the
    day. A straightforward way to check that happens is to look for the customer''s
    first name is shown on the page. Add the next test which does just that, shown
    below:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件首次加载时，我们应该显示当天的第一个预约。一个检查这一点的简单方法是在页面上查找客户的第一个名字。添加下一个测试，如下所示：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since we’re looking for the customer’s name, we’ll need to make sure that’s
    available in the `twoAppointments` array. Update it now to include the customer’s
    first name as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在寻找客户的姓名，我们需要确保它在`twoAppointments`数组中可用。现在更新它，包括客户的第一个名字如下：
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Make the test pass by modifying the `Appointment` component. Change the last
    line of the `div` component to read as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改`Appointment`组件来使测试通过。将`div`组件的最后一行修改如下：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we’re ready to let the user make a selection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好让用户进行选择了。
- en: Adding events to a functional component
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向功能组件添加事件
- en: We’re about to add *state* to our component. The component will show a button
    for each appointment. When the button is clicked, the component stores the array
    index of the appointment that it refers to. To do that, we’ll use the `useState`
    hook.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将为我们的组件添加**状态**。该组件将为每个预约显示一个按钮。当按钮被点击时，组件将存储它所引用的预约的数组索引。为此，我们将使用`useState`钩子。
- en: What are hooks?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是钩子？
- en: '`useState` hook stores data across multiple renders of your function. The call
    to `useState` returns both the current value in storage and a setter function
    that allows it to be set.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState`钩子存储了函数多次渲染之间的数据。对`useState`的调用返回存储中的当前值和一个设置函数，允许它被设置。'
- en: If you’re new to hooks, check out the *Further reading* section at the end of
    this chapter. Alternatively, you could just follow along and see how much you
    can pick up just by reading the tests!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触钩子，请查看本章末尾的**进一步阅读**部分。或者，你也可以只是跟随并看看你通过阅读测试能学到多少！
- en: 'We’ll start by asserting that each `li` element has a `button` element:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先断言每个`li`元素都有一个`button`元素：
- en: 'Add the following test below the last one you added. The second expectation
    is peculiar in that it is checking the `type` attribute of the button element
    to be `button`. If you haven’t seen this before, it’s idiomatic when using `button`
    elements to define its role by setting the `type` attribute as shown in this test:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你添加的最后一个测试下面添加以下测试。第二个期望是独特的，因为它正在检查按钮元素的`type`属性是否为`button`。如果你之前没有见过，当使用`button`元素时，通过设置`type`属性来定义其角色是惯用的，就像这个测试中所示：
- en: '[PRE24]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Testing element positioning
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 测试元素定位
- en: We don’t need to be pedantic about checking the content or placement of the
    `button` element within its parent. For example, this test would pass if we put
    an empty `button` child at the end of `li`. But, thankfully, doing the right thing
    is just as simple as doing the wrong thing, so we can opt to do the right thing
    instead. All we need to do to make this test pass is wrap the existing content
    in the new tag.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要过于关注检查`button`元素在其父元素中的内容或位置。例如，如果我们把一个空的`button`子元素放在`li`的末尾，这个测试就会通过。但幸运的是，做正确的事情和做错误的事情一样简单，所以我们可以选择做正确的事情。要使这个测试通过，我们只需要将现有内容包裹在新的标签中。
- en: 'Make the test pass by wrapping the appointment time with a `button` element
    in the `AppointmentsDayView` component, as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`AppointmentsDayView`组件中将约会时间包裹在`button`元素中来使测试通过，如下所示：
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now test what happens when the button is clicked. Back in `test/Appointment.test.js`,
    add the following as the next test. This uses the `click` function on the DOM
    element to raise a DOM click event:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以测试当按钮被点击时会发生什么。回到`test/Appointment.test.js`，添加以下内容作为下一个测试。这个测试使用DOM元素的`click`函数来引发一个DOM点击事件：
- en: '[PRE26]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Synthetic events and Simulate
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 合成事件和Simulate
- en: An alternative to using the `click` function is to use the `Simulate` namespace
    from React’s test utilities to raise a `Simulate` is somewhat simpler than the
    DOM API for raising events, it’s also unnecessary for testing. There’s no need
    to use extra APIs when the DOM API will suffice. Perhaps more importantly, we
    also want our tests to reflect the real browser environment as much as possible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`click`函数的替代方法是使用React测试工具的`Simulate`命名空间来引发`Simulate`。与使用DOM API引发事件相比，`Simulate`要简单一些，但它对于测试也是不必要的。当DOM
    API足够用时，没有必要使用额外的API。也许更重要的是，我们还想让我们的测试尽可能反映真实的浏览器环境。
- en: 'Go ahead and run the test. The output will look like this:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续运行测试。输出将如下所示：
- en: '[PRE27]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice the full text in the received string. We’re getting the text content
    of the list too because we’ve used `document.body.textContent` in our expectation
    rather than something more specific.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意接收到的字符串中的全文。我们之所以获取列表的文本内容，是因为我们在期望中使用了`document.body.textContent`而不是更具体的内容。
- en: Specificity of expectations
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的特定性
- en: Don’t be too bothered about *where* the customer’s name appears on the screen.
    Testing `document.body.textContent` is like saying *“I want this text to appear
    somewhere, but I don’t care where.”* Often, this is enough for a test. Later on,
    we’ll see techniques for expecting text in specific places.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 不要太在意客户名字在屏幕上的位置。测试`document.body.textContent`就像说“我想这个文本出现在某个地方，但我不在乎它在哪里。”通常，这足以进行测试。稍后，我们将看到在特定位置期望文本的技术。
- en: 'There’s a lot we now need to get in place in order to make the test pass. We
    need to introduce state and we need to add the handler. Perform the following
    steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，我们现在需要做很多事情。我们需要引入状态，并添加处理程序。执行以下步骤：
- en: 'Update the import at the top of the file to pull in the `useState` function
    as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件顶部的导入更新为拉入`useState`函数，如下所示：
- en: '[PRE28]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Wrap the constant definition in curly braces, and then return the existing
    value as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将常量定义包裹在花括号中，然后按照以下方式返回现有值：
- en: '[PRE29]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following line of code above the `return` statement:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`return`语句上方添加以下代码行：
- en: '[PRE30]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can now use `selectedAppointment` rather than hardcoding an index selecting
    the right appointment. Change the return value to use this new state value when
    selecting an appointment, like this:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`selectedAppointment`而不是硬编码一个索引来选择正确的约会。在选择约会时，将返回值更改为使用这个新的状态值，如下所示：
- en: '[PRE31]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Change the `map` call to include an index in its arguments. Let’s just name
    that `i` as shown here:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`map`调用修改为包括其参数中的索引。让我们将其命名为`i`，如下所示：
- en: '[PRE32]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now call `setSelectedAppointment` from within the `onClick` handler on the
    `button` element as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从`button`元素的`onClick`处理程序中调用`setSelectedAppointment`，如下所示：
- en: '[PRE33]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run your tests, and you should find they’re all green:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的测试，你应该会发现它们都是绿色的：
- en: '[PRE34]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We’ve covered a lot of detail in this section, starting with specifying the
    initial state of the view through to adding a `button` element and handling its
    `onClick` event.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中涵盖了大量的细节，从指定视图的初始状态开始，到添加 `button` 元素并处理其 `onClick` 事件。
- en: We now have enough functionality that it makes sense to try it out and see where
    we’re at.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有足够的功能，可以尝试一下，看看我们目前处于什么位置。
- en: Manually testing our changes
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动测试我们的更改
- en: The words *manual testing* should strike fear into the heart of every TDDer
    because it takes up *so* much time. Avoid it when you can. Of course, we can’t
    avoid it entirely – when we’re done with a complete feature, we need to give it
    a once-over to check we’ve done the right thing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: “手动测试”这个词应该让每个 TDDer 都感到恐惧，因为它会占用 *如此* 多的时间。尽可能避免它。当然，我们无法完全避免它 - 当我们完成一个完整的功能后，我们需要检查我们是否做了正确的事情。
- en: As it stands, we can’t yet run our app. To do that, we’ll need to add an entry
    point and then use webpack to bundle our code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，我们尚不能运行我们的应用程序。为了做到这一点，我们需要添加一个入口点，然后使用 webpack 打包我们的代码。
- en: Adding an entry point
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加入口点
- en: React applications are composed of a hierarchy of components that are rendered
    at the root. Our application entry point should render this root component.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: React 应用程序由在根处渲染的组件层次结构组成。我们的应用程序入口点应该渲染此根组件。
- en: We tend to *not* test-drive entry points because any test that loads our entire
    application can become quite brittle as we add more and more dependencies into
    it. In *Part 4, Behavior-Driven Development with Cucumber*, we’ll look at using
    Cucumber tests to write some tests that *will* cover the entry point.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常 *不* 对入口点进行测试驱动，因为任何加载我们整个应用程序的测试，随着我们添加越来越多的依赖项，都可能变得非常脆弱。在 *第 4 部分，使用
    Cucumber 进行行为驱动开发* 中，我们将探讨使用 Cucumber 测试编写一些将 *确实* 覆盖入口点的测试。
- en: 'Since we aren’t test-driving it, we follow a couple of general rules:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有进行测试驱动，我们遵循以下几条一般规则：
- en: Keep it as brief as possible
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量简短
- en: Only use it to instantiate dependencies for your root component and to call
    `render`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅将其用于实例化根组件的依赖项并调用 `render`
- en: 'Before we run our app, we’ll need some sample data. Create a file named `src/sampleData.js`
    and fill it with the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行应用程序之前，我们需要一些示例数据。创建一个名为 `src/sampleData.js` 的文件，并填充以下代码：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Important note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `Chapter02/Complete` directory in the GitHub repository contains a more
    complete set of sample data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 仓库中的 `Chapter02/Complete` 目录包含一个更完整的示例数据集。
- en: 'This list also doesn’t need to be test-driven for the following couple of reasons:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表也不需要测试驱动，以下是一些原因：
- en: It’s a list of static data with no behavior. Tests are all about specifying
    behavior, and there’s none here.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个没有行为的静态数据列表。测试都是关于指定行为的，这里没有。
- en: This module will be removed once we begin using our backend API to pull data.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们开始使用我们的后端 API 拉取数据，此模块将被移除。
- en: Tip
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: TDD is often a pragmatic choice. Sometimes, not test-driving is the right thing
    to do.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 经常是一种实用主义的选择。有时，不进行测试驱动是正确的事情。
- en: 'Create a new file, `src/index.js`, and enter the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`src/index.js`，并输入以下代码：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That’s all you’ll need.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您所需要的。
- en: Putting it all together with webpack
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 webpack 整合所有内容
- en: Jest uses Babel to transpile all our code when it’s run in the test environment.
    But what about when we’re serving our code via our website? Jest won’t be able
    to help us there.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Jest 在测试环境中运行时，它会使用 Babel 将所有我们的代码进行转译。但当我们通过我们的网站提供代码时怎么办？Jest 将无法帮助我们。
- en: 'That’s where webpack comes in, and we can introduce it now to help us do a
    quick manual test as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正是 webpack 的用武之地，我们现在可以介绍它，帮助我们快速手动测试，如下所示：
- en: 'Install webpack using the following command:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 webpack：
- en: '[PRE37]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following code to the `scripts` section of your `package.json` file:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的 `package.json` 文件的 `scripts` 部分：
- en: '[PRE38]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You’ll also need to set some configuration for webpack. Create the `webpack.config.js`
    file in your project root directory with the following content:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还需要为 webpack 设置一些配置。在项目根目录中创建 `webpack.config.js` 文件，并包含以下内容：
- en: '[PRE39]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This configuration works for webpack in development mode. Consult the webpack
    documentation for information on setting up production builds.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置适用于开发模式下的 webpack。有关设置生产构建的信息，请参阅 webpack 文档。
- en: 'In your source directory, run the following commands:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的源目录中，运行以下命令：
- en: '[PRE40]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the following content to the file you just created:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到您刚刚创建的文件中：
- en: '[PRE41]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You’re now ready to run the build using the following command:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以使用以下命令运行构建：
- en: '[PRE42]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should see output such as the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下输出：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Open `dist/index.xhtml` in your browser and behold your creation!
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开 `dist/index.xhtml`，欣赏你的作品！
- en: The following screenshot shows the application once the *Exercises* are completed,
    with added CSS and extended sample data. To include the CSS, you’ll need to pull
    `dist/index.xhtml` and `dist/styles.css` from the `Chapter02/Complete` directory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了完成 *练习* 后的应用程序，其中添加了 CSS 和扩展的示例数据。要包含 CSS，你需要从 `Chapter02/Complete` 目录中提取
    `dist/index.xhtml` 和 `dist/styles.css`。
- en: '![Figure 2.2 – The application so far ](img/Figure_2.02_B18423.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 到目前为止的应用程序](img/Figure_2.02_B18423.jpg)'
- en: Figure 2.2 – The application so far
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 到目前为止的应用程序
- en: Before you commit your code into Git...
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将代码提交到 Git 之前...
- en: 'Make sure to add `dist/main.js` to your `.gitignore` file as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 确保按照以下方式将 `dist/main.js` 添加到你的 `.gitignore` 文件中：
- en: '**echo "dist/main.js" >> .gitignore**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**echo "dist/main.js" >> .gitignore**'
- en: The `main.js` file is generated by webpack, and as with most generated files,
    you shouldn’t check it in.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.js` 文件是由 webpack 生成的，就像大多数生成的文件一样，你不应该将其提交到版本控制中。'
- en: You may also want to add `README.md` at this point to remind yourself how to
    run tests and how to build the application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能还想添加 `README.md` 文件来提醒自己如何运行测试以及如何构建应用程序。
- en: 'You’ve now seen how to put TDD aside while you created an entry point: since
    the entry point is small and unlikely to change frequently, we’ve opted not to
    test-drive it.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经看到了如何在创建入口点时暂时放下 TDD：因为入口点很小且不太可能频繁更改，所以我们选择不对其进行测试驱动。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you’ve been able to practice the TDD cycle a few times and
    get a feel for how a feature can be built out using tests as a guide.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经能够多次练习 TDD 循环，并感受到如何使用测试作为指南来构建一个功能。
- en: We started by designing a quick mock-up that helped us decide our course of
    action. We have built a container component (`AppointmentsDayView`) that displayed
    a list of appointment times, with the ability to display a single `Appointment`
    component depending on which appointment time was clicked.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设计了一个快速的原型，这帮助我们决定了我们的行动方案。我们构建了一个容器组件（`AppointmentsDayView`），它显示了一系列的预约时间，并且能够根据点击的预约时间显示单个
    `Appointment` 组件。
- en: We then proceeded to get a basic list structure in place, then extended it to
    show the initial `Appointment` component, and then finally added the `onClick`
    behavior.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后着手建立一个基本的列表结构，然后扩展它以显示初始的 `Appointment` 组件，最后添加了 `onClick` 行为。
- en: This testing strategy, of starting with the basic structure, followed by the
    initial view, and finishing with the event behavior, is a typical strategy for
    testing components.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试策略，即从基本结构开始，然后是初始视图，最后是事件行为，是测试组件的典型策略。
- en: We’ve only got a little part of the way to fully building our application. The
    first few tests of any application are always the hardest and take the longest
    to write. We are now over that hurdle, so we’ll move quicker from here onward.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们距离完全构建我们的应用程序还有一段距离。任何应用程序的前几个测试总是最难的，并且需要最长时间来编写。我们现在已经越过了这个障碍，所以从这里开始我们将更快地前进。
- en: Exercises
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Rename `Appointment.js` and `Appointment.test.js` to `AppointmentsDayView.js`
    and `AppointmentsDayView.test.js`. While it’s fine to include multiple components
    in one file if they form a hierarchy, you should always name the file after the
    root component for that hierarchy.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Appointment.js` 和 `Appointment.test.js` 重命名为 `AppointmentsDayView.js` 和 `AppointmentsDayView.test.js`。如果多个组件构成一个层次结构，将它们包含在一个文件中是可以的，但你应该始终以该层次结构的根组件命名文件。
- en: 'Complete the `Appointment` component by displaying the following fields on
    the page. You should use a `table` HTML element to give the data some visual structure.
    This shouldn’t affect how you write your tests. The fields that should be displayed
    are the following:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在页面上显示以下字段来完成 `Appointment` 组件。你应该使用 `table` HTML 元素来给数据一些视觉结构。这不应该影响你编写测试的方式。应该显示的字段如下：
- en: Customer last name, using the `lastName` field
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户的姓氏，使用 `lastName` 字段
- en: Customer telephone number, using the `phoneNumber` field
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户电话号码，使用 `phoneNumber` 字段
- en: Stylist name, using the `stylist` field
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美容师姓名，使用 `stylist` 字段
- en: Salon service, using the `service` field
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美容院服务，使用 `service` 字段
- en: Appointment notes, using the `notes` field
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预约备注，使用 `notes` 字段
- en: Add a heading to `Appointment` to make it clear which appointment time is being
    viewed.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Appointment` 组件中添加一个标题，以清楚地显示正在查看的预约时间。
- en: There is some repeated sample data. We’ve used sample data in our tests, and
    we also have `sampleAppointments` in `src/sampleData.js`, which we used to manually
    test our application. Do you think it is worth drying this up? If so, why? If
    not, why not?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在一些重复的样本数据。我们在测试中使用了样本数据，同时我们也在`src/sampleData.js`中创建了`sampleAppointments`，我们用它来手动测试我们的应用程序。你认为这样做值得吗？如果是，为什么？如果不是，为什么？
- en: Further reading
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Hooks are a relatively recent addition to React. Traditionally, React used
    classes for building components with state. For an overview of how hooks work,
    take a look at React’s own comprehensive documentation at the following link:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks 是 React 中相对较新的功能。传统上，React 使用类来构建具有状态的组件。要了解 Hooks 的工作原理，请查看以下链接中的 React
    官方全面文档：
- en: '[https://reactjs.org/docs/hooks-overview.xhtml](https://reactjs.org/docs/hooks-overview.xhtml).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reactjs.org/docs/hooks-overview.xhtml](https://reactjs.org/docs/hooks-overview.xhtml).'
