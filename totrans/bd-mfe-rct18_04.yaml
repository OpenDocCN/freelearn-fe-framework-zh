- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monorepos versus Polyrepos for Microfrontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the time engineers at Google and Facebook mentioned they have a single
    monorepo in their organization, the developer community – especially the frontend
    community – has been actively participating in debates and discussions on monorepos
    versus polyrepos.
  prefs: []
  type: TYPE_NORMAL
- en: We are seeing more and more teams leaning more toward monorepos for maintaining
    their frontend code. However, which should you choose between a polyrepo and a
    monorepo based on what the community thinks?
  prefs: []
  type: TYPE_NORMAL
- en: As we will learn in this chapter, the decision to go with a monorepo or a polyrepo
    is far deeper than just fancy technology or hype. We will see that, in fact, it
    is more to do with teams, and the culture we would like to establish within teams.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we start by understanding what polyrepos and monorepos are.
    We will see how each of them impacts how teams work and collaborate, then we will
    see why monorepos are more suited for microfrontends. Finally, we will set up
    our monorepo base application with the necessary permissions to work in teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Repo types and their nuances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Monorepos for Microfrontends?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our Monorepo with Team permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a deep understanding of the differences
    between and implications of choosing a polyrepo versus a monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: We will also have our monorepo set up and ready for vertically sliced domain-driven
    teams to get started with it.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we go through the code examples in this chapter, we will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A PC, Mac, or Linux desktop or laptop with at least 8 GB of RAM (16 GB preferred)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Intel chipset i5+, AMD, or Mac M1 + chipset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 256 GB of free hard disk storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will also need the following software installed on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js version 16+ (use **nvm** to manage different versions of Node.js if
    you have to)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Terminal: iTerm2 with Oh My Zsh (you will thank me later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IDE: We strongly recommend VS Code as we will be making use of some of the
    plugins that come with VS Code for an improved developer experience'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: npm, yarn, or pnpm – we recommend pnpm because it’s fast and storage-efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Browser: Chrome, Microsoft Edge, Brave, or Firefox (I use Firefox)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React)'
  prefs: []
  type: TYPE_NORMAL
- en: We also assume you have a basic working knowledge of Git, such as branching,
    committing code, and raising pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: Repo types and their nuances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn exactly what a polyrepo and a monorepo are.
  prefs: []
  type: TYPE_NORMAL
- en: As most of you will already know by now, repo is short for repository and refers
    to storage for all the files for your project. It also keeps track of all the
    changes to those files. This means, at any time, we can easily go and see what
    lines of code were changed, by whom, and when. In most cases, we use Git for version
    control. Some teams may use other systems, such as Mercurial or some other distributed
    version control system.
  prefs: []
  type: TYPE_NORMAL
- en: There are two strategies that teams most commonly use for managing repos. They
    are commonly known as monorepos and polyrepos. There are other patterns, such
    as Git submodules or Git subtrees, but these are beyond the scope of this chapter.
    We will focus on monorepos and polyrepos.
  prefs: []
  type: TYPE_NORMAL
- en: Monorepos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name suggests, mono means single and so the source code is managed in
    a single Git repo. This means that all team members work on a common single repository,
    and in most cases, the monorepo will consist of multiple applications. The following
    figure shows a monorepo setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Monorepo setup](img/Figure_3.01_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Monorepo setup
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, we have a single repo that consists
    of multiple apps within it. All the apps use a shared set of tools for CI and
    CD and linting and a shared component library that is usually built from source
    each time an application is built. You will also notice that all the teams have
    access to all the items within the repo.
  prefs: []
  type: TYPE_NORMAL
- en: Polyrepos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polyrepos are where each app has its own repository. Teams generally work on
    multiple repos, switching repos as they work on different apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most teams prefer going down the polyrepos route as they are a lot easier to
    manage and each team can define its own branching strategies and repo permissions.
    The following figure shows a polyrepo setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Polyrepo setup](img/Figure_3.02_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Polyrepo setup
  prefs: []
  type: TYPE_NORMAL
- en: In the polyrepo setup, you will notice multiple repositories, denoted by the
    dotted-line boxes. Each app generally has its own repository, and we have another
    repository for shared components and libraries. The shared components need to
    first be published to an artifact repository such as `npm` or Nexus before they
    can be consumed by the other repositories. We also notice that each repository
    has its own team, and generally, teams don’t have access to another team’s repository
    (unless you are an admin or a senior developer that looks after multiple applications).
  prefs: []
  type: TYPE_NORMAL
- en: Differences between Polyrepos and Monorepos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, choosing between a polyrepo or a monorepo is not just
    about how code is organized but goes a lot deeper and has a huge impact on how
    teams collaborate, the culture within the teams, how your build tools are set
    up, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, let us go a bit deeper into understanding the nuances of monorepos
    and polyrepos.
  prefs: []
  type: TYPE_NORMAL
- en: Team Collaboration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With polyrepos, teams create their own individual repositories and decide and
    define their own rules and guidelines on how the code is maintained. Obviously,
    this is the easiest and fastest way to get started, and teams become productive
    quite quickly. However, this pattern also has a few drawbacks. With polyrepos,
    teams tend to become more siloed as each team is just focused on its repo and
    doesn’t really have a lot of visibility of what other teams are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Another drawback with polyrepos is the effort required to set up and maintain
    all the build pipelines, and precommit hooks and so on are duplicated for each
    repo.
  prefs: []
  type: TYPE_NORMAL
- en: With monorepos, teams are forced to collaborate as they need to agree on a common
    way for how the code will be maintained. In a monorepo setup, since everybody
    is able to see everybody else’s code, the chances of them working in silos are
    greatly reduced. Teams are naturally encouraged to collaborate by providing feedback
    on code and it also provides an opportunity for teams to replicate good code patterns
    that other teams may have implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Build tools and Quality gates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With polyrepos, each team needs to implement its own build systems and quality
    gates such as precommit hooks. This results in duplication of effort and leads
    to higher maintenance costs. It also boils down to the engineering maturity of
    each team. Teams with strong leads will obviously have optimized build tools,
    while junior teams will struggle with not-very-optimized build tools and quality
    gates and will need intervention from other teams.
  prefs: []
  type: TYPE_NORMAL
- en: With a monorepo, all the build tools and quality gates can be centrally managed,
    reducing duplication of effort. In most cases, this is usually set up by the experts
    within one of the teams. This allows leveraging strengths and skillsets across
    all teams and teams immediately benefit from the knowledge within the wider organization.
  prefs: []
  type: TYPE_NORMAL
- en: Code Ownership
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a polyrepo, the permissions are set at a repo level in terms of who has permission
    to view the code in a repo or make changes to it.
  prefs: []
  type: TYPE_NORMAL
- en: In a monorepo, all team members have access to view and edit all the files in
    the code. The permissions and control in a monorepo are maintained via a `CODEOWNERS`
    file later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The mental model with monorepos is everybody in the team can make changes to
    a file and raise a request to merge their changes; however, only the rightful
    owner defined in the `CODEOWNERS` file has the permission to accept or reject
    the changes being made by a team member.
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As may be obvious by now, polyrepos provide the highest level of flexibility,
    in terms of how the code within each team is managed.
  prefs: []
  type: TYPE_NORMAL
- en: In a monorepo, this flexibility is intentionally restricted to ensure that all
    team members benefit from the best coding practices and tooling setup that the
    team can offer.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With polyrepos, refactoring code across multiple repos can be time-consuming
    as one will need to check out all the different repos and individually raise a
    merge request or pull request for each repository.
  prefs: []
  type: TYPE_NORMAL
- en: With monorepos, doing such large-scale refactoring is quite easy by making atomic
    commits where a single merge request can contain the necessary changes for all
    the apps.
  prefs: []
  type: TYPE_NORMAL
- en: Ownership of Upgrades
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the time comes to upgrade libraries or tooling is when the most interesting
    differences between a polyrepo and monorepo setup come into play.
  prefs: []
  type: TYPE_NORMAL
- en: In a polyrepo, the onus of upgrading shared libraries or tools lies with each
    of the teams, and the teams can choose to defer an upgrade if they have other
    priorities. This can be both good and bad. While it allows teams to upgrade at
    their own pace, there is always a risk that some teams may get far behind in upgrading
    their libraries. This becomes a serious issue if an outdated library has a serious
    security vulnerability, and teams have ignored upgrading it. Since each team is
    responsible for upgrading libraries, they are also responsible for fixing breaking
    changes, and this is often the primary trigger to defer upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: With monorepos, if a shared library or tool is being upgraded, it is easy to
    make atomic commits across all the apps within the monorepo, which means all teams
    directly get the benefit of the latest versions. What’s interesting with monorepos
    (*that have the right build tools and quality gates in place*) is the ownership
    of fixing any breaking changes lies with the library owner or the person doing
    the upgrade, as the build pipelines will not allow you to merge the code unless
    it passes all the build steps and quality gates.
  prefs: []
  type: TYPE_NORMAL
- en: Code base Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With polyrepos, your code base gradually increases over time; however, with
    a monorepo, you are dealing with a large code base right from day one, and the
    monorepo tends to grow exponentially as the application grows.
  prefs: []
  type: TYPE_NORMAL
- en: A large code base has a negative impact on productivity. Not only does checking
    out code take time but also, all the other activities, such as running build steps
    or running unit tests, take longer both on the local developer PC and also on
    the CI and CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Unless one makes use of features such as caching and building and testing only
    what has changed, monorepos can become very slow to work with.
  prefs: []
  type: TYPE_NORMAL
- en: As we reach the end of this section, we have learned about the differences between
    polyrepos and monorepos and have gone into the details of how they differ when
    it comes to things such as code refactoring and ownership, tooling team culture,
    collaboration, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see which of the two is more suited for building
    microfrontends.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Monorepos for Microfrontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After going through the pros and cons of polyrepos and monorepos, which one
    would you choose to use for your project? Well, you can choose either one of them
    and build microfrontends. Like all things in programming, there are trade-offs
    for every decision you make, and you need to be clear about what trade-offs you
    are comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the rest of this book, we will choose to go with the monorepo setup for
    the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: With monorepos, team members are naturally encouraged to collaborate by learning
    and reviewing each other’s code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows all teams to easily use a shared library of components. This ensures
    that each micro-app built as part of the overall app has the same look and feel
    and the overall user experience is consistent as the user interacts with the different
    micro-apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also makes it easy for central platform teams, such as the DevOps team or
    admin team, to easily refactor code across all the micro-apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the drawbacks of monorepos, such as the slower execution of quality
    gates on pipelines, can be overcome by making use of caching techniques, many
    of which are the default with most monorepo tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As your overall app grows, and new features get added, new micro-apps will keep
    getting added to your app. Now, if you have a polyrepo setup with each micro-app
    in its own repo, it will become quite difficult to manage the large number of
    repos.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a microfrontend setup, most of the time, you would work on your individual
    micro-app; however, at times you would need to run all the micro-apps together
    to test out your app locally. This would be quite difficult to achieve if your
    micro apps are set up in a polyrepo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we will have a look at some of the popular open source
    monorepo tools out there, which will help you decide which would be the most suitable
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Popular Monorepo tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section covers some of the most popular open source monorepo tools that
    you can choose when building your microfrontends.
  prefs: []
  type: TYPE_NORMAL
- en: Lerna
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lerna was probably the first and most widely used monorepo tool. It follows
    what is called the packages-based monorepo style. What this basically means is
    each app sits under the `packages` folder and has its own `package.json` file,
    so every app has its own set of dependencies and there is nothing common between
    these apps.
  prefs: []
  type: TYPE_NORMAL
- en: Lerna was recently adopted by the nrwl team who originally built the Nx monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Nx
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nx was the next monorepo to become very popular and is probably the most mature
    and feature-rich of all the monorepo tools out there. Nx started off as an integrated
    monorepo. What that means is, in Nx, there is a single `package.json` file on
    the root and all apps use the same version of the packages. Nx has now evolved
    to also support the package-based style of monorepos.
  prefs: []
  type: TYPE_NORMAL
- en: It comes with advanced local and distributed caching solutions and is ideal
    for managing large monorepo code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Turborepo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Turborepo is the newest entrant in the monorepos war. It follows a package-based
    style and is very similar to how Lerna works. The main advantage of Turborepo
    is it supports a local and distributed caching system and is tightly integrated
    with Vercel’s product suite, including Next.js and Vercel cloud hosting.
  prefs: []
  type: TYPE_NORMAL
- en: As we come to the end of this section, we have learned about the pros and cons
    of polyorepos versus monorepos. We saw some of the reasons why we choose to use
    monorepos for microfrontends and we also learned about some of the popular monorepo
    tools that teams use. In the next section, we will get our hands dirty setting
    up our monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our Monorepo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to set up our monorepo, which will act as a base
    for our microfrontend apps. We will learn how to set up the right permissions
    and the necessary quality gates. Along the way, we will also learn about a couple
    of productivity tricks and plugins that improve the developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: For this example and the rest of the chapters, we will use Nx as the monorepo
    to build our microfrontends as it allows you to build both a package-setup-style
    and an integrated-style monorepo. You can equally choose either Lerna or Turborepo
    to build your microfrontends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow along with the step-by-step guide to set up an Nx monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the terminal, **cd** into the folder where you generally keep your
    projects, and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, it will prompt you to select what kind of apps you would like to create.
    We will choose **react**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Select a workspace with a single React application](img/Figure_3.03_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Select a workspace with a single React application
  prefs: []
  type: TYPE_NORMAL
- en: When prompted for the application name, enter **catalog**, as this will be the
    catalog app within our microfrontend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted to select the stylesheet format, you can select the default, **CSS**,
    or any other format you prefer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it will prompt you to enable distributed caching. For this exercise, we
    will say **No**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find complete details of setting up NX here: [https://nx.dev/getting-started/intro](https://nx.dev/getting-started/intro)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will then go on to install all the dependencies and, once successfully completed,
    you should have a folder structure similar to *Figure 3**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Folder structure for our monorepo](img/Figure_3.04_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Folder structure for our monorepo
  prefs: []
  type: TYPE_NORMAL
- en: You will notice it will have created a monorepo called `my-mfe` and an app called
    `catalog` within the `apps` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and open up this folder in Visual Studio Code and, once you do that,
    you will get a prompt to install recommended plugins. Go ahead and install the
    recommended plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once all the plugins have been installed, you will notice a new icon on the
    VS Code pane, as highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Nx Console installed on VS Code](img/Figure_3.05_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Nx Console installed on VS Code
  prefs: []
  type: TYPE_NORMAL
- en: Nx Console is one of the coolest features of using Nx and we will be extensively
    using it for the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: For those curious about how this popup to install recommended plugins came up,
    the answer lies in the `my-mfe/.vscode/extensions.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a VS Code feature and you can read about it here: [https://code.visualstudio.com/docs/editor/extension-marketplace#_workspace-recommended-extensions](https://code.visualstudio.com/docs/editor/extension-marketplace#_workspace-recommended-extensions)'
  prefs: []
  type: TYPE_NORMAL
- en: You can use this file to add your own list of recommended plugins that you would
    like your team members to use.
  prefs: []
  type: TYPE_NORMAL
- en: This is an easy way for teams to standardize plugins and help junior developers
    get productive faster without them having to learn things the hard way.
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that Nx has also created a few other files, such as `eslintrc.json`,
    `.prettierrc`, `.editorconfig`, and so on. All of these files help lay a good
    foundation for writing good code and ensuring consistency in how that code is
    written with regard to things such as indentation, the use of single versus double
    quotes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Running the app locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run the app locally, we could always run the terminal commands, but for a
    better developer experience, we will use the newly auto-added Nx Console extension
    we talked about earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Nx Console icon and then, under **GENERATE & RUN TARGET**, select
    **serve** and then, from the dropdown at the top, select the **catalog** app,
    then select **Execute:nx** **run catalog:serve**
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Serving the catalog app using Nx Console](img/Figure_3.06_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Serving the catalog app using Nx Console
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that it actually runs `pnpm exec nx serve catalog` in the terminal
    and, after a few seconds, you will have the catalog app running at `http://localhost:4200`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the link in the browser and get a feel for the newly created catalog app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Catalog app running on port 4200](img/Figure_3.07_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Catalog app running on port 4200
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new app with Nx Console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let us create another new app. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Nx Console and from **GENERATE & RUN TARGET**, select the **generate**
    command. Then, from the dropdown, select **Create React application**. On the
    following screen, where it asks for the name of the application, enter **checkout**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you scroll down the form for the section that says **e2eTestRunner**, select
    none. This will ensure the **checkout-e2e** folder is not created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Notice as you fill in the form fields that Nx is actually doing a dry run on
    the terminal to show what the output would look like.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and click on the `apps` folder of the monorepo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Nx Console, go ahead and serve the checkout app. On the nx serve checkout
    screen, scroll down a bit and select **port** and type 4201 then select **Execute:nx
    run checkout:serve –port=4201** to run the checkout app on port 4201.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can follow the same steps to create additional apps. Nx comes with a whole
    set of core and community plugins, which allows you to create apps in different
    frameworks, such as Angular, Next.js, Vue, and so on. You can view the full list
    of plugins available here: [https://nx.dev/community](https://nx.dev/community).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting permissions in your Monorepo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have multiple apps within the monorepo and we assume there are independent
    teams working on each of these apps, the next thing that arises is how we ensure
    the right permissions to ensure that teams don’t accidentally make changes to
    another team’s code.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier, the general thought process with monorepos is that everybody
    with access to the repo has access to all the apps and folders within the monorepo
    but they can’t merge code changes in apps they don’t own.
  prefs: []
  type: TYPE_NORMAL
- en: 'In monorepos, the permissions are set at a folder level and by making use of
    the `CODEOWNERS` file. You can read in detail about `CODEOWNERS` here: [https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The **CODEOWNERS** file works with GitHub and GitLab. If you are using Azure
    DevOps, this feature is implemented via the required approvers feature: [https://learn.microsoft.com/en-gb/azure/devops/repos/git/branch-policies?view=azure-devops&tabs=browser#automatically-include-code-reviewers](https://learn.microsoft.com/en-gb/azure/devops/repos/git/branch-policies?view=azure-devops&tabs=browser#automatically-include-code-reviewers).'
  prefs: []
  type: TYPE_NORMAL
- en: In short, the `CODEOWNERS` file allows us to ensure that an individual or a
    team is explicitly involved in the code review and approval of changes to files
    they own.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can assign files in two ways: all files within a given folder or all files
    of a certain type.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see this in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root of our monorepo, let’s create a file called `CODEOWNERS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What this means is if any of the pull requests contain modifications to files
    within the `apps/catalog` folder, it will automatically add people from the catalog
    team as reviewers to the pull request, and without approval from that team, the
    pull request cannot be merged.
  prefs: []
  type: TYPE_NORMAL
- en: The same holds true for pull requests with modifications to files in the `checkout`
    folder. In this case, it will require an explicit approval from members of the
    checkout team.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also assign an individual in the `CODEOWNERS` file. Let’s say we want
    to ensure that any changes to files in the `tools` folder need approval from GitHub
    user `@msadmin`. Let’s also assume we have a CSS expert on our team and would
    like that person to review all CSS changes in the entire repo. We can add the
    following two rules to enable this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can ensure a fine-grained approval process for pull requests, ensuring
    that the right stakeholders are involved in the approval of all changes being
    made to the files they are responsible for. As you can see, this also allows you
    to set rules so that an individual’s expertise on a certain subject can be leveraged
    for the overall benefit of the whole team.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few points to keep in mind as you create entries in the
    `CODEOWNERS` file:'
  prefs: []
  type: TYPE_NORMAL
- en: File paths in the file are case-sensitive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The priority of the rules is from the bottom to the top of the **CODEOWNERS**
    file; for example, if there are multiple matching rules, the bottom-most row gets
    the highest priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a row has a syntax error, it will be skipped, and GitHub will simply move
    on to the next row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test this, push the code to GitHub with the entries in the `CODEOWNERS` file,
    make changes to the file, and raise a pull request to see the `CODEOWNERS` file
    come into action.
  prefs: []
  type: TYPE_NORMAL
- en: Having come to the end of this section, we have learned how to initialize a
    monorepo using Nx, how to create apps within our monorepo, and how to run them
    individually using NX Console. We also had a quick look at some of the tooling
    advantages we get with Nx, which offers a really good developer experience for
    beginners and also ensures a strong foundation for your application by automatically
    setting up some of the quality gates for your repo. Finally, we looked at the
    various way we can set up permissions on our repo to allow open collaboration
    and also leverage individual team members’ strengths for the benefit of the whole
    team.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we come to the end of this chapter, where we unpacked quite a bit.
    We saw how teams today are choosing between a monorepo and a polyrepo approach
    to version control their code bases.
  prefs: []
  type: TYPE_NORMAL
- en: We then went into the details of how the choice of a polyrepo or a monorepo
    impacts how your teams operate, how easy or difficult it is to refactor code,
    and who owns the responsibility of fixing breaking changes in the repo.
  prefs: []
  type: TYPE_NORMAL
- en: We then saw why choosing monorepos for microfrontends has more benefits, such
    as the ease of managing all the micro-apps within a single repo, especially when
    it comes to running multiple apps locally and managing the tooling centrally for
    all the apps within the monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we went about setting up our monorepo, where we saw the benefits of
    using a tool such as Nx, which provides us with prebaked quality gates such as
    ESLint and Prettier to ensure consistency and code quality. We also saw how to
    use Nx Console to easily create new micro-apps and run existing micro-apps. We
    then saw how to set up the `CODEOWNERS` file to ensure granular control over who
    can approve code changes for a given micro-app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take our current setup and go about creating a
    full-fledged multi-SPA pattern microfrontend.
  prefs: []
  type: TYPE_NORMAL
