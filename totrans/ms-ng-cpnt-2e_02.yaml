- en: Ready, Set, Go!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start building our task management application. We'll
    jump right into the core of the application and create the initial components
    required to manage a simple task list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the process of going through this chapter, you''ll learn about the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to `NgModule`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrapping an Angular application using a main module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component input and output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host property binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling and view encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `EventEmitter` to emit custom events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After picking up the basics from the previous chapter, we will now go on and
    create a task management application together in the upcoming chapters. You'll
    learn about some concepts during these chapters and then use them with practical
    examples. You'll also learn how to structure an application using components.
    This begins with the folder structure and ends with setting up the interaction
    between components.
  prefs: []
  type: TYPE_NORMAL
- en: Vision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The task management application, which we''re going to create during the course
    of this book, should enable users to manage tasks easily and help them organize
    small projects. Usability is the central aspect of any application; therefore,
    you''ll need to design a modern and flexible user interface that will support
    the users managing their tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfbc15e1-5f86-4f48-9c80-2ccf9f0c5e12.png)'
  prefs: []
  type: TYPE_IMG
- en: A preview of the task management application we are going to build
  prefs: []
  type: TYPE_NORMAL
- en: 'Our task management application will consist of components that will allow
    us to design a platform, providing a great user experience for the purpose of
    managing tasks. Let''s define the core features of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing tasks within multiple projects and providing a project overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple scheduling as well as a time-and-effort-tracking mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overviewing the DASHBOARD using graphical charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking activities and providing a visual audit log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple commenting system that will work across different components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The task management application is the main example in this book. Therefore,
    the building blocks within this book should only contain the code that is relevant
    to the theme of this book. Of course, other than components, an application needs
    other functionalities, such as visual design, data, session management, and other
    important parts, to work. While the required code for each chapter can be downloaded
    online, we'll only discuss the code that is relevant to the topics that we will
    be learning about in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start out by creating a new Angular project using the Angular CLI. We''ll
    name it `mastering-angular-components`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a console window and navigate to a proper workspace for our project. Let''s
    use the Angular CLI to create our initial project structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After the project has been successfully created, let''s move into the project
    folder and start serving using the `ng serve` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After following the preceding steps, you should be able to open up your browser
    and point it to `http://localhost:4200`. You should be able to see the generated
    application app with a welcome message saying Welcome to mac!.
  prefs: []
  type: TYPE_NORMAL
- en: It's recommended that you leave the serving mode of the CLI running all the
    time while in development. Since the underlying webpack will use caching when
    recompiling the output bundles, it will speed up your development process quite
    a lot. I recommend that you always have a second command-line window open and
    start Angular CLI in serve mode there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine what the Angular CLI tool has created for us so far. Along with
    a lot of files that we''ll cover in later chapters, the Angular CLI tool has created
    the core files that are needed in order to assemble a simple Angular application.
    The following directory listing shows all the critical files, which you''ll also
    find within your generated project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a quick look at these dependencies, development dependencies, and
    their purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File(s)** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `package.json` `node_modules` | Since the Angular CLI uses Node.js for tooling,
    our project contains a `package.json` to store all required dependencies and their
    versions. Node dependencies get installed within the `node_modules` folder.If
    you want to check which version of Angular has been installed along with your
    project, you can check the dependencies within the `package.json` file. |'
  prefs: []
  type: TYPE_TB
- en: '| `src/index.html` | The main HTML file of your project. Within this file,
    you''ll find the host element of your root component. This is the place where
    you root or main component will be rendered. Just open the file and you''ll notice
    an element called `<mac-root>`. Since we''ve specified the prefix `mac` when creating
    our project using the Angular CLI, all our components and therefore all our component
    host elements contain this prefix. |'
  prefs: []
  type: TYPE_TB
- en: '| `src/main.ts` | This is the main entry file of our TypeScript project code.
    It contains all the necessary code to start Angular and bootstrap our main application
    module. |'
  prefs: []
  type: TYPE_TB
- en: '| `src/styles.css` | Any global CSS styles we''d like to apply to our application
    website go here. |'
  prefs: []
  type: TYPE_TB
- en: '| `src/app/app.module.ts` | The main `NgModule` of your Angular project. This
    module is bootstrapped when your application is starting up. It contains references
    to your project components and specifies your main entry component, which should
    be rendered at startup. |'
  prefs: []
  type: TYPE_TB
- en: '| `src/app/app.component.ts` `src/app/app.component.html` `src/app/app.component.css`  |
    The main component of your Angular application. This component represents the
    outermost component, sometimes just called app or root component. The TypeScript,
    HTML, and CSS code is separated into different files by default. This can also
    be changed so that everything is embedded within the TypeScript file. However,
    following a good separation practice, it makes absolute sense to have all concerns
    about the component in individual files. |'
  prefs: []
  type: TYPE_TB
- en: Main application component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at our main application component. You can think of it as
    the outermost component of your application. It's called the main component because
    it represents your whole application. This is where your component tree has its
    roots and therefore it's sometimes also called the root component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the component TypeScript file located in `src/app/app.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing different here from what we already know about structuring a
    component, something that we learned in the previous chapter. However, there are
    two main differences here compared to how we created the components before. Instead
    of using the `template` property to write our HTML template inline, we're using
    the `templateUrl` property to tell Angular to load the HTML from the specified
    file. The second thing which we've not covered yet is how to load CSS for your
    component. The `styleUrls` property allows us to specify an array of URLs which
    get resolved to assemble the styles of our component. Similar to the HTML template
    mechanism, we could also use a property called `styles` to write our styles inline
    within the component TypeScript file.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we'd like to change the behaviour slightly on how we handle
    styling. The default way of organizing styles when creating components is that
    each component contains its own encapsulated styles. However, for our project,
    we want to use the global `styles.css` file to add all our component styles. This
    will make it much easier to work with the books source repository and eliminates
    the need to include CSS code excerpts within this book.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Angular uses a Shadow DOM emulation on our components, which is
    preventing styles within a component to leak outside and influence other components.
    However, this behaviour can be changed easily by configuring the view encapsulation
    on components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular has three ways to handle view encapsulation and each way has its own
    pros and cons. Let''s look at the different settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Encapsulation type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ViewEncapsulation.Emulated` | If a component is set to emulated view encapsulation,
    it will emulate style encapsulation by attaching the generated attributes to the
    component element and modifying CSS selectors to include these attribute selectors.
    This will enable certain forms of encapsulation, although the outer styles can
    still leak into the component if there are other global styles.This view encapsulation
    mode is the default mode, if not specified otherwise. |'
  prefs: []
  type: TYPE_TB
- en: '| `ViewEncapsulation.Native` | Native view encapsulation is supposed to be
    the ultimate goal of the view encapsulation concept within Angular. It makes use
    of Shadow DOM, as described in the previous chapter, to create an isolated DOM
    for the whole component. This mode depends on the browser to support Shadow DOM
    natively, and therefore, can''t always be used. It''s also important to note that
    global styles will no longer be respected and local styles need to be placed within
    the component in inline style tags (or use the `styles` property on the component
    annotation). |'
  prefs: []
  type: TYPE_TB
- en: '| `ViewEncapsulation.None` | This mode tells Angular not to provide any template
    or style encapsulation. Within our application, we rely on styles coming from
    a global CSS; therefore, we use this mode for most of the components. Neither
    Shadow DOM, nor attributes will be used to create style encapsulation; we can
    simply use the classes specified within our global CSS file. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s change the view encapsulation of our main component to use the `ViewEncapsulation.None`
    mode. Since we''re going to put all our styles in the global `src/styles.css`
    file, we can also remove the `styleUrls` property from our component configuration
    completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Resource download
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the first few chapters of this book is to build our application
    from scratch. There's some code which is necessary to build an application, which
    does not exactly meet the topic of this book, to master the creation of a solid
    component architecture. One of those things is CSS styling. Although an integral
    part of everything built with web technology, it's definitely not something to
    be bothered too much by in this book.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, I've prepared all the CSS styling which is used within the
    components created throughout this book. Before you continue working on your application,
    you should download these styles and apply them to your project. Please find the
    exact download link in the download section of Chapter 11, *Task Management Application
    Source Code*.
  prefs: []
  type: TYPE_NORMAL
- en: Place the downloaded StyleSheet into the `src` folder of your project where
    it will replace the existing `styles.css` file.
  prefs: []
  type: TYPE_NORMAL
- en: Main application NgModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s also take a look at the main `NgModule` generated by the Angular CLI.
    You can find it in the path `src/app/app.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you've been following the section *Angular NgModule*, about `NgModule` within
    the first chapter of this book, there should not be any surprises when looking
    at our generated main application module.
  prefs: []
  type: TYPE_NORMAL
- en: Our application currently only consists of one component, the `AppComponent`,
    which we're declaring within our `AppModule`. We also specify that this component
    should be bootstrapped when this module is being bootstrapped.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting point of our project is located within the `src/main.ts` file.
    This file is responsible for bootstrapping the Angular framework and starting
    our applications main module.
  prefs: []
  type: TYPE_NORMAL
- en: We can go ahead and bootstrap our Angular application by providing our main
    application module, `AppModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to bootstrap an Angular module, we first need to create a platform.
    There are many ways for different platforms and environments to create a platform.
    If you''d like to create a browser platform, which is the default platform for
    browser environments, we need to import the platform factory function `platformBrowserDynamic`
    from the `@angular/platform-browser-dynamic` module. Simply by calling the platform
    factory function, we will receive an instance of the newly created platform. On
    the platform instance, we can then call the `bootstrapModule` function, passing
    our main application module as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at the steps involved in the bootstrapping mechanism
    of Angular. We should try to understand how our root component is getting rendered
    in the right place by calling the `bootstrapModule` function on the platform instance:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we call the `bootstrapModule` function on our platform instance, passing
    our main application module as a parameter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular will examine our main application module metadata and find the `AppComponent`
    listed in the `bootstrap` property of the `NgModule` configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By evaluating the metadata on the `AppComponent`, looking at the `selector`
    property, Angular will know where to render our root component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `AppComponent` is rendered as our root component into the host element found
    within the `index.html` file matching the CSS selector in the `selector` property
    on the component metadata
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make sure our modifications to the main component, `AppComponent`, are working
    as expected and we didn''t break anything, let''s start our application using
    the Angular CLI. Open a command line and point it to your project directory. Then,
    start the CLI in serve mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If everything goes well, you will have an open web browser that shows Welcome
    to mac!.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recap what we have done so far:'
  prefs: []
  type: TYPE_NORMAL
- en: We initialized a new project using Angular CLI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We modified our main application component in `src/app/app.component.ts` to
    include `ViewEncapsulation.None` for enabling global styles
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've looked at the generated `MainModule` as well as the bootstrapping happening
    within our main entry file `src/main.ts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we used the Angular CLI to start our application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a task list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our main application component set up, we can go on and start
    fleshing out our task management application. The second component that we're
    going to create will be responsible for listing tasks. Following the concept of
    composition, we'll create a task list component as a subcomponent of our main
    application component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new component for our task list by using the Angular CLI generator
    functionality. We already want to structure our application by area, where we
    put all task-relevant components into a `tasks` subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using the `--spec false` option while generating our component, we can skip
    creating test specifications. Since we're going to cover testing in a later chapter,
    we're skipping this process for the moment. Also, by using the `-ve none` parameter,
    we can tell Angular to create the component using `ViewEncapsulation.None` as
    a default encapsulation setting.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using the Angular CLI tool to generate components, they will be automatically
    added to your main module. This is really handy and offloads a lot of boilerplate
    work on your side. If you're creating a component manually, you should never forget
    to include the newly created component within your `NgModule` declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the generated file `src/app/tasks/task-list.ts` and do some modifications
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We've created a very simple task list component that has a list of tasks stored
    internally. This component will be attached to HTML elements that match the CSS
    element selector `mac-task-list`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create a view template for this component to display the tasks. As
    you can see from the `templateUrl` property within the component metadata, we
    are looking for a file called `task-list.component.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the content of this file to match the following excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We use the `NgFor` directive to repeat the outermost DIV element for as many
    tasks as we have on the task list of our component. The `NgFor` directive in Angular
    will create a template element from its underlying content and instantiate as
    many elements from the template as the expression evaluates to. We currently have
    two tasks in our task list component, so this will create two instances of our
    template.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left to do in order to make our task list work is include the task
    list component within the main application component. We can go ahead and modify
    our `src/app/app.component.html` file and change its content to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This was the last change we needed to make in order to make our task list component
    work. To view your changes, you can start the serving mode of Angular CLI, if
    you don't have it running already.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at what we did in the previous building block. We achieved a simple
    listing of tasks within an encapsulated component by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We created the component TypeScript file that contains the logic of our component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created the component's view within a separate HTML file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We included the component HTML element within our main application view template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The right size of components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our task list is displayed correctly and the code we used to achieve this looks
    quite okay. However, if we want to follow a better approach for composition, we
    should rethink the design of our task list component. If we draw a line at enlisting
    the task list's responsibilities, we would come up with things such as listing
    tasks, adding new tasks to the list, sorting or filtering the task list; however,
    operations are not performed on an individual task itself. Also, rendering the
    task itself falls outside of the responsibilities of the task list. The task list
    component should only serve as a container for tasks.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at our code again, we will see that we're violating the single responsibility
    principle and rendered the whole task body within our task list component. Let's
    take a look at how we can fix this by increasing the granularity of our components.
  prefs: []
  type: TYPE_NORMAL
- en: The goal now is to do a code refactoring exercise, also known as extraction.
    We are pulling our task's relevant template out of the task list template and
    creating a new component that encapsulates the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the Angular CLI to create a new task component. Open a command line
    and enter the root folder of our application. Execute the necessary code to create
    the task component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a new folder which includes all the code for our new task
    component. Now, let''s open the HTML template on the path `src/app/tasks/task/task.component.html`
    and change the content to represent a single task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The content of our new `task.component.html` file is pretty much the same as
    what we already have within our task list component. However, within the newly
    created task component, we're only concerned about what a task looks like and
    not about the whole list of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the task component TypeScript file located on the path `src/app/tasks/task/task.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previous chapter of this book, we spoke about encapsulation and the preconditions
    to establish a clean encapsulation for UI components. One of these preconditions
    is the possibility to design proper interfaces in and out of the component. Such
    input and output methods are necessary to make the component work within compositions.
    That's how a component will receive and publish information.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from our task component implementation, we are now building such
    an interface using the `@Input` decorator on a class instance property. In order
    to use this decorator, we will first need to import it from the angular core module.
  prefs: []
  type: TYPE_NORMAL
- en: Input properties in Angular allow us to bind expressions in our templates to
    class instance properties on our components. This way, we can pass data from the
    outside of the component to the component inside, using the component's template.
    This can be thought of as an example of one-way binding, from the view of a parent
    component to the child component instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re using property binding on a regular DOM property, Angular will create
    a binding of the expression directly to the element''s DOM property. We''re using
    such a type of binding to bind the task completed flag to the `checked` property
    of the checkbox''s `input` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Usage** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `@Input() inputProp;` | This allows us to bind the `inputProp` attribute
    to the component element within the parent component.Angular assumes that the
    attribute on the host element has the same name as that of the `input` property.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@Input(''inp'') inputProp;` | You can also override the name of the attribute
    that should be mapped to this input. Here, the `inp` attribute of the component''s
    host element is mapped to the component''s input property, `inputProp`. |'
  prefs: []
  type: TYPE_TB
- en: The last missing piece so that we can use our newly created task component is
    the modification of the existing template of the task list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We include the task component within our task list template by using a `<mac-task>`
    element, as specified in the selector within our task component. Also, we need
    to create an input binding on the task component to pass the `task` object from
    the current `NgFor` iteration to the `task` input of the `task` component. We
    need to replace all the existing content in the `src/app/tasks/task-list/task-list.component.html`
    file with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You've successfully refactored your task list by extracting
    the task into its own component and established a clean composition, encapsulation,
    and single responsibility. Also, we can now say that our task list is a composition
    of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: If you think about maintainability and re-usability, this was actually a very
    important step in the process of building our application. You should constantly
    look out for such composition opportunities, and if you feel something could be
    arranged into multiple subcomponents, you should probably go for it. Of course,
    you can also overdo this. There's simply no golden rule to determine what granularity
    of composition is the right one.
  prefs: []
  type: TYPE_NORMAL
- en: The right granularity of composition and encapsulation for a component architecture
    always depends on the context. My personal tip here is to use known principles
    from OOP, such as single responsibility, to lay the groundwork for a good design
    of your component tree. Always make sure your components are only doing things
    that they are supposed to do as their names suggest. A task list has the responsibility
    of listing tasks and providing some filters or other controls for the list. The
    responsibility of operating on individual task data and rendering the necessary
    view clearly belongs to a task component and not the task list.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this building block, we cleaned up our component tree and established clean
    encapsulation using subcomponents. Then, we set up the interfaces provided by
    Angular using input bindings. We performed these actions by following the ensuing
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a task subcomponent
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used the task subcomponent with the task list component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used input bindings and DOM element property bindings to establish one-way
    data binding in the task component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our task list looks nice already, but it would be quite useless if the user
    is unable to add new tasks to the list. Let's create a component for entering
    new tasks together. Let's create a new component with the responsibilities of
    handling all the UI logic necessary for entering a new task to our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the Angular CLI tool to create a new component stub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up the template of the newly created component located at `src/app/tasks/enter-task/enter-task.component.html`
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This template consists of an input field as well as a button to enter a new
    task. If you take a closer look at the input field, you can see that we've added
    a special attribute called `#titleInput`. This is called a local view reference
    and we can use this reference within the current component view, or query for
    the element within our component code.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are actually using the local view reference to pass the input
    field DOM element to the `enterTask` function that we call on a click event on
    the `Add Task` button. All local view references are available as variables within
    expressions in the view of a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation of our component class for entering
    a new task. For this, we need to replace the generated code in the `src/app/tasks/enter-task/enter-task.component.ts`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For this component, we've chosen a design approach where we use a loose relation
    to our task list where the actual task will be created. Although this component
    is closely related to the task list, it's better to keep the components as loosely
    coupled as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the simplest forms of inversion of control, a callback function or event
    listener is a great principle to establish loose coupling. In this component,
    we are using the `@Output` decorator to create an event emitter. The output properties
    need to be instance properties that hold an event emitter within the component.
    On the component''s host element, we can then use event bindings to capture any
    events emitted. This gives us a great flexibility that we can use to create a
    clean application design, where we glue components together through the binding
    within the view:'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, your output names will clash with your component instance
    methods names. For this purpose, it's advised that you stick to some naming conventions
    when naming your outputs and methods which will trigger the outputs. Within this
    book, we are sticking to the naming convention of prefixing all output names with
    the prefix "out". This way, we can avoid name clashes and still keep names similar.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Usage** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `@Output() outputProp = new EventEmitter()`; | When `outputProp.emit()` is
    called, a custom event with the name `outputProp` will be emitted on the component.
    Angular will look for event bindings on the component''s HTML element (where the
    component is used) and execute them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Within the expressions in event bindings, you will always have access to a synthetic
    variable called `$event`. This variable is a reference to the data emitted by
    the event emitter. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `@Output(''out'') outputProp = new EventEmitter();` | Use this way of declaring
    your output properties if you''d want to name your events differently from what
    your property name is. In this example, a custom event with the name `out` will
    be fired when `outputProp.emit()` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s use our newly created component to add new tasks to our task list
    component. First, let''s modify the existing template of the task list component.
    Open the task list template file, `src/app/tasks/task-list/task-list.component.html`.
    We need to add the `enter-task` component to the template and also handle the
    custom event that we''re going to emit, once a new task is entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Since the output property within the enter task component is called `outEnterTask`,
    we can bind it with the event binding attribute `(outEnterTask)=""` on the host
    element of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Within the event binding expression, we then call a function on our task list
    component called `addTask`. We also use the synthetic variable `$event`, which
    contains the task title emitted from the enter task component. Now, whenever we
    push the button in our enter task component and an event gets emitted from the
    component, we catch the event in our event binding and handle it within the task
    list component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to make some minor changes to the task list component''s TypeScript
    file. We need to implement the `addTask` function, which gets called within the
    template of the task list component. Let''s open `src/app/tasks/task-list/task-list.component.ts`
    and modify it with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have created a function, `addTask`, which will add a new task to our task
    list with a title that is passed to the function. Now, the loop is closed and
    our event from the enter task component is forwarded to this function within the
    view of the task list component.
  prefs: []
  type: TYPE_NORMAL
- en: Now is a good time to preview your changes if you haven't already. Try adding
    new tasks to the list and relate the behaviour to the changes you've applied to
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have added a new enter task component which is responsible for providing
    the UI logic to add new tasks. We have covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a child component that is loosely coupled using output properties
    and event emitters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned about the `@Output` decorator and how to use it to create output
    properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used event bindings to react on component output and execute actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom UI elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard UI elements in the browser are great, but sometimes, modern web
    applications require smarter and more complex input elements than the ones available
    within the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now create two specific custom UI elements that we''ll use within our
    application going forward in order to provide a nice user experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkbox**: There''s already a native checkbox input in the browser, but
    sometimes, it''s hard to fit it into the visual design of an application. Native
    checkboxes are limited in their styling possibilities, and therefore, it''s hard
    to make them look great. Sometimes, it''s those minor details that make an application
    look appealing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toggle buttons**: This is a list of toggle buttons, where only one button
    can be toggled within the list. They can also be represented with a native radio
    button list. However, like with native checkboxes, radio buttons are sometimes
    not really the nicest visual solution to the problem. A list of toggle buttons
    that also represent a select-one-user input element is much more modern and provides
    the visual aspect that we are looking for. Besides, who doesn''t like to push
    buttons?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create our custom checkbox UI element first. As we''ll probably come
    up with a few custom UI elements, we will introduce a new top-level UI folder.
    By calling the Angular CLI generator with the right parameter, we can create the
    stub for our checkbox component in the right folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with the template of our new component and change the content
    of `src/app/ui/checkbox/checkbox.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: On the checkbox input, we have two bindings. First, we have a property binding
    for the `checked` property on the DOM element. We are binding the DOM property
    to the `checked` member field on our component, which we are going to create in
    a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have an event binding on the input element where we listen for the
    checkbox change DOM event and call the method `check` on our component instance.
    We use the synthetic variable `$event` to pass the `checked` property of the checkbox
    DOM element where the change event originated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to our component class implementation, let''s edit the TypeScript
    file on the path `src/app/ui/checkbox/checkbox.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing special about this component class. It uses an input property
    to set the checked state from the outside, and it also has an output property
    with an event emitter that allows us to notify the outer component about the changes
    of the checked state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s integrate our checkbox in the task component to replace the native checkbox
    input we''re currently using there. For this purpose, we need to modify the `src/app/tasks/task/task.component.html`
    file by replacing its previous content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now already be able to see the changes in your browser and our nice
    custom checkbox component in action. As a next step, we''d like to apply some
    styling changes when a task is marked as done. This gives us better visual feedback
    than just the tick of the checkbox. For this, we''re looking at a new concept
    to manipulate the host element of a component. Let''s open the task component
    class on the path `src/app/tasks/task/task.component.ts` and add the following
    code to the body of the `TaskComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Using the `@HostBinding` decorator, we can create property bindings on the component
    host element based on the members of our component. Let's use this decorator in
    order to create a binding that will conditionally set a class with the name `done`
    on the component's HTML element. This is used to make some visual distinctions
    of finished tasks within our styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good time to check your result and play around with these large new
    checkboxes in the task list. Isn''t that much more fun to do than activating regular
    checkboxes? Don''t underestimate the effect of a user interface that is pleasing
    to use. This can have a very positive impact on the usage of your product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d491a9c-a40a-4b89-8537-f3fd766160dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Our task list after adding our custom checkbox component
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you learned how to build custom UI components that are generic
    and loosely coupled so that they can be used in other components as subcomponents.
    We also completed the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a subcomponent that is loosely coupled using output properties and
    event emitters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned what the `@Output` decorator is and how to use it to create output
    properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used event bindings to link the behaviour together from the view of a component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task data service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned a lot about building basic components and how to compose
    them together in order to form larger components. In the previous building block,
    we created a reusable checkbox UI component, which we've used to enhance the usability
    of our task list.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will use the toggle button component to create a filter for
    our task list. But before we start to introduce more complexity into our application,
    we're going to refactor our application by introducing data services. As our application
    gets larger, it's crucial to centralize our data manipulation and streamline our
    data flow. Services come in very handy since they allow us to store state which
    is accessible in all our components using Angular's dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Going forward, we'll deal with quite a lot of data within our application. TypeScript
    supports us very well when it comes to building type-safe data structures. So
    far, we've treated our task data as object literals, and TypeScript was extracting
    type information from there. However, as we start to use our data in different
    areas of our application, it makes sense to model our data in a central location.
    For this purpose, we're going to create our first TypeScript interface for representing
    our task data. In TypeScript, we can not only use interfaces for implementing
    classes and polymorphism, we can also use it to solely add type safety to our
    object literals and operations on objects. This is considered a very useful practice
    and will save us from a lot of potential bugs in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new TypeScript file on the path `src/app/model.ts` and add
    the following content to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have stored our task list data directly within the task list component,
    but let's change that here and use a service that will provide task data for us.
    It's generally never a good idea to store data directly within a component. Refactoring
    our data into services is only the first step toward a clean component architecture,
    and we will learn about different methods about how to store our state and data
    in later chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the service we''re about to create, we''re going to make use
    of Angular''s dependency injection for the first time. The Angular CLI comes in
    handy here, too. We can use it to generate a stub service for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a file for us located on the path `src/app/tasks/task.service.ts`.
    Let''s open this file in an editor and edit it with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We've moved all our task data into the newly created service. In order to make
    our service class injectable, we need to decorate it with the `@Injectable` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: We're also using the `Task` interface for our tasks so that we have better type
    safety when working with task objects. In order to keep our data encapsulated
    and safe, we're going to create a clone of the internal tasks list when we're
    exposing it to any consumers. In JavaScript, we can simply call `Array.prototype.slice`
    in order to create a copy of an existing array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use our task service within components, we need to provide it
    as a dependency. Dependencies are typically provided on the application level.
    In order to provide a dependency on the application level, we need to do some
    modifications to our main application module located on the path `src/app/app.module.ts`.
    The changes to the module are highlighted in the following code excerpt. The ellipsis
    character indicates that there''s more code in the existing file, which is irrelevant
    for the changes we are applying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Since we've provided our task service to the main module as a dependency, it
    will now be available for injection from the application injector.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can go ahead and modify our task list component to consume our task
    service. All our tasks are now stored in the task service and we need to remove
    the data which we previously embedded into the task list component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply the changes to our task list component and modify the `src/app/tasks/task-list/task-list.component.ts`
    file. The following excerpt contains the whole code for the task list component.
    The changed and new sections are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Instead of storing all our tasks within the task list component, we're now just
    declaring the `tasks` member. On the constructor of our component, we're using
    dependency injection to inject our newly created task service. Within the constructor
    body, we're retrieving task data by calling the `getTasks` method on our service.
    The resulting list is then stored within the `tasks` member of our component.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `addTask` method, we're no longer directly modifying our task list.
    Instead, we're using the service to add a new task. After that, we need to get
    the updated list from the service by calling `getTasks` again.
  prefs: []
  type: TYPE_NORMAL
- en: We've also created a method called `updateTask` to update our tasks using our
    task service. Until now, we have updated the task data directly within our task
    component. The output binding on our checkbox was modifying the task's state on
    updates directly from within the view. While we're shaping our application, it
    becomes critical that we modify the state of our application in a more controlled
    manner. Imagine that you have dozens of components within your application, where
    each of them is modifying the state of your application. This would be a true
    maintenance hell.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how should we best approach this problem? The answer is delegation. We
    will delegate state manipulation to our parent components until we reach a component
    which is supposed to handle the manipulation. Component output is perfect for
    this use-case. We can tell our parent component about a change by emitting an
    output value. In our case, this means the following flow should occur:'
  prefs: []
  type: TYPE_NORMAL
- en: The checkbox component will tell the task component that the checkbox was ticked
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task component will tell the task list component that the task should be
    updated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task list component will call the service to update the task data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we''re going to fix the state manipulation which is happening within
    the task component. Open up the task component template located at `src/app/tasks/task/task.component.html`
    and perform the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re adding a new output to our task component and implementing the
    `updateTask` method in `src/app/tasks/task/task.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! All whats left to do now is to catch the `outUpdateTask` output in the
    task list component template and call the `updateTask` method, which we''ve already
    added to the component class. Let''s edit the file `src/app/tasks/task-list/task-list.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now is a good time to preview your changes in the browser. Our task list should
    be fully functional again. Try adding new tasks and marking tasks as done. Our
    task list component is already much cleaner since we're not storing any data within
    the component. Instead, we're using a service which can also be used in other
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within this section, we''ve not created anything new in the user interface
    of our application. However, it was still one of the more important sections of
    this chapter. We''ve learned about clean data flow, data and state best practices,
    and have created and integrated our first Angular service:'
  prefs: []
  type: TYPE_NORMAL
- en: We have created a task service to store and manipulate our task data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've delegated state manipulation from our task component to the task list
    component which was then interacting with our service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have learned about `@Injectable` and how to provide dependencies at the application
    level
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've injected our task service in the constructor of our task list component
    where we use it to obtain data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filtering tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to implement some filter functionality for our
    task list. In order to control the active filter criteria, we are first building
    a toggle button list component. Let''s go ahead and create a new component using
    the Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the Angular CLI generator command on your console, let''s edit
    the HTML template of the newly created component in `src/app/ui/toggle/toggle.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Nothing special here, really! We repeat a button by iterating over an instance
    field called `buttonList` using the `NgFor` directive. This button list will contain
    the labels of our toggle buttons. Conditionally, we set a class called `active`
    using a property binding and check it against our current button within the iteration
    against an instance field called `selectedButton`. When the button is clicked,
    we call a method, `activate`, on our component instance and pass the current button
    label from the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s change the code of our component class on the path `src/app/ui/toggle/toggle.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Within our toggle component, we rely on the `buttonList` input to be an array
    of button label strings. We are using this array within our template on a `NgFor`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: The `activeButton` input is expected to be set to the button label string which
    is currently active within the toggle list. We also create an output named `outActivate`
    to notify the outside world about state changes of the active toggle button.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `activate` function, we are only emitting the `outActivate` output.
    From the binding outside of the component, we then expect the `activeButton` input
    to be updated accordingly. It's important to understand that our toggle component
    is only communicating to the parent component about a button that got activated.
    It's not updating any state, really. We're expecting that the parent component
    which uses our toggle component will then update the `activeButton` input accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The `ngOnInit` method is called by Angular automatically within the life cycle
    of directives and components. This is also the reason why our toggle component
    class is implementing the life cycle hook interface `OnInit`. In the case where
    the `activeButton` input property was not specified, we'll add a check and select
    the first button from the available button list. Since `activeButton`, as well
    as `buttonList`, are input properties, we need to wait for them to be initialized
    in order to execute this logic. It's important not to perform this initialization
    within the component constructor. Only within the life cycle hook `OnInit` do
    we have the guarantee that our input properties have been set already. It is invoked
    only once for each component which is created.
  prefs: []
  type: TYPE_NORMAL
- en: Angular will call any life cycle hooks that have been implemented in your component
    automatically. The interfaces which are available for each life cycle hook are
    only helpful in the sense that they ensure you have implemented all desired callbacks
    for the individual life cycle hooks.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram illustrates the life cycle of an Angular component. Upon
    component construction, all the life cycle hooks will be called as per the order
    which is shown in the diagram, except the `OnDestroy` hook, which will be called
    upon component destruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change detection will also start a subset of life cycle hooks, where some of
    the hooks which are called during creation are skipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '`doCheck`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterContentChecked`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterViewChecked`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onChanges (if any changes are detected)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A detailed description of the life cycle hooks and their purposes is available
    on the Angular documentation website at [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db407698-3cc5-4c75-a878-4e7ff8fc780a.png)'
  prefs: []
  type: TYPE_IMG
- en: An illustration of the life cycle of an Angular component
  prefs: []
  type: TYPE_NORMAL
- en: Alright! We have created a new UI component to render a toggle button list.
    Now, it's time to move on with our main goal within this chapter, implementing
    a filtering system in our task list component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should think about the model for our filter. We''d want to include
    three states, all, open, and done, which should each result in a different view
    of our task list. Let''s open up our model file located at `src/app/model.ts`
    and add the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We're defining a type alias, which represents a list of valid filter types.
    TypeScript type aliases are really helpful in order to make certain things more
    type safe. Especially when you're dealing with string types, you can use type
    aliases to create string literal types. By creating a type alias `TaskListFilterType`,
    and later using it in the context of the filter, we can specify which strings
    are valid while filtering. This will prevent any typos when dealing with task
    filter type strings within our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to implement our filter functionality. Let''s open the task
    list component file located at `src/app/tasks/task-list/task-list.component.ts`
    and apply some code changes. Again, changed parts of the code are highlighted,
    to make it easier for you to see the effective changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Within the component, we want to store a list of types the task filter can have.
    This list will serve as input for our toggle button list. If you recall the input
    properties on our toggle button, we have a `buttonList` input that accepts a list
    of button labels. To store the currently selected filter type, we use an instance
    field called `activeTaskFilterType`.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece that we need to add to our task list component is the actual
    filtering of tasks. For this, we're introducing a new member called `filteredTasks`,
    which will always be updated with the currently filtered subset of tasks. Within
    the `filterTasks` method, we are computing the subset of filtered tasks by evaluating
    the active filter criteria stored in `activeTaskFilterType`. The result of the
    filtering will be stored in our `filteredTasks` member.
  prefs: []
  type: TYPE_NORMAL
- en: We've also created a method, `activateFilterType`, which we can call to switch
    the active filter criteria. This method will then call the `filterTasks` method
    to update our filtered subset of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, that''s all we are going to change in our component class. We still need
    to change our view template, though. We need to render our toggle component and
    execute our filtering on filter criteria changes. Since we want to render the
    filtered subset of tasks instead of the whole task list, we also need to change
    the source for the `NgFor`, which repeats our tasks in the view. Let''s open the
    template file `src/app/tasks/task-list/task-list.html` and modify it with the
    following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Let's discuss the changes quickly. First, we are binding the `taskFilterTypes`
    property where we store a list of possible filter types within the task list component
    class, to the toggle component `buttonList` input property. This will make the
    toggle component render all filter types as toggle buttons.
  prefs: []
  type: TYPE_NORMAL
- en: We also bind the `activeTaskFilterType` instance field of the task list to the
    `activeButton` input property of the toggle component. This way, changes to the
    `activeTaskFilterType` property will be reflected in the toggle component. At
    the same time, when a user changes the active toggle button inside the toggle
    component, we capture the `outActivate` output of the toggle component and call
    the `activateFilterType` method on the task list component.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it, congratulations! You''ve successfully added a filtering mechanism
    to your task list by using our newly created toggle component. Preview the changes
    in your browser; you should see a fully functional task list where you can mark
    tasks as done, add new tasks, and filter the list by activating our nice toggle
    buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a36edc80-1201-4813-9f14-65d3daa984a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of the task list with the newly added toggle button component for
    filtering the task state
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ve built a filtering system into our task list component.
    We have also created an additional UI component to render toggle buttons, which
    we''re presenting to the user for selecting the filter criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a new toggle component to render a set of toggle buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used the `@HostBinding` decorator to create property bindings declaratively
    from within our component class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned about the Angular component life cycle and how we can use the `OnInit`
    life cycle hook to initialize the component after the input has been processed
    for the first time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned a lot of new concepts on building UI component-based
    applications with Angular. We also built the core component of our task management
    application, which is the task list itself. You learned about the concept of input
    and output properties and how to use them to establish proper component communication.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the basics of the Angular component life cycle and how to use
    life cycle hooks to execute post-initialization steps within the `OnInit` hook.
  prefs: []
  type: TYPE_NORMAL
- en: As the last step, we integrated a toggle button list component within our task
    list to filter the task states. We refactored our task list component to use a
    service in order to obtain task data. For this, we used Angular's dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Within the next chapter, we're going to look at ways how to improve our handling
    of data and state. There are plenty of ways how to deal with application state
    and we're going to learn how to best tackle this issue.
  prefs: []
  type: TYPE_NORMAL
