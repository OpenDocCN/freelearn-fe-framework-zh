- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging Everything – Best Practices for Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After architecting, developing, and testing your application, it’s time to deploy
    it to your users.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn the best practices for generating production
    packages and how to use automation tools to maximize the team’s productivity and
    effectiveness at this point in the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiating environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the production bundle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting a Docker image with Nginx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a page to Azure Static Web Apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use the Angular CLI to generate
    a package optimized for production and CI/CD tools to automate this process for
    your team.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio Code** (**VSCode**) ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker ([https://www.docker.com/](https://www.docker.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker for VSCode ([https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Azure account ([https://azure.microsoft.com](https://azure.microsoft.com))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure CLI ([https://learn.microsoft.com/en-us/cli/azure/](https://learn.microsoft.com/en-us/cli/azure/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions Core Tools ([https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local](https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Tools for VSCode ([https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NestJS CLI ([https://docs.nestjs.com/cli/overview](https://docs.nestjs.com/cli/overview))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch12](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch12).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before preparing our gym diary project for production, let’s first upload the
    backend to a cloud service so that our page has access to the data.
  prefs: []
  type: TYPE_NORMAL
- en: We chose the Azure service for this book, but the concepts in this chapter can
    also be applied to other cloud services, such as AWS ([https://aws.amazon.com](https://aws.amazon.com))
    and GCP ([https://cloud.google.com](https://cloud.google.com)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The backend of this example does not use a database and was built using the
    NestJS framework ([https://nestjs.com/](https://nestjs.com/)), which actually
    has an architecture completely inspired by Angular, but for the backend! This
    framework allows you to add cloud deployment capabilities with Azure. To prepare
    your backend for deployment, in the command line of your operating system, in
    the `project` folder (`/gym-diary-backend`), run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first command installs the Angular Schematic package, which will be used
    to build the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `nest add` command has the same functionality as Angular’s `ng add` command,
    and here, in addition to installing the dependencies for deployment on Azure,
    it also configures and creates the necessary files for this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the tools from the *Technical requirements* section installed, we first
    need to create an Azure Functions project. To do this, let’s go to the Azure portal
    in the **Function App** menu option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Function App menu option](img/B19562_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Function App menu option
  prefs: []
  type: TYPE_NORMAL
- en: Azure has several ways to run a backend service, and one of the simplest is
    through Azure Functions. With it, we can upload our service without needing to
    configure a server, as the provider will take care of these details.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need to perform some basic configurations. To do this, we will click
    on **+ Create**. Once done, we will be presented with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Azure Functions service configuration](img/B19562_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Azure Functions service configuration
  prefs: []
  type: TYPE_NORMAL
- en: In the **Subscription** field, you need to choose your Azure subscription. In
    the **Resource Group** field, you can select a group that you already have; if
    you don’t have one, you can create a new one and enter its name. The **Function
    App name** field is important as it will initially be the address of your endpoint.
    It is possible to buy a specific URL or place this API behind an Azure API gateway
    (https://azure.microsoft.com/en-us/products/api-management), although this is
    not required for our example. We will deploy directly from the code, so leave
    **Do you want to deploy code or container image?** as **Code**. The project’s
    runtime stack should be set to **NodeJS**, version **18 LTS**. For the project
    region, select one close to you, or **East US**, which is the default option.
    Finally, **Operating System** should be set to **Linux**. The **Hosting options
    and plans** option should be set to **Consumption (Serverless)** as we do not
    need any more specific features in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Hosting options and plans](img/B19562_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Hosting options and plans
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are done filling in all the necessary information, click on **Review
    + Create**. On the next screen, confirm your information and execute the creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Azure Functions service created](img/B19562_12_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Azure Functions service created
  prefs: []
  type: TYPE_NORMAL
- en: 'To publish our backend to the created service, we will use the VS plugin. Open
    the backend project, left-click, and select **Deploy to Function App…**, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – VSCode extension for publishing Azure Functions](img/B19562_12_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – VSCode extension for publishing Azure Functions
  prefs: []
  type: TYPE_NORMAL
- en: The extension will get the list of services created from your account, so select
    the one we created from the **AZURE** panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – VSCode AZURE panel](img/B19562_12_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – VSCode AZURE panel
  prefs: []
  type: TYPE_NORMAL
- en: After publication, the Azure service will point you to a public URL with your
    service. Access it in a browser with the `/exercise` endpoint to check whether
    the service is live.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return of the published URL should be a list similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'One last configuration we must do is configure the service’s CORS to enable
    our local application to connect to the cloud service. In the Azure console, click
    on the created service and then on the `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – CORS configuration](img/B19562_12_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – CORS configuration
  prefs: []
  type: TYPE_NORMAL
- en: With our backend service online, we will focus on how to access it from our
    application in the next section. An important point is to always remember to turn
    off the service in Azure so as not to incur unnecessary costs when going through
    this book’s examples in your Azure account.
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After finishing the task of deploying our backend, we need to change our frontend
    project to make requests to our cloud infrastructure. But here, a problem arises.
    We want to access our published backend when we are in production, but the team
    needs to continue accessing the API locally to develop new features in a more
    practical way. How can we have the best of both worlds?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this, once again, was thought up by the Angular team and is the
    creation of configuration files for each development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Until version 14 of Angular, these files were already standard when creating
    the project (the `ng new` command). However, to simplify new projects and reduce
    the learning curve, these files were removed for new projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we shouldn’t worry because to add them, we can use the Angular CLI. On
    the command line, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After executing the preceding command, the Angular CLI creates the `environments`
    folder, and inside it, we have the `environment.development.ts` and `environment.ts`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'These TypeScript files have only one object, and this object is where we will
    place all the settings that we need to differentiate between production and development
    environments. We will first change the `environment.development.ts` file like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In these objects, we declare a flag to indicate that this is a configuration
    of the development environment and the URL of our local backend service. We will
    now change the `environment.ts` file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are doing the same but indicating the production environment of our
    application. The backend address will be the one created in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use these files, we must import them and refactor the `HostInterceptor`
    service to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our interceptor service, which is responsible for adding the URL to our
    requests (for more details, see [*Chapter 8*](B19562_08.xhtml#_idTextAnchor225),
    *Improving Backend Integrations: the Interceptor Pattern*), we use the `environment`
    object property to determine the URL.'
  prefs: []
  type: TYPE_NORMAL
- en: A point of attention here is that we must import the `environment.ts` file for
    this variable because Angular makes the change when generating the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it clear which environment we are in, we will change the `AppComponent`
    component like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this change, we are using the toaster service (for more details, refer to
    [*Chapter 8*](B19562_08.xhtml#_idTextAnchor225), *Improving Backend Integrations:
    the Interceptor Pattern*) to indicate, when the user enters the page, which environment
    they are in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run our application using the `ng serve` command, and we will get the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Application in development mode](img/B19562_12_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Application in development mode
  prefs: []
  type: TYPE_NORMAL
- en: 'If we log in to our application, we can see, by looking at the developer tools
    in the **Networks** tab, that the application is making requests to our local
    backend. To run our Angular project as a production build, we can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When accessing our application, we can see in the message on the screen that
    requests are made to the service published in our cloud service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Application in production mode](img/B19562_12_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Application in production mode
  prefs: []
  type: TYPE_NORMAL
- en: With our service prepared for multiple environments, we can now see how we can
    better prepare it for deployment in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the production bundle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The environmental needs of a frontend application running in production are
    different from the development environment we have seen so far in the book.
  prefs: []
  type: TYPE_NORMAL
- en: When we are developing, we look for speed in compilation, powerful debugging,
    and profiling tools to analyze our code, as well as generating boilerplate code,
    among other features.
  prefs: []
  type: TYPE_NORMAL
- en: Even though it costs more to process on our local machine, requires more space
    to generate instrumented bundles to be able to perform debugging, and requires
    greater network consumption to download development tools, all of this is important
    for the team’s productivity, and the Angular framework delivers it in a robust
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: When we are talking about frontend web code running in production, the objective
    is almost the opposite. We want our code to be as small and optimized as possible,
    to be downloaded and executed by our users in the most performant way possible.
  prefs: []
  type: TYPE_NORMAL
- en: With this objective in mind, the Angular framework has a robust and simple build
    tool for generating the production package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run it, we need to use the following command in our `project` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command will create the package that we will run in production in the `dist`
    folder of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'But to deepen our knowledge of the Angular framework, let’s understand what
    the basis for this build process is. The answer is in the `angular.json` file.
    Let’s analyze some important properties of the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `configurations` property, we have definitions of the types of environments
    that we can have in our project. Initially, the Angular CLI creates two configurations:
    production and development.'
  prefs: []
  type: TYPE_NORMAL
- en: In the production configuration, we have the `budgets` property, which determines
    the maximum size that our package must have in addition to defining the maximum
    size that a unitary component must have.
  prefs: []
  type: TYPE_NORMAL
- en: If your project exceeds this size, Angular may show a warning in the production
    console or even not build your project.
  prefs: []
  type: TYPE_NORMAL
- en: This is important because we need to generate the smallest file possible as
    this results in a greater perception of performance for our users, especially
    if they are using a device on a 3G network.
  prefs: []
  type: TYPE_NORMAL
- en: One way to reduce file sizes is to use Angular’s lazy-loading capabilities (for
    more details on this feature, see [*Chapter 2*](B19562_02.xhtml#_idTextAnchor081),
    *Organizing* *Your Application*).
  prefs: []
  type: TYPE_NORMAL
- en: The `outputHashing` attribute ensures that the files generated by the application
    have their names added to a hash.
  prefs: []
  type: TYPE_NORMAL
- en: This is important because most public clouds and **Content Delivery Networks**
    (**CDNs**) cache the application based on the name of the files. When we generate
    a new version of our app, we want this cache to be invalidated to deliver the
    new version to our users.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `defaultConfiguration` property determines that if no parameter
    is passed, the `ng build` command will execute with the configuration indicated
    in it, in this case, production.
  prefs: []
  type: TYPE_NORMAL
- en: These configurations can be expanded and new ones created depending on your
    project needs. In our case, we will leave it with the default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the build in production configurations, Angular performs the following
    processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ahead-of-Time (AOT) compilation**: Angular compiles templates and CSS files
    in addition to TypeScript files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Production mode**: The application has some validations optimized for running
    in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bundling**: It bundles all component files, templates, services and libraries
    in files separated by modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minification**: From the files generated by TypeScript, it concatenates and
    eliminates whitespace and comments to generate the smallest files possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uglification**: It rewrites generated code for variables, function names,
    and small, cryptic modules to make it difficult to reverse engineer the frontend
    code delivered to the user’s browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dead code elimination**: Also known as **tree shaking**, this is the process
    of not including components in bundles that are not referenced in the code and
    do not need to be present in the production package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these processes are done with the `ng build` command and with the configuration
    that was set when your project was created. It is important to note that this
    process improves with each new version of Angular and is another reason to always
    keep your project up to date with the latest versions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create a Docker image with our code built and run
    by the Nginx web server.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a Docker image with Nginx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until this chapter, we have been using the web server included in the Angular
    package to run our application locally. Although very competent, it focuses purely
    on the developer’s experience and does not have the performance and scalability
    capabilities required by the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, we use production-grade web servers. One of the most popular
    is Nginx (pronounced *Engine X*).
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure it, we need to create a file in the root of our project called
    `nginx.default.conf` and add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this configuration file, the first three properties (`listen`, `sendfile`,
    and `default_type`) aim to configure the exposed port and prepare the server to
    send our project’s package files.
  prefs: []
  type: TYPE_NORMAL
- en: The properties starting with `gzip` configure the delivery of files with the
    native web compression data `gzip`, further reducing the files delivered to our
    user’s browser.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the file determines the first page to be served. As we are
    in a `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: With this configuration, we can run Nginx, but instead of installing it natively
    on our local machine, we will use Docker to run it.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is a tool widely used in today’s modern systems and aims to compartmentalize
    an application’s environment. In other words, by configuring a file, we can create
    an environment for our application where it can be run both on our local machine
    and on a cloud provider with the same dependencies and versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s exemplify its use by first creating a file called `.dockerignore` in
    our project’s root and adding the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using the `.gitignore` file as an example, we are ensuring that the `node_modules`
    folder will not be copied to the image . Keep in mind that the image and the service
    that will be run from it (called a container in the Docker ecosystem) is as if
    it were a new machine and we will only copy what our application needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the `dockerfile` file and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we are using the multi-stage build technique to create our image.
    First, we build the application and then use the result of this build to create
    the final image. This way, our image becomes smaller and more optimized.
  prefs: []
  type: TYPE_NORMAL
- en: The first stage, which we call `build` here, is based on the `node:18-alpine`
    image, which is a minimal image with the `Alpine` Linux distribution and version
    18 of Node.js included.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `package.json` and `package-lock.json` files are copied and the `npm
    ci` command is run to install the package.
  prefs: []
  type: TYPE_NORMAL
- en: Then, with the `COPY . .` command, all project code is copied (except the `node_module`
    folder).
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this stage, our application bundle is generated using the `npm
    run` `build` command.
  prefs: []
  type: TYPE_NORMAL
- en: The next stage, which will be production, is based on the `nginx:1.25-alpine`
    image because to run the web server, we only need a Linux distribution such as
    Nginx installed.
  prefs: []
  type: TYPE_NORMAL
- en: The next task is to copy the configuration file for the Nginx installation,
    delete the example file that comes with the tool, and copy the files generated
    in the previous stage to this one.
  prefs: []
  type: TYPE_NORMAL
- en: The line `["nginx", "-g", "daemon off;"]` runs Nginx and makes it ready to deliver
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: To mount the image, right-click on the `dockerfile` file in VSCode and select
    the **Build** **Image** option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the Docker container locally, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By accessing the `http://localhost:8080` URL, we have our application running
    in production mode. Another way to put our project on the web is by using Azure
    Static Web Apps. We will work on this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a page to Azure Static Web Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the Docker image we created, we can run our project on any cloud provider
    that offers container services. However, there are other ways to deploy our Angular
    project.
  prefs: []
  type: TYPE_NORMAL
- en: One of these alternatives is Azure Static Web Apps, a service that specializes
    in web page design and allows automatic integration with GitHub. Let’s see it
    in practice in our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first requirement is that your project is on GitHub, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – GitHub repository for frontend project](img/B19562_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – GitHub repository for frontend project
  prefs: []
  type: TYPE_NORMAL
- en: If you have copied the project repository, place the `gym-diary` folder in your
    own GitHub project.
  prefs: []
  type: TYPE_NORMAL
- en: To configure the Azure service, go to the account portal and search for `Static`
    `Web Apps`.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Create Static Web App** button and the service form will be presented
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first part, we have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subscription**: Select your Azure subscription.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Group**: Create or define a group for this service. In Azure, every
    resource must be linked to a resource group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: Provide a name for your frontend project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plan type**: Select the tier of your environment. The more resources, the
    higher the cost, but for our example, we will just use the free plan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Azure Static Web App creation](img/B19562_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Azure Static Web App creation
  prefs: []
  type: TYPE_NORMAL
- en: '**Source**: In this field, we identify whether our project is on GitHub or
    in the Azure repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organization**: The name of the GitHub user or organization that you want
    to select the repository from. It is important that your user has high access
    permission, such as maintainer or admin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository**: Azure will list all the repositories that you have access to
    in the selected organization..'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branch**: The branch of the repository that you want to deploy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![ Figure 12.12 – Deployment details configuration](img/B19562_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Deployment details configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second part, we have the specific configuration for our project using
    Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build Presets**: The Azure service supports several frontend technologies.
    Here, in this case, we will choose **Angular**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Api location**: This is an optional field if you want to point to a backend
    service deployed in Azure. Here, in this example, we are going to leave it blank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dist/gym-diary/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Preset settings](img/B19562_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Preset settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, click on **Review and Create**, and on the next screen, confirm
    the operation. Azure will begin processing, and once ready, it will display the
    created service dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Service dashboard created](img/B19562_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – Service dashboard created
  prefs: []
  type: TYPE_NORMAL
- en: In the **URL** field, you will see the URL created by Azure for our project.
    Select it and our system will be presented as soon as the deploy status is **Ready**.
    So, we have our project up and running in the cloud. You can configure other settings,
    such as adding your own URL, although remember that some settings are not available
    in the free plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting thing about this feature is that it implements a GitHub
    action in our repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – GitHub action](img/B19562_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – GitHub action
  prefs: []
  type: TYPE_NORMAL
- en: What is a GitHub action? It is a GitHub feature that allows the creation and
    execution of scripts to automate tasks, such as, in our example, deploying to
    the Azure service.
  prefs: []
  type: TYPE_NORMAL
- en: With our configuration, the Azure wizard created and ran the script in our GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: A bonus is that our generated script is configured to execute and deploy with
    each push we make to the repository, updating our application deployed in the
    cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the techniques and capabilities of Angular when
    deploying our application to production.
  prefs: []
  type: TYPE_NORMAL
- en: We started by uploading our backend to the cloud, where it will be available
    for our frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we adapted our application to differentiate the development environment
    and the production environment using the Angular feature of `environment.ts` files.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the `ng build` command and all the tasks that Angular performs for
    us to make our application as lean as possible to be faster for our users.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about Docker and how we can package our Angular application to run
    on a web server such as Nginx regardless of the type of machine our application
    runs on.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about another way to deploy to the cloud with the Azure
    Static Web Apps service and saw how it automates this process by creating a GitHub
    action script.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the latest Angular innovations, including
    Angular Signals.
  prefs: []
  type: TYPE_NORMAL
