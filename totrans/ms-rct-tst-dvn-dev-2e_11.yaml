- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test-Driving React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**React Router** is a popular library of components that integrate with the
    browser’s own navigation system. It manipulates the browser’s address bar so that
    changes in your UI appear as page transitions. To the user, it seems like they
    are navigating between separate pages. In reality, they remain on the same page
    and avoid an expensive page reload.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll refactor our example appointments system to make use
    of React Router. Unlike the rest of the book, this chapter is not a walkthrough.
    That’s because the refactoring process is quite long and laborious. Instead, we’ll
    look at each of the main changes in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing React Router applications from a test-first perspective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing components within a router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing router links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing programmatic navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have learned all the necessary techniques
    for test-driving React Router integrations.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter11)'
  prefs: []
  type: TYPE_NORMAL
- en: Designing React Router applications from a test-first perspective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is a run-down of all the major pieces of the React Router ecosystem,
    just in case you’re not familiar with it. It also contains guidance on how to
    test a system that relies on React Router.
  prefs: []
  type: TYPE_NORMAL
- en: A list of all the React Router pieces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s what you’ll be working with from the React Router library:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Router` component. You’ll generally have one of these, and there are a bunch
    of different types. The basic one is `BrowserRouter` but you’ll undoubtedly upgrade
    to `HistoryRouter` if you need to manipulate history outside of the router, which,
    since you’re writing tests, you will. In [*Chapter 12*](B18423_12.xhtml#_idTextAnchor231),
    *Test-Driving Redux*, you’ll also see how this is necessary if you’re causing
    page transitions to occur within Redux actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Routes` component. This is analogous to the `switch` statement in our existing
    `App` component. It has a list of `Route` children and will choose just one of
    those children to display at one time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of `Route` components with the `Routes` parent. Each `Route` has a path
    property, for example, `/addCustomer`, that the `Router` component uses to compare
    with the window’s current location. The route that matches is the one that is
    displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more `Link` components. These display like normal HTML hyperlinks, but
    they don’t act like them; React Router stops the browser from receiving these
    navigation events and instead sends them back to the `Routes` component, meaning
    a page transition doesn’t occur.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `useNavigate` hook. This is used to perform a page transition as part of
    a React side effect or event handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `useLocation` and `useSearchParams` hooks. These are used to get parts of
    the current window location within your components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting tests when the window location changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can see from this list that React Router’s core function is to manipulate
    the window location and modify your application’s behavior based on that location.
  prefs: []
  type: TYPE_NORMAL
- en: One way to think about this is that we will utilize the window location as a
    form of application state that is accessible to all our components. Importantly,
    this state persists across web requests, because a user can save or bookmark links
    for use later.
  prefs: []
  type: TYPE_NORMAL
- en: 'A consequence of this is that we must now split apart some of our unit tests.
    Take, for example, the **Create appointment** button that was previously used
    to switch out the main component on display on the page. With React Router in
    place, this button will become a link. Previously, we had a single unit test named
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But now, we’ll split that into two tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the first test stops at the moment the window location changes.
    The second test begins at the moment the browser navigates to the same location.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to make this change because React Router isn’t just refactoring,
    it’s adding a new feature: the URL is now accessible as an entry point into your
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: That is, in essence, the most important thing you need to know before introducing
    React Router into your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Up-front design for our new routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before launching into this refactor, let’s take a look at the routes we’ll
    be introducing:'
  prefs: []
  type: TYPE_NORMAL
- en: The default route, `/`, will remain as our `AppointmentsDayViewLoader` together
    with navigation buttons. This is extracted out as a new component named `MainScreen`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A route to add a new customer, at `/addCustomer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A route to add a new appointment for a given customer, at `/addAppointment?customer=<id>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A route to search for customers at `/searchCustomers`. This can receive a set
    of query string values: `searchTerm`, `limit`, and `previousRowIds`. For example,
    the query string might look as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we’ll look at test-driving a `Router` component along with its `Route`
    children.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components within a router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll look at how to use the primary `Router`, `Routes`, and
    `Route` components.
  prefs: []
  type: TYPE_NORMAL
- en: No walkthrough in this chapter
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the chapter introduction, this chapter does not follow the usual
    walkthrough approach. The examples shown here are taken from the completed refactoring
    of our Appointments code base, which you’ll find in the `Chapter11/Complete` directory
    of the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: The Router component and its test equivalent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a top-level component that hooks into your browser’s location mechanics.
    We do not generally test drive this because JSDOM doesn’t deal with page transitions,
    or have full support for the `window.location` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we put it in the `src/index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is necessary because if you try to use any of the other React Router components
    outside of a child of a `Router` component, it will blow up. The same is true
    for our tests: our components need to be rendered inside of a router. So, we introduce
    a new render helper called `renderWithRouter`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This definition is within `test/reactTestExtensions.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: MemoryRouter versus HistoryRouter
  prefs: []
  type: TYPE_NORMAL
- en: The React Router documentation will suggest you use `MemoryRouter`, which is
    often good enough. Using `HistoryRouter` allows you to control the history instance
    that is passed in, meaning you can manipulate it from within your tests.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, take a look at [https://reacttdd.com/memory-router-vs-history-router](https://reacttdd.com/unpublished/memory-router-vs-history-router/).
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to export the `history` variable itself if you want to manipulate
    the window location from within your own tests. A special case of this is if you
    want to set the window location before mounting the component; in this situation,
    you can simply pass a `location` property to the `renderWithRouter` function.
    You’ll see how this works next.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Routes component to replace a switch statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s look at using the `Routes` component to switch components depending
    on the window location. This component is generally at the top of the application
    component hierarchy, and in our case, it is indeed the first component within
    `App`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Routes` component is analogous to the `switch` statement that existed in
    the original app. The `switch` statement was using a state variable to determine
    which component should be shown. The `Routes` component relies on the parent `Router`
    to feed it the window location as context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the original `switch` statement looked like in the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Its `Router` replacement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `view` state variable is no longer needed. Notice how we have a couple of
    new components with a `Route` suffix. These components are small wrappers that
    pull out the customer ID and other parameters from the window location before
    passing it to the original components. We’ll look at those soon.
  prefs: []
  type: TYPE_NORMAL
- en: But first, how do the tests look for these new routes?
  prefs: []
  type: TYPE_NORMAL
- en: 'For the default route, the tests are simple, and are updates to the tests that
    were there before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that we use the `renderWithRouter` helper, not `render`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other routes are similar, except that they use the `location` property
    to set the initial window location, and their assertions are based on mocked components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using intermediate components to translate URL state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a closer look at `AppointmentFormRoute` and `CustomerSearchRoute`.
    What are these components doing?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the definition of `AppointmentFormRoute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This component is an intermediate component that sits between the `Route` component
    instance for `/addAppointment` and the `AppointmentFormLoader` component instance.
  prefs: []
  type: TYPE_NORMAL
- en: It would have been possible to simply reference the `useSearchParams` function
    from within `AppointmentFormLoader` itself, but by using this intermediate class,
    we can avoid modifying that component and keep the two responsibilities separate.
  prefs: []
  type: TYPE_NORMAL
- en: Having a single responsibility per component helps with comprehension. It also
    means that should we ever wish to rip out React Router at a later date, `AppointmentFormLoader`
    doesn’t need to be touched.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of interesting tests for this component. The first is the
    check for parsing the `customer` search parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `location` property sent to `renderWithRouter` is just a standard query
    string: `?customer=123`. We could have entered a full URL here, but the test is
    clearer by focusing purely on the query string portion of the URL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second test is for the remainder of the props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The test is important because the `Route` element passes through an `onSave`
    property that is for `AppointmentFormLoader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We’ll look at what the `transitionToDayView` function does in the *Testing navigation*
    section a little further on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see `CustomerSearchRoute`. This is a little more complicated because
    it parses some of the query string parameters, using a function called `convertParams`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This function replaces the three state variables that were used in the existing
    `CustomerSearch` component. Since all query string parameters are strings, each
    value needs to be parsed into the right format. These values are then passed into
    `CustomerSearch` as props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This parameter parsing functionality could have been put into `CustomerSearch`,
    but keeping that logic in a separate component helps with readability.
  prefs: []
  type: TYPE_NORMAL
- en: This example also shows the use of `useNavigate`, which is passed through to
    `CustomerSearch`. Passing this hook function return value as a prop means we can
    test `CustomerSearch` with a standard Jest spy function for the value of `navigate`,
    avoiding the need to render the test component within a router.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests for this component are straightforward. Let’s take a look at one
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve now learned all there is to working with the three components: `Router`,
    `Routes`, and `Route`. Next up is the `Link` component.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing router links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to use and test the `Link` component. This
    component is React Router’s version of the humble HTML anchor (or `a`) tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two forms of the `Link` component that we use. The first uses the
    `to` prop as a string, for example, `/addCustomer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The second sets the `to` prop to an object with a `search` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This object form also takes a `pathname` property, but we can avoid setting
    that since the path remains the same for our use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll look at two different ways of testing links: the standard way (by checking
    for hyperlinks), and the slightly more painful way of using mocks.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking the page for hyperlinks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the `MainScreen` component in `src/App.js`, which shows the navigation
    links and the appointments day view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Extracted component
  prefs: []
  type: TYPE_NORMAL
- en: The `MainScreen` component has been extracted out of `App`. The same code previously
    lived in the `switch` statement as the default case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Link` component generates a standard HTML anchor tag. This means we create
    a helper to find a specific link by looking for an anchor tag with a matching
    `href` attribute. This is in `test/reactTestExtensions.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That can be then used to test for the presence of a link and its caption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to test this would be to click the link and check that it works,
    as shown in the following test. However, as mentioned at the beginning of this
    chapter, this test isn’t necessary because you’ve already tested the two “halves”
    of this test: that the link is displayed, and that navigating to the URL renders
    the right component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That covers the main way to test `Link` components. Another way to test links
    is to mock the `Link` component, which we’ll cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking the Link component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method is slightly more complicated than simply testing for HTML hyperlinks.
    However, it does mean you can avoid rendering your component under test within
    a `Router` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `src/CustomerSearch/RouterButton.js` file contains this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this using plain `render`, instead of `renderWithRouter`, we’ll need
    to mock out the `Link` component. Here’s how that looks in `test/CustomerSearch/RouterButton.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can happily use that mock in your test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There’s one final piece to think about. Sometimes, you have a single mocked
    component that has multiple rendered instances on the same page, and this happens
    frequently with `Link` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, this is the `SearchButtons` component, which contains a list of
    `RouterButton` and `ToggleRouterButton` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to testing these links, the simplest approach is to use `renderWithRouter`
    to render the `SearchButtons` components and then check the rendered HTML hyperlinks.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you’ve decided to mock, then you need a way to easily find the element
    you’ve rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’d specify the mock to include an `id` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use a new test extension called `propsMatching` to find the specific
    instance. Here’s the definition from `test/reactTestExtensions.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then write your test to make use of that, as shown in the following
    code. Remember though, it’s probably going to be easier not to mock this component
    and simply use `renderWithRouter`, and then check the HTML hyperlinks directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s everything there is to testing the `Link` component. In the next section,
    we’ll look at the final aspect of testing React Router: navigating programmatically.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing programmatic navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you’ll want to trigger a location change programmatically—in other
    words, without waiting for a user to click a link.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to do this: one using the `useNavigate` hook, and the second
    using a `history` instance that you pass into your top-level router.'
  prefs: []
  type: TYPE_NORMAL
- en: Navigation inside and outside of components
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at just the first method, using the hook. Later,
    in [*Chapter 12*](B18423_12.xhtml#_idTextAnchor231), *Test-Driving Redux*, we’ll
    use the second method to change the location within a Redux action.
  prefs: []
  type: TYPE_NORMAL
- en: The `useNavigate` hook is the appropriate method when you’re able to navigate
    from within a React component.
  prefs: []
  type: TYPE_NORMAL
- en: In the Appointments application, this happens in two places. The first is after
    a customer has been added and we want to move the user on to the `/addAppointment`
    route. The second is after that form has been completed and the appointment has
    been created—then we want to move them back to the default route.
  prefs: []
  type: TYPE_NORMAL
- en: Since these are very similar, we’ll look at just the first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the `/addCustomer` route definition looks in `src/App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `onSave` prop; this is the callback that gets called once the customer
    form submission is completed. Here’s that callback definition, together with the
    bits relevant for the `useNavigate` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to testing this, clearly, we can’t simply rely on the presence
    of a `Link` component, because there isn’t one. Instead, we must call the `onSave`
    callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The expectation is to test that the history is updated correctly. This history
    is the exported constant from `test/reactTestExtensions.js` that is set in the
    `renderWithRouter` function that we defined in the *Testing components within
    a router* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a variation of this. Instead of using the `history` import, you could
    also simply use the `window.location` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You’ve now learned how to test programmatic React Router navigation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Test-Driving Redux*, we’ll see how we can use this same
    history instance from a Redux saga.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has shown you how to use React Router in a testable fashion. You
    have learned how to test-drive the `Router`, `Routes`, `Route`, and `Link` components.
    You have seen how to use the React Router `useSearchParams` and `useNavigate`
    hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most importantly, you’ve seen that because routes give an extra level of entry
    into your application, you must split your existing navigation tests into two
    parts: one to test that a link exists (or is followed), and one to check that
    if you visit that URL, the right component is displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve successfully integrated one library, the next one shouldn’t
    be too tricky, right? In the next chapter, we’ll apply all the skills we’ve learned
    in this chapter to the integration of another library: Redux.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, there was no walkthrough because the refactoring process is
    quite involved and would have taken up a decent chunk of time and space.
  prefs: []
  type: TYPE_NORMAL
- en: Use this opportunity to try refactoring yourself. Use a *systematic refactoring*
    approach to break down the change to React Router into many small steps. At each
    step, you should still have working software.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a guide on how to approach this type of refactoring at [https://reacttdd.com/refactoring-to-react-router](https://reacttdd.com/unpublished/refactoring-to-react-router/).
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official React Router documentation can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)'
  prefs: []
  type: TYPE_NORMAL
