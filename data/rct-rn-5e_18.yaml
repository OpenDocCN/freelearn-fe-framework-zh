- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: React Native under the Hood
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native 内部机制
- en: The previous chapter briefly touched on what React Native is and the differences
    that users experience between the React Native UI and mobile browsers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章简要介绍了 React Native 是什么以及用户在 React Native UI 和移动浏览器之间体验到的差异。
- en: In this chapter, we will dig deeper into React Native, becoming well-versed
    on how it performs on mobile devices and what we should attain before commencing
    any efforts with this framework. We will also look at what options we can execute
    for the native functionality of JavaScript and what restrictions we will be up
    against.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨 React Native，深入了解它在移动设备上的表现以及我们在开始使用此框架之前应该达到的目标。我们还将探讨我们可以执行哪些原生功能选项以及我们将面临哪些限制。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Exploring the React Native architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 React Native 架构
- en: Explaining JavaScript and Native modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释 JavaScript 和本地模块
- en: Exploring React Native components and APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 React Native 组件和 API
- en: Exploring the React Native architecture
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 React Native 架构
- en: Before understanding how React Native works, let’s revisit some historical points
    about the React architecture and the differences between web and native mobile
    apps.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解 React Native 的工作原理之前，让我们回顾一下关于 React 架构和网页与原生移动应用之间差异的历史观点。
- en: The state of web and mobile apps in the past
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过去网页和移动应用的状态
- en: Meta released **React** in 2013 as a monolith tool for creating apps, using
    a component approach and a **virtual DOM**. It gave us the opportunity to develop
    web applications without thinking about browser processes, such as parsing JS
    code, creating the DOM, and handling layers and rendering. We just had to create
    interfaces using state and props for data and CSS for styling, fetch data from
    the backend, save it in local storage, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Meta 在 2013 年发布了 **React**，这是一个用于创建应用的单一工具，采用组件方法和 **虚拟 DOM**。它为我们提供了开发无需考虑浏览器进程（如解析
    JS 代码、创建 DOM、处理层和渲染）的网页应用的机会。我们只需使用状态和属性创建界面，用于数据和 CSS 用于样式，从后端获取数据，保存在本地存储中等。
- en: 'React, together with browsers, allowed us to create a performance application
    in less time. At that time, the architecture of React looked like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: React 与浏览器一起，使我们能够在更短的时间内创建性能应用。当时，React 的架构看起来是这样的：
- en: '![](img/B19636_16_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_16_01.png)'
- en: 'Figure 16.1: React architecture in 2013'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1：2013 年的 React 架构
- en: The new declarative approach to developing interfaces became more favorable
    because of the fast development and the low threshold for novices. Additionally,
    if your backend is built with **Node.js**, you can benefit from the ease of support
    and development of the entire project using just one programming language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于快速开发和低门槛，新的声明式接口开发方法变得更加受欢迎。此外，如果你的后端是用 **Node.js** 构建的，你可以通过仅使用一种编程语言来享受整个项目的支持和开发的便利。
- en: 'At the same time, mobile apps require more complex techniques to create apps.
    For Android and iOS apps, companies should manage three different teams with unparalleled
    experience to support three major ecosystems:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，移动应用需要更复杂的技术来创建应用。对于 Android 和 iOS 应用，公司应该管理三个不同团队，这些团队具有无与伦比的经验，以支持三个主要生态系统：
- en: Web developers should know HTML, CSS, JS, and React.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页开发者应该了解 HTML、CSS、JS 和 React。
- en: '**Java** or **Kotlin** SDK experience is required for Android developers.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java** 或 **Kotlin** SDK 经验对于 Android 开发者来说是必需的。'
- en: The iOS developer should be familiar with **Objective-C** or **Swift** and **CocoaPods**.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS 开发者应该熟悉 **Objective-C** 或 **Swift** 和 **CocoaPods**。
- en: 'Every step of developing an application, from prototyping to release, requires
    unique skills. Web and mobile app development before cross-platform solutions
    looked like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 开发应用的每一步，从原型设计到发布，都需要独特的技能。在跨平台解决方案出现之前，网页和移动应用开发看起来是这样的：
- en: '![](img/B19636_16_02.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_16_02.png)'
- en: 'Figure 16.2: The state of web and mobile apps'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2：网页和移动应用的状态
- en: 'Even if a corporation carries out a basic application, it can be faced with
    some major issues:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是一家公司执行一个基本应用，也可能面临一些重大问题：
- en: Each of these teams implements the same business logic.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些团队中的每一个都实现了相同的企业逻辑。
- en: There is no alternative to sharing code between teams.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在团队之间共享代码没有替代方案。
- en: It is not conceivable to share resources between teams (Android developers can’t
    write code for iOS applications, and vice versa).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在团队之间共享资源是不可能的（Android 开发者无法为 iOS 应用编写代码，反之亦然）。
- en: As a result of these significant issues, we likewise have complications with
    having more testing resources, since there are more places to create bugs. The
    speed of development is also diverse because mobile apps take more time to deliver
    the same features. This all accumulates into a large, costly problem for the companies
    involved. Many of them came up with ideas on how to write a single code base or
    reuse a current one that can be used in multiple ecosystems. The simplest method
    would be to wrap a web app for mobile using a browser, but this has limitations
    in handling touch and gestures, as we explored in *Chapter 15*, *Why React Native?*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些重大问题，我们在测试资源方面也遇到了复杂性，因为存在更多可能产生错误的地方。开发速度也各不相同，因为移动应用程序需要更多时间来实现相同的功能。所有这些都累积成了对公司来说成本高昂的大问题。其中许多公司提出了如何编写单一代码库或重用现有代码库的想法，这些代码库可以在多个生态系统中使用。最简单的方法是使用浏览器将
    Web 应用程序包装成移动应用，但正如我们在 *第 15 章* 中探讨的，“为什么选择 React Native？” 这在处理触摸和手势方面存在局限性。
- en: In response to these issues, Meta started investing resources in developing
    a cross-platform framework and released the **React Native library** in 2015\.
    Also, it divided React into two separate libraries. To render our app in the browser,
    we should now use the **ReactDOM** library.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 针对这些问题的回应，Meta 开始投资资源开发跨平台框架，并在 2015 年发布了 **React Native 库**。它还将 React 分为两个独立的库。现在，为了在浏览器中渲染我们的应用程序，我们应该使用
    **ReactDOM** 库。
- en: 'In *Figure 16.3*, we can see how **React** works together with **ReactDOM**
    and **React Native** to render our apps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 16.3* 中，我们可以看到 **React** 如何与 **ReactDOM** 和 **React Native** 协同工作以渲染我们的应用程序：
- en: '![](img/B19636_16_03.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_16_03.png)'
- en: 'Figure 16.3: ReactDOM and React Native flow'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3：ReactDOM 和 React Native 流程
- en: Now, React only works to manage the components tree. This approach encapsulates
    any rendering APIs and hides a lot of platform-specific methods from us. We can
    concentrate solely on developing interfaces and cease speculating about how they
    would be rendered.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，React 只负责管理组件树。这种方法封装了任何渲染 API，并隐藏了许多平台特定的方法。我们可以专注于开发界面，而无需猜测它们将如何被渲染。
- en: That’s why React is frequently claimed as a renderer-agnostic library. Also,
    for web apps, we use ReactDOM, which forms elements and applies them right to
    the browser DOM. For mobile apps, React Native renders our interface directly
    on the mobile screen.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，React 常常被宣称为一个渲染无关的库。此外，对于 Web 应用程序，我们使用 ReactDOM，它形成元素并将它们直接应用到浏览器 DOM
    上。对于移动应用程序，React Native 直接在移动屏幕上渲染我们的界面。
- en: But how does React Native replace the whole browser API and allow us to write
    familiar code and run it on mobiles?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，React Native 是如何替换整个浏览器 API，并允许我们编写熟悉的代码并在移动设备上运行的呢？
- en: React Native current architecture
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native 当前架构
- en: 'The React Native library allows you to create native applications with React
    and JS by utilizing native building blocks. For instance, the `<Image/>` component
    represents two other native components, `ImageView` on Android and `UIImageView`
    on iOS. This is viable because of the architecture of React Native, which includes
    two dedicated layers, represented by **JS** and **Native** threads:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 库允许您通过利用原生构建块使用 React 和 JS 创建原生应用程序。例如，`<Image/>` 组件代表了两个其他原生组件，Android
    上的 `ImageView` 和 iOS 上的 `UIImageView`。这是可行的，因为 React Native 的架构包括两个专门的层，分别由 **JS**
    和 **Native** 线程表示：
- en: '![](img/B19636_16_04.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_16_04.png)'
- en: 'Figure 16.4: React Native threads'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4：React Native 线程
- en: In the next sections, we will explore each thread and see how they can communicate,
    ensuring that JS is integrated into the native code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探索每个线程，并了解它们如何进行通信，确保 JS 能够集成到原生代码中。
- en: JS as part of React Native
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JS 作为 React Native 的一部分
- en: As the browser executes JS through **JS engines** such as **V8**, **SpiderMonkey**,
    and others, React Native also contains a **JS virtual machine**. There, our JS
    code is executed, API calls are made, touch events are processed, and many other
    processes occur.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器通过 **JS 引擎**（如 **V8**、**SpiderMonkey** 等）执行 JS，React Native 也包含一个 **JS
    虚拟机**。在那里，我们的 JS 代码被执行，API 调用被处理，触摸事件被处理，以及许多其他过程发生。
- en: Initially, React Native only supported Apple’s **JavaScriptCore** virtual machine.
    With iOS devices, this virtual machine is built-in and available out of the box.
    In the case of Android, JavaScriptCore is bundled with React Native. This increases
    the size of the app.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，React Native 只支持苹果的 **JavaScriptCore** 虚拟机。在 iOS 设备上，这个虚拟机是内置的，并且可以直接使用。在
    Android 设备的情况下，JavaScriptCore 是与 React Native 一起打包的。这增加了应用程序的大小。
- en: Therefore, the *Hello World* application of React Native would consume approximately
    3 to 4 MB on Android. From the 0.60 version, React Native started using the new
    **Hermes virtual machine**, and from 0.64, provided support for iOS as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，React Native的**Hello World**应用程序在Android上大约消耗3到4 MB。从0.60版本开始，React Native开始使用新的**Hermes虚拟机**，从0.64版本开始，也提供了对iOS的支持。
- en: 'The Hermes virtual machine introduced a lot of improvements for both platforms:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Hermes虚拟机为两个平台带来了许多改进：
- en: Improvement of the app’s startup time
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高了应用的启动时间
- en: A size reduction of the downloaded app
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少了下载的应用大小
- en: Decreased memory usage
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少了内存使用
- en: Built-in proxy support, enabling the use of **react-native-firebase** and **mobx**
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置代理支持，使**react-native-firebase**和**mobx**可用
- en: 'Understanding the comparative benefits between the old and new architectures
    is a relatively common topic in interviews. More information about Hermes can
    be found here: [https://reactnative.dev/docs/hermes](https://reactnative.dev/docs/hermes).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试中，了解新旧架构之间的比较优势是一个相对常见的话题。有关Hermes的更多信息，请参阅[https://reactnative.dev/docs/hermes](https://reactnative.dev/docs/hermes)。
- en: JS in React Native, as in browsers, is implemented in a single thread. That
    thread is responsible for executing JS. The business logic we write is carried
    out in this thread. This means all our common code, such as components, state,
    Hooks, and REST API calls, will be handled in the JS part of the app.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native中，与浏览器一样，JS是在单个线程中实现的。这个线程负责执行JS。我们编写的业务逻辑在这个线程上执行。这意味着我们所有的常见代码，如组件、状态、Hooks和REST
    API调用，都将由应用中的JS部分处理。
- en: Our entire application structure is packaged into a single file using the **Metro**
    bundler. It is also responsible for transpiling JSX code into JS. If we want to
    use TypeScript, **Babel** can support it. It works right out of the box, so there’s
    no need to configure anything. In future chapters, we will learn how to start
    a ready-to-work project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们整个应用程序结构都使用**Metro**打包器打包成一个文件。它还负责将JSX代码转换为JS。如果我们想使用TypeScript，**Babel**可以支持它。它直接可用，因此无需进行任何配置。在未来的章节中，我们将学习如何启动一个现成的项目。
- en: The “Native” part
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “原生”部分
- en: 'Here is where native code is executed. React Native implements this part in
    native code for each platform: Java for Android and Objective-C for iOS. The **Native**
    layer is mainly composed of Native modules that communicate with the Android or
    iOS SDK and are supposed to provide native functionality for our apps, using a
    unified API. If we want to display an alert dialog, for instance, the **Native**
    layer presents a unified API for both platforms, which we will call from the JS
    thread using the single API.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行原生代码的地方。React Native为每个平台实现了这部分的原生代码：Android使用Java，iOS使用Objective-C。**原生**层主要由与Android或iOS
    SDK通信的Native模块组成，旨在为我们提供使用统一API的原生功能。例如，如果我们想显示一个警告对话框，**原生**层为两个平台提供了一个统一的API，我们可以通过JS线程使用单个API来调用它。
- en: 'This thread interacts with the JS thread when you need to update the interface
    or call the native functions. There are two parts to this thread:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要更新界面或调用原生函数时，这个线程会与JS线程交互。这部分有两个部分：
- en: The first, the **React Native UI**, is responsible for using native interface
    shaping tools.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是**React Native UI**，负责使用原生界面塑造工具。
- en: The second is **Native Modules**, which allow applications to access the specific
    capabilities of the platform on which they run.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是**原生模块**，允许应用程序访问它们运行的平台上的特定功能。
- en: Communication between threads
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程间的通信
- en: As previously mentioned, each React Native layer implements a unique API for
    every native and UI feature in an application. The communication between layers
    is accomplished through the bridge. The module is written in C ++ and is based
    on an asynchronous queue. When the bridge receives data from one of the parties,
    it serializes it, converts it to a **JSON** string, and passes it through the
    queue. After arriving at its destination, the data is deserialized.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个React Native层为应用中的每个原生和UI功能实现了一个独特的API。层与层之间的通信是通过桥接完成的。该模块是用C++编写的，基于异步队列。当桥接从一方接收数据时，它会将其序列化，将其转换为**JSON**字符串，并通过队列传递。到达目的地后，数据会被反序列化。
- en: 'As shown in the alert example, the native part accepts the call from JS and
    displays the dialog. In reality, the JS method, upon being invoked, sends a message
    to the **bridge**, and upon receiving this message, the Native part executes the
    instruction. Native messages may also be forwarded to the **JS** layer. On clicking
    the button, for example, the **Native** layer sends a message to the **JS** one
    with an `onClick` event. It can be imagined as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如警报示例所示，本地部分接受来自 JS 的调用并显示对话框。实际上，当 JS 方法被调用时，它会向 **桥** 发送消息，并在接收到这条消息后，本地部分执行指令。本地消息也可以转发到
    **JS** 层。例如，在点击按钮时，**Native** 层会向 **JS** 层发送一个带有 `onClick` 事件的 **Native** 消息。可以想象如下：
- en: '![](img/B19636_16_05.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_16_05.png)'
- en: 'Figure 16.5: The bridge'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5：桥梁
- en: 'JS and the Native part of this architecture, together with the bridge, resemble
    the server and client sides of web applications, where they communicate through
    the REST APIs. It does not matter to us in which language or how the Native part
    is implemented, since the code in JS is isolated. We simply send messages and
    receive responses from the bridge. This is both a significant advantage and a
    great disadvantage: first, it allows us to implement cross-platform apps with
    one code base, but it can be a bottleneck in our app when we have a lot of business
    logic in it. All events and actions in the application rely on asynchronous JSON-bridged
    messages. Each party sends these messages, expecting that sometime in the future,
    a response will be received from these messages (which is not guaranteed). With
    such a data exchange scheme, there is a risk of overloading the communication
    channel.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JS 和该架构的本地部分，连同桥一起，类似于网络应用的客户端和服务器端，它们通过 REST APIs 进行通信。对我们来说，本地部分是用哪种语言或如何实现的不重要，因为
    JS 中的代码是隔离的。我们只需通过桥发送消息并接收响应。这既是显著的优势，也是巨大的劣势：首先，它允许我们用一个代码库实现跨平台应用，但当我们应用中有大量业务逻辑时，它可能成为瓶颈。应用中的所有事件和动作都依赖于异步的
    JSON-bridged 消息。每一方发送这些消息，期望在未来某个时刻收到这些消息的响应（这并不保证）。在这种数据交换方案中，存在过载通信通道的风险。
- en: Here is an example commonly used to illustrate how such a communication scheme
    can cause performance problems for an application. Suppose a user of an application
    scrolls through a huge list. When the `onScroll` event occurs in the native environment,
    information is passed asynchronously to the JS environment. But native mechanisms
    do not wait until the JS part of the application does its job and reports to them
    about it. Because of this, there is a delay in the appearance of empty space in
    the list before displaying its contents. We can avoid a lot of usual problems
    using special approaches, such as using paginated `FlatList` on limitless lists.
    We will look at the main tricks in future chapters, but it is important to remember
    the limitations of the current architecture.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个常用的例子，用来说明这种通信方案如何导致应用出现性能问题。假设一个应用的用户在滚动一个巨大的列表。当在本地环境中发生 `onScroll` 事件时，信息会异步传递到
    JS 环境中。但是本地机制不会等待 JS 应用部分完成工作并向其报告。因此，在显示内容之前，列表中空白的区域会出现延迟。我们可以通过使用分页的 `FlatList`
    等特殊方法来避免许多常见问题。我们将在未来的章节中探讨主要技巧，但记住当前架构的限制是很重要的。
- en: Styling
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: As we already understand the cross-platform concept, we can assume that each
    platform has its own technologies for creating and styling interfaces. In order
    to unify this, React Native has a **CSS-in-JS** syntax to style an app. Using
    **Flexbox**, components are able to specify the layout of their children. This
    ensures a consistent layout across different screen sizes. It is usually similar
    to how CSS works on the web, except the names are written in camel case, such
    as `backgroundColor` rather than `background-color`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经理解了跨平台的概念，因此可以假设每个平台都有自己的技术来创建和设计界面。为了统一这些技术，React Native 使用 **CSS-in-JS**
    语法来设计应用的外观。使用 **Flexbox**，组件能够指定其子组件的布局。这确保了在不同屏幕尺寸上保持一致的布局。这通常与网页上 CSS 的工作方式相似，只是名称采用驼峰式，例如
    `backgroundColor` 而不是 `background-color`。
- en: In JS, it is a plain object with style properties, and in native code, it is
    a separate thread called **Shadow**. It recalculates the layout of the application
    using the **Yoga** engine, which was developed by Meta. In this thread, the calculations
    related to the formation of the application interface are performed. The results
    of these calculations are sent to the Native UI thread responsible for displaying
    the interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在JS中，它是一个具有样式属性的普通对象，在原生代码中，它是一个名为**Shadow**的独立线程。它使用Meta开发的**Yoga**引擎重新计算应用程序的布局，在这个线程中执行与形成应用程序界面相关的计算。这些计算的结果被发送到负责显示界面的原生UI线程。
- en: 'With all the parts coming together, the final architecture of React Native
    is illustrated in this figure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有部分组合在一起时，React Native的最终架构如图所示：
- en: '![](img/B19636_16_06.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_16_06.png)'
- en: 'Figure 16.6: The current React Native architecture'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：当前React Native架构
- en: 'The current architecture of React Native addresses major business problems:
    it is feasible to develop web and mobile applications within the same team, it
    is possible to reuse a large amount of business logic code, and even developers
    with no previous experience in mobile development can easily use React Native.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当前React Native的架构解决了主要的商业问题：可以在同一个团队内开发Web和移动应用程序，可以重用大量的业务逻辑代码，甚至没有移动开发经验的开发者也能轻松使用React
    Native。
- en: However, the current architecture is not ideal. Over the past few years, the
    React Native team has been working on a bridge bottleneck solution. The new architecture
    is designed to address this issue.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当前的架构并不理想。在过去的几年里，React Native团队一直在努力解决桥接瓶颈问题。新的架构旨在解决这个问题。
- en: React Native future architecture
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Native的未来架构
- en: A series of significant improvements have been introduced to React Native that
    will streamline the development process and make it more convenient for everyone.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: React Native引入了一系列重大改进，这将简化开发过程，使每个人都更加方便。
- en: React Native’s re-architecture will gradually deprecate the bridge and replace
    it with a new component called the **JS Interface** (**JSI**). In addition, this
    element will enable new `Fabric` components and `TurboModules`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的重构将逐步弃用桥接，并用一个新的组件**JS接口**（**JSI**）来替代它。此外，这个元素将启用新的`Fabric`组件和`TurboModules`。
- en: 'The use of the JSI opens up many possibilities for improvement. In *Figure
    16.7*, you can see the major updates to the React Native architecture:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSI为改进打开了众多可能性。在*图16.7*中，你可以看到React Native架构的主要更新：
- en: '![](img/B19636_16_07.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_16_07.png)'
- en: 'Figure 16.7: The new React Native architecture'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：新的React Native架构
- en: The first change is that the JS bundle is no longer dependent on a **JavaScriptCore**
    virtual machine. It is actually part of the current architecture because, now,
    we can enable the new **Hermes JS engine** on both platforms. In other words,
    the JavaScriptCore engine can now easily be replaced with something else, quite
    possibly with better performance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变化是JS包不再依赖于**JavaScriptCore**虚拟机。实际上，它现在是当前架构的一部分，因为现在我们可以在两个平台上启用新的**Hermes
    JS引擎**。换句话说，JavaScriptCore引擎现在可以轻松地被其他东西取代，很可能是性能更好的东西。
- en: The second improvement is what lies at the heart of the new React Native architecture.
    The JSI allows JS to call native methods and functions directly. This was made
    possible by the `HostObject` C++ object, which stores references to native methods
    and properties. `HostObject` in JS binds native methods and props to a global
    object, so direct calls to JS functions will invoke Java or Objective-C APIs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个改进是新的React Native架构的核心所在。JSI允许JS直接调用原生方法和函数。这是通过`HostObject` C++对象实现的，它存储了对原生方法和属性的引用。在JS中，`HostObject`将原生方法和属性绑定到一个全局对象上，因此直接调用JS函数将调用Java或Objective-C
    API。
- en: Another benefit of the new React Native is the ability to fully control native
    modules called `TurboModules`. Rather than starting them all at once, the application
    will only use them when they are needed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 新的React Native的另一个好处是能够完全控制名为`TurboModules`的原生模块。而不是一次性启动它们，应用程序将只在需要时使用它们。
- en: '**Fabric** is the new UI manager, called **Renderer** in *Figure 16.7*, which
    is expected to transform the rendering layer by eliminating the need for bridges.
    It is now possible to create a **Shadow Tree** directly in C++, which increases
    speed and reduces the number of steps to render a particular element.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fabric** 是新的 UI 管理器，在 *图 16.7* 中被称为 **Renderer**，它预计将通过消除对桥接器的需求来改变渲染层。现在可以直接在
    C++ 中创建 **Shadow Tree**，这提高了速度并减少了渲染特定元素所需的步骤数量。'
- en: In order to ensure smooth communication between React Native and Native parts,
    Meta is currently working on a tool called **CodeGen**. It is expected to automate
    the compatibility of strongly typed native code and dynamically typed JS to make
    them synchronize. With this upgrade, there will be no need to duplicate the code
    for both threads, thereby enabling smooth synchronization.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 React Native 和本地部分之间的通信顺畅，Meta 目前正在开发一个名为 **CodeGen** 的工具。它预计将自动化强类型本地代码和动态类型
    JS 的兼容性，使它们同步。通过这次升级，将不再需要为两个线程重复代码，从而实现平滑的同步。
- en: The new architecture could open the way for the development of new designs that
    are capable of things that were not available in old React Native applications.
    The fact is that we now have at our disposal the power of C++. This means that
    with React Native, it will now be possible to create many more varieties of applications
    than before.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 新的架构可能为开发能够实现旧 React Native 应用程序中不可用的新设计开辟了道路。事实上，我们现在可以利用 C++ 的力量。这意味着，使用 React
    Native，现在将能够创建比以前更多的应用程序种类。
- en: Here, we discussed the fundamentals that explain how React Native works. It
    is important to understand the architecture of the tools we use. Having this knowledge
    allows you to avoid mistakes during planning and prototyping, as well as maximize
    the potential of your future applications. In the following section, we will briefly
    explore how to extend React Native with modules.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们讨论了解释 React Native 如何工作的基本原理。了解我们使用的工具的架构非常重要。拥有这些知识可以让你在规划和原型设计时避免错误，并最大限度地发挥未来应用程序的潜力。在下一节中，我们将简要探讨如何通过模块扩展
    React Native。
- en: Explaining JS and Native modules
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 JS 和本地模块
- en: React Native does not cover all the native capabilities out of the box. It only
    provides the most common features that you will need in a basic application. Also,
    the Meta team itself has recently moved some functions into its own modules in
    an effort to reduce the size of the overall application. For example, `AsyncStorage`,
    for storing data on a device, was moved into a separate package and must be installed
    if you plan to use it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 并没有提供所有内置的本地功能。它只提供了在基本应用程序中需要的最常见功能。此外，Meta 团队最近将一些功能移动到其自己的模块中，以减少整体应用程序的大小。例如，用于在设备上存储数据的
    `AsyncStorage` 被移动到单独的包中，如果你打算使用它，就必须安装。
- en: However, React Native is an extendable framework. We can add our own native
    modules and expose the JS API using the same bridge or JSI. Our focus in this
    book will not be on developing native modules, since we need prior experience
    with Objective-C or Java. Also, it is not necessary, since the React community
    has created an enormous number of ready-to-use modules for all cases. We will
    learn how to install native packages in subsequent chapters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，React Native 是一个可扩展的框架。我们可以添加自己的本地模块，并使用相同的桥接器或 JSI 暴露 JS API。在这本书中，我们的重点不会放在开发本地模块上，因为我们需要先有
    Objective-C 或 Java 的经验。此外，这也不是必要的，因为 React 社区已经为所有情况创建了大量现成的模块。我们将在后续章节中学习如何安装本地包。
- en: The following are a few of the most popular native modules, without which most
    projects couldn’t prosper.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些最受欢迎的本地模块，没有它们，大多数项目都无法繁荣发展。
- en: React Navigation
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Navigation
- en: '**React Navigation** is one of the best React Native navigation libraries for
    creating navigation menus and screens for your app. It’s a good tool for beginners
    because it’s stable, fast, and less buggy. The documentation is really good, and
    it provides examples for all use cases.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Navigation** 是创建应用导航菜单和屏幕的最佳 React Native 导航库之一。它对于初学者来说是个好工具，因为它稳定、快速且错误较少。文档非常好，并为所有用例提供了示例。'
- en: We’ll learn more about React Navigation in *Chapter 19*, *Navigating between
    Screens.*
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 19 章“屏幕间导航”中了解更多关于 React Navigation 的内容。
- en: UI component libraries
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI 组件库
- en: The UI component libraries enable you to quickly assemble an application layout
    without wasting time designing and coding atomic elements. In addition, such libraries
    are often more stable and consistent, which leads to better results both in terms
    of UI and UX.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: UI组件库使您能够快速组装应用布局，而无需花费时间设计和编码原子元素。此外，此类库通常更稳定、更一致，这导致UI和UX方面都取得更好的结果。
- en: 'These are some of the most popular libraries (we will explore a few of them
    in greater detail in future chapters):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些最受欢迎的库（我们将在未来的章节中更详细地探讨其中的一些）：
- en: '**NativeBase**: This is a component library that enables developers to build
    universal design systems. It is built on top of React Native, allowing you to
    develop apps for Android, iOS, and the web.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NativeBase**：这是一个组件库，使开发者能够构建通用设计系统。它建立在React Native之上，允许您为Android、iOS和网页开发应用。'
- en: '**React Native Element**: This provides an all-in-one UI kit for creating apps
    in React Native.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React Native Element**：这提供了一个用于在React Native中创建应用的综合性UI工具包。'
- en: '**UI Kitten**: This is a React Native implementation of the **Eva Design System**.
    The framework contains a set of general-purpose UI components styled in a similar
    way.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI Kitten**：这是**Eva设计系统**的React Native实现。该框架包含一组以类似方式设计的通用UI组件。'
- en: '**React-native-paper**: This is a collection of customizable and production-ready
    components for React Native, following Google’s Material Design guidelines.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React-native-paper**：这是一个为React Native提供的可定制和现成组件集合，遵循谷歌的Material Design指南。'
- en: '**Tamagui**: This UI kit provides components that can run on mobiles and the
    web.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tamagui**：这个UI工具包提供可以在移动设备和网页上运行的组件。'
- en: Splash screen
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动画面
- en: Adding a splash screen to your mobile app can be a tedious task, since this
    screen should appear before the JS thread begins. The **react-native-bootsplash**
    package allows you to create a fancy splash screen from the command line. The
    package will do all the work for you if you provide it with an image and a background
    color.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将启动画面添加到您的移动应用中可能是一项繁琐的任务，因为这个屏幕应该在JS线程开始之前出现。**react-native-bootsplash**包允许您从命令行创建一个花哨的启动画面。如果您提供图像和背景颜色，该包将为您完成所有工作。
- en: Icons
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图标
- en: Icons are an integral part of the visualization of interfaces. Different approaches
    are used to display icons and other vector graphics on each platform. React Native
    unifies this for us but only with additional libraries such as **react-native-vector-icons**.
    Using **react-native-svg**, you can also render **scalable vector graphics** (**SVG**s)
    in a React Native app.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图标是界面可视化的一个重要部分。每个平台都使用不同的方法来显示图标和其他矢量图形。React Native为我们统一了这一点，但仅限于使用如**react-native-vector-icons**等额外库。使用**react-native-svg**，你还可以在React
    Native应用中渲染**可缩放矢量图形**（**SVG**）。
- en: Handling errors
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: Usually, when we develop a web application, we are able to handle errors without
    any difficulty, since they do not reach beyond the scope of JS. As a result, we
    have more control and stability in the event of critical bugs because if the application
    does not start at all, we can easily see the reason and open the logs in **DevTools**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们开发Web应用时，我们能够轻松处理错误，因为它们不会超出JS的作用域。因此，在出现关键错误的情况下，我们拥有更多的控制和稳定性，因为如果应用根本无法启动，我们可以轻松地看到原因并在**DevTools**中打开日志。
- en: There are even more complications with React Native applications, since we have
    a Native component in addition to the JS of the environment, which can also cause
    errors in application execution. Therefore, when an error occurs, our application
    will close immediately. It will be hard for us to figure out why.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React Native应用中除了环境的JS之外还有一个本地组件，这可能会在应用执行过程中引起错误，因此存在更多复杂性。因此，当发生错误时，我们的应用将立即关闭。这将使我们很难找出原因。
- en: '`react-native-exception-handler` provides a simple technique for handling native
    and JS errors and providing feedback. To make it work, you need to install and
    link the module. Then, register your global handler for JS and native exceptions,
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-native-exception-handler`提供了一种处理本地和JS错误并提供反馈的简单技术。要使其工作，您需要安装并链接该模块。然后，注册您的全局处理器以处理JS和本地异常，如下所示：'
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `setJSExceptionHandler` and `setNativeExceptionHandler` methods are custom
    global error handlers. If a crash occurs, you can show an error message, use Google
    Analytics to track it, or use a custom API to inform the development team.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`setJSExceptionHandler`和`setNativeExceptionHandler`方法是一些自定义的全局错误处理器。如果发生崩溃，您可以显示错误消息，使用Google
    Analytics进行跟踪，或者使用自定义API通知开发团队。'
- en: Push notifications
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送通知
- en: We live in a world where notifications are integral. We open dozens of apps
    every day just because we receive notifications from them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个通知至关重要的世界。我们每天打开数十个应用，仅仅是因为我们收到了它们的推送通知。
- en: 'Push notifications are often connected to a gateway provider that sends messages
    to users’ devices. The following libraries can be used to add push notifications
    to your application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知通常与一个网关提供商相关联，该提供商向用户的设备发送消息。以下库可以用于向你的应用添加推送通知：
- en: '`react-native-onesignal`: A OneSignal provider for push notifications, email,
    and SMS'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-onesignal`：用于推送通知、电子邮件和短信的 OneSignal 提供商'
- en: '`react-native-firebase`: Google Firebase'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-firebase`：Google Firebase'
- en: '`@aws-amplify/pushnotification`: AWS Amplify'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@aws-amplify/pushnotification`：AWS Amplify'
- en: Over-the-air updates
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空中传输更新
- en: As part of a normal application update, when you build a new version and upload
    it to the app store, you can replace the JS package **over the air** (**OTA**).
    As the bundle contains only one file, updating it is not complicated. You can
    update your application as often as you like without waiting for Apple or Google
    to verify your application. That is the real power of React Native.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为正常应用更新的一个部分，当你构建新版本并将其上传到应用商店时，你可以通过空中传输（**OTA**）来替换 JS 包。由于包中只包含一个文件，更新它并不复杂。你可以随时更新你的应用，无需等待苹果或谷歌验证你的应用。这就是
    React Native 的真正力量。
- en: 'We can use it due to the **CodePush** service made by Microsoft. You can find
    more information about CodePush here: [https://docs.microsoft.com/en-gb/appcenter/distribution/codepush/](https://docs.microsoft.com/en-gb/appcenter/distribution/codepush/).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它是因为微软提供的 **CodePush** 服务。你可以在以下链接中找到更多关于 CodePush 的信息：[https://docs.microsoft.com/en-gb/appcenter/distribution/codepush/](https://docs.microsoft.com/en-gb/appcenter/distribution/codepush/)。
- en: Expo also supports OTA updates with the `expo-updates` package.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Expo 也支持使用 `expo-updates` 包进行空中传输更新。
- en: JS libraries
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JS 库
- en: 'As for JS (non-native) modules, we have almost no restrictions, except for
    libraries that use unsupported APIs, such as the DOM and Node.js. We can use any
    packages written in JS: `Moment`, `Lodash`, `Axios`, `Redux`, `MobX`, and a thousand
    others.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JS（非原生）模块，我们几乎没有限制，除了使用不受支持的 API 的库，如 DOM 和 Node.js。我们可以使用任何用 JS 编写的包：`Moment`、`Lodash`、`Axios`、`Redux`、`MobX`
    和成千上万个其他包。
- en: 'We have barely scratched the surface of the possibilities to extend an application
    with various modules in this section. Because React Native has thousands of libraries,
    it makes little sense to go through them all. In order to find the required package
    you need, there is a project called **React Native Directory** that has collected
    and rated a huge list of packages. The project can be found here: [https://reactnative.directory/](https://reactnative.directory/).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们仅仅触及了使用各种模块扩展应用的潜力。因为 React Native 有数千个库，逐一浏览它们几乎毫无意义。为了找到所需的包，有一个名为
    **React Native 目录** 的项目收集并评估了大量包。该项目可以在以下地址找到：[https://reactnative.directory/](https://reactnative.directory/)。
- en: We now know how React Native is organized internally and how we can expand its
    functionality. Our next step is to examine what API and components this framework
    offers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了 React Native 的内部组织结构以及如何扩展其功能。我们的下一步是检查这个框架提供的 API 和组件。
- en: Exploring React Native components and APIs
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 React Native 组件和 API
- en: The main modules and components will be discussed in detail in each new chapter,
    but for now, let’s familiarize ourselves with them. A number of core components
    are available in the React Native framework for use in an app.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新章节将详细讨论主要模块和组件，但就目前而言，让我们先熟悉它们。React Native 框架中提供了一些核心组件，可以在应用中使用。
- en: 'Almost all apps use at least one of these components. These are the fundamental
    building blocks of React Native apps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有应用都至少使用这些组件中的一个。这些是 React Native 应用的基本构建块：
- en: '`View`: The main brick of any app. This is the equivalent of `<div>`, and on
    mobiles, it is represented as `UIView` or `android.view`. Any `<View/>` component
    can nest inside another `<View/>` component and can have zero or many children
    of any type.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View`：任何应用的基石。这相当于 `<div>`，在移动设备上表示为 `UIView` 或 `android.view`。任何 `<View/>`
    组件都可以嵌套在另一个 `<View/>` 组件内部，并且可以有零个或多个任何类型的子组件。'
- en: '`Text`: This is a React component for displaying text. As with `View`, `<Text/>`
    supports nesting, styling, and touch handling.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Text`：这是一个用于显示文本的 React 组件。与 `View` 一样，`<Text/>` 支持嵌套、样式化和触摸处理。'
- en: '`Image`: This displays images from a variety of sources, such as network images,
    static resources, temporary local images, and images from the camera roll.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`：这显示来自各种来源的图像，如网络图像、静态资源、临时本地图像和相册中的图像。'
- en: '`TextInput`: This allows users to input text using a keyboard. Props enable
    a variety of features that can be configured, including auto-correction, auto-capitalization,
    placeholder text, and different keyboard types, such as a numeric keypad.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextInput`：这允许用户使用键盘输入文本。属性可以配置各种功能，包括自动更正、自动大写、占位文本以及不同的键盘类型，如数字键盘。'
- en: '`ScrollView`: This component is a generic container for scrolling multiple
    views and components. There can be both vertical and horizontal scrolling (by
    adjusting the horizontal property) for the scrollable items. If you need to render
    a huge or limitless list of items, you should use `FlatList`. This supports a
    set of special props such as **Pull to Refresh** and **Scroll loading** (lazy-loading).
    If your list needs to be divided into sections, then there is also a special component
    for this: `SectionList`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScrollView`：这个组件是用于滚动多个视图和组件的通用容器。对于可滚动项，可以有垂直和水平滚动（通过调整水平属性）。如果你需要渲染大量或无限列表项，你应该使用`FlatList`。它支持一系列特殊属性，如**下拉刷新**和**滚动加载**（懒加载）。如果你的列表需要分成几个部分，那么也有专门用于此的特殊组件：`SectionList`。'
- en: '`Button`: React Native has advanced components that can be used to create custom
    buttons and other touchable components, such as `TouchableHighlight`, `TouchableOpacity`,
    and `TouchableWithoutFeedback`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`：React Native有高级组件可以用来创建自定义按钮和其他触摸组件，例如`TouchableHighlight`、`TouchableOpacity`和`TouchableWithoutFeedback`。'
- en: '`Pressable`: This gives more precise touch control with React Native version
    0.63\. Basically, it is a wrapper for detecting touch. It is a well-defined component
    that can be used instead of touchable components such as `TouchableOpacity` and
    `Button`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pressable`：这为React Native 0.63版本提供了更精确的触摸控制。基本上，它是一个用于检测触摸的包装器。它是一个定义良好的组件，可以用作`TouchableOpacity`和`Button`等触摸组件的替代品。'
- en: '`Switch`: This component resembles a checkbox; however, it is presented in
    the form of a switch, which we are familiar with on mobile devices.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Switch`：这个组件类似于复选框；然而，它以我们在移动设备上熟悉的开关形式呈现。'
- en: In the following chapters, we will delve deeper into common components and their
    properties, as well as explore new components that are rarely used. We’ll also
    look at code examples that show how to combine components to create application
    interfaces.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地探讨常见组件及其属性，以及探索很少使用的组件。我们还将查看代码示例，展示如何组合组件以创建应用程序界面。
- en: Detailed information about all the available components can be found at [https://reactnative.dev/docs/components-and-apis](https://reactnative.dev/docs/components-and-apis).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用组件的详细信息可以在[https://reactnative.dev/docs/components-and-apis](https://reactnative.dev/docs/components-and-apis)找到。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the history of the cross-platform framework React
    Native and what problems it solved for companies. With it, companies can use a
    single universal developer team to build one business logic and apply it to all
    platforms simultaneously, thus saving a lot of time and money. Considering, in
    detail, how React Native works under the hood allows us to identify potential
    issues at the planning stage and resolve them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了跨平台框架React Native的历史以及它为公司解决了哪些问题。有了它，公司可以使用单一的全能开发团队构建一个业务逻辑，并将其同时应用于所有平台，从而节省大量时间和金钱。详细考虑React
    Native在底层的工作原理使我们能够在规划阶段识别潜在问题并解决它们。
- en: Additionally, we started to examine React Native’s basic components, and with
    each new chapter, we will learn more about them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们开始检查React Native的基本组件，并且随着每一章的新内容，我们将更多地了解它们。
- en: In the next chapter, you’ll learn how to get started with new React Native projects.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何开始新的React Native项目。
