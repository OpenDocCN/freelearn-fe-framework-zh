- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and Automating Workflows
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating workflows with modern workflow automation is an absolute must in
    large-scale projects. It will save you a lot of time, but even more importantly,
    it will guarantee that you don’t miss anything and your repetitive processes for
    steps such as checking for code styling and code quality, building your application,
    or releasing your application just work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Next, it gives you the confidence that the code you have just written doesn’t
    only work on your machine because it is cloned and started on a clean machine.
    Last, it ensure the project isn't dependent on individual people.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In particular, steps such as building and releasing an application can become
    quite complex in larger-scale projects, so not every member of the project can
    do it. But with the correct automation setup, all it takes is the push of a button.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: When talking about workflow automation, you’ll also often hear the terms **continuous
    integration** (**CI**) and **continuous delivery** (**CD**). Both terms describe
    automated workflows. CI refers to the development phase of a project. This means
    that every developer integrates the code they create into a shared repository
    frequently, normally multiple times a day. In every integration, the code is checked
    automatically (TypeScript/Flow, ESLint, Prettier, and Tests) and the developer
    gets immediate feedback. DS refers to the deployment or delivery step. It describes
    the automation of building and delivering the application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Since CI is possible when building apps, you should use it. CD works for testing
    builds, but for public production builds, such as mobile apps, it doesn’t work
    well. Releasing to the public multiple times a day isn’t possible because every
    release has to be reviewed manually by Apple and Google to be available in the
    respective app store.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: And even if it were possible (which you could achieve using CodePush, as you’ll
    learn in [*Chapter 13*](B16694_13.xhtml#_idTextAnchor462), *Tips and Outlook*)
    I wouldn’t recommend pushing updates too frequently as it will result in every
    user having to update the app version on every start.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: That’s why we will focus on CI for development and building automated workflows
    for the build and release step, which can either be triggered manually for public
    production builds or automatically for internal testing builds (CD).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: This enables you to deliver your application updates automatically to your test
    users and ship your app to the public with the push of a button while not annoying
    your real users with too frequent updates.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Since the best automation tools are worth nothing when the workflows you automate
    are not good, we’ll also focus on creating an effective development workflow in
    this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Understanding integration/delivery workflow automation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a collaborative development workflow
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating useful CI pipelines for the development process
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding workflow automation and CD for build and release
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to run the code in this chapter, you must set up the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: A working React Native environment ([bit.ly/prn-setup-rn](http://bit.ly/prn-setup-rn)
    – React Native CLI Quickstart)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While most of this chapter should also work on Windows, I recommend working
    on a Mac
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An account with GitHub to run the CI pipelines
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An account with Bitrise to run the Bitrise delivery workflows
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding integration/delivery workflow automation
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of integration and delivery workflow automation is pretty simple:
    you need a repository and an automation tool or build server that can connect
    to your repository. Then, you must define rules regarding which Git events should
    send information to the server to trigger certain scripts. The following diagram
    illustrates this process:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Basic CI setup'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_11_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Basic CI setup
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: A Git event such as commit, pull request, or merge triggers the automation tool.
    The automation tool starts a clean server with a configuration defined in the
    automation tool settings. Then, it clones the code from your repository and starts
    running scripts on it. When it comes to React Native apps, these scripts normally
    start with installing all the project dependencies and running static type checkers
    (Flow/TypeScript).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Next, you should run code quality tools such as ESLint and Prettier and check
    whether the code matches all the requirements. Most of the time, you would also
    run some tests here (more on this in [*Chapter 12*](B16694_12.xhtml#_idTextAnchor410)*,
    Automated Testing of React Native Apps*).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: You can run every other script here, as well as integrating other cloud tools
    such as SonarQube ([https://bit.ly/prn-sonarcube](https://bit.ly/prn-sonarcube),
    an advanced code quality tool) or Snyk ([https://bit.ly/prn-snyk](https://bit.ly/prn-snyk),
    a cloud-based security intelligence tool).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: After the scripts have been executed, your automation tool creates a response
    and sends it back to your repository. This answer then gets shown in your repository
    and can be used to allow or deny further actions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, basic automation tools are integrated into all popular Git-based source
    code repository services, including GitHub (GitHub Actions), Bitbucket (Bitbucket
    Pipelines), and GitLab (GitLab CI/CD). While these tools work fine for React Native
    CI requirements, building and deploying mobile apps is a very complex process
    with special requirements.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: For example, iOS apps can still only be built on macOS machines. While this
    step is technically also possible with most of these basic automation tools, I
    wouldn’t recommend using them for building and deploying.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: For this step, there is a special toolkit called fastlane that integrates into
    special workflow automation tools such as Bitrise, CircleCI, and Travis CI. I
    recommend using the toolkit as it will save you a lot of hours.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned about the theory behind process automation, it’s time
    to think about what our development process should look like. We need a good process
    in place before we can automate anything.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了流程自动化的理论，是时候考虑我们的开发过程应该是什么样子了。在我们可以自动化任何事情之前，我们需要建立一个良好的流程。
- en: Creating a collaborative development workflow
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建协作开发工作流
- en: In large-scale projects, one of the most important things is up-to-date information.
    Typically, in those projects, a lot of people have to be coordinated and multiple
    project parts have to work together to build a complex product. While information
    is important, it shouldn’t limit development speed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模项目中，最重要的是信息更新。通常，在这些项目中，很多人需要协调，多个项目部分需要协同工作以构建复杂的产品。虽然信息很重要，但它不应限制开发速度。
- en: 'So, we have to create a workflow that can be supported with automation to fulfill
    both requirements. The following diagram shows the important parts of this workflow:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须创建一个可以支持自动化的工作流程，以满足这两个要求。以下图表显示了此工作流程的重要部分：
- en: '![Figure 11.2 – Workflow automation setup'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – 工作流自动化设置'
- en: '](img/B16694_11_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16694_11_02.jpg](img/B16694_11_02.jpg)'
- en: Figure 11.2 – Workflow automation setup
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 工作流自动化设置
- en: 'As you can see, four technical parts are needed for the workflow. These are
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，工作流程需要四个技术部分。具体如下：
- en: '**Single Point of Information**: All information is centralized here. Normally,
    this is an issue tracker where every task, bug, or feature request is created
    as an issue. Examples include Jira, ClickUp, GitLab issues, and GitHub issues.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息单一来源**：所有信息都集中在这里。通常，这是一个问题跟踪器，其中每个任务、错误或功能请求都作为一个问题创建。例如，包括 Jira、ClickUp、GitLab
    问题跟踪器和 GitHub 问题跟踪器。'
- en: '**Code Management**: This is where your source code is stored. It should be
    able to integrate with your *Single Point of Information* to transfer information
    about which issues have already been finished or worked on. Examples include Bitbucket,
    GitHub code, and GitLab repository.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码管理**：这是您的源代码存储的地方。它应能够与您的 *信息单一来源* 集成，以传输有关哪些问题已经完成或正在处理的信息。例如，包括 Bitbucket、GitHub
    代码和 GitLab 仓库。'
- en: '**Workflow Automation**: This is where your application gets tested and built.
    This tool should also be able to communicate with your *Single Point of Information*
    to transfer information about the state of the issues. Examples include Bitbucket
    Pipelines, GitHub Actions, GitLab CI/CD, CircleCI, and Bitrise.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作流自动化**：这是您的应用程序进行测试和构建的地方。此工具还应能够与您的 *信息单一来源* 通信，以传输有关问题状态的信息。例如，包括 Bitbucket
    Pipelines、GitHub Actions、GitLab CI/CD、CircleCI 和 Bitrise。'
- en: '**Stability Monitoring**: After your app has been deployed to your users, you
    should track information about its stability. Crashes or other problems should
    be automatically reported to your *Single Point of Information*. Examples include
    Bugsnag, Sentry, Rollbar, and Crashlytics. You will learn more about these tools
    in [*Chapter 13*](B16694_13.xhtml#_idTextAnchor462), *Tips and Outlook*.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定性监控**：在您的应用程序部署给用户之后，您应该跟踪有关其稳定性的信息。崩溃或其他问题应自动报告给您的 *信息单一来源*。例如，包括 Bugsnag、Sentry、Rollbar
    和 Crashlytics。您将在 [*第 13 章*](B16694_13.xhtml#_idTextAnchor462) “技巧与展望” 中了解更多关于这些工具的信息。'
- en: 'Now, we can start creating our development workflow. The following diagram
    shows the standard feature branch workflow that I recommend using:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始创建我们的开发工作流程。以下图表显示了推荐的标准化功能分支工作流程：
- en: '![Figure 11.3 – Feature branch workflow'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 – 功能分支工作流程](img/B16694_11_03.jpg)'
- en: '](img/B16694_11_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16694_11_03.jpg](img/B16694_11_03.jpg)'
- en: Figure 11.3 – Feature branch workflow
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 功能分支工作流程
- en: 'As the workflow’s name suggests, for every feature (which can also be a bug
    or improvement – here, every single issue is considered a feature) a new branch
    is created. Then, the following workflow starts:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如工作流名称所暗示的，对于每个功能（这也可以是一个错误或改进——在这里，每个单独的问题都被视为一个功能），都会创建一个新的分支。然后，以下工作流程开始：
- en: When the branch is created, the single point of information must be updated
    so that it contains information regarding whether the issue has already been worked
    on and who is working on it.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当创建分支时，信息单一来源必须更新，以便包含有关问题是否已经处理以及谁正在处理的信息。
- en: Next, the developer makes one or multiple commits to solve the issue.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，开发者会对问题进行一次或多次提交以解决问题。
- en: Every commit is checked by the workflow automation tool.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个提交都会由工作流程自动化工具进行检查。
- en: If there are errors, the developer will be notified immediately. When the developer
    thinks they have solved the issue and finished their work, they create a pull
    request (sometimes called a **merge request**).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有错误，开发者会立即收到通知。当开发者认为他们已经解决了问题并完成了他们的工作后，他们会创建一个拉取请求（有时也称为**合并请求**）。
- en: This pull request is also checked by the workflow automation, but this time,
    not only with simple checks but with more extensive ones (for example, E2E tests).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个拉取请求也经过了工作流程自动化的检查，但这次，不仅进行了简单的检查，还进行了更广泛的检查（例如，端到端测试）。
- en: If everything passes, the single point of information must be updated. The issue
    gets assigned to another developer for review and the status is changed to reflect
    the review status.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，必须更新单一的信息点。问题被分配给另一位开发者进行审阅，状态也会相应地更改以反映审阅状态。
- en: If changes are requested, the process falls back to *Step 1*. If the reviewer
    is satisfied with the result, they can merge the code to the master or main branch.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要更改，则过程将回退到**步骤1**。如果审阅者对结果满意，他们可以将代码合并到master或main分支。
- en: Again, the single point of information has to be updated, to reflect the correct
    status of the issue.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，必须更新单一的信息点，以反映问题的正确状态。
- en: 'I like this process a lot because it provides you with a lot of things you
    need. Some of these are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢这个过程，因为它为你提供了你需要的大量东西。以下是一些例子：
- en: You always know the exact state of the project.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你总是能知道项目的确切状态。
- en: Most parts of the workflow can be automated to save time. Normally, the developers
    and reviewers only have to work in the code management tool; everything else is
    automated.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作流程的大部分可以自动化以节省时间。通常，开发者和审阅者只需要在代码管理工具中工作；其他一切都是自动化的。
- en: It ensures that every code is double-checked by another developer, which increases
    code quality.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这确保了每段代码都由另一位开发者进行双重检查，从而提高了代码质量。
- en: The reviewer doesn’t have to do checks for basic code quality because that’s
    done automatically.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审阅者不需要对基本代码质量进行检查，因为这是自动完成的。
- en: Now that we know our process, let’s start writing the automation pipelines.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了我们的流程，让我们开始编写自动化管道。
- en: Creating useful CI pipelines for the development process
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为开发过程创建有用的持续集成（CI）管道
- en: Again, we’ll use our example project here. First, we’ll set up a pipeline that
    can support us during the development process with very simple checks for *Step
    3* of *Figure 11.3*. We’ll use GitHub Actions to execute this CI pipeline, but
    it works very similar with Bitbucket ([https://bit.ly/prn-bitbucket-pipelines](https://bit.ly/prn-bitbucket-pipelines))
    and GitLab CI/CD ([https://bit.ly/prn-gitlab-cicd](https://bit.ly/prn-gitlab-cicd)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用我们的示例项目。首先，我们将设置一个管道，它可以在开发过程中通过非常简单的检查来支持我们，针对的是图11.3的**步骤3**。我们将使用GitHub
    Actions来执行这个CI管道，但它与Bitbucket ([https://bit.ly/prn-bitbucket-pipelines](https://bit.ly/prn-bitbucket-pipelines))
    和GitLab CI/CD ([https://bit.ly/prn-gitlab-cicd](https://bit.ly/prn-gitlab-cicd))
    非常相似。
- en: First, we have to create the scripts we want to use in our pipelines. In our
    example, we want to run type checking with the TypeScript compiler and static
    code analysis with ESLint and Prettier to ensure the correct code styling is in
    place.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建我们希望在管道中使用的脚本。在我们的例子中，我们想要使用TypeScript编译器进行类型检查，并使用ESLint和Prettier进行静态代码分析，以确保代码风格正确。
- en: 'For this, we’ll provide the following scripts in the `scripts` section of our
    `package.json` file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将在`package.json`文件的`scripts`部分提供以下脚本：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we have to create a workflow file that can be interpreted by GitHub Actions.
    Since this is a fully integrated workflow automation, as soon as we push this
    file to our GitHub repository, GitHub Actions starts working.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个可以被GitHub Actions解释的工作流程文件。由于这是一个完全集成的自动化工作流程，一旦我们将这个文件推送到我们的GitHub仓库，GitHub
    Actions就会开始工作。
- en: 'This is what our first workflow automation pipeline (or CI pipeline) looks
    like. You have to create it under `.github/workflows/<the github actions workflow
    name>.yml`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的第一个工作流程自动化管道（或CI管道）的样子。你必须将它创建在 `.github/workflows/<the github actions
    workflow name>.yml` 下：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s go through the code line by line. The first line defines the name of the
    workflow. The second line defines when the workflow should run. In this case,
    we want to run it on every push to the repository, no matter to which branch or
    from which author this push comes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看代码。第一行定义了工作流程的名称。第二行定义了工作流程应该在何时运行。在这种情况下，我们希望在每次向仓库推送时运行它，无论推送来自哪个分支或作者。
- en: Hint
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can run workflows on different trigger events. You can find the full list
    in the documentation ([https://bit.ly/prn-github-actions-events](https://bit.ly/prn-github-actions-events)
    for the GitHub Actions event list).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在不同的触发事件上运行工作流。您可以在文档中找到完整的列表（[https://bit.ly/prn-github-actions-events](https://bit.ly/prn-github-actions-events)为GitHub
    Actions事件列表）。
- en: Some especially useful events for the development process described in the previous
    section are push and pull requests. You can also limit these triggers to specific
    branches.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节描述的开发过程中，一些特别有用的触发事件是推送和拉取请求。您还可以将这些触发事件限制在特定的分支上。
- en: Next, you can see the `jobs` section. Here, you define the actual workflow,
    which contains one or multiple jobs that can run in sequence or parallel. In this
    case, we defined one job with multiple steps.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以看到`jobs`部分。在这里，您定义实际的流程，它包含一个或多个可以顺序或并行运行的作业。在这种情况下，我们定义了一个包含多个步骤的作业。
- en: The first thing we have to do for our job is define which machine it should
    run on. Every workflow automation tool has a lot of predefined machine images
    you can choose from, but you can always provide your own machines to run the automation
    pipelines. In our example, we’ll use the latest Ubuntu image that is provided
    by GitHub Actions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的工作，我们首先要做的是定义它应该在哪个机器上运行。每个工作流自动化工具都有许多预定义的机器映像供您选择，但您始终可以提供自己的机器来运行自动化管道。在我们的例子中，我们将使用GitHub
    Actions提供的最新Ubuntu映像。
- en: Next, we define the steps of our job. This can either be a predefined action
    that we use with the `uses` command or an action that we create by ourselves.
    In our example, we make use of both options. First, we use a predefined action
    to check out our code, then we use four self-created actions to install the modules
    and run our checks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义作业的步骤。这可以是使用`uses`命令与预定义操作一起使用的预定义操作，或者是我们自己创建的操作。在我们的例子中，我们使用了这两种选项。首先，我们使用预定义操作来检出我们的代码，然后我们使用四个自定义操作来安装模块和运行我们的检查。
- en: Hint
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When working with workflow automation tools, the time your workflows run for
    is the metric you will pay for. So, you should always think about how to structure
    your workflows so that you spend as little time as possible on the automation
    tool machines.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用工作流自动化工具时，您的工作流运行时间将是您需要支付的指标。因此，您应该始终考虑如何构建您的工作流，以便在自动化工具机器上花费尽可能少的时间。
- en: As soon as we pushed this file to our GitHub repository, the first run of the
    automated workflow was triggered. In this case, the machine started, cloned the
    repository, installed the dependency modules, and ran our checks. You can watch
    the automation running in the **GitHub Actions** tab.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将此文件推送到我们的GitHub仓库，自动工作流的第一次运行就被触发了。在这种情况下，机器启动，克隆了仓库，安装了依赖模块，并运行了我们的检查。您可以在**GitHub
    Actions**标签页中查看自动化运行情况。
- en: 'In the preceding *Hint*, you learned that optimizing workflows to run as fast
    as possible is important. So, that’s what we’ll do next. The following diagram
    shows two ways to optimize our workflow so that we can complete it faster:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的*提示*中，您了解到优化工作流以尽可能快地运行是很重要的。所以，这就是我们接下来要做的。以下图表显示了两种优化我们工作流的方法，以便我们可以更快地完成它：
- en: '![Figure 11.4 – Parallelize workflows'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.4 – Parallelize workflows]'
- en: '](img/B16694_11_04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16694_11_04.jpg]'
- en: Figure 11.4 – Parallelize workflows
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 并行化工作流
- en: The easiest way to complete things faster is by running them in parallel. GitHub
    Actions doesn’t allow you to run steps in parallel, but you can run multiple jobs
    in parallel. You have to investigate your workflow in detail to find out which
    parts can be parallelized, and which steps are better to run in sequence.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完成事情最快的方法是通过并行运行它们。GitHub Actions不允许您并行运行步骤，但您可以并行运行多个作业。您必须详细调查您的工作流，以找出哪些部分可以并行化，哪些步骤更适合顺序运行。
- en: In our example, it wouldn’t make much sense to just create three jobs for the
    three tasks. This is because the step that takes the most time installs the dependencies
    and it would be necessary for all three jobs. Fortunately, it is possible to work
    with caches so that we don’t have to repeat cacheable tasks with any test run.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，仅仅为三个任务创建三个作业并没有太多意义。这是因为花费时间最长的步骤是安装依赖项，这对于所有三个作业都是必要的。幸运的是，我们可以使用缓存来工作，这样我们就不必在每次测试运行中重复缓存的任务。
- en: On the left-hand side of the preceding diagram, you can see the pipeline setup
    for our example, which installs dependencies first and then runs our three jobs
    in parallel. All three jobs fetch the dependencies from the cache, which is populated
    in the install step. On the right-hand side, you can see another setup. In this
    setup, we have three parallel jobs, running completely independently from each
    other.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示左侧，您可以看到我们示例的管道设置，它首先安装依赖项，然后并行运行我们的三个作业。所有三个作业都从缓存中获取依赖项，这些依赖项是在安装步骤中填充的。在右侧，您可以看到另一种设置。在这个设置中，我们有三个并行作业，它们完全独立于彼此运行。
- en: All three jobs try to fetch the dependencies from the cache and install them
    only if they can’t find them there. Both options are faster in certain scenarios.
    If you have to install the dependencies, the second setup would take a little
    longer because the install step will be triggered three times (because the steps
    start in parallel, and at the time they start, the dependencies are either cached
    or not for all three jobs).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个作业都试图从缓存中获取依赖项，并且只有在找不到它们时才安装它们。在某些场景下，这两种选项都更快。如果您必须安装依赖项，第二种设置会稍微长一点，因为安装步骤将被触发三次（因为步骤是并行开始的，而在它们开始的时候，依赖项要么被缓存，要么不是所有三个作业都有）。
- en: The first setup only triggers the dependency install once and ensures that it
    is cached for the other jobs. This first setup will take more time in most scenarios
    because it requires you to run two jobs in sequence (*install* + *typecheck/Prettier/ESLint*).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种设置只触发一次依赖项安装，并确保它为其他作业缓存。在大多数场景中，这种第一种设置会花费更多时间，因为它需要您按顺序运行两个作业（*安装* + *类型检查/Prettier/ESLint*）。
- en: 'This is why I recommend going with the second setup, as shown in the following
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我建议采用以下代码中所示的第二种设置：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the three jobs are very similar. We check out the project, set
    the node environment with a specified node version, and check the cache. The key
    of the cache contains the OS version of the runtime and the hash value of the
    `package-lock.json` file, which changes when anything changes with the dependencies
    (version updates, new libraries, and so on).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，三个作业非常相似。我们检出项目，使用指定的节点版本设置节点环境，并检查缓存。缓存的键包含运行时的操作系统版本和`package-lock.json`文件的哈希值，当依赖项（版本更新、新库等）发生变化时，这个哈希值会改变。
- en: Next, we have a conditional install step, which only installs the dependencies
    when we didn’t hit the cache. This is the case when the name of our cache changes,
    as described previously, or if the cache expires (which it does after it hasn’t
    been used for at least 1 week).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个条件安装步骤，它只在未命中缓存时安装依赖项。这发生在我们的缓存名称更改时，如前所述，或者如果缓存过期（这发生在至少一周未使用后）。
- en: Finally, we execute our typecheck/Prettier/ESLint step. While this parallelization
    seems to be quite complex, it can save you a lot of time when using it at scale.
    So, you should take some time to set up your workflow automation so that it fits
    your needs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们执行我们的类型检查/Prettier/ESLint步骤。虽然这种并行化看起来相当复杂，但在大规模使用时可以节省您大量时间。因此，您应该花些时间设置您的工作流程自动化，以确保它符合您的需求。
- en: All modern code management solutions, such as GitHub, Bitbucket, and GitLab,
    have a very deep integration of workflow automation tools. This means that as
    soon as you have configured your workflow automation, you will see the results
    not only in the workflow automation tool or section but also in your repository.
    For example, it will show the result of every commit that was tested directly
    in the commit list.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代代码管理解决方案，如GitHub、Bitbucket和GitLab，都深度集成了工作流程自动化工具。这意味着一旦您配置了工作流程自动化，您不仅会在工作流程自动化工具或部分中看到结果，还会在您的仓库中看到结果。例如，它将直接在提交列表中显示每个已测试提交的结果。
- en: For more details, you have to visit the workflow automation tool or section
    – in our case, GitHub Actions – to see the results of the CI pipeline. If everything
    worked as expected, you will see a green checkmark. If the workflow detected that
    an error was thrown in any of our checks, we will see a red dot, which notifies
    us about our failed workflow execution.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多详细信息，您必须访问工作流程自动化工具或部分 – 在我们的案例中，GitHub Actions – 以查看CI管道的结果。如果一切按预期进行，您将看到一个绿色的勾选标记。如果工作流程检测到我们的任何检查中抛出了错误，我们将看到一个红色的点，这会通知我们我们的工作流程执行失败。
- en: 'The following screenshot shows a list with multiple workflow runs:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个包含多个工作流程运行的列表：
- en: '![Figure 11.5 – Workflow runs inside GitHub Actions'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5 – GitHub Actions中的工作流程运行'
- en: '](img/B16694_11_05.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16694_11_05.jpg)'
- en: Figure 11.5 – Workflow runs inside GitHub Actions
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – GitHub Actions中的工作流程运行
- en: In this example, two runs of our workflow succeeded, while one of them failed.
    The failed workflow run is always the interesting one because it provides a lot
    of information about what went wrong.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的工作流程运行了两次成功，而其中一次失败了。失败的流程运行总是最有趣的，因为它提供了大量关于出错原因的信息。
- en: 'By clicking on it, you will see information about the logs and execution times
    so that you can find and fix the error. This is how it looks inside **GitHub Actions**:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 点击它，你会看到有关日志和执行时间的详细信息，这样你就可以找到并修复错误。这是它在**GitHub Actions**中的样子：
- en: '![Figure 11.6 – Failed workflow run in GitHub Actions'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.6 – GitHub Actions中的失败工作流程运行'
- en: '](img/B16694_11_06.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16694_11_06.jpg]'
- en: Figure 11.6 – Failed workflow run in GitHub Actions
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – GitHub Actions中的失败工作流程运行
- en: As you can see, we don’t only see which check fails, but also the detailed logs.
    In this case, we used the wrong type in the `Genre.tsx` file, which resulted in
    a bunch of errors. With this workflow, we didn’t only find the error – we also
    know the exact file and line number where we have to fix our error.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们不仅可以看到哪些检查失败，还可以看到详细的日志。在这种情况下，我们在`Genre.tsx`文件中使用了错误类型，这导致了一系列错误。通过这个工作流程，我们不仅找到了错误，还知道了我们必须修复错误的精确文件和行号。
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Working with CI pipelines is all about giving feedback as soon as possible.
    You should use tools such as Husky ([https://bit.ly/prn-husky](https://bit.ly/prn-husky))
    to run your pipelines before committing them to your local machine. This not only
    replaces your workflow automation tool, but it can also be useful to shorten the
    feedback cycle even more.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与CI管道一起工作，关键在于尽快提供反馈。你应该使用Husky ([https://bit.ly/prn-husky](https://bit.ly/prn-husky))等工具在将它们提交到本地机器之前运行你的管道。这不仅取代了你的工作流程自动化工具，还可以进一步缩短反馈周期。
- en: Now that you know how to create CI pipelines to support and improve the development
    process, let’s have a look at building and releasing apps.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何创建CI管道来支持和改进开发过程，让我们来看看构建和发布应用。
- en: Understanding workflow automation and CD for build and release
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解工作流程自动化和CD对于构建和发布的重要性
- en: 'Before we start creating our pipeline, let’s look at building and releasing
    apps in general. Android uses Gradle as its build tool and a KeyStore file to
    verify ownership of an app. If you are not familiar with releasing Android apps,
    please read this guide first: [https://bit.ly/prn-android-release](https://bit.ly/prn-android-release).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建我们的管道之前，让我们先看看构建和发布应用的一般情况。Android使用Gradle作为其构建工具，并使用KeyStore文件来验证应用的所有权。如果你不熟悉发布Android应用，请先阅读此指南：[https://bit.ly/prn-android-release](https://bit.ly/prn-android-release)。
- en: 'On iOS, you have to use Xcode to build, sign, and release your app. If you
    are not familiar with this process, please read this guide first: [https://bit.ly/prn-ios-release](https://bit.ly/prn-ios-release).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，你必须使用Xcode来构建、签名和发布你的应用。如果你不熟悉这个过程，请先阅读此指南：[https://bit.ly/prn-ios-release](https://bit.ly/prn-ios-release)。
- en: Fortunately, for both platforms (Android and iOS), the build and deployment
    processes can be executed via command-line tools. Gradle works as a command-line
    tool itself and Xcode provides the Xcode command-line tools. This means we can
    write scripts for the complete process, which we can then invoke with our workflow
    automation tools.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于两个平台（Android和iOS），构建和部署过程可以通过命令行工具执行。Gradle本身就是一个命令行工具，Xcode提供了Xcode命令行工具。这意味着我们可以为整个过程编写脚本，然后我们可以使用我们的工作流程自动化工具调用这些脚本。
- en: 'Unfortunately, these processes are quite complex, so we don’t want to write
    scripts by ourselves. This is where a toolset called **Fastlane** comes into play.
    Fastlane is a specialized automation tool for iOS and Android apps. It provides
    scripts for signing, building, and deploying code to the Apple App Store and Google
    Play. You can find more information about Fastlane here: [https://bit.ly/prn-fastlane](https://bit.ly/prn-fastlane).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些过程相当复杂，所以我们不想自己编写脚本。这就是一个名为**Fastlane**的工具集发挥作用的地方。Fastlane是iOS和Android应用的专用自动化工具。它提供了用于签名、构建和将代码部署到Apple
    App Store和Google Play的脚本。你可以在这里找到有关Fastlane的更多信息：[https://bit.ly/prn-fastlane](https://bit.ly/prn-fastlane)。
- en: The reason why I do not recommend using Fastlane directly is that it has excellent
    integration with advanced workflow automation tools such as Bitrise and CircleCI.
    We’ll take a deeper look at Bitrise as an example, but other tools such as CircleCI
    and Travis CI work very similarly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我不推荐直接使用Fastlane的原因是它与Bitrise和CircleCI等高级工作流程自动化工具具有出色的集成。我们将以Bitrise为例进行深入了解，但其他工具如CircleCI和Travis
    CI的工作方式非常相似。
- en: Bitrise integrates into your code management solution the same way you saw with
    GitHub Actions. You can use certain events to trigger workflows. It provides an
    excellent UI to create these workflows. I like working with it because it is quite
    easy and saves a lot of time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Bitrise以与GitHub Actions相同的方式集成到您的代码管理解决方案中。您可以使用某些事件来触发工作流程。它提供了一个出色的UI来创建这些工作流程。我喜欢使用它，因为它相当简单，并且节省了大量时间。
- en: 'You can choose from a huge variety of predefined actions, which mainly focus
    on iOS and Android apps. Bitrise even provides its own automatic setup for React
    Native apps. The following diagram shows a typical iOS build and deploy workflow:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从大量预定义的操作中选择，这些操作主要关注iOS和Android应用程序。Bitrise甚至为React Native应用程序提供自己的自动设置。以下图表显示了典型的iOS构建和部署工作流程：
- en: '![Figure 11.7 – Bitrise iOS build and deploy workflow'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.7 – Bitrise iOS build and deploy workflow](img/B16694_11_07.jpg)'
- en: '](img/B16694_11_07.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16694_11_07.jpg](img/B16694_11_07.jpg)'
- en: Figure 11.7 – Bitrise iOS build and deploy workflow
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – Bitrise iOS构建和部署工作流程
- en: The steps are executed column after column. So, we start by activating an SSH
    key to be able to connect to the repository. Next, the repository gets cloned.
    After that, the `npm` dependency modules are installed, as well as the native
    module via CocoaPods.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤是按列执行的。因此，我们首先激活一个SSH密钥，以便能够连接到仓库。接下来，仓库被克隆。之后，安装`npm`依赖模块，以及通过CocoaPods安装的原生模块。
- en: As an example, for every other script that can be integrated here, we’ll fetch
    the most recent translation files for our app UI to be integrated with the app
    bundle in the next step. Then, we’ll update the version number inside our `Info.plist`
    file. Next, the workflow handles the code signing, builds the application, and
    deploys it to App Store Connect.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于可以在此集成的每个其他脚本，我们将获取我们应用UI的最近翻译文件，以便在下一步与应用程序包集成。然后，我们将更新`Info.plist`文件中的版本号。接下来，工作流程处理代码签名，构建应用程序，并将其部署到App
    Store Connect。
- en: 'The workflow for an Android build looks pretty similar:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Android构建的工作流程看起来非常相似：
- en: '![Figure 11.8 – Bitrise Android build and deploy workflow'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.8 – Bitrise Android build and deploy workflow](img/B16694_11_07.jpg)'
- en: '](img/B16694_11_08.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16694_11_08.jpg](img/B16694_11_08.jpg)'
- en: Figure 11.8 – Bitrise Android build and deploy workflow
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.8 – Bitrise Android build and deploy workflow](img/B16694_11_08.jpg)'
- en: Again, the actions are executed column after column. The first column is the
    same as in the iOS workflow. The SSH key gets activated, the repository gets cloned,
    and the `npm` dependency modules are installed. Next, we have to install all the
    missing Android SDK tools.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，操作是按列执行的。第一列与iOS工作流程中的相同。激活SSH密钥，克隆仓库，并安装`npm`依赖模块。接下来，我们必须安装所有缺失的Android
    SDK工具。
- en: Then, we must change the Android version code and – as we did in iOS – fetch
    the translations to be bundled with the application. Then, we must build the application
    and deploy it to Google Play.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须更改Android版本代码，就像我们在iOS中做的那样，获取与应用程序捆绑的翻译。然后，我们必须构建应用程序并将其部署到Google Play。
- en: 'Under the hood, Bitrise and other CI tools with graphical workflow editors
    use the same logic you learned about while setting up the development CI pipeline.
    The following code is for the `.yml` file for the iOS workflow:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Bitrise和其他具有图形工作流程编辑器的CI工具使用您在设置开发CI管道时了解到的相同逻辑。以下代码是为iOS工作流程的`.yml`文件：
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, it has the same structure. It contains multiple steps, which
    can get additional input as configuration. Like any other workflow automation
    tool, Bitrise works with environment variables. These variables are stored on
    the platform and replace the placeholders (here, they start with `$`) during the
    execution of the workflow.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它具有相同的结构。它包含多个步骤，这些步骤可以作为配置获取额外的输入。像任何其他工作流程自动化工具一样，Bitrise使用环境变量。这些变量存储在平台上，并在工作流程执行期间替换占位符（在这里，它们以`$`开头）。
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should never add private keys or signing information to your repository.
    If this happened, everyone who has access to the repository would get access to
    this private data and would be able to sign releases for your application. It’s
    much better to store this information in your workflow automation tool because
    there, nobody can obtain the keys and signing certificates, but all developers
    with access can still create new releases.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不应该将私钥或签名信息添加到你的仓库中。如果发生了这种情况，任何可以访问仓库的人都可以获取这些私有数据，并能够为你的应用程序签名发布。将此信息存储在你的自动化工作流程工具中会更好，因为在那里，没有人可以获取密钥和签名证书，但所有有访问权限的开发者仍然可以创建新的发布。
- en: This workflow can either be triggered manually, which I would recommend for
    public production builds, or automatically, which I would recommend for internal
    or public testing builds.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此工作流程可以是手动触发的，我建议用于公共生产构建，或者自动触发的，我建议用于内部或公共测试构建。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now, it’s time to wrap up this chapter. First, you learned what the terms workflow
    automation, continuous integration, and continuous delivery mean and which of
    them work for app development. Then, you considered a development process you
    can use in large-scale projects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候总结本章内容了。首先，你学习了工作流程自动化、持续集成和持续交付这些术语的含义，以及它们在应用开发中的应用。然后，你考虑了一个适用于大规模项目的开发流程。
- en: Next, you learned how to support this process through workflow automation with
    simple workflow automation tools such as GitHub Actions. Finally, you learned
    about specialized workflow automation tools such as Bitrise so that you can build,
    sign, and deploy your iOS and Android apps.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，你学习了如何通过简单的自动化工作流程工具，如GitHub Actions，来支持这个流程。最后，你了解了专门的自动化工作流程工具，如Bitrise，这样你就可以构建、签名和部署你的iOS和Android应用。
- en: One topic that is especially important when it comes to workflow automation
    was left out in this chapter – **testing**. Automated testing is important during
    the development phase, as well as before shipping your releases. Therefore, we’ll
    have a detailed look at automated testing in the next chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，有一个特别重要的主题——**测试**——在关于工作流程自动化的讨论中被遗漏了。自动化测试在开发阶段以及发布前都很重要。因此，我们将在下一章详细探讨自动化测试。
