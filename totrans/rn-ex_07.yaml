- en: Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have had a chance to get our feet wet with React Native, it''s
    time to dive into some serious architecture. One of the things that you might
    have encountered with our previous apps is that our components ended up encapsulating
    a large amount of logic in them and that some files ran several hundred lines.
    In this chapter, we''re going to introduce a new architecture for our apps to
    reduce bloat in our components. In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about Redux, the architecture that will help manage our React Native apps'
    state and data flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the dependencies for Redux in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactor `Tasks`, our to-do list app, to use Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux is a very popular library that many developers use to help write their
    React applications. On its GitHub repo, Redux bills itself as *a predictable state
    container for JavaScript apps*. Rather than having each component manage its own
    independent state, Redux proposes that your entire React application is governed
    by one single state. This single state is then proliferated through each component
    and allows the majority of your app's logic to live in reusable functions.
  prefs: []
  type: TYPE_NORMAL
- en: The three principles of Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can describe Redux by referring to three key principles regarding the state:
    it needs to be the single source of truth for your application, be read-only,
    and be modifiable only by pure functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Single state tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Redux, rather than having each component manage its own state, we deal with
    one single-state tree that contains all the logic in our application. For example,
    for the `Tasks` app we built in the first two chapters, you can visualize it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This helps make our app a lot easier to debug, since we're only dealing with
    one object tree when looking at the information it contains.
  prefs: []
  type: TYPE_NORMAL
- en: State is read-only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application state should never be modified directly. Instead, it should
    only be modified as the result of actions being dispatched and reducers interacting
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Changes are made with pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of a pure function comes from functional programming, and can be summarized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Given the same arguments, a pure function always returns the same result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of our application state, a pure function is able to execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables outside of a pure function's scope cannot be modified by it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three principles correlate with three major parts of the Redux ecosystem:
    actions, reducers, and store.'
  prefs: []
  type: TYPE_NORMAL
- en: Actions are how we can indirectly modify our read-only state. Reducers are the
    pure functions that perform that modification. The single store in Redux is where
    our state exists.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actions are simple objects containing information that sends data from your
    app over to the app's store. All the logic that your app handles will pass through
    the action - your store never receives any data from sources that aren't actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'An action requires a `type` property, which defines the type of user action
    that has occurred. Types of actions are represented in a stringified form. They
    can be hardcoded into the object itself or passed in as a constant. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These functions will be made available as props to all the components in your
    application and can be called at any time. When an action is called, the store
    then dispatches the action to every reducer in your application. Only the right
    reducer, chosen with conditional logic, will fire at this time, and will execute
    code that changes your application's state.
  prefs: []
  type: TYPE_NORMAL
- en: Reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vanilla JavaScript, there's an array prototype method called `reduce`. The
    purpose of this native reduce function is to return one single reduced value after
    running a callback and initial value through an entire array's contents.
  prefs: []
  type: TYPE_NORMAL
- en: In Redux, a reducer is a function that takes in your application's state and
    relevant information passed to it from an action, and then returns one single
    reduced value for your application's state after executing the code.
  prefs: []
  type: TYPE_NORMAL
- en: Reducers should, as a good practice, be restricted to one reducer per file,
    for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two really important things we need to know about reducers with Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: Your application state is never mutated. Instead, a copy is returned with any
    changed values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since each reducer will fire when an action happens in order to decide if that
    action is relevant to it, we have to return the previous application state in
    the event that any unknown (to that specific reducer) actions are fired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working from the preceding example, this is how a reducer would look for an
    `ADD_TASK` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Using ES6''s default arguments syntax to give us an empty array if a state
    does not exist, the `action` object is passed in from the action creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A store is an object that brings actions and reducers together. It does the
    following things for us:'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the application state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gives access to that state, via a method called `getState`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatches actions, which reducers then use to modify that state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing to be aware of with Redux is that, in a given application, you will
    only ever have one store. In the event that we want to split our logic into multiple
    handlers, we'll actually split the reducers instead, through a method called **reducer
    composition** this is something we'll take a look at once we need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how a sample store in Redux looks. Let''s assume we have the task reducer
    from before, and another one as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These are examples of actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These are where we would have our reducers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Within a component, we can simply call an action within a component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: But wait, how do our components know that this action is available? Just where
    do we expose our props? We do it using a library called `React-Redux`, which contains
    two things we want to utilize.
  prefs: []
  type: TYPE_NORMAL
- en: The first is the `connect` method, which connects our React Native application
    to the Redux store. The two arguments we're interested in passing to connect are
    `mapStateToProps` and `mapDispatchToProps`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mapStateToProps`, if specified, is a function that subscribes to updates to
    the state tree. Any time the state tree updates, `mapStateToProps` will be called
    and merges its return value into your component''s props. The return value needs
    to be an object. Here''s a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`mapDispatchToProps` will map our dispatch methods to our components'' props.
    As a function, we can call `bindActionCreators` to it and pass in our action creators,
    as well as a dispatch call, so they can be invoked directly. Here''s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, assuming `Main` as the entry point for our app, we''ll use `connect`
    to bring them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to propagate our store (and all of the actions and reducers associated
    with it), we''ll use the `Provider` from `React-Redux` to wrap our application
    and pass it our store as a prop. This allows the components in our React app to
    inherit these props naturally. It happens at the root level, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a good amount of setup, and, if you''re having some doubts about its
    effectiveness, I would urge you to power through the rest of this chapter: Redux
    is incredibly useful, because it''s going to let us write cleaner components that
    are a lot easier to maintain, and will help future contributors understand our
    code base better.'
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to install Redux, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use `npm` to install Redux. There are also a couple of dependencies
    it needs, and we''re going to install all of them at once. Make sure you''re at
    the root directory of your project folder, and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a brief overview of the three packages we''re installing into our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Redux`: This is the library itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React-Redux`: This is a library that provides bindings for React. Redux isn''t
    specifically tied to React, and this library will let us access the `Provider`
    component to pass down our props at the parent level with ease.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Redux-Thunk`: This is middleware that will help us make asynchronous calls
    with our actions, and is useful because we will be making calls to `AsyncStorage`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have the three packages installed, it's time to start setting up
    our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Redux architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The architecture of our application when using Redux will be slightly modified
    from what we had before. At present, this is how the `app` directory in our project
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Redux requires us to think differently about how we approach our app''s architecture,
    and we''ll be adding some new folders into the `app` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Containers in Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are where we're going to map the dispatch methods and application
    state that connect to both the component and Redux. The `components` folder will
    still exist, but we are going to refactor what's inside to not rely on a component-based
    state.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, every time we would usually render a component, we instead render
    its container.
  prefs: []
  type: TYPE_NORMAL
- en: Remaining folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `reducers` folder is going to contain a single reducer file, which handles
    all the logic that modifies our application state.
  prefs: []
  type: TYPE_NORMAL
- en: The `index.js` file found within the app folder will handle our Redux setup
    and be rendered by the root index files for both iOS and Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you''ll have at our root `index.ios.js` and `index.android.js` files are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Planning the Redux conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The approach we will take in converting our app to Redux will involve multiple
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we should begin by scaffolding a Redux project by creating a store, wrapping
    the `AppContainer` around a `Provider`, and creating some basic actions and reducers
    to handle very basic functionality--we can worry about persistent storage later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we will begin converting the `TasksList` component to Redux by creating
    a `TasksListContainer` and mapping our actions and state tree to the `TasksList`
    component. Any other components from when we built `Tasks` in [Chapter 1](d99b3309-3285-4c98-accc-0a3785a8d3be.xhtml), *First
    Project - Creating a Basic To-Do List App*, and [Chapter 2](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml),
    *Advanced Functionality and Styling the To-Do List App*, will remain untouched
    for the time being.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Afterwards, we will modify the `TasksList` component to take advantage of its
    container by removing all component-unspecific logic from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will repeat this series of steps for the `EditTask` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we should address the asynchronous calls to the `AsyncStorage` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Along the way, we should take every opportunity to make changes to the Android
    version of `Tasks` to convert it to a Redux architecture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the entry point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `index` file found at `app/index.js` will serve as the entry point into
    our application. Both the iOS and Android versions of `Tasks` will call upon it,
    and it''s going to set up our Redux architecture. First, we''ll import all the
    necessary dependencies. Don''t worry if we haven''t created any applicable files
    or folders for these items yet; we''ll do so very shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's set up our store.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up our store, we will need to use Redux''s `createStore` method and
    then pass it a reducer. Here''s how it looks on a high level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, since we know we'll be dealing with asynchronous calls in our
    application, we should also set up `Redux-Thunk` to support it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, pass the `applyMiddleware` function as the second argument to `createStore`.
    Pass `thunk` as an argument for `applyMiddleware`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll export a stateless function that returns our app container
    wrapped around the `Provider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In total, here''s how our `index.js` file will look at the end of the setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have created this file, let's build the app container. If you haven't
    already, create a `containers` folder within the `app` folder and then create
    separate `AppContainer` files for Android and iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Building the app container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The app container is going to provide a base `NavigatorIOS` route that renders
    our `TasksList` container. It looks similar to what we previously had in our root
    index files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The major difference between the `AppContainer` and the root index file is that
    it does not call `AppRegistry.registerComponent`. That part is still handled by
    the root index file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the two routes we will use for `Navigator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `routes` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This function handles the logic for rendering different routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next we will move onto creating actions and reducers in anticipation of building
    the `TasksList` container.
  prefs: []
  type: TYPE_NORMAL
- en: Creating actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create some actions that will help us with our application. In the `Tasks`
    app, we had functionality for the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching tasks from `AsyncStorage`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing a task's name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marking/unmarking a task as complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing/hiding the expandable component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving changes to a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearing changes to a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a due date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a due date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of how an action for editing a task''s name can look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When naming an action, we want to correlate the type of action with exactly
    what has happened as a result of a user interaction. In this case, the user edited
    the task name. This action will also pass our reducer a `title` and `index`, so
    the reducer can then search the state for the task with the provided `index`,
    and edit its `title`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, we have three actions we want to make sure work in `TasksList`:
    adding a task, changing its completion status, and modifying the value of `TextInput`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Each action is an exported function that returns an object with the action
    type as well as any other key-value pairs that contain data for our reducers to
    interact with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These will do for now - we'll slowly build in the other actions as we convert
    more and more of our application to support Redux. Next up, let's build the reducers
    for these three actions.
  prefs: []
  type: TYPE_NORMAL
- en: Building reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at how we would build reducers to handle creating a new task and
    saving it into our list of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we''re working with the following state tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the interest of writing a pure function, we want to make sure that we're
    not mutating the state and instead re-assigning our state to contain the updated
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an impure function, we would simply do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't do this!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'What we''re doing here is mutating our state tree''s tasks array to push a
    new task into it. This can lead to problems when debugging later. Instead, what
    we want to do can be broken into a series of actionable steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a copy of the current state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a copy of the task's property of our copied state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add our new task to the end of this copy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign this copied array as the new task's value of our copied state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the copied state as our new current state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `singleTask` reducer handles logic that affects just one single task in
    the list. The results of this reducer are immediately accessed by the main `listOfTasks`
    reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this event, we return an object containing a new task's details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `singleTask` reducer is called during iteration in the `listOfTasks` reducer.
    Here, if the index of the individual task matches up with the index we want to
    interact with, we return the existing object using a spread operator and switch
    its completed status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets a default state to pass over to `listOfTasks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `listOfTasks` reducer is where all actions first end up firing through.
    It then uses a switch statement to figure out which action type is being called
    and returns a new state object based on that action type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to add a task, return the state object through a spread operator
    containing an updated `listOfTasks` array that is built using the spread operator,
    calling the `singleTask` reducer with an empty object and the action object that
    is initially passed there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we change a task''s completion status, we call map on the `listOfTasks`
    array in the state and then call `singleTask` on each element in the task, passing
    the current task object and the action object to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `text` property of our state tree for `TextInput` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, `listOfTasks` is our parent reducer and handles the overall logic
    of our app, while `singleTask` handles the pertinent information for one single
    item in our list.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the TasksList container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've got our actions and reducers, we'll create the container that
    connects our dispatch methods and state to the `TasksList` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import the `connect` module from `react-redux`, alongside any
    actions we intend to dispatch in `TasksList`, as well as the `TasksList` component
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll create three methods that will result in dispatching functions
    to our state tree using `mapDispatchToProps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, we''ll map the state we intend to pass into TasksList''s prop,
    including the `Navigator` that we already have from the top level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will `connect` the `mapStateToProps` and `mapDispatchToProps` functions
    to the `TasksList` component and export it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at how we refactor the `TasksList` component.
  prefs: []
  type: TYPE_NORMAL
- en: Redux-connected TasksList component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Components in Redux will retain their JSX markup, but any logic that isn''t
    specific to that exact component is kept by our state tree and modified through
    actions and reducers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: React Native APIs and components such as `AsyncStorage` have been removed from
    this component, since any calls to any storage methods will be handled by our
    actions and reducers in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `ListView.DataSource` instance, since it is specific to this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `dataSource` constant for our `ListView` with the `listOfTasks`
    array in our state tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Callbacks such as `onChangeText` and `onSubmitEditing` now call actions that
    have been mapped to the `TasksListContainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This passes `TasksListCell''s` required `onLongPress` callback a placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Converting EditTasks to Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With `EditTasks`, we are introducing some new actions and reducers into the
    mix. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the currently selected task to one that was pressed on in `TasksList`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling a change when the Cancel or Save buttons are pressed in the `EditTask`
    screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toggling the selected task as completed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the name of the selected task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding, modifying, and removing the due date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding the expandable cell that shows and hides the `DatePicker` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first two bullet points, those modifications will come in the form of
    three new actions placed in the `TasksList` container, since that's the component
    where these events will either happen or be defined and passed to EditTask's navigator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our state tree will also need to hold the following new properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The formatted and unformatted dates from the DatePicker component that point
    to the selected task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object pertaining to the currently selected task in the `EditTask` screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indication whether the `ExpandableCell` is visible or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indication whether a date has been selected in the EditScreen view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this in mind, let's start the conversion with our actions!
  prefs: []
  type: TYPE_NORMAL
- en: Adding actions for EditTask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the additions to the actions file to accommodate `EditTask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: These are new constants that describe the different actions that the `EditTask`
    component will bring to the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions are straightforward, since they pass the desired action type
    between zero and two values for our reducers to handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `saveSelectedTaskDetails` action is more complex than the rest. It takes
    an object from the `EditTask` component and then breaks it into different properties
    for our reducer to work with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Reducers for EditTask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should also update our reducers to handle these newly introduced actions.
    We should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the `defaultState` object, including the `date`, `dateSelected`, `expanded`,
    `formattedDate`, and `selectedTaskObject` properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a helper function to format a date with MomentJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new switch case for the `singleTask` reducer to handle the `SAVE_SELECTED_TASK_DETAILS`
    action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a new `selectedTask` reducer for temporarily storing and modifying the
    `selectedTaskObject` being edited by the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend the `listOfTasks` reducer to handle each of the new actions, delegating
    them to either the `singleTask` or `selectedTask` reducers when necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `defaultState` object has gotten larger to accommodate new information
    that `EditTask` will be using, such as the `expanded` status of `ExpandableCell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Format the date with MomentJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'No changes were made to these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This is specifically to save details for a task that has been selected for
    editing by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a new reducer created to address the task object currently being edited
    by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Redux state stores the object being edited by the user because at any given
    point, the user can simply decide to cancel any changes. Keeping changes in a
    temporary object and only saving them to the state once the user has pressed on
    the Save button saves us the hassle of undoing any changes the user has made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the `singleTask` reducer, `selectedTask` is accessed by the main
    `listOfTasks` reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: No changes were made to the following two cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This is the code for setting the `selectedTaskObject` property in our Redux
    state. It also sets the date, `dateSelected`, and `formattedDate` properties for
    the `DatePicker` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'No changes to this case either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the first time we call the `selectedTask` reducer from `listOfTasks`.
    It changes the completion status of the task currently being edited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This case changes the due date of the selected task, as well as the `date`,
    `dateSelected`, and `formattedDate` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the name of the selected task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Handle the `expanded` property of `ExpandableCell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what gets executed if the user presses `Cancel` in the `EditTask` screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the due date from the selected task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this saves the selected task permanently into the `listOfTasks` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Updating TasksListContainer to accommodate EditTask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we should update the `TasksListContainer` and `TasksList` component. First,
    `TasksListContainer` should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `changeCurrentlyEditedTask`, `resetSelectedTask`, and `saveSelectedTaskDetails`
    actions and add them to the `mapDispatchToProps` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import the `date`, `formattedDate`, and `selectedTaskObject` properties of our
    Redux state and add them to the `mapStateToProps` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Above, I imported three new actions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Mapping the three new actions to the dispatch methods of `TasksList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Mapping three new values in the Redux state to the props of `TasksList`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the TasksList component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s make changes to `TasksList` so that it supports `EditTask`. It
    should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `EditTaskContainer` for us to push to the navigator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Platform` API to support Android devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `onLongPress` callback for `TasksListCell` to call a function that
    first adds the currently selected task to the Redux state and then navigate the
    user to the `EditTaskContainer`. It should contain a `Cancel` and `Save` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Cancel` button should fire a function that `pops` the navigator and resets
    the `selectedTaskObject` value in your Redux state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Save` button should fire a function that `pops` the navigator and saves
    the `selectedTaskObject` into the `listOfTasks` array in your Redux state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are my changes to the `TasksList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code adds the `_cancelEditingTask` function to call `pop` on
    the navigator and then the `resetSelectedTask` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `onLongPress` callback for `TasksListCell` to call the following
    `_onLongPress` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user is on an iOS device, `push` the `EditTaskContainer` to the navigator
    and pass it a string for the left and right buttons, and give them callbacks that
    fire when they are pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'On an Android device, just `push` the index of the route specified in `AppContainer.android.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'When saving the edited task, first `pop` the navigator and then dispatch the
    `saveSelectedTaskDetails` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Creating the EditTask container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `EditTaskContainer` will be composed the same way as TasksListContainer.
    It will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Import actions relevant to the `EditTask` component from your actions file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `EditTask` and `connect` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Contain a `mapDispatchToProps` method to map the actions you imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `mapStateToProps` on any parts of the Redux state you wish `EditTask` to
    have access to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `connect` on `mapDispatchToProps`, `mapStateToProps`, and the `EditTask`
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These are the actions that `EditTask` will be utilizing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `resetSelectedTask` and `saveSelectedTaskDetails` actions are mapped to
    `EditTaskContainer` specifically for the Android version of this app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '`EditTask` should have access to the following data from the state tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `connect` everything together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the EditTask component for iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will modify the `EditTask` component. It should:'
  prefs: []
  type: TYPE_NORMAL
- en: Be nearly identical to the `EditTask` component we had at the end of [Chapter
    2](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml), *Advanced Functionality and Styling
    the To-Do List App*, with both an Android- and iOS-specific version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace any methods that manipulate data with the actions that we can dispatch
    to the state tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since `datePickerHeight` is set during the `onLayout` event of `DatePickerIOS`,
    we will keep it in the local state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TextInput` dispatches the `changeTextInputValue` action when text is changed,
    and gets its value from the `selectedTaskObject` of our state tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExpandableCell` component remains the same here, but delegates its `expanded`
    Boolean and `title` determination logic to our Redux state and dispatches the
    `onExpand`  action when pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the only remaining component-based logic is with `_getDatePickerHeight`.
    All other functions are dispatched for the state tree to handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the EditTask component for Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's easiest for us to take the Android `EditTask` component from [Chapter 2](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml), *Advanced
    Functionality and Styling the To-Do List App*, and make changes to it. Additionally,
    referencing the updated iOS version of this component during these changes can
    also help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, for the Android version of `EditTask`, we want to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Swap out any references to the local state with the state tree made available
    via `props`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace any unnecessary calls to the local methods, dispatching actions instead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the local methods for saving a task and opening both the date and time
    pickers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the callback that pressing the back button triggers, resetting the `selectedTaskObject`
    in addition to calling `pop` on the navigator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modifications that I made show the differences between `EditTask/index.android.js`
    and `EditTask/index.ios.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I removed `ExpandableCell` from my import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'I removed the `datePickerHeight` value in the state, since the Android component
    does not deal with `ExpandableCell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding and removing event listeners for the Android back button is unchanged
    from [Chapter 2](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml), *Advanced Functionality
    and Styling the To-Do List App*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: No changes were made to the `TextInput` component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Button` to open `DatePickerAndroid` is modified to reference the `selectedTaskObject`
    due property to determine the text to render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'No changes were made to the `Switch` component, Clear Date `Button`, or Save
    `Button`. The Save `Button` is exclusive to the Android version of this app, since
    the logic to save the edited task is handled in the navigation bar on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `_backButtonPress` to also dispatch the `resetSelectedTask` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'I also modified `_saveSelectedTaskDetails` to dispatch the `saveSelectedTasks`
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Change `_showAndroidDatePicker` to not keep the `day`, `month`, and `year`
    values in the state. Instead, it passes the data directly to `_showAndroidTimePicker`
    for immediate use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, `_showAndroidTimePicker` is changed to accept those `day`, `month`,
    and `year` values. Then it creates a new `Date` object immediately with those
    three values, along with the `hour` and `minute` that `TimePickerAndroid` returns,
    and dispatches the `onDateChange` action with the new `Date` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have almost completed our port to Redux! The only thing that
    remains is persisting our list of tasks as before.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a StorageMethods file for asynchronous saving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, any refresh or exiting of the application will wipe our list of tasks
    clean. That doesn't make for a very useful app, so we're now going to modify our
    actions to store and retrieve our list of tasks from `AsyncStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `utils` folder within `app`, and then create a file titled
    `storageMethods.js` within `utils`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_07_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This file will contain two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getAsyncStorage`: This gets the `listOfTasks` item in `AsyncStorage` and returns
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saveAsyncStorage`: This accepts an array and saves it into `AsyncStorage`
    under the `listOfTasks` key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you worked on the previous projects in this book, this part will be very
    familiar to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This uses asynchronous functions for readability, grabbing the `listOfTasks`
    value in `AsyncStorage`, parsing it to transform it back to an array, and then
    returning it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, accept an array and then set the `listOfTasks` key in `AsyncStorage`
    to the stringified version of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing the store to changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To update the `listOfTasks` key in `AsyncStorage` whenever a change is made
    to the state tree, we will call the `subscribe` method of our store. This creates
    a change listener to be called whenever an action has been dispatched and the
    state tree may have been changed.
  prefs: []
  type: TYPE_NORMAL
- en: It accepts a callback as its argument, and within that argument we can call
    the `getState` method of the store to access the state tree and retrieve any values
    we want from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the index file found in the app folder so that it subscribes
    to changes to the store, firing a callback that calls `saveAsyncStorage` and passes
    it the most recent version of the `listOfTasks` array in our state tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Since the rest of our application state does not have a need for persistence,
    `listOfTasks` is the only item being saved into `AsyncStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thunk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Redux-Thunk` library is a wrapper around your action creators, allowing
    them to perform asynchronous tasks before dispatching their intended action to
    the Redux store for a reducer to handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we will create a thunk: in the file where we create actions, we
    will export a function that returns a custom, asynchronous function within it,
    passing it the existing `dispatch` method. In this custom function, we will grab
    the results of a call to our `getAsyncStorage` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, within the same method, we will dispatch a private function, which we
    also create in the same file. That private function will return the action type,
    along with any parameters we wish to pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: I removed the `currentIndex` variable from this file, since we will no longer
    rely on a hardcoded number to set the index of our tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a constant for the action to set the list of tasks and index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Create the `getListOfTasksAndIndex` action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This `setListOfTasksAndIndex` function is not exported, since it is only being
    called by `getListOfTasksAndIndex`. We are using the length of the array to set
    the index for a newly added task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Modifying our reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to modify our reducers file so that it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adds the `currentIndex` property to its `defaultState` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the `index` of a task when it is added to our state tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increases the `currentIndex` property of our state tree by one when adding a
    new task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains a switch case for the `SET_LIST_OF_TASKS_AND_INDEX` action, setting
    the `currentIndex` and `listOfTasks` properties of our state tree to the results
    of our `getListOfTasksAndIndex` thunk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The `ADD_TASK` case in the `singleTask` sub-reducer sets the index of the added
    task.
  prefs: []
  type: TYPE_NORMAL
- en: No changes are made to the `selectedTask` sub-reducer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `ADD_TASK` case in the `listOfTasks` reducer increments
    the `currentIndex` of the state tree by one and sets it as the new `currentIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `SET_LIST_OF_TASKS_AND_INDEX` case sets the `currentIndex`
    and `listOfTasks` properties in our state tree with the results of calling `getAsyncStorage`
    back in our `getListOfTasksAndIndex` thunk.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the TasksListContainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we need to update the `TasksListContainer` so that it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Maps the `getListOfTasksAndIndex` action and `currentIndex` value to its props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifies the `addTask` action to expect and send an `index` argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the changes I ended up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the TasksList component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we will edit `TasksList` so that it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Dispatches the `getListOfTasksAndIndex` action during the `componentWillMount`
    life cycle event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passes in the `currentIndex` of the state tree to the `TextInput's``onSubmitEditing`
    callback as a second argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Call `getListOfTasksAndIndex` during `componentWillMount`, making sure that
    `TasksList` has the most up-to-date version of the `listOftasks` array as the
    user opens the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `this.props.currentIndex` as the second argument to calling the `addTask`
    method, so that we explicitly give each task a unique index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: And there you have it! We've successfully converted `Tasks`, our to-do list
    app, to support Redux.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the fundamentals of React development with Redux!
    We started by creating actions, which dispatch intent to our Redux store. Then,
    we wrote reducers to handle that intent and update our state tree. We also built
    a store that consolidated our reducers and middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Afterwards, we used the Connect method to wrap a container around a React component,
    giving it access to any actions and parts of the state tree of our choosing.
  prefs: []
  type: TYPE_NORMAL
- en: We also converted the existing `EditTask` and `TasksList` components to be less
    reliant on the local state and use its logic from the state tree.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, we discovered how to temporarily delay the dispatching
    of actions to perform necessary asynchronous calls first by using `Redux-Thunk`.
    This, in conjunction with subscribing our store to any updates, allowed us to
    have a fully persistent app that used `AsyncStorage` to keep its data.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we made sure that every step along the way kept the Android support
    we started the chapter with.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to change things a bit. We have spent all
    this time building applications, but no time on how to share them with the world.
    In the next chapter, we will learn just how to get these apps you have made onto
    the Apple App Store and Google Play Store.
  prefs: []
  type: TYPE_NORMAL
