- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Forms, Observables, Signals, and Subjects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单、可观察对象、信号和主题
- en: In this chapter, we’ll work on a simple weather app, **LocalCast Weather**,
    using Angular and a third-party web API from [OpenWeatherMap.org](https://www.geonames.org/postal-codes).
    The source code for this project is provided on GitHub at [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app),
    including various stages of development in the `projects` folder.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Angular 和来自 [OpenWeatherMap.org](https://www.geonames.org/postal-codes)
    的第三方 Web API，开发一个简单的天气应用 **LocalCast Weather**。该项目的源代码可在 GitHub 上找到，网址为 [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)，包括在
    `projects` 文件夹中的各个开发阶段。
- en: If you’ve never used Angular before and need an introduction to Angular essentials,
    I recommend checking out *What is Angular?* on Angular.dev at [https://angular.dev/overview](https://angular.dev/overview)
    and going through the *Learn Angular Tutorial* at [https://angular.dev/tutorials/learn-angular](https://angular.dev/tutorials/learn-angular).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前从未使用过 Angular，并且需要了解 Angular 的基础知识，我建议您查看 Angular.dev 上的 *什么是 Angular？*
    [https://angular.dev/overview](https://angular.dev/overview)，并学习 *Angular 教程*
    [https://angular.dev/tutorials/learn-angular](https://angular.dev/tutorials/learn-angular)。
- en: 'Feeling brave? Just type the following into your terminal:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 感觉勇敢吗？只需在您的终端中输入以下内容：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: LocalCast Weather is a simple app that demonstrates the essential elements that
    make up an Angular application, such as components, standalone components, modules,
    providers, pipes, services, RxJS, unit testing, e2e using Cypress, environment
    variables, Angular Material, and **Continuous Integration** and **Continuous Delivery**
    (**CI/CD**) pipelines leveraging CircleCI.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: LocalCast Weather 是一个简单的应用，展示了构成 Angular 应用程序的基本元素，例如组件、独立组件、模块、提供者、管道、服务、RxJS、单元测试、使用
    Cypress 的端到端测试、环境变量、Angular Material 以及利用 CircleCI 的 **持续集成** 和 **持续交付** （**CI/CD**）
    管道。
- en: 'I’ve created a Kanban board for this project on GitHub. You can access it at
    the following link to get more context about the project:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在 GitHub 上为这个项目创建了一个看板板。您可以通过以下链接访问它，以了解更多关于项目的背景信息：
- en: '[https://github.com/users/duluca/projects/1](https://github.com/duluca/local-weather-app).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/users/duluca/projects/1](https://github.com/duluca/local-weather-app).'
- en: A Kanban board is a great way to document your plans for building an app. I
    touch on the importance of building a roadmap and creating information radiators
    for the status of your project in *Chapter 3*, *Architecting an Enterprise App*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 看板板是一个很好的方式来记录您构建应用的计划。我在 *第 3 章*，*构建企业应用架构* 中提到了制定路线图和创建项目状态信息发射器的必要性。
- en: An information radiator is a physical or virtual display that is easily visible
    or accessible, conveying key information about a project or process. It typically
    includes metrics, progress charts, or status indicators and is designed to provide
    at-a-glance awareness without requiring the viewer to seek out information. The
    goal of an information radiator is to promote transparency, facilitate communication
    among team members, and enable stakeholders to get updates without interrupting
    the team’s workflow.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 信息发射器是一种物理或虚拟显示，易于可见或访问，传达有关项目或过程的关键信息。它通常包括指标、进度图表或状态指示器，旨在提供一目了然的认识，而无需观众寻求信息。信息发射器的目标是促进透明度，促进团队成员之间的沟通，并使利益相关者能够在不打扰团队工作流程的情况下获取更新。
- en: As a bonus, I created a rudimentary wiki page on my repository at [https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki).
    Note that you can’t upload images to `README.md` or wiki pages. To get around
    this limitation, you can create a new issue, upload an image in a comment, and
    copy and paste the URL for it to embed images in `README.md` or wiki pages. In
    the sample wiki, I followed this technique to embed the wireframe design into
    the page.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外奖励，我在我的仓库 [https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki)
    上创建了一个基本的维基页面。请注意，您无法在 `README.md` 或维基页面上上传图片。为了克服这一限制，您可以创建一个新的问题，在评论中上传一张图片，并将图片的
    URL 复制粘贴到 `README.md` 或维基页面上以嵌入图片。在示例维基中，我使用了这种方法将线框设计嵌入到页面中。
- en: The source code for the sample projects in the book is divided into **stages**
    to capture snapshots of various states of development. In this chapter, we pick
    up the app development from `stage5` and evolve it into `stage6`. In `stage5`,
    the app is polished, but it can only pull weather information for one city, which
    is hardcoded into the app. As a result, it is not a very useful app.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 书中示例项目的源代码被分为 **阶段** 以捕捉开发的各种状态快照。在本章中，我们从 `stage5` 开始应用开发，并演进到 `stage6`。在 `stage5`
    中，应用已经完善，但它只能拉取一个城市的天气信息，该信息被硬编码到应用中。因此，它不是一个非常有用的应用。
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_02_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B20960_02_01.png)'
- en: 'Figure 2.1: The LocalCast Weather app as in projects/stage5'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：LocalCast 天气应用，如 projects/stage5 中的项目
- en: You will inherit an existing project that is not interactive yet. To build an
    interactive app, we need to be able to handle user input. Enabling user input
    in your application opens possibilities for creating great user experiences.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您将继承一个尚未交互的项目。为了构建交互式应用，我们需要能够处理用户输入。在您的应用程序中启用用户输入可以打开创建优秀用户体验的可能性。
- en: 'We will cover the following main topics in this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Great UX should drive implementation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀的用户体验应驱动实现
- en: Reactive forms versus template-driven forms
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式表单与模板驱动表单的比较
- en: Component interaction with observables and RxJS/BehaviorSubject
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件与可观察对象和 RxJS/BehaviorSubject 的交互
- en: Managing subscriptions and memory leaks
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理订阅和内存泄漏
- en: Coding in the reactive paradigm
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在响应式范式中进行编码
- en: Chaining API calls
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接 API 调用
- en: Using Angular Signals
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 信号
- en: Generating apps with ChatGPT
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ChatGPT 生成应用
- en: Technical requirements
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked shortly. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的示例代码的最新版本可在 GitHub 上找到，链接将在稍后提供。该存储库包含代码的最终和完成状态。您可以在本章末尾通过查找 `projects`
    文件夹下的章节末尾代码快照来验证您的进度。
- en: 'For *Chapter 2*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **第 2 章**：
- en: Clone the [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
    repo.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆 [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
    存储库。
- en: Execute `npm install` on the root folder to install dependencies.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根文件夹中执行 `npm install` 以安装依赖项。
- en: 'The beginning state of the project is reflected at:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目的初始状态反映在：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The end state of the project is reflected at:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目的最终状态反映在：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将阶段名称添加到任何 `ng` 命令中，以仅对该阶段执行操作：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the `dist/stage6` folder at the root of the repository will contain
    the compiled result.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，存储库根目录下的 `dist/stage6` 文件夹将包含编译结果。
- en: Beware that the source code provided in the book and the version on GitHub are
    likely to be different. The ecosystem around these projects is ever evolving.
    Between changes to how the Angular CLI generates new code, bug fixes, new versions
    of libraries, and side-by-side implementations of multiple techniques, there’s
    a lot of variation impossible to account for. If you find errors or have questions,
    please create an issue or submit a pull request on GitHub.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，书中提供的源代码和 GitHub 上的版本可能不同。这些项目周围的生态系统一直在不断发展。由于 Angular CLI 生成新代码的方式的变化、错误修复、库的新版本以及多种技术的并行实现，存在许多难以计数的差异。如果您发现错误或有问题，请在
    GitHub 上创建问题或提交拉取请求。
- en: By the end of the chapter, you should be comfortable leveraging observables
    and signals to build apps that provide a great UX. As a bonus, I’ll touch on how
    you can leverage **Generative AI** (**GenAI**) tools like ChatGPT ([https://chat.openai.com/](https://chat.openai.com/))
    to build quick prototypes. But first, let’s get back to UX because no matter how
    much you run, crawl, or scale the city walls, if you nail the UX, your app will
    be loved; but if you miss the mark, your app will be a dime a dozen.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该能够熟练地利用可观察对象和信号构建提供优秀用户体验的应用。作为额外奖励，我将简要介绍您如何利用 **生成式 AI**（**GenAI**）工具，如
    ChatGPT ([https://chat.openai.com/](https://chat.openai.com/)) 来构建快速原型。但首先，让我们回到用户体验，因为无论您如何奔跑、爬行或扩展城市城墙，如果您的用户体验做得好，您的应用将受到喜爱；但如果您没有达到目标，您的应用将一文不值。
- en: Great UX should drive implementation
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优秀的用户体验应驱动实现
- en: 'Creating an easy-to-use and rich **User Experience** (**UX**)should be your
    main goal. You shouldn’t pick a design just because it’s easiest to implement.
    However, often, you’ll find a great UX that is simple to implement in the front
    end of your app but a lot more difficult on the back end. Consider google.com’s
    landing page:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个易于使用且丰富的**用户体验**（**UX**）应该是你的主要目标。你不应该仅仅因为最容易实现而选择一个设计。然而，通常你会发现一个伟大的 UX，在应用的前端实现起来很简单，但在后端却要困难得多。考虑一下
    google.com 的登录页面：
- en: '![A screenshot of a google search  Description automatically generated with
    medium confidence](img/B20960_02_02.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![谷歌搜索截图，描述由中等置信度自动生成](img/B20960_02_02.png)'
- en: 'Figure 2.2: Google’s landing page'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：谷歌的登录页面
- en: In this context, Google Search is just a simple input field with two buttons.
    Easy to build, *right?* That simple input field unlocks some of the world’s most
    sophisticated and advanced software technologies backed by a global infrastructure
    of custom-built data centers and **Artificial Intelligence** (**AI**). It is a
    deceptively simple and insanely powerful way to interact with users. You can augment
    user input by leveraging modern web APIs like `GeoLocation` and add critical context
    to derive new meaning from user input. So, when the user types in `Paris`, you
    don’t have to guess whether they mean Paris, France, or Paris, Texas, or whether
    you should show the current temperature in Celsius or Fahrenheit. With `LocalStorage`,
    you can cache user credentials and remember user preferences to enable dark mode
    in your app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，谷歌搜索只是一个简单的输入字段，带有两个按钮。容易构建，**对吧**？这个简单的输入字段解锁了世界上一些最复杂和最先进的软件技术，这些技术背后是全球基础设施中的定制数据中心和**人工智能**（**AI**）。这是一种欺骗性的简单且疯狂强大的与用户互动的方式。你可以通过利用现代网络
    API，如`GeoLocation`来增强用户输入，并为从用户输入中推导出新的含义添加关键上下文。因此，当用户输入`巴黎`时，你不必猜测他们是指法国的巴黎，还是指德克萨斯州的巴黎，或者你是否应该显示摄氏度或华氏度的当前温度。使用`LocalStorage`，你可以缓存用户凭据并记住用户偏好，以在您的应用中启用深色模式。
- en: In this book, we won’t be implementing an AI-driven super app, but we will enable
    users to search for their cities using a city name or postal code (often called
    *zip codes* in the US). Once you realize how complicated it can get to implement
    something as seemingly simple as a search by postal code, you may gain a new appreciation
    for well-designed web apps.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会实现一个由人工智能驱动的超级应用，但我们将允许用户通过城市名称或邮政编码（在美国通常称为“邮编”）来搜索他们的城市。一旦你意识到实现看似简单的邮政编码搜索可能有多么复杂，你可能会对精心设计的网络应用产生新的赞赏。
- en: To accomplish the UX goal, we need to build a UI centered around an input field.
    To do this, we need to leverage Angular forms with validation messages to create
    engaging search experiences with *search-as-you-type* functionality.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现用户体验目标，我们需要构建一个以输入字段为中心的用户界面。为此，我们需要利用 Angular 表单和验证消息来创建具有“边打边搜”功能的引人入胜的搜索体验。
- en: Behind the scenes, `RxJS`/`BehaviorSubject` or `signals` enables us to build
    decoupled components that can communicate with one another, and a reactive data
    stream allows us to merge data from multiple web APIs without increasing the complexity
    of our app. In addition, you will be introduced to Angular Signals and see how
    it differs from RxJS.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`RxJS`/`BehaviorSubject`或`信号`使我们能够构建解耦的组件，它们可以相互通信，并且一个响应式数据流允许我们在不增加我们应用复杂性的情况下合并来自多个网络
    API 的数据。此外，你将了解 Angular 信号，并了解它与 RxJS 的区别。
- en: 'Next, let’s see how to implement an input field using forms. Forms are the
    primary mechanism that we need to capture user input. In Angular, there are two
    kinds of forms: **reactive** and **template-driven**. We need to cover both techniques
    so that you’re familiar with how forms work in Angular.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用表单实现输入字段。表单是我们捕获用户输入的主要机制。在 Angular 中，有两种类型的表单：**响应式**和**模板驱动**。我们需要涵盖这两种技术，以便你熟悉
    Angular 中表单的工作方式。
- en: Reactive versus template-driven forms
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式表单与模板驱动表单
- en: Now, we’ll implement the search bar on the home screen of the application. The
    next user story states **Display forecast information for current location**,
    which may be taken to imply an inherent GeoLocation functionality. However, as
    you may note, GeoLocation is a separate task. The challenge is that with native
    platform features such as GeoLocation, you are never guaranteed to receive the
    actual location information. This may be due to signal loss issues on mobile devices,
    or the user may simply refuse to give permission to share their location information.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现搜索栏在应用程序的主屏幕上。下一个用户故事是**显示当前位置的预报信息**，这可能意味着固有的地理定位功能。然而，正如你可能注意到的，地理定位是一个单独的任务。挑战在于，使用原生平台功能，如地理定位，你永远不能保证收到实际的位置信息。这可能是由于移动设备上的信号丢失问题，或者用户可能简单地拒绝分享他们的位置信息。
- en: 'First and foremost, we must deliver a good baseline UX and implement value-added
    functionality such as GeoLocation only afterward. In `stage5`, the status of the
    project is represented on the Kanban board, as captured in the following snapshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须提供一个良好的基线用户体验，然后才实现诸如地理定位等增值功能。在 `阶段5`，项目状态在看板（Kanban board）上表示，如下快照所示：
- en: '![A screenshot of a chat  Description automatically generated with medium confidence](img/B20960_02_03.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![聊天截图，描述自动生成，中等置信度](img/B20960_02_03.png)'
- en: 'Figure 2.3: GitHub project Kanban board'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：GitHub项目看板
- en: We’ll implement the **Add city search capability** card (which captures a user
    story), as shown in the **In progress** column. As part of this story, we are
    going to implement a search-as-you-type functionality while providing feedback
    to the user if the service is unable to retrieve the expected data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现**添加城市搜索功能**卡片（它捕获了一个用户故事），如图**进行中**列所示。作为这个故事的一部分，我们将实现一个即搜即显的功能，并在服务无法检索预期数据时向用户提供反馈。
- en: Initially, it may be intuitive to implement a type-search mechanism; however,
    `OpenWeatherMap` APIs don’t provide such an endpoint. Instead, they provide bulk
    data downloads, which are costly and are in the multiples-of-megabytes range.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，实现一个类型搜索机制可能看起来很直观；然而，`OpenWeatherMap` API 并不提供这样的端点。相反，它们提供批量数据下载，这些下载成本高昂，且数据量在兆字节级别。
- en: We will need to implement our application server to expose such an endpoint
    so that our app can effectively query while using minimal data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现我们的应用程序服务器以暴露这样的端点，以便我们的应用程序在尽可能少用数据的情况下有效地查询。
- en: The free endpoints for `OpenWeatherMap` do pose an interesting challenge, where
    a two-digit country code may accompany either a city name or zip code for the
    most accurate results. This is an excellent opportunity to implement a feedback
    mechanism for the user if more than one result is returned for a given query.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenWeatherMap` 的免费端点确实提出了一个有趣的挑战，即两位数的国家代码可能伴随城市名称或邮政编码，以获得最准确的结果。这是一个为用户提供反馈机制的绝佳机会，如果针对特定查询返回多个结果。'
- en: We want every iteration of the app to be a potentially releasable increment
    and avoid doing too much at any given time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望应用程序的每一次迭代都是一个可能发布的增量，并避免在任何给定时间内做太多事情。
- en: 'Before you begin working on a story, it is a good idea to break it into technical
    tasks. The following is the task breakdown for this story:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写故事之前，将故事分解成技术任务是件好事。以下是本故事的分解任务：
- en: Add an Angular form control so that we can capture user input events.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 Angular 表单控件，以便我们可以捕获用户输入事件。
- en: Use an Angular Material input as documented at [https://material.angular.io/components/input](https://material.angular.io/components/input)
    to improve the UX of the input field.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在[https://material.angular.io/components/input](https://material.angular.io/components/input)上记录的
    Angular Material 输入来提高输入字段的用户体验。
- en: Create the search bar as a separate component to enforce the separation of concerns
    and a decoupled component architecture.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将搜索栏作为一个单独的组件创建，以强制执行关注点的分离和解耦的组件架构。
- en: Extend the existing endpoint to accept a zip code and make the country code
    optional in `weather.service.ts` to make it more intuitive for end users to interact
    with our app.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `weather.service.ts` 中扩展现有端点以接受邮政编码，并使国家代码在可选，以便使最终用户与我们的应用程序交互更加直观。
- en: Throttle requests so that we don’t query the API with every keystroke but at
    an interval where users still get immediate feedback without clicking a separate
    button.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制请求频率，这样我们就不需要在每次按键时查询API，而是在用户仍然能够立即获得反馈而不需要点击单独按钮的间隔内进行查询。
- en: Let’s tackle these tasks over the following few sections.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的几节中处理这些任务。
- en: Adding Angular reactive forms
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Angular 响应式表单
- en: You may wonder why we’re adding Angular forms since we’ve got just a single
    input field, not a form with multiple inputs. As a general rule of thumb, any
    time you add an input field, it should be wrapped in a `<form>` tag. The `Forms`
    module contains `FormControl` that enables you to write the backing code behind
    the input field to respond to user inputs and provide the appropriate data or
    the validation or message in response.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们要添加 Angular 表单，因为我们只有一个输入字段，而不是一个包含多个输入字段的表单。作为一个一般规则，每次添加输入字段时，都应该将其包裹在
    `<form>` 标签中。`Forms` 模块包含 `FormControl`，它允许你编写输入字段背后的代码以响应用户输入并提供适当的数据或验证或消息。
- en: 'There are two types of forms in Angular:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 中有两种类型的表单：
- en: '**Template-driven forms**: These forms are like what you may be familiar with
    in the case of AngularJS, where the form logic is mainly inside the HTML template.
    I’m not a fan of this approach because it is harder to test these behaviors, and
    fat HTML templates become challenging to maintain quickly.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板驱动表单**：这些表单类似于你可能熟悉的 AngularJS 中的情况，其中表单逻辑主要在 HTML 模板内部。我不是这种方法的粉丝，因为它更难测试这些行为，而且庞大的
    HTML 模板难以快速维护。'
- en: '**Reactive forms**: The behavior of reactive forms is driven by TypeScript
    code in the controller. This means that your validation logic can be unit tested
    and, better yet, reused across your application. Reactive forms are the core technology
    that, in the future, will enable the Angular Material team to write automated
    tools that can autogenerate an input form based on a TypeScript interface.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式表单**：响应式表单的行为由控制器中的 TypeScript 代码驱动。这意味着你的验证逻辑可以进行单元测试，并且更好的是，可以在你的应用程序中重用。响应式表单是核心技术，在未来将使
    Angular Material 团队能够编写自动化工具，这些工具可以根据 TypeScript 接口自动生成输入表单。'
- en: Read more about reactive forms at [https://angular.dev/guide/forms/reactive-forms](https://angular.dev/guide/forms/reactive-forms).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://angular.dev/guide/forms/reactive-forms](https://angular.dev/guide/forms/reactive-forms)
    了解更多关于响应式表单的信息。
- en: In Angular, dependencies are encapsulated in modules provided by the framework.
    User-created modules are no longer mandatory, and our code sample is configured
    as a standalone app. For the component we define in the next section, you must
    import `FormsModule` and `ReactiveFormsModule` to be able to use these features
    in your template.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，依赖项被封装在框架提供的模块中。用户创建的模块不再是强制性的，并且我们的代码示例配置为一个独立的应用程序。对于下一节中定义的组件，你必须导入
    `FormsModule` 和 `ReactiveFormsModule` 才能在模板中使用这些功能。
- en: In a pure reactive form implementation, you only need `ReactiveFormsModule`.
    Note that `FormsModule` supports template-driven forms and other scenarios where
    you may only want to declare `FormControl` without `FormGroup`. This is how we
    implement the input field for this app. `FormGroup` is defined in the next section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯响应式表单实现中，你只需要 `ReactiveFormsModule`。请注意，`FormsModule` 支持模板驱动表单和其他你可能只想声明 `FormControl`
    而不是 `FormGroup` 的场景。这是我们实现此应用程序输入字段的这种方式。`FormGroup` 将在下一节中定义。
- en: Note that reactive forms allow you to code in the reactive paradigm, which is
    a net positive when using observables. Next, let’s add a city search component
    to our app.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，响应式表单允许你在响应式范式中进行编码，这在使用可观察者时是一个净正面。接下来，让我们向我们的应用程序添加一个城市搜索组件。
- en: Adding and verifying components
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和验证组件
- en: 'We will be creating a `citySearch` component using Angular Material form and
    input modules:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Angular Material 表单和输入模块创建一个 `citySearch` 组件：
- en: 'Create the new `citySearch` component:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的 `citySearch` 组件：
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Import the form dependencies from the previous section and Material dependencies,
    `MatFormFieldModule` and `MatInputModule`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一节导入表单依赖项和材料依赖项，`MatFormFieldModule` 和 `MatInputModule`：
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’re adding `MatFormFieldModule` because each input field should be wrapped
    in a `<mat-form-field>` tag to get the most out of the Angular Material functionality.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加 `MatFormFieldModule` 是因为每个输入字段都应该包裹在 `<mat-form-field>` 标签中，以充分利用 Angular
    Material 的功能。
- en: At a high level, `<form>` encapsulates numerous default behaviors for keyboard,
    screen-reader, and browser extension users; `<mat-form-field>` enables easy two-way
    data binding, a technique that should be used in moderation, and also allows graceful
    label, validation, and error message displays.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在高层次上，`<form>` 封装了针对键盘、屏幕阅读器和浏览器扩展用户的众多默认行为；`<mat-form-field>` 使双向数据绑定变得简单，这是一种应该适度使用的技巧，同时也允许优雅地显示标签、验证和错误消息。
- en: 'Create a basic template, replacing the existing content:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基本模板，替换现有内容：
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Declare a property named `search` and instantiate it as an instance of `FormControl`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `search` 的属性，并将其实例化为 `FormControl` 的一个实例：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Reactive forms have three levels of control:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 响应式表单有三个级别的控制：
- en: '`FormControl` is the most basic element with a one-to-one relationship with
    an input field.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormControl` 是与输入字段一对一关系的最基本元素。'
- en: '`FormArray` represents repetitive input fields that represent a collection
    of objects.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormArray` 表示表示对象集合的重复输入字段。'
- en: '`FormGroup` registers individual `FormControl` or `FormArray` objects as you
    add more input fields to a form.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormGroup` 在你向表单添加更多输入字段时，将单个 `FormControl` 或 `FormArray` 对象注册为对象。'
- en: Finally, the `FormBuilder` object is used to orchestrate and maintain the actions
    of a `FormGroup` object more easily. `FormBuilder` and `FormGroup` are first used
    in *Chapter 6*, *Implementing Role-Based Navigation*, and all controls, including
    `FormArray`, are covered in depth in *Chapter 8*, *Recipes – Reusability, Forms,
    and Caching*.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，`FormBuilder` 对象用于更轻松地编排和维护 `FormGroup` 对象的操作。`FormBuilder` 和 `FormGroup`
    首次在第 6 章“实现基于角色的导航”中使用，所有控件，包括 `FormArray`，在第 8 章“食谱 - 可重用性、表单和缓存”中进行了深入介绍。
- en: 'In `app.component.ts`, import `CitySearchComponent`, then add `<app-city-search>`
    as a new `div` in between the row that contains the tagline of the app and the
    row that contains `mat-card`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.component.ts` 中导入 `CitySearchComponent`，然后在包含应用标语和包含 `mat-card` 的行的中间添加
    `<app-city-search>` 作为新的 `div`：
- en: '[PRE8]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Launch your app from your terminal:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端启动你的应用：
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Test the integration of components by checking out the app in the browser, as
    shown:![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_02_04.png)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在浏览器中查看应用来测试组件的集成，如下所示：![计算机屏幕截图  描述由中等置信度自动生成](img/B20960_02_04.png)
- en: 'Figure 2.4: The LocalCast Weather app with a search field'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.4：带有搜索字段的 LocalCast 天气应用
- en: If no errors occur, we can start adding the `FormControl` elements and wire
    them up to a search endpoint.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生错误，我们可以开始添加 `FormControl` 元素并将它们连接到搜索端点。
- en: Adding a search option to the weather service
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向天气服务添加搜索选项
- en: So far, we have been passing parameters to get the weather for a city using
    its name and country code. By allowing users to enter zip codes, we must make
    our service more flexible in accepting both types of inputs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过传递参数使用城市名称和国家代码来获取天气。通过允许用户输入邮政编码，我们必须使我们的服务在接受这两种类型的输入时更加灵活。
- en: OpenWeatherMap’s API accepts URI parameters, so we can refactor the existing
    `getCurrentWeather` function using a TypeScript **union type** and a **type guard**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWeatherMap 的 API 接受 URI 参数，因此我们可以使用 TypeScript 的 **联合类型** 和 **类型守卫** 重构现有的
    `getCurrentWeather` 函数。
- en: 'That means we can supply different parameters while preserving type checking:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在保留类型检查的同时提供不同的参数：
- en: 'Refactor the `getCurrentWeather` function in `weather.service.ts` to handle
    both `zip` and `city` inputs:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `weather.service.ts` 中重构 `getCurrentWeather` 函数以处理 `zip` 和 `city` 输入：
- en: '[PRE10]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We renamed the `city` parameter to `search` since it can be a city name or a
    zip code. We then allowed its type to be either a `string` or a `number`, and
    depending on what the type is at runtime, we will either use `q` or `zip`. We
    also made `country` optional and only append it to the query if it exists.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将 `city` 参数重命名为 `search`，因为它可以是城市名称或邮政编码。然后我们允许其类型为 `string` 或 `number`，并且根据运行时类型，我们将使用
    `q` 或 `zip`。我们还使 `country` 可选，并且仅在它存在时将其附加到查询中。
- en: '`getCurrentWeather` now has business logic embedded into it and is thus a good
    target for unit testing. Following the single responsibility principle from the
    SOLID principles, we will refactor the HTTP call to its own function, `getCurrentWeatherHelper`.'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getCurrentWeather` 现在已经嵌入业务逻辑，因此是单元测试的良好目标。遵循 SOLID 原则中的单一职责原则，我们将重构 HTTP
    调用到其自己的函数 `getCurrentWeatherHelper`。'
- en: 'If you’re unfamiliar with SOLID principles, I cover them in the Agile engineering
    best practices section of *Chapter 3, Architecting an Enterprise App*. If you
    want to read more about it now, see the Wikipedia entry here: [https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID).'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你对 SOLID 原则不熟悉，我在第 3 章“构建企业应用”的敏捷工程最佳实践部分进行了介绍。如果你想现在了解更多关于它的信息，请参阅维基百科条目：[https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID)。
- en: Refactor the HTTP call into `getCurrentWeatherHelper`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 HTTP 调用重构为 `getCurrentWeatherHelper`。
- en: 'In the next sample, note the use of a backtick character, `` ` ``, instead
    of a single-quote character, `''`, which leverages the template literals’ functionality
    that allows embedded expressions in JavaScript:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一个示例中，请注意使用反引号字符 `` ` `` 而不是单引号字符 `'`，这利用了模板字面量的功能，允许在 JavaScript 中嵌入表达式：
- en: '[PRE11]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As a positive side effect, `getCurrentWeatherHelper` adheres to the open/closed
    principle from SOLID. After all, it is open to extension by our ability to change
    the function’s behavior by supplying different `uriParams` and is closed to modification
    because it won’t have to be changed frequently.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为积极的副作用，`getCurrentWeatherHelper` 遵循 SOLID 的开闭原则。毕竟，它可以通过提供不同的 `uriParams`
    来扩展函数的行为，并且由于它不需要经常更改，因此它是封闭的。
- en: To demonstrate the latter point, let’s implement a new function to get the current
    weather by latitude and longitude.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们实现一个新的函数来通过纬度和经度获取当前天气。
- en: 'Implement `getCurrentWeatherByCoords`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `getCurrentWeatherByCoords`：
- en: '[PRE12]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the functionality of `getCurrentWeatherHelper` is extensible
    without modifying its code.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，`getCurrentWeatherHelper` 的功能是可扩展的，而无需修改其代码。
- en: 'Ensure that you update `IWeatherService` with the changes made earlier:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您更新 `IWeatherService` 以包含之前所做的更改：
- en: '[PRE13]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As a result of adhering to the SOLID design principles, we make it easier to
    robustly unit test flow-control logic and ultimately write code that is more resilient
    to bugs and cheaper to maintain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于遵循 SOLID 设计原则，我们使得对流程控制逻辑进行健壮的单元测试更加容易，并最终编写出对错误更具有弹性和更易于维护的代码。
- en: Implementing a search
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现搜索
- en: 'Now, let’s connect the new service method to the input field:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将新的服务方法连接到输入字段：
- en: 'Update `citySearch` to inject `weatherService` and subscribe to input changes:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `citySearch` 更新为注入 `weatherService` 并订阅输入变化：
- en: '[PRE14]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are treating all input as `string` at this point. The user input can be a
    city and zip code, city and country code, or a zip code and country code, separated
    by a comma. While a city or zip code is required, a country code is optional.
    We can use the `String.split` function to parse any potential comma-separated
    input and then trim any whitespace out from the beginning and the end of the string
    with `String.trim`. We then ensure that we trim all parts of the string by iterating
    over them with `Array.map`.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前我们正在将所有输入视为 `string`。用户输入可以是城市和邮编、城市和国家代码，或者邮编和国家代码，由逗号分隔。虽然城市或邮编是必需的，但国家代码是可选的。我们可以使用
    `String.split` 函数来解析任何潜在的逗号分隔输入，然后使用 `String.trim` 从字符串的开始和结束处去除任何空白。然后我们通过迭代它们确保我们修剪字符串的所有部分。
- en: We then deal with the optional parameter with the ternary operator `?:`, only
    passing in a value if it exists, otherwise leaving it undefined.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们然后使用三元运算符 `?:` 处理可选参数，只有当它存在时才传递值，否则将其留为未定义。
- en: 'Implement the search handler:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现搜索处理程序：
- en: '[PRE15]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add a hint for the user under the input field, informing them about the optional
    country functionality:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入字段下方为用户添加提示，告知他们关于可选的国家功能：
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At this point, the subscribe handler will call the server and log its output
    to the console.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，订阅处理程序将调用服务器并将输出记录到控制台。
- en: Observe how this works using Chrome DevTools. Note how often the `search` function
    is run and that we are not handling service errors.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Chrome DevTools 观察这个工作原理。注意 `search` 函数运行的频率，并且我们没有处理服务错误。
- en: Limiting user inputs with throttle/debounce
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用节流/防抖限制用户输入
- en: We currently submit a request to the server with every keystroke. This is not
    desirable behavior because it can lead to a bad user experience and drain battery
    life, resulting in wasted network requests and performance issues both on the
    client and server side. Users make typos; they can change their minds about what
    they are inputting, and rarely do the first few characters of information input
    result in useful results.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前在每个按键敲击时都会向服务器提交一个请求。这不是理想的行为，因为它可能导致糟糕的用户体验和电池寿命消耗，从而在客户端和服务器端都造成网络请求浪费和性能问题。用户会犯拼写错误；他们可能会改变他们输入的内容，而且信息输入的前几个字符很少能产生有用的结果。
- en: We can still listen to every keystroke, but we don’t have to react to every
    stroke. By leveraging `throttle`/`debounce`, we can limit the number of events
    generated to a predetermined interval and maintain the type-as-you-search functionality.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以监听每个按键敲击，但不必对每个敲击做出反应。通过利用 `throttle`/`debounce`，我们可以限制生成的事件数量到一个预定的间隔，并保持按搜索功能。
- en: Note that `throttle` and `debounce` are not functional equivalents, and their
    behavior will differ from framework to framework. In addition to throttling, we
    expect to capture the last input that the user has typed. In the `lodash` framework,
    the `throttle` function fulfills this requirement, whereas, in `RxJS`, `debounce`
    fulfills it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`throttle` 和 `debounce` 并不是功能等效的，它们的行为会因框架而异。除了节流之外，我们还期望捕获用户最后输入的内容。在 `lodash`
    框架中，`throttle` 函数满足这一要求，而在 `RxJS` 中，`debounce` 函数满足这一要求。
- en: 'It is easy to inject throttling into the observable stream using `RxJS/debounceTime`.
    Implement `debounceTime` with `pipe`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `RxJS/debounceTime` 很容易将节流注入到可观察流中。使用 `pipe` 实现 `debounceTime`：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`debounceTime` will, at a maximum, run a search every second, but also run
    another search after the user has stopped typing. In comparison, `RxJS/throttleTime`
    will only run a search every second, on the second, and will not necessarily capture
    the last few characters the user may have input.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`debounceTime` 最多每秒运行一次搜索，但用户停止输入后也会运行另一个搜索。相比之下，`RxJS/throttleTime` 只会在每秒的第二次运行搜索，并且不一定捕获用户可能输入的最后几个字符。'
- en: RxJS also has the `throttle` and `debounce` functions, which you can use to
    implement custom logic to limit input that is not necessarily time-based.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 还提供了 `throttle` 和 `debounce` 函数，你可以使用这些函数来实现自定义逻辑，以限制非基于时间的输入。
- en: Since this is a time- and event-driven functionality, breakpoint debugging is
    not feasible. You may monitor the network calls within the **Chrome Dev Tools
    | Network** tab, but to get a more real-time feel for how often your search handler
    is being invoked, add a `console.log` statement.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个基于时间和事件的函数，断点调试不可行。你可以在 **Chrome Dev Tools | Network** 选项卡中监控网络调用，但要更实时地了解你的搜索处理程序被调用的频率，可以添加一个
    `console.log` 语句。
- en: It is not a good practice to check in code with active `console.log` statements.
    These debug statements make it difficult to read the actual code, which creates
    a high cost of maintainability. Even if debug statements are commented out, do
    not check them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中检查时，不要使用带有活动 `console.log` 语句。这些调试语句使得实际代码难以阅读，从而增加了维护成本。即使调试语句被注释掉了，也不要检查它们。
- en: Input validation and error messages
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入验证和错误消息
- en: '`FormControl` is highly customizable. It allows you to set a default initial
    value, add validators, or listen to changes on `blur`, `change`, and `submit`
    events, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormControl` 非常可定制。它允许你设置默认的初始值，添加验证器，或者监听 `blur`、`change` 和 `submit` 事件，如下所示：'
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We won’t be initializing `FormControl` with a value, but we need to implement
    a validator to disallow single-character inputs:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会用值初始化 `FormControl`，但我们需要实现一个验证器来禁止单字符输入：
- en: 'Import `Validators` from `@angular/forms`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `@angular/forms` 中导入 `Validators`：
- en: '[PRE19]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Modify `FormControl` to add a minimum length validator:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `FormControl` 以添加最小长度验证器：
- en: '[PRE20]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Modify the template to show a validation error message below the hint text:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改模板以在提示文本下方显示验证错误消息：
- en: '[PRE21]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note the addition of some extra margin to make room for lengthy error messages.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意添加了一些额外的边距，以便为长错误消息腾出空间。
- en: 'If you are handling different kinds of errors, the `hasError` syntax in the
    template can get repetitive. You may want to implement a more scalable solution
    that can be customized through code, as shown:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正在处理不同类型的错误，模板中的 `hasError` 语法可能会变得重复。你可能想实现一个更可扩展的解决方案，可以通过代码进行定制，如下所示：
- en: '[PRE22]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Modify the `search` function to not execute a search with invalid input, replacing
    the condition in the existing `if` statement:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `search` 函数，使其在输入无效时不执行搜索，替换现有 `if` 语句中的条件：
- en: '[PRE23]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Instead of doing a simple check to see whether `searchValue` is defined and
    not an empty string, we can tap into the validation engine for a more robust check
    by calling `this.search.invalid`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用 `this.search.invalid` 来利用验证引擎进行更健壮的检查，而不是简单地检查 `searchValue` 是否已定义且不是空字符串。
- en: For now, we’re done with implementing `search` functionality. Next, let’s go
    over a what-if scenario to see how a template-driven form implementation would
    appear.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经完成了 `search` 功能的实现。接下来，让我们探讨一个假设场景，看看模板驱动的表单实现会是什么样子。
- en: Template-driven forms with two-way binding
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有双向绑定的模板驱动表单
- en: The alternative to reactive forms is template-driven forms. If you’re familiar
    with `ng-model` from AngularJS, you’ll find that the new `ngModel` directive is
    an API-compatible replacement for it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与响应式表单相比，另一种选择是模板驱动表单。如果你熟悉 AngularJS 中的 `ng-model`，你会发现新的 `ngModel` 指令是与它兼容的
    API 替代品。
- en: Behind the scenes, `ngModel` implements `FormControl` that automatically attaches
    itself to `FormGroup`. `ngModel` can be used at the `<form>` level or the individual
    `<input>` level. You can read more about `ngModel` at [https://angular.dev/api/forms/NgModel](https://angular.dev/api/forms/NgModel).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`ngModel`实现了`FormControl`，它会自动附加到`FormGroup`。`ngModel`可以在`<form>`级别或单个`<input>`级别使用。你可以在[https://angular.dev/api/forms/NgModel](https://angular.dev/api/forms/NgModel)了解更多关于`ngModel`的信息。
- en: 'In the `stage6` example code of the LocalCast Weather app repository on GitHub,
    I have included a template-driven component in `app.component.ts` named `<app-city-search-tpldriven>`
    rendered under `<div class="example">`. You can experiment with this component
    to see what the alternate template implementation looks like:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub上LocalCast Weather应用程序仓库的`stage6`示例代码中，我已在`app.component.ts`中包含了一个名为`<app-city-search-tpldriven>`的模板驱动组件，它被渲染在`<div
    class="example">`下。你可以尝试这个组件，看看替代的模板实现是什么样的：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note the `[()]` “box of bananas” two-way binding syntax in use with `ngModel`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`ngModel`时使用的`[()]`“香蕉箱”双向绑定语法。
- en: 'The differences in the components are implemented as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 组件之间的差异是这样实现的：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, most of the logic is implemented in the template; as such, you
    are required to maintain an active mental model of the template and the controller.
    Any changes to event handlers and validation logic require you to switch back
    and forth between the two files.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，大部分逻辑都是在模板中实现的；因此，你需要保持对模板和控制器的一个活跃的心理模型。任何对事件处理程序和验证逻辑的更改都需要你在两个文件之间来回切换。
- en: Furthermore, we have lost input limiting and the ability to prevent service
    calls when the input is invalid. It is still possible to implement these features,
    but they require convoluted solutions and do not neatly fit into the new Angular
    syntax and concepts.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们失去了输入限制和防止在输入无效时调用服务的能力。虽然仍然可以实施这些功能，但它们需要复杂的解决方案，并且无法很好地适应新的Angular语法和概念。
- en: Overall, I do not recommend the use of template-driven forms. There may be a
    few instances where it may be very convenient to use the box-of-bananas syntax.
    However, this sets a bad precedent for other team members to replicate the same
    pattern around the application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我不推荐使用模板驱动的表单。可能有一些情况下使用“香蕉箱”语法非常方便。然而，这为其他团队成员复制相同的模式在应用程序中设定了一个不好的先例。
- en: Component interaction with BehaviorSubject
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BehaviorSubject与组件进行交互
- en: 'To update the current weather information, we need the `citySearch` component
    to interact with the `currentWeather` component. There are four main techniques
    to enable component interaction in Angular:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新当前的天气信息，我们需要`citySearch`组件与`currentWeather`组件进行交互。在Angular中，有四种主要的技术来实现组件间的交互：
- en: Global events
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局事件
- en: Parent components listening for information bubbling up from children components
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父组件监听从子组件冒泡上来的信息
- en: Sibling, parent, or children components within a module that works off of similar
    data streams
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个基于相似数据流的模块中，兄弟、父或子组件
- en: Parent components passing information to children components
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父组件向子组件传递信息
- en: Let’s explore them in detail in the following sections.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的章节中详细探讨它们。
- en: Global events
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局事件
- en: This technique has been leveraged since the early days of programming in general.
    In JavaScript, you may have achieved this with global function delegates or jQuery’s
    event system. In AngularJS, you may have created a service and stored variables
    within it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在编程的早期就已经被利用了。在JavaScript中，你可能通过全局函数代理或jQuery的事件系统实现了这一点。在AngularJS中，你可能创建了一个服务并在其中存储变量。
- en: In Angular, you can still create a root-level service, store values in it, use
    Angular’s `EventEmitter` class, which is meant for directives, or use `RxJS/Subscription`
    to create a fancy messaging bus for yourself.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，你仍然可以创建根级别的服务，在其中存储值，使用Angular的`EventEmitter`类（它旨在用于指令），或者使用`RxJS/Subscription`为自己创建一个花哨的消息总线。
- en: As a pattern, global events are open to rampant abuse, and rather than helping
    to maintain a decoupled application architecture, they lead to a global state
    over time. A global state or a localized state at the controller level, where
    functions read and write to variables in any given class, is enemy number one
    of writing maintainable and unit-testable software.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种模式，全局事件容易受到滥用，并且它们不仅不能帮助维护解耦的应用架构，反而随着时间的推移导致全局状态。全局状态或控制器级别的本地状态，其中函数在任意给定的类中读写变量，是编写可维护和可单元测试的软件的头号敌人。
- en: Ultimately, if you’re storing all your application data or routing all events
    in one service to enable component interaction, you’re merely inventing a better
    mousetrap. A single service will grow large and complex over time. This leads
    to unforeseen bugs, side effects from unintentional mutations of unrelated data,
    continuously increasing memory usage because data from previous views can’t be
    discarded, and low cohesion due to data stored from unrelated components of the
    application. Overusing a service is an anti-pattern that should be avoided at
    all costs. In a later section, you will find that, essentially, we will still
    be using services to enable component interaction; however, I want to point out
    that there’s a fine line that exists between a flexible architecture that enables
    decoupling and the global or centralized decoupling approach that does not scale
    well.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，如果您在一个服务中存储所有应用程序数据或路由所有事件以启用组件交互，那么您只是在发明一个更好的捕鼠器。随着时间的推移，单个服务会变得庞大而复杂。这会导致不可预见的错误、由于无意中修改了无关数据而产生的副作用、由于先前视图中的数据无法丢弃而持续增加的内存使用，以及由于存储了应用程序中无关组件的数据而导致的低内聚。过度使用服务是一种应该不惜一切代价避免的反模式。在后面的章节中，您会发现，本质上，我们仍然会使用服务来启用组件交互；然而，我想指出，在允许解耦的灵活架构和全球或集中式解耦方法之间存在着一条细线，后者扩展性不佳。
- en: Child-parent relationships with event emitters
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件发射器的子父关系
- en: Your child component should be completely unaware of its parent. This is key
    to creating reusable components.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您的子组件应该完全不知道其父组件。这是创建可重用组件的关键。
- en: We can implement the communication between `CitySearchComponent` and the `CurrentWeatherComponent`,
    leveraging `AppComponent` as a parent element and letting the `AppComponent` controller
    orchestrate the data.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用`AppComponent`作为父元素，让`AppComponent`控制器协调数据来实现`CitySearchComponent`和`CurrentWeatherComponent`之间的通信。
- en: '*Commit your code now!* In the next two sections, you will be making code changes
    that you will need to discard.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*立即提交您的代码!* 在接下来的两节中，您将进行代码更改，这些更改您将需要丢弃。'
- en: 'Let’s see how this implementation will look:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个实现将如何呈现：
- en: '`CitySearchComponent` exposes `EventEmitter` through an `@Output` property:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CitySearchComponent`通过一个`@Output`属性暴露`EventEmitter`：'
- en: '[PRE26]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`AppComponent` consumes that and calls `weatherService`, setting the `currentWeather`
    variable:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AppComponent`消费这些数据并调用`weatherService`，设置`currentWeather`变量：'
- en: '[PRE27]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we are binding to `searchEvent` with the parenthesis syntax. The `$event`
    variable automatically captures the output from the event and passes it into the
    `doSearch` method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用括号语法绑定到`searchEvent`。`$event`变量自动捕获事件输出并将其传递到`doSearch`方法。
- en: We successfully bubbled the information up to the parent component, but we must
    also be able to pass it down to `CurrentWeatherComponent`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地将信息冒泡到父组件，但我们也必须能够将其传递到`CurrentWeatherComponent`。
- en: Parent-child relationships with input binding
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用输入绑定的父子关系
- en: 'By definition, the parent component will know what child components it is working
    with. Since the `currentWeather` property is bound to the `current` property on
    `CurrentWeatherComponent`, the results are passed down for display. This is achieved
    by creating an `@Input` property:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，父组件将知道它正在与哪些子组件一起工作。由于`currentWeather`属性绑定到`CurrentWeatherComponent`上的`current`属性，结果会向下传递以供显示。这是通过创建一个`@Input`属性来实现的：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that the `ngOnInit` function of `CurrentWeatherComponent` is now superfluous
    and can be removed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`CurrentWeatherComponent`的`ngOnInit`函数现在已不再必要，可以删除。
- en: 'You can then update `AppComponent` to bind the data to the current weather:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以更新`AppComponent`以将数据绑定到当前天气：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At this point, your code should work! Try searching for a city. If `CurrentWeatherComponent`
    updates, then success!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的代码应该可以正常工作！尝试搜索一个城市。如果`CurrentWeatherComponent`更新，那么就成功了！
- en: 'The event emitter to input binding approach is appropriate in cases where you
    are creating well-coupled components or user controls, and the child is not consuming
    any external data. A good demonstrator for this might be by adding forecast information
    to `CurrentWeatherComponent` as shown:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发射器到输入绑定的方法适用于您正在创建紧密耦合的组件或用户控件，并且子组件没有消费任何外部数据的情况。一个很好的示例可能是向`CurrentWeatherComponent`添加预测信息，如下所示：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B20960_02_05.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述的图片，自动生成](img/B20960_02_05.png)'
- en: 'Figure 2.5: Weather forecast wireframe'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：天气预报线框图
- en: 'Each day of the week can be implemented as a component that is repeated using
    `@for`, and it will be perfectly reasonable for `CurrentWeatherComponent` to retrieve
    and bind this information to its child component:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 每周每一天都可以实现为一个使用`@for`重复的组件，并且对于`CurrentWeatherComponent`来说，检索并将此信息绑定到其子组件是完全合理的：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In general, if you’re working with data-driven components, the parent-child
    or child-parent communication pattern results in an inflexible architecture, making
    it difficult to reuse or rearrange your components. A good example of tight coupling
    is when we imported `WeatherService` in `app.component.ts`. Note that `AppComponent`
    should have no idea about `WeatherService`; its only job is to lay out several
    components. Given ever-changing business requirements and design, this is an important
    lesson to remember.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你正在处理数据驱动的组件，父-子或子-父通信模式会导致一个不灵活的架构，这使得重用或重新排列你的组件变得困难。一个紧密耦合的好例子是我们将`WeatherService`导入到`app.component.ts`中。请注意，`AppComponent`不应该知道`WeatherService`；它的唯一任务是布局几个组件。鉴于不断变化的企业需求和设计，这是一个需要记住的重要教训。
- en: '*Discard changes from the two sections* before moving on. We will instead be
    implementing an alternate solution.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，*丢弃两个部分的更改*。我们将实现一个替代解决方案。
- en: Next, we cover a better way for two components to interact with each other without
    introducing additional coupling with subjects.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一种更好的方法，让两个组件在不引入与`subject`额外耦合的情况下相互交互。
- en: Sibling interactions with subjects
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与`subject`的兄弟交互
- en: The main reason for components to interact is to send or receive updates to
    data either provided by the user or received from the server. In Angular, your
    services expose `RxJS/Observable` endpoints, which are data streams that your
    components can subscribe to. `RxJS/Observer` complements `RxJS/Observable` as
    a consumer of events emitted by `Observable`. `RxJS/Subject` brings the two functionalities
    together in an easy-to-work-with package.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 组件交互的主要原因是为了发送或接收由用户提供或从服务器接收的数据更新。在Angular中，你的服务暴露`RxJS/Observable`端点，这些是组件可以订阅的数据流。`RxJS/Observer`作为`RxJS/Observable`事件的消费者，补充了`RxJS/Observable`。`RxJS/Subject`将这两种功能结合在一个易于使用的包中。
- en: 'You can essentially describe a stream that belongs to a particular set of data,
    such as the current weather data that is being displayed, with subjects:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用`subject`来本质上描述属于特定数据集的流，例如正在显示的当前天气数据：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`currentWeather$` is still a data stream and does not simply represent one
    data point. You can subscribe to changes to `currentWeather$` data using `subscribe`,
    or you can publish changes to it using `next` as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentWeather$`仍然是一个数据流，并不简单地代表一个数据点。你可以使用`subscribe`来订阅`currentWeather$`数据的变化，或者你可以使用`next`来发布对其的变化，如下所示：'
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note the naming convention for the `currentWeather$` property, which is postfixed
    with `$`. This is the naming convention for observable properties.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`currentWeather$`属性的命名约定，它以`$`结尾。这是可观察属性的命名约定。
- en: The default behavior of `Subject` is very much like generic pub/sub mechanisms,
    such as jQuery events. However, in an asynchronous world where components are
    loaded or unloaded in unpredictable ways, using the default `Subject` is not very
    useful.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject`的默认行为非常类似于通用的发布/订阅机制，例如jQuery事件。然而，在一个异步世界中，组件以不可预测的方式加载或卸载，使用默认的`Subject`并不是非常有用。'
- en: 'There are three advanced variants of subjects:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 存在三种高级的`subject`变体：
- en: '`ReplaySubject` remembers and caches data points that occurred within the data
    stream so that a subscriber can replay old events at any given time.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplaySubject`会记住并缓存数据流中发生的数据点，以便订阅者可以在任何给定时间回放旧事件。'
- en: '`BehaviorSubject` remembers only the last data point while listening for new
    data points.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BehaviorSubject`在监听新数据点时只记住最后一个数据点。'
- en: '`AsyncSubject` is for one-time-only events that are not expected to reoccur.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncSubject`用于一次性事件，这些事件预计不会再次发生。'
- en: '`ReplaySubject` can have severe memory and performance implications on your
    application, so it should be used carefully. In the case of `CurrentWeatherComponent`,
    we are only interested in displaying the latest weather data received, but through
    user input or other events, we are open to receiving new data to keep `CurrentWeatherComponent`
    up to date. `BehaviorSubject` would be the appropriate mechanism to meet these
    needs:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplaySubject` 可能会对你的应用程序的内存和性能产生严重影响，因此应谨慎使用。在 `CurrentWeatherComponent`
    的情况下，我们只对显示接收到的最新天气数据感兴趣，但通过用户输入或其他事件，我们愿意接收新数据以保持 `CurrentWeatherComponent` 的更新。`BehaviorSubject`
    将是满足这些需求适当的机制：'
- en: 'Add `currentWeather$` as a read-only property to `IWeatherService`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `currentWeather$` 作为只读属性添加到 `IWeatherService`：
- en: '[PRE33]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`currentWeather$` is declared as read-only because its `BehaviorSubject` should
    not be reassigned. It’s our data anchor or a reference, not a copy of the data
    itself. Any updates to the value should be sent by calling the `next` function
    on the property.'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`currentWeather$` 被声明为只读，因为其 `BehaviorSubject` 不应重新分配。它是我们的数据锚点或引用，而不是数据本身的副本。任何对值的更新都应该通过在属性上调用
    `next` 函数来发送。'
- en: 'Define `BehaviorSubject` in `WeatherService` and set a default value:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WeatherService` 中定义 `BehaviorSubject` 并设置默认值：
- en: '[PRE34]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add a new function named `updateCurrentWeather`, which will trigger `getCurrentWeather`
    and update the value of `currentWeather$`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `updateCurrentWeather` 的新函数，该函数将触发 `getCurrentWeather` 并更新 `currentWeather$`
    的值：
- en: '[PRE35]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Update `IWeatherService` with the new function so that it appears as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新函数更新 `IWeatherService` 以使其如下所示：
- en: '[PRE36]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Update `CurrentWeatherComponent` to subscribe to the new `BehaviorSubject`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `CurrentWeatherComponent` 以订阅新的 `BehaviorSubject`：
- en: '[PRE37]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `CitySearchComponent`, update the `getCurrentWeather` function call to utilize
    the new `updateCurrentWeather` function:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CitySearchComponent` 中，更新 `getCurrentWeather` 函数调用以利用新的 `updateCurrentWeather`
    函数：
- en: '[PRE38]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Test your app in the browser; it should appear as follows:![A screenshot of
    a weather forecast  Description automatically generated with medium confidence](img/B20960_02_06.png)
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中测试你的应用程序；它应该如下所示：![天气预报屏幕截图  描述由中等置信度自动生成](img/B20960_02_06.png)
- en: 'Figure 2.6: Weather information for Bursa, Turkey'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.6：土耳其布尔萨的天气信息
- en: 'When you type in a new city, the component should update to include the current
    weather information for that city. We can move the **Add city search capability...**
    task to the **Done** column, as shown on our Kanban board:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入一个新城市时，组件应该更新以包含该城市的当前天气信息。我们可以将 **添加城市搜索功能...** 任务移动到 **完成** 列，如图所示在我们的看板板上：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_02_07.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由中等置信度自动生成](img/B20960_02_07.png)'
- en: 'Figure 2.7: GitHub project Kanban board status'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：GitHub项目看板板状态
- en: We have a functional app. However, we have introduced a memory leak in the way
    we handled the subscription to `currentWeather$`. In the next section, we’ll review
    how memory leaks can happen and avoid them altogether by using `first` and `takeUntilDestroyed`
    operations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个功能齐全的应用程序。然而，我们在处理 `currentWeather$` 订阅的方式中引入了内存泄漏。在下一节中，我们将回顾内存泄漏是如何发生的，以及如何通过使用
    `first` 和 `takeUntilDestroyed` 操作来完全避免它们。
- en: Managing subscriptions
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理订阅
- en: Subscriptions are a convenient way to read a value from a data stream for your
    application logic. If unmanaged, they can create memory leaks in your application.
    A leaky application will consume ever-increasing amounts of RAM, eventually leading
    the browser tab to become unresponsive, leading to a negative perception of your
    app and, even worse, potential data loss, which can frustrate end users.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅是读取数据流中值以供应用程序逻辑使用的一种便捷方式。如果未管理，它们可以在你的应用程序中创建内存泄漏。一个泄漏的应用程序将消耗越来越多的RAM，最终导致浏览器标签页无响应，导致对你的应用产生负面印象，甚至更糟的是，可能的数据丢失，这可能会让最终用户感到沮丧。
- en: The source of a memory leak may not be obvious. In `CurrentWeatherComponent`,
    we inject `WeatherSevice` to access the value of `BehaviorSubject`, `currentWeather$`.
    If we mismanage subscriptions,`currentWeather$`, we can end up with leaks in the
    component or the service.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏的源头可能不明显。在 `CurrentWeatherComponent` 中，我们注入 `WeatherSevice` 以访问 `BehaviorSubject`
    的 `currentWeather$` 值。如果我们管理不当 `currentWeather$` 订阅，我们可能会在组件或服务中产生泄漏。
- en: Lifecycle of services
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务的生命周期
- en: 'By default, Angular services are **shared instance services** or singletons
    automatically registered to a **root provider**. This means that, once created
    in memory, they’re kept alive as long as the app or feature module they’re a part
    of remains in memory. See the following example of a shared instance service:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular服务是自动注册到**根提供者**的**共享实例服务**或单例。这意味着一旦在内存中创建，只要它们所属的应用程序或功能模块仍然在内存中，它们就会被保留。请参见以下共享实例服务的示例：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: From a practical perspective, this will mean that most services in your application
    will live in the memory for the application’s lifetime. However, the lifetime
    of a component may be much shorter, or there could be multiple instances of the
    same component created repeatedly.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际的角度来看，这意味着你应用程序中的大多数服务将存在于应用程序的生命周期内。然而，组件的生命周期可能要短得多，或者可能会有多个相同组件的实例被反复创建。
- en: 'Additionally, there are use cases where a component needs its own instance
    or a copy of the service (e.g., caching values input into a form or displaying
    weather for different cities simultaneously). To create **multiple instance services,**
    see the example below:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些用例需要组件自己的实例或服务的副本（例如，缓存表单输入的值或同时显示不同城市的天气）。要创建**多个实例服务**，请参见下面的示例：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You would then provide the service with a **component provider**:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将为该服务提供一个**组件提供者**：
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this case, the service would be destroyed when the component is destroyed.
    But this is not protection against memory leaks. If we don’t manage the interactions
    between long-lived and short-lived objects carefully, we can end up with dangling
    references between objects, leading to memory leaks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当组件被销毁时，服务也会被销毁。但这并不是防止内存泄漏的保护措施。如果我们没有仔细管理长生命期和短生命期对象之间的交互，我们可能会在对象之间留下悬挂引用，从而导致内存泄漏。
- en: Exposé of a memory leak
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存泄漏的揭露
- en: When we subscribe to `currentWeather$`, we attach an event handler to it so
    that `CurrentWeatherComponent` can react to value changes pushed to `BehaviorSubject`.
    This presents a problem when the component needs to be destroyed.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们订阅`currentWeather$`时，我们将其附加到一个事件处理器上，以便`CurrentWeatherComponent`可以响应推送到`BehaviorSubject`的值变化。当组件需要被销毁时，这会带来问题。
- en: In managed languages such as JavaScript, memory is managed by the garbage collector,
    or GC for short, as opposed to having to allocate and deallocate memory by hand
    in unmanaged languages such as C or C++. At a very high level, the GC periodically
    scans the stack for objects not referenced by other objects.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在像JavaScript这样的管理语言中，内存由垃圾回收器（GC）管理，而不是像在C或C++这样的非管理语言中那样手动分配和释放内存。在非常高的层面上，GC定期扫描堆栈中其他对象未引用的对象。
- en: If an object is found to be dereferenced, then the space it takes up in the
    stack can be freed up. However, if an unused object still has a reference to another
    object that is still in use, it can’t be garbage collected. The GC is not magical
    and can’t read our minds. When an object is unused and can’t be deallocated, the
    memory taken up by the object can never be used for another purpose so long as
    your application is running. This is considered a memory leak.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现某个对象被取消引用，那么它占用的堆栈空间可以被释放。然而，如果一个未使用的对象仍然引用另一个仍在使用的对象，它就不能被垃圾回收。GC不是魔法，不能读我们的心思。当一个对象未使用且无法被解除分配时，只要你的应用程序在运行，该对象占用的内存就永远不能用于其他目的。这被认为是内存泄漏。
- en: 'My colleague, Brendon Caulkins, provides a helpful analogy:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我的同事Brendon Caulkins提供了一个有用的类比：
- en: Imagine the memory space of the browser as a parking lot; every time we assign
    a value or create a subscription, we park a car in that lot. If we happen to abandon
    a car, we still leave the parking spot occupied; no one else can use it. If all
    the applications in the browser do this, or we do it repeatedly, you can imagine
    how quickly the parking lot gets full, and we never get to run our application.
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 想象浏览器的内存空间就像一个停车场；每次我们分配一个值或创建一个订阅时，我们就在这个停车场停车。如果我们不小心丢弃了一辆车，我们仍然会留下停车位被占用；其他人无法使用它。如果浏览器中的所有应用程序都这样做，或者我们反复这样做，你可以想象停车场会很快填满，我们永远无法运行我们的应用程序。
- en: Next, let’s see how we can ensure we don’t abandon our car in the parking lot.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何确保我们不把车留在停车场里。
- en: Unsubscribing from a subscription
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消订阅
- en: Subscriptions or event handlers create references to other objects, such as
    from a short-lived component to a long-lived service. Granted, in our case, `CurrentWeatherComponent`
    is also a singleton, but that could change if we added more features to the app,
    navigating from page to page or displaying weather from multiple cities at once.
    If we don’t unsubscribe from `currentWeather$`, then any instance of `CurrentWeatherComponent`
    would be stuck in memory. We subscribe in `ngOnInit`, so we must unsubscribe in
    `ngOnDestroy`. `ngOnDestroy` is called when Angular determines that the framework
    no longer uses the component.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅或事件处理器会创建对其他对象的引用，例如从短生命周期的组件到长生命周期的服务。诚然，在我们的情况下，`CurrentWeatherComponent`也是一个单例，但如果我们向应用程序添加更多功能，在页面之间导航或同时显示多个城市的天气，这可能会改变。如果我们不取消`currentWeather$`的订阅，那么`CurrentWeatherComponent`的任何实例都会卡在内存中。我们在`ngOnInit`中订阅，所以我们必须在`ngOnDestroy`中取消订阅。`ngOnDestroy`是在Angular确定框架不再使用组件时被调用的。
- en: 'Let’s see an example of how you can unsubscribe from a subscription in the
    sample code in the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例代码中如何取消订阅订阅的例子：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we need to implement the `OnDestroy` interface for the component. Then,
    we update `ngOnInit` to store a reference to the subscription in a property named
    `currentWeatherSubscription`. Finally, in `ngOnDestroy`, we can call the `unsubscribe`
    method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为组件实现`OnDestroy`接口。然后，我们将`ngOnInit`更新为将订阅存储在名为`currentWeatherSubscription`的属性中。最后，在`ngOnDestroy`中，我们可以调用`unsubscribe`方法。
- en: Should our component get destroyed, it will no longer result in a memory leak.
    However, if we have multiple subscriptions in a component, this leads to tedious
    amounts of coding.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的组件被销毁，它将不再导致内存泄漏。然而，如果我们在一个组件中有多个订阅，这会导致大量的繁琐编码。
- en: Note that in `CitySearchComponent`, we subscribe to the `valueChanges` event
    of a `FormControl` object. We don’t need to manage the subscription to this event
    because `FormControl` is a child object of our component. When the parent component
    is dereferenced from all objects, all its children can be safely collected by
    the GC.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`CitySearchComponent`中，我们订阅了`FormControl`对象的`valueChanges`事件。我们不需要管理此事件的订阅，因为`FormControl`是我们组件的子对象。当父组件从所有对象中取消引用时，所有其子对象都可以安全地被GC收集。
- en: Subscribing to values in data streams itself can be considered an anti-pattern
    because you switch your programming model from reactive to imperative. But of
    course, we must subscribe at least once to activate the data stream. In the next
    section, we will cover how you ensure you don’t leak memory when subscribing.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅数据流中的值本身可以被认为是一种反模式，因为您将编程模型从响应式切换到命令式。但当然，我们必须至少订阅一次以激活数据流。在下一节中，我们将介绍如何确保在订阅时不会泄漏内存。
- en: Subscribe with first or takeUntilDestroyed
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用first或takeUntilDestroyed进行订阅
- en: By default, an observable stream doesn’t end. Given how engrained RxJS is within
    every Angular operation, this is rarely the desired outcome. There are two common
    strategies that we can apply at the time of subscribing to a resource so we can
    ensure that streams will complete predictably and won’t lead to memory leaks.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，可观察流不会结束。鉴于RxJS在每次Angular操作中都根深蒂固，这很少是期望的结果。在订阅资源时，我们可以应用两种常见的策略，以确保流可以可预测地完成，并且不会导致内存泄漏。
- en: 'The first strategy is, well, the first method. Observe the `updateCurrentWeather`
    method in `WeatherService`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种策略，嗯，就是第一种方法。观察`WeatherService`中的`updateCurrentWeather`方法：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the example above, we intend to get the current weather and display it –
    and do this only once per request. By piping in a `first()` call into the observable
    stream, we instruct RxJS to complete the stream after it receives one result.
    This way, when a resource that utilizes this stream is being GC’d, the relevant
    RxJS objects will not cause a leak.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们的目的是获取当前天气并将其显示出来——并且只在每个请求中这样做一次。通过将一个`first()`调用管道输入到可观察流中，我们指示RxJS在接收到一个结果后完成流。这样，当正在GC（垃圾回收）使用此流的资源时，相关的RxJS对象不会引起泄漏。
- en: 'The second strategy is `takeUntilDestroyed`. The `first()` strategy doesn’t
    make sense with components that will update multiple times, that will update multiple
    times. For example `CurrentWeatherComponent` can update after the user enters
    new search text, so we want to receive updates as long as the component exists.
    See the following example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种策略是`takeUntilDestroyed`。对于将更新多次的组件，`first()`策略没有意义。例如`CurrentWeatherComponent`可以在用户输入新的搜索文本后更新，因此我们希望在组件存在期间接收更新。请看以下示例：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`takeUntilDestroyed` can only be used within an injector context, i.e., a constructor.
    When using it in lifecycle hook calls, like `ngOnInit`, we must inject `DestroyRef`
    and pass it into the function. It automatically registers itself, so when the
    component is destroyed, it completes the stream. This way, the component can receive
    messages while it’s needed, but with no risk of leaking memory.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeUntilDestroyed`只能在注入器上下文中使用，即构造函数中。当在生命周期钩子调用（如`ngOnInit`）中使用它时，我们必须注入`DestroyRef`并将其传递到函数中。它会自动注册自己，因此当组件被销毁时，它会完成流。这样，组件可以在需要时接收消息，但没有任何内存泄漏的风险。'
- en: By applying these alongside the `subscribe` method, we don’t have to rely on
    difficult-to-trace unsubscribe methods, and we can easily verify their implementation
    with a quick search of the word subscribe.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用这些方法与`subscribe`方法一起，我们不必依赖于难以追踪的取消订阅方法，并且我们可以通过快速搜索单词`subscribe`来轻松验证它们的实现。
- en: The best part is no part at all. Next, let’s see how we can consume an observable
    component without subscribing to it all.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是完全没有。接下来，让我们看看我们如何在不订阅的情况下消费一个可观察组件。
- en: Coding in the reactive paradigm
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在响应式范式下编码
- en: As covered in *Chapter 1*, *Angular’s Architecture and Concepts*, we should
    only subscribe to an observable stream to activate it. If we treat a `subscribe`
    function as an event handler, we implement our code imperatively.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*第一章*，*Angular的架构和概念*中所述，我们应仅订阅可观察流以激活它。如果我们将`subscribe`函数视为事件处理器，我们就以命令式的方式实现我们的代码。
- en: Seeing anything other than an empty `subscribe()` call in your code base should
    be considered a red flag because it deviates from the reactive paradigm.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码库中看到除了空的`subscribe()`调用以外的任何内容都应该被视为一个红旗，因为它偏离了响应式范式。
- en: In reactive programming, when you subscribe to an event in a reactive stream,
    you shift your coding paradigm from reactive programming to imperative programming.
    There are two places in our application where we subscribe, one in `CurrentWeatherComponent`,
    and the other in `CitySearchComponent`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，当你在一个响应式流中订阅一个事件时，你将你的编码范式从响应式编程转换为命令式编程。在我们的应用程序中有两个地方我们进行了订阅，一个在`CurrentWeatherComponent`中，另一个在`CitySearchComponent`中。
- en: Let’s start by fixing `CurrentWeatherComponent` so we don’t mix paradigms.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修复`CurrentWeatherComponent`开始，这样我们就不会混淆范式。
- en: Binding to an observable with an async pipe
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异步管道绑定到可观察值
- en: Angular has been designed to be an asynchronous framework from the ground up.
    You can get the most out of Angular by staying in the reactive paradigm. It can
    feel unnatural to do so at first, but Angular provides all the tools you need
    to reflect the current state of your application to the user without having to
    shift to imperative programming.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始设计，Angular就被设计成一个异步框架。你可以通过保持响应式范式来充分利用Angular。一开始这样做可能会感觉不自然，但Angular提供了你需要的所有工具，让你无需切换到命令式编程就能将应用程序的当前状态反映给用户。
- en: 'You may leverage the `async` pipe in your templates to reflect the current
    value of an observable. Let’s update `CurrentWeatherComponent` to use the `async`
    pipe:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在模板中使用`async`管道来反映可观察值的当前值。让我们更新`CurrentWeatherComponent`以使用`async`管道：
- en: 'Start by replacing `current: ICurrentWeather` with an observable property:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，将`current: ICurrentWeather`替换为一个可观察属性：'
- en: '[PRE45]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the constructor, assign `weatherService.currentWeather$` to `current$:`
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，将`weatherService.currentWeather$`分配给`current$`：
- en: '[PRE46]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Remove all code related to `SubSink`, `ngOnInit`, and `ngOnDestroy`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有与`SubSink`、`ngOnInit`和`ngOnDestroy`相关的代码。
- en: 'Update the template to so you can bind to `current$`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新模板以便你可以绑定到`current$`：
- en: '[PRE47]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `async` pipe automatically subscribes to the current value of `current$`
    and makes it available to the template to be used imperatively as the `current`
    variable. The beauty of this approach is that the `async` pipe implicitly manages
    the subscription, so you don’t have to worry about unsubscribing.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`async`管道会自动订阅`current$`的当前值，并将其作为`current`变量提供给模板以进行命令式使用。这种方法的优点是`async`管道隐式地管理订阅，因此你不必担心取消订阅。'
- en: Remove the `@else { <div>no data</div> }` block, which is no longer needed because
    `BehaviorSubject` is always initialized.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除不再需要的`@else { <div>no data</div> }`块，因为`BehaviorSubject`总是初始化的。
- en: So far, the reactive paradigm has allowed us to streamline and clean up our
    code.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，响应式范式已经使我们能够简化并清理我们的代码。
- en: 'The async pipe allows you to display a loading message with simple `if-else`
    logic. To display a message while your observable is resolved, see the following
    technique:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 异步管道允许您使用简单的`if-else`逻辑显示加载消息。要显示在您的可观察对象解析时的消息，请参阅以下技术：
- en: '[PRE48]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Next, let’s further improve our code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们进一步改进我们的代码。
- en: Tapping into an observable stream
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获可观察的数据流
- en: The `CitySearchComponent` implements a callback within a `subscribe` statement
    when firing the `search` function. This leads to an imperative style of coding
    and mindset. The danger with switching programming paradigms is that you can introduce
    unintentional side effects to your code base by making it easier to store state
    or create bugs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发`search`函数时，`CitySearchComponent`在`subscribe`语句中实现了一个回调。这导致了一种命令式编程风格和思维模式。切换编程范式时的危险在于，您可以通过更容易地存储状态或创建错误来无意中引入代码库中的副作用。
- en: 'Let’s refactor `CitySearchComponent` to be in the reactive functional programming
    style, as shown in the following example:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`CitySearchComponent`重构为响应式函数式编程风格，如下例所示：
- en: '[PRE49]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, we removed the `OnInit` implementation and implemented
    our filtering logic reactively. The `tap` operator will only get triggered if
    `this.search` is valid.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们移除了`OnInit`实现并实现了我们的响应式过滤逻辑。`tap`操作符只有在`this.search`有效时才会被触发。
- en: '`constructor` should only be used when working with properties and events local
    to the class context. In this case, search is initialized when defined, and `valueChanges`
    can only be triggered by a user interacting with the component. So, it’s okay
    to set up the subscribe logic in it.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor`仅应在处理类上下文内的属性和事件时使用。在这种情况下，搜索在定义时初始化，并且`valueChanges`只能由用户与组件的交互触发。因此，在`constructor`中设置订阅逻辑是可行的。'
- en: However, if you’re referencing any properties within the template, `@Input`
    variables, or registering an external service call, you must use `ngOnInit`. Otherwise,
    you will run into render errors or unpredictable behavior. This is because template
    properties, including `@Input` variables, won’t be accessible until `ngOnInit`
    is called. Further, external service calls may return a response before the component
    is initialized, leading to change detection errors.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您在模板中引用任何属性、`@Input`变量或注册外部服务调用，则必须使用`ngOnInit`。否则，您将遇到渲染错误或不可预测的行为。这是因为模板属性，包括`@Input`变量，直到`ngOnInit`被调用才可用。此外，外部服务调用可能在组件初始化之前返回响应，导致检测错误。
- en: Simply put, 99% of the time you should use `ngOnInit`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，99%的时间您应该使用`ngOnInit`。
- en: In addition, `doSearch` is called in a functional context, making it very difficult
    to reference any other class property within the function. This reduces the chances
    of the state of the class impacting the outcome of our function. As a result,
    `doSearch` is a composable and unit-testable function, whereas in the previous
    implementation, it would have been very challenging to unit test `ngOnInit` in
    a straightforward manner.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`doSearch`在函数式上下文中被调用，这使得在函数内部引用任何其他类属性变得非常困难。这减少了类状态影响我们函数结果的可能性。因此，`doSearch`是一个可组合的且可单元测试的函数，而在先前的实现中，以直接方式单元测试`ngOnInit`将非常具有挑战性。
- en: Note that `subscribe()` must be called on `valueChanges` to activate the observable
    data stream. Otherwise, no event will fire.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，必须在对`valueChanges`调用`subscribe()`来激活可观察数据流。否则，不会触发任何事件。
- en: The fact that we didn’t need to implement `ngOnInit` reflects the truly asynchronous
    nature of our code, which is independent of the lifecycle or state of the application.
    However, you should stick with `ngOnInit` as a general best practice.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要实现`ngOnInit`的事实反映了我们代码的真实异步性，它与应用程序的生命周期或状态无关。然而，您应该坚持使用`ngOnInit`作为一般最佳实践。
- en: With our refactoring complete, the app should function the same as before but
    with less boilerplate code. Now, let’s look into enhancing our app to handle postal
    codes from any country.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的重构完成后，应用程序应该与之前相同，但具有更少的样板代码。现在，让我们看看如何增强我们的应用程序以处理来自任何国家的邮政编码。
- en: Chaining API calls
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接API调用
- en: Currently, our app can only handle 5-digit numerical postal or zip codes from
    the US. A postal code such as `22201` is easy to differentiate from a city name
    with a simplistic conditional such as `typeof search === 'string'`. However, postal
    codes can vary widely from country to country, the UK being a great example, with
    postal codes such as `EC2R 6AB`. Even if we had a perfect understanding of how
    postal codes are formatted for every country, we still couldn’t ensure that the
    user didn’t fat-finger a slightly incorrect postal code. Today’s sophisticated
    users expect web applications to be resilient toward such mistakes. However, as
    web developers, we can’t be expected to code up a universal postal code validation
    service by hand. Instead, we need to leverage an external service before we send
    our request to OpenWeatherMap APIs. Let’s explore how we can chain back-to-back
    API calls that rely on each other.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序只能处理来自美国的 5 位数字邮政或邮编。例如，邮编 `22201` 可以通过简单的条件 `typeof search === 'string'`
    与城市名称区分开来。然而，邮编在不同国家之间差异很大，英国就是一个很好的例子，其邮编如 `EC2R 6AB`。即使我们对每个国家的邮编格式有完美的理解，我们仍然不能确保用户没有输入一个轻微错误的邮编。今天的复杂用户期望网络应用程序对这类错误具有弹性。然而，作为网络开发者，我们不能期望手动编写一个通用的邮编验证服务。相反，在我们向
    OpenWeatherMap API 发送请求之前，我们需要利用外部服务。让我们探索如何串联依赖彼此的连续 API 调用。
- en: After the first edition of this book was published, I received some passionate
    reader feedback on their disappointment that the sample app could only support
    US zip codes. I’ve implemented this feature because it demonstrates how simple
    requests can introduce unplanned complexity to your apps. As a bonus, the app
    now works worldwide.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版出版后，我收到了一些热情的读者反馈，他们对示例应用程序只能支持美国邮编表示失望。我已经实现了这个功能，因为它展示了简单的请求如何引入您应用程序中的未计划复杂性。作为额外的好处，应用程序现在可以在全球范围内使用。
- en: 'Let’s add a new item, **Support international zip codes**, to the backlog and
    move it to **In progress**:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个新项目，**支持国际邮编**，并将其移动到**进行中**：
- en: '![A screenshot of a chat  Description automatically generated with medium confidence](img/B20960_02_08.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![聊天截图，描述自动生成，置信度中等](img/B20960_02_08.png)'
- en: 'Figure 2.8: Adding an international zip codes story'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：添加国际邮编故事
- en: Implementing a postal code service
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现邮编服务
- en: To properly understand whether the user inputs a valid postal code versus the
    name of a city, we must rely on a third-party API call provided by [geonames.org](http://geonames.org).
    Let’s see how we can inject a secondary API call into the search logic of our
    app.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确理解用户输入的是有效的邮编还是城市名称，我们必须依赖 [geonames.org](http://geonames.org) 提供的第三方 API
    调用。让我们看看我们如何将二级 API 调用注入到我们应用程序的搜索逻辑中。
- en: You need to sign up for a free account on [geonames.org](http://geonames.org).
    Afterward, store username as a new parameter in `environment.ts` and `environment.prod.ts`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在 [geonames.org](http://geonames.org) 上注册一个免费账户。之后，将用户名作为新参数存储在 `environment.ts`
    和 `environment.prod.ts` 文件中。
- en: You may experiment with the postal code API interactively at [https://www.geonames.org/postal-codes](https://www.geonames.org/postal-codes).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://www.geonames.org/postal-codes](https://www.geonames.org/postal-codes)
    交互式地实验邮政编码 API。
- en: 'We need to implement a service that adheres to the following interface:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个符合以下接口的服务：
- en: '[PRE50]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Declaring an interface for your service is a useful practice when you’re initially
    designing your app. You and your team members can focus on providing the right
    interaction model without being bogged down by implementation details. Once your
    interface is defined, you can quickly stub out functionality and have a walking
    skeleton version of your app in place. Stubbed-out functions help validate design
    choices and encourage early integration between components. Once in place, team
    members will no longer need to guess whether they are coding in the right spot.
    You should always export your interface, so you can use the type information for
    writing unit tests, creating test doubles or fakes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在您最初设计应用程序时，声明服务接口是一种有用的实践。您和您的团队成员可以专注于提供正确的交互模型，而不会被实现细节所困扰。一旦您的接口定义完成，您就可以快速创建功能原型，并放置应用程序的行走骨架版本。原型化的函数有助于验证设计选择并鼓励组件之间的早期集成。一旦实施，团队成员就不再需要猜测他们是否在正确的位置编码。您应该始终导出接口，这样您就可以使用类型信息编写单元测试，创建测试替身或模拟。
- en: Interfaces are key to practicing **Test-Driven Development** (**TDD**).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是实践**测试驱动开发**（**TDD**）的关键。
- en: 'Now implement `PostalCodeService` as shown below:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照以下示例实现 `PostalCodeService`：
- en: You may generate the service by executing `npx ng generate service postalCode
    --project=local-weather-app --no-flat`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行 `npx ng generate service postalCode --project=local-weather-app --no-flat`
    来生成服务。
- en: '[PRE51]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note the new environment variable, `environment.geonamesApi`. In `environment.ts`,
    set this value to `api` and, in `environment.prod.ts`, to `secure`, so calls over
    HTTPS work correctly to avoid the mixed-content error, as covered in *Chapter
    10*, *Releasing to Production Using CI/CD*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新的环境变量 `environment.geonamesApi`。在 `environment.ts` 中将其值设置为 `api`，在 `environment.prod.ts`
    中设置为 `secure`，这样 HTTPS 调用就可以正确工作，避免混合内容错误，如第 10 章 *使用 CI/CD 发布到生产* 中所述。
- en: In the preceding code segment, we implement a `resolvePostalCode` function that
    calls an API, which is configured to receive the first viable result the API returns.
    The results are then flattened and piped out to the subscriber. With `defaultIfEmpty`,
    we ensure that a null value will be provided if we don’t receive a result from
    the API. If the call is successful, we will get back all the information defined
    in `IpostalCode`, making it possible to leverage `getCurrentWeatherByCoords` using
    coordinates.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们实现了一个 `resolvePostalCode` 函数，该函数调用一个配置为接收 API 返回的第一个有效结果的 API。然后结果被展平并传递给订阅者。使用
    `defaultIfEmpty`，我们确保如果没有从 API 收到结果，将提供一个 null 值。如果调用成功，我们将得到 `IpostalCode` 中定义的所有信息，这使得可以使用坐标调用
    `getCurrentWeatherByCoords`。
- en: Observable sequencing with switchMap
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `switchMap` 进行可观察的序列化
- en: 'Let’s update the weather service so that it can call the `postalCode` service
    to determine whether the user input was a valid postal code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新天气服务，使其能够调用 `postalCode` 服务以确定用户输入是否为有效的邮政编码：
- en: 'Start by updating the interface so we only deal with a string:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，更新接口，这样我们只处理字符串：
- en: '[PRE52]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Inject `PostalCodeService` to the weather service as a private property:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `PostalCodeService` 注入到天气服务作为私有属性：
- en: '[PRE53]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Update the method signature for `updateCurrentWeather`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `updateCurrentWeather` 方法的签名。
- en: 'Update `getCurrentWeather` to try and resolve `searchText` as a postal code:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `getCurrentWeather` 以尝试将 `searchText` 解析为邮政编码：
- en: '[PRE54]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you run into TypeScript issues when passing the latitude and longitude into
    `getCurrentWeatherByCoords`, you may have to cast the object using the `as` operator.
    So, your code would look like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在将纬度和经度传递给 `getCurrentWeatherByCoords` 时遇到 TypeScript 问题，你可能需要使用 `as` 操作符来强制转换对象。因此，你的代码看起来会是这样：
- en: '[PRE55]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code segment, our first call is to the `postalCode` service.
    We then react to postal codes posted on the data stream using `switchMap`. Inside
    `switchMap`, we can observe whether `postalCode` is null and make the appropriate
    follow-up call to either get the current weather by coordinates or by city name.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们的第一次调用是到 `postalCode` 服务。然后我们使用 `switchMap` 对数据流上发布的邮政编码做出反应。在 `switchMap`
    内部，我们可以观察 `postalCode` 是否为 null，并做出适当的后续调用，要么通过坐标获取当前天气，要么通过城市名称获取。
- en: 'Now, LocalCast Weather should work with global postal codes, as shown in the
    following screenshot:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，LocalCast 天气应该可以与全球邮政编码一起工作，如下面的截图所示：
- en: '![A screenshot of a weather forecast  Description automatically generated with
    medium confidence](img/B20960_02_09.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![天气预报截图，描述自动生成，置信度中等](img/B20960_02_09.png)'
- en: 'Figure 2.9: LocalCast Weather with global postal codes'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：带有全球邮政编码的 LocalCast 天气
- en: 'We are done with implementing international zip code support. Move it to the
    **Done** column on your Kanban board:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了国际邮政编码支持的实施。将其移动到你的看板上的 **完成** 列：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_02_10.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述自动生成，置信度中等](img/B20960_02_10.png)'
- en: 'Figure 2.10: International zip code support done'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：国际邮政编码支持完成
- en: As we complete our implementation of LocalCast Weather, there’s still room for
    improvement. Initially, the app looks broken when it first loads because of the
    dashes and empty fields shown. There are at least two different ways to handle
    this. The first is to hide the entire component at the `AppComponent` level if
    there’s no data to display. For this to work, we must inject `WeatherService`
    into `AppComponent`, ultimately leading to a less flexible solution. Another way
    is to enhance `CurrentWeatherComponent` so that it is better able to handle missing
    data.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们完成 LocalCast 天气应用程序的实现，仍有改进的空间。最初，由于显示的破折号和空字段，应用程序看起来损坏。至少有两种不同的方法来处理这个问题。第一种是在没有数据显示时，在
    `AppComponent` 级别隐藏整个组件。为了使这可行，我们必须将 `WeatherService` 注入到 `AppComponent` 中，这最终导致了一个灵活性较低的解决方案。另一种方法是增强
    `CurrentWeatherComponent`，使其能够更好地处理缺失的数据。
- en: You improve the app further by implementing geolocation to get the weather for
    the user’s current location upon launching the app. You can also leverage `window.localStorage`
    to store the city that was last displayed or the last location retrieved from
    `window.geolocation` upon initial launch.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现地理位置功能，您可以在启动应用程序时获取用户的当前位置的天气。您还可以利用 `window.localStorage` 在应用程序初始启动时存储最后显示的城市或从
    `window.geolocation` 获取的最后位置。
- en: We are done with the LocalCast Weather app until *Chapter 9*, *Recipes – Master/Detail,
    Data Tables, and NgRx*, where I demonstrate how a state store like NgRx compares
    to using `RxJS/BehaviorSubject`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了 LocalCast 天气应用程序的本地化，直到 *第 9 章*，*食谱 – 主/详细页面，数据表和 NgRx*，在那里我展示了像 NgRx
    这样的状态存储与使用 `RxJS/BehaviorSubject` 相比的情况。
- en: Using Angular Signals
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular 信号
- en: A signal is a reactivity primitive that keeps track of its value changing over
    time. Angular Signals implements this primitive to granularly sync the application
    state with the DOM. By focusing on granular changes in state and only the relevant
    DOM nodes, the number and severity of change detection operations are significantly
    reduced. As covered in *Chapter 1*, *Angular’s Architecture and Concepts*, change
    detection is one of the most expensive operations that the Angular framework performs.
    As an app grows in complexity, change detection operations may be forced to traverse
    or update larger parts of the DOM tree. As the number of interactive elements
    increases in your app, change detection events occur more frequently. App complexity
    combined with the frequency of events can introduce significant performance issues,
    resulting in slow or choppy rendering of the app. Usually, there’s no quick fix
    for a problem like this. So, it is critical to understand how signals work and
    implement them in your app to avoid costly performance issues.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是一种反应原语，它跟踪其值随时间的变化。Angular 信号实现了这种原语，以细粒度同步应用程序状态与 DOM。通过关注状态中的细粒度变化以及仅相关的
    DOM 节点，可以显著减少变更检测操作的数量和严重程度。如 *第 1 章*，*Angular 的架构和概念* 中所述，变更检测是 Angular 框架执行的最昂贵的操作之一。随着应用程序复杂性的增加，变更检测操作可能被迫遍历或更新
    DOM 树的更大部分。随着应用程序中交互元素的数量的增加，变更检测事件发生的频率也会更高。应用程序的复杂性与事件频率的结合可能会引入重大的性能问题，导致应用程序渲染缓慢或断断续续。通常，对于这类问题没有快速的解决方案。因此，了解信号的工作原理并在您的应用程序中实现它们以避免昂贵的性能问题是至关重要的。
- en: 'As of this publication, Angular Signals is in preview. This means that the
    functionality and performance characteristics of the feature set can and likely
    will change. Refer to the following guide for the latest information: [https://angular.dev/guide/signals](https://angular.dev/guide/signals).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本次发布，Angular 信号处于预览阶段。这意味着功能集的功能和性能特征可能会发生变化。有关最新信息，请参阅以下指南：[https://angular.dev/guide/signals](https://angular.dev/guide/signals)。
- en: 'Angular Signals provides a few simple functions to interact with it:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 信号提供了一些简单的函数来与之交互：
- en: '`signal`: A wrapper around a value. It works like a value getter or setter
    in a class and is conceptually similar to how `BehaviorSubject` works:'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signal`：一个值的包装器。它就像类中的值获取器或设置器一样工作，在概念上类似于 `BehaviorSubject` 的工作方式：'
- en: '[PRE56]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`computed`: A computed signal. It utilizes one or more signals to modify the
    outcome:'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`computed`：一个计算信号。它利用一个或多个信号来修改结果：'
- en: '[PRE57]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`effect`: An event that triggers when a signal changes:'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`effect`：当信号发生变化时触发的事件：'
- en: '[PRE58]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Signals are a new foundational concept, and they change how we think about observables,
    binding data, and syncing state between components. They are performant, surgical
    in their nature, and best of all, they’re memory safe. No subscriptions to worry
    about here.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是一个新的基础概念，它们改变了我们对可观察对象、数据绑定和组件之间状态同步的看法。它们性能出色，性质上具有手术性，而且最好，它们是内存安全的。这里没有订阅需要担心。
- en: Let’s start by covering a simple example of using signals.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用信号的一个简单示例开始。
- en: Implementing dark mode
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现深色模式
- en: 'For our app to be considered cool by techies, we must implement a dark mode
    for it. Let’s use signals to implement this feature and go a step further by remembering
    the user’s selection in `localStorage`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的应用程序在技术人员眼中看起来很酷，我们必须为它实现一个深色模式。让我们使用信号来实现这个功能，并进一步通过在 `localStorage`
    中记住用户的选择来更进一步：
- en: '[PRE59]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If this were production code, I would not use this terse line of code:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是生产代码，我不会使用这样简短的代码行：
- en: '[PRE60]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, I wanted to keep the lines of code to a minimum, and the toggle function
    provided by the DOM API contains the logic needed to make this work correctly.
    The line should be refactored to adhere to the single responsibility principle.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我希望将代码行数保持在最低，并且 DOM API 提供的切换函数包含了使这正确工作的逻辑。这一行应该重构以符合单一责任原则。
- en: Observe the `readonly` property named `toggleState`. This is our signal. It
    holds a Boolean value. We can initialize it by reading a value from `localStorage`;
    if it doesn’t exist, it will default to `false`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 观察名为 `toggleState` 的 `readonly` 属性。这是我们信号。它包含一个布尔值。我们可以通过从 `localStorage` 读取值来初始化它；如果它不存在，它将默认为
    `false`。
- en: In the toolbar, we define mat-slide-toggle and assign its [`checked`] state
    to `toggleState()`. This binds the value of the signal to the component. By assigning
    `(change)="toggleState.set($event.checked)"`, we ensure that when the user flips
    the toggle, its value will be written back to the signal.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具栏中，我们定义 `mat-slide-toggle` 并将其 `checked` 状态分配给 `toggleState()`。这会将信号值绑定到组件上。通过分配
    `(change)="toggleState.set($event.checked)"`，我们确保当用户翻转开关时，其值将被写回到信号中。
- en: Finally, we implement the `effect` method to react to the changes in the value
    of the signal. In the constructor, we can define the behavior we want within the
    `effect` function. First, we update `localStorage` with the current value of `toggleState`,
    and second, we set the `dark-theme` class on the DOM to toggle the dark mode state.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现 `effect` 方法来响应信号值的变化。在构造函数中，我们可以在 `effect` 函数内定义我们想要的操作行为。首先，我们使用 `toggleState`
    的当前值更新 `localStorage`，其次，我们将 `dark-theme` 类设置在 DOM 上以切换深色模式状态。
- en: We leverage Angular Material’s built-in dark theme functionality to define a
    dark theme and attach it to a CSS class named `dark-theme`. Refer to `styles.scss`
    to see how this is configured.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用 Angular Material 内置的深色主题功能来定义一个深色主题，并将其附加到名为 `dark-theme` 的 CSS 类。请参阅 `styles.scss`
    以了解如何配置。
- en: We could’ve implemented this functionality at least a half-dozen different ways,
    but signals do offer a very economical way of doing it.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以实现这一功能至少六种不同的方式，但信号确实提供了一种非常经济的方式来实现。
- en: We can build on these concepts and replace the uses of `BehaviorSubject` and
    `[(ngModel)]` throughout our application. Doing so greatly simplifies how our
    Angular app works, while also reducing package size and complexity.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在此基础上构建，并在整个应用程序中替换 `BehaviorSubject` 和 `[ngModel]` 的使用。这样做极大地简化了我们的 Angular
    应用程序的工作方式，同时减少了包的大小和复杂性。
- en: Replacing BehaviorSubject with signals
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用信号替换 `BehaviorSubject`
- en: Now, let’s see what it looks like to use signals instead of `BehaviorSubject`.
    Implementing a signal means we must change the end-to-end pipeline of how a value
    is retrieved and displayed. A signal is a synchronous pipeline, whereas RxJS is
    asynchronous.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用信号而不是 `BehaviorSubject` 的样子。实现一个信号意味着我们必须改变值检索和显示的端到端管道。信号是一个同步管道，而
    RxJS 是异步的。
- en: You may wonder, isn’t asynchronous better than synchronous? Yes, but not when
    the synchronous code can run in a non-blocking manner. Asynchronous is expensive,
    and due to the fundamental technologies that are being leveraged under the hood,
    signals are way cheaper and faster. This is due to great features that are now
    built into JavaScript. See [https://www.arrow-js.com](https://www.arrow-js.com)
    by Justin Schroeder as an example of this. Certain kinds and sizes of projects
    no longer need full-fat frameworks like Angular, React, or Vue.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，异步不是比同步更好吗？是的，但并不是当同步代码可以以非阻塞方式运行时。异步是昂贵的，而且由于底层所利用的基本技术，信号要便宜得多，速度快得多。这得益于JavaScript中现在内置的出色功能。参见Justin
    Schroeder的[https://www.arrow-js.com](https://www.arrow-js.com)作为例子。某些类型和规模的项目不再需要像Angular、React或Vue这样的完整框架。
- en: 'We will need to update `WeatherService`, `CitySearchComponent`, and `CurrentWeatherComponent`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新`WeatherService`、`CitySearchComponent`和`CurrentWeatherComponent`：
- en: 'First replace `currentWeather$` with `currentWeatherSignal` in `WeatherService`:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将`WeatherService`中的`currentWeather$`替换为`currentWeatherSignal`：
- en: '[PRE61]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Implement a new `getCurrentWeatherAsPromise` function to convert the observable
    to a `Promise` and a new `updateCurrentWeatherSignal` function to await the result
    of the call and assign the result to the signal:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个新的`getCurrentWeatherAsPromise`函数，将可观察对象转换为`Promise`，以及一个新的`updateCurrentWeatherSignal`函数，以等待调用结果并将结果分配给信号：
- en: '[PRE62]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that we use `firstValueFrom` to make sure the stream completes as intended.
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用`firstValueFrom`以确保流按预期完成。
- en: 'Next, replace the `current$` property with `currentSignal` in `CurrentWeatherComponent`:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`CurrentWeatherComponent`中将`current$`属性替换为`currentSignal`：
- en: '[PRE63]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Update the template to use the signal:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新模板以使用信号：
- en: '[PRE64]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, update `CitySearchComponent` to trigger the new service call:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`CitySearchComponent`以触发新的服务调用：
- en: '[PRE65]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We have transformed our app to use a signal to communicate between components.
    A signal is less sophisticated than `BehaviorSubject`, but most of the time, the
    extra capabilities aren’t used. Signals are memory safe, lightweight, and allow
    novel applications by leveraging computed signals, like the RxJS merge technique
    discussed earlier in this chapter.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将应用转换为使用信号在组件之间进行通信。信号比`BehaviorSubject`简单，但大多数时候，额外的功能并没有被使用。信号是内存安全的、轻量级的，并且通过利用计算信号（如本章前面讨论的RxJS合并技术）允许新颖的应用。
- en: Ultimately, RxJS and signals are complementary technologies. For example, we
    wouldn’t consider replacing the debounce logic in the search input away from RxJS.
    Angular also ships with `toSignal` and `fromSignal` interoperability functions;
    however, I would caution against mixing paradigms. To get the full benefit of
    signals, always prefer an end-to-end refactor, as this section covers.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，RxJS和信号是互补的技术。例如，我们不会考虑在RxJS之外替换搜索输入中的防抖逻辑。Angular还提供了`toSignal`和`fromSignal`互操作性函数；然而，我警告不要混合范式。为了充分利用信号，始终优先考虑端到端的重构，正如本节所涵盖的。
- en: With so many options, paradigms, techniques, and gotchas, you may be wondering
    if you can just generate this code using AI. I did just that for you. Read on.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在如此多的选项、范式、技术和陷阱中，你可能想知道是否可以使用AI生成此代码。我正是这样做的。请继续阅读。
- en: Generating apps with ChatGPT
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ChatGPT生成应用
- en: 'Let’s see what result we get if we ask ChatGPT to generate a weather app. In
    August 2023, I asked ChatGPT to generate a weather app using GPT-4 with the `CodeInterpreter`
    plugin. I gave it the following prompt:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果让ChatGPT生成一个天气应用，我们会得到什么结果。在2023年8月，我让ChatGPT使用GPT-4和`CodeInterpreter`插件生成一个天气应用。我给了它以下提示：
- en: Write an Angular app that displays real-time weather data from openweathermap.org
    APIs, using Angular Material, with a user input that accepts city name, country,
    or postal code as input.
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个Angular应用，使用Angular Material显示来自openweathermap.org API的实时天气数据，用户输入可以接受城市名、国家或邮政编码作为输入。
- en: 'After making a few minor corrections, this is the result I got:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行几处小的修正后，这是我得到的结果：
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_02_11.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 自动生成描述](img/B20960_02_11.png)'
- en: 'Figure 2.11: ChatGPT weather app – August 2023'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：ChatGPT天气应用 – 2023年8月
- en: ChatGPT created a very simple and straightforward app for me, with a weather-display
    component using two-way binding for the input field. The service call was correctly
    implemented in a dedicated weather service triggered by the **Fetch Weather**
    button. To achieve similar results to the `LocalCast` app we built, we would have
    to provide a prompt with far more technical details. Non-technical people won’t
    know to ask for specific implementation details, and developers may simply find
    it easier to iteratively develop their solution. Nevertheless, the results are
    impressive.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT为我创建了一个非常简单直接的应用程序，其中包含一个使用双向绑定的输入字段的天气显示组件。服务调用在“获取天气”按钮触发的专用天气服务中正确实现。为了达到与我们构建的`LocalCast`应用程序相似的结果，我们必须提供一个包含更多技术细节的提示。非技术人员不知道要求具体的实现细节，而开发者可能觉得迭代开发他们的解决方案更容易。尽管如此，结果仍然令人印象深刻。
- en: Four months later, I questioned my premise from the paragraph above.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 四个月后，我对上面段落中的前提产生了疑问。
- en: '*What if developers were okay with providing one or two more prompts?*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果开发者可以接受提供一两个额外的提示会怎样？*'
- en: 'In December 2023, I provided the same prompt from above to ChatGPT using GPT-4
    without using any plugins, and after it generated the code, I provided an additional
    prompt:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在2023年12月，我使用GPT-4，没有使用任何插件，向ChatGPT提供了上述相同的提示，并在它生成代码后，我提供了额外的提示：
- en: Can you rewrite weather.component.html and style it in a way that looks like
    a professional design on desktop and mobile devices alike?
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你能重写weather.component.html并将其样式设计得在桌面和移动设备上看起来都像专业设计吗？
- en: And boom, I got a result that looked a lot better!
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我得到了一个看起来好得多的结果！
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_02_12.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动生成描述](img/B20960_02_12.png)'
- en: 'Figure 2.12: ChatGPT Weather app initial version – December 2023'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：ChatGPT天气应用初始版本 – 2023年12月
- en: Still, this output doesn’t look like my design. Of course, ChatGPT has no idea
    what my design is, and it’s too cumbersome to meticulously describe it in writing.
    Then I remembered I had a hand-drawn mockup of the weather app I created for the
    1^(st) edition in 2018.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个输出并不像我设计的。当然，ChatGPT不知道我的设计是什么，而且详细地用文字描述它也太繁琐了。然后我想起了我有一个为2018年第一版创建的天气应用程序的手绘原型。
- en: '![A picture containing text, handwriting, drawing, diagram  Description automatically
    generated](img/B20960_02_13.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、手写、绘图、图表的图片，自动生成描述](img/B20960_02_13.png)'
- en: 'Figure 2.13: Hand-drawn wireframe for LocalCast'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：LocalCast的手绘线框图
- en: Yes, I did use a ruler!
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我确实使用了尺子！
- en: In August 2023, ChatGPT couldn’t see, but since then, it has gained computer
    vision. I uploaded the mockup as is and said, “Redesign the UI to follow this
    mockup.” Remember that my mockup has three screens and difficult-to-read handwriting
    in it.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在2023年8月，ChatGPT无法看到，但从那时起，它已经获得了计算机视觉。我上传了原型，并说，“根据这个原型重新设计UI。”记住，我的原型有三个屏幕，并且有难以阅读的手写文字。
- en: '![Initial result with Sidenav](img/B20960_02_14.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![带有Sidenav的初始结果](img/B20960_02_14.png)'
- en: 'Figure 2.14: ChatGPT weather app second version – December 2023'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：ChatGPT天气应用第二版 – 2023年12月
- en: I’m shocked that it picked up on `SideNav` and incorporated it using proper
    Material components and `FlexLayout` media queries to make it responsive – never
    mind the misinterpretation of my handwriting.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我震惊的是它注意到了`SideNav`并将其使用适当的Material组件和`FlexLayout`媒体查询来使其响应式地整合 – 就算我的手写被误解了。
- en: 'I updated the generated UI code to make it interactive and included it as a
    project named `chat-get-dec23` in the repo. Here’s the result:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我更新了生成的UI代码，使其具有交互性，并将其作为一个名为`chat-get-dec23`的项目包含在仓库中。这是结果：
- en: '![Initial result with Sidenav](img/B20960_02_15.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![带有Sidenav的初始结果](img/B20960_02_15.png)'
- en: 'Figure 2.15: ChatGPT weather app final version – December 2023'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：ChatGPT天气应用最终版本 – 2023年12月
- en: This is beyond impressive. By the time the next edition of this book is published,
    this chapter may be only a few pages long and filled with tips, highlighting the
    crucial need to use a ruler when drawing your mockups.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经超出了令人印象深刻。到这本书的下一版出版时，这一章可能只有几页长，充满了提示，强调了在绘制原型时使用尺子的关键需求。
- en: Summary
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create search-as-you-type functionality
    using `MatInput`, validators, reactive forms, and data-stream-driven handlers.
    You became aware of two-way binding and template-driven forms. You also learned
    about different strategies to enable inter-component interactions and data sharing.
    You dove into understanding how memory leaks can be created and the importance
    of managing your subscriptions.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用`MatInput`、验证器、响应式表单和数据流驱动的处理程序创建搜索即输入的功能。你意识到了双向绑定和模板驱动的表单。你还学习了不同的策略来启用组件间的交互和数据共享。你深入了解了内存泄漏是如何产生的，以及管理你的订阅的重要性。
- en: You can now differentiate between imperative and reactive programming paradigms
    and understand the importance of sticking with reactive programming where possible.
    Finally, you learned how to implement sophisticated functionality by chaining
    multiple API calls together. You learned about the signal primitive and how you
    can use it to build simpler and more performant applications.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以区分命令式和响应式编程范式，并理解在可能的情况下坚持使用响应式编程的重要性。最后，你学习了如何通过链式调用多个API来实现复杂的功能。你了解了信号原语以及如何使用它来构建更简单、性能更优的应用程序。
- en: LocalCast Weather is a straightforward application that we used to cover the
    basic concepts of Angular. As you saw, Angular is great for building such small
    and dynamic applications while delivering a minimal amount of framework code to
    the end user. You should consider leveraging Angular for quick and dirty projects,
    which is always great practice for building larger applications. You also learned
    you can use GenAI tools like ChatGPT to give yourself a quick start when beginning
    a new project.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: LocalCast Weather是一个简单的应用程序，我们用它来介绍Angular的基本概念。正如你所见，Angular非常适合构建这样小型且动态的应用程序，同时向最终用户交付最少的框架代码。你应该考虑利用Angular进行快速且简单的项目，这对于构建更大的应用程序来说总是一个很好的实践。你还了解到，你可以使用像ChatGPT这样的GenAI工具，在开始一个新项目时给自己一个快速启动。
- en: In the next chapter, we will dive into considerations around architecting a
    web application in an enterprise app and learn where all the monsters are hidden.
    We will go over how you can build a **Line-of-Business** (**LOB**) application
    using a router-first approach to designing and architecting scalable Angular applications
    with first-class authentication and authorization, user experience, and numerous
    recipes that cover a vast majority of requirements that you may find in LOB applications.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨在企业应用程序中构建Web应用程序的考虑因素，并了解所有怪物隐藏的地方。我们将介绍如何使用以路由器为首要方法的设计和架构，构建具有一流身份验证和授权、用户体验以及覆盖大多数LOB应用程序需求的众多菜谱的可扩展Angular应用程序的**业务线**（**LOB**）应用程序。
- en: Exercises
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: After completing the **Support international zip codes** feature, did we switch
    coding paradigms here? Is our implementation above imperative, reactive, or a
    combination of both? If our implementation is not entirely reactive, how would
    you implement this function reactively? I’ll leave this as an exercise for the
    reader.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成**支持国际邮编**功能后，我们是否在这里切换了编程范式？我们的实现是命令式、响应式，还是两者的组合？如果我们的实现不是完全响应式的，你将如何以响应式的方式实现这个函数？我将把这个作为读者的练习。
- en: Don’t forget to execute `npm test`, `npm run e2e`, and `npm run test:a11y` before
    moving on. It is left as an exercise for the reader to fix the unit and end-to-end
    tests.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，不要忘记执行`npm test`、`npm run e2e`和`npm run test:a11y`。将修复单元测试和端到端测试的任务留给读者作为练习。
- en: Visit GitHub to see the unit tests I implemented for this chapter at [https://github.com/duluca/local-weather-app/tree/master/projects/stage6](https://github.com/duluca/local-weather-app/tree/master/projects/stage6).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 访问GitHub查看我为本章实现的单元测试，链接为[https://github.com/duluca/local-weather-app/tree/master/projects/stage6](https://github.com/duluca/local-weather-app/tree/master/projects/stage6)。
- en: Questions
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能好地回答以下问题，以确保你已理解本章的关键概念，而无需搜索任何内容。你知道你是否回答了所有问题吗？访问[https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)获取更多信息：
- en: What is the `async` pipe?
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`async`管道是什么？'
- en: Explain how reactive and imperative programming is different and which technique
    we should prefer.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释响应式和命令式编程有何不同，以及我们应该优先选择哪种技术。
- en: What is the benefit of `BehaviorSubject`, and what is it used for?
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BehaviorSubject` 的好处是什么，它用于什么？'
- en: What are memory leaks and why should they be avoided?
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是内存泄漏，为什么应该避免它们？
- en: What is the best method for managing subscriptions?
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理订阅的最佳方法是什么？
- en: How are Angular signals different than RxJS streams?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Angular signals 与 RxJS streams 有何不同？
- en: What are ways you can use Angular Signals to simplify your application?
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 Angular Signals 的哪些方法来简化你的应用程序？
