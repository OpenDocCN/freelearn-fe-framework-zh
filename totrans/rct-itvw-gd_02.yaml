- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Understanding ReactJS Fundamentals and Its Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解ReactJS基础及其特性
- en: Web development is a critical requirement for today’s modern businesses to generate
    long-term customer relationships because it provides a platform to interact with
    your customers. However, it is challenging to build scalable and optimized web
    applications for large enterprises that have heavy user interactions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发是当今现代企业生成长期客户关系的关键要求，因为它提供了一个与客户互动的平台。然而，对于拥有大量用户交互的大型企业来说，构建可扩展和优化的网络应用具有挑战性。
- en: JavaScript is a popular programming language for web development. It has become
    more popular over the past few years, and it is used to create a wide variety
    of applications, including web-based apps, mobile apps, desktop apps, and games.
    As part of JavaScript’s evolution, a few libraries were created while keeping
    its reusable **user interface** (**UI**) in mind to speed up development, but
    they failed to improve its performance by re-rendering the whole UI even for any
    small change. This situation has been overcome by the introduction of the ReactJS
    library, which is based on composable components and it only re-renders specific
    parts of the application wherever the screen updates are required. Before we deep
    dive into ReactJS’s features, it is important to understand the fundamentals of
    React so that you can face interviews with confidence and have a strong foundation
    for the React developer role.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种流行的网络开发编程语言。在过去几年中，它变得越来越受欢迎，并被用于创建各种应用，包括基于网络的、移动的、桌面和游戏应用。作为JavaScript进化的一个部分，一些库在考虑其可重用的**用户界面**（**UI**）的同时被创建出来，以加快开发速度，但它们未能通过重新渲染整个UI（即使是任何小的变化）来提高其性能。这种情况通过引入基于可组合组件的ReactJS库得到了克服，该库仅在屏幕更新需要的地方重新渲染应用的具体部分。在我们深入ReactJS的特性之前，了解React的基础知识非常重要，这样您可以在面试中自信地面对，并为React开发者角色打下坚实的基础。
- en: This chapter will give you complete knowledge of React fundamentals such as
    class components, functional components, state, props, and JSX as a starting point.
    You must understand important features such as virtual DOM unidirectional data
    flow, refs, the context API, and **server-side rendering** (**SSR**) to be able
    to answer most questions asked by interviewers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为您提供React基础知识的完整知识，如类组件、函数组件、状态、props和JSX作为起点。您必须理解重要特性，如虚拟DOM单向数据流、refs、上下文API和**服务器端渲染**（**SSR**），以便能够回答面试官提出的大部分问题。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Prerequisites to ReactJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReactJS的先决条件
- en: Introduction to ReactJS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReactJS简介
- en: Understanding JSX
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX简介
- en: Building views with elements and components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元素和组件构建视图
- en: Controlling the component data using props and state
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用props和state控制组件数据
- en: Understanding the importance of key prop
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解key prop的重要性
- en: Learning about event handling
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习事件处理
- en: Understanding the virtual DOM
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解虚拟DOM
- en: Difference between unidirectional data flow and bidirectional data flow
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向数据流与双向数据流的区别
- en: Accessing DOM elements in React
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中访问DOM元素
- en: Managing state globally using the context API
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文API全局管理状态
- en: Understanding server-side rendering
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务器端渲染
- en: Prerequisites to ReactJS
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactJS的先决条件
- en: 'For this chapter, you need to know about the following web technologies and
    topics before you can learn about ReactJS’s fundamentals and its features. These
    technologies will act as a strong foundation for learning ReactJS:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习ReactJS的基础和特性之前，您需要了解以下网络技术和主题。这些技术将作为学习ReactJS的强大基础：
- en: Basic knowledge of HTML, CSS, and JavaScript
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML、CSS和JavaScript的基本知识
- en: The fundamentals of ES6 features such as `let`, `const`, arrow functions, classes,
    imports and exports, the spread operator, promises and destructing, and more
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6特性的基础，如`let`、`const`、箭头函数、类、导入和导出、扩展运算符、Promise和析构赋值等
- en: A basic understanding of package managers such as npm
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对包管理器如npm的基本理解
- en: By understanding these prerequisites, you will have a clear understanding of
    the core building blocks of web development and commonly used ECMAScript features
    in the React ecosystem.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解这些先决条件，您将清楚地了解网络开发的核心理念和React生态系统中常用的ECMAScript特性。
- en: Introduction to ReactJS
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactJS简介
- en: ReactJS’s popularity in the JavaScript community stems from its ability to build
    large-scale applications where the data changes repeatedly over time. At the beginning
    of the interview process, an interviewer expects you to discuss an introduction
    to ReactJS, its features, your reason for choosing it for programming, JSX and
    its purpose in React development, and more. So, let’s answer some introductory
    questions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS在JavaScript社区中的流行源于其构建大规模应用程序的能力，这些应用程序的数据随时间不断变化。在面试过程的开始阶段，面试官期望您讨论ReactJS的简介、其特性、您选择它进行编程的原因、JSX及其在React开发中的作用，以及更多内容。因此，让我们回答一些入门问题。
- en: What is React?
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是React？
- en: React (also known as **React.js** or **ReactJS**) is an open source frontend
    JavaScript library that is used for building UIs, especially for single-page and
    mobile apps. It is used for handling the view layer of web and mobile apps.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: React（也称为**React.js**或**ReactJS**）是一个开源的前端JavaScript库，用于构建UI，特别是用于单页和移动应用程序。它用于处理网络和移动应用程序的视图层。
- en: React was created by Jordan Walke, a software engineer working for Facebook,
    and later maintained by the Facebook team. React was first deployed on Facebook’s
    newsfeed in 2011 and on Instagram in 2012.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: React是由Facebook的软件工程师Jordan Walke创建的，后来由Facebook团队维护。React首次于2011年在Facebook的新闻源上部署，并于2012年在Instagram上部署。
- en: What are the reasons for choosing React for programming?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择React进行编程的原因有哪些？
- en: 'React is a popular choice among frontend libraries nowadays for web development
    and there are multiple reasons for that. Here are some of the most notable reasons:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: React是当今前端库中流行的选择之一，用于网络开发，并且有多个原因。以下是一些最显著的原因：
- en: '**Fast**: React can handle complex updates while maintaining a fast and responsive
    UI.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**：React可以在保持快速和响应式UI的同时处理复杂的更新。'
- en: '**Declarative**: It follows a declarative approach in which you write all the
    code you need. Thereafter, React is going to be in charge of taking your declared
    code and performing all the JavaScript/DOM steps for the desired output.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式**：它遵循声明式方法，您只需编写所需的全部代码。然后，React将负责执行所有JavaScript/DOM步骤以生成所需的输出。'
- en: '**High performance**: React has better performance compared to other JavaScript
    languages due to its less expensive DOM manipulation calls by using the virtual
    DOM strategy.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能**：由于使用了虚拟DOM策略，React在DOM操作调用上成本较低，因此与其它JavaScript语言相比，性能更优。'
- en: '**SEO-friendly**: React allows you to create web applications that are **search
    engine optimization** (**SEO**)-friendly via SSR features. This feature makes
    apps faster with lower page load times and quicker rendering times, which, in
    turn, leads to better search engine ranking compared to **client-side** **rendering**
    (**CSR**).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SEO友好型**：React 允许您通过SSR（服务器端渲染）功能创建对搜索引擎优化（SEO）友好的网络应用程序。此功能使应用程序加载速度更快，页面加载时间更短，渲染时间更快，从而与客户端渲染（CSR）相比，带来更好的搜索引擎排名。'
- en: '**Cross-platform**: The library supports building web applications, cross-platform
    desktop apps, and even mobile apps using React Native.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台**：该库支持使用React Native构建网络应用程序、跨平台桌面应用程序，甚至移动应用程序。'
- en: '**Easy to test**: The library provides a comprehensive set of testing utilities
    to test the components easily by simulating user behavior in tests.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于测试**：该库提供了一套全面的测试工具，通过在测试中模拟用户行为来轻松测试组件。'
- en: '**Strong community support**: It has very strong community support with millions
    of developers across the globe who can access or share resources such as tutorials,
    articles, blogs, and YouTube videos and discuss them in various forums and communities.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强大的社区支持**：它拥有非常强大的社区支持，全球有数百万开发者可以访问或共享资源，如教程、文章、博客和YouTube视频，并在各种论坛和社区中讨论它们。'
- en: The preceeding reasons justify why ReactJS is a popular library compared to
    other frameworks or libraries. ReactJS also has some notable features that bring
    several benefits to businesses.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述原因解释了为什么与其它框架或库相比，ReactJS是一个流行的库。ReactJS还有一些显著特性，为商业带来了诸多好处。
- en: What are the major features of React?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React的主要特性有哪些？
- en: 'React has some outstanding features that make it a superior choice among modern
    frontend technologies. Some of its major features are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: React具有一些卓越的特性，使其在现代前端技术中成为更优的选择。以下是一些主要特性：
- en: It uses the **JavaScript XML** (**JSX**) syntax, a syntax extension of JavaScript
    that allows developers to write HTML in their JavaScript code, which makes the
    code easy and understandable.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用**JavaScript XML**（**JSX**）语法，这是JavaScript的一种语法扩展，允许开发者在JavaScript代码中编写HTML，这使得代码易于理解和阅读。
- en: It uses a virtual DOM instead of Real DOM since Real DOM manipulations are expensive.
    The legacy JavaScript frameworks update the whole DOM at once, which makes web
    applications quite slow.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用虚拟DOM而不是真实DOM，因为真实DOM操作成本较高。传统的JavaScript框架会一次性更新整个DOM，这使得Web应用变得相当缓慢。
- en: It supports SSR, which offers quick initial page load times and SEO-friendly
    applications compared to CSR.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持SSR（服务器端渲染），与CSR（客户端渲染）相比，它提供了快速的初始页面加载时间和SEO友好的应用。
- en: It follows a **unidirectional data flow** or one-way data binding in which the
    data flows from parent to child but not vice versa. This helps make the application
    less error-prone and easier to debug and provides more control over the data.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遵循**单向数据流**或单向数据绑定，其中数据从父级流向子级，但反之则不然。这有助于使应用更少出错，更容易调试，并提供了对数据的更多控制。
- en: It uses reusable or composable UI components to develop the view at a fast pace
    and follows the **Don’t Repeat Yourself** (**DRY**) principle, which states that
    duplication in logic should be eliminated.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用可重用或可组合的UI组件以快速的速度开发视图，并遵循**DRY**（不要重复自己）原则，该原则指出逻辑重复应该被消除。
- en: React can be written either in **JSX** or JavaScript code, but most developers
    use JSX in their code since the benefits are worth the learning curve. The next
    section will provide answers to the most common questions you’ll be asked at the
    beginning of the interview.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: React可以用**JSX**或JavaScript代码编写，但大多数开发者由于学习曲线的收益，在代码中使用JSX。下一节将提供您在面试开始时最常被问到的问题的答案。
- en: Understanding JSX
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JSX
- en: It is recommended that you use JSX with React to describe what the UI should
    look like in a web application. Even though JSX is not mandatory to use in React,
    it comes with several advantages, all of which we’ll cover here.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您使用JSX与React来描述Web应用中UI应该呈现的样子。尽管在React中使用JSX不是强制性的，但它带来了许多优势，所有这些优势我们都会在这里介绍。
- en: What is JSX?
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX是什么？
- en: JSX is an XML-like syntax extension of the JavaScript language that’s based
    on ES6, which means you can structure component rendering using syntax such as
    HTML. This means it is just syntactic sugar that allows you to write HTML inside
    JavaScript and place it in the DOM without using any `createElement()` or `appendChild()`
    methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JSX是JavaScript语言的一种类似于XML的语法扩展，基于ES6，这意味着您可以使用HTML之类的语法来结构化组件渲染。这意味着它只是语法糖，允许您在JavaScript内部编写HTML并将其放置在DOM中，而无需使用任何`createElement()`或`appendChild()`方法。
- en: 'Let’s look at an example of a simple JSX code snippet to better understand
    how it works:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的JSX代码片段的例子来更好地理解它是如何工作的：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After rendering the code, React outputs the content inside the `<h1>` tag to
    your DOM.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染代码后，React将`<h1>`标签内的内容输出到您的DOM中。
- en: 'The plain JavaScript code snippet without the preceding JSX code would look
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 没有前导JSX代码的纯JavaScript代码片段如下所示：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: JSX is stricter than HTML, so all the elements should have a closing tag.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JSX比HTML更严格，因此所有元素都应该有闭合标签。
- en: Why can’t browsers understand JSX?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么浏览器不能理解JSX？
- en: 'Web browsers can only read JavaScript objects but not JSX because there is
    no inherent implementation for the browser engines to read and understand the
    syntax. To use JSX, you need to use transpilers or compilers such as Babel to
    convert JSX code into its respective plain JavaScript code at runtime:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Web浏览器只能读取JavaScript对象，但不能读取JSX，因为没有浏览器引擎内置的实现来读取和理解该语法。要使用JSX，您需要使用转译器或编译器，如Babel，在运行时将JSX代码转换为相应的纯JavaScript代码：
- en: '![Figure 2.1: JSX transpilation](img/Figure_02.01_B18603.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：JSX转译](img/Figure_02.01_B18603.jpg)'
- en: 'Figure 2.1: JSX transpilation'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：JSX转译
- en: The preceding diagram explains how the transpilation works in JSX code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表解释了JSX代码中的转译是如何工作的。
- en: What are the advantages of JSX?
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX的优势是什么？
- en: 'JSX is not mandatory for writing React applications, but it offers many benefits:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: JSX不是编写React应用的强制要求，但它提供了许多好处：
- en: JSX makes it easier to read and understand the structure of a component just
    by seeing its layout in code
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX使得仅通过查看代码中的布局就能更容易地阅读和理解组件的结构。
- en: Most developers find it helpful as a visual aid while writing the template code
    for the UI
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数开发者发现，在编写UI模板代码时，将其作为视觉辅助工具非常有帮助。
- en: It allows you to create reusable components that can be reused throughout your
    application
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您创建可重复使用的组件，这些组件可以在整个应用程序中重复使用
- en: It can show useful errors and warning messages in React applications
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在React应用程序中显示有用的错误和警告消息
- en: JSX makes optimizations while translating the code into regular JavaScript,
    so it improves performance compared to writing normal JavaScript
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX在将代码转换为常规JavaScript时进行优化，因此与编写常规JavaScript相比，它提高了性能
- en: Once you are familiar with JSX code, it is easy to build views with elements
    and components.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您熟悉JSX代码，使用元素和组件构建视图就变得容易。
- en: Building views with elements and components
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元素和组件构建视图
- en: Both elements and components are basic building blocks for creating React views
    or apps. It is easy to build a UI with isolated, customizable, and reusable components.
    The following questions and the content they cover will help you answer the basics
    of ReactJS and will act as a foundation for the next set of questions in this
    book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 元素和组件是创建React视图或应用程序的基本构建块。使用隔离的、可定制的和可重复使用的组件来构建UI非常容易。以下问题和它们涵盖的内容将帮助您了解ReactJS的基础知识，并将作为本书下一组问题的基石。
- en: What are components?
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是组件？
- en: 'A component is an independent, reusable code block that divides the UI into
    smaller pieces. For example, while building the UI part of a web application using
    the React library, you can break its UI into small pieces for reusability purposes,
    highlighted with blue boxes in the following figure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是一个独立的、可重复使用的代码块，它将UI分割成更小的部分。例如，在构建使用React库的Web应用程序的UI部分时，您可以将它的UI分割成小块以提高可重复使用性，如下图中用蓝色方框突出显示：
- en: '![Figure 2.2: React components](img/Figure_02.02_B18603.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：React组件](img/Figure_02.02_B18603.jpg)'
- en: 'Figure 2.2: React components'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：React组件
- en: Each piece can be considered a component and is represented in a separate file
    instead of the UI being built in a single file. These components can be reused
    across the application wherever they are applicable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都可以被视为一个组件，并且它们分别在一个单独的文件中表示，而不是在单个文件中构建UI。这些组件可以在应用程序的任何适用位置重复使用。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Each component returns some HTML code, but you can only return a single HTML
    element. Otherwise, JSX will throw an error saying *JSX expressions must have
    one* *parent element.*
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件返回一些HTML代码，但您只能返回一个HTML元素。否则，JSX将抛出一个错误，表示*JSX表达式必须有一个* *父元素*。
- en: What are the different ways to create components?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有哪些创建组件的不同方式？
- en: 'There are two possible ways to create a component in ReactJS. Let’s look at
    them:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在ReactJS中创建组件有两种可能的方式。让我们来看看它们：
- en: '`props` object as the first parameter and return React elements to render the
    output:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`props`对象作为第一个参数，并返回React元素以渲染输出：
- en: '[PRE2]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is also possible to use local state in function components after the introduction
    of the React Hooks feature.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入React Hooks功能之后，也可以在函数组件中使用本地状态。
- en: '`React.Component`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.Component`。'
- en: 'The preceding function component can be written as follows:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述函数组件可以写成以下形式：
- en: '[PRE3]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `render()` method in the preceding code is the only mandatory method that
    needs to be implemented in every class component.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码中的`render()`方法是每个类组件必须实现的唯一强制方法。
- en: What is the difference between an element and a component?
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素和组件之间的区别是什么？
- en: An element is a plain object that describes a component instance or DOM node
    with its desired properties to represent the UI at a certain point in time. It
    contains information such as the component’s type, its properties, and any child
    elements under it. It is cheaper to create React elements compared to DOM elements.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 元素是一个描述组件实例或DOM节点及其所需属性以在某个时间点表示UI的普通对象。它包含有关组件类型、其属性以及其下的任何子元素的信息。与DOM元素相比，创建React元素的成本更低。
- en: 'The syntactical representation of any React element is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 任何React元素的语法表示如下：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is an example of creating a simple `SignOut` React element where an element
    contains another element:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个创建简单的`SignOut` React元素的示例，其中元素包含另一个元素：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding `React.createElement` method returns an object, as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`React.createElement`方法返回一个对象，如下所示：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, it is rendered to the DOM using `ReactDOM.render()`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它使用`ReactDOM.render()`渲染到DOM中。
- en: 'The same React element can be simplified and represented in JSX in a short
    notation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的React元素可以通过简化的方式在JSX中以短格式表示：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: React elements are immutable – that is, once you create an element, you can’t
    modify its children or attributes further.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: React 元素是不可变的——也就是说，一旦你创建了一个元素，你就不能再进一步修改其子元素或属性。
- en: A component, on the other hand, is composed of React elements. In other words,
    a component is a factory for creating elements. This component can be one of two
    types – a class or a function type that optionally takes input and returns an
    element tree as output.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个组分由 React 元素组成。换句话说，一个组分是一个创建元素的工厂。这个组分可以是两种类型之一——一个类或一个可选输入并返回元素树的函数类型。
- en: 'Let’s understand this concept by looking at an example that uses the preceding
    `SignOut` React element to create a React component:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解这个概念，这个例子使用了前面的 `SignOut` React 元素来创建一个 React 组分：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following figure represents how elements and components are structured
    inside the React view:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了元素和组分在 React 视图中的结构：
- en: '![Figure 2.3: Components versus elements](img/Figure_02.03_B18603.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3：组分与元素](img/Figure_02.03_B18603.jpg)'
- en: 'Figure 2.3: Components versus elements'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：组分与元素
- en: These components can be further categorized into pure components, **higher-order
    components** (**HOCs**), and more, alongside their specific functionality. You
    will learn more about them in the upcoming questions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组分可以进一步分为纯组分、**高阶组分**（**HOCs**）等，以及它们的特定功能。你将在接下来的问题中了解更多关于它们的信息。
- en: What are pure components?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是纯组分？
- en: Pure components are components that render the same output for the same state
    and props. It is possible to achieve pure functionality within function components
    with the help of the Memoize API (that is, `React.memo()`), which you can wrap
    around the component. This API is mainly useful for performance optimizations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 纯组分是指对于相同的 state 和 props，渲染相同输出的组分。在函数组件中，借助 Memoize API（即 `React.memo()`），可以在组件周围包裹以实现纯功能。这个
    API 主要用于性能优化。
- en: The Memoize API prevents unnecessary updates from being rendered using shallow
    comparisons of props. This means it doesn’t compare the previous state with the
    new state. This is because the function component itself prevents re-rendering
    by default when you set (that is, using the setter function) the same state again.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Memoize API 通过对 props 进行浅比较来防止不必要的更新渲染。这意味着它不会比较前一个状态与新状态。这是因为函数组件默认情况下会阻止重新渲染，当你再次设置（即使用设置函数）相同的状态时。
- en: 'Let’s understand this memoization concept using an example. First, create a
    parent `UserEnquiryForm` component to enter the user input and then create another
    component to display the same information called `UserProfile`; this is the child
    component. The child component has been wrapped with the Memoize API to prevent
    the same prop details from being passed down from the parent component:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解这个记忆化概念。首先，创建一个父 `UserEnquiryForm` 组分来输入用户输入，然后创建另一个显示相同信息的组分，称为
    `UserProfile`；这是子组分。子组分被包裹在 Memoize API 中，以防止相同的 prop 细节从父组件传递下来：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, the `email` property has not been passed down to the
    child component. So, there won’t be any re-rendering for the changes on email
    input.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`email` 属性没有被传递给子组件。因此，对于 email 输入的变化，不会进行任何重新渲染。
- en: However, in class components, the component will become a pure component since
    we extended it with `PureComponent` instead of `Component`. Internally, a pure
    component implements the `shouldComponentUpdate()` life cycle method with shallow
    comparison.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在类组件中，由于我们用 `PureComponent` 扩展了它而不是 `Component`，组件将变成一个纯组件。内部，纯组件实现了 `shouldComponentUpdate()`
    生命周期方法，并使用浅比较。
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended that all React components act like pure functions concerning
    their props. This guideline helps improve performance as it prevents unnecessary
    re-renders and avoids unexpected bugs in the application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 建议所有 React 组分在处理 props 时都像纯函数一样。这个指南有助于提高性能，因为它防止了不必要的重新渲染，并避免了应用中意外的错误。
- en: Apart from pure components, another special type of component is also created
    as a pattern in the React ecosystem. It works as a pure function with zero side
    effects, similar to a pure component’s behavior.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了纯组分之外，在 React 生态系统中还创建了一种特殊的组分类型，作为一种模式。它作为一个具有零副作用（类似于纯组件的行为）的纯函数工作。
- en: What is a higher-order component?
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是高阶组分？
- en: An HOC is a function that takes a component and returns a new component. HOCs
    are not part of the React API but they are an advanced technique for reusing component
    logic. You can share props and states between components using HOCs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: HOC（高阶组件）是一个函数，它接受一个组件并返回一个新的组件。HOC不是React API的一部分，但它们是重用组件逻辑的高级技术。你可以使用HOC在组件之间共享props和states。
- en: 'An HOC can be represented with the following syntax:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: HOC可以用以下语法表示：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Third-party libraries such as Redux’s `connect` and Relay’s `createFragmentContainer`
    have been created based on the HOC concept.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 基于HOC概念创建了第三方库，如Redux的`connect`和Relay的`createFragmentContainer`。
- en: What are fragments and where do you use them?
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是片段以及你会在哪里使用它们？
- en: A React fragment is a syntax that allows you to wrap or group a list of child
    elements to a React component without the need to add an extra node to the DOM.
    You can use either `<Fragment>` or a shorter syntax with an empty tag (`<></>`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: React片段是一种语法，允许你将一组子元素包装或分组到一个React组件中，而无需在DOM中添加额外的节点。你可以使用`<Fragment>`或带有空标签的更短语法（`<></>`）。
- en: 'For example, let’s take an `Author` component to represent an author who has
    posted several blog posts. This component loops through the author’s blog posts
    and displays them without adding an extra DOM node such as `<div>` or `<span>`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们以一个`Author`组件来表示一个发布了多篇博客文章的作者。该组件遍历作者的博客文章并显示它们，而不添加额外的DOM节点，如`<div>`或`<span>`：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, the `<Fragment>` tag is used to support the `key`
    prop while iterating the list items. The alternative `<></>` syntax doesn’t support
    key attributes. Hence, it is preferred to use `<Fragment>` over `<></>` if you’re
    iterating the list items.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，使用`<Fragment>`标签来支持在迭代列表项时的`key` prop。替代的`<></>`语法不支持key属性。因此，如果你正在迭代列表项，则首选使用`<Fragment>`而不是`<></>`。
- en: 'There are a few more benefits of using fragments:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用片段还有更多好处：
- en: Fragments are faster and use less memory on very large or deep DOM trees
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非常大的或深层的DOM树中，片段更快且占用更少的内存
- en: CSS frameworks or libraries such as `<div>` element will disturb the desired
    layout
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS框架或库，如`<div>`元素，会干扰期望的布局
- en: The DOM inspector is less clustered since it doesn’t contain any additional
    DOM nodes
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM检查器不那么拥挤，因为它不包含任何额外的DOM节点
- en: Now that you understand the various building blocks of a component, you can
    easily learn how to control the data in a component or between components. Data
    management is crucial for any web application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了组件的各种构建块，你可以轻松地学习如何控制组件中的数据或组件之间的数据。数据管理对于任何Web应用都是至关重要的。
- en: Controlling component data using props and state
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用props和state控制组件数据
- en: The data inside a component is controlled by props and state. All kinds of React
    applications are based on these two concepts, and they are important core topics
    that help with creating efficient and robust applications. These topics are not
    only useful in interviews, as you will also encounter their usage in everyday
    jobs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 组件内的数据由props和state控制。所有类型的React应用都基于这两个概念，它们是创建高效和健壮应用的重要核心主题。这些主题不仅在面试中很有用，你也会在日常工作中遇到它们的用法。
- en: What are props in React?
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React中的props是什么？
- en: Props, which stands for properties, are arguments that appear in the form of
    either individual values or an object holding a set of values that are passed
    into components. Their naming convention is similar to that of HTML attributes.
    They help pass data from the parent component to the child component and are used
    to render the child component dynamically on the screen. This means that props
    act as a channel for components to communicate inside the component tree.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Props，代表属性，是以单个值或包含一组值的对象的形式出现的参数，它们被传递到组件中。它们的命名规范类似于HTML属性。它们有助于将数据从父组件传递到子组件，并用于在屏幕上动态渲染子组件。这意味着props充当组件在组件树内部通信的通道。
- en: 'The main purpose of props in React is to achieve the following component functionality:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: React中props的主要目的是实现以下组件功能：
- en: Pass the custom data to your component based on business needs.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据业务需求将自定义数据传递到你的组件中。
- en: Trigger state changes in a component based on the prop’s value.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据prop的值在组件中触发状态变化。
- en: Access props via `props.propName` for a function component or `this.props.reactProp`
    for a class component inside the component’s rendering code. This data is helpful
    for conditionally rendering the UI.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在组件的渲染代码中使用`props.propName`（对于函数组件）或`this.props.reactProp`（对于类组件）来访问props。这些数据对于条件渲染UI很有帮助。
- en: 'The following is an example of how props are passed from a parent component
    to a child component (in this case, `Employee`):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个从父组件向子组件传递道具的例子（在这种情况下，`Employee`）：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, the `defaultProps` property has been used to assign the
    default values of props. These will be used if no explicit props are passed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用了`defaultProps`属性来分配道具的默认值。如果没有传递显式道具，将使用这些值。
- en: The better alternative to access the properties of a props object is by using
    destructuring from ES6 (ECMAScript 2015).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 访问道具对象的属性的更好方法是使用ES6（ECMAScript 2015）中的解构。
- en: 'With the help of destructuring, the preceding child component can be rewritten
    like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解构的帮助，前面的子组件可以重写如下：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Important note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Props are immutable (read-only) in nature and trying to modify these values
    will throw an error. If you still need to modify the data in a component, then
    state is the right choice for managing your data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 道具在本质上是不可变的（只读），尝试修改这些值将引发错误。如果你仍然需要在组件中修改数据，那么状态是管理你的数据的正确选择。
- en: Can you describe state in React?
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能描述一下React中的状态吗？
- en: State is an in-built JavaScript object where you store property values that
    belong to the component. In other words, state is private and fully controlled
    by the component. The crucial part of state is that whenever the state object
    changes, the component re-renders.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是一个内置的JavaScript对象，其中存储属于组件的属性值。换句话说，状态是私有的，完全由组件控制。状态的关键部分是，每当状态对象发生变化时，组件都会重新渲染。
- en: 'The scope of state is always inside the component, as shown in the following
    diagram:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的作用域始终在组件内部，如下面的图所示：
- en: '![Figure 2.4: Scope of state inside a component](img/Figure_02.04_B18603.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：组件内部状态的作用域](img/Figure_02.04_B18603.jpg)'
- en: 'Figure 2.4: Scope of state inside a component'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：组件内部状态的作用域
- en: 'Here is an example of a `User` functional component with a welcome message
    as the state to explain more about its usage:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个`User`函数组件的例子，其中包含欢迎信息作为状态，以解释其用法：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, the `useState` Hook was used to add state to the `User`
    component. It returns an array which contains the current state and the setter
    function to update the state.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用了`useState`钩子向`User`组件添加状态。它返回一个数组，包含当前状态和用于更新状态的setter函数。
- en: 'Compared to the functional component, the class component holds the state properties
    inside a built-in state object and accesses it through `this.state.message` inside
    the `User` component:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数组件相比，类组件将状态属性存储在内部状态对象中，并在`User`组件内部通过`this.state.message`访问它：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The built-in `setState` function is used to update the state of the preceding
    class component.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`setState`函数用于更新前一个类组件的状态。
- en: Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended to make the state variable as simple as possible for readability
    purposes and minimize the stateful components to achieve a single source of truth.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，建议将状态变量保持尽可能简单，并尽量减少有状态的组件以实现单一数据源。
- en: What are the main differences between props and state?
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 道具和状态之间主要有哪些区别？
- en: 'Both props and state are plain JavaScript objects that are used to manage the
    data of a component, but they are used in different ways and have different characteristics:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 道具和状态都是用于管理组件数据的纯JavaScript对象，但它们以不同的方式使用，具有不同的特性：
- en: '| **Props** | **State** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **道具** | **状态** |'
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Read-only and immutable | Mutable and changes asynchronously |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 只读和不可变 | 可变和异步更改 |'
- en: '| Props are passed from the parent component to the child component | Managed
    by the component itself |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 道具是从父组件传递给子组件 | 由组件本身管理 |'
- en: '| Accessed by child components | Cannot be accessed by child components |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 由子组件访问 | 不能由子组件访问 |'
- en: '| Props make components reusable | State cannot make components reusable |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 道具使组件可重用 | 状态不能使组件可重用 |'
- en: '| Used for communication between components | Used for rendering dynamic changes
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 用于组件间的通信 | 用于渲染动态变化 |'
- en: 'Table 2.1: Props versus state'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1：道具与状态对比
- en: Unlike props, state can be updated in different ways. Let’s learn more about
    batching multiple state updates.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与道具不同，状态可以通过不同的方式更新。让我们更深入地了解批量更新多个状态。
- en: How does React batch multiple state updates?
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React是如何批量更新多个状态的？
- en: React prevents components from re-rendering for each state update. React makes
    this possible by optimizing application performance using group updates within
    event handlers with the help of built-in Hooks. This entire process is known as
    **batching**. React version 17 only supports batching for browser events, whereas
    React version 18 supports an improved version of batching known as **automatic
    batching**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: React防止组件在每次状态更新时重新渲染。React通过使用内置的Hooks在事件处理器内进行分组更新来优化应用程序性能，从而实现这一点。整个过程被称为**批处理**。React版本17仅支持浏览器事件的批处理，而React版本18支持批处理的改进版本，称为**自动批处理**。
- en: Automatic batching supports state updates that are invoked from any location
    instead of just browser events. In other words, it supports native event handlers,
    asynchronous operations, timeouts, and intervals.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 自动批处理支持从任何位置调用的状态更新，而不仅仅是浏览器事件。换句话说，它支持原生事件处理器、异步操作、超时和间隔。
- en: 'Let’s look at an example demonstrating automatic batching:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个展示自动批处理的例子：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Even though the preceding code updates two state variables using an event handler,
    React will batch them automatically by default and the component will only re-render
    once.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 即使前面的代码使用事件处理器更新了两个状态变量，React也会默认自动批处理它们，组件只会重新渲染一次。
- en: Can you prevent automatic batching?
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能防止自动批处理吗？
- en: Automatic batching is a great feature of the React library that optimizes rendering
    performance. However, there are situations where you need to re-render your component
    for each state update or update one state depending on another updated state value.
    React introduced the `flushSync` API function from ReactDOM to stop automatic
    batching whenever necessary. This function is also useful for use cases where
    you need to flush updates immediately to the DOM in case you’re integrating with
    third-party code such as browser APIs and UI libraries.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 自动批处理是React库的一个优秀特性，它优化了渲染性能。然而，在某些情况下，你可能需要为每个状态更新重新渲染你的组件，或者根据另一个更新的状态值更新一个状态。React通过ReactDOM引入了`flushSync`
    API函数，以便在必要时随时停止自动批处理。此函数对于需要立即将更新刷新到DOM的情况也很有用，尤其是在与第三方代码（如浏览器API和UI库）集成时。
- en: 'For example, let’s say you want to update the scroll position on a web page
    after adding a new to do or task to a simple to do list app. This behavior is
    helpful if you wish to have a direct focus on the new to do content. In this scenario,
    the latest to do state needs to be updated immediately for you to get the correct
    scroll position:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想在向简单的待办事项应用中添加一个新的待办事项或任务后更新网页的滚动位置。如果你希望直接关注新的待办事项内容，这种行为是有帮助的。在这种情况下，最新的待办事项状态需要立即更新，以便你获得正确的滚动位置：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The usage of this function is not common and using it can often impact application
    performance badly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的使用并不常见，使用它可能会严重影响应用程序的性能。
- en: How do you update objects inside the state?
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何更新状态中的对象？
- en: You shouldn’t update React’s state object directly. Instead, you need to create
    a new object or make a copy of the existing object and then set the state with
    the newly created object. So, while updating the state object, you always need
    to treat objects inside the state as read-only, even though JavaScript objects
    are mutable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该直接更新React的状态对象。相反，你需要创建一个新的对象或复制现有的对象，然后使用新创建的对象设置状态。因此，在更新状态对象时，你始终需要将状态中的对象视为只读的，尽管JavaScript对象是可变的。
- en: 'Let’s see this comparison in action and show the results of these two updating
    processes. As an example, the `WeatherReport` component has been created, along
    with its properties, including `temperature` and `city`. After that, component
    properties are mutated directly inside the event handler:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个比较的实际效果，并展示这两个更新过程的结果。例如，已经创建了`WeatherReport`组件及其属性，包括`temperature`和`city`。之后，组件属性在事件处理器内部被直接修改：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once the preceding code has been deployed, try to enter the new weather details
    in the UI. You will see that the input fields won’t get updated.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前面的代码被部署，尝试在UI中输入新的天气详情。你会发现输入字段不会更新。
- en: 'You can fix this by creating a new copy of the `weather` object and then setting
    the state. To do that, let’s update the preceding event handler:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建`weather`对象的新副本然后设置状态来修复这个问题。为此，让我们更新前面的事件处理器：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code updates the weather details in the UI as intended.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码按预期更新了UI中的天气详情。
- en: Sometimes, only one field needs to be modified in the state object. In this
    case, it is recommended to use object spread syntax to get the benefit of reusing
    the previous state object property values instead of setting each field in the
    state.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，只需要修改状态对象中的一个字段。在这种情况下，建议使用对象展开语法来利用重用先前状态对象属性值的优势，而不是在状态中设置每个字段。
- en: How do you update nested state objects?
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何更新嵌套状态对象？
- en: It is quite easy to update top-level state objects with the spread syntax. But
    when it comes to nested state objects, you cannot update the required nested property
    directly like you can in regular JavaScript objects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用展开语法更新顶层状态对象相当容易。但是，当涉及到嵌套状态对象时，你不能直接更新所需的嵌套属性，就像你在常规JavaScript对象中做的那样。
- en: 'This can be explained further with an example: we’ll take a nested state object
    and modify the nested property inside it. To demonstrate this behavior, let’s
    consider the `User` state object with nested address details as a property:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一个例子进一步解释：我们将使用嵌套状态对象并修改其内部的嵌套属性。为了演示这种行为，让我们考虑具有嵌套地址详情属性的用户`User`状态对象：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, you can try to update the `postalCodeproperty` using an expression like
    `user.address.postalCode = 75015` in your React components, similar to how you
    do in plain JavaScript. The screen won’t be updated with the latest value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在React组件中使用类似于在纯JavaScript中进行的表达式`user.address.postalCode = 75015`来尝试更新`postalCodeproperty`，但屏幕不会更新为最新值。
- en: 'If it is not possible to flatten the nested `User` object as a workaround,
    then there are two possible approaches to update the state properly:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法通过作为解决方案将嵌套的`User`对象展平，那么有两条可能的途径来正确更新状态：
- en: '`updatedAddress`) using the spread syntax. After that, create a new top-level
    object (`updatedUser`) that points to the newly created nested object:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用展开语法创建一个新的顶层对象`updatedUser`，它指向新创建的嵌套对象：
- en: '[PRE21]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Update nested object with a single** **function call**:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过单个** **函数调用** **更新嵌套对象**：'
- en: 'It is also possible to update the nested object together with a top-level object
    by using the spread syntax within a single state setter function:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也可以通过在单个状态设置函数中使用展开语法来一起更新嵌套对象和顶层对象：
- en: '[PRE22]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you would like to go beyond the traditional approach, third-party libraries
    such as **Immer** provide a convenient way to update the deeply nested state objects.
    This library enables direct nested object updates just like regular JavaScript
    updates the properties.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要超越传统方法，第三方库如**Immer**提供了一种方便的方式来更新深层嵌套的状态对象。这个库允许直接更新嵌套对象，就像常规JavaScript更新属性一样。
- en: 'Mutating nested objects using Immer looks like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Immer修改嵌套对象看起来是这样的：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The component’s state can be an array of items as well, not just a primitive
    value or an object type. However, you need to supply the additional key prop,
    as detailed in the upcoming questions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的状态也可以是一个项的数组，而不仅仅是原始值或对象类型。然而，你需要提供额外的key属性，这将在后续问题中详细说明。
- en: Understanding the importance of key props
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解key属性的重要性
- en: Keys help you control component or element instances. They play a major role
    in deciding whether the element needs to be re-rendered or not in a list of elements.
    Hence, every developer should have an idea about the importance of a key prop.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Keys帮助你控制组件或元素实例。它们在决定元素是否需要在元素列表中重新渲染中起着重要作用。因此，每个开发者都应该了解key属性的重要性。
- en: What is a key prop and what is the purpose of it?
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: key属性是什么，它的用途是什么？
- en: A **key** is a special attribute that you need to include when creating a list
    of elements in a component. This key prop helps React identify which elements
    have changed and been added or removed. In other words, it helps you retain a
    unique identity of the elements or among the siblings in the list even after the
    elements have been modified.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键**属性是在创建组件中元素列表时需要包含的一个特殊属性。这个key属性帮助React识别哪些元素已更改、已添加或已删除。换句话说，它帮助你在元素被修改后仍然保留元素的唯一标识或列表中兄弟元素的唯一标识。'
- en: 'Even if you don’t supply a key prop, the list can render the content to the
    browser successfully, but with a warning message logged in the console, as shown
    here:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你没有提供key属性，列表也可以成功地将内容渲染到浏览器中，但会在控制台记录一条警告消息，如下所示：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is recommended to use a unique ID value from the data as a key prop. This
    value can be a string or number.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用数据中的唯一ID值作为key属性。这个值可以是字符串或数字。
- en: 'Let’s understand this key prop concept in a better way by implementing the
    to do list of a programmer. Here, you are assigning a key to the `TodoItem` component
    while iterating from the list and not to the extracted `<``li>` tag:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现程序员的待办事项列表来更好地理解这个关键的属性概念。在这里，你是在迭代列表时将键分配给`TodoItem`组件，而不是分配给提取的`<li>`标签：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is discouraged to assign indexes (received from iterating the list of elements)
    as keys because if the elements of the list get reordered in the future, then
    the keys of the elements will also change.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议将索引（从元素列表迭代中接收）作为键分配，因为如果列表的元素在未来被重新排序，那么元素的键也会改变。
- en: Learning about event handling
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解事件处理
- en: Event handling is essential for interacting with a web page in an application.
    React has its own event handling ecosystem. The event handler determines what
    action has to be taken whenever a particular event is fired. This section will
    give you a good understanding of event handling in the React library.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理对于在应用程序中与网页交互至关重要。React 有自己的事件处理生态系统。事件处理器决定了每当特定事件被触发时必须采取什么操作。本节将为您提供一个关于
    React 库中事件处理的良好理解。
- en: What are synthetic events?
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是合成事件？
- en: A synthetic event is a cross-browser wrapper around a browser’s actual native
    event object. It provides a unified API that prevents browser inconsistencies
    and ensures that the event works across multiple platforms.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 合成事件是浏览器实际原生事件对象的跨浏览器包装器。它提供了一个统一的 API，防止浏览器不一致性，并确保事件在多个平台上工作。
- en: 'There are some similarities between synthetic events and native events if you
    use the same `preventDefault` and `stopPropogation` methods in those two events.
    It is also possible to access native events directly by using the `nativeEvent`
    attribute on the `syntheticEvent` instance. As an example, the following search
    component is still able to access the native input event and other properties
    or methods inside the handler:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这两种事件中使用相同的`preventDefault`和`stopPropagation`方法，合成事件和原生事件之间有一些相似之处。你也可以通过在`syntheticEvent`实例上使用`nativeEvent`属性直接访问原生事件。例如，以下搜索组件仍然能够访问原生输入事件和其他在处理器内部的其他属性或方法：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The event handling in React has a few differences compared to HTML event handling,
    which we will discuss in the next section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HTML 事件处理相比，React 事件处理有一些不同之处，我们将在下一节中讨论。
- en: How do you differentiate between React event handling and HTML event handling?
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何区分 React 事件处理和 HTML 事件处理？
- en: 'React event handling is similar to event handling DOM elements in HTML. However,
    there are some notable differences between them:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: React 事件处理类似于 HTML 中的 DOM 元素事件处理。然而，它们之间有一些显著的区别：
- en: '**Naming convention**: In HTML, the name of the event is represented in lowercase
    as a convention:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名约定**：在 HTML 中，事件名称按照惯例以小写表示：'
- en: '[PRE27]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`false` inside the event handler.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理器中的`false`。
- en: 'As an example, let’s take a simple login form that contains a username and
    a password field to input the data. After submitting the form, you need to restrict
    the default behavior of an `onsubmit` event, and the enclosing form must not be
    refreshed:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，让我们以一个简单的登录表单为例，该表单包含用户名和密码字段以输入数据。在提交表单后，你需要限制`onsubmit`事件的默认行为，并且包含表单必须不被刷新：
- en: '[PRE28]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, in React, the default behavior can be prevented by calling the `event.preventDefault()`
    method:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，在 React 中，可以通过调用`event.preventDefault()`方法来防止默认行为：
- en: '[PRE29]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`()`) after the function name or use `addEventListener()` to attach events
    and listeners.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数名称后使用`()`或使用`addEventListener()`来附加事件和监听器。
- en: The following example shows a button `onclick` event and invoking the respective
    handler. This can be done in two ways.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下示例显示了一个按钮的`onclick`事件和调用相应的处理器。这可以通过两种方式完成。
- en: 'For the first approach, you can insert parentheses for the `handleSiginUp`
    function’s name:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于第一种方法，你可以在`handleSiginUp`函数名称后插入括号：
- en: '[PRE30]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How do you bind event handlers in class components?
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何在类组件中绑定事件处理器？
- en: 'There are several ways to bind event handlers in React class components:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 类组件中绑定事件处理器有几种方法：
- en: '`this` keyword in a constructor function.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数中的`this`关键字。
- en: 'As an example, let’s add a `handleUserDetails()` binding inside the constructor:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，让我们在构造函数中添加一个`handleUserDetails()`绑定：
- en: '[PRE31]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you forget to bind the handler, the `this` keyword will be undefined when
    the function is invoked.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你忘记绑定处理器，当函数被调用时`this`关键字将是未定义的。
- en: '**Public class** **fields syntax**:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共类** **字段语法**：'
- en: If you are not interested in binding handlers in the constructor, the public
    class fields approach is much better for readability and ease of use. This syntax
    is enabled by default in the **Create React App** (**CRA**) tool.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你对在构造函数中绑定处理程序不感兴趣，那么公共类字段方法在可读性和易用性方面要优越得多。这种语法在 **Create React App** （**CRA**）
    工具中默认启用。
- en: 'The previous binding approach can be rewritten and simplified using public
    class fields syntax, as shown here:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的绑定方法可以使用公共类字段语法重写和简化，如下所示：
- en: '[PRE32]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`this` keyword explicitly.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式使用 `this` 关键字。
- en: 'The arrow function is passed in the `User` component callback, like so:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 箭头函数被传递到 `User` 组件的回调中，如下所示：
- en: '[PRE33]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The main problem with this arrow function approach is that a different callback
    is created every time the component renders, and the child component might do
    extra re-rendering if the callbacks are passed as props to child components. Hence,
    it is recommended to use either a binding in a constructor or the public class
    fields syntax approach.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种箭头函数方法的主要问题在于，每次组件渲染时都会创建不同的回调，如果将回调作为属性传递给子组件，子组件可能会进行额外的重新渲染。因此，建议使用构造函数中的绑定或公共类字段语法方法。
- en: The magic behind the React library, including syncing the component data with
    the UI, DOM updates, and more, is taken care of by the virtual DOM. In the next
    section, you will learn about virtual DOM, its importance, and its processes behind
    the scenes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: React 库背后的魔法，包括同步组件数据与 UI、DOM 更新等，都由虚拟 DOM 来处理。在下一节中，你将了解虚拟 DOM、其重要性以及其背后的工作流程。
- en: Understanding virtual DOM
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解虚拟 DOM
- en: '**DOM** stands for **Document Object Model** and it represents the entire UI
    of a web page (HTML) in a tree data format. virtual DOM was not invented by React,
    but it uses it as its core feature. Its main purpose is to minimize the number
    of DOM operations when re-rendering the UI. React uses this feature to enhance
    its performance. There’s a high chance you’ll get questions related to this topic
    in an interview.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**DOM** 代表 **Document Object Model**，它以树形数据格式表示网页（HTML）的整个 UI。虚拟 DOM 不是由 React
    发明的，但它将其作为核心功能。其主要目的是在重新渲染 UI 时最小化 DOM 操作的数量。React 使用此功能来提高其性能。在面试中，你很可能会有关于这个话题的问题。'
- en: What is virtual DOM?
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是虚拟 DOM？
- en: virtual DOM is an in-memory, lightweight virtual representation of Real DOM
    that’s generated by React components. The virtual representation of a UI is stored
    in memory and synced with Real DOM to align with the latest state updates. This
    is possible through a library known as **ReactDOM**, and this step happens in
    between the render function being called and elements being displayed on the screen.
    This entire process is known as **reconciliation**.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟 DOM 是由 React 组件生成的 Real DOM 的内存中轻量级虚拟表示。UI 的虚拟表示存储在内存中，并与 Real DOM 同步以与最新的状态更新保持一致。这是通过名为
    **ReactDOM** 的库实现的，这一步骤发生在调用渲染函数和元素显示在屏幕之间。整个过程被称为 **reconciliation**。
- en: How does virtual DOM work?
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟 DOM 是如何工作的？
- en: React and Vue.js technologies use virtual DOM under the hood to abstract the
    manual DOM operations away from developers. This programming mechanism works in
    four major steps.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: React 和 Vue.js 技术在底层使用虚拟 DOM 来抽象开发者的手动 DOM 操作。这种编程机制在四个主要步骤中工作。
- en: 'As an example, let’s take a simple search form with an inputfield inside the
    `CitySearch component` and see how the virtual DOM works. We’ll provide diagrams
    for ease of understanding:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们以一个简单的搜索表单为例，该表单包含在 `CitySearch 组件` 中的输入字段，看看虚拟 DOM 是如何工作的。我们将提供图表以方便理解：
- en: '[PRE34]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceeding city search works internally with the following steps of virtual
    DOM mechanism:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的城市搜索在内部使用以下虚拟 DOM 机制的步骤：
- en: 'When the application is rendered for the first time, React creates a virtual
    DOM representing the UI and stores the same in memory:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序首次渲染时，React 创建一个代表 UI 的虚拟 DOM 并将其存储在内存中：
- en: "![Figure 2.5: Initial \uFEFFvrtual DOM](img/Figure_02.05_B18603.jpg)"
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5：初始虚拟 DOM](img/Figure_02.05_B18603.jpg)'
- en: 'Figure 2.5: Initial vrtual DOM'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：初始虚拟 DOM
- en: 'Whenever the underlying state changes, it will automatically create a new virtual
    DOM for the update. Since virtual DOM is just an object representing the UI, there
    won’t be any changes (such as repainting) in the UI at this point:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当底层状态发生变化时，它将自动为更新创建一个新的虚拟 DOM。由于虚拟 DOM 只是一个代表 UI 的对象，因此在这一点上 UI 不会有任何变化（例如重绘）：
- en: "![Figure 2.6: Updated \uFEFFvirtual DOM](img/Figure_02.06_B18603.jpg)"
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6：更新后的虚拟 DOM](img/Figure_02.06_B18603.jpg)'
- en: 'Figure 2.6: Updated virtual DOM'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：更新后的虚拟 DOM
- en: 'Once the new virtual DOM has been created, React compares it to a pre-updated
    version or snapshot of virtual DOM. React uses the **diffing** algorithm to compare
    the changes; this process is known as **reconciliation**:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了新的虚拟 DOM，React 就将其与预更新的虚拟 DOM 版本或快照进行比较。React 使用 **diffing** 算法来比较变化；这个过程被称为
    **协调**：
- en: "![  Figure 2.7: Comparing \uFEFFvirtual DOM snapshots](img/Figure_02.07_B18603.jpg)"
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![  图 2.7：比较虚拟 DOM 快照](img/Figure_02.07_B18603.jpg)'
- en: 'Figure 2.7: Comparing virtual DOM snapshots'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：比较虚拟 DOM 快照
- en: 'After the reconciliation process, React uses a render library such as ReactDOM,
    which takes the changes and updates that in Real DOM:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在协调过程之后，React 使用像 ReactDOM 这样的渲染库，它接受变化并更新 Real DOM：
- en: '![Figure 2.8: Updated Real DOM](img/Figure_02.08_B18603.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8：更新后的 Real DOM](img/Figure_02.08_B18603.jpg)'
- en: 'Figure 2.8: Updated Real DOM'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：更新后的 Real DOM
- en: What is Shadow DOM?
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Shadow DOM？
- en: Shadow DOM is a web component technology that’s designed primarily for scoping
    variables and CSS. This is useful when CSS styles defined in a parent component
    don’t affect or apply to a child component.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Shadow DOM 是一种主要设计用于作用域变量和 CSS 的 Web 组件技术。当父组件中定义的 CSS 样式不会影响或应用于子组件时，这非常有用。
- en: What is the difference between Real DOM, virtual DOM, and Shadow DOM?
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Real DOM、虚拟 DOM 和 Shadow DOM 之间的区别是什么？
- en: In modern web development, virtual DOM and shadow DOM have been introduced to
    improve performance and encapsulation as add-ons to real DOM.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 Web 开发中，虚拟 DOM 和 Shadow DOM 作为真实 DOM 的附加功能被引入，以提高性能和封装。
- en: 'Some of the notable differences among these three DOMs are listed here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些三个 DOM 之间的显著差异如下列出：
- en: '| **Real DOM** | **Virtual DOM** | **Shadow DOM** |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **Real DOM** | **Virtual DOM** | **Shadow DOM** |'
- en: '| It creates a single DOM for the entire screen | It creates a copy of the
    entire real DOM in memory and keeps track of changes | It creates small copies
    of Real DOM with its isolated scope (that is, scoped CSS styles and JavaScript)
    |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 它为整个屏幕创建一个单一的 DOM | 它在内存中创建整个真实 DOM 的副本并跟踪变化 | 它创建具有独立作用域（即，作用域 CSS 样式和 JavaScript）的真实
    DOM 的小副本 |'
- en: '| Any change will involve re-rendering the whole screen | The state change
    will involve re-rendering the specific part of the page | The changes apply to
    its own web component |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 任何变化都将涉及整个屏幕的重绘 | 状态变化将涉及页面特定部分的重绘 | 变更适用于其自身的 Web 组件 |'
- en: '| Implemented in web browsers, such as via the Solid.js library | Implemented
    in JavaScript libraries such as React, Vue, and others | Implemented in web components,
    such as Lit and Vaadin libraries |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 通过像 Solid.js 这样的库在 Web 浏览器中实现 | 通过像 React、Vue 等这样的 JavaScript 库实现 | 通过像 Lit
    和 Vaadin 这样的 Web 组件库实现 |'
- en: '| Suitable for small to medium scale applications without complex interactivity
    | Suitable for large-scale applications with complex interactivity | Suitable
    for small to medium scale applications with less complex interactivity |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 适用于小到中等规模的应用程序，没有复杂的交互性 | 适用于具有复杂交互性的大型应用程序 | 适用于小到中等规模的应用程序，交互性相对简单 |'
- en: '| Uses less CPU and memory compared to virtual DOM | Uses more CPU and memory
    compared to Real DOM | Uses less CPU and memory compared to virtual DOM |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 相比虚拟 DOM，使用更少的 CPU 和内存 | 相比 Real DOM，使用更多的 CPU 和内存 | 相比虚拟 DOM，使用更少的 CPU 和内存
    |'
- en: '| Doesn’t support encapsulation because components can be modified outside
    | Supports encapsulation because components cannot be modified outside | Supports
    encapsulation because components cannot be modified outside |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 不支持封装，因为组件可以在外部被修改 | 支持封装，因为组件不能在外部被修改 | 支持封装，因为组件不能在外部被修改 |'
- en: 'Table 2.2: Real DOM versus irtual DOM versus Shadow DOM'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2：Real DOM 与 irtual DOM 与 Shadow DOM 的比较
- en: What is React Fiber?
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 React Fiber？
- en: Fiber is a new reconciliation engine that was introduced in React version 16
    to enable in-built scheduling and incremental rendering of virtual DOM. Incremental
    rendering means having the ability to split rendering work into chunks and spread
    it out over multiple frames. So, with the help of incremental rendering, Fiber
    improves application performance in areas such as animation, layout, and gestures.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Fiber 是 React 版本 16 中引入的一种新的协调引擎，它能够实现虚拟 DOM 的内置调度和增量渲染。增量渲染意味着能够将渲染工作分成块，并在多个帧上分散。因此，借助增量渲染，Fiber
    在动画、布局和手势等方面提高了应用程序的性能。
- en: This reconciler is a complete rewrite of an old reconciliation algorithm called
    **stack reconciler**.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协调器是对一个名为 **stack reconciler** 的旧协调算法的完全重写。
- en: Data flow and communication in React applications
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 应用程序中的数据流和通信
- en: The unidirectional data flow feature of React makes the UI simple and predictable
    for data changes in small to large-scale applications. It is quite important to
    know the benefits of data flow and communication between components to better
    understand the relevant React concepts.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: React的单向数据流特性使得UI在从小到大规模的应用程序中数据变化时简单且可预测。了解数据流和组件之间的通信的好处对于更好地理解相关的React概念非常重要。
- en: Can you describe unidirectional data flow in React?
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能描述一下React中的单向数据流吗？
- en: Unidirectional data flow is also known as one-way data binding and is where
    the data flows one way only while being transferred between different parts of
    an application. This technique or feature already exists in functional reactive
    programming.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 单向数据流也称为单向数据绑定，是指数据在应用程序的不同部分之间传输时只能单向流动。这种技术或特性已经在函数式响应式编程中存在。
- en: React follows unidirectional data flow, where the data is transferred from parent
    to child using props but not vice versa. Moreover, the child components can’t
    update data that comes from the parent component. React doesn’t encourage bidirectional
    or two-way binding to make sure you are following a clean data flow architecture.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: React遵循单向数据流，其中数据通过props从父组件传递到子组件，而不是相反。此外，子组件不能更新来自父组件的数据。React不鼓励双向或双向绑定，以确保你遵循清晰的数据流架构。
- en: 'The following figure gives a clearer idea of the data flow in React:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 下图更清晰地展示了React中的数据流：
- en: "![Figure 2.9: Unidirectional versus \uFEFFbidirectional data flow](img/Figure_02.09_B18603.jpg)"
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9：单向与双向数据流](img/Figure_02.09_B18603.jpg)'
- en: 'Figure 2.9: Unidirectional versus bidirectional data flow'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：单向与双向数据流
- en: The only way to update the data in the parent component is by triggering the
    events from the child component.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 更新父组件中的数据的唯一方法是通过从子组件触发事件。
- en: Note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In contrast to React, Vue.js follows two-way data binding or bidirectional data
    flow between the components.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 与React不同，Vue.js在组件之间遵循双向数据绑定或双向数据流。
- en: What are the advantages of unidirectional data flow?
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单向数据流有哪些优点？
- en: 'The main advantage of unidirectional data flow is having a single source of
    truth for your data. There are many other advantages of the unidirectional data
    flow feature. Some of the key benefits are listed here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 单向数据流的主要优势是拥有数据的一个单一真相来源。单向数据流特性的其他优点也很多。以下列出了一些关键好处：
- en: '**Debugging**: Since the developers know where the data comes from and where
    it goes, it is much easier to debug problems'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**：由于开发者知道数据从何而来以及去向何方，因此调试问题要容易得多'
- en: '**Less error-prone**: The data flows in one direction, which makes the programs
    less error-prone and gives the developers better control'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更少错误**：数据单向流动，这使得程序更少出错，并使开发者有更好的控制'
- en: '**Efficiency**: No extra resources are wasted with the known boundaries of
    unidirectional data flow in the application'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：在应用中，单向数据流的已知边界不会浪费额外资源'
- en: You cannot always depend on the state, props, and data flow concepts to control
    the view layer. Irrespective of the JavaScript library, you may need access to
    DOM elements, and accessing elements through conventional approaches such as `document.getElementById`
    becomes cumbersome. In the next section, you will find a better alternative to
    access DOM.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能总是依赖状态、属性和数据流概念来控制视图层。无论JavaScript库如何，你可能需要访问DOM元素，而通过传统的`document.getElementById`等方式访问元素变得繁琐。在下一节中，你将找到更好的替代方法来访问DOM。
- en: How do you access DOM?
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你如何访问DOM？
- en: DOM manipulation is taken care of by the React library under the hood, without
    the need for any manual DOM updates. But sometimes, you might encounter use cases
    (focusing, scrolling to specific elements, and so on) to have DOM element access
    managed by React. As a solution to these use cases, refs have been introduced
    to access the DOM nodes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: React库在底层处理DOM操作，无需任何手动DOM更新。但有时，你可能会遇到需要由React管理DOM元素访问的情况（如聚焦、滚动到特定元素等）。为了解决这些用例，引入了refs来访问DOM节点。
- en: A React interviewer might expect a good knowledge of DOM access and possible
    use cases, both of which cannot be handled through a traditional declarative approach.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: React面试官可能期望你对DOM访问和可能的用例有很好的了解，这两者都不能通过传统的声明式方法处理。
- en: What are refs? How do you create refs?
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是refs？如何创建refs？
- en: '`current` attribute of the ref. In other words, refs are plain JavaScript objects
    with additional  current property. To understand this ref concept in a better
    way, let’s look at an example of implementing auto-focus behavior for an input
    element using a ref. To do that, we''ll follow the following instructions::'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Ref 的 `current` 属性。换句话说，refs 是具有附加 current 属性的纯 JavaScript 对象。为了更好地理解这个 ref
    概念，让我们看看使用 ref 实现输入元素自动聚焦行为的示例。为此，我们将遵循以下说明：
- en: Import the `useRef` Hook from the React library.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 React 库中导入 `useRef` Hook。
- en: Declare `inputRef` inside the `SignUpForm` component with the return value of
    the Hook.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SignUpForm` 组件内部声明 `inputRef`，并使用 Hook 的返回值。
- en: Pass `inputRef` to the `<input>` element, which connects the input’s DOM node
    to the `inputRef.current` property.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `inputRef` 传递给 `<input>` 元素，这会将输入的 DOM 节点连接到 `inputRef.current` 属性。
- en: While loading the component instance, apply focus to an input element programmatically
    by calling `focus()` on the DOM node within the `useEffect` Hook.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载组件实例时，通过在 `useEffect` Hook 中的 DOM 节点上调用 `focus()` 来程序化地将焦点应用于输入元素。
- en: 'After following all the preceding steps, the final component that’s using refs
    should look like this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循所有前面的步骤之后，使用 refs 的最终组件应该看起来像这样：
- en: '[PRE35]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Similar to how the `useRef` Hook is used in function components, `createRef`
    is typically used when creating a ref in a class component.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 与在函数组件中使用 `useRef` Hook 类似，`createRef` 通常用于在类组件中创建 ref。
- en: What is the main purpose of refs?
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Refs 的主要用途是什么？
- en: 'The main purpose of refs is to imperatively modify a child outside of the typical
    one-way data flow. A few common use cases that can be handled through refs as
    an escape hatch are discussed here:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Refs 的主要目的是在典型的单向数据流之外强制修改子组件。这里讨论了一些可以通过 refs 作为逃生口的常见用例：
- en: For the first use case, let’s talk about how UI elements are modified through
    certain events or actions. This use case category includes scenarios such as managing
    input field focus, text selection, and media control (or playback).
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第一个用例，让我们谈谈如何通过某些事件或操作修改 UI 元素。这个用例类别包括管理输入字段焦点、文本选择和媒体控制（或播放）等场景。
- en: 'As an example, let’s look at the aforementioned text selection and audio scenarios
    controlled through external button clicks:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为例子，让我们看看通过外部按钮点击控制的上述文本选择和音频场景：
- en: '[PRE36]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For the second use case, let’s talk about triggering imperative animations in
    the UI without writing any explicit animations either through CSS or JavaScript.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第二个用例，让我们谈谈在不通过 CSS 或 JavaScript 编写任何显式动画的情况下在 UI 中触发命令式动画。
- en: 'Here is an example of accessing the `div` element and finding its position
    based on the scroll event to perform certain actions in the layout:'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是一个示例，展示如何通过滚动事件访问 `div` 元素并找到其位置，以在布局中执行某些操作：
- en: '[PRE37]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For the third use case, let’s discuss integrating with third-party DOM libraries
    in a React application.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第三个用例，让我们讨论在 React 应用程序中与第三方 DOM 库的集成。
- en: It is easy to integrate an existing application with some of the JavaScript
    plugins or libraries using refs. For example, third-party plugins such as `DataTable.js`
    and `select2` can easily be accessed inside React applications without recreating
    them from scratch.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 refs 很容易将现有的应用程序与一些 JavaScript 插件或库集成。例如，第三方插件如 `DataTable.js` 和 `select2`
    可以轻松地在 React 应用程序内部访问，而无需从头开始重新创建。
- en: Note
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended to avoid refs if you can implement the task declaratively.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以声明式地实现任务，建议避免使用 refs。
- en: How do you compare refs with state?
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何比较 refs 和状态？
- en: 'Both refs and state are used to persist the component data between renders.
    However, there are many differences between them:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Refs 和状态都用于在渲染之间持久化组件数据。然而，它们之间有很多不同之处：
- en: '| **Ref** | **State** |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| **Ref** | **State** |'
- en: '| --- | --- |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Created by the `useRef(initialValue)` Hook, which returns the `{current:
    initialValue}` JavaScript object | Created by the `useState(initialValue)` Hook,
    which returns the current state value and the setter function to update the state–
    that is, `[``value, setValue]` |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 由 `useRef(initialValue)` Hook 创建，它返回 `{current: initialValue}` JavaScript
    对象 | 由 `useState(initialValue)` Hook 创建，它返回当前状态值和更新状态的设置函数–即 `[value, setValue]`
    |'
- en: '| Doesn’t trigger a re-render for any changes that are made to it | Triggers
    a re-render for any change in state |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 不会触发对其所做的任何更改的重新渲染 | 触发状态中的任何更改的重新渲染 |'
- en: '| It is often used to communicate with external APIs | It is frequently used
    within a component to change its appearance |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 它通常用于与外部 API 通信 | 它经常在组件内部使用以改变其外观 |'
- en: '| It is possible to update the `current` attribute value outside the rendering
    process – that is, ref is mutable | You should not update the state variables
    directly; a setter function should be used to modify the value – that is, state
    is immutable |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 可以在渲染过程之外更新 `current` 属性值 – 即，引用是可变的 | 你不应该直接更新状态变量；应该使用设置函数来修改值 – 即，状态是不可变的
    |'
- en: '| React cannot track ref changes | React can track state changes |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| React 无法跟踪引用变化 | React 可以跟踪状态变化 |'
- en: '| You shouldn’t read or write refs during the rendering process | You can read
    state at any time |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 在渲染过程中你不应该读取或写入引用 | 你可以在任何时候读取状态 |'
- en: '| Avoid using refs unless declarative views based on state can’t be implemented,
    since changes to the DOM structure may conflict with React’s `diff` and `update`
    approach | It’s always recommended to use state for UI updates |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 除非基于状态的声明性视图无法实现，否则应避免使用引用，因为 DOM 结构的变化可能与 React 的 `diff` 和 `update` 方法冲突
    | 始终推荐使用状态进行 UI 更新 |'
- en: 'Table 2.3: Ref versus state'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3：引用与状态
- en: Even though refs are less strict (in terms of mutation) than state, most of
    the time, you will be using state over refs because refs are an escape hatch for
    accessing the DOM, which you don’t need that often.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管引用（在可变方面）不如状态严格，但大多数时候，你将使用状态而不是引用，因为引用是访问 DOM 的逃生门，而你不需要那么频繁地这样做。
- en: Note
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are storing the information across the re-renders without rendering on
    the screen, then you should use refs. Otherwise, you always need to use state
    to store data.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在屏幕渲染之外存储信息，那么你应该使用引用。否则，你总是需要使用状态来存储数据。
- en: What are forward refs?
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前向引用是什么？
- en: Nowadays, components are more complex and barely use plain HTML elements directly.
    This leads to a parent and child component hierarchy with composable views. If
    you just try to pass down the ref to the child component as a prop, the child
    component won’t receive the actual DOM element that needs to be accessed. Instead,
    it returns `{` `current:` `null}`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，组件更加复杂，几乎不直接使用纯 HTML 元素。这导致了一个父组件和子组件的层次结构，具有可组合的视图。如果你只是尝试将引用作为属性传递给子组件，子组件将不会接收到需要访问的实际
    DOM 元素。相反，它返回 `{` `current:` `null}`。
- en: 'React’s `forwardRef` is a method that allows a parent component to pass down
    refs to its children. In the following example, the child component receivesa
    ref from its parent component by wrapping it with the `forwardRef` method. This,
    in turn, forwards it to the `<button/>` DOM element:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: React 的 `forwardRef` 是一种方法，允许父组件将其引用传递给其子组件。在下面的示例中，子组件通过使用 `forwardRef` 方法从其父组件接收一个引用，然后将其转发到
    `<button/>` DOM 元素：
- en: '[PRE38]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding child component receives a `ref` as a second argument, whereas
    the first argument refers to `props`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的子组件接收一个 `ref` 作为第二个参数，而第一个参数指的是 `props`。
- en: Note
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can limit the information you expose about your DOM node instead of passing
    the entire DOM node using the `userImperativeHandle` Hook. You will learn more
    about this Hook in [*Chapter 3*](B18603_03.xhtml#_idTextAnchor110).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `userImperativeHandle` 钩子来限制你关于 DOM 节点的信息暴露，而不是传递整个 DOM 节点。你将在 [*第 3
    章*](B18603_03.xhtml#_idTextAnchor110) 中了解更多关于这个钩子的内容。
- en: Managing state globally using the context API
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文 API 全局管理状态
- en: Context helps you share global data with the child components, even though those
    components exist at a deeper level in the component tree. You can perform state
    management for large-scale applications by using the context API and Hooks. There’s
    a high chance you’ll get interview questions related to context implementation
    to solve common use cases regarding maintaining data globally in React applications.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文可以帮助你与子组件共享全局数据，即使这些组件在组件树中存在更深的层级。你可以通过使用上下文 API 和钩子来执行大型应用的状态管理。有很大可能性你会在面试中遇到与上下文实现相关的问题，以解决有关在
    React 应用程序中全局维护数据的常见用例。
- en: What is prop drilling?
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是开孔钻探？
- en: Prop drilling refers to the process of sending props from a higher-level component
    to a lower-level component in a component tree by going through several other
    components in the middle that don’t need the data but only help in passing it
    around. This prop drilling term doesn’t exist in ReactJS officially, but it is
    frequently used to represent the situation.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 传参钻取指的是通过中间的几个组件（这些组件不需要数据，但仅帮助传递数据）将属性从组件树中的高级组件发送到低级组件的过程。这个“传参钻取”术语在ReactJS中官方并不存在，但它经常被用来表示这种情况。
- en: Can you describe context?
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能描述一下上下文吗？
- en: Context is used to solve the prop drilling issue. It provides a way to pass
    data from parent-level components to child components by storing the data in a
    central location without the need to pass the data manually at each level of the
    component tree.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文用于解决传参钻取问题。它提供了一种通过在中央位置存储数据，而不需要在组件树的每一级手动传递数据的方式来将数据从父级组件传递到子级组件。
- en: 'You can use context in React by following three simple steps:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下三个简单步骤在React中使用上下文：
- en: '`createContext(defaultValue)` factory function from the React library is used
    to create the context object. It only accepts one argument to provide the default
    value. Let’s create a user context with the default username:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自React库的`createContext(defaultValue)`工厂函数用于创建上下文对象。它只接受一个参数来提供默认值。让我们创建一个带有默认用户名的用户上下文：
- en: '[PRE39]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`Context.Provider` component needs to be applied to the parent component with
    the context changes that were supplied to its child components. The `value` prop
    on this component is used to set the context value.'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Context.Provider`组件需要应用于带有上下文更改的父组件，这些更改已提供给其子组件。此组件上的`value`属性用于设置上下文值。'
- en: 'In this step, the `username` field is going to be updated with current user
    details as context for the provider component:'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，`username`字段将更新为当前用户详情，作为提供者组件的上下文：
- en: '[PRE40]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The child components that need to consume the context should be wrapped inside
    the provider component.
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要消费上下文的子组件应该被包裹在提供者组件内部。
- en: '`useContext` Hook. This Hook returns the value of the context:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useContext`钩子。这个钩子返回上下文的值：'
- en: '[PRE41]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You will learn more about the `useContext` Hook in [*Chapter 3*](B18603_03.xhtml#_idTextAnchor110).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在[*第3章*](B18603_03.xhtml#_idTextAnchor110)中了解更多关于`useContext`钩子的内容。
- en: 'These steps have been represented with a diagram to help you understand context
    in action:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤已经用图表表示，以帮助您理解实际操作中的上下文：
- en: '![Figure 2.10: Context in action](img/Figure_02.10_B18603.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10：上下文在行动](img/Figure_02.10_B18603.jpg)'
- en: 'Figure 2.10: Context in action'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：上下文在行动
- en: What is the purpose of context?
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文的作用是什么？
- en: The main purpose of context is to allow your components to access global data
    without you facing any prop drilling problems and re-render the components when
    the global data has been changed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文的主要目的是允许您的组件访问全局数据，而不会遇到任何传参钻取问题，并且当全局数据发生变化时，不需要重新渲染组件。
- en: 'Here are some of the common use cases of context:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些上下文的常见用例：
- en: Theme information for applying branding to the entire application
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序主题信息，用于将品牌应用于整个应用程序
- en: Authenticated user profile information
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证用户配置文件信息
- en: User settings
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户设置
- en: Preferred language settings
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏好语言设置
- en: Application configuration
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序配置
- en: So far, we’ve learned how to render the React application on the client side.
    In the next section, you will learn how to render web content on the server side
    to improve page loading speed, along with a few other benefits.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何在客户端渲染React应用程序。在下一节中，您将学习如何通过服务器端渲染Web内容来提高页面加载速度，以及一些其他好处。
- en: Understanding the server-side rendering technique
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务器端渲染技术
- en: '**SSR** is rapidly becoming a more prominent feature in JavaScript libraries
    and frameworks. React-based frameworks such as Next.js, Gatsby, and others make
    creating SSR much easier. Nowadays, interviewers expect a good knowledge of SSR,
    along with regular **CSR**.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSR**正迅速成为JavaScript库和框架中一个更加突出的特性。基于React的框架，如Next.js、Gatsby等，使得创建SSR变得更加容易。如今，面试官期望应聘者对SSR有很好的了解，以及常规的**CSR**。'
- en: What is server-side rendering?
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染是什么？
- en: SSR is a popular alternative rendering method for **single-page applications**
    (**SPAs**). This technique renders a client-side SPA on the server and then sends
    a fully rendered HTML page to the client. This is helpful for SEO purposes because
    search engines can easily find the content first before they send the page to
    the users.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: SSR是**单页应用**（**SPAs**）的一种流行的替代渲染方法。这种技术将在服务器上渲染客户端SPA，然后将完全渲染的HTML页面发送到客户端。这对于SEO来说很有帮助，因为搜索引擎可以在将页面发送给用户之前先轻松找到内容。
- en: What is the main difference between server-side rendering and client-side rendering?
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染和客户端渲染之间主要区别是什么？
- en: CSR is the rendering mode in which the browser downloads a minimal HTML page
    and it renders using JavaScript. The data fetching, templating, and routing processes
    are handled on the client side – that is, by the browser.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: CSR是一种渲染模式，其中浏览器下载一个最小的HTML页面，并使用JavaScript进行渲染。数据获取、模板化和路由过程由客户端处理——即浏览器处理。
- en: SSR, on the other hand, converts HTML files on the server into a fully rendered
    HTML page that includes the data for the client.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，SSR将服务器上的HTML文件转换为包含客户端数据的完全渲染的HTML页面。
- en: When do you need to use server-side rendering?
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时需要使用服务器端渲染？
- en: 'Which rendering method is used depends on the requirements of the business.
    But here, we have mentioned a few situations where you can consider using SSR:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种渲染方法被使用取决于业务需求。但在这里，我们提到了一些可以考虑使用SSR的情况：
- en: If you are prioritizing SEO and building a blog site, it is recommended to use
    SSR
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您优先考虑SEO并构建博客网站，建议使用SSR
- en: If your website needs a faster initial page load time
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的网站需要更快的初始页面加载时间
- en: If the application has a simple UI with less interactivity with a smaller number
    of features and pages
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序具有简单的UI，与较少的功能和页面交互性较小
- en: If the application contains less dynamic data
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序包含较少的动态数据
- en: If the user traffic on the website is less
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果网站的用户流量较少
- en: A few other pre-rendering techniques are also available, such as **static site
    generation** (**SSG**) and **incremental static regeneration** (**ISR**), both
    of which will be discussed in [*Chapter 9*](B18603_09.xhtml#_idTextAnchor276).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他预渲染技术，例如**静态站点生成**（**SSG**）和**增量静态再生**（**ISR**），这两者将在[*第9章*](B18603_09.xhtml#_idTextAnchor276)中讨论。
- en: We have now answered a lot of fundamental questions about React. This knowledge
    also acts as a foundation for answering the next stage of questions in the upcoming
    chapters.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经回答了关于React的许多基本问题。这些知识也作为回答即将到来的章节中下一阶段问题的基础。
- en: Summary
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed a lot of fundamental concepts that are frequently
    asked about in React interviews. We started by introducing ReactJS and JSX and
    discussing their advantages in building robust web applications. Then, we went
    on to talk about the core building blocks of ReactJS, such as elements, components,
    props, and state, and how the virtual DOM and one-way data flow work behind the
    scenes.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多在React面试中经常被问到的基础概念。我们首先介绍了ReactJS和JSX，并讨论了它们在构建健壮的Web应用程序中的优势。然后，我们继续讨论ReactJS的核心构建块，如元素、组件、属性和状态，以及虚拟DOM和单向数据流在幕后是如何工作的。
- en: Lastly, we covered questions related to an application’s interaction through
    event handling and how to share data globally using context and SSR in the React
    ecosystem. In the next chapter, we will consider questions related to Hooks, their
    importance, and how Hooks make React so much better by implementing functionalities
    faster and more effectively.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了与通过事件处理与应用程序交互相关的问题，以及如何在React生态系统中使用上下文和SSR来全局共享数据。在下一章中，我们将考虑与Hooks相关的问题，它们的重要性以及Hooks如何通过更快、更有效地实现功能来使React变得更好。
