- en: '*Chapter 1*: What Is Micro State Management with React Hooks?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*: 什么是使用 React 钩子的微状态管理？'
- en: '**State management** is one of the most important topics in developing React
    apps. Traditionally, state management in React was something monolithic, providing
    a general framework for state management, and with developers creating purpose-specific
    solutions within the framework.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态管理**是开发 React 应用程序中最重要的话题之一。传统上，React 中的状态管理是某种单体结构，提供了一个通用的状态管理框架，并且开发者在框架内创建特定目的的解决方案。'
- en: The situation changed after **React hooks** landed. We now have primitive hooks
    for state management that are reusable and can be used as building blocks to create
    richer functionalities. This allows us to make state management lightweight or,
    in other words, micro. **Micro state management** is more purpose-oriented and
    used with specific coding patterns, whereas monolithic state management is more
    general.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**React hooks** 的引入改变了情况。我们现在有用于状态管理的原始钩子，它们是可重用的，可以用作构建更丰富功能的基石。这使得我们可以使状态管理变得轻量级，换句话说，就是微状态管理。**微状态管理**更具有目的性，并与特定的编码模式一起使用，而单体状态管理则更通用。'
- en: In this book, we will explore various patterns of state management with React
    hooks. Our focus is on global states, in which multiple components can share a
    state. React hooks already provide good functionality for local states—that is,
    states within a single component or a small tree of components. **Global states**
    are a hard topic in React because React hooks are missing the capability to directly
    provide global states; it's instead left to the community and ecosystem to deal
    with them. We will also explore some existing libraries for micro state management,
    each of which has different purposes and patterns; in this book, we will discuss
    Zustand, Jotai, Valtio, and React Tracked.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将探讨使用 React 钩子的各种状态管理模式。我们的重点是全局状态，其中多个组件可以共享状态。React 钩子已经为局部状态提供了良好的功能——即单个组件或小型组件树内的状态。**全局状态**是
    React 中的一个难题，因为 React 钩子缺少直接提供全局状态的能力；相反，这留给了社区和生态系统来处理。我们还将探讨一些现有的微状态管理库，每个库都有不同的用途和模式；在这本书中，我们将讨论
    Zustand、Jotai、Valtio 和 React Tracked。
- en: Important Note
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This book focuses on a global state and doesn't discuss "general" state management,
    which is a separate topic. One of the most popular state management libraries
    is Redux ([https://redux.js.org](https://redux.js.org)), which uses a one-way
    data model for state management. Another popular library is XState ([https://xstate.js.org](https://xstate.js.org)),
    which is an implementation of statecharts, a visual representation of complex
    states. Both provide sophisticated methods to manage states, which are out of
    the scope of this book. On the other hand, such libraries also have a capability
    for a global state. For example, React Redux ([https://react-redux.js.org](https://react-redux.js.org))
    is a library to bind React and Redux for a global state, which is in the scope
    of this book. To keep the focus of the book only on a global state, we don't specifically
    discuss React Redux, which is tied to Redux.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书专注于全局状态，不讨论“通用”状态管理，这是一个独立的话题。最受欢迎的状态管理库之一是 Redux ([https://redux.js.org](https://redux.js.org))，它使用单向数据模型进行状态管理。另一个流行的库是
    XState ([https://xstate.js.org](https://xstate.js.org))，它是状态图的实现，是复杂状态的视觉表示。两者都提供了管理状态的高级方法，但这本书的范围之外。另一方面，这些库也具备全局状态的能力。例如，React
    Redux ([https://react-redux.js.org](https://react-redux.js.org)) 是一个将 React 和
    Redux 绑定以用于全局状态的库，这属于本书的范围。为了使本书只关注全局状态，我们不特别讨论与 Redux 相关的 React Redux。
- en: In this chapter, we will define what micro state management is, discuss how
    React hooks allow micro state management, and why global states are challenging.
    We will also recap the basic usage of two hooks for state management and compare
    their similarity and differences.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将定义什么是微状态管理，讨论 React 钩子如何允许微状态管理，以及为什么全局状态具有挑战性。我们还将回顾两个用于状态管理的基本钩子的用法，并比较它们的相似之处和不同之处。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding micro state management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解微状态管理
- en: Working with hooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用钩子
- en: Exploring global states
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索全局状态
- en: Working with `useState`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useState`
- en: Using `useReducer`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useReducer`
- en: Exploring the similarities and differences between `useState` and `useReducer`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 `useState` 和 `useReducer` 之间的相似之处和不同之处
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run code snippets, you need a React environment—for example, Create React
    App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码片段，你需要一个 React 环境——例如，Create React App ([https://create-react-app.dev](https://create-react-app.dev))
    或 CodeSandbox ([https://codesandbox.io](https://codesandbox.io))。
- en: 'You are expected to have basic knowledge of React and React hooks. More precisely,
    you should already be familiar with the official React documentation, which you
    can find here: [https://reactjs.org/docs/getting-started.html](https://reactjs.org/docs/getting-started.html).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 预期你已经具备 React 和 React hooks 的基本知识。更准确地说，你应该已经熟悉官方的 React 文档，你可以在这里找到：[https://reactjs.org/docs/getting-started.html](https://reactjs.org/docs/getting-started.html)。
- en: We don't use class components and it's not necessary to learn them unless you
    need to learn some existing code with class components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用类组件，除非你需要学习带有类组件的现有代码，否则没有必要学习它们。
- en: The code in this chapter is available on GitHub at [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_01](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_01).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_01](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_01)。
- en: Understanding micro state management
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解微状态管理
- en: What is micro state management? There is no officially established definition
    yet; however, let's try defining one here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是微状态管理？目前还没有官方确立的定义；然而，让我们在这里尝试定义一个。
- en: Important Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This definition may not reflect community standards in the future.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义可能不会在未来反映社区标准。
- en: '**State**, in React, is any data that represents the **user interface** (**UI**).
    States can change over time, and React takes care of components to render with
    the state.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，**状态**是指任何代表**用户界面**（**UI**）的数据。状态会随时间变化，React 负责确保组件根据状态进行渲染。
- en: 'Before we had React hooks, using monolithic state libraries was a popular pattern.
    A single state covers many purposes for better developer experience, but sometimes
    it was overkill because the monolithic state libraries can contain unused functionalities.
    With hooks, we have a new way to create states. This allows us to have different
    solutions for each specific purpose that you need. Here are some examples of this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们拥有 React hooks 之前，使用单体状态库是一种流行的模式。单一状态覆盖了许多用途，从而提高了开发者的体验，但有时这可能是过度设计，因为单体状态库可能包含未使用的功能。有了
    hooks，我们有了创建状态的新方法。这使我们能够为每个特定的目的提供不同的解决方案。以下是一些例子：
- en: Form state should be treated separately from a global state, which is not possible
    with a single-state solution.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单状态应该与全局状态分开处理，而单状态解决方案是无法做到这一点的。
- en: Server cache state has some unique characteristics, such as refetching, which
    is a different feature from other states.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器缓存状态有一些独特的特性，例如重新获取，这是与其他状态不同的功能。
- en: Navigation state has a special requirement that the original state resides on
    the browser end and, again, a single-state solution doesn't fit.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航状态有特殊要求，即原始状态位于浏览器端，再次强调，单状态解决方案不适用。
- en: Fixing these issues is one of the goals of React hooks. The trend with React
    hooks is to handle various states with special solutions for them. There are many
    hook-based libraries to solve things such as form state, server cache state, and
    so on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题是 React hooks 的一个目标。React hooks 的趋势是针对各种状态使用专门的解决方案。有许多基于 hooks 的库可以解决诸如表单状态、服务器缓存状态等问题。
- en: There's still a need for general state management, as we will need to deal with
    states that are not covered by purpose-oriented solutions. The proportion of work
    left for general state management varies on apps. For example, an app that mainly
    deals with server states would require only one or a few small global states.
    On the other hand, a rich graphical app would require many large global states
    compared to server states required in the app.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然需要通用状态管理，因为我们还需要处理那些未被目的导向解决方案覆盖的状态。通用状态管理的工作量在应用程序中各不相同。例如，主要处理服务器状态的应用程序可能只需要一个或几个小的全局状态。另一方面，与该应用程序中所需的服务器状态相比，一个丰富的图形应用程序可能需要更多的全局状态。
- en: Hence, solutions for general state management should be lightweight, and developers
    can choose one based on their requirements. This is what we call micro state management.
    To define this concept, it's lightweight state management in React, where each
    solution has several different features, and developers can choose one from possible
    solutions depending on app requirements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通用状态管理的解决方案应该是轻量级的，开发者可以根据自己的需求选择一个。这就是我们所说的微状态管理。为了定义这个概念，它是在 React 中的轻量级状态管理，其中每个解决方案都有几个不同的特性，开发者可以根据应用需求从可能的解决方案中选择一个。
- en: 'Micro state management can have several requirements, to fulfill developers''
    various needs. There are base state management requirements, to do things such
    as these:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 微状态管理可能有多个要求，以满足开发者各种需求。有基础状态管理需求，例如做以下这些事情：
- en: Read state
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取状态
- en: Update state
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新状态
- en: Render with state
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态渲染
- en: 'But there may be additional requirements to do other things, such as these:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，可能还有其他额外的要求，例如以下这些：
- en: Optimize re-renders
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化重新渲染
- en: Interact with other systems
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他系统交互
- en: Async support
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步支持
- en: Derived state
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生状态
- en: Simple syntax; and so on
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的语法；等等
- en: However, we don't need all features, and some of them may conflict. Hence, a
    micro state management solution cannot be a single solution either. There are
    multiple solutions for different requirements.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不需要所有功能，其中一些可能存在冲突。因此，微状态管理解决方案也不能是一个单一的解决方案。针对不同的需求，有多个解决方案。
- en: Another aspect to mention regarding micro state management and its library is
    its learning curve. Ease of learning is important for general state management
    too, but as the use cases covered by micro state management can be smaller, it
    should be easier to learn. An easier learning curve will result in a better developer
    experience and more productivity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关于微状态管理和其库的另一个需要提及的方面是其学习曲线。易于学习对于通用状态管理也很重要，但由于微状态管理覆盖的使用案例可能较小，因此应该更容易学习。更简单的学习曲线将导致更好的开发者体验和更高的生产力。
- en: In this section, we discussed what micro state management is. Coming up, we
    will see an overview of some hooks that handle states.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了什么是微状态管理。接下来，我们将看到一些处理状态的钩子的概述。
- en: Working with hooks
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与钩子一起工作
- en: 'React hooks are essential for micro statement management. React hooks include
    some primitive hooks to implement state management solutions, such as the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: React 钩子对于微状态管理至关重要。React 钩子包括一些原始钩子，用于实现状态管理解决方案，例如以下这些：
- en: The `useState` hook is a basic function to create a local state. Thanks to React
    hooks' composability, we can create a custom hook that can add various features
    based on `useState`.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState` 钩子是一个创建局部状态的基本函数。得益于 React 钩子的可组合性，我们可以创建一个自定义钩子，它可以基于 `useState`
    添加各种功能。'
- en: The `useReducer` hook can create a local state too and is often used as a replacement
    for `useState`. We will revisit these hooks to learn about the similarities and
    differences between `useState` and `useReducer` later in this chapter.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useReducer` 钩子也可以创建局部状态，通常用作 `useState` 的替代品。我们将在本章后面重新审视这些钩子，以了解 `useState`
    和 `useReducer` 之间的相似之处和不同之处。'
- en: The `useEffect` hook allows us to run logic outside the React render process.
    It's especially important to develop a state management library for a global state
    because it allows us to implement features that work with the React component
    lifecycle.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子允许我们在 React 渲染过程之外运行逻辑。对于开发全局状态管理库来说，这尤为重要，因为它使我们能够实现与 React
    组件生命周期协同工作的功能。'
- en: 'The reason why React hooks are novel is that they allow you to extract logic
    out of UI components. For example, the following is a counter example of the simple
    usage of the `useState` hook:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: React 钩子之所以新颖，是因为它们允许你从 UI 组件中提取逻辑。例如，以下是一个 `useState` 钩子简单使用的计数器示例：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s see how we can extract logic. Using the same counter example, we
    will create a custom hook named `useCount`, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何提取逻辑。使用相同的计数器示例，我们将创建一个自定义钩子，命名为 `useCount`，如下所示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It doesn''t change a lot, and some of you may think this is overcomplicated.
    However, there are two points to note, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它的变化不大，有些人可能会认为这过于复杂。然而，有两个要点需要注意，如下所述：
- en: We now have a clearer name—`useCount`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在有一个更清晰的名字——`useCount`。
- en: '`Component` is independent of the implementation of `useCount`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Component` 与 `useCount` 的实现无关。'
- en: The first point is very important for programming in general. If we name the
    custom hook properly, the code is more readable. Instead of `useCount`, you could
    name it `useScore`, `usePercentage`, or `usePrice`. Even though they have the
    same implementations, if the name is different, we consider it a different hook.
    Naming things is very important.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点对于一般编程来说非常重要。如果我们正确命名自定义钩子，代码就更容易阅读。例如，你可能会将 `useCount` 命名为 `useScore`、`usePercentage`
    或 `usePrice`。尽管它们有相同的实现，但如果名称不同，我们就会将其视为不同的钩子。命名事物非常重要。
- en: The second point is also important when it comes to micro state management libraries.
    As `useCount` is extracted from `Component`, we can add functionality without
    breaking the component.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到微状态管理库时，第二点也很重要。由于 `useCount` 是从 `Component` 中提取出来的，我们可以添加功能而不会破坏组件。
- en: 'For example, we want to output a debug message on the console when the count
    is changed. To do so, we would execute the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当计数改变时，我们想在控制台输出一个调试信息。为此，我们将执行以下代码：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By just changing `useCount`, we can add a feature of showing a debug message.
    We do not need to change the component. This is the benefit of extracting logic
    as custom hooks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 只需更改 `useCount`，我们就可以添加显示调试信息的特性。我们不需要更改组件。这就是将逻辑提取为自定义钩子的好处。
- en: 'We could also add a new rule. Suppose we don''t want to allow the count to
    change arbitrarily, but only by increments of one. The following custom hook does
    the job:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一条新规则。假设我们不想允许计数任意改变，而只想通过每次增加一来改变。以下自定义钩子完成了这项工作：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This opens up the entire ecosystem to provide custom hooks for various purposes.
    They can be a wrapper to add a tiny functionality or a huge hook that has a larger
    job.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这为整个生态系统提供了提供各种目的的自定义钩子打开了大门。它们可以是添加微小功能的包装器，也可以是执行更大任务的巨大钩子。
- en: You will find many custom hooks publicly available on **Node Package Manager**
    (**npm**) ([https://www.npmjs.com/search?q=react%20hooks](https://www.npmjs.com/search?q=react%20hooks))
    or GitHub ([https://github.com/search?q=react+hooks&type=repositories](https://github.com/search?q=react+hooks&type=repositories)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在公共领域找到许多自定义钩子，这些钩子可以在 **Node 包管理器**（**npm**）([https://www.npmjs.com/search?q=react%20hooks](https://www.npmjs.com/search?q=react%20hooks))
    或 GitHub ([https://github.com/search?q=react+hooks&type=repositories](https://github.com/search?q=react+hooks&type=repositories))
    上找到。
- en: We should also discuss a little about suspense and concurrent rendering, as
    React hooks are designed and developed to work with these modes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该稍微讨论一下 suspense 和并发渲染，因为 React hooks 是设计和开发来与这些模式一起工作的。
- en: Suspense for Data Fetching and Concurrent Rendering
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据获取和并发渲染的 suspense
- en: Suspense for Data Fetching and Concurrent Rendering are not yet released by
    React, but it's important to mention them briefly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取和并发渲染的 suspense 尚未由 React 发布，但简要提及它们是很重要的。
- en: Important Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Suspense for Data Fetching and Concurrent Rendering may have different names
    when they are officially released, but these are the names at the time of writing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取和并发渲染的 suspense 在正式发布时可能会有不同的名称，但这些都是写作时的名称。
- en: '`async`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`。'
- en: '**Concurrent Rendering** is a mechanism to split the render process into chunks
    to avoid blocking the **central processing unit** (**CPU**) for long periods of
    time.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发渲染**是一种将渲染过程分割成块以避免长时间阻塞**中央处理器**（**CPU**）的机制。'
- en: React hooks are designed to work with these mechanisms; however, you need to
    avoid misusing them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: React hooks 是设计来与这些机制一起工作的；然而，你需要避免误用它们。
- en: For example, one rule is that you should not mutate an existing `state` object
    or `ref` object. Doing so may lead to unexpected behavior such as not triggering
    re-renders, triggering too many re-renders, and triggering partial re-renders
    (meaning some components re-render while others don't when they should).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一条规则是你不应该修改现有的 `state` 对象或 `ref` 对象。这样做可能会导致意外的行为，例如不触发重新渲染、触发过多的重新渲染，以及触发部分重新渲染（意味着当应该重新渲染时，一些组件重新渲染而其他组件没有）。
- en: Hook functions and component functions can be invoked multiple times. Hence,
    another rule is those functions have to be "pure" enough so that they behave consistently,
    even if they are invoked several times.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子函数和组件函数可以被多次调用。因此，另一个规则是这些函数必须足够“纯”，以便它们在多次调用时表现一致。
- en: These are the two major rules people often violate. This is a hard problem in
    practice, because even if your code violates those rules, it may just work in
    Non-Concurrent Rendering. Hence, people wouldn't notice the misuse. Even in Concurrent
    Rendering, it may work to some extent without problems, and people would only
    see problems occasionally. This makes it especially difficult for beginners who
    are using React for the first time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是人们经常违反的两个主要规则。在实践中，这是一个难题，因为即使你的代码违反了这些规则，在非并发渲染中也可能只是工作，人们就不会注意到误用。即使在并发渲染中，也可能在一定程度上没有问题，人们只会偶尔看到问题。这使得对于第一次使用React的初学者来说尤其困难。
- en: Unless you are familiar with these concepts, it's better to use well-designed
    and battle-tested (micro) state management libraries for future/newer versions
    of React.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你熟悉这些概念，否则最好使用经过良好设计和实战检验的（微）状态管理库来处理React的未来/较新版本。
- en: Important Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'As of writing, Concurrent Rendering is described in the *React 18 Working Group*,
    which you can read about here: [https://github.com/reactwg/react-18/discussions](https://github.com/reactwg/react-18/discussions).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，并发渲染在*React 18工作组*中有所描述，您可以在以下链接中了解更多信息：[https://github.com/reactwg/react-18/discussions](https://github.com/reactwg/react-18/discussions)。
- en: In this section, we revisited basic React hooks and got some understanding of
    the concepts. Coming up, we start exploring global states, which are the main
    topic in this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了基本的React钩子，并对概念有了更深入的理解。接下来，我们将开始探索全局状态，这是本书的主要内容。
- en: Exploring global states
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索全局状态
- en: React provides primitive hooks such as `useState` for states that are defined
    in a component and consumed within the component tree. These are often called
    local states.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: React为在组件中定义并在组件树内使用的状态提供了原始的钩子，如`useState`。这些通常被称为局部状态。
- en: 'The following example uses a local state:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用局部状态：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On the other hand, a global state is a state that is consumed in multiple components,
    often far apart in an app. A global state doesn't have to be a singleton, and
    we may call a global state a shared state instead, to clarify that it's not a
    singleton.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，全局状态是一种在多个组件中使用的状态，通常在应用程序中相隔甚远。全局状态不一定是单例的，我们可能将全局状态称为共享状态，以明确它不是单例。
- en: 'The following code snippet provides an example of what a React component would
    look like with a global state:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段提供了一个React组件具有全局状态的示例：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we haven't yet defined `useGlobalState`, it won't work. In this case, we
    want `Component1` and `Component2` to have the same state.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未定义`useGlobalState`，它将不起作用。在这种情况下，我们希望`Component1`和`Component2`具有相同的状态。
- en: Implementing global states in React is not a trivial task. This is mostly because
    React is based on the component model. In the component model, locality is important,
    meaning a component should be isolated and should be reusable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中实现全局状态并非易事。这主要是因为React基于组件模型。在组件模型中，局部性很重要，这意味着组件应该是隔离的，并且应该是可重用的。
- en: Notes about the Component Model
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于组件模型的注意事项
- en: A component is a reusable piece of a unit, like a function. If you define a
    component, it can be used many times. This is only possible if a component definition
    is self-contained. If a component depends on something outside, it may not be
    reusable because its behavior can be inconsistent. Technically, a component itself
    should not depend on a global state.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是单元的可重用部分，就像一个函数。如果你定义了一个组件，它可以被多次使用。这只有在组件定义是自包含的情况下才可能。如果组件依赖于外部的东西，它可能不可重用，因为它的行为可能不一致。技术上，组件本身不应该依赖于全局状态。
- en: 'React doesn''t provide a direct solution for a global state, and it seems up
    to the developers and the community. Many solutions have been proposed, and each
    has its pros and cons. The goal of this book is to show typical solutions and
    discuss these pros and cons, which we will do in the following chapters:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: React没有提供全局状态的直接解决方案，这似乎取决于开发者和社区。已经提出了许多解决方案，每个都有其优缺点。本书的目标是展示典型解决方案并讨论这些优缺点，我们将在接下来的章节中这样做：
- en: '[*Chapter 3*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049), *Sharing Component
    State with Context*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第3章*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049)，*使用上下文共享组件状态*'
- en: '[*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066), *Sharing Module
    State with Subscription*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066)，*使用订阅共享模块状态*'
- en: '[*Chapter 5*](B17780_05_Final_VK_ePub.xhtml#_idTextAnchor073), *Sharing Component
    State with Context and Subscription*'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B17780_05_Final_VK_ePub.xhtml#_idTextAnchor073)，*使用上下文和订阅共享组件状态*'
- en: In this section, we learned what a global state with React hooks would look
    like. Coming up, we will learn some basics of `useState` to prepare the discussion
    in the following chapters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了使用React hooks的全局状态会是什么样子。接下来，我们将学习一些`useState`的基础知识，为下一章的讨论做准备。
- en: Working with useState
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用useState
- en: In this section, we will learn how to use `useState`, from basic usage to advanced
    usage. We start with the simplest form, which is updating with the state with
    a new value, then updating with a function, which is a very powerful feature,
    and finally, we will discuss lazy initialization.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用`useState`，从基本用法到高级用法。我们从一个最简单的形式开始，即使用新值更新状态，然后是使用函数更新，这是一个非常强大的功能，最后我们将讨论懒初始化。
- en: Updating the state value with a value
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用值更新状态值
- en: One way to update the state value with `useState` is by providing a new value.
    You can pass a new value to the function returned by `useState` that will eventually
    replace the state value with the new value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useState`更新状态值的一种方法是通过提供一个新值。你可以向`useState`返回的函数传递一个新值，这将最终用新值替换状态值。
- en: 'Here is a counter example showing updating with a value:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个显示使用值更新的反例：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You pass a value of `1` to `setCount` in the `onClick` handler. If you click
    the button, it will trigger `Component` to re-render with `count=1`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`onClick`处理程序中将值`1`传递给`setCount`。如果你点击按钮，它将触发`Component`重新渲染，`count=1`。
- en: What would happen if you clicked the button again? It will invoke `setCount(1)`
    again, but as it is the same value, it "bails out" and the component won't re-render.
    **Bailout** is a technical term in React and basically means avoiding triggering
    re-renders.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次点击按钮会发生什么？它将再次调用`setCount(1)`，但由于值相同，它“退出”并且组件不会重新渲染。**退出**是React中的一个技术术语，基本上意味着避免触发重新渲染。
- en: 'Let''s look at another example here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里看看另一个例子：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This behaves exactly the same as the previous example for the first click;
    however, if you click the button again, the component will re-render. You don''t
    see any difference on screen because the count hasn''t changed. This happens because
    the second click creates a new object, `{ count: 1 }`, and it''s different from
    the previous object.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '对于第一次点击，这与前面的例子行为完全相同；然而，如果你再次点击按钮，组件将重新渲染。你不会在屏幕上看到任何差异，因为计数没有变化。这是因为第二次点击创建了一个新的对象，`{
    count: 1 }`，它与前一个对象不同。'
- en: 'Now, this leads to the following bad practice:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这会导致以下不良做法：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This doesn't work as expected. Even if you click the button, it won't re-render.
    This is because the state object is referentially unchanged, and it bails out,
    meaning this alone doesn't trigger the re-render.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这不符合预期。即使你点击按钮，它也不会重新渲染。这是因为状态对象在引用上没有改变，并且它退出了，这意味着这本身不会触发重新渲染。
- en: 'Finally, there''s an interesting usage of value update, which we can see here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个关于值更新的有趣用法，我们在这里可以看到：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Clicking the button will increment the count; however, if you click the button
    twice quickly enough, it will increment by just one number. This is sometimes
    desirable as it matches with the button title, but sometimes it's not if you expect
    to count how many times the button is actually clicked. That requires a function
    update.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮将增加计数；然而，如果你足够快地连续点击两次按钮，它将只增加一个数字。这有时是可取的，因为它与按钮标题匹配，但有时不是，如果你期望计算按钮实际被点击的次数。这需要函数更新。
- en: Updating the state value with a function
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数更新状态值
- en: Another way to update the state with `useState` is called a function update.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useState`更新状态的另一种方法称为函数更新。
- en: 'Here is a counter example showing updating with a function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个显示使用函数更新的反例：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This actually counts how many times the button is clicked, because `(c) => c
    + 1` is invoked sequentially. As we saw in the previous section, value update
    has the same use case as the `Set Count to {count + 1}` feature. In most use cases,
    function updates work better if the update is based on the previous value. The
    `Set Count to {count + 1}` feature actually means that it doesn't depend on the
    previous value but depends on the displayed value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上计算了按钮被点击的次数，因为`(c) => c + 1`是按顺序调用的。正如我们在前面的章节中看到的，值更新与`Set Count to {count
    + 1}`功能具有相同的使用场景。在大多数情况下，如果更新基于前一个值，函数更新工作得更好。`Set Count to {count + 1}`功能实际上意味着它不依赖于前一个值，而是依赖于显示的值。
- en: 'Bailout is also possible with function updates. Here''s an example to demonstrate
    this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数更新也可能发生退出。以下是一个演示此点的例子：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the update function returns the exact same state as the previous state, it
    will bail out, and this component won't re-render. For example, if you invoke
    `setCount((c) => c)`, it will never re-render.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更新函数返回与上一个状态完全相同的状态，它将退出，并且这个组件不会重新渲染。例如，如果你调用 `setCount((c) => c)`，它将永远不会重新渲染。
- en: Lazy initialization
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒初始化
- en: '`useState` can receive a function for initialization that will be evaluated
    only in the first render. We can do something like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` 可以接收一个初始化函数，该函数只会在第一次渲染时评估。我们可以这样做：'
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The use of `init` in this example is not very effective because returning `0`
    doesn't require much computation, but the point is that the `init` function can
    include heavy computation and is only invoked to get the initial state. The `init`
    function is evaluated lazily, not evaluated before calling `useState`; in other
    words, it's invoked just once on `mount`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`init` 的使用并不非常有效，因为返回 `0` 不需要太多的计算，但重点是 `init` 函数可以包含复杂的计算，并且只被调用以获取初始状态。`init`
    函数是懒加载的，不是在调用 `useState` 之前评估；换句话说，它只在 `mount` 时调用一次。
- en: We have now learned how to use `useState`; next up is `useReducer`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何使用 `useState`；接下来是 `useReducer`。
- en: Using useReducer
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `useReducer`
- en: In this section, we will learn how to use `useReducer`. We will learn about
    its typical usage, how to bail out, its usage with primitive values, and lazy
    initialization.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 `useReducer`。我们将了解其典型用法、如何退出、使用原始值以及懒初始化。
- en: Typical usage
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 典型用法
- en: 'A reducer is helpful for complex states. Here''s a simple example a with two-property
    object:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer 对于复杂的状态很有帮助。这里是一个具有两个属性对象的简单示例：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`useReducer` allows us to define a reducer function in advance by taking the
    defined reducer function and initial state in parameters. The benefit of defining
    a reducer function outside the hook is being able to separate code and testability.
    Because the reducer function is a pure function, it''s easier to test its behavior.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer` 允许我们通过将定义的 reducer 函数和初始状态作为参数来预先定义一个 reducer 函数。定义 reducer 函数在
    hook 之外的好处是能够分离代码和可测试性。因为 reducer 函数是一个纯函数，所以更容易测试其行为。'
- en: Bailout
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退出
- en: 'As well as `useState`, bailout works with `useReducer` too. Using the previous
    example, let''s modify the reducer so that it will bail out if `action.text` is
    empty, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `useState` 一样，退出也适用于 `useReducer`。使用之前的示例，让我们修改 reducer，使其在 `action.text`
    为空时退出，如下所示：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice that returning `state` itself is important. If you return `{ ...state,
    text: action.text || state.text }` instead, it won''t bail out because it''s creating
    a new object.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '注意返回 `state` 本身是很重要的。如果你返回 `{ ...state, text: action.text || state.text }`
    而不是，它不会退出，因为它正在创建一个新的对象。'
- en: Primitive value
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始值
- en: '`useReducer` works for non-object values, which are primitive values such as
    numbers and strings. `useReducer` with primitive values is still useful as we
    can define complex reducer logic outside it.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer` 适用于非对象值，如数字和字符串等原始值。使用原始值的 `useReducer` 仍然很有用，因为我们可以在它之外定义复杂的
    reducer 逻辑。'
- en: 'Here is a reducer example with a single number:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个只有一个数字的 reducer 示例：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that the action (= `delta`) doesn't have to have an object either. In
    this reducer example, the state value is a number—a primitive value—but the logic
    is a little more complex, with more conditions than just adding numbers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，动作（即 `delta`）也不一定需要是对象。在这个 reducer 示例中，状态值是一个数字——一个原始值，但逻辑要复杂一些，条件比仅仅加法要多。
- en: Lazy initialization (init)
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒初始化（init）
- en: '`useReducer` requires two parameters. The first is a reducer function and the
    second is an initial state. `useReducer` accepts an optional third parameter,
    which is called `init`, for lazy initialization.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer` 需要两个参数。第一个是一个 reducer 函数，第二个是一个初始状态。`useReducer` 接受一个可选的第三个参数，称为
    `init`，用于懒初始化。'
- en: 'For example, `useReducer` can be used like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`useReducer` 可以这样使用：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `init` function is invoked just once on `mount`, so it can include heavy
    computation. Unlike `useState`, the `init` function takes a second argument—`initialArg`—in
    `useReducer`, which is `0` in the previous example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 函数只在 `mount` 时调用一次，因此它可以包含复杂的计算。与 `useState` 不同，`init` 函数在 `useReducer`
    中接受第二个参数——`initialArg`——在之前的示例中是 `0`。'
- en: Now we have looked at `useState` and `useReducer` separately, it's time to compare
    them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经单独探讨了 `useState` 和 `useReducer`，是时候比较它们了。
- en: Exploring the similarities and differences between useState and useReducer
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 useState 和 useReducer 之间的相似之处和不同之处
- en: In this section, we demonstrate some similarities and differences between `useState`
    and `useReducer`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了 `useState` 和 `useReducer` 之间的相似之处和不同之处。
- en: Implementing useState with useReducer
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `useReducer` 实现 `useState`
- en: Implementing `useState` with `useReducer` instead is 100% possible. Actually,
    it's known that `useState` is implemented with `useReducer` inside React.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 用 `useReducer` 替代 `useState` 实现 100% 是可能的。实际上，已知 `useState` 在 React 中是用 `useReducer`
    实现的。
- en: Important Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This may not hold in the future as `useState` could be implemented more efficiently.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在未来不会成立，因为 `useState` 可能会被更有效地实现。
- en: 'The following example shows how to implement `useState` with `useReducer`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用 `useReducer` 实现 `useState`：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This can then be simplified and improved upon, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简化并改进如下：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we proved that what you can do with `useState` can be done with `useReducer`.
    So, wherever you have `useState`, you can just replace it with `useReducer`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们证明了你可以用 `useReducer` 实现用 `useState` 能做到的事情。所以，无论你在哪里使用 `useState`，你都可以直接替换成
    `useReducer`。
- en: Implementing useReducer with useState
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `useState` 实现 `useReducer`
- en: Now, let's explore if the opposite is possible—can we replace all instances
    of `useReducer` with `useState`? Surprisingly, it's almost true. "Almost" means
    there are subtle differences. But in general, people expect `useReducer` to be
    more flexible than `useState`, so let's see if `useState` is flexible enough in
    reality.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索是否可能相反——我们能否用 `useState` 替换所有 `useReducer` 的实例？令人惊讶的是，几乎可以。这里的“几乎”意味着存在细微的区别。但总的来说，人们期望
    `useReducer` 比起 `useState` 更灵活，让我们看看 `useState` 在现实中是否足够灵活。
- en: 'The following example illustrates how to implement the basic capability of
    `useReducer` with `useState`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何使用 `useState` 实现基本 `useReducer` 功能：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In addition to this basic capability, we can implement lazy initialization
    too. Let''s also use `useCallback` to have a stable dispatch function, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个基本功能外，我们还可以实现懒初始化。让我们也使用 `useCallback` 来有一个稳定的 dispatch 函数，如下所示：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This implementation works almost perfectly as a replacement for `useReducer`.
    Your use case of `useReducer` is very likely handled by this implementation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现几乎完美地作为 `useReducer` 的替代品。你使用 `useReducer` 的用例很可能被这个实现处理。
- en: However, we have two subtle differences. As they are subtle, we don't usually
    consider them in too much detail. Let's learn about them in the following two
    subsections to get a deeper understanding.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们有两个细微的区别。由于它们很微妙，我们通常不会过多地考虑它们。让我们在以下两个小节中了解它们，以获得更深入的理解。
- en: Using the init function
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `init` 函数
- en: One difference is that we can define `reducer` and `init` outside hooks or components.
    This is only possible with `useReducer` and not with `useState`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区别是我们可以在 hooks 或组件外部定义 `reducer` 和 `init`。这只有在 `useReducer` 中才可能，而不是在 `useState`
    中。
- en: 'Here is a simple count example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的计数示例：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see in `ComponentWithUseState`, `useState` requires two inline functions,
    whereas `ComponentWithUseReducer` has no inline functions. This is a trivial thing,
    but some interpreters or compilers can optimize better without inline functions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 `ComponentWithUseState` 中所看到的，`useState` 需要两个内联函数，而 `ComponentWithUseReducer`
    没有内联函数。这是一件小事，但一些解释器或编译器可以在没有内联函数的情况下进行更好的优化。
- en: Using inline reducers
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内联 reducer
- en: The inline reducer function can depend on outside variables. This is only possible
    with `useReducer` and not with `useState`. This is a special capability of `useReducer`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 内联 reducer 函数可以依赖于外部变量。这只有在 `useReducer` 中才可能，而不是在 `useState` 中。这是 `useReducer`
    的一个特殊功能。
- en: Important Note
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This capability is not usually used and not recommended unless it's really necessary.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种能力通常不使用，除非真的有必要，否则不建议使用。
- en: 'Hence, the following code is technically possible:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下代码在技术上是可以的：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This works correctly even when `bonus` and `delta` are both updated.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `bonus` 和 `delta` 都被更新，这也能正确工作。
- en: With the `useState` emulation, this doesn't work correctly. It would use an
    old `bonus` value in a previous render. This is because `useReducer` invokes the
    reducer function in the render phase.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `useState` 模拟时，这不会正确工作。它会在前一个渲染中使用旧的 `bonus` 值。这是因为 `useReducer` 在渲染阶段调用
    reducer 函数。
- en: As noted, this is not typically used, so overall, if we ignore this special
    behavior, we can say `useReducer` and `useState` are basically the same and interchangeable.
    You could just pick either one, based on your preference or your programming style.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所注，这通常不常用，所以总的来说，如果我们忽略这种特殊行为，我们可以说 `useReducer` 和 `useState` 基本上是相同的，可以互换。你可以根据你的偏好或编程风格选择任何一个。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed state management and defined micro state management,
    in which React hooks play an important role. To prepare for the following chapters,
    we learned about some React hooks that are used for state management solutions,
    including `useState` and `useReducer`, while also looking at their similarities
    and differences.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了状态管理并定义了微状态管理，其中 React 钩子在微状态管理中扮演着重要角色。为了为后续章节做准备，我们学习了用于状态管理解决方案的一些
    React 钩子，包括 `useState` 和 `useReducer`，同时也探讨了它们的相似之处和不同之处。
- en: In the next chapter, we learn more about a global state. For this purpose, we
    will discuss a local state and when a local state works, and we will then look
    at when a global state is required.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于全局状态的知识。为此，我们将讨论局部状态以及何时局部状态有效，然后我们将探讨何时需要全局状态。
