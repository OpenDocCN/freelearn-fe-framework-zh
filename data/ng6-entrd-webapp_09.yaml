- en: Design Authentication and Authorization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计身份验证和授权
- en: Designing a high-quality authentication and authorization system without frustrating
    the end user is a difficult problem to solve. Authentication is the act of verifying
    the identity of a user, and authorization specifies the privileges a user has
    to access a resource. Both processes, auth for short, must seamlessly work in
    tandem to address the needs of users with varying roles, needs, and job functions.
    In today's web, users have a high baseline level of expectations from any auth
    system they encounter through the browser, so this is a really important part
    of your application to get absolutely right the first time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计高质量的身份验证和授权系统而不会让最终用户感到沮丧是一个难题。身份验证是验证用户身份的行为，授权指定用户访问资源的特权。这两个过程，简称为auth，必须无缝地协同工作，以满足具有不同角色、需求和工作职能的用户的需求。在今天的网络中，用户对通过浏览器遇到的任何auth系统都有很高的期望水平，因此这是您的应用程序中绝对需要第一次就完全正确的一个非常重要的部分。
- en: The user should always be aware of what they can and can't do in your app. If
    there are errors, failures, or mistakes, the user should be clearly informed as
    to why such an error occured. As your application grows, it is easy to miss all
    the ways an error condition could be triggered. Your implementation should be
    easy to extend or maintain, otherwise this basic backbone of your application
    will require a lot of maintenance. In this chapter, we will walk-through the various
    challenges of creating a great auth UX and implement a solid baseline experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应始终了解他们在应用程序中可以做什么和不能做什么。如果出现错误、失败或错误，用户应清楚地了解为什么会发生这样的错误。随着应用程序的增长，很容易忽略触发错误条件的所有方式。您的实现应易于扩展或维护，否则您的应用程序的基本骨架将需要大量的维护。在本章中，我们将介绍创建出色的auth
    UX的各种挑战，并实现一个坚实的基线体验。
- en: We will be continuing the router-first approach to designing SPAs by implementing
    the authentication and authorization experience of LemonMart. In [Chapter 7](b35a976c-1709-4f43-9c4e-1cf957e7ca6c.xhtml),
    *Create a Router-First Line-of-Business App*, we defined user roles, finished
    our build-out of all major routing and completed a rough walking-skeleton navigation
    experience of LemonMart, so we are well prepared to implement role-based routing
    and the nuances of pulling such an implementation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续采用路由器优先方法来设计SPA，通过实现LemonMart的身份验证和授权体验。在[第7章](b35a976c-1709-4f43-9c4e-1cf957e7ca6c.xhtml)中，*创建基于路由器的企业应用程序*，我们定义了用户角色，完成了所有主要路由的构建，并完成了LemonMart的粗略行走骨架导航体验，因此我们已经准备好实现基于角色的路由和拉取此类实现的细微差别。
- en: In [Chapter 8](efa828d3-c66a-4fa9-9b31-11a42937253a.xhtml), *Continuous Integration
    and API Design*, we discussed the idea of designing around major data components,
    so you are already familiar with how a user entity looks like, which will come
    in handy in implementing a token-based login experience, including caching role
    information within the entity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](efa828d3-c66a-4fa9-9b31-11a42937253a.xhtml)中，*持续集成和API设计*，我们讨论了围绕主要数据组件进行设计的想法，因此您已经熟悉用户实体的外观，这将在实现基于令牌的登录体验中派上用场，包括在实体内缓存角色信息。
- en: Before diving into auth, we will discuss the importance of completing high-level
    mock -ups for your application before starting to implement various conditional
    navigation elements, which may change significantly during the design phase.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究auth之前，我们将讨论在开始实现各种条件导航元素之前，完成应用程序的高级模拟的重要性，这在设计阶段可能会发生重大变化。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解以下主题：
- en: Importance of high-level UX design
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级UX设计的重要性
- en: Token-based authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于令牌的身份验证
- en: Conditional navigation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件导航
- en: Side Navigation bar
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侧边导航栏
- en: Reusable UI Service for alerts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用的警报UI服务
- en: Caching data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存数据
- en: JSON Web Tokens
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON Web Tokens
- en: Angular HTTP interceptors
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular HTTP拦截器
- en: Router guards
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由守卫
- en: Wrapping up mock-ups
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成模型
- en: Mock-ups are important in determining what kind of components and user controls
    we will need throughout the app. Any user control or component that will be used
    across components will need to defined at the root level and others scoped with
    their own modules.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模型在确定我们在整个应用程序中需要哪种组件和用户控件方面非常重要。任何将在组件之间使用的用户控件或组件都需要在根级别定义，其他的则在其自己的模块中定义。
- en: 'In [Chapter 7](b35a976c-1709-4f43-9c4e-1cf957e7ca6c.xhtml), *Create a Router-First
    Line-of-Business App*, we have already identified the submodules and designed
    landing pages for them to complete the walking skeleton. Now that we have defined
    the major data components, we can complete mock-ups for the rest of the app. When
    designing screens at a high-level, keep several things in mind:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](b35a976c-1709-4f43-9c4e-1cf957e7ca6c.xhtml)，*创建一个以路由为首的业务应用程序*中，我们已经确定了子模块并为它们设计了着陆页面，以完成行走的骨架。现在我们已经定义了主要的数据组件，我们可以为应用程序的其余部分完成模型。在高层次设计屏幕时，请牢记几件事：
- en: Can a user complete common tasks required for their role with as little navigation
    as possible?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否可以尽可能少地导航来完成其角色所需的常见任务？
- en: Can users readily access all information and functionality of the app through
    visible elements on the screen?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否可以通过屏幕上可见的元素轻松访问应用程序的所有信息和功能？
- en: Can a user search for the data they need easily?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否可以轻松搜索他们需要的数据？
- en: Once a user finds a record of interest, can they drill-down into detail records
    or view related records with ease?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦用户找到感兴趣的记录，他们是否可以轻松地深入了解详细记录或查看相关记录？
- en: Is that pop-up alert really necessary? You know users won't read it, right?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个弹出警报真的有必要吗？您知道用户不会阅读它，对吧？
- en: Keep in mind that there's no one right way to design any user experience, which
    is why when designing screens, always keep modularity and reusability in mind.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，设计任何用户体验都没有一种正确的方式，这就是为什么在设计屏幕时，始终要牢记模块化和可重用性。
- en: 'As you generate various design artifacts, such as mock-ups or design decisions,
    take care to post them on a wiki reachable by all team members:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您生成各种设计工件，如模型或设计决策时，请务必将它们发布在所有团队成员都可以访问的维基上：
- en: On GitHub, switch over to the Wiki tab
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub上，切换到Wiki选项卡
- en: 'You may check out my sample wiki at [Github.com/duluca/lemon-mart/wiki](https://github.com/duluca/lemon-mart/wiki),
    as shown:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以查看我的示例维基，如下所示：[Github.com/duluca/lemon-mart/wiki](https://github.com/duluca/lemon-mart/wiki)
- en: '![](Images/41a5f242-42e3-41b4-b27d-fdd7a0dee99d.png)GitHub.com LemonMart Wiki'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/41a5f242-42e3-41b4-b27d-fdd7a0dee99d.png)GitHub.com LemonMart Wiki'
- en: When creating a wiki page, ensure that you cross-link between any other documentation
    available, such as Readme
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建维基页面时，请确保在任何其他可用文档之间进行交叉链接，例如Readme
- en: Note that GitHub shows subpages on the wiki under Pages
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，GitHub在页面下显示维基上的子页面
- en: However, an additional summary is helpful, such as the Design Artifacts section,
    since some people may miss the navigational element on the right
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，额外的摘要是有帮助的，比如设计工件部分，因为有些人可能会错过右侧的导航元素
- en: As you complete mock-ups, post them on wiki
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成模型后，请将其发布在维基上
- en: 'You can see a summary view of the wiki here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到维基的摘要视图：
- en: '![](Images/007c499f-6d70-4b56-bf5c-ce687effd2b6.png)Summary view of Lemon Mart
    mock-ups'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/007c499f-6d70-4b56-bf5c-ce687effd2b6.png)柠檬市场模型的摘要视图'
- en: Optionally, place the mock-ups in the walking skeleton app so that testers can
    better envision the functionality that is yet to be developed
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，将模型放在行走的骨架应用程序中，以便测试人员更好地设想尚未开发的功能
- en: With the mock-ups completed, we can now continue the implementation of LemonMart
    with the Authentication and Authorization workflow.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完成模拟后，我们现在可以继续使用身份验证和授权工作流来实现 LemonMart。
- en: Design authentication and authorization workflow
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计认证和授权工作流
- en: A well-designed authentication workflow is stateless so that there's no concept
    of an expiring session. User's are free to interact with your stateless REST APIs
    from as many devices and tabs as they wish, simultaneously or overtime. **JSON
    Web Token** (**JWT**) implements distributed claims-based authentication that
    can be digitally signed or integration protected and/or encrypted using a **Message
    Authentication Code** (**MAC**). This means once a user's identity is authenticated
    through, let's say a password-challenge, they receive an encoded claim ticket
    or a token, which can then be used to make future requests to the system without
    having to reauthenticate the identity of a user. The server can independently
    verify the validity of this claim and process the requests without requiring any
    prior knowledge of having interacted with this user. Thus, we don't have to store
    session information regarding a user, making our solution stateless and easy to
    scale. Each token will expire after a predefined period and due to their distributed
    nature, they can't be remotely or individually revoked; however, we can bolster
    real-time security by interjecting custom account and user role status checks
    to ensure that the authenticated user is authorized to access server-side resources.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的身份验证工作流是无状态的，因此没有会话过期的概念。用户可以自由地与您的无状态 REST API 进行交互，无论他们希望同时或随后在多少设备和标签页上。**JSON
    Web Token** (**JWT**) 实现了基于分布式声明的身份验证，可以通过数字签名或集成保护和/或使用 **消息认证码** (**MAC**) 进行加密。这意味着一旦用户的身份经过认证，比如说通过密码挑战，他们将收到一个编码的声明票据或令牌，然后可以使用它来对系统进行未来的请求，而无需重新验证用户的身份。服务器可以独立验证此声明的有效性并处理请求，而无需事先知道与该用户进行过互动。因此，我们不必存储有关用户的会话信息，使我们的解决方案无状态且易于扩展。每个令牌将在预定义的时间后过期，并且由于它们的分布式性质，无法远程或单独撤销；但是，我们可以通过插入自定义帐户和用户角色状态检查来加强实时安全性，以确保经过身份验证的用户有权访问服务器端资源。
- en: JSON Web Tokens implement IETF industry standard RFC7519, found at [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Tokens 实现了 IETF 行业标准 RFC7519，可以在 [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)
    找到。
- en: A good authorization workflow enables conditional navigation based on a user's
    role so that users are automatically taken to the optimal landing screen; they
    are not shown routes or elements that are not suitable for their roles and if
    by mistake they try to access an authorized path, they're prevented from doing
    so. You must remember that any client-side role-based navigation is merely a convenience
    and is not meant for security. This means that every call made to the server should
    contain the necessary header information, with the secure token, so that the user
    can be reauthenticated by the server, their role independently verified and only
    then they are allowed to retrieve secured data. Client-side authentication can't
    be trusted, which is why password reset screens must be built with a server-side
    rendering technology so that both the user and the server can verify that the
    intended user is interacting with the system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的授权工作流程能够基于用户角色进行条件导航，以便用户自动进入最佳的登陆界面；他们不会看到不适合他们角色的路由或元素，如果他们错误地尝试访问一个授权的路径，他们将被阻止这样做。您必须记住，任何客户端角色导航仅仅是一种便利，而不是用于安全目的。这意味着每次向服务器发出的调用都应包含必要的头部信息，带有安全令牌，以便服务器可以重新验证用户，独立验证他们的角色，只有在这样做之后才允许检索安全数据。客户端身份验证是不可信的，这就是为什么密码重置屏幕必须使用服务器端渲染技术构建，以便用户和服务器都可以验证预期的用户正在与系统交互。
- en: 'In the following sections, we will design a fully featured auth workflow around
    the User data entity, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将围绕用户数据实体设计一个完整的身份验证工作流程，如下所示：
- en: '![](Images/472734b5-1c3b-4696-af25-7f21d53aa6c2.png)User entity'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/472734b5-1c3b-4696-af25-7f21d53aa6c2.png)用户实体'
- en: Add auth service
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加身份验证服务
- en: 'We will start by creating an auth service with a real and a fake login provider:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个具有真实和虚假登录提供程序的身份验证服务：
- en: 'Add an authentication and authorization service:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加身份验证和授权服务：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ensure that the service is provided in `app.module`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保服务在`app.module`中提供：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating a separate folder for the service will organize various related components
    to authentication and authorization, such as the `enum` definition for Role. Additionally,
    we will be able to add an `authService` fake to the same folder, essential for
    writing unit tests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为服务创建一个单独的文件夹将组织各种与身份验证和授权相关的组件，例如`Role`的`enum`定义。此外，我们还将能够在同一个文件夹中添加一个`authService`的伪造版本，这对于编写单元测试至关重要。
- en: 'Define user roles as an `enum`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户角色定义为`enum`：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implement a basic authentication service
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基本的身份验证服务
- en: 'Now, let''s build a local authentication service that will enable us to demonstrate
    a robust login form, caching, and conditional navigation concepts based on authentication
    status and a user''s role:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个本地身份验证服务，这将使我们能够演示一个强大的登录表单、缓存和基于身份验证状态和用户角色的条件导航概念：
- en: 'Start by installing a JWT decoding library, and for faking authentication,
    a JWT encoding library:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先安装一个JWT解码库，以及一个用于伪造身份验证的JWT编码库：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define your imports for `auth.service.ts`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`auth.service.ts`定义导入项：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement an `IAuthStatus` interface to store decoded user information, a helper
    interface, and the secure by-default `defaultAuthStatus`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`IAuthStatus`接口来存储解码后的用户信息，一个辅助接口，以及默认安全的`defaultAuthStatus`：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`IAuthUser` is an interface that represents the shape of a typical JWT that
    you may receive from your authentication service. It contains minimal information
    about the user and its role, so it can be attached to the `header` of server calls
    and optionally cached in `localStorage` to remember the user''s login state. In
    the preceding implementation, we''re assuming the default role of a `Manager`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAuthUser`是一个接口，代表了您可能从身份验证服务接收到的典型JWT的形状。它包含有关用户及其角色的最少信息，因此可以附加到服务器调用的`header`中，并且可以选择地缓存在`localStorage`中以记住用户的登录状态。在前面的实现中，我们假设了`Manager`的默认角色。'
- en: 'Define the `AuthService` class with a `BehaviorSubject` to anchor the current
    `authStatus` of the user and configure an `authProvider` that can process an `email`
    and a `password` and return an `IServerAuthResponse` in the constructor:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`BehaviorSubject`定义`AuthService`类来锚定用户当前的`authStatus`，并在构造函数中配置一个`authProvider`，该`authProvider`可以处理`email`和`password`并返回一个`IServerAuthResponse`：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that `fakeAuthProvider` is configured to be the `authProvider` for this
    service. A real auth provider may look like the following code, where users''
    email and password are sent to a POST endpoint, which verifies their information,
    creating and returning a JWT for our app to consume:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`fakeAuthProvider`被配置为该服务的`authProvider`。真实的身份验证提供程序可能看起来像以下代码，其中用户的电子邮件和密码被发送到一个POST端点，该端点验证他们的信息，创建并返回一个JWT供我们的应用程序使用：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is pretty straightforward, since the hard work is done on the server side.
    This call can also be made to a third party.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，因为大部分工作是在服务器端完成的。这个调用也可以发送给第三方。
- en: Note that the API version, `v1`, in the URL path is defined at the service and
    not as part of the `baseUrl`. This is because each API can change versions independently
    from each other. Login may remain `v1` for a long time, while other APIs may be
    upgraded to `v2`, `v3`, and such.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，URL路径中的API版本`v1`是在服务中定义的，而不是作为`baseUrl`的一部分。这是因为每个API可以独立于其他API更改版本。登录可能长时间保持为`v1`，而其他API可能升级为`v2`、`v3`等。
- en: 'Implement a `fakeAuthProvider` that simulates the authentication process, including
    creating a fake JWT on the fly:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`fakeAuthProvider`，模拟身份验证过程，包括动态创建一个假的JWT：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `fakeAuthProvider` implements what would otherwise be a server-side method
    right in the service, so you can conveniently experiment the code while fine-tuning
    your auth workflow. It creates and signs a JWT, with the temporary `fake-jwt-sign` library
    so that we can also demonstrate how to handle a properly-formed JWT.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`fakeAuthProvider`在服务中实现了本来应该是服务器端方法，因此您可以方便地在微调身份验证工作流程的同时实验代码。它使用临时的`fake-jwt-sign`库创建并签署了一个JWT，以便我们还可以演示如何处理一个格式正确的JWT。'
- en: Do not ship your Angular app with the `fake-jwt-sign` dependency, since it is
    meant to be server-side code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将您的Angular应用程序与`fake-jwt-sign`依赖项一起发布，因为它是用于服务器端代码的。
- en: 'Before we move on, implement a `transformError` function to handle mixed `HttpErrorResponse`
    and string errors in an observable stream under `common/common.ts`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续之前，实现一个`transformError`函数来处理在`common/common.ts`下的可观察流中混合的`HttpErrorResponse`和字符串错误：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implement the `login` function that will be called from `LoginComponent`, shown
    in the next section
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`login`函数，该函数将从`LoginComponent`中调用，如下一节所示
- en: Add ``import { transformError } from '../common/common'``
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加``import { transformError } from '../common/common'``
- en: 'Also implement a corresponding `logout` function, which may be called by the
    Logout button in the top toolbar, a failed login attempt, or if an unauthorized
    access attempt is detected by a router auth guard as the user is navigating the
    app, which is a topic covered later in the chapter:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要实现一个相应的`logout`函数，可以由顶部工具栏中的注销按钮调用，也可以由登录尝试失败或者如果路由器身份验证守卫检测到未经授权的访问尝试时调用，这是本章后面涵盖的一个主题：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `login` method encapsulates the correct order of operations by calling the `logout` method,
    the `authProvider` with the `email` and `password` information, and throwing errors
    when necessary.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`方法通过调用`logout`方法，`authProvider`与`email`和`password`信息，并在必要时抛出错误来封装正确的操作顺序。'
- en: The `login` method adheres to the Open/Closed principle, from SOLID design,
    by being open to extension by our ability to externally supply different auth
    providers to it, but it remains closed to modification, since the variance in
    functionality is encapsulated with the auth provider.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`方法遵循SOLID设计中的开闭原则，通过对外部提供不同的auth提供程序来扩展，但对修改保持封闭，因为功能的差异被封装在auth提供程序中。'
- en: In the next section, we will implement the `LoginComponent` so that users can
    enter their username and password information and attempt a login.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现`LoginComponent`，以便用户可以输入他们的用户名和密码信息并尝试登录。
- en: Implementing the login component
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现登录组件
- en: The `login` component leverages the `authService` that we just created and implements
    validation errors using reactive forms. The login component should be designed
    in a way to be rendered independently of any other component, because during a
    routing event, if we discover that the user is not properly authenticated or authorized,
    we will navigate them to this component. We can capture this origination URL as
    a `redirectUrl` so that once a user logs in successfully, we can navigate them
    back to it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`组件利用我们刚刚创建的`authService`并使用响应式表单实现验证错误。登录组件应该以一种独立于任何其他组件的方式进行设计，因为在路由事件期间，如果我们发现用户没有得到适当的身份验证或授权，我们将把他们导航到这个组件。我们可以将这个起源URL捕获为`redirectUrl`，这样一旦用户成功登录，我们就可以将他们导航回去。'
- en: 'Let''s start with implementing the routes to the `login` component:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从实现到`login`组件的路由开始：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now implement the component itself:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现组件本身：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As the result of a successful login attempt, we leverage the router to navigate
    an authenticated user to their profile. In the case of an error sent from the
    server via the service, we assign that error to `loginError`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 作为成功登录尝试的结果，我们利用路由器将经过身份验证的用户导航到他们的个人资料。在通过服务从服务器发送的错误的情况下，我们将将该错误分配给`loginError`。
- en: 'Here''s an implementation for a login form to capture and validate a user''s
    `email` and `password`, and if there are any server errors, display them:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个用于捕获和验证用户的`email`和`password`的登录表单的实现，并且如果有任何服务器错误，显示它们：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Login button is disabled until email and password meets client site validation
    rules. Additionally, `<mat-form-field>` will only display one `mat-error` at a
    time, unless you create more space for more errors, so be sure place your error
    conditions in the correct order.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 登录按钮在满足客户端验证规则之前将被禁用。此外，`<mat-form-field>`一次只会显示一个`mat-error`，除非您为更多错误创建更多的空间，所以请确保将您的错误条件放在正确的顺序中。
- en: Once you're done implementing the `login` component, you can now update the
    home screen to conditionally display or hide the new component we created.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了实现`login`组件，现在可以更新主屏幕以有条件地显示或隐藏我们创建的新组件。
- en: 'Update `home.component` to display login when a user opens up the app:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`home.component`以在用户打开应用程序时显示登录：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Don't forget to import the requisite dependent modules for the code above in
    to your Angular application. It is intentionally left as an exercise for the reader
    to locate and import the missing modules.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将上面的代码中所需的依赖模块导入到您的Angular应用程序中。有意留给读者去找到并导入缺失的模块。
- en: 'Your app should look similar to this screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序应该看起来类似于这个屏幕截图：
- en: '![](Images/801401dc-95ca-47be-9eb0-621967769d61.png)LemonMart with login'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/801401dc-95ca-47be-9eb0-621967769d61.png)带有登录的LemonMart'
- en: There's still some work to be done, in terms of implementing and showing/hiding
    the sidenav menu, profile and logout icons, given the user's authentication status.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现和显示/隐藏侧边栏菜单、个人资料和注销图标方面，还有一些工作要做，这取决于用户的认证状态。
- en: Conditional navigation
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有条件的导航
- en: Conditional navigation is necessary in creating a frustration-free user experience.
    By selectively showing the elements that the user has access to and hiding the
    ones they don't, we allow the user to confidently navigate through the app.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有条件的导航在创建一个无挫折的用户体验方面是必要的。通过选择性地显示用户可以访问的元素并隐藏他们无法访问的元素，我们允许用户自信地浏览应用程序。
- en: 'Let''s start by hiding the login component after a user logs in to the app:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在用户登录到应用程序后隐藏登录组件开始：
- en: On the `home` component, import the `authService` in `home.component`
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`home`组件中，导入`authService`到`home.component`
- en: 'Set the `authStatus` to a local variable named `displayLogin`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`authStatus`设置为名为`displayLogin`的本地变量：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A property getter for `displayLogin` here is necessary, otherwise you may receive
    a Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after
    it was checked message. This error is a side effect of how the Angular component
    life-cycle and change detection works. This behavior may very well change in future
    Angular versions.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '这里需要一个`displayLogin`的属性获取器，否则您可能会收到一个`Error: ExpressionChangedAfterItHasBeenCheckedError:
    Expression has changed after it was checked`的错误消息。这个错误是Angular组件生命周期和变化检测工作方式的副作用。这种行为很可能会在未来的Angular版本中发生变化。'
- en: 'On the `app` component, subscribe to the authentication status and store the
    current value in a local variable named `displayAccountIcons`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`组件上，订阅认证状态并将当前值存储在名为`displayAccountIcons`的本地变量中：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use `*ngIf` to hide all buttons meant for logged in users:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`*ngIf`来隐藏所有针对已登录用户的按钮：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, when a user is logged out, your toolbar should look all clean with no
    buttons, as shown:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户登出时，您的工具栏应该看起来干净整洁，没有任何按钮，如下所示：
- en: '![](Images/377d973e-f502-49e8-b98a-b7b82df0b0ae.png)LemonMart toolbar after
    log in'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/377d973e-f502-49e8-b98a-b7b82df0b0ae.png)登录后的LemonMart工具栏'
- en: Common validations
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见验证
- en: 'Before we move on, we need to implement validations for `loginForm`. As we
    implement more forms in [Chapter 10](99f040e3-89f0-4ac8-a849-4cef38e7a992.xhtml),
    *Angular App Design and Recipes*, you will realize that it gets tedious, fast,
    to repeatedly type out form validations in either template or reactive forms.
    Part of the allure of reactive forms is that it is driven by code, so we can easily
    extract out the validations to a shared class, unit test, and reuse them:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要为`loginForm`实现验证。当我们在[第10章](99f040e3-89f0-4ac8-a849-4cef38e7a992.xhtml)中实现更多表单时，您会意识到在模板或响应式表单中重复输入表单验证会变得很繁琐。响应式表单的吸引力之一是它由代码驱动，因此我们可以轻松地将验证提取到一个共享类中，进行单元测试，并重复使用它们：
- en: Create a `validations.ts` file under the `common` folder
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`common`文件夹下创建一个`validations.ts`文件
- en: 'Implement email and password validations:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现电子邮件和密码验证：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Depending on your password validation needs, you can use a `RegEx` pattern with
    the `Validations.pattern()` function to enforce password complexity rules or leverage
    the OWASP npm package, `owasp-password-strength-test`, to enable pass-phrases
    as well as set more flexible password requirements.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的密码验证需求，您可以使用`RegEx`模式和`Validations.pattern()`函数来强制密码复杂性规则，或者利用OWASP npm包`owasp-password-strength-test`来启用密码短语以及设置更灵活的密码要求。
- en: 'Update the `login` component with the new validations:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的验证更新`login`组件：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: UI service
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI服务
- en: As we start dealing with complicated workflows, such as the auth workflow, it
    is important to be able to programmatically display a toast notification for the
    user. In other cases, we may want to ask for a confirmation before executing a
    destructive action with a more intrusive pop-up notification.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始处理复杂的工作流程，比如身份验证工作流时，能够以编程方式为用户显示一个提示通知是很重要的。在其他情况下，我们可能希望在执行破坏性操作之前要求确认，这时需要一个更具侵入性的弹出通知。
- en: 'No matter what component library you use, it gets tedious to recode the same
    boiler plate, just to display a quick notification. A UI service can neatly encapsulate
    a default implementation that can also be customized on a need basis:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪个组件库，都会变得很烦琐，因为您需要重复编写相同的样板代码，只是为了显示一个快速通知。UI服务可以整洁地封装一个默认实现，也可以根据需要进行自定义：
- en: Create a new `uiService` under `common`
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`common`下创建一个新的`uiService`
- en: 'Implement a `showToast` function:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`showToast`函数：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For a showDialog function, we must implement a basic dialog component:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`showDialog`函数，我们必须实现一个基本的对话框组件：
- en: Add a new `simpleDialog` under the `common` folder provided in `app.module`
    with inline template and styling
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.module`提供的`common`文件夹下添加一个新的`simpleDialog`，包括内联模板和样式
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that `SimpleDialogComponent` should not have app selector like  `selector:
    ''app-simple-dialog''` since we only plan to use it with `UiService`. Remove this
    property from your component.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，`SimpleDialogComponent`不应该像`selector: ''app-simple-dialog''`那样具有应用程序选择器，因为我们只打算与`UiService`一起使用它。从组件中删除此属性。'
- en: 'Then, implement a `showDialog` function to display the `SimpleDialogComponent`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现一个`showDialog`函数来显示`SimpleDialogComponent`：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`ShowDialog` returns an `Observable<boolean>`, so you can implement a follow-on
    action, depending on what selection the user makes. Clicking on OK will return
    `true`, and Cancel will return `false`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowDialog`返回一个`Observable<boolean>`，因此您可以根据用户的选择实施后续操作。单击“确定”将返回`true`，单击“取消”将返回`false`。'
- en: In `SimpleDialogComponent`, using `@Inject`, we're able to use all variables
    sent by `showDialog` to customize the content of the dialog.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SimpleDialogComponent`中，使用`@Inject`，我们可以使用`showDialog`发送的所有变量来自定义对话框的内容。
- en: Don't forget to update `app.module.ts` and `material.module.ts` with the various
    dependencies that are being introduced.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更新`app.module.ts`和`material.module.ts`，引入各种新的依赖项。
- en: 'Update the `login` component to display a toast message after login:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`login`组件以在登录后显示一个提示消息：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A toast message will appear after a user logs in, as shown:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登录后将显示一个提示消息，如下所示：
- en: '![](Images/32e7c130-1a5d-4f92-a6c1-fa83dc5773b8.png)Material Snack barThe `snackBar`
    will either take the full width of the screen or a portion depending on the size
    of the browser.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/32e7c130-1a5d-4f92-a6c1-fa83dc5773b8.png)Material Snack bar`snackBar`将根据浏览器的大小占据整个屏幕或部分屏幕。'
- en: Caching with cookie and localStorage
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cookie和本地存储进行缓存
- en: We must be able to cache the authentication status of the logged in user. Otherwise,
    with every page refresh, the user will have go through the login routine. We need
    to update `AuthService` so that it persists the auth status.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须能够缓存已登录用户的身份验证状态。否则，每次刷新页面，用户都必须通过登录流程。我们需要更新`AuthService`以便持久保存身份验证状态。
- en: 'There are three main ways to store data:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种主要的数据存储方式：
- en: '`cookie`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookie
- en: '`localStorage`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地存储
- en: '`sessionStorage`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话存储
- en: Cookies should not be used to store secure data, because they can be sniffed
    or stolen by bad actors. In addition, cookies can store 4 KB of data and can be
    set to expire.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不应该使用Cookie来存储安全数据，因为它们可能会被不良行为者嗅探或窃取。此外，Cookie最多可以存储4KB的数据，并且可以设置过期时间。
- en: '`localStorage` and `sessionStorage` are similar to each other. They are protected
    and isolated browser-side stores that allow for storing larger amounts of data
    for your application. You can''t set an expiration date-time on either stores.
    `sessionStorage` values are removed, when the browser window is closed. The values
    survive page reloads and restores.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage` 和 `sessionStorage` 在某种程度上是相似的。它们是受保护和隔离的浏览器端存储，允许存储大量应用程序数据。你不能在这两个存储上设置过期时间。当浏览器窗口关闭时，`sessionStorage`
    的值会被移除。这些值会在页面重新加载和恢复时保留。'
- en: JSON Web Tokens are encrypted, and they include a timestamp for expiration,
    in essence, countering the weaknesses of `cookie` and `localStorage`. Either option
    should be secure to use with JWTs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Token 是加密的，并包括一个用于过期的时间戳，从本质上来说，它抵消了 `cookie` 和 `localStorage` 的弱点。任何选项都应该与
    JWT 一起使用是安全的。
- en: 'Let''s start by implement a caching service that can abstract away our method
    of caching authentication information that the `AuthService` can consume:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先实现一个缓存服务，可以将我们的身份验证信息的缓存方法抽象出来，`AuthService` 可以使用。
- en: 'Start by creating an abstract `cacheService` that encapsulates the method of
    caching:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个抽象的 `cacheService`，封装缓存方法：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This cache service base class can be used to give caching capabilities to any
    service. It is not the same as creating a centralized cache service that you inject
    into other service. By avoiding a centralized value store, we avoid inter-dependencies
    between various services.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缓存服务基类可以用来赋予任何服务缓存功能。这与创建一个注入到其他服务中的集中式缓存服务不同。通过避免集中式值存储，我们避免了各种服务之间的相互依赖。
- en: 'Update `AuthService` to extend the `CacheService` and implement caching of
    the `authStatus`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `AuthService` 以扩展 `CacheService` 并实现 `authStatus` 的缓存：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The technique demonstrated here can be used to persist any kind of data and
    intentionally leverages RxJS events to update the cache. As you may note, we don't
    need to update the login function to call `setItem`, because it already calls
    `this.authStatus.next`, and we just tap in to the data stream. This helps with
    staying stateless and avoiding side effects, by decoupling functions from each
    other.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里演示的技术可以用来持久化任何类型的数据，并有意地利用 RxJS 事件来更新缓存。正如你可能注意到的，我们不需要更新登录函数来调用 `setItem`，因为它已经调用了
    `this.authStatus.next`，我们只是连接到数据流。这有助于保持无状态和避免副作用，通过将函数解耦。
- en: When initializing the `BehaviorSubject`, take care to handle the `undefined/null`
    case, when loading data from the cache and still provide a default implementation.You
    can implement your own custom cache expiration scheme in `setItem` and `getItem`
    functions or leverage a service created by a third party.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 `BehaviorSubject` 时，要注意处理从缓存加载数据时的 `undefined/null` 情况，并提供默认实现。你可以在 `setItem`
    和 `getItem` 函数中实现自己的自定义缓存过期方案，或者利用第三方创建的服务。
- en: If you are going after a high-security application, you may choose to only cache
    the JWT to ensure an additional layer security. In either case, the JWT should
    be cached separately, because the token must be sent to the server in the header
    with every request. It is important to understand how token-based authentication
    works well, to avoid revealing compromising secrets. In the next section, we will
    go over the JWT life cycle to improve your understanding.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个高安全性的应用程序，你可能选择只缓存 JWT 以确保额外的安全层。在任何情况下，JWT 应该被单独缓存，因为令牌必须在每个请求的标头中发送到服务器。了解基于令牌的身份验证如何工作是很重要的，以避免泄露妥协的秘密。在下一节中，我们将介绍
    JWT 的生命周期，以提高你的理解。
- en: JSON Web Token life cycle
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Web Token 生命周期
- en: 'JSON Web Tokens compliment a stateless REST API architecture with an encrypted
    token mechanism that allow for convenient, distributed, and high-performance authentication
    and authorization of requests sent by clients. There are three main components
    of a token-based authentication scheme:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Tokens与基于状态的REST API架构相辅相成，具有加密令牌机制，允许方便、分布式和高性能的客户端请求的身份验证和授权。令牌身份验证方案有三个主要组件：
- en: Client-side, captures login information and hides disallowed actions for a good
    UX
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端，捕获登录信息并隐藏不允许的操作，以获得良好的用户体验
- en: Server-side, validates that every request is both authenticated and has the
    proper authorization
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端，验证每个请求既经过身份验证又具有适当的授权
- en: Auth service, generates and validates encrypted tokens, independently verifies
    authentication and authorization status of user requests from a data store
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Auth服务，生成和验证加密令牌，独立验证用户请求的身份验证和授权状态，从数据存储中验证
- en: A secure system presumes that data sent/received between the major components
    mentioned is encrypted in-transit. This means your REST API must be hosted with
    a properly configured SSL certificate, serving all API calls over HTTPS, so that
    user credentials are never exposed between the client and the server. Similarly,
    any database or third-party service call should happen over HTTPS. Furthermore,
    any data store storing passwords should utilize a secure one-way hashing algorithm
    with good salting practices. Any other sensitive user information should be encrypted
    at-rest with a secure two-way encryption algorithm. Following this layered approach
    to security is critical, because attackers will need to accomplish the unlikely
    feat of compromising all layers of security implemented at the same time to cause
    meaningful harm to your business.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 安全系统假定在主要组件之间发送/接收的数据是在传输中加密的。这意味着您的REST API必须使用正确配置的SSL证书托管，通过HTTPS提供所有API调用，以便用户凭据在客户端和服务器之间永远不会暴露。同样，任何数据库或第三方服务调用都应该通过HTTPS进行。此外，存储密码的任何数据存储应该使用安全的单向哈希算法和良好的盐化实践。任何其他敏感用户信息应该使用安全的双向加密算法在静止状态下进行加密。遵循这种分层安全方法至关重要，因为攻击者需要同时攻破所有实施的安全层，才能对您的业务造成实质性的伤害。
- en: 'The next sequence diagram highlights the life-cycle of JWT-based authentication:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个序列图突出了基于JWT的身份验证的生命周期：
- en: '![](Images/f30e0ffc-b007-4c03-a12f-b3c448b31dfa.jpg)Life-Cycle of JWT-based
    authentication'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/f30e0ffc-b007-4c03-a12f-b3c448b31dfa.jpg)基于JWT的身份验证的生命周期'
- en: Initially, a user logs in by providing their username and password. Once validated,
    the user's authentication status and role is encrypted to a JWT with an expiration
    date and time and is sent back to the browser.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，用户通过提供其用户名和密码登录。一旦验证，用户的身份验证状态和角色将被加密为具有过期日期和时间的JWT，并发送回浏览器。
- en: Your Angular (or any other SPA) app can cache this token in local or session
    storage securely so that the user isn't forced to login with every request or
    worse yet, we don't store user credentials in the browser. Let's update the authentication
    service so that it can cache the token.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Angular（或任何其他SPA）应用程序可以安全地将此令牌缓存在本地或会话存储中，以便用户不必在每个请求中登录，或者更糟糕的是，我们不会在浏览器中存储用户凭据。让我们更新身份验证服务，以便它可以缓存令牌。
- en: 'Update the service to be able to set, get, decode, and clear the token, as
    shown:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新服务以能够设置、获取、解码和清除令牌，如下所示：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Call `setToken` during login and `clearToken` during logout as highlight as
    follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在登录期间调用`setToken`，在注销期间调用`clearToken`，如下所示：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Every subsequent request will contain the JWT in the request header. You should
    secure every API to check for and validate the token received. For example, if
    a user wanted to access their profile, the `AuthService` would validate the token
    to check whether the user authenticated, but a further database call is required
    to check whether the user is also authorized to view the data. This ensures an
    independent confirmation of the users' access to the system and prevents any abuse
    of an unexpired token.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每个后续请求都将在请求头中包含JWT。您应该保护每个API以检查并验证收到的令牌。例如，如果用户想要访问他们的个人资料，`AuthService`将验证令牌以检查用户是否经过身份验证，但还需要进一步的数据库调用来检查用户是否有权查看数据。这确保了对用户对系统的访问的独立确认，并防止对未过期令牌的滥用。
- en: If an authenticated user makes a call to an API, where they don't have the proper
    authorization, say if a clerk wants to get access to a list of all the users,
    then the `AuthService` will return a falsy status and the client will receive
    a 403 Forbidden response, which will be displayed as an error message to the user.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果经过身份验证的用户调用API，但他们没有适当的授权，比如说一个职员想要访问所有用户的列表，那么`AuthService`将返回一个虚假的状态，客户端将收到403
    Forbidden的响应，这将显示为用户的错误消息。
- en: A user can make a request with an expired token; when this happens, a 401 Unauthorized
    response is sent to the client. As a good UX practice, we should automatically
    prompt the user to login again and let them resume their workflow without any
    data loss.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用过期的令牌发出请求；当这种情况发生时，将向客户端发送401未经授权的响应。作为良好的用户体验实践，我们应该自动提示用户重新登录，并让他们在没有任何数据丢失的情况下恢复他们的工作流程。
- en: In summary, real security is achieved by a robust server-side implementation
    and any client-side implementation is largely there to enable a good UX around
    good security practices.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，真正的安全性是通过强大的服务器端实现来实现的，任何客户端实现主要是为了实现良好的安全实践周围的良好用户体验。
- en: HTTP interceptor
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP拦截器
- en: 'Implement an HTTP interceptor to inject the JWT into the header of every request
    sent to the user and also gracefully handle authentication failures by asking
    the user to log in:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 实现HTTP拦截器以将JWT注入到发送给用户的每个请求的头部，并通过要求用户登录来优雅地处理身份验证失败：
- en: 'Create `authHttpInterceptor` under `auth`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`auth`下创建`authHttpInterceptor`：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that `AuthService` is leveraged to retrieve the token, and the `redirectUrl`
    is being set for the login component after a 401 error.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`AuthService`被利用来检索令牌，并且在401错误后为登录组件设置`redirectUrl`。
- en: 'Update the `app` module to provide the interceptor:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app`模块以提供拦截器：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can observe the interceptor in action, while the app is fetching the `lemon.svg`
    file, in the Chrome Dev Tools | Network tab, here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Chrome Dev Tools | Network选项卡中观察拦截器的操作，当应用程序正在获取`lemon.svg`文件时：
- en: '![](Images/4ee15346-c629-4a11-b54b-d581d81621dd.png)Request header for lemon.svg'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/4ee15346-c629-4a11-b54b-d581d81621dd.png)lemon.svg的请求头'
- en: Side navigation
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边导航
- en: 'Enable mobile-first workflows and provide an easy navigation mechanism to quickly
    jump to desired functionality. Using the authentication service, given a user''s
    current role, only display the links for features they can access. We will be
    implementing the side navigation mock-up, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 启用移动优先工作流，并提供一个简单的导航机制，以便快速跳转到所需的功能。使用身份验证服务，根据用户当前的角色，只显示他们可以访问的功能链接。我们将按照以下方式实现侧边导航的模拟：
- en: '![](Images/a9a1fd13-c22a-4f01-9b08-7d9b3a62f4e8.png)Side navigation mock-up'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/a9a1fd13-c22a-4f01-9b08-7d9b3a62f4e8.png)侧边导航的模拟'
- en: 'Let''s implement the code for the side nav as a separate component, so that
    it is easier to maintain:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将侧边导航的代码实现为一个单独的组件，以便更容易维护：
- en: Create and declare a `NavigationMenuComponent` in `app.module`
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.module`中创建和声明`NavigationMenuComponent`。
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The side navigation isn't technically required until after a user is logged
    in. However, in order to be able to launch the side navigation menu from the toolbar,
    we need to be able to trigger it from `app.component`. Since this component will
    be simple, we will eagerly load it. To do this lazily, Angular does have a Dynamic
    Component Loader pattern, which has a high implementation overhead that will only
    make sense if multi-hundred kilobyte savings will be made.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户登录之后，其实并不需要侧边导航。但是，为了能够从工具栏启动侧边导航菜单，我们需要能够从`app.component`触发它。由于这个组件很简单，我们将急切加载它。要惰性加载它，Angular确实有一个动态组件加载器模式，但这种模式的实现开销很大，只有在节省数百千字节的情况下才有意义。
- en: '`SideNav` will be triggered from the toolbar, and it comes with a `<mat-sidenav-container>` parent
    container that hosts the `SideNav` itself and the content of the app. So we will
    need to render all app content by placing the `<router-outlet>` inside `<mat-sidenav-content>`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`SideNav`将从工具栏触发，并且它带有一个`<mat-sidenav-container>`父容器，其中包含`SideNav`本身和应用程序的内容。因此，我们需要通过将`<router-outlet>`放置在`<mat-sidenav-content>`中来渲染所有应用程序内容。'
- en: Import `MatSidenavModule` and `MatListModule` to material.module
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在material.module中导入`MatSidenavModule`和`MatListModule`
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define some styles that will ensure that the web app will expand to fill the
    entire page and remain properly scrollable on desktop and mobile scenarios:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些样式，以确保Web应用程序将扩展到填满整个页面，并在桌面和移动设备情况下保持正确的可滚动性：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Import an `ObservableMedia` service in `AppComponent`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`中导入`ObservableMedia`服务：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Update the template with a responsive `SideNav` that will slide over the content
    in mobile or push the content aside in desktop scenarios:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用响应式`SideNav`更新模板，该模板将在移动设备上滑动到内容上方，或者在桌面情况下将内容推到一边：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding template leverages Angular Flex Layout media observable for a
    responsive implementation that was injected earlier.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模板利用了早期注入的Angular Flex布局媒体可观察对象，实现了响应式实现。
- en: Since the links that will be shown inside the `SiveNav` will be of variable
    length and subject various role-based business rules, it is a good practice to
    implement it in a separate component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将显示在`SiveNav`内的链接长度不定，并且受到各种基于角色的业务规则的影响，最好将其实现为一个单独的组件。
- en: Implement a property getter for `displayAccountIcons` and a `setTimeout` so
    that you can avoid errors like `ExpressionChangedAfterItHasBeenCheckedError`
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`displayAccountIcons`实现一个属性获取器，并使用`setTimeout`来避免出现`ExpressionChangedAfterItHasBeenCheckedError`等错误
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Implement navigational links in `NavigationMenuComponent`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NavigationMenuComponent`中实现导航链接：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`<mat-nav-list>` is functionally equivalent to `<mat-list>`, so you can use
    the documentation for that component for layout purposes. Observe the subheaders
    for Manager, Inventory, and Clerk here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mat-nav-list>`在功能上等同于`<mat-list>`，因此您可以使用该组件的文档进行布局目的。观察这里的经理、库存和职员的子标题：'
- en: '![](Images/8c2bd49a-3dca-4beb-9e9a-d6d486e310e0.png)Manager dashboard showing
    receipt lookup on desktop'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/8c2bd49a-3dca-4beb-9e9a-d6d486e310e0.png)在桌面上显示的经理仪表板上的收据查找'
- en: '`routerLinkActive="active-link"` highlights the selected Receipts route, as
    shown in the preceding screenshot.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`routerLinkActive="active-link"`突出显示所选的收据路由，如前面的屏幕截图所示。'
- en: 'Additionally, you can see the difference in appearance and behavior on mobile
    devices as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以在移动设备上看到外观和行为的差异如下：
- en: '![](Images/358e52a3-137f-4616-a257-f070bffecc92.png)Manager dashboard showing
    receipt lookup on mobile'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/358e52a3-137f-4616-a257-f070bffecc92.png)在移动设备上显示的经理仪表板上的收据查找'
- en: Log out
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登出
- en: 'Now that we''re caching the login status, we need to implement a log out experience:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在缓存登录状态，我们需要实现一个登出体验：
- en: 'In `AuthService`, implement a `logout` function:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AuthService`中实现`logout`函数：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the `logout` component:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`logout`组件：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you note, after a log out, user is navigated back to the home page.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，注销后，用户将被导航回到主页。
- en: Role-based routing after login
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录后基于角色的路由
- en: This is the most elemental and important part of your application. With lazy
    loading, we have ensured only the bare minimum amount of assets will be loaded
    to enable a user to login.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您应用程序的最基本和重要的部分。通过延迟加载，我们确保只加载了最少量的资产，以使用户能够登录。
- en: Once a user logs in, they should be routed to the appropriate landing screen
    as per their user role, so they're not guessing how they need to use the app.
    For example, a cashier needs to only access the POS to check out customers, so
    they can automatically be routed to that screen.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 用户一旦登录，他们应该根据其用户角色被路由到适当的登陆屏幕，这样他们就不会猜测他们需要如何使用应用程序。例如，收银员只需要访问POS来结账，所以他们可以自动路由到该屏幕。
- en: 'You find the mock up of the POS screen as illustrated:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以找到POS屏幕的模拟如下所示：
- en: '![](Images/f87320ca-0c8c-44ac-ade3-cf04e7340f5e.png)Point-of-Sale screen mock-upLet''s
    ensure that users get routed to the appropriate page after logging in by updating
    the `LoginComponent`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/f87320ca-0c8c-44ac-ade3-cf04e7340f5e.png)销售点屏幕模拟让我们通过更新`LoginComponent`来确保用户在登录后被路由到适当的页面：'
- en: 'Update the `login` logic to route per role:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`login`逻辑以根据角色路由：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Similarly, clerks and manager are routed to their landing screens to access
    the features they need to accomplish their tasks, as shown earlier. Since we implemented
    a default manager role, the corresponding landing experience will be launched
    automatically. The other side of the coin is intentional and unintentional attempts
    to access routes that a user isn't meant to have access to. In the next section,
    we will learn about router guards that can help check authentication and even
    load requisite data before the form is rendered.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，职员和经理被路由到他们的登陆屏幕，以便访问他们需要完成任务的功能，就像之前展示的那样。由于我们实现了默认的经理角色，相应的登陆体验将自动启动。另一面是有意和无意地尝试访问用户无权访问的路由。在下一节中，我们将学习关于路由守卫，它可以在表单呈现之前帮助检查身份验证甚至加载必要的数据。
- en: Router Guards
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由守卫
- en: Router Guards enable further decoupling and reuse of logic and greater control
    over the component lifecycle.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 路由守卫使逻辑进一步解耦和重用，并对组件生命周期有更大的控制。
- en: 'Here are the four major guards you will most likely use:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您最有可能使用的四个主要守卫：
- en: '`CanActivate` and `CanActivateChild`, used for checking auth access to a route'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CanActivate`和`CanActivateChild`，用于检查对路由的授权访问'
- en: '`CanDeactivate`, used to ask permission before navigating away from a route'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CanDeactivate`，用于在离开路由之前请求权限'
- en: '`Resolve`, allows for pre-fetching of data from route parameters'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Resolve`，允许从路由参数预取数据'
- en: '`CanLoad`, allows for custom logic to execute before loading feature module
    assets'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CanLoad`，允许在加载功能模块资产之前执行自定义逻辑'
- en: Refer to the following sections for how to leverage `CanActivate` and `CanLoad` . `Resolve`
    guard will be covered in [Chapter 10,](99f040e3-89f0-4ac8-a849-4cef38e7a992.xhtml)
    *Angular App Design and Recipes*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何利用`CanActivate`和`CanLoad`，请参考以下章节。`Resolve`守卫将在[第10章](99f040e3-89f0-4ac8-a849-4cef38e7a992.xhtml)
    *Angular App Design and Recipes*中介绍。
- en: Auth Guard
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证守卫
- en: Auth Guards enable good UX by allowing or disallowing accidental navigation
    to a feature module or component before it is loaded and any data requests are
    made to the server.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证守卫通过允许或禁止在加载任何数据请求到服务器之前意外导航到功能模块或组件，从而实现良好的用户体验。
- en: For example, when a Manager logs in, they're automatically routed to the `/manager/home` path. The
    browser will cache this URL, and it will be completely plausible for a clerk to
    accidentally navigate to the same URL. Angular doesn't know whether a particular
    route is accessible to a user or not and, without an `AuthGuard`, it will happily
    render the Manager's home page and trigger server requests that will end up failing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当经理登录时，他们会自动路由到`/manager/home`路径。浏览器将缓存此URL，对于一个职员意外导航到相同的URL是完全合理的。Angular不知道特定路由对用户是否可访问，没有`AuthGuard`，它将愉快地渲染经理的主页并触发最终失败的服务器请求。
- en: 'Regardless of the robustness of your frontend implementation, every REST API
    you implement should be properly secured server-side.Let''s update the router
    so that `ProfileComponent` can''t be activated without an authenticated user and
    the `ManagerModule` won''t load unless a manager is logging in using an `AuthGuard`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 不管你的前端实现有多健壮，你实现的每个REST API都应该在服务器端得到适当的保护。让我们更新路由器，这样`ProfileComponent`在没有经过身份验证的用户的情况下就无法激活，而`ManagerModule`在没有经过经理使用`AuthGuard`登录的情况下就不会加载：
- en: 'Implement an `AuthGuard` service:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`AuthGuard`服务：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Use the `CanLoad` guard to prevent loading of lazily loaded module, such as
    Manager''s module:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CanLoad`守卫来阻止惰性加载模块，比如经理的模块：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this instance, when the `ManagerModule` is being loaded, `AuthGuard` will
    be activated during the `canLoad` event, and the `checkLogin` function will verify
    the authentication status of the user. If the guard returns `false`, the module
    will not be loaded. At this point, we don't have the metadata to check the role
    of the user.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当`ManagerModule`正在加载时，`AuthGuard`将在`canLoad`事件期间被激活，并且`checkLogin`函数将验证用户的身份验证状态。如果守卫返回`false`，模块将不会被加载。在这一点上，我们没有元数据来检查用户的角色。
- en: 'Use the `CanActivate` guard to prevent activation of individual components,
    such as user''s `profile`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CanActivate`守卫来阻止个别组件的激活，比如用户的`profile`：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the case of `user-routing.module`, `AuthGuard` is activated during the `canActivate` event,
    and the `checkLogin` function controls where this route can be navigated to. Since
    the user is viewing their own profile, there's no need to check the user's role
    here.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`user-routing.module`的情况下，在`canActivate`事件期间激活`AuthGuard`，并且`checkLogin`函数控制这个路由可以导航到哪里。由于用户正在查看自己的个人资料，这里不需要检查用户的角色。
- en: 'Use `CanActivate` or `CanActivateChild` with an `expectedRole` property to
    prevent activation of components by other users, such as `ManagerHomeComponent`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CanActivate`或`CanActivateChild`与`expectedRole`属性来阻止其他用户激活组件，比如`ManagerHomeComponent`：
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Inside `ManagerModule`, we can verify whether the user is authorized to access
    a particular route. We can do this by defining some metadata in the route definition,
    like `expectedRole`, which will be passed into the `checkLogin` function by the `canActivate` event.
    If a user is authenticated but their role doesn't match `Role.Manager`, `AuthGuard`
    will return false and the navigation will be prevented.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ManagerModule`内部，我们可以验证用户是否有权访问特定路由。我们可以通过在路由定义中定义一些元数据，比如`expectedRole`，将其传递给`checkLogin`函数来实现这一点，该函数将通过`canActivate`事件来激活。如果用户经过身份验证但其角色与`Role.Manager`不匹配，`AuthGuard`将返回false并阻止导航。
- en: Ensure that both `AuthService` and `AuthGuard` are provided in `app.module`
    and `manager.module` since they used in both contexts
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`AuthService`和`AuthGuard`都在`app.module`和`manager.module`中提供，因为它们在两个上下文中都被使用。
- en: As always, before moving on ensure that all your tests pass by executing `npm
    test` and `npm run e2e`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，在继续之前，请确保通过执行`npm test`和`npm run e2e`来通过所有测试。
- en: Auth Service Fake and Common Testing Providers
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证服务伪造和常见测试提供者
- en: We need to implement an `AuthServiceFake` so that our unit tests pass and use
    a pattern similar to `commonTestingModules` mentioned in [Chapter 7,](https://cdp.packtpub.com/full_stack_angular_for_java_developers__/wp-admin/post.php?post=29&action=edit) *Create
    a Router-First Line-of-Business App*, to conveniently provider this fake across
    our spec files.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个`AuthServiceFake`，以便我们的单元测试通过，并使用类似于[第7章](https://cdp.packtpub.com/full_stack_angular_for_java_developers__/wp-admin/post.php?post=29&action=edit)中提到的`commonTestingModules`模式，方便地在我们的规范文件中提供这个假数据。
- en: 'To ensure that our fake will have the same public functions and properties
    as the actual `AuthService`, let''s first start with creating an interface:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的假数据具有与实际`AuthService`相同的公共函数和属性，让我们首先创建一个接口：
- en: Add `IAuthService` to `auth.service.ts`
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IAuthService`添加到`auth.service.ts`
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Make sure `AuthService` implements the interface
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`AuthService`实现了接口
- en: Export `defaultAuthStatus` for reuse
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出`defaultAuthStatus`以便重复使用
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now we can create a fake that implements the same interface, but provides functions
    that don't have any dependencies to any external authentication system.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个实现相同接口的假数据，但提供的函数不依赖于任何外部认证系统。
- en: 'Create a new file named `auth.service.fake.ts` under `auth`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`auth`下创建一个名为`auth.service.fake.ts`的新文件。
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Update `common.testing.ts` with `commonTestingProviders`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`commonTestingProviders`更新`common.testing.ts`：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Observer the use of the fake in `app.component.spec.ts`:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察在`app.component.spec.ts`中使用假数据：
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The empty `commonTestingProviders` array we created earlier is being concatenated
    with fakes that are specific to `app.component`, so our new `AuthServiceFake`
    should apply automatically.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建的空`commonTestingProviders`数组正在与特定于`app.component`的假数据连接，因此我们的新`AuthServiceFake`应该自动应用。
- en: 'Update the spec file for `AuthGuard` shown as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AuthGuard`的规范文件如下所示：
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Go ahead and apply this technique to all spec files that have a dependency on
    `AuthService` and `UiService`
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续将这种技术应用到所有依赖于`AuthService`和`UiService`的规范文件中
- en: 'The notable exception is in `auth.service.spec.ts` where you do *not *want
    to use the fake, since `AuthService` is the class under test, make sure it is
    configure shown as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值得注意的例外情况是在`auth.service.spec.ts`中，您不希望使用假数据，因为`AuthService`是被测试的类，请确保它配置如下所示：
- en: '[PRE51]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In addition `SimpleDialogComponent` tests require stubbing out some external
    dependencies like:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，`SimpleDialogComponent`的测试需要对一些外部依赖进行存根处理，例如：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Remember, don't move on until all your tests are passing!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，直到所有测试都通过之前不要继续！
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now be familiar with how to create high-quality authentication and
    authorization experiences. We started by going over the importance of completing
    and documenting high-level UX design of our entire app so that we can properly
    design a great conditional navigation experience. We created a reusable UI service
    so that we can conveniently inject alerts into the flow-control logic of our app.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该熟悉如何创建高质量的身份验证和授权体验了。我们首先讨论了完成和记录整个应用的高级UX设计的重要性，以便我们可以正确地设计出色的条件导航体验。我们创建了一个可重用的UI服务，以便我们可以方便地将警报注入到我们应用的流程控制逻辑中。
- en: We covered the fundamentals of token-based authentication and JWTs so that you
    don't leak any critical user information. We learned that caching and HTTP interceptors
    are necessary so that users don't have to input their login information with every
    request. Finally, we covered router guards to prevent users from stumbling onto
    screens they are not authorized to use, and we reaffirmed the point that the real
    security of your application should be implemented on the server side.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了基于令牌的身份验证和JWT的基础知识，以便您不会泄漏任何关键用户信息。我们了解到缓存和HTTP拦截器是必要的，这样用户就不必在每个请求中输入他们的登录信息。最后，我们介绍了路由守卫，以防止用户意外进入他们未被授权使用的屏幕，并重申了应用程序的真正安全性应该在服务器端实现的观点。
- en: In the next chapter, we will go over a comprehensive list of Angular recipes
    to complete the implementation of our line-of-business app—LemonMart.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将逐一介绍一份全面的Angular配方清单，以完成我们的企业应用程序LemonMart的实施。
