- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: We have finally finished developing our application. Before we release it to
    production, we want to ensure that everything works as expected.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于完成了应用程序的开发。在我们将其发布到生产之前，我们想确保一切按预期工作。
- en: In this chapter, we will learn how to test our application by using different
    testing approaches. This will give us the confidence to refactor the application,
    build new features, and modify the existing ones without worrying about breaking
    the current application behavior.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用不同的测试方法来测试我们的应用程序。这将给我们信心重构应用程序，构建新功能，修改现有功能，而不用担心破坏当前应用程序的行为。
- en: 'We will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Unit testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: End-to-end testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试
- en: By the end of this chapter, we will know how to test our application with different
    methods and tools.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将知道如何使用不同的方法和工具来测试我们的应用程序。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we get started, we need to set up our project. To be able to develop
    our project, we will need the following things installed on our computer:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要设置我们的项目。为了能够开发我们的项目，我们需要在计算机上安装以下内容：
- en: '**Node.js** version 16 or above and **npm** version 8 or above'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js** 版本 16 或更高版本以及 **npm** 版本 8 或更高版本'
- en: 'There are multiple ways to install Node.js and npm. Here is a great article
    that goes into more detail: [https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Node.js 和 npm 有多种方法。这里有一篇很好的文章，详细介绍了更多细节：[https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js)。
- en: '**VSCode** (optional) is currently the most popular editor/IDE for JavaScript/TypeScript,
    so we will be using it. It is open source, has great integration with TypeScript,
    and we can extend its features via extensions. It can be downloaded from [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSCode**（可选）目前是 JavaScript/TypeScript 最受欢迎的编辑器/IDE，因此我们将使用它。它是开源的，与 TypeScript
    集成良好，我们可以通过扩展来扩展其功能。可以从 [https://code.visualstudio.com/](https://code.visualstudio.com/)
    下载。'
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production)。
- en: 'The repository can be cloned locally with the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令在本地克隆存储库：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the repository has been cloned, we need to install the application’s dependencies:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦克隆了存储库，我们需要安装应用程序的依赖项：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can provide the environment variables using the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令提供环境变量：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the dependencies have been installed, we need to select the right stage
    of the code base that matches this chapter. We can do that by executing the following
    command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了依赖项，我们需要选择与本章匹配的正确代码库阶段。我们可以通过执行以下命令来完成：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will prompt us with a list of stages for each chapter:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将为我们提供每个章节的阶段列表：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the eighth chapter, so we can select `chapter-08-start` if we want to
    follow along, or `chapter-08` to see the final results of this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第八章，因此如果我们想跟随，可以选择 `chapter-08-start`，或者选择 `chapter-08` 来查看本章的最终结果。
- en: Once the chapter has been selected, all the files required to follow along with
    this chapter will appear.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了章节，所有跟随该章节所需的文件将显示出来。
- en: For more information about the setup details, check out the `README.md` file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置细节的更多信息，请查看 `README.md` 文件。
- en: Unit testing
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is a testing method where application units are tested in isolation
    without depending on other parts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种测试方法，其中应用程序单元在隔离状态下进行测试，不依赖于其他部分。
- en: For unit testing, we will use Jest, which is the most popular framework for
    testing JavaScript applications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元测试，我们将使用 Jest，这是测试 JavaScript 应用程序最流行的框架。
- en: In our application, we will unit test the notifications store.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将对通知存储进行单元测试。
- en: 'Let’s open the `src/stores/notifications/__tests__/notifications.test.ts` file
    and add the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 `src/stores/notifications/__tests__/notifications.test.ts` 文件并添加以下内容：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The notifications test works as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通知测试工作如下：
- en: We assert that the `notifications` array is initially empty.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们断言 `notifications` 数组最初是空的。
- en: Then, we fire the `showNotification` action and test that the newly created
    notification exists in the `notifications` array.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们触发`showNotification`动作，并测试新创建的通知是否存在于`notifications`数组中。
- en: Finally, we call the `dismissNotification` function to dismiss the notification
    and make sure the notification is removed from the `notifications` array.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`dismissNotification`函数来取消通知，并确保通知已从`notifications`数组中移除。
- en: 'To run unit tests, we can execute the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行单元测试，我们可以执行以下命令：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another use case for unit testing would be various utility functions and reusable
    components, including logic that could be tested in isolation. However, in our
    case, we will test our components mostly with integration tests, which we will
    see in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的另一个用例将是各种实用函数和可重用组件，包括可以单独测试的逻辑。然而，在我们的案例中，我们将主要使用集成测试来测试我们的组件，这将在下一节中看到。
- en: Integration testing
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration testing is a testing method where multiple parts of the application
    are tested together. Integration tests are generally more helpful than unit tests,
    and most application tests should be integration tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是一种测试方法，其中测试应用程序的多个部分。集成测试通常比单元测试更有帮助，并且大多数应用程序测试应该是集成测试。
- en: Integration tests are more valuable because they can give more confidence in
    our application since we are testing the functionality of different parts, the
    relationship between them, and how they communicate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试更有价值，因为它们可以增加我们对应用程序的信心，因为我们正在测试不同部分的功能、它们之间的关系以及它们如何进行通信。
- en: For integration testing, we will use Jest and the React Testing Library. This
    is a great approach to testing features of the application in the same way the
    user would use it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集成测试，我们将使用Jest和React Testing Library。这是一种测试应用程序功能的好方法，就像用户使用它一样。
- en: 'In `src/testing/test-utils.ts`, we can define some utilities we can use in
    our tests. We should also re-export all utilities provided by the React Testing
    Library from here so that we can easily reach out to them whenever they are needed
    in our tests. Currently, in addition to all the functions provided by the React
    Testing Library, we are also exporting the following utilities:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/testing/test-utils.ts`中，我们可以定义一些我们可以在测试中使用的实用工具。我们还应该从这里重新导出React Testing
    Library提供的所有实用工具，这样我们就可以在测试中需要时轻松访问它们。目前，除了React Testing Library提供的所有函数外，我们还导出以下实用工具：
- en: '`appRender` is a function that calls the `render` function from the React Testing
    Library and adds `AppProvider` as a `wrapper`. We need this because, in our integration
    tests, our components rely on multiple dependencies defined in `AppProvider`,
    such as the React Query context, notifications, and more. Providing `AppProvider`
    as a `wrapper` will make it available when we render the component during testing.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appRender`是一个函数，它调用React Testing Library中的`render`函数，并将`AppProvider`作为`wrapper`。我们需要这样做，因为在我们进行集成测试时，我们的组件依赖于在`AppProvider`中定义的多个依赖项，例如React
    Query上下文、通知等。提供`AppProvider`作为`wrapper`将在我们测试期间渲染组件时使其可用。'
- en: '`checkTableValues` is a function that goes through all the cells in the table
    and compares each value with the corresponding value from the provided data, ensuring
    that all the information is displayed in the table.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkTableValues`是一个函数，它遍历表格中的所有单元格，并将每个值与提供的数据中的相应值进行比较，确保所有信息都显示在表格中。'
- en: '`waitForLoadingToFinish` is a function that waits for all loading spinners
    to disappear before we can proceed further with our tests. This is useful when
    we must wait for some data to be fetched before we can assert the values.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitForLoadingToFinish`是一个函数，它在我们可以继续进行测试之前等待所有加载旋转器消失。这在我们必须等待某些数据被获取后才能断言值时很有用。'
- en: Another file worth mentioning is `src/testing/setup-tests.ts`, where we can
    configure different initialization and cleanup actions. In our case, it helps
    us initialize and reset the mocked API between tests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提及的文件是`src/testing/setup-tests.ts`，在那里我们可以配置不同的初始化和清理动作。在我们的案例中，它帮助我们初始化和重置测试之间的模拟API。
- en: 'We can split our integration tests by pages and test all the parts on each
    page. The idea is to perform integration tests on the following parts of our application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据页面拆分我们的集成测试，并测试每个页面上的所有部分。想法是在以下部分对我们的应用程序进行集成测试：
- en: Dashboard jobs page
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板工作页面
- en: Dashboard job page
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板工作页面
- en: Create job page
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建工作页面
- en: Login page
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录页面
- en: Public job page
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共工作页面
- en: Public organization page
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共组织页面
- en: Dashboard jobs page
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪表板工作页面
- en: The functionality of the dashboard jobs page is based on the currently logged-in
    user. Here, we are fetching all the jobs of the user’s organization and displaying
    them in the jobs table.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板作业页面的功能基于当前登录用户。在这里，我们正在获取用户组织的所有作业并在作业表中显示它们。
- en: 'Let’s start by opening the `src/__tests__/dashboard-jobs-page.test.tsx` file
    and adding the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`src/__tests__/dashboard-jobs-page.test.tsx`文件并添加以下内容开始：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The test is working as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工作如下：
- en: Since loading the jobs depends on the currently logged-in user, we need to mock
    the `useUser` hook to return the proper user object.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于加载作业依赖于当前登录用户，我们需要模拟`useUser`钩子以返回正确的用户对象。
- en: Then, we render the page.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们渲染页面。
- en: Then, we make sure the jobs page’s title is displayed on the page.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们确保作业页面的标题显示在页面上。
- en: To get the loaded jobs, we need to wait for them to finish loading.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取已加载的作业，我们需要等待它们加载完成。
- en: Finally, we assert the jobs values in the table.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们断言表格中的作业值。
- en: Dashboard job page
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪表板作业页面
- en: The functionality of the dashboard job page is that we want to load the job
    data and display it on the page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板作业页面的功能是我们希望加载作业数据并在页面上显示它。
- en: 'Let’s start by opening the `src/__tests__/dashboard-job-page.test.tsx` file
    and adding the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`src/__tests__/dashboard-job-page.test.tsx`文件并添加以下内容开始：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The test works as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工作如下：
- en: Since we are loading job data based on the `jobId` URL parameter, we need to
    mock the `useRouter` hook to return the proper job ID.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们是根据`jobId` URL参数加载作业数据，我们需要模拟`useRouter`钩子以返回正确的作业ID。
- en: Then, we render the page and wait for the data to load by waiting for all loaders
    to disappear from the page.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们渲染页面并等待数据加载，通过等待页面上所有加载器消失来实现。
- en: Finally, we check that the job data is displayed on the page.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们检查作业数据是否显示在页面上。
- en: Job creation page
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作业创建页面
- en: The job creation page contains a form which, when submitted, calls the API endpoint
    that creates a new job on the backend. When the request succeeds, we redirect
    the user to the dashboard jobs page and show the notification about successful
    job creation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作业创建页面包含一个表单，当提交时，它调用API端点在后端创建一个新的作业。当请求成功时，我们将用户重定向到仪表板作业页面并显示关于成功创建作业的通知。
- en: 'Let’s start by opening the `src/__tests__/dashboard-create-job-page.test.tsx`
    file and adding the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`src/__tests__/dashboard-create-job-page.test.tsx`文件并添加以下内容开始：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The test works as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工作如下：
- en: First, we need to mock the `useRouter` hook to contain the `push` method because
    it is used for navigating to the jobs page after the submission.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要模拟`useRouter`钩子以包含`push`方法，因为提交后它用于导航到作业页面。
- en: Then, we render the page component.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们渲染页面组件。
- en: After that, we get all the inputs and insert values into them.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将所有输入值插入到它们中。
- en: Then, we submit the form by simulating the click event on the **Submit** button.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过模拟**提交**按钮上的点击事件来提交表单。
- en: After the submission, we need to wait for the **Job Created** notification to
    appear in the document.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交后，我们需要等待文档中显示**作业已创建**的通知。
- en: Public organization page
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共组织页面
- en: For the organization page, since we are rendering it on the server, we need
    to fetch the data on the server and display it on the page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组织页面，由于我们是在服务器上渲染它，我们需要在服务器上获取数据并在页面上显示。
- en: 'Let’s start by opening the `src/__tests__/public-organization-page.test.tsx`
    file and defining the skeleton of the test suite, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`src/__tests__/public-organization-page.test.tsx`文件并定义测试套件的骨架开始，如下所示：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we will focus on each test in the test suite.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将关注测试套件中的每个测试。
- en: 'First, we want to test that the `getServerSideProps` function fetches the right
    data and returns it as props, which will be provided on the page:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要测试`getServerSideProps`函数获取正确的数据并将其作为props返回，这些props将在页面上提供：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are calling the `getServerSideProps` function and asserting that the
    returned value contains the corresponding data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在调用`getServerSideProps`函数并断言返回的值包含相应的数据。
- en: 'In the second test, we want to verify that the data provided as props to the
    `PublicOrganizationPage` component is rendered properly:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试中，我们想要验证提供给`PublicOrganizationPage`组件的props是否正确渲染：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this test, we are rendering the page component and verifying that all the
    values are displayed on the page.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们正在渲染页面组件并验证所有值是否显示在页面上。
- en: 'In the third test of the test suite, we want to assert that if the organization
    does not exist, we want to display the *not* *found* message:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试套件的第三个测试中，我们想要断言如果组织不存在，我们想要显示*未找到*消息：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are rendering the `PublicOrganizationPage` component with an organization
    value of `null`, and then verifying that the *not found* message should be in
    the document.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在渲染`PublicOrganizationPage`组件，并使用`null`的组织值，然后验证*未找到*消息是否在文档中。
- en: Public job page
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共职位页面
- en: For the public job page, since we are rendering it on the server, we need to
    fetch the data on the server and display it on the page.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于公共职位页面，由于我们在服务器上渲染它，我们需要在服务器上获取数据并在页面上显示它。
- en: 'Let’s start by opening the `src/__tests__/public-job-page.test.tsx` file and
    defining the skeleton for the tests:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`src/__tests__/public-job-page.test.tsx`文件并定义测试的框架开始：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we can focus on each test in the test suite.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以专注于测试套件中的每个测试。
- en: 'First, we need to test the `getServerSideProps` function, which will fetch
    the data and return it via props to the page:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要测试`getServerSideProps`函数，它将获取数据并通过props将数据返回到页面：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are calling `getServerSideProps` and asserting whetherthe return value
    matches the expected data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`getServerSideProps`并断言返回值是否与预期数据匹配。
- en: 'Now, we can test `PublicJobPage`, where we want to ensure the provided data
    is displayed on the page:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试`PublicJobPage`，我们想要确保提供的数据显示在页面上：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we are rendering the page component and verifying that the given job’s
    data is displayed on the page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们渲染页面组件并验证提供的职位数据是否显示在页面上。
- en: 'Finally, we want to assert the case where the data provided by `getServerSideProps`
    does not exist:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们要断言`getServerSideProps`提供的数据不存在的情况：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since there are several cases where the data can be considered invalid, we are
    using the `rerender` function, which can re-render the component with a different
    set of props. We assert that if the data is not found, the *not found* message
    is displayed on the page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在多个数据可能被视为无效的情况，我们使用了`rerender`函数，它可以使用不同的props集重新渲染组件。我们断言如果数据未找到，则*未找到*消息将在页面上显示。
- en: Login page
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录页面
- en: The login page renders the login form, which, when submitted successfully, navigates
    the user to the dashboard.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面渲染登录表单，当成功提交时，将用户导航到仪表板。
- en: 'Let’s start by opening the `src/__tests__/login-page.test.tsx` file and adding
    the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`src/__tests__/login-page.test.tsx`文件并添加以下内容开始：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The test works as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工作如下：
- en: We need to mock the `useRouter` hook because it is being used to navigate the
    user to the dashboard on successful submission.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要模拟`useRouter`钩子，因为它被用来在成功提交时将用户导航到仪表板。
- en: Next, we render the page.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们渲染页面。
- en: Then, we enter the credentials into the form and submit it.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将凭据输入到表单中并提交。
- en: Finally, we expect the `replace` method on the router to be called with the
    `/dashboard/jobs` value, which should navigate the user to the dashboard if the
    login submission succeeds.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们期望在路由器上的`replace`方法被调用，并带有`/dashboard/jobs`值，如果登录提交成功，则应将用户导航到仪表板。
- en: 'To run the integration tests, we can execute the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行集成测试，我们可以执行以下命令：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we want to watch the changes in the test, we can execute the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想观察测试中的变化，我们可以执行以下命令：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: End-to-end testing
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试
- en: End-to-end testing is a testing method where an application is tested as a complete
    entity. Usually, these tests consist of running the entire application with the
    frontend and the backend in an automated way and verifying that the entire system
    works.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是一种将应用程序作为一个完整实体进行测试的测试方法。通常，这些测试包括以自动化方式运行整个应用程序，包括前端和后端，并验证整个系统是否正常工作。
- en: In end-to-end tests, we usually want to test the happy path to confirm that
    everything works as expected.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在端到端测试中，我们通常想要测试成功路径，以确认一切按预期工作。
- en: To test our application end to end, we will be using Cypress, a very popular
    testing framework that works by executing the tests in a headless browser. This
    means that the tests will be running in a real browser environment. In addition
    to Cypress, since we have become familiar with the React Testing Library, we will
    use the Testing Library plugin for Cypress to interact with the page.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的应用程序端到端，我们将使用Cypress，这是一个非常流行的测试框架，它通过在无头浏览器中执行测试来工作。这意味着测试将在真实的浏览器环境中运行。除了Cypress之外，由于我们已经熟悉了React
    Testing Library，我们将使用Cypress的Testing Library插件来与页面交互。
- en: 'For our application, we want to test two flows of the application:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们想要测试两个应用程序的流程：
- en: Dashboard flow
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板流程
- en: Public flow
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共流程
- en: Dashboard flow
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪表板流程
- en: The dashboard flow is the flow for organization admins where we want to test
    authenticating the user and accessing and interacting with different parts of
    the dashboard.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板流程是组织管理员想要测试用户认证以及访问和交互仪表板不同部分的流程。
- en: 'Let’s start by opening the `cypress/e2e/dashboard.cy.ts` file and adding the
    skeleton for our test:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`cypress/e2e/dashboard.cy.ts`文件并添加我们的测试骨架开始：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, let’s implement the tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来实现测试。
- en: 'First, we want to authenticate into the dashboard:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要认证进入仪表板：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we want to clear cookies and `localStorage`. Then, we must attempt to
    navigate to the dashboard; however, the application will redirect us to the login
    page. We must enter the credentials in the login form and submit it. After that,
    we will be redirected to the dashboard jobs page, where we can see the **Jobs**
    title.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要清除cookies和`localStorage`。然后，我们必须尝试导航到仪表板；然而，应用程序将重定向我们到登录页面。我们必须在登录表单中输入凭据并提交。之后，我们将被重定向到仪表板职位页面，在那里我们可以看到**职位**标题。
- en: 'Now that we are on the dashboard jobs page, we can proceed further by visiting
    the job details page:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处于仪表板职位页面，我们可以通过访问职位详情页面来进一步操作：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we are clicking the **View** link of one of the jobs and navigating to
    the job details page, where we verify that the selected job data is being displayed
    on the page.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们点击了其中一个职位的**查看**链接，并导航到职位详情页面，以验证所选的职位数据是否显示在页面上。
- en: 'Now, let’s test the job creation process:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试职位创建过程：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since we are on the job details page, we need to navigate back to the dashboard
    jobs page, where we can click on the **Create Job** link. This will take us to
    the create job page. Here, we fill in the form and submit it. When the submission
    succeeds, the **Job Created** notification should appear.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处于职位详情页面，我们需要导航回仪表板职位页面，在那里我们可以点击**创建职位**链接。这将带我们到创建职位页面。在这里，我们填写表格并提交。当提交成功时，应该会显示**职位已创建**的通知。
- en: 'Now that we have tested at all the features of the dashboard, we can log out
    from the dashboard:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了仪表板的所有功能，我们可以从仪表板注销：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Clicking the **Log Out** button logs the user out and redirects them to the
    login page.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**注销**按钮将用户注销并重定向到登录页面。
- en: Public flow
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共流程
- en: The public flow of the application is available for everyone who visits it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的公共流程对访问它的每个人都是可用的。
- en: 'Let’s start by opening the `cypress/e2e/public.cy.ts` file and adding the skeleton
    of the test:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`cypress/e2e/public.cy.ts`文件并添加测试的骨架开始：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, let’s start implementing the tests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实现测试。
- en: 'First, we want to visit the organization page:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要访问组织页面：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we are visiting an organization details page and checking whether the
    data displayed there matches the organization.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在访问组织详情页面，并检查显示的数据是否与组织匹配。
- en: 'Now that we are on the organization details page, we can view a job of the
    organization:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处于组织详情页面，我们可以查看组织的职位：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we click the **View** link of a job, and then we navigate to the job details
    page, where we are asserting the job data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们点击了职位的**查看**链接，然后导航到职位详情页面，在这里我们断言职位数据。
- en: 'To run end-to-end tests, we need to build the application first by running
    the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行端到端测试，我们需要首先通过运行以下命令来构建应用程序：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we can start the tests by opening the browser:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过打开浏览器来开始测试：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alternatively, we can run the tests in headless mode since it is less resource-demanding,
    which is great for CI:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以以无头模式运行测试，因为它对资源的需求较少，这对于CI来说非常好：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to test our application, thus making it ready
    for production.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何测试我们的应用程序，使其准备好投入生产。
- en: We started by learning about unit testing by implementing unit tests for our
    notifications store.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过为我们的通知存储实现单元测试来学习单元测试。
- en: Since integration tests are much more valuable because they give more confidence
    that something is working properly, we used these tests to test the pages.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集成测试非常有价值，因为它们提供了更多的信心，表明某些东西正在正常工作，我们使用了这些测试来测试页面。
- en: Finally, we created end-to-end tests for public and dashboard flows, where we
    tested the entire functionality of each flow.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为公共和仪表板流程创建了端到端测试，其中我们测试了每个流程的整个功能。
- en: In the next chapter, we will learn how to prepare and release our application
    to production. We will use these tests and integrate them within our CI/CD pipeline,
    where we will not allow the application to be released to production if any of
    the tests fail. This will keep our users more satisfied as there is less chance
    of bugs ending up in production.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何准备和发布我们的应用程序到生产环境。我们将使用这些测试并将它们集成到我们的CI/CD管道中，如果任何测试失败，我们将不允许应用程序发布到生产环境。这将使我们的用户更加满意，因为出现错误最终进入生产环境的可能性更小。
