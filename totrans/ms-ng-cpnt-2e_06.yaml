- en: Keeping up with Activities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持活动更新
- en: In this chapter, we'll build an activity log in our task management system,
    using **Scalable Vector Graphics** (**SVG**) to build graphical components with
    Angular. SVG is the perfect candidate when it comes to complex graphical content,
    and by using Angular components, we can easily build encapsulated and reusable
    content.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 **可伸缩矢量图形**（**SVG**）和 Angular 构建图形组件来构建我们的任务管理系统中的活动日志。SVG 是处理复杂图形内容的完美选择，通过使用
    Angular 组件，我们可以轻松构建封装和可重用的内容。
- en: Since we want to log all of the activities within our application, such as adding
    comments or renaming tasks, we are going to create a central repository for activities.
    We can then display these activities and render them as an activity timeline by
    using SVG.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望记录我们应用程序中的所有活动，例如添加评论或重命名任务，我们将创建一个活动中央存储库。然后我们可以使用 SVG 显示这些活动并将它们渲染为活动时间线。
- en: To add an overview of all of the activities and to provide user input to narrow
    the range of activities displayed, we're going to create an interactive slider
    component. This component will use a projection to render timestamps, in the form
    of ticks and activities, directly on the slider's background. We'll also use SVG
    to render the elements within the component.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加所有活动的概述并提供用户输入以缩小显示活动的范围，我们将创建一个交互式滑块组件。此组件将使用投影在滑块的背景上渲染时间戳，以形式为刻度和活动。我们还将使用
    SVG 在组件内渲染元素。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: A basic introduction to SVG
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG 的基本介绍
- en: Making SVG composable with Angular components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使 SVG 可与 Angular 组件组合
- en: Using namespaces in component templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件模板中使用命名空间
- en: Creating a simple pipe to format calendar times using Moment.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的管道，使用 Moment.js 格式化日历时间
- en: Using the `@HostListener` decorator to handle user input events, to create an
    interactive slider element
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@HostListener` 装饰器处理用户输入事件，以创建交互式滑块元素
- en: Making use of Shadow DOM using `ViewEncapsulation.Native`, in order to create
    native style encapsulation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ViewEncapsulation.Native` 来利用 Shadow DOM，以创建原生样式封装
- en: Creating a service for logging activities
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于记录活动的服务
- en: The goal of this chapter is to provide a way to keep track of all user activities
    within a task management application. For that purpose, we'll need a system that
    will allow us to log activities within components and access previously logged
    activities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是提供一个方法来跟踪任务管理应用程序中的所有用户活动。为此，我们需要一个系统，允许我们在组件内记录活动并访问先前记录的活动。
- en: Within this chapter, we'll only track activities on projects. However, the activity
    tracker can be used in any feature within our application. We're going to use
    TypeScript discriminated unions to describe our activities. Let's jump right into
    it and start by creating the model used within our new activities feature.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只跟踪项目上的活动。然而，活动跟踪器可以用于我们应用程序中的任何功能。我们将使用 TypeScript 区分联合来描述我们的活动。让我们直接进入正题，首先创建我们新活动功能中使用的模型。
- en: 'Let''s open our model file, located in `src/app/model.ts`, and add the following
    changes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 `src/app/model.ts` 的模型文件，并添加以下更改：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Activities, as entities, should be quite generic, and should have the following
    fields with their respective purposes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实体，活动应该是相当通用的，并且应该具有以下字段及其相应用途：
- en: '`user`: The user object of the user that is responsible for this activity.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：负责此活动的用户对象。'
- en: '`time`: The timestamp of the activity. We will format this timestamp to a readable
    display format, but will also use it for our projection math when we draw our
    activity slider.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`：活动的时间戳。我们将对此时间戳进行格式化以供可读的显示格式，但当我们绘制活动滑块时，我们还将使用它进行投影数学。'
- en: '`category`: This field provides an additional way of tagging the activity.
    For projects, we will currently use two categories; **comments** and **tasks**.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category`：此字段提供了一种额外的标记活动的方式。对于项目，我们目前将使用两个类别；**评论**和**任务**。'
- en: '`title`: This refers to the title of the activity, which will provide a very
    brief summary of what the activity is about. This could be something such as *New
    task was added* or *Comment was added*.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这指的是活动的标题，它将提供关于活动内容的非常简短的摘要。这可能像 *新任务已添加* 或 *评论已添加* 这样的内容。'
- en: '`message`: This is the field where the real beef of the activity goes. It should
    contain enough information to provide good traceability of what happened during
    the activity.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：这是活动真正内容所在字段。它应该包含足够的信息，以便在活动期间提供良好的可追溯性。'
- en: Additionally, we're creating an interface, `ActivitySliderSelection`, which
    we're going to use when communicating selection changes within our custom slider
    UI component.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还在创建一个接口`ActivitySliderSelection`，我们将在与我们的自定义滑块UI组件通信选择变化时使用它。
- en: The custom type, `ActivityAlignment`, will be used to store information about
    the positioning of activities on a timeline.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型`ActivityAlignment`将被用来存储关于活动在时间线上的位置信息。
- en: 'Let''s also update our in-memory database with some initial data, so that we
    have something to work with when creating our UI components for the activities
    view. Open up the file located in `src/app/database.ts`, and apply the following
    changes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也更新我们的内存数据库，以便在创建活动视图的UI组件时有东西可以工作。打开位于`src/app/database.ts`的文件，并应用以下更改：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we can go ahead and create a service to load activities and log new activities.
    Let''s use the Angular CLI to create the stub of our service:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续创建一个服务来加载活动和记录新活动。让我们使用Angular CLI来创建我们服务的占位符：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will generate a new service class on the path `src/app/activities/activities.service.ts`.
    Let''s open that file and add the necessary code to implement our service:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在路径`src/app/activities/activities.service.ts`上生成一个新的服务类。让我们打开那个文件，并添加必要的代码来实现我们的服务：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There's not much that we need to discuss here. Our service is very similar to
    the task list or project service that we already created. Additionally, when obtaining
    an observable of our activities behavior subject, we're performing a sort on the
    emitted activity list. We always want to emit the activity list sorted by activity
    time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多需要讨论的。我们的服务与我们已经创建的任务列表或项目服务非常相似。另外，当我们获取我们的活动行为主题的可观察对象时，我们正在对发出的活动列表进行排序。我们总是希望按活动时间发出排序后的活动列表。
- en: Since activities can't be edited or deleted, we only need to be concerned with
    newly added activities.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于活动不能被编辑或删除，我们只需要关注新添加的活动。
- en: In the `logProjectActivity` method, we're simply posting a new activity into
    our in-memory web database, using the Angular HTTP client. The user service will
    provide us with information on the currently logged-in user.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`logProjectActivity`方法中，我们只是使用Angular HTTP客户端将一个新的活动发布到我们的内存中Web数据库。用户服务将为我们提供当前登录用户的信息。
- en: That's it on the data front. We have created a simple platform that will help
    us keep track of activities within our application. Later in this book, we can
    use the activities service to track all sorts of activities. For now, we're just
    concerned with project-related activities.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数据方面就到这里。我们创建了一个简单的平台，将帮助我们跟踪应用程序中的活动。在本书的后面部分，我们可以使用活动服务来跟踪所有类型的活动。现在，我们只关心与项目相关的活动。
- en: Logging activities
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录活动
- en: We have created a nice system to log activities. Now, let's go ahead and use
    it within our components, to keep an audit of all of the activities happening
    within the context of projects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个很好的系统来记录活动。现在，让我们继续在我们的组件中使用它，以保持对项目上下文中发生的所有活动的审计。
- en: First, let's use our activities service to log activities when project tasks
    get updated and created. Logging activities can be viewed as an application side
    effect, and we don't want to cause side effects within our pure UI components.
    Instead, the container components are the perfect places to perform these kinds
    of operations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用我们的活动服务来记录当项目任务被更新和创建时的活动。记录活动可以被视为应用程序的副作用，我们不希望在纯UI组件中引起副作用。相反，容器组件是执行这些操作的理想场所。
- en: 'Let''s open the container component for our task list on the path `src/app/container/task-list-container/task-list-container.component.ts`,
    and apply the following changes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于`src/app/container/task-list-container/task-list-container.component.ts`的任务列表容器组件，并应用以下更改：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the `logProjectActivity` method of our activities service, we can easily
    log an activity for creating and updating tasks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们活动服务的`logProjectActivity`方法，我们可以轻松地记录创建和更新任务的活动。
- en: In the message body of our activities, we've used a new utility function, `limitWithEllipsis`,
    which we're importing from a new module, called `string-utilities`. This function
    truncates an input string and cuts it off at a position specified with a second
    parameter. In addition, it appends an ellipsis character (`…`) at the end of the
    truncated string. This is a nice utility for when we want to create a preview
    of text that might be lengthy.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的活动消息体中，我们使用了一个新的实用函数`limitWithEllipsis`，我们从这个名为`string-utilities`的新模块中导入它。这个函数截断输入字符串，并在第二个参数指定的位置截断。此外，它还在截断字符串的末尾添加一个省略号字符（`…`）。这是一个当我们需要创建可能很长的文本预览时的有用工具。
- en: 'Let''s quickly craft this little helper function and create a new file on the
    path `src/app/utilities/string-utilities.ts`. Open up the file and add the following
    code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速构建这个小小的辅助函数，并在路径`src/app/utilities/string-utilities.ts`上创建一个新文件。打开文件，并添加以下代码：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's it for now. We're successfully logging activities upon task creation
    and updates. We're also going to use the activity service within the project comments
    container component to create logs for added and edited comments. Since the steps
    involved are very similar to what we've just done for the task list container
    component, we're going to skip over this. You can always take a look at the final
    code base for this chapter to add activity logs for the project comments container
    component.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止。我们已经成功地在任务创建和更新时记录活动。我们还将使用项目评论容器组件中的活动服务来创建添加和编辑评论的日志。由于涉及的步骤与我们刚刚为任务列表容器组件所做的工作非常相似，我们将跳过这一部分。您始终可以查看本章的最终代码库，为项目评论容器组件添加活动日志。
- en: Leveraging the power of SVG
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用SVG的力量
- en: 'SVG has been a part of the Open web platform standards since 1999, and was
    first recommended in 2001, under the SVG 1.0 standard. SVG is a consolidation
    of two independent proposals for an XML-based vector image format. **Precision
    Graphics** **Markup Language** (**PGML**), mainly developed by Adobe and Netscape,
    and **Vector Markup Language** (**VML**), which was mainly represented by Microsoft
    and Macromedia, were both different XML formats that served the same purpose.
    The W3C consortium declined both of the proposals in favor of the newly developed
    SVG standard, which unified the best of both worlds into a single standard:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SVG自1999年以来一直是开放网络平台标准的一部分，并于2001年首次推荐，当时是SVG 1.0标准。SVG是两个基于XML的矢量图像格式的独立提案的整合。**精确图形标记语言**（**PGML**），主要由Adobe和Netscape开发，以及**矢量标记语言**（**VML**），主要由Microsoft和Macromedia代表，都是不同的XML格式，服务于相同的目的。W3C联盟拒绝了这两个提案，转而支持新开发的SVG标准，将两者的优点统一到一个标准中：
- en: '![](img/b6273a34-2e1c-4c5b-8b3c-da7f8ed8cef9.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6273a34-2e1c-4c5b-8b3c-da7f8ed8cef9.png)'
- en: Timeline showing the development of the SVG standard
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 展示SVG标准发展的时间线
- en: All three standards had a common goal, which was to provide a format for the
    web to display vector graphics in the browser. SVG is a declarative language that
    specifies graphical objects using XML elements and attributes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三个标准都有一个共同的目标，那就是为网络提供一个格式，以便在浏览器中显示矢量图形。SVG是一种声明性语言，它使用XML元素和属性来指定图形对象。
- en: 'Let''s look at a simple example of how to create an SVG image with a black
    circle, using SVG:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用SVG创建一个黑色圆形的简单示例：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This rather simple example represents an SVG image with a black circle, whose
    center is located at `cx="10"` px and `cy="10"` px. The radius of the circle is
    `10` px, which makes this circle `20` px in width and height.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当简单的例子代表了一个SVG图像，其中有一个黑色的圆形，其中心位于`cx="10"` px和`cy="10"` px。圆的半径是`10` px，这使得这个圆的宽度和高度都是`20`
    px。
- en: 'The origin of the coordinate system in SVG sits on the top-left corner, where
    the *y*-axis faces the south direction and the *x*-axis eastward:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SVG坐标系的原点位于左上角，其中*y*轴朝南方向，*x*轴向东：
- en: '![](img/eba7f085-0746-49c7-af8f-b924daa109e1.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eba7f085-0746-49c7-af8f-b924daa109e1.png)'
- en: The coordinate system within SVG
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SVG内部的坐标系
- en: Using not only primitive shapes, such as circles, lines, and rectangles, but
    also complex polygons, the possibilities for creating graphical content are nearly
    unlimited.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以使用原始形状，如圆形、线条和矩形，还可以使用复杂的多边形，创建图形内容的可能性几乎是无限的。
- en: SVG is not only used within the web, but has also become a very important intermediate
    format for exchanging vector graphics between different applications. Almost any
    application that supports vector graphics also supports the import and export
    of SVG files.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SVG不仅用于网络，而且已经成为不同应用程序之间交换矢量图形的重要中间格式。几乎任何支持矢量图形的应用程序都支持导入和导出SVG文件。
- en: The real power of SVG comes to the surface when we do not include an SVG file
    as an HTML image element, but rather, include the SVG content directly within
    our DOM. Since HTML5 directly supports the SVG namespace within an HTML document
    and will render the graphics that we define within our HTML, a whole bunch of
    new possibilities spring up. We can now style our SVG with CSS, manipulate the
    DOM with JavaScript, and easily make our SVG interactive.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不将SVG文件作为HTML图像元素包含在内，而是直接在我们的DOM中包含SVG内容时，SVG的真正力量才显现出来。由于HTML5直接支持HTML文档中的SVG命名空间，并将渲染我们在HTML中定义的图形，因此出现了一系列新的可能性。现在，我们可以使用CSS来样式化SVG，使用JavaScript来操作DOM，并轻松地使SVG交互式。
- en: 'Taking the previous example of our circle image to the next level, we could
    make it interactive by changing the circle color (by clicking on it). First, let''s
    create a minimal HTML document and include our SVG elements directly within the
    DOM:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们之前的圆形图像示例提升到下一个层次，我们可以通过改变圆的颜色（通过点击它）使其交互式。首先，让我们创建一个最小的HTML文档，并将我们的SVG元素直接包含在DOM中：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we can get rid of the version and the XML namespace declaration
    when we use SVG directly within the DOM of our HTML document. What's interesting
    here is that we can treat SVG very much like regular HTML. We can assign an ID,
    and even classes, to SVG elements, and access them from JavaScript.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当我们直接在我们的HTML文档的DOM中使用SVG时，我们可以去掉版本和XML命名空间声明。这里有趣的是，我们可以将SVG视为非常普通的HTML。我们可以为SVG元素分配一个ID，甚至类，并从JavaScript中访问它们。
- en: Within the `script` tag of our HTML document, we can directly access our `circle`
    element using the ID we've previously assigned to it. We can add event listeners
    to SVG elements the same way as with regular HTML elements. In this example, we
    added a `click` event listener and changed the color of our circle to red.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML文档的`script`标签中，我们可以直接使用之前分配给它的ID访问我们的`circle`元素。我们可以像处理常规HTML元素一样为SVG元素添加事件监听器。在这个例子中，我们添加了一个`click`事件监听器，并将我们的圆的颜色改为红色。
- en: For the sake of simplicity, we used an inline `script` tag in this example.
    It would, of course, be much cleaner to have a separate JavaScript file to do
    the scripting.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们在本例中使用了内联`script`标签。当然，使用一个单独的JavaScript文件来进行脚本编写会更为整洁。
- en: Styling SVG
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG样式
- en: I'm a purist when it comes to the separation of concerns within the web. I still
    strongly believe in the separation of structure (HTML), appearance (CSS), and
    behavior (JavaScript), as well as producing the most maintainable applications
    when following this practice.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中关注点的分离方面，我是一个纯粹主义者。我仍然坚信结构（HTML）、外观（CSS）和行为（JavaScript）的分离，以及遵循这一实践时产生最易于维护的应用程序。
- en: 'First, it seems weird to have SVG in your HTML, and you might think that this
    breaks the contract of a clean separation. Why is this graphical content, consisting
    of only appearance-relevant data, sitting in my HTML, which is supposed to contain
    only raw information? After dealing with a lot of SVGs within a DOM, I have come
    to the conclusion that we can establish a clean separation when using SVG by dividing
    our appearance responsibilities into the two following subgroups:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在HTML中包含SVG看起来有些奇怪，你可能会认为这打破了清晰的分离合同。为什么只有外观相关的数据组成的图形内容，会坐在我的HTML中，而HTML本应只包含原始信息？在处理了大量DOM中的SVG之后，我得出结论，我们可以通过将外观责任分为以下两个子组来使用SVG建立清晰的分离：
- en: '**Graphical structure**: This subgroup deals with the process of defining the
    basic structure of your graphical content. This is about shapes and layout.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形结构**：这个子组处理定义你的图形内容基本结构的过程。这是关于形状和布局。'
- en: '**Visual appearance**: This subgroup deals with the process of defining the
    look and feel of our graphical structures, such as colors, line widths, line styles,
    and text alignment.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉外观**：这个子组处理定义我们图形结构的外观和感觉的过程，例如颜色、线宽、线型和文本对齐。'
- en: If we separate the concerns of SVG into these groups, we can actually gain great
    maintainability. The graphical structure is defined by the SVG shapes themselves.
    They are directly written within our HTML, but don't have a particular look and
    feel. We only store the basic structural information within HTML.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将SVG的关注点分为这些组，我们实际上可以获得很好的可维护性。图形结构由SVG形状本身定义。它们直接写入我们的HTML中，但没有特定的外观和感觉。我们只在HTML中存储基本的结构信息。
- en: Luckily, instead of using attributes on SVG elements, all the properties for
    visual appearance, such as color, can also be specified with corresponding CSS
    properties. That allows us to offload all of the look-and-feel relevant aspects
    of the structure to CSS.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要在SVG元素上使用属性，所有与视觉外观相关的属性，例如颜色，也可以使用相应的CSS属性来指定。这允许我们将结构与外观相关的所有方面都卸载到CSS中。
- en: 'Let''s go back to the example where we drew a black circle; we''ll tweak this
    a bit, to fit our demands of separation of concerns, so that we can distinguish
    graphical structure from graphical appearance:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们画黑色圆圈的例子；我们将稍作调整，以满足我们对关注点分离的需求，以便我们可以区分图形结构和图形外观：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Styling our graphical structures can now be achieved by using CSS, including
    a style sheet with the following content:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过使用CSS来样式化我们的图形结构，包括以下内容的样式表：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is fantastic, as we can not only reuse some graphical structures, but can
    also apply different visual appearance parameters using CSS, similar to those
    enlightening moments when we managed to reuse some semantic HTML by only changing
    some CSS.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太棒了，因为我们不仅可以重用一些图形结构，还可以使用CSS应用不同的视觉外观参数，类似于我们通过仅更改一些CSS就成功重用了一些语义HTML时的启发时刻。
- en: 'Let''s look at the most important CSS properties that we can use to style SVG
    shapes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以用来样式化SVG形状的最重要CSS属性：
- en: '`fill`: When working with solid SVG shapes, there''s always a shape fill and
    stroke option available; the `fill` property specifies the color of the shape
    fill.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill`: 当与实心SVG形状一起工作时，始终有形状填充和轮廓选项可用；`fill`属性指定了形状填充的颜色。'
- en: '`stroke`: This property specifies the color of the SVG shape''s outline.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke`: 这个属性指定了SVG形状轮廓的颜色。'
- en: '`stroke-width`: This property specifies the width of the SVG shape''s outline
    on solid shapes. For non-solid shapes, such as lines, this can be thought of as
    the line width.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke-width`: 这个属性指定了SVG形状轮廓的宽度，对于实心形状而言。对于非实心形状，例如线条，这可以被视为线条宽度。'
- en: '`stroke-dasharray`: This specifies a dash pattern for strokes. Dash patterns
    are space-separated values that define a pattern.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke-dasharray`: 这指定了线条的虚线模式。虚线模式是由空格分隔的值，定义了一个模式。'
- en: '`stroke-dashoffset`: This specifies an offset for the dash pattern, which is
    specified with the `stroke-dasharray` property.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke-dashoffset`: 这指定了虚线模式的偏移量，该偏移量由`stroke-dasharray`属性指定。'
- en: '`stroke-linecap`: This property defines how line caps should be rendered. They
    can be rendered as square, butt, or rounded caps.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke-linecap`: 这个属性定义了线条端点应该如何渲染。它们可以渲染为方形、平头或圆角端点。'
- en: '`stroke-linejoin`: This property specifies how lines are joined together within
    a path.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke-linejoin`: 这个属性指定了路径内线条的连接方式。'
- en: '`shape-rendering`: Using this property, you can override the shape-rendering
    algorithm that, as the name suggests, is used to render shapes. This is particularly
    useful if you need crispy edges on your shapes.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shape-rendering`: 使用这个属性，你可以覆盖用于渲染形状的形状渲染算法，正如其名所示。如果你需要在形状上获得清晰的边缘，这特别有用。'
- en: For a complete reference of the available appearance-relevant SVG attributes,
    visit the Mozilla Developer website at [https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关可用外观相关SVG属性的完整参考，请访问Mozilla开发者网站[https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute)。
- en: I hope that this brief introduction gave you a better feeling about SVG and
    the great power it comes with. In this chapter, we're going to use some of that
    power to create nice, interactive graphical components. If you would like to learn
    more about SVG, I strongly recommend that you go through the great articles by
    Sara Soueidan.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这个简短的介绍让你对SVG及其带来的强大功能有了更好的感觉。在本章中，我们将使用其中的一些功能来创建漂亮的、交互式的图形组件。如果你想了解更多关于SVG的信息，我强烈建议你阅读Sara
    Soueidan的精彩文章。
- en: Building SVG components
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建SVG组件
- en: When building Angular components with SVG templates, there are a couple of things
    that you need to be aware of. The first and most obvious one is XML namespaces.
    Modern browsers are very intelligent when parsing HTML. Besides being probably
    the most fault-tolerant parsers in the history of computer science, DOM parsers
    are very smart in recognizing markup, and then deciding how to treat it. They
    will automatically decide the correct namespaces for us, based on element names,
    so we don't need to deal with them when writing HTML.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 SVG 模板构建 Angular 组件时，有一些事情你需要注意。首先也是最明显的一点是 XML 命名空间。现代浏览器在解析 HTML 时非常智能。除了可能是计算机科学历史上最容错的解析器之外，DOM
    解析器在识别标记并决定如何处理它方面也非常聪明。它们会根据元素名称自动为我们决定正确的命名空间，因此我们编写 HTML 时不需要处理它们。
- en: 'If you''ve messed around with the DOM API a bit, you''ve probably recognized
    that there are two methods for creating new elements. In the document object,
    for example, there''s a `createElement` function, but there''s also `createElementNS`,
    which accepts an additional namespace URI parameter. Also, every element created
    has a `namespaceURI` property that tells you the namespace of the specific element.
    That is important, since HTML5 is a standard that consists of at least three namespaces:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你稍微玩过 DOM API，你可能已经注意到有两种方法可以创建新元素。例如，在文档对象中，有一个 `createElement` 函数，但还有一个
    `createElementNS`，它接受一个额外的命名空间 URI 参数。此外，每个创建的元素都有一个 `namespaceURI` 属性，它告诉你特定元素的命名空间。这很重要，因为
    HTML5 是一个至少包含三个命名空间的标准：
- en: '**HTML**: This is the standard HTML namespace, with the [http://www.w3.org/1999/xhtml](http://www.w3.org/1999/xhtml)
    URI.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML**：这是标准的 HTML 命名空间，具有 [http://www.w3.org/1999/xhtml](http://www.w3.org/1999/xhtml)
    URI。'
- en: '**SVG**: This embraces all SVG elements and attributes and uses the [http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)
    URI. You can sometimes see this namespace URI in an `xmlns` attribute of the `svg`
    elements. In fact, this is not really required, as the browser is smart enough
    to decide on the correct namespace itself.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SVG**：它包含所有 SVG 元素和属性，并使用 [http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)
    URI。有时你可以在 `svg` 元素的 `xmlns` 属性中看到这个命名空间 URI。实际上，这并不是必需的，因为浏览器足够智能，可以自己决定正确的命名空间。'
- en: '**MathML**: This is an XML-based format to describe mathematical formulas,
    and it is supported in most modern browsers. It uses the [http://www.w3.org/1998/Math/MathML](http://www.w3.org/1998/Math/MathML)
    namespace URI.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MathML**：这是一个基于 XML 的格式，用于描述数学公式，并且大多数现代浏览器都支持它。它使用 [http://www.w3.org/1998/Math/MathML](http://www.w3.org/1998/Math/MathML)
    命名空间 URI。'
- en: We can mix all of these elements from different standards and namespaces within
    a single document, and our browser will figure out the correct namespace itself,
    when it creates elements within the DOM.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在单个文档中混合来自不同标准和命名空间的所有这些元素，并且当浏览器在 DOM 中创建元素时，它会自己确定正确的命名空间。
- en: If you want more information on namespaces, I recommend that you go through
    the *Namespaces* *Crash Course* article on the Mozilla Developer Network at [https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course](https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更多关于命名空间的信息，我建议你阅读 Mozilla 开发者网络上的 *命名空间快速入门* 文章，网址为 [https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course](https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course)。
- en: As Angular will compile templates for us and render elements into the DOM using
    the DOM API, it needs to be aware of the namespaces when doing so. Similar to
    the browser, Angular provides some intelligence for deciding the correct namespace
    when creating elements. However, there will be some situations where you will
    need to help Angular recognize the correct namespace.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Angular 会为我们编译模板，并使用 DOM API 将元素渲染到 DOM 中，因此它需要在这个过程中了解命名空间。类似于浏览器，Angular
    在创建元素时提供了一些智能来决定正确的命名空间。然而，在某些情况下，你可能需要帮助 Angular 识别正确的命名空间。
- en: 'To illustrate some of this behavior, let''s transform the circle example that
    we''ve been working on into an Angular component:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一些这种行为，让我们将我们一直在工作的圆形示例转换成一个 Angular 组件：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've wrapped our circle SVG graphics into a simple Angular component. The `size`
    input parameter determines the actual width and height of the circle by controlling
    the SVG's `width` and `height` attributes and the circle's `cx`, `cy`, and `r`
    attributes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将圆形 SVG 图形封装成了一个简单的 Angular 组件。`size` 输入参数通过控制 SVG 的 `width` 和 `height`
    属性以及圆形的 `cx`、`cy` 和 `r` 属性来确定圆形的实际宽度和高度。
- en: 'To use our circle component, simply use the following template within another
    component:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的圆形组件，只需在另一个组件中使用以下模板：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's important to note that we need to use attribute bindings on SVG elements,
    and we can't set DOM element properties directly. This is due to the nature of
    SVG elements that have special property types (for example, `SVGAnimatedLength`)
    that can be animated with **Synchronized Multimedia Integration** **Language**
    (**SMIL**). Instead of interfering with these rather complex element properties,
    we can simply use attribute bindings to set the attribute values of the DOM element.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们需要在SVG元素上使用属性绑定，而不能直接设置DOM元素的属性。这是由于SVG元素具有特殊的属性类型（例如，`SVGAnimatedLength`），可以使用**同步多媒体集成****语言**（**SMIL**）进行动画。我们不需要干扰这些相对复杂的元素属性，而可以简单地使用属性绑定来设置DOM元素的属性值。
- en: Let's go back to our namespace discussion. Angular will know that it needs to
    use the SVG namespace to create the elements within this template. It will function
    in this way simply because we're using the `svg` element as a root element within
    our component, and it can switch the namespace within the template parser for
    any child elements automatically.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的命名空间讨论。Angular将知道它需要使用SVG命名空间来创建这个模板内的元素。它将以这种方式工作，仅仅因为我们正在使用`svg`元素作为组件内的根元素，并且它可以在模板解析器中自动切换任何子元素的命名空间。
- en: 'However, there are certain situations where we need to help Angular determine
    the correct namespace for the elements we''d like to create. This strikes us if
    we''re creating nested SVG components that don''t contain a root `svg` element:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们需要帮助Angular确定我们想要创建的元素的正确命名空间。当我们创建不包含根`svg`元素的嵌套SVG组件时，我们会遇到这种情况：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we're nesting SVG components, and our awesome circle component
    does not have an `svg` root element to tell Angular to switch the namespace. That
    is why we've created the `svg` element within our app component, and then included
    the awesome circle component in an SVG group.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们嵌套SVG组件，我们出色的圆形组件没有`svg`根元素来告诉Angular切换命名空间。这就是为什么我们在我们的应用程序组件中创建了`svg`元素，然后在一个SVG组中包含了出色的圆形组件。
- en: We need to explicitly tell Angular to switch to the SVG namespace within our
    circle component, and we can do this by including the namespace name as a prefix
    separated by a colon, as you can see in the highlighted section of the preceding
    code excerpt.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要明确告诉Angular在我们的圆形组件中切换到SVG命名空间，我们可以通过在前面代码摘录的高亮部分中看到的方式，将命名空间名称作为冒号分隔的前缀来做到这一点。
- en: If you have multiple elements that need to be created explicitly within the
    SVG namespace, you can rely on the fact that Angular does apply the namespace
    for child elements, too, and groups all of your elements with an SVG group element.
    So, you only need to prefix the group element with `<svg:g> ... </svg:g>`, but
    none of the contained SVG elements.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在SVG命名空间中显式创建多个元素，你可以依赖Angular也会为子元素应用命名空间的事实，并将所有元素与一个SVG组元素组合在一起。因此，你只需要在组元素前加上`<svg:g>
    ... </svg:g>`前缀，而不是包含的任何SVG元素。
- en: That is enough to know about Angular internals when dealing with SVG. Let's
    move on and create some real components!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理SVG时，这就是了解Angular内部结构的足够信息。让我们继续前进，创建一些真正的组件！
- en: Building an interactive activity slider component
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个交互式活动滑块组件
- en: In the previous topics, we covered the basics of working with SVG and dealing
    with SVG in Angular components. Now, it's time to apply our knowledge to the task
    management application and create some awesome components using SVG.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的主题中，我们介绍了与SVG一起工作的基础知识以及处理Angular组件中的SVG。现在，是时候将我们的知识应用到任务管理应用程序中，并使用SVG创建一些出色的组件了。
- en: 'The first component we''ll be creating in this context is an interactive slider
    that allows the user to select the time range of activities that he or she is
    interested in checking out. Displaying a simple HTML5 range input could be a solution,
    but since we''ve gained some SVG superpower, we can do better! We''ll use SVG
    to render our own slider that will show existing activities as ticks on the slider.
    Let''s look at a mock-up of the slider component that we''re going to create:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，我们将创建的第一个组件是一个交互式滑块，允许用户选择他或她感兴趣检查的活动时间范围。显示一个简单的HTML5范围输入可能是一个解决方案，但既然我们已经获得了一些SVG超级能力，我们可以做得更好！我们将使用SVG来渲染我们自己的滑块，它将在滑块上显示现有活动作为刻度。让我们看看我们将要创建的滑块组件的模拟图：
- en: '![](img/82660348-4ed9-4955-9650-845f2152666f.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82660348-4ed9-4955-9650-845f2152666f.png)'
- en: A mock-up of the activity slider component
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 活动滑块组件的模拟图
- en: Our slider component will actually serve two purposes. It should be a user control,
    and should provide a way to select a time range for filtering activities. However,
    it should also provide an overview of all of the activities, so that a user can
    filter the range more intuitively. By drawing vertical bars that represent activities,
    we can already give the user a feeling of the range he or she is interested in.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的滑块组件实际上将有两个用途。它应该是一个用户控件，并提供一种选择时间范围以过滤活动的方法。然而，它还应该提供所有活动的概述，以便用户可以更直观地过滤范围。通过绘制代表活动的垂直条，我们已经在用户心中建立了他或她感兴趣的范围感。
- en: 'Let''s create our new activity slider component using the Angular CLI tool:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Angular CLI工具创建我们的新活动滑块组件：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Open the generated component class on the path `src/app/activities/activity-slider/activity-slider.component.ts`,
    and add the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 打开路径`src/app/activities/activity-slider/activity-slider.component.ts`上生成的组件类，并添加以下代码：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first thing we should mention, which differs from all of the other components
    we've written about so far, is that we're using `ViewEncapsulation.Native` for
    this component. As we learned from the *Creating our application component* section
    in [Chapter 2](11f96942-6e99-46c5-b152-1af3b2579d44.xhtml), *Ready, Set, Go!*,
    when we use `ViewEncapsulation.Native` for our component encapsulation, Angular
    actually uses Shadow DOM to create the component. We briefly looked at this in
    the *Shadow DOM* section in [Chapter 1](72fc993e-43db-48eb-8797-c65ea9226b87.xhtml),
    *Component-Based User Interfaces,* as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该首先提到的，与迄今为止我们所写的所有其他组件不同，我们为这个组件使用了`ViewEncapsulation.Native`。正如我们在[第2章](11f96942-6e99-46c5-b152-1af3b2579d44.xhtml)的“创建我们的应用程序组件”部分所学的，在*准备，设置，出发！*当我们为组件封装使用`ViewEncapsulation.Native`时，Angular实际上使用阴影DOM来创建组件。我们也在[第1章](72fc993e-43db-48eb-8797-c65ea9226b87.xhtml)的“基于组件的用户界面”部分的“阴影DOM”中简要介绍了这一点。
- en: 'Using Shadow DOM for our component will give us this advantage: Our component
    will be fully encapsulated, from the CSS side of things. This not only means that
    none of the global CSS will leak into our component; it also means that we''ll
    need to create local styles, in order to style our component.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用阴影DOM（Shadow DOM）为我们组件带来的优势是：我们的组件将完全封装，从CSS方面来说。这不仅意味着全局CSS不会泄漏到我们的组件中；这也意味着我们需要创建局部样式，以便为我们的组件进行样式设计。
- en: So far, we've used styles coming from a global style sheet, which has been prepared
    for the book. We're using a component CSS naming convention within that file,
    in order to avoid name clashes with CSS classes. However, when using Shadow DOM,
    we can forego prefixes and other naming conventions to avoid name clashes, since
    we're only applying styles locally, within the component.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了来自全局样式表的样式，该样式表是为本书准备的。我们在该文件中使用了组件CSS命名约定，以避免与CSS类名冲突。然而，当使用阴影DOM时，我们可以省略前缀和其他命名约定来避免冲突，因为我们只在我们组件的局部应用样式。
- en: Chrome supports Shadow DOM natively, from Version 35\. Within Firefox, Shadow
    DOM can be enabled by visiting the `about:config` page and turning on the `dom.webcomponents.enabled`
    flag. IE, Edge, and Safari don't support this standard at all; however, we can
    set things up in a way that they can deal with Shadow DOM, by including a polyfill
    named `webcomponents.js`. You can find more information on this polyfill at [https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome从版本35开始原生支持阴影DOM。在Firefox中，可以通过访问`about:config`页面并打开`dom.webcomponents.enabled`标志来启用阴影DOM。IE、Edge和Safari完全不支持这个标准；然而，我们可以通过包含一个名为`webcomponents.js`的polyfill来设置它们以处理阴影DOM。你可以在[https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs)上找到有关此polyfill的更多信息。
- en: 'Now, let''s add the local CSS styles that we''re going to use within our activity
    slider component. Open the file `src/app/activities/activity-slider/activity-slider.component.css`,
    and add the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加我们将在活动滑块组件中使用的局部CSS样式。打开文件`src/app/activities/activity-slider/activity-slider.component.css`，并添加以下代码：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Usually, such short class names would probably lead to name clashes within our
    project, but since the styles will be local to the Shadow DOM of our component,
    we don't need to worry about name clashes anymore.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这样的短类名可能会在我们的项目中导致名称冲突，但由于样式将局限于我们组件的阴影DOM中，我们不再需要担心名称冲突。
- en: You can see that we're using a special pseudo-selector, `:host`, within our
    styles. This selector is part of the Shadow DOM specification for CSS, and it
    allows us to style the host element of a shadow root. This becomes very handy,
    since we can treat the host element as a part of our component internals when
    styling.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们在我们的样式中使用了特殊的伪选择器`:host`。这个选择器是CSS的Shadow DOM规范的一部分，它允许我们样式化shadow root的主机元素。这变得非常方便，因为我们可以在样式化时将主机元素视为组件内部的一部分。
- en: Let's go back to the rest of the code inside of our activity slider component.
    As an input parameter, we define the list of activities that will be used, not
    only to determine the available range in the slider, but also to render activities
    on the background of the slider.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到活动滑块组件内部的其余代码。作为一个输入参数，我们定义了将用于的活动的列表，这不仅用于确定滑块中的可用范围，还用于在滑块的背景上渲染活动。
- en: Once a selection is made by the user, our component will use the `outSelectionChange`
    output to notify the outside world about the change.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户做出选择，我们的组件将使用`outSelectionChange`输出通知外界关于变化。
- en: Within the constructor, we're injecting the host element for later use. We will
    need that to access the native DOM elements of our slider, in order to do some
    width calculations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们正在注入主机元素以供以后使用。我们需要它来访问滑块的本地DOM元素，以便进行一些宽度计算。
- en: Projection of time
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间投影
- en: 'Our slider component needs to be able to project timestamps into the coordinate
    system of SVG. Also, when a user clicks on the timeline to select a range, we''ll
    need to be able to project coordinates back into timestamps. For this purpose,
    we need to create two projection functions within our component, which will use
    a few helper functions and states to calculate the values, from coordinates to
    time, and vice-versa:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的滑块组件需要能够将时间戳投影到SVG的坐标系中。此外，当用户点击时间轴选择范围时，我们需要能够将坐标投影回时间戳。为此，我们需要在我们的组件内创建两个投影函数，这些函数将使用一些辅助函数和状态来计算值，从坐标到时间，反之亦然：
- en: '![](img/67be855a-4b2d-4263-a26b-549231cf0f4d.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67be855a-4b2d-4263-a26b-549231cf0f4d.png)'
- en: Visualization of important variables and functions for our calculations
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 计算中重要变量和函数的可视化
- en: While we will use percentages to position our SVG elements on the slider component,
    the padding on the sides will need to be specified in pixels. The `totalWidth`
    function will return the total width of the area in pixels; this is where we'll
    draw the activity indicators. The `timeFirst`, `timeLast`, and `timeSpan` variables
    will also be used by the calculations, and are specified in milliseconds.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将使用百分比来定位滑块组件上的SVG元素，但两侧的内边距需要以像素为单位指定。`totalWidth`函数将返回该区域的像素总宽度；这是我们将在其中绘制活动指示器的地方。`timeFirst`、`timeLast`和`timeSpan`变量也将被计算使用，并以毫秒为单位指定。
- en: 'Let''s add some code to our slider to deal with the projection of our activities
    on the slider:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在滑块中添加一些代码来处理我们的活动在滑块上的投影：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since we have put aside the reference to the host element, we can use its `clientWidth`
    property to get the full width of the component and subtract the padding. This
    will give us the full width of the area where we'd like to draw activity indicators,
    in pixels.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经忽略了主机元素的引用，我们可以使用其`clientWidth`属性来获取组件的全宽并减去内边距。这将给我们想要的绘制活动指示器的区域的全宽，以像素为单位。
- en: In the `projectTime` function, we will first transform the timestamp into a
    position by a simple rule of three. Because we have access to the timestamp of
    the first activity, as well as the total time span, this will be a quite simple
    task. Once we do this, we can convert our position value, which is of unit pixels,
    into a percentage, by dividing it by the total component width and then multiplying
    it by 100.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`projectTime`函数中，我们首先将时间戳通过简单的三段式规则转换为位置。因为我们可以访问第一个活动的时间戳以及总时间跨度，这将是一个相当简单的任务。一旦我们这样做，我们可以通过将其除以总组件宽度然后乘以100来将我们的位置值（以像素为单位）转换为百分比。
- en: To project a pixel value back to a timestamp, we can more or less perform the
    reverse of `projectTime`, except that we're not dealing with percentages here,
    but assuming that the length parameter of the `projectLength` function is in a
    pixel unit.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要将像素值投影回时间戳，我们可以基本上执行`projectTime`的逆操作，只不过我们这里不处理百分比，而是假设`projectLength`函数的长度参数是以像素单位。
- en: 'We''ve used some member variables (`timeFirst`, `timeLast`, and `timeSpan`)
    within our projection code, but how do we set these member variables? Since we
    have an `activities` component input, which is expected to be a list of relevant
    activities, we can observe the input for changes and set the values based on the
    input. To observe that component input for changes, we can use the `OnChanges`
    life cycle hook:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的预测代码中使用了某些成员变量（`timeFirst`、`timeLast`和`timeSpan`），但如何设置这些成员变量呢？由于我们有一个`activities`组件输入，预期它将是一个相关活动的列表，我们可以观察输入的变化并根据输入设置值。为了观察该组件输入的变化，我们可以使用`OnChanges`生命周期钩子：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we need to check whether the changes include changes to the `activities`
    input and that the current value of the input is valid. After checking for the
    input value, we can determine our member variables, namely `timeFirst`, `timeLast`,
    and `timeSpan`. We limit the `timeSpan` variable to at least `1`, as our projection
    calculations would be messed up otherwise.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查更改是否包括对`activities`输入的更改，以及当前输入值是否有效。在检查输入值之后，我们可以确定我们的成员变量，即`timeFirst`、`timeLast`和`timeSpan`。我们将`timeSpan`变量限制至少为`1`，否则我们的预测计算将会出错。
- en: The preceding code will ensure that we will always recalculate our member variables
    when the `activities` input changes, and that we'll be using the most recent data-rendering
    activities.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将确保当`activities`输入更改时，我们将始终重新计算我们的成员变量，并且我们将使用最新的数据渲染活动。
- en: Rendering activity indicators
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染活动指示器
- en: We've already implemented the basics of the component and laid the groundwork
    for drawing time information into the coordinate system of our component. It's
    time to use our projection functions and draw our activities as indicators on
    the slider using SVG.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了组件的基本功能，并为将时间信息绘制到组件的坐标系中奠定了基础。现在是时候使用我们的投影函数，并使用SVG在滑块上绘制活动指示器了。
- en: 'Let''s open the template of our activity slider in `src/app/activities/activity-slider/activity-slider.component.html`,
    and add the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`src/app/activities/activity-slider/activity-slider.component.html`中打开活动滑块的模板，并添加以下代码：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since we need to create an indicator for every activity within our activities
    list, we can simply use the `ngFor` directive to repeat the rectangle that represents
    our activity indicator.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要为活动列表中的每个活动创建一个指示器，我们可以简单地使用`ngFor`指令重复表示活动指示器的矩形。
- en: As we know from building our activity service class in a previous topic, *Creating
    a service for logging activities*, activities always contain a `time` field with
    the timestamp of the activity. Within our component, we have already created a
    projection function that converts time into a percentage, relative to our component
    width. We can simply use the `projectTime` function within our attribute binding
    for the `x` attribute of the `rect` element, to position our activity indicators
    at the correct positions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一个主题中构建活动服务类时所知，*创建用于记录活动的服务*，活动总是包含一个带有活动时间戳的`time`字段。在我们的组件中，我们已创建了一个将时间转换为相对于组件宽度的百分比的投影函数。我们可以在`rect`元素的`x`属性绑定中简单地使用`projectTime`函数，以将活动指示器定位在正确的位置。
- en: By only using an SVG template and our backing function to project time, we have
    created a nice little chart that displays activity indicators on a timeline.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅使用SVG模板和我们的背景函数来预测时间，我们已经创建了一个小巧的图表，该图表显示活动指示器在时间轴上的位置。
- en: You can imagine that if we have a lot of activities, our slider will actually
    look pretty stuffed, and it will be hard to get a feeling for when those activities
    may have occurred. We need to have some sort of a grid that will help us associate
    the chart with a timeline.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，如果我们有很多活动，我们的滑块实际上看起来会很拥挤，很难感觉到这些活动可能发生的时间。我们需要有一种类型的网格，帮助我们把图表与时间轴关联起来。
- en: As already shown in the mock-up of our slider component, now, we're going to
    introduce some ticks on the slider background that will divide the slider into
    sections. We'll also label each tick with a calendar time. This will give our
    users a rough sense of time, when looking at the activity indicators on the slider.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们的滑块组件的模拟所示，现在，我们将在滑块背景上引入一些刻度，将滑块分成几个部分。我们还将为每个刻度标注日历时间。这将使用户在查看滑块上的活动指示器时对时间有一个大致的感觉。
- en: 'Let''s look at the code changes within our activity slider class that will
    enable the rendering of our ticks:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们活动滑块类中的代码更改，这将启用我们的刻度渲染：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First of all, we need to create a function that computes some ticks for us,
    which we can place onto the timeline. For this purpose, we need to create the
    `computeTicks` method, which will divide the whole timeline into five equal segments
    and generate timestamps that represent the positions in time for individual ticks.
    We will store these ticks in a new `ticks` member variable. With the help of these
    timestamps, we can easily render the ticks within our view.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个函数来计算一些刻度，我们可以将它们放置在时间轴上。为此，我们需要创建`computeTicks`方法，它将整个时间轴分成五个相等的部分，并生成表示各个刻度时间位置的戳记。我们将这些刻度存储在一个新的`ticks`成员变量中。有了这些时间戳的帮助，我们可以在视图中轻松渲染刻度。
- en: We use the `Array.from` ES6 function to create a new array with the desired
    length, and use the functional array extra function `map` to generate tick model
    objects from this array. Using `Array.from` is a nice trick to create an initial
    array of a given length, which can be used to establish a functional style.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Array.from` ES6函数来创建一个具有所需长度的新数组，并使用功能数组额外函数`map`从该数组生成刻度模型对象。使用`Array.from`是一个很好的技巧，可以创建一个给定长度的初始数组，这可以用来建立一种功能风格。
- en: 'Let''s look at the template of our activity slider component, and how we can
    use our array of timestamps to render ticks on our slider component:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的活动滑块组件的模板，以及我们如何使用我们的时间戳数组在滑块组件上渲染刻度：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To render our ticks, we've used an SVG group element to place our `ngFor` directive
    that repeats the tick timestamps we've stored in the `ticks` member variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染我们的刻度，我们使用了一个SVG组元素来放置我们的`ngFor`指令，该指令重复我们在`ticks`成员变量中存储的刻度戳记。
- en: For each tick, we need to place a label, as well as a line, that spans over
    the slider background. We can use the SVG text element to render our label with
    the timestamp on top of the slider. Within the attribute binding for the `x` attribute
    of our `text` element, we've used our `projectTime` projection function to receive
    the projected percentage value from our timestamp. The `y` coordinate of our `text`
    element is fixed at a position where the labels will just sit on top of our slider.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个刻度，我们需要放置一个标签，以及跨越滑块背景的线。我们可以使用SVG文本元素来渲染带有时间戳的标签，并将其放置在滑块上方。在我们的`text`元素的`x`属性绑定中，我们使用了我们的`projectTime`投影函数来接收从时间戳中得到的投影百分比值。我们的`text`元素的`y`坐标固定在一个位置，标签将正好位于滑块上方。
- en: 'SVG lines consist of four coordinates: `x1`, `x2`, `y1`, and `y2`. Together,
    they define two coordinate points, where a line will be drawn from one point to
    the other.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: SVG线由四个坐标组成：`x1`、`x2`、`y1`和`y2`。共同定义了两个坐标点，一条线将从一点画到另一点。
- en: Now, we are getting closer to the final slider that we specified in the mock-up
    at the beginning of this topic. The last missing piece of the puzzle is to make
    our slider interactive, so a user can select a range of activities.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们越来越接近我们在本主题开头所指定的最终滑块。最后缺失的拼图碎片是使我们的滑块交互式，以便用户可以选择一系列活动。
- en: Bringing it to life
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使其生动起来
- en: So far, we've covered the rendering of the slider background, as well as the
    rendering of the activity indicators. We've also generated ticks and displayed
    them with a grid line and a label, to display the calendar time of each tick.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了滑块背景的渲染，以及活动指示器的渲染。我们还生成了刻度并使用网格线和标签显示它们，以显示每个刻度的日历时间。
- en: Well, that does not really make a slider, does it? Of course, we also need to
    handle user input, and make the slider interactive, so that users can select a
    time range that they want to display the activities for.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不真正是一个滑块，对吧？当然，我们还需要处理用户输入，并使滑块交互式，以便用户可以选择他们想要显示活动的时间范围。
- en: 'To do this, add the following changes to the component class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请向组件类添加以下更改：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we detect a change in the `activities` input property within the `OnChanges`
    life cycle hook, we initialize a `ActivitySliderSelection` object for the user
    selection in our slider component. It consists of a `start` and `end` property,
    both containing timestamps that represent the selected range on our activity slider.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`OnChanges`生命周期钩子中检测到`activities`输入属性的变化时，我们为我们的滑块组件中的用户选择初始化一个`ActivitySliderSelection`对象。它包含一个`start`和`end`属性，两者都包含表示我们在活动滑块上所选范围的戳记。
- en: Once we've set our initial selection, we need to use the `outSelectionChange`
    output property to emit an event. That way, we can let our parent component know
    that the selection within the slider has changed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了初始选区，我们需要使用`outSelectionChange`输出属性来发出事件。这样，我们可以让父组件知道滑动条内的选区已更改。
- en: 'To display the selected range, we use an overlay rectangle within our template,
    which will be placed above the slider background. If you look at the mock-up image
    of the slider again, you''ll notice that this overlay is painted in grey:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示选定的范围，我们在模板中使用一个覆盖矩形，它将放置在滑动背景之上。如果你再次查看滑动条的模拟图像，你会注意到这个覆盖层被涂成灰色：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This rectangle will be placed just above our slider background, and will use
    our projection function to calculate the `x` and `width` attributes. As we need
    to wait for change detection to initialize our selection within the `OnChanges`
    life cycle hook, we'll just check for a valid selection object by making use of
    the `ngIf` directive.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩形将放置在我们的滑动背景之上，并使用我们的投影函数来计算`x`和`width`属性。由于我们需要等待变化检测在`OnChanges`生命周期钩子中初始化我们的选区，我们将通过使用`ngIf`指令来检查有效的选区对象。
- en: 'Now, we need to start tackling user input in our activity slider component.
    The mechanics for storing the state and rendering our selection are already in
    place, so we can implement the required host listeners to handle user input. Since
    we''ve applied quite a few changes progressively, let''s look at the final, full
    version of the component class. The missing changes to add user interactions are
    marked in bold:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要开始处理我们的活动滑动组件的用户输入。存储状态和渲染选区的机制已经就位，因此我们可以实现所需的主监听器来处理用户输入。由于我们已经逐步应用了许多更改，让我们看看组件类的最终完整版本。需要添加用户交互的缺失更改以粗体显示：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code excerpt, we handled a total of four events on the slider
    host element:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在滑动组件的主元素上处理了总共四个事件：
- en: '`onMouseDown`: We set our selection model''s `start` and `end` properties with
    the same value. Since we''re using timestamps for these properties, we projected
    the mouse position into the timespace first. The mouse position comes in pixels,
    relative to the slider component''s origin. Since we know the slider''s width
    and the total time duration displayed, we can easily convert this into timestamps.
    We''re using the `projectLength` method for this purpose. By passing a second
    argument to the `@HostListener` decorator, we specified that we''d like to pass
    the DOM event to our `onMouseDown` method. We also set a state flag, `modifySelection`,
    in our component, to indicate that a selection is in progress.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMouseDown`: 我们将选择模型`start`和`end`属性设置为相同的值。由于我们使用时间戳来设置这些属性，我们首先将鼠标位置投影到时间空间中。鼠标位置以像素为单位，相对于滑动组件的起点。由于我们知道滑动条的宽度和显示的总时间长度，我们可以轻松地将它转换为时间戳。我们使用`projectLength`方法来完成这个目的。通过传递第二个参数到`@HostListener`装饰器，我们指定了我们将把DOM事件传递给我们的`onMouseDown`方法。我们还在我们的组件中设置了一个状态标志`modifySelection`，以指示正在进行的选区。'
- en: '`onMouseMove`: If the component is in selection mode (the `modifySelection`
    flag is `true`), you can adjust the end property of the `selection` object. Here,
    we also made sure that we ruled out the possibility of creating a negative selection,
    by using `Math.max` and limiting the end of the selection to not be smaller than
    the start.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMouseMove`: 如果组件处于选区模式（`modifySelection`标志为`true`），你可以调整`selection`对象的结束属性。在这里，我们还确保通过使用`Math.max`和限制选区的结束不小于开始，排除了创建负选区的可能性。'
- en: '`onMouseUp`: When the user releases the mouse button, the component exits the
    selection mode. This can be done by setting the `modifySelection` flag to `false`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMouseUp`: 当用户释放鼠标按钮时，组件退出选区模式。这可以通过将`modifySelection`标志设置为`false`来完成。'
- en: '`onMouseLeave`: This is the same as the `onMouseUp` event; the difference is
    that here, the component will just exit the selection mode.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMouseLeave`: 这与`onMouseUp`事件相同；区别在于这里，组件将仅退出选区模式。'
- en: Using the `@HostListener` decorator, we were able to handle all of the necessary
    user input to complete our component with the interactive elements that were still
    missing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@HostListener`装饰器，我们能够处理所有必要的用户输入，以完成我们组件中仍缺少的交互元素。
- en: Recap
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this topic, we learned how to use SVG in order to create graphical and interactive
    components with Angular. By creating attribute bindings on our SVG elements and
    controlling the instantiation of graphical elements using the `ngFor` and `ngIf`
    directives, we built a custom slider component that provides a nice overview of
    our activities. At the same time, we also learned how to handle user input using
    the `@HostListener` decorator, in order to make our component interactive:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们学习了如何使用 SVG 来创建具有 Angular 的图形和交互式组件。通过在我们的 SVG 元素上创建属性绑定，并使用 `ngFor`
    和 `ngIf` 指令控制图形元素的实例化，我们构建了一个自定义滑动组件，为我们提供了活动的好概述。同时，我们还学习了如何使用 `@HostListener`
    装饰器来处理用户输入，以便使我们的组件具有交互性：
- en: '![](img/6441d4ab-9f66-4b56-b90f-af09ac9bc02d.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6441d4ab-9f66-4b56-b90f-af09ac9bc02d.png)'
- en: A screenshot of the finished activity slider component
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后的活动滑动组件的截图
- en: 'To sum things up, we learned about the following concepts:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们学习了以下概念：
- en: Encapsulating component views using `ViewEncapsulation.Native` and importing
    local styles
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ViewEncapsulation.Native` 封装组件视图并导入本地样式
- en: Covering some basic projections of timestamps onto screen coordinates, to be
    used with SVG elements
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖一些基本的时间戳到屏幕坐标的投影，用于与 SVG 元素一起使用
- en: Handling user input and creating a custom selection mechanism using the `@HostListener`
    decorator
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户输入并使用 `@HostListener` 装饰器创建自定义选择机制
- en: Building the activity timeline
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建活动时间线
- en: So far, we've built a service to log activities and a slider component to select
    a time range and provide an overview using activity indicators. Since we needed
    to perform a lot of drawing tasks within the slider component, SVG was a perfect
    fit for this use case. To complete our activities component tree, we still need
    to render the activities that were selected using the activity slider component.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一个用于记录活动的服务和一个滑动组件来选择时间范围，并使用活动指示器提供概述。由于我们需要在滑动组件内执行许多绘图任务，SVG
    对于这个用例来说是一个完美的选择。为了完成我们的活动组件树，我们仍然需要渲染使用活动滑动组件选择的活动。
- en: 'Let''s continue to work on our activities component tree. We will create a
    new component that is responsible for rendering an individual activity within
    an activity timeline. Let''s use the Angular CLI to create our activity component:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续完善我们的活动组件树。我们将创建一个新的组件，该组件负责在活动时间线中渲染单个活动。让我们使用 Angular CLI 来创建我们的活动组件：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s start with the component template. Open the file `src/app/activities/activity/activity.component.html`,
    and add the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从组件模板开始。打开文件 `src/app/activities/activity/activity.component.html`，并添加以下代码：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Each activity will consist of a user image, as well as an information box that
    will contain the activity title, message, and authoring details.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个活动将包括一个用户图像，以及一个包含活动标题、消息和作者详情的信息框。
- en: Our activity will use an input to determine its alignment. This allows us to
    align the activity from outside of the component. The `isAlignedRight` method
    helps us set an additional CSS class, `info-align-right`, on the activity information
    box.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的活动将使用一个输入来确定其对齐方式。这允许我们从组件外部对齐活动。`isAlignedRight` 方法帮助我们设置一个额外的 CSS 类，`info-align-right`，在活动信息框上。
- en: 'Let''s create our component class within the file `src/app/activities/activity/activity.component.ts`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在文件 `src/app/activities/activity/activity.component.ts` 中创建我们的组件类：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our activity component expects four inputs:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的活动组件期望有四个输入：
- en: '`activity`: This property takes the data model of the activity that needs to
    be rendered with the component. This is the activity that we created using the
    activity service.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activity`：这个属性接受需要用组件渲染的活动数据模型。这是我们使用活动服务创建的活动。'
- en: '`alignment`: This input property should be set to a string containing the word
    `left` or `right`. We used this to determine whether we needed to add an additional
    CSS class to our template, in order to align the activity information box to the
    right.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alignment`：这个输入属性应该设置为包含单词`left`或`right`的字符串。我们使用这个属性来确定是否需要在模板中添加一个额外的 CSS
    类，以便将活动信息框对齐到右侧。'
- en: '`startMark`: This input property acts as an input and a host binding at the
    same time. If this input is set to `true`, the activity will get an additional
    CSS class, `start-mark`, which will cause a small mark on top of the timeline,
    to indicate the timeline termination.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startMark`：这个输入属性同时充当输入和宿主绑定。如果这个输入设置为`true`，活动将获得一个额外的 CSS 类，`start-mark`，这将在时间线上方产生一个小标记，以指示时间线的终止。'
- en: '`endMark`: In the same way as `startMark`, this input uses a host binding to
    set an additional CSS class, `end-mark`, which will cause a small mark on the
    bottom of the timeline, to indicate the timeline termination.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endMark`：与 `startMark` 相同，这个输入使用主机绑定来设置一个额外的 CSS 类，`end-mark`，这将导致时间线底部出现一个小标记，以指示时间线的终止。'
- en: The `isAlignedRight` method is used within the template, to determine whether
    we need to add an additional CSS class to the information box, in order to align
    it to the right.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中使用了 `isAlignedRight` 方法，用于确定我们是否需要为信息框添加一个额外的 CSS 类，以便将其对齐到右侧。
- en: We formatted the timestamp of the activity using the `FromNow` pipe, which we
    created in [Chapter 4](1682edec-f2b3-4b02-afd8-ed7ef586b712.xhtml), *Thinking
    in Projects*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在 [第 4 章](1682edec-f2b3-4b02-afd8-ed7ef586b712.xhtml) “在项目中思考” 中创建的 `FromNow`
    管道格式化了活动的日期时间戳。
- en: 'We now have almost all of the components to display our activities. Still,
    there''s something missing, which is the glue to combine the activity slider with
    our activity components. For this, we''ll create a new component, called `activities`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎有了显示活动所需的所有组件。然而，还缺少一些东西，那就是将活动滑块与我们的活动组件结合在一起的东西。为此，我们将创建一个新的组件，称为 `activities`：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After the Angular CLI has generated the component files, let''s open the component
    class in `src/app/activities/activities/activities.component.ts`, and add the
    following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular CLI 生成组件文件后，让我们打开位于 `src/app/activities/activities/activities.component.ts`
    的组件类，并添加以下代码：
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since this component will just act as a compositional component for arranging
    the slider and rendering all activities, we don't have a lot of logic in it. This
    is a pure component, and it relies on a parent container component to determine
    which of the activities should be displayed/selected. We're also re-emitting the
    `outSelectionChange` event originated at the activity slider.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个组件将仅作为组合组件，用于排列滑块并渲染所有活动，所以我们里面没有太多逻辑。这是一个纯组件，它依赖于父容器组件来确定哪些活动应该显示/选择。我们还重新发出在活动滑块中产生的
    `outSelectionChange` 事件。
- en: 'Let''s also take a look at the template located in `src/app/activities/activities/activities.component.ts`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看位于 `src/app/activities/activities/activities.component.ts` 的模板：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, that's just simple composition. We're rendering our activity slider,
    and we use the `ngFor` directive to render our activity timeline. With the help
    of the local view variables `odd`, `first`, and `last`, we can set all of the
    necessary formatting inputs required on our activity component.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这只是一个简单的组合。我们正在渲染活动滑块，并使用 `ngFor` 指令来渲染我们的活动时间线。借助局部视图变量 `odd`、`first`
    和 `last`，我们可以设置活动组件上所需的所有必要格式化输入。
- en: Alright! We are almost there. We have all of our activity UI components ready.
    However, we still need to create a container component for our activities and
    add the necessary route configuration, so that the user can navigate to the project
    activities tab.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！我们几乎完成了。我们已经准备好了所有的活动 UI 组件。然而，我们仍然需要为我们的活动创建一个容器组件，并添加必要的路由配置，以便用户可以导航到项目活动标签页。
- en: 'Let''s use the Angular CLI tool again, to create the files for our activities
    container component:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用 Angular CLI 工具，为我们的活动容器组件创建文件：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Open the component class file located in `src/app/container/project-activities-container/project-activities-container.component.ts`,
    and apply the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 `src/app/container/project-activities-container/project-activities-container.component.ts`
    的组件类文件，并应用以下代码：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Although this looks like a lot of code, it should actually look very familiar.
    Our other container components look almost the same as this. We're accessing the
    activities observable from our activities service and combining the observable
    with the parent route parameter to obtain the selected project ID.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来像很多代码，但实际上应该看起来非常熟悉。我们的其他容器组件几乎与这个相同。我们正在从活动服务访问活动可观察对象，并将可观察对象与父路由参数组合，以获取所选的项目
    ID。
- en: What's special about this container is that we're storing a behavior subject,
    `selection`, which is used to emit the latest selection that we receive from our
    activity slider component. Within the `selectedActivities` observable, we're then
    using this selection together with a mapping function, in order to filter for
    only the activities that are within the range of our selection.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器组件的特殊之处在于我们存储了一个行为主题，`selection`，它用于发出我们从活动滑块组件接收到的最新选择。在 `selectedActivities`
    可观察对象中，我们使用这个选择与映射函数一起，以过滤出我们选择范围内的活动。
- en: 'As is usual with container components, the template for this one is really
    simple. We''re just rendering our activities component and create bindings using
    the async pipe on our container observables. Open the file `src/app/container/project-activities-container/project-activities-container.component.html`,
    and apply the following changes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如容器组件通常所做的那样，这个组件的模板非常简单。我们只是渲染我们的活动组件，并在我们的容器可观察对象上使用异步管道创建绑定。打开文件 `src/app/container/project-activities-container/project-activities-container.component.html`，并应用以下更改：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Okay; that''s it for our container. Now, we only need to add our newly created
    activities container component into the route configuration. Let''s open our router
    configuration file, `src/app/routes.ts`, and apply the following changes:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 好的；我们的容器部分就到这里。现在，我们只需要将新创建的活动容器组件添加到路由配置中。让我们打开我们的路由配置文件 `src/app/routes.ts`，并应用以下更改：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That''s it for our activities page! We''ve created three components that are
    composed together and display an activity stream, which provides a slider to filter
    activities for dates. Preview your changes in the browser, and you should now
    be able to navigate to the ACTIVITIES tab on your projects. Also, try to cause
    some activities to be logged, by adding new tasks or updating them. Click and
    drag on the activity slider to change your selections:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“活动”页面就到这里！我们已经创建了三个组件，它们组合在一起并显示活动流，提供了一个滑块来筛选日期相关的活动。在浏览器中预览您的更改，现在您应该能够导航到项目中的“活动”标签页。此外，尝试通过添加新任务或更新它们来记录一些活动。点击并拖动活动滑块以更改您的选择：
- en: '![](img/bc042898-071e-4c7b-a9e1-d03dfe7ab031.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc042898-071e-4c7b-a9e1-d03dfe7ab031.png)'
- en: A screenshot of the finished activities view
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后的活动视图截图
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created an interactive slider component using SVG. While
    doing this, we learned about some SVG basics and the power of SVG within the DOM.
    Using Angular, we were able to make SVG composable, which it isn't by nature.
    We learned about namespaces, how Angular handles them, and how we can tell Angular
    that we'd like to use namespaces explicitly.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 SVG 创建了一个交互式滑块组件。在这个过程中，我们学习了 SVG 的基础知识以及 SVG 在 DOM 中的强大功能。利用 Angular，我们能够使
    SVG 具有可组合性，这是它本身所不具备的。我们学习了命名空间、Angular 如何处理它们，以及如何告诉 Angular 我们希望显式地使用命名空间。
- en: Besides using SVG for our slider component, we also learned how to use Shadow
    DOM to create native view encapsulation. As a result of this, we were able to
    use local styles for our component. We don't need to worry about CSS name clashes,
    specificity, and global CSS side effects when using local styles.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为我们的滑块组件使用 SVG 之外，我们还学习了如何使用 Shadow DOM 来创建原生视图封装。因此，我们能够为我们的组件使用本地样式。当我们使用本地样式时，我们不需要担心
    CSS 命名冲突、特异性和全局 CSS 的副作用。
- en: In the next chapter, we're going to enhance what we've built so far. We will
    create some components to enrich the user experience within our application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将增强到目前为止所构建的内容。我们将创建一些组件来丰富我们应用程序中的用户体验。
