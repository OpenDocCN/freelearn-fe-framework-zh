- en: NgRx – Reduxing that Angular App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgRx – Reduxing that Angular App
- en: We have reached the last chapter of this book. The time has come to understand
    the NgRx library. So far, different topics have been covered, making you as a
    reader more used to thinking about things such as immutable data structures and
    reactive programming. We did all this so it would be easier for you to digest
    what is to come in this chapter. NgRx is an implementation of Redux made for Angular,
    so concepts such as store, action creators, actions, selectors, and reducers are
    well used. What you have hopefully picked up on by reading the past chapters is
    how Redux works. By reading the previous chapter, you will have discovered how
    what you learned about Redux translates to NgRx and its principles on how to organize
    your code. This chapter aims to describe the core library `@ngrx-store`, how to
    handle side effects with `@ngrx-effects`, and how to debug like a pro with `@ngrx/store-devtools`,
    among other things.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了这本书的最后一章。现在是时候理解 NgRx 库了。到目前为止，已经涵盖了不同的主题，使您作为读者更习惯于思考诸如不可变数据结构和响应式编程等问题。我们这样做是为了使您更容易消化本章中将要介绍的内容。NgRx
    是为 Angular 制作的 Redux 实现，因此诸如存储、动作创建器、动作、选择器和还原器等概念被广泛使用。您通过阅读前面的章节可能已经了解到了 Redux
    的工作原理。通过阅读上一章，您将发现您所学的 Redux 知识如何转化为 NgRx 以及其代码组织原则。本章旨在描述核心库 `@ngrx-store`，如何使用
    `@ngrx-effects` 处理副作用，以及如何像专业人士一样使用 `@ngrx/store-devtools` 进行调试，以及其他内容。
- en: 'In this chapter, we will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: State management with `@ngrx/store`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@ngrx/store` 进行状态管理
- en: Handling side effects with `@ngrx/effects`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@ngrx/effects` 处理副作用
- en: How to debug with `@ngrx/store-devtools`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `@ngrx/store-devtools` 进行调试
- en: How to capture and transform the router state with `@ngrx/router-store`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `@ngrx/router-store` 捕获和转换路由状态
- en: NgRx overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgRx 概述
- en: 'NgRx consists of the following parts:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx 由以下部分组成：
- en: '`@ngrx/store`: This is the core that contains a way for us to maintain state
    and dispatch actions.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/store`：这是包含我们维护状态和分发动作方式的核心。'
- en: '`@ngrx/effects`: This will handle side effects such as, AJAX requests, for
    example.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/effects`：这将处理副作用，例如，例如 AJAX 请求。'
- en: '`@ngrx/router-store`: This ensures we can integrate NgRx with the Angular routing.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/router-store`：这确保我们可以将 NgRx 与 Angular 路由集成。'
- en: '`@ngrx/store-devtools`: This will install a tool that gives us the opportunity
    to debug NgRx by, for example, giving us a time travel debugging functionality.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/store-devtools`：这将安装一个工具，例如，通过提供时间旅行调试功能，给我们调试 NgRx 的机会。'
- en: '`@ngrx/entity`: This is a library that helps us manage record collections.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/entity`：这是一个帮助我们管理记录集合的库。'
- en: '`@ngrx/schematics`: This is a scaffolder library that helps you when using
    NgRx.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/schematics`：这是一个脚手架库，在您使用 NgRx 时提供帮助。'
- en: A word on state management
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于状态管理的一些话
- en: Some components must have state. When there is a need for another component
    to know about that very same state, the first component needs to find a way to
    communicate that to the other component. There are many ways to achieve this.
    One way is to ensure that all state that should be shared lives in a centralized
    store. Think of this store as a single source of truth, from which all components
    can read. Every state does not necessarily need to end up in the centralized store,
    as the state may only concern a specific component. Before NgRx and Redux, one
    way of solving this was to put everything in a globally accessible object or service.
    The store, as we mentioned, is just that. It is globally accessible in the sense
    that it can be injected into any component that might need it. A word of caution;
    even though it is tempting to put all of our state in our store, we really shouldn't.
    State that we notice needs to be shared between components is worth putting there.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组件必须具有状态。当有其他组件需要了解那个非常相同的状态时，第一个组件需要找到一种方法将这个状态传达给其他组件。有许多实现这一目标的方法。一种方法是通过确保所有应该共享的状态都生活在中央存储中。将这个存储视为一个单一的真实来源，所有组件都可以从中读取。并不是每个状态都一定需要最终进入中央存储，因为状态可能只关注特定的组件。在
    NgRx 和 Redux 之前，解决这一问题的方法之一是将所有内容放入一个全局可访问的对象或服务中。正如我们提到的，存储就是这样。它在全局上是可访问的，因为它可以被注入到可能需要它的任何组件中。一个警告：尽管将所有状态放入我们的存储中很有诱惑力，但我们真的不应该这样做。需要在不同组件之间共享的状态值得放入那里。
- en: Another benefit we get from having a centralized store is that it is very easy
    to save down the application's state for later recovery. If state only lives in
    one place, a user, or the system, can easily persist that state to a backend so
    that next time, if they want to continue from where they left off, they can easily
    do so by querying the backend for that state. So, there does exist another reason
    for wanting a centralized store other than wanting to share the data between many
    components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从拥有集中式存储中我们得到的另一个好处是，保存应用程序的状态以便稍后恢复非常容易。如果状态只存在于一个地方，比如用户或系统，那么用户可以轻松地将该状态持久化到后端，这样下次，如果他们想要从上次离开的地方继续，他们可以通过查询后端的状态来轻松地做到这一点。所以，除了想要在许多组件之间共享数据之外，还存在另一个想要集中存储的原因。
- en: '@ngrx/store – state management'
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ngrx/store – 状态管理'
- en: All of the files in this section points to `Chapter9/State` project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有文件都指向`Chapter9/State`项目。
- en: 'This is the moment we have been waiting for. How do we actually get started?
    It''s really easy. Let''s first ensure we have installed Angular CLI. We do so
    by typing the following in our terminal:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们一直等待的时刻。我们实际上该如何开始呢？这真的很简单。首先，让我们确保我们已经安装了Angular CLI。我们通过在终端中输入以下内容来完成此操作：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At this point, we need an Angular project. We use the Angular CLI for that,
    and scaffold ourselves a new project using the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要一个Angular项目。我们使用Angular CLI来做这件事，并使用以下命令搭建一个新项目：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the scaffolding process is done, we navigate to our newly created director
    project with a simple `cd <project dir>`.We want to use the core functionality
    provided in the `@ngrx/store` library, therefore we install it by typing the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦搭建过程完成，我们使用简单的`cd <项目目录>`命令导航到我们新创建的项目目录。我们想要使用`@ngrx/store`库提供的核心功能，因此我们通过输入以下内容来安装它：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s now open up the `app.module.ts` file in our scaffolded project. The
    time has come to import and register NgRx with `AppModule`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们打开我们搭建的项目中的`app.module.ts`文件。是时候将NgRx导入并注册到`AppModule`中了：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we''ve highlighted the important part, which is importing
    `StoreModule` and registering it with `AppModule` by typing:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们突出显示了重要部分，即导入`StoreModule`并通过输入将其与`AppModule`注册：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we are telling the store what state should exist, which is `counter`,
    and that `counterReducer` is the reducer meant to take care of that slice of state.
    As you can see, the code doesn''t quite work yet because we haven''t created `counterReducer`
    yet, let''s do that next:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉存储应该存在什么状态，即`counter`，以及`counterReducer`是负责该状态片段的reducer。正如你所见，代码还没有完全工作，因为我们还没有创建`counterReducer`，让我们接下来创建它：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Hopefully, you have read [Chapter 8](e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml),
    *Redux*, and understand why we write the reducer file as we have done. Let''s
    recap a bit, and declare that a reducer is just a function that takes a state
    and produces a new state given an action. It''s also important to stress that
    reducers are so called pure functions that do not change the state, but produce
    a new state, given the old state plus the incoming action. Let''s show here how
    we would theoretically use our reducer if we wanted to use it outside of Redux.
    We do this just to demonstrate how reducers work:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经阅读了[第8章](e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml)，*Redux*，并理解为什么我们以这种方式编写reducer文件。让我们回顾一下，并声明reducer只是一个函数，它接受一个状态并根据一个动作产生一个新的状态。同样重要的是强调，reducer被称为纯函数，它不会改变状态，而是根据旧状态加上传入的动作产生一个新的状态。让我们在这里展示如果我们想在Redux之外使用reducer时会如何理论性地使用它。我们这样做只是为了演示reducer是如何工作的：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see from this, we start off with an initial value of `0`, and it
    computes a new value that results in `1`. Upon the second execution of the function,
    we provide it with the existing state, which has the value `0`. This results in
    our state now being `2`. This may look simple, but this is pretty much as complicated
    as a reducer can get. Normally, you wouldn''t execute the reducer function yourself
    but rather register it with the store and dispatch actions towards the store.
    This will lead to the reducer being invoked. So, how do we tell the store to dispatch?
    Simple, we use the function `dispatch()` on the store. For this code, let''s move
    to the `app.component.ts` file. We also need to create a file called `app-state.ts`,
    which is an interface, a typed representation of our store:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们从初始值`0`开始，并计算出一个新值，结果为`1`。在函数的第二次执行中，我们向它提供现有的状态，其值为`0`。这导致我们的状态现在变为`2`。这看起来可能很简单，但这几乎是一个reducer可能达到的复杂程度。通常，你不会自己执行reducer函数，而是将其注册到store中，并向store发送动作。这将导致reducer被调用。那么，我们如何告诉store发送动作呢？很简单，我们使用store上的`dispatch()`函数。对于这段代码，让我们转到`app.component.ts`文件。我们还需要创建一个名为`app-state.ts`的文件，它是一个接口，是我们store的类型化表示：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What we can see from the preceding code is how we inject a store service into
    the constructor, like so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到我们如何将store服务注入到构造函数中，如下所示：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Thereafter, we call `store.select("count")`, which means we are asking our
    store for the `count` property part of its state as that''s all this component
    cares about. A call `store.select()` returns an `Observable` that when resolved
    contains a value. We can easily show this value by adding it to the template markup,
    like so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们调用`store.select("count")`，这意味着我们正在向store请求其状态的`count`属性部分，因为这就是这个组件所关心的。`store.select()`的调用返回一个`Observable`，当解析时包含一个值。我们可以通过将其添加到模板标记中轻松显示此值，如下所示：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That takes care of getting and displaying the state. What about dispatching
    an action? The store instance has a method on it called `dispatch()`, which takes
    an object containing the property type. So the following is perfectly good input:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了获取和显示状态。那么，发送动作怎么办？store实例上有一个名为`dispatch()`的方法，它接受一个包含属性类型的对象。所以以下是一个完美的输入：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s build out our component a little, and create some methods and markup
    that will allow us to dispatch actions and see the end result of doing so:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建我们的组件，并创建一些方法和标记，以便我们可以发送动作并看到这样做的结果：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We added the `increment()` and `decrement()` methods to the class body, and
    also added two buttons to the markup that invoke said functions. Trying this out,
    we can see how our UI is updated for every press of the button. The reason for
    this working is, of course, that each dispatched action calls our `counterReducer`
    implicitly, and also because we hold a reference to our state in the form of the
    `counter$` variable. As this is an `Observable`, it means it will be updated when
    a change happens. The change is then pushed out to our `counter$` variable when
    an action is dispatched. It's simple, but powerful.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类体中添加了`increment()`和`decrement()`方法，并在标记中添加了两个按钮，这些按钮调用这些函数。尝试这样做，我们可以看到我们的UI在每次按钮按下时都会更新。当然，这是因为每个发送的动作都会隐式调用我们的`counterReducer`，也因为我们在`counter$`变量的形式中持有对状态的引用。由于这是一个`Observable`，这意味着当发生变化时它会被更新。当发送动作时，变化会被推送到我们的`counter$`变量。这很简单，但很强大。
- en: A more complex example – a list
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更复杂的例子——一个列表
- en: We have so far learned how to set up NgRx by importing and registering its module.
    We have also been taught about the `select()` function that gives us a slice of
    state, and the `dispatch()` function that allows us to dispatch an action. These
    are the basics, we will use these very same basics and create a new reducer to
    reinforce what we already know, while introducing the concept payload.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何通过导入和注册其模块来设置NgRx。我们还学习了`select()`函数，它给我们一个状态切片，以及允许我们发送动作的`dispatch()`函数。这些都是基础知识，我们将使用这些非常相同的基础知识来创建一个新的reducer，以巩固我们已知的知识，同时引入负载的概念。
- en: 'We need to do the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做以下事情：
- en: Tell the store we have a new state, `jedis`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉store我们有一个新的状态，`jedis`
- en: Create a `jediListReducer` and register it with the store
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`jediListReducer`并将其注册到store中
- en: Create a component that supports showing our `jediList`, but is also able to
    dispatch actions that will change our slice of state `jedis`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个组件，它不仅支持显示我们的`jediList`，还能够发送改变我们状态切片`jedis`的动作。
- en: 'Let''s get down to business by defining our reducer, `jediListReducer`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s explain what goes on here for each case in our switch. First off, we
    have `ADD_JEDI`. We take our `action.payload` and add it to the list. Or technically,
    we take our existing list and construct a new list based on the old list, plus
    our new list item found in `action.payload`. Secondly we have `REMOVE_JEDI` that
    uses the `filter()` function to take away the list item that we don''t want to
    see. Lastly we have `LOAD_JEDIS` that takes in an existing list and replaces our
    state. Now, let''s demo this reducer by invoking it here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s register this reducer with the store. We will therefore return
    to `app.module.ts`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Because we just added a new state to our store, we should make the `app-state.ts`
    file aware of it, and we should also create a `Jedi` model so we can use that
    in our component later on:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'From the preceding code, we can see that `jediListReducer`, as well as the
    state `jediList`, is added to the object that serves as input to the `StoreModule.forRoot()`
    function. This means that NgRx is aware of this state and will let us retrieve
    it and dispatch actions to it. To do so, let''s build a component with just that.
    We need to create the `jedi-list.component.ts` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last thing we need to do is to register this component with our module,
    and we should have a working application:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Best practices
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following files points to the demo project `Chapter9/BestPractices`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have created some working code, but it could look a lot better,
    and be less error prone as well. There are steps we can take to improve the code,
    those are:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Get rid of so-called magic strings and rely on constants
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a default state to your reducer
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create so-called action creators
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move everything into a dedicated module and split up it up into several components
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at our first bullet point. Given the type of actions we
    perform on our `jediList`, we can create a `constants.ts` file for them, like
    so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, when we refer to these actions we can instead import this file and use
    these constants instead, decreasing the risk of us mistyping.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing we can do is to simplify the creation of actions by creating
    the so-called action creator. We are so far used to typing the following to create
    an action:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A better habit here is to create a function that does this for us. For the
    case with the list reducer, there are three possible actions that can take place,
    so let''s put all these in a `actions.ts` file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The point of creating the `actions.ts` file was so that we would have to write
    less code when we dispatch actions. Instead of writing the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now write this as:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A cleanup example
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following scenario can be found in the **`Chapter9/BestPractices`** folder
    of the code repository.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain where we are coming from, and why there might be a need to clean
    up your code. If you are starting out with a very simple app, you might add the
    reducer, the actions, and components in the root module of your project. This
    might create a mess as soon as you want to add another component. Let''s illustrate
    what our file structure might look like before we start cleaning up:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From this, it's pretty clear that this will only hold up if our app will only
    consist of that one component. As soon as we add more components, things will
    start to look messy.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list what we need to do to create a better file structure, but also
    utilize the action creator, constants, and reducers in the best way possible:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Create a dedicated feature module and directory
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create action constants that the reducer and actions file can use
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an action creator file with all the actions we mean to perform
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a reducer that handles dispatches
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `JediList` component that is able to handle all actions we mean to
    use
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register our reducer and state with the store
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a dedicated directory and feature module
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For that reason, we want to place everything in a dedicated directory, `jedi`.
    The easiest way to do that is to use the Angular CLI and run the following commands:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code will generate the following files:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Place yourself in your newly created `jedi` directory and type the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will add the following structure to your `jedi` directory:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, we have created the `jedi-list.component` and its belonging files
    in a previous section, so we will remove those scaffolded files for now and just
    move in the already created files under the `jedi-list` directory. So, your directory
    should look like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Add reducer and constants
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our reducer, like so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our next order of business is our constants file, which has already been created
    and just need to move, like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A general tip is if you find the number of components and files growing, consider
    creating a dedicated directory for it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the action creator file that we have also already created, and that
    we just need to move to our `jedi` directory, like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our directory should now look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Moving the component to our jedi directory
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next point is about moving our `JediListComponent` to our `jedi` directory,
    like so:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After moving our `jedi-list` component, our directory should now look like
    the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Registering our reducer with the store
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, we just need to do a slight update to the `app.module.ts` file to have
    it point correctly to our `JediListReducer`, like so:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Leveraging types and feature modules
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following files is pointing to the demo project `Chapter9/FeatureModules`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, one thing we can definitely improve is how we tell the `StoreModule` about
    what state and reducers exist in our app. Let''s do a quick recap and look at
    its current state:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, we are essentially feeding the `forRoot()` method an object. What''s wrong
    with that? Well, imagine you have ten different feature modules and every feature
    module may have three to four states, then the object you pass to `forRoot()`
    will grow in size and the number of imports that you need to do in your `app.module.ts`
    will grow. It will look something like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们实际上是在向`forRoot()`方法传递一个对象。这有什么问题吗？好吧，想象一下你有十个不同的功能模块，每个功能模块可能有三到四个状态，那么传递给`forRoot()`的对象将增大，你需要在`app.module.ts`中进行的导入数量也将增加。它看起来可能像这样：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Going from forRoot() to forFeature()
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从forRoot()到forFeature()
- en: 'To solve the mess we are creating in `app.module.ts,` we will now use a method
    called `forFeature()` on `StoreModule` that will allow us to set up the states
    we need per feature module. Let''s take the existing setup and refactor that:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决我们在`app.module.ts`中造成的混乱，我们现在将使用在`StoreModule`上的`forFeature()`方法，这将允许我们为每个功能模块设置所需的各个状态。让我们从现有的设置开始，进行重构：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We move our two reducer entries to their respective feature modules, `counter.module.ts`
    and `jedi.module.ts`. That would now look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个还原器条目移动到它们各自的功能模块中，`counter.module.ts`和`jedi.module.ts`。现在它看起来可能像这样：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We left out the implementation on purpose here because we need to take a step
    back. Remember when we called `StoreModule.forRoot()`, we could just pass it an
    object. It doesn''t look quite the same with `forFeature()`. There is a little
    bit of difference, so let''s try to explain what that difference is. We are used
    to setting up our store by passing it an object, which looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意省略了这里的实现，因为我们需要退后一步。记得当我们调用`StoreModule.forRoot()`时，我们可以直接传递一个对象。使用`forFeature()`时看起来并不完全一样。有一点不同，所以让我们尝试解释一下这个差异。我们习惯于通过传递一个对象来设置我们的存储，这个对象看起来像这样：
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Setting up forFeature() from string to selection function
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将forFeature()从字符串转换为选择函数
- en: 'We can set it up in pretty much the same way, but we need to pass it the name
    of a feature as well. Let''s take our `counter.module.ts` and add a little code
    to it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以几乎相同的方式设置它，但我们需要传递一个功能模块的名称。让我们看看我们的`counter.module.ts`，并给它添加一些代码：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will change how we select our state, though. Imagine we are inside of
    `counter.component.ts` with the current implementation looking like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变我们选择状态的方式。想象一下我们处于`counter.component.ts`内部，当前的实现看起来如下：
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Because we changed what the state looked like in `counter.module.ts`, we now
    need to reflect that in `counter.component.ts`, like so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在`counter.module.ts`中改变了状态的外观，我们现在需要在`counter.component.ts`中反映这一点，如下所示：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Introducing NgRx types for setting up the state
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍用于设置状态的NgRx类型
- en: 'Up to this point, we have learned how we move the store state declaration from
    `app.module.ts` and register it in each feature module instead. This will provide
    us with a little more order. Let''s take a close look at the types used for registering
    state. `ActionReducerMap` is a type we have been using implicitly so far. We have
    been using it every time we call `StoreModule.forRoot()` or `StoreModule.forFeature()`.
    We have been using it in the sense that, the object we pass containing state and
    their reducers consists of this type. Let''s prove that is the case by turning
    to our `counter.module.ts`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何将存储状态声明从`app.module.ts`移动并注册到每个功能模块中。这将给我们带来更多的秩序。让我们仔细看看用于注册状态的类型。`ActionReducerMap`是我们迄今为止隐式使用的一个类型。每次我们调用`StoreModule.forRoot()`或`StoreModule.forFeature()`时，我们都在使用它。我们在使用它的意义上，传递包含状态及其还原器的对象由这种类型组成。让我们通过转向我们的`counter.module.ts`来证明这一点：
- en: '[PRE44]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s change that a bit, to this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍作改变，变成这样：
- en: '[PRE45]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, we can see that we are leveraging `ActionReducerMap`, which is a generic
    that forces us to provide it with a type. In this case, the type is `CounterState`.
    Running this code should just work. So, why use `ActionReducerMap` explicitly
    like this?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到我们正在利用`ActionReducerMap`，这是一个泛型，它强制我们提供给它一个类型。在这种情况下，类型是`CounterState`。运行这段代码应该可以正常工作。那么，为什么要显式地使用`ActionReducerMap`呢？
- en: Giving forFeature() a type
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给forFeature()一个类型
- en: 'Well, the `forFeature()` method is a generic as well, and we can specify this
    one explicitly like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`forFeature()`方法也是一个泛型，我们可以像这样显式指定它：
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This protects us from adding a state mapping object that it does not expect
    to the `forFeature()` method. For instance, the following would render an error:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这保护我们不会向`forFeature()`方法添加它不期望的状态映射对象。例如，以下将引发错误：
- en: '[PRE47]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The reason for this is that we are providing the wrong type to the `forFeature()`
    method. It expects a reducer parameter to be something of type `ActionReducerMap<CounterState>`,
    which it clearly is not, as we are sending in `ActionReducerMap<State>`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于我们向`forFeature()`方法提供了错误类型。它期望reducer参数是`ActionReducerMap<CounterState>`类型，这显然不是，因为我们发送的是`ActionReducerMap<State>`。
- en: Several states in the same feature module
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同一特征模块中的多个状态
- en: The following scenario can be found in the `Chapter9/TypesDemo` folder of the
    code repository.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下场景可以在代码仓库的`Chapter9/TypesDemo`文件夹中找到。
- en: 'OK, so now we know about the `ActionReducerMap` type, and we also know that
    we can provide a type to the `forFeature()` method and make it safer to use. What
    happens if we''ve got several states in our feature module, what then? The answer
    is quite simple, but let''s first have a closer look at what we mean exactly by
    several states. Our counter module contains the `counter.value` state. This is
    displayed in our `counter.component.ts`. If we want to add a `counter.list` state,
    we need to add the supporting constants, reducers, actions, and a component file
    so we can properly display it. Our file structure should therefore look like the
    following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们知道了`ActionReducerMap`类型，我们也知道可以向`forFeature()`方法提供一个类型，使其使用更安全。如果我们特征模块中有多个状态，会发生什么？答案是相当简单的，但让我们首先更仔细地看看我们所说的“多个状态”究竟是什么意思。我们的计数器模块包含`counter.value`状态。这在我们`counter.component.ts`中显示。如果我们想添加一个`counter.list`状态，我们需要添加支持常量、reducer、actions和一个组件文件，以便我们能够正确地显示它。因此，我们的文件结构应该如下所示：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We need to add implementation for all of these bold files.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为所有这些加粗的文件添加实现。
- en: Adding the counter-list reducer
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加计数器列表的reducer
- en: 'Let''s start off with the reducer:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从reducer开始：
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This reducer supports two types, `ADD_COUNTER_ITEM` and `REMOVE_COUNTER_ITEM`,
    which will let us add and remove items from the list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个reducer支持两种类型，`ADD_COUNTER_ITEM`和`REMOVE_COUNTER_ITEM`，这将使我们能够向列表中添加和移除项目。
- en: Adding the component
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加组件
- en: 'This one comes in two parts, the HTML template and the class file. Let''s start
    with the class file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分分为两部分，HTML模板和类文件。让我们先从类文件开始：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The HTML template file is quite simple, and looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: HTML模板文件相当简单，看起来像这样：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code, we are supporting the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们支持以下内容：
- en: Showing a list of counter objects
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示计数器对象的列表
- en: Adding an item to the list
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目添加到列表中
- en: Removing an item from the list
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表中移除项目
- en: Adding the constants
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加常量
- en: 'Next up is adding the constants. Constants are a nice thing to have; they protect
    us from making mistakes due to us mistyping when we deal with action creators
    as well as reducers:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是添加常量。常量是件好事；它们可以保护我们免受在处理action creators和reducers时因误输入而犯错的困扰：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Adding the action methods
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动作方法
- en: 'We also need to define the action methods. These are just functions that will
    help us create our actions, so it''s less for us to type:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须定义动作方法。这些只是帮助我们创建动作的函数，所以我们需要输入的更少：
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Adding the model
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加模型
- en: 'We need to type what our counter-list should contain. For that we need to create
    a model:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的计数器列表指定类型。为此，我们需要创建一个模型：
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Register our reducers
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册我们的reducer
- en: 'We do need to add and implement all the files in bold, but we also need to
    update the `counter.module.ts` file so we are able to handle the added state:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实需要添加和实现所有加粗的文件，但我们也需要更新`counter.module.ts`文件，以便我们能够处理添加的状态：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We need to add a `CombinedState` interface that represents all of our reducers
    with their state. Lastly, we change the call to `StoreModule.forFeature()`. That
    concludes how we deal with several states and reducers within the same module.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个`CombinedState`接口，它代表所有我们的reducer及其状态。最后，我们更改对`StoreModule.forFeature()`的调用。这就完成了我们在同一模块内处理多个状态和reducer的方法。
- en: Component architecture
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件架构
- en: 'There are different kinds of components. Two types of components are of interest
    in the context of NgRx: smart components and dumb components.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同种类的组件。在NgRx的上下文中，有两种类型的组件值得关注：智能组件和哑组件。
- en: Smart components are also called container components. They should be on the
    highest level of your application, and handle routes. For example, `ProductsComponent`
    should be a container component if it handles the `route/products`. It should
    also know about the store.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 智能组件也被称为容器组件。它们应该在应用程序的最高级别，并处理路由。例如，如果`ProductsComponent`处理`route/products`，它应该是一个容器组件。它还应该了解存储。
- en: 'The definition of a dumb component is that it has no knowledge of a store and
    relies solely on the `@Input` and `@Output` properties—it''s all about presentation,
    which is why it is also called a presentational component. A presentational component
    in this context can therefore be a `ProductListComponent` or a `ProductCreateComponent`.
    A quick overview of a feature module could therefore look like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 纯组件的定义是它没有关于存储的知识，并且完全依赖于 `@Input` 和 `@Output` 属性——它完全是关于展示的，这也是为什么它也被称为展示组件。因此，在这个上下文中，一个展示组件可以是
    `ProductListComponent` 或 `ProductCreateComponent`。一个功能模块的快速概述可能看起来像这样：
- en: '[PRE56]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s look at a small code example so you get the idea:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个小代码示例，以便你理解这个概念：
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our `ProductsComponent` is responsible for handling the route to `/products`.
    `ProductsListComponent` is a dumb component and just gets a list assigned to it
    that it is more than happy to render to the screen.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ProductsComponent` 负责处理 `/products` 路由。`ProductsListComponent` 是一个纯组件，它只被分配了一个列表，并且非常乐意将其渲染到屏幕上。
- en: '@ngrx/store-devtools – debugging'
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ngrx/store-devtools – 调试'
- en: The following scenario can be found in the code repository under `Chapter9/DevTools`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下场景可以在代码仓库的 `Chapter9/DevTools` 目录下找到。
- en: 'There are three things we need to do to get DevTools to work:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 DevTools 工作正常，我们需要做三件事：
- en: 'Install the NPM package: `` npm install @ngrx/store-devtools --save`.` ``'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 NPM 包：`npm install @ngrx/store-devtools --save`。
- en: 'Install the Chrome extension: `http://extension.remotedev.io/`. This is called
    the Redux DevTools extension.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Chrome 扩展程序：`http://extension.remotedev.io/`。这个扩展程序被称为 Redux DevTools 扩展程序。
- en: 'Set it up in your Angular module: this requires us to import DevTools into
    our Angular project.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的 Angular 模块中设置它：这需要我们将 DevTools 导入到我们的 Angular 项目中。
- en: 'Providing we have done the two first steps, we should only have the set up
    stage left, so we need to open up the `app.module.ts` file for that:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经完成了前两个步骤，那么我们只剩下设置阶段了，所以我们需要打开 `app.module.ts` 文件：
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Ok, so now everything is set up and we are ready to take our application for
    a spin and see what our debug tool can tell us. Let''s start up our application
    with `ng serve` and surf to `http://localhost:4200/`. First thing we want to do
    is open developer tools in Chrome and click on a tab called Redux. You should
    see something like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在一切都已经设置好了，我们准备运行我们的应用程序并看看我们的调试工具能告诉我们什么。让我们使用 `ng serve` 启动我们的应用程序，并访问
    `http://localhost:4200/`。我们首先想要做的是在 Chrome 中打开开发者工具，并点击一个名为 Redux 的标签页。你应该会看到如下内容：
- en: '![](img/c7818d9f-9121-49c7-af28-4e4f4524deae.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7818d9f-9121-49c7-af28-4e4f4524deae.png)'
- en: Redux tab
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 标签
- en: 'To the left we have our application UI, and to the right we have our Redux
    plugin. At this point, no actions have been carried out other than the initialization
    of the store, which we can see under the plugin part marked as Inspector. There
    is but one log entry, `@ngrx/store/init`. Let''s interact with the UI by clicking
    on the Increment button and see what happens with our store:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们有我们的应用程序 UI，在右侧，我们有 Redux 插件。在这个时候，除了存储的初始化之外，没有执行任何动作，这可以在插件的“检查器”部分看到。只有一个日志条目，`@ngrx/store/init`。让我们通过点击增量按钮与
    UI 交互，看看我们的存储会发生什么：
- en: '![](img/bb2388fa-38d0-4a20-b48d-2b8c23239336.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb2388fa-38d0-4a20-b48d-2b8c23239336.png)'
- en: Increment button
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 增量按钮
- en: 'As you can see, we have a new entry called INCREMENT. Two things are of interest
    now from a debug perspective:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有一个新的条目叫做 INCREMENT。从调试的角度来看，现在有两个事情值得关注：
- en: What actions were dispatched?
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派发了哪些动作？
- en: What impact did these actions have on the store?
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些动作对存储有什么影响？
- en: 'We learn the answer to both these questions by interacting with the tab buttons
    on the right-hand side of our plugin. The button called Action will tell us what
    action was dispatched and what payload it had, if any:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过与插件右侧的标签按钮交互来了解这两个问题的答案。名为 Action 的按钮会告诉我们派发了什么动作以及它是否有任何负载：
- en: '![](img/95fceeaa-999a-406f-b37f-a47dce810345.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95fceeaa-999a-406f-b37f-a47dce810345.png)'
- en: Action button
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 动作按钮
- en: 'Here, it is clearly stated that an action with type value Increment was dispatched.
    Now to our second question; what was the impact to our store? To find that out,
    we simply click the State button:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，清楚地说明了派发了一个类型值为 Increment 的动作。现在，关于我们的第二个问题；这些动作对存储有什么影响？为了找出答案，我们只需点击状态按钮：
- en: '![](img/ae545d45-0bca-445c-9082-09af2a3d29c8.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae545d45-0bca-445c-9082-09af2a3d29c8.png)'
- en: State button
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 状态按钮
- en: 'Our state tells us it consists of three properties, `count`, `todos` and `jediList`.
    Our `count` property has the value 1, and is the one affected by us clicking the
    Increment button. Let''s hit the Increment button a few more times to see that
    really is the case:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54f3ef2f-6319-4ab2-88c4-1612837dbb4a.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: Increment button
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We now see that our `count` property has the value `3`, and we have three entries
    of Increment actions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s talk about a really cool feature, time-travel debugging. Yes, you
    read that correctly, we can control time in our store by replaying dispatched
    actions, and even change history by removing dispatched actions, all in the name
    of debugging. The Redux plugin gives us several ways to do this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Click on a specific dispatched action on your left, and choose to skip dispatching
    it
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a slider to control and replay all the events, and traverse back and forth
    in time as you see fit
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s investigate the first way — click on a specific action:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/536749d5-d146-47c5-b158-b4e21df2aa0a.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: Click on a specific action
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Here we've clicked on the Skip button for one dispatch action and the end result
    is that this dispatched action is removed, which is indicated by the action being
    overstricken. We can also see that our `count` property now has the value `2`,
    as the action never took place. We can easily toggle this back if we want to by
    hitting Skip again.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned there was another way to control the flow of dispatched actions,
    namely by using a slider. There is a button called Slider that toggles the slider.
    Clicking it results in us being shown a slider control with a Play button, like
    so:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0997df04-8a9a-47f8-a426-0e765c7139d1.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: Play button
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: If you press the Play button, it will simply play all the dispatched actions.
    However, if you choose to interact with the cursor on the slider itself you are
    able to pull it both to the left, to move back in time, and to the right, to move
    forward in time.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the Redux plugin is a truly powerful tool to use in order to
    quickly gain an understanding of the following aspects:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: What your app's state is at a given point in time
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What part of the UI leads to what effects in the store
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '@ngrx/effects – working with side effects'
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have a basic understanding of NgRx. We know how to set up
    our state and create all the artifacts that go with it such as actions, action
    creators, and reducers. Additionally, we have also gained familiarity with the
    Redux plugin for Chrome and understood what a valuable tool it can be to help
    us quickly gain an understanding of the state in our app, and most importantly
    how it can aid us in debugging any problems we may have related to NgRx.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Now, the time has come to talk about something that doesn't quite fit in to
    our organized and synchronous world of reducers and actions. I am talking about
    something called side effects. Side effects are operations such as accessing files
    or network resources, and is not really related to our applications state even
    though they may be the vessels that contain the data we want, or be the place
    we persist data to. As we just said, a dispatched action is dispatched in a synchronous
    way and the change to our state happens straight away. A side effect is something
    that may take time. Imagine that we access a large file or ask for a resource
    over the network using AJAX. This request will finish sometime in the future and,
    when done, it may affect our state. How do we make these time consuming and asynchronous
    operations fit in with our synchronous and momentary world? The answer in NgRx
    is a library called `@ngrx/effects`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting it up
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing it is as easy as performing the following command in your terminal:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The next step is to set it up. The setup can be seen as consisting of two steps:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Create our effect
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register the effect with the `EffectsModule`
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An effect is just an injectable service that listens for a specific action.
    Once the effect is in focus, it can carry out a number of operations and transformations
    before leaving over control. It leaves over control by dispatching an action.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first effect – a realistic scenario
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following scenario can be found in the code repository under `Chapter9/DemoEffects`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'This sounds a bit cryptic, so let''s take a realistic scenario. You want to
    fetch products using AJAX from an endpoint. If you think about what you are about
    to undertake in the following steps:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch a `FETCHING_PRODUCTS`, this sets up our state so we can see that an
    AJAX request is under way and we can thereby use this to display a spinner for
    as long as the AJAX request is waiting to complete.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform an AJAX call and retrieve your products.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If successfully retrieving the products, then dispatch `FETCHING_PRODUCTS_SUCCESSFULLY`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is an error, then dispatch `FETCHING_PRODUCTS_ERROR`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s solve this task in the following steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Create a reducer for it.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create actions and action creators.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an effect.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the preceding effect with our effects module.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To perform all of this, we will create a feature module. To do so, we create
    the `product/` directory with the following files:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '`product.component.ts`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.actions.ts`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.constants.ts`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.reducer.ts`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.selectors.ts`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.module.ts`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.effect.ts`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these files are known to us before, except for `product.effect.ts`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Creating our constants
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with our constants file. What we need are constants that will
    support us firing away an AJAX request. We also need a constant for when we get
    our data back successfully, but we also need to cater to any error that might
    occur. This means we need the following three constants:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Action creators
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to expose a number of functions that can build objects for us containing
    a type and a payload property. Depending on what function we invoke, we will assign
    it with a different constant, and of course a different payload, if using one.
    The action creator `fetchProducts()` will create an object where only the type
    is set. This is followed by a `fetchSuccessfully()` action creator, which will
    be invoked once the data comes back from an endpoint. Lastly, we have the `fetchError()`
    action creator, which we will invoke if an error occurs:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Reducer with a new type of default state
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At first glance, the following reducer is just like any reducer you have written
    before. It is a function that takes a parameters'' state and action, and it contains
    a switch construct that switches between different actions. So far, everything
    is familiar. The `initialState` variable is different though. It contains the
    `loading`, `list`, and `error` properties. `loading` is simply a Boolean that
    indicates whether our AJAX request is still pending. `list` is our data property
    that will contain our list of products once they are are returned. The `error`
    property is simply a property that contains the error if any comes back from the
    AJAX request:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The effect – listening to a specific dispatched action
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So we come to the effect. Our effect acts like a listener to a dispatched action.
    This gives us the opportunity to carry out a unit of work, but also to dispatch
    an action once that work is done.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created all the usual bits that we are used to, so now it is time to
    create our effect that will handle the entire workflow:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The effect is just a class decorated with the `@Injectable` decorator. It also
    contains two members: one member of `Actions` type and another of the `Observable<Action>`
    type. Actions come from the `@ngrx/effects` module and are nothing more than a
    specialized `Observable` with the `ofType()` method on it. `ofType()` is the method
    that takes a string constant, which is the event we are listening for. In the
    previous code, the `products$` is the `Observable` that we decorate with the `@Effect`
    decorator. Our next step is to connect `products$` with `actions$`, and define
    how our effect should work. We do that with the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Ok, so we have set up our effect a little more. The call to `ofType()` ensures
    we set ourselves up to listen to a specific dispatched action. The call to `switchMap()`
    ensures we are able to take the current `Observable` that we are currently on,
    and turn it into something completely different, such as a call to an AJAX service.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now return back to our example and see how we can fit in some product-related
    logic in there:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: What we do in the preceding code is listen to our `FETCHING_PRODUCTS` action
    and carry out a call to an AJAX service. We added a call to the `delay()` operator
    so as to simulate that our AJAX call takes some time to carry out. This will give
    us a chance to show a loading spinner. The `map()` operator ensures we dispatch
    an action when we get the AJAX response back. We can see that we call the action
    creator, `fetchProductsSuccessfully()`, which implicitly calls the reducer and
    sets a new state on the products property.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we need to register the effect before moving on. We can do so
    in the root module or in the feature module. It''s a very similar call, so let''s
    describe both ways of doing it:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we have a feature module, on the other hand, we could be using the `forFeature()`
    method on the `EffectsModule` and call that in our feature module like so:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Adding a component – introducing selectors
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it, thats all you need to create an effect. We're not done here though,
    we need a component to display our data, as well as a spinner, while we are waiting
    for the AJAX request to finish.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, first things first: what do we know of components that should be using
    NgRx? The obvious answer is that they should be injecting the store so we can
    listen to a slice of state from the store. The way we listen to a slice of state
    is by calling the stores `select()` function. This will return an `Observable`.
    We know we can easily show Observables in the template through the use of the
    async pipe. So let''s start sketching our component:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This part of our component here shouldn''t come as too much of a surprise;
    we inject the store into the constructor, call `select()`, and get an Observable
    back. But, there is a *but* here, we are calling the `select()` method differently.
    We used to pass a string to the `select()` function, and now we pass it a function.
    Why is that? Well, because we changed how our state looked. Let''s show our new
    state again, for clarity:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The preceding code shows that we can''t just do `store.select("products")`
    because that would give us the whole object back. So we need a way to dig into
    the previous object in order to get a hold of the list property that should contain
    our list of products. The way to do that is to use the variant of the `select`
    method that takes a function instead. We do just that with the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Ok, but will this really be type safe? Won''t the `AppState` interface complain?
    Does it know of our changed state structure? Well, we can tell it knows about
    it, but we need to ensure that our reducer exports an interface that represents
    our new state structure. We therefore change the reducer to look like the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And of course, we need to update the `AppState` interface to look like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Ok, this made our `AppState` know what kind of beast our `products` property
    really is, and is thereby what makes the `store.select(<Fn>)` call possible. The
    function we gave the `select` method is called a selector, and is actually something
    that doesn''t have to live inside the component. The reason for this is that we
    might want to access that slice of state somewhere else. Let''s therefore create
    a `product.selectors.ts` file. We will add to this later as we keep supporting
    CRUD:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Ok, so now we have created our selectors file, and we can immediately start
    improving our components code and clean it up a bit before we continue to add
    things to it:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Our code looks much better. It''s time to start caring about the other aspect
    of this; what if our HTTP service takes a few seconds, or even one second to return?
    This is a real concern especially with our users being potentially on a 3G connection.
    To take care of this, we grab the `loading` property from our products state and
    use that as a conditional in our template. We will basically say that if the HTTP
    call is still pending, show some text or an image that indicates to the user that
    something is loading. Let''s add that piece of functionality to the component:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let''s also ensure that we show any errors by subscribing to `products.error`.
    We simply update the component with the following alterations:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Ok, we fire up our application at this point. There is just one teeny tiny
    problem; we don''t see any products at all. Why is that? The explanation is simple.
    We don''t actually dispatch an action that will lead to the AJAX call being made.
    Let''s fix that by adding the following code to our component:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This will of course trigger our effect, which will lead to our HTTP call, which
    will lead to `fetchProductsSuccessfully()` being called, and thereby our state
    will be updated and `products.list` will no longer be an empty array, meaning
    our UI will show a list of products. Success!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Extending our example with the create effect
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have gone through the full flow of adding an effect, building a
    component, and improved the code with selectors. To make sure we really understand
    how to work with effects and how the application scales with it, let''s add another
    effect, this time let''s add an effect to support an HTTP POST call. What we want
    to happen from an application standpoint is that we add another product to the
    list. This should update the UI and show our added product. What happens data-wise
    is that our store should reflect that change and, as a side effect, a HTTP POST
    should be carried out. We need the following to accomplish this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: A reducer that supports adding a product to our products list
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An effect that listens to a product being added action and that carries out
    a HTTP POST
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to register the created effect
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the constants file
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like with the fetching of products, we need to support one action that
    triggers everything. We need another action for when the HTTP request succeeds
    and one last action to support error handling:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Updating the reducer
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point we take our existing `reducer.ts` file and add what we need to
    support adding a product:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: It's worth noting how we create the help function, `addProduct()`, which allows
    us to create a new list containing the old content and our new product. It's also
    worth noting that we can group `FETCHING_PRODUCTS_ERROR` and `ADD_PRODUCT_ERROR`
    actions, and also `ADD_PRODUCT` and `ADD_PRODUCT_SUCCESSFULLY`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Additional actions
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next order of business is to update our `products.actions.ts` file with
    the new methods that we need to support the preceding code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: What is worth noting with the created actions is that the `addProduct()` method
    takes a product as a parameter. The reason for that is that we want the side effect
    to use that as body data for the forthcoming HTTP POST.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Adding another effect
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are finally ready to construct our effect. It''s going to look very
    similar to the existing one:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The first thing we do here is to reuse our `ProductEffects` class and add a
    new member `productsAdd$` to it. While at it, we rename `products$` to `productsGet$`.
    As long as we are dealing with products we can keep on adding to this class.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: The similarities we see with the existing effect is that we set up our `ofType()`
    operator to listen for a dispatched action of our choice. Thereafter, we continue
    with our side effect, that is the call to the `HttpClient` service that ends up
    being an HTTP POST call.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Supporting the effect in our component
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We don''t need to do much in our component. Of course, we need to add some
    things in the template to support adding a product. In terms of NgRx, we just
    need to dispatch the `ADD_PRODUCT` action. Let''s have a look at the code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Ok, from this code we set up an input control and a button to be able to handle
    the user inputting a new product. For the class, we added the `newProduct` field
    and we also added the `addNewProduct()` method that, in its body, invokes the
    `addProduct()`, method and thereby passes an `ADD_PRODUCT` action. We really don't
    need to do more. Our product addition sets the loading state before carrying out
    the HTTP call, so we can show a spinner if we want, and our error state picks
    up on any errors that might occur and presents them in the UI. Lastly, don't forget
    to add the `FormsModule` to the `import` property in the `product.module.ts`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Running a demo of the app
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To try out our app, we can simply run the `ng serve` command in the terminal.
    What we expect to see is a screen that for three seconds states it is loading,
    just to be replaced by the fetched data. This will demonstrate both the dispatch
    of the loaded state, as well as us dispatching the data to the store once it arrives.
    The following is the initial screen when our data is yet to arrive. We fire off
    the `FETCHING_PRODUCTS` action, which makes our loading text appear:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/322941c2-5f58-4f91-97a7-e8c27e8e020b.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: 'The next screen is when our data arrives. Subsequently, we fire off `ADD_PRODUCT_SUCCESSFULLY`
    to ensure that the fetched data is placed in the store:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c69a9eb-ebef-413a-b7f5-47e5509acea2.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone through a lot in this chapter. Among the things covered have been
    installing and using the store. To that knowledge, we have added some sound best
    practices to organize your code. It's important to note that consistency is key.
    There are many ways to organize code, so as long as that chosen way remains consistent
    throughout the app, that is the most important factor. With that said, organizing
    your code by domain is what is prescribed for most things Angular. Whether that
    holds true for NgRx is up to you, dear reader. See best practices as a guide rather
    than a rule. Furthermore, we covered side effects and how to handle those with
    `@ngrx/effects`. `@store-devtools` was another thing we covered, which lets us
    use our browser to easily debug our store. In the next, and final, chapter, we
    will cover `@ngrx/schematics` and `@ngrx/entity`, so we really cover everything
    NgRx has to offer us. Also, we will showcase how you can build NgRx yourself to
    gain further understanding on what goes on under the hood. If knowing what goes
    on under the hood isn't exciting to you, then you are in the wrong profession!
    Everything is really set up to make the final chapter a very interesting one.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
