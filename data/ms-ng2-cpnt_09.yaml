- en: Chapter 9. Spaceship Dashboard
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。太空船仪表盘
- en: When I was a child, I loved to play spaceship pilot. I piled up old carton boxes
    and decorated the interior to look like a spaceship cockpit. With a marker, I
    drew a spaceship dashboard on the inside of the boxes, and I remember playing
    in there for hours.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我还是个孩子的时候，我喜欢扮演太空船飞行员。我把一些旧的纸箱堆叠起来，并装饰内部使其看起来像太空船驾驶舱。我用记号笔在纸箱的内侧画了一个太空船仪表盘，我记得我在那里玩了好几个小时。
- en: The thing that's special about the design of cockpits and spaceship dashboards
    is that they need to provide an overview and control over the whole spaceship
    on very limited space. I think the same also applies to application dashboards.
    A dashboard should provide the user with an overview and a sense for the overall
    status of what's going on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 舰桥和太空船仪表盘的设计特别之处在于，它们需要在非常有限的空间内提供对整个太空船的概述和控制。我认为这同样适用于应用程序仪表盘。仪表盘应该为用户提供对正在发生的事情的整体概述和感知。
- en: 'In this chapter, we will create such a dashboard for our task management application.
    We will make use of the open source charting library Chartist to create good looking
    responsive charts and provide an overview over open tasks and project status:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的任务管理应用程序创建这样一个仪表盘。我们将利用开源图表库 Chartist 创建外观美观的响应式图表，并提供对开放任务和项目状况的概述：
- en: '![Spaceship Dashboard](img/image00340.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![太空船仪表盘](img/image00340.jpeg)'
- en: A preview of the tasks chart that we will build during the course of this chapter
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的进程中预览将要构建的任务图表
- en: 'On a higher level, we will create the following components in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高层次上，在本章中我们将创建以下组件：
- en: '**Project summary**: This is the project summary that will provide a quick
    insight into the overall project status. By aggregating all efforts of containing
    tasks, we can provide a nice overall efforts status, for which we have created
    the components in the previous chapter.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目摘要**：这是提供对整体项目状况快速洞察的项目摘要。通过聚合所有包含任务的努力，我们可以提供一个很好的整体努力状态，为此我们在上一章中创建了组件。'
- en: '**Project activity chart**: Without any labels or scales, this bar chart will
    just give a quick sense for the activity on projects in the last 24 hours.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目活动图表**：没有标签或刻度，这个条形图将只给出过去24小时内项目活动的快速感知。'
- en: '**Project tasks chart**: This chart provides an overview of the task progress
    on projects. Using a line chart, we will display the count of open tasks over
    a certain time period. Using our Toggle component that we created in [Chapter
    2](part0020.xhtml#aid-J2B81 "Chapter 2. Ready, Set, Go!"), *Ready, Set, Go!*,
    of this book, we''ll provide an easy way for the user to switch the displayed
    timeframe on the chart.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目任务图表**：此图表提供了项目任务进度的概述。我们将使用折线图显示一定时间内的开放任务数量。利用我们在本书[第2章](part0020.xhtml#aid-J2B81
    "第2章。准备，出发！")中创建的 Toggle 组件，我们将为用户提供一种简单的方法来切换图表上显示的时间范围。'
- en: Introduction to Chartist
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chartist 简介
- en: We will create some components in this chapter that will render charts, and
    we should look for some help in rendering them. Of course, we can follow a similar
    approach as we did in [Chapter 6](part0044.xhtml#aid-19UOO1 "Chapter 6. Keeping
    Up with Activities"), *Keeping Up with Activities*, when we drew our activity
    timeline. However, when it comes to more complex data visualization, it's better
    to rely on a library to do the heavy lifting.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一些可以渲染图表的组件，并且我们应该寻找一些帮助来渲染它们。当然，我们可以遵循我们在[第6章](part0044.xhtml#aid-19UOO1
    "第6章。跟上活动")中采取的类似方法，即*跟上活动*，当时我们绘制了我们的活动时间线。然而，当涉及到更复杂的数据可视化时，最好依赖于库来完成繁重的工作。
- en: It shouldn't be a surprise that we'll use Chartist to fill this gap because
    I've spent almost two years writing it. As the author of Chartist, I feel very
    lucky that we've found a perfect spot in this book to make use of it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Chartist 来填补这个空缺并不令人惊讶，因为我几乎花了两年时间来编写它。作为 Chartist 的作者，我感到非常幸运，我们在这本书中找到了一个完美的位置来利用它。
- en: I'd like to take the opportunity to introduce you to Chartist briefly before
    we dive into the implementation of the components for our dashboard.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入到仪表板组件的实现之前，我想借此机会简要地向您介绍 Chartist。
- en: The claim of Chartist is simple responsive charts, and this is luckily still
    the case after three years of existence. I can tell you that probably the hardest
    job of maintaining this library was to protect it from feature bloating. There
    are so many great movements, technologies, and ideas in the open source community
    and to resist and always stay focused on the initial claim wasn't easy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Chartist 的承诺很简单，即简单响应式图表，幸运的是，在存在了三年之后，这仍然是事实。我可以告诉你，维护这个库最困难的工作可能是保护它免受功能膨胀的影响。开源社区中有许多伟大的运动、技术和想法，抵制并始终专注于最初的承诺并不容易。
- en: 'Let me show you a very basic example of how you can create a simple line chart
    once you''ve included the Chartist scripts on your website:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你一个非常基本的例子，看看你如何在网站上包含 Chartist 脚本后创建一个简单的折线图：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The corresponding HTML markup that is required for this example looks as simple
    as the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为此示例所需的相应 HTML 标记看起来如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following figure shows you the resulting chart that is rendered by Chartist:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了由 Chartist 生成的结果图表：
- en: '![Introduction to Chartist](img/image00341.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Chartist 简介](img/image00341.jpeg)'
- en: A simple line chart rendered with Chartist
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Chartist 生成的简单折线图
- en: I believe that by saying that we've been sticking to our claim to stay simple,
    we've not promised too much.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，通过说我们一直在坚持我们的简单承诺，我们并没有承诺太多。
- en: Let's look at the second core concern of Chartist, which is to be perfectly
    responsive. Well, let's start with one of my most appreciated principles in web
    development, which is the separation of concerns in the frontend. Chartist tries
    to stick to this separation wherever possible, which means that it uses CSS for
    its appearance, SVG for the basic graphical structure, and JavaScript for any
    behavior. Simply by following this principle, we've already enabled a lot of responsiveness.
    We can use CSS media queries to apply different styles to our charts on different
    media.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Chartist 的第二个核心关注点，即完美响应。嗯，让我们从我在前端开发中最欣赏的一个原则开始，那就是关注点的分离。Chartist 尽可能地遵循这个原则，这意味着它使用
    CSS 来控制外观，SVG 来构建基本的图形结构，以及 JavaScript 来实现任何行为。仅仅通过遵循这个原则，我们已经实现了很多响应性。我们可以使用
    CSS 媒体查询来为不同媒体上的图表应用不同的样式。
- en: While CSS is great for visual styles, there are plenty of elements in the process
    of rendering charts, which can't be controlled simply by styling. After all, this
    is the reason why we use a JavaScript library to render charts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 CSS 对于视觉样式来说很棒，但在渲染图表的过程中有许多元素不能仅仅通过样式来控制。毕竟，这就是我们为什么使用 JavaScript 库来渲染图表的原因。
- en: So, how can we control how Chartist renders our charts on different media if
    we haven't got control over this in CSS? Well, Chartist provides something called
    responsive configuration overrides. Using the browsers `matchMedia` API, Chartist
    is able to provide a configuration mechanism that allows you to specify options
    that you want overridden on certain media.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们没有在 CSS 中控制 Chartist 在不同媒体上渲染图表的方式，我们该如何控制呢？嗯，Chartist 提供了一种称为响应式配置覆盖的功能。通过使用浏览器的
    `matchMedia` API，Chartist 能够提供一个配置机制，允许您指定在某些媒体上要覆盖的选项。
- en: 'Let''s look into a simple example of how we can easily implement responsive
    behavior using a mobile-first approach:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过移动优先的方法轻松实现响应性行为的一个简单示例：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the second parameter to the `Chartist.Line` constructor sets the initial
    options; we can provide overriding options annotated with media queries in an
    array as the third parameter of the constructor. In this example, we'll override
    the `showPoint` option for any media larger than 400 px in width. Media larger
    than 800 px in width will receive both the `showPoint` override as well as the
    `lineSmooth` override.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Chartist.Line` 构造函数的第二个参数设置了初始选项；我们可以将带有媒体查询的覆盖选项作为构造函数的第三个参数提供一个数组。在这个例子中，我们将覆盖宽度大于
    400 像素的任何媒体的 `showPoint` 选项。宽度大于 800 像素的媒体将接收到 `showPoint` 覆盖以及 `lineSmooth` 覆盖。
- en: Not only can we specify real media queries to trigger setting changes, but we
    can also use an overriding mechanism that is very similar to CSS. This way, we
    can implement various approaches, such as ranged or exclusive media queries, mobile-first,
    or desktop-first. This responsive options mechanism can be used for all options
    available in Chartist.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以通过指定真实的媒体查询来触发设置更改，还可以使用与 CSS 非常相似的覆盖机制。这样，我们可以实现各种方法，如范围或排他性媒体查询、移动优先或桌面优先。这个响应式选项机制可以用于
    Chartist 中所有可用的选项。
- en: '![Introduction to Chartist](img/image00342.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Chartist 简介](img/image00342.jpeg)'
- en: Displaying the previous chart on three different media left to right, starting
    from a media with less than 400 px (A), less than 800 px (B), and more than 800
    px (C).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，在三种不同的媒体上显示之前的图表，从小于 400 像素的媒体（A），小于 800 像素的媒体（B），到大于 800 像素的媒体（C）。
- en: As you can see, implementing complex responsive behavior is a breeze with Chartist.
    Although our task management application was never meant to be a responsive web
    application, we can still benefit from this feature in order to optimize our content.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 Chartist 实现复杂的响应式行为非常简单。尽管我们的任务管理应用原本并不打算成为一个响应式网络应用，但我们仍然可以从中受益，以优化我们的内容。
- en: If I've tickled your fantasy with Chartist, I recommend that you check out the
    project's website at [http://gionkunz.github.io/chartist-js](http://gionkunz.github.io/chartist-js).
    On the website, you can also visit the live example page at [http://gionkunz.github.io/chartist-js/examples.html](http://gionkunz.github.io/chartist-js/examples.html),
    where you can hack some charts directly in the browser.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Chartist 激发了你的想象力，我建议你查看该项目的网站 [http://gionkunz.github.io/chartist-js](http://gionkunz.github.io/chartist-js)。在网站上，你还可以访问实时示例页面
    [http://gionkunz.github.io/chartist-js/examples.html](http://gionkunz.github.io/chartist-js/examples.html)，在那里你可以直接在浏览器中修改一些图表。
- en: Projects dashboard
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目仪表板
- en: 'In this chapter, we''ll create a projects dashboard, which will consist of
    the following components:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个项目仪表板，它将包括以下组件：
- en: '**Tasks chart**: This is where we''ll provide a visual overview on open tasks
    over time. All projects will be represented in a line chart that displays the
    progress of open tasks. We''ll also provide some user interaction so that the
    user can choose between different timeframes.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务图表**：我们将在这里提供关于随时间推移的开放任务的视觉概述。所有项目将以折线图的形式表示，显示开放任务的进度。我们还将提供一些用户交互，以便用户可以选择不同的时间段。'
- en: '**Activity chart**: This component visualizes activities in a bar chart over
    a timeframe of 24 hours. This will help our users quickly identify overall and
    peak project activities.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动图表**：该组件在 24 小时的时间范围内以柱状图的形式可视化活动。这将帮助我们的用户快速识别整体和峰值项目活动。'
- en: '**Project summary**: This is where we''ll display a summary of each project
    where we outline the most important facts. Our project summary component will
    also include an activity chart component that visualizes project activity.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目摘要**：这是我们展示每个项目摘要的地方，其中概述了最重要的信息。我们的项目摘要组件还将包括一个活动图表组件，用于可视化项目活动。'
- en: '**Projects dashboard**: This component is just a composition of the previous
    two components. This is our main component in the dashboard. It represents our
    dashboard page and is directly exposed to the router.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目仪表板**：这个组件只是前两个组件的组合。这是我们仪表板中的主要组件。它代表我们的仪表板页面，并直接暴露给路由器。'
- en: Creating the projects dashboard component
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目仪表板组件
- en: 'First, we''ll create our main dashboard component. The `ProjectsDashboard`
    component has only two responsibilities:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建我们的主仪表板组件。`ProjectsDashboard` 组件只有两个职责：
- en: Obtaining project data, which is used to create the dashboard
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取用于创建仪表板的项目数据
- en: Composing the main dashboard layout by including our dashboard subcomponents
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过包含我们的仪表板子组件来组合主仪表板布局
- en: 'Let''s jump right in and create a new component class on the path, `lib/projects-dashboard/projects-dashboard.js`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入并创建一个新的组件类，在路径 `lib/projects-dashboard/projects-dashboard.js` 上：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our `dashboard` component, we'll use the change observable of `ProjectService`
    directly. This is different to the usual way that we deal with observables. Usually,
    we'd subscribe to the observable in our component and then update our component
    whenever data streams through. However, in our projects dashboard, we're directly
    storing the change observable of `ProjectService` on our component.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `dashboard` 组件中，我们将直接使用 `ProjectService` 的变化可观察对象。这与我们通常处理可观察对象的方式不同。通常，我们会在组件中订阅可观察对象，并在数据流通过时更新我们的组件。然而，在我们的项目仪表板中，我们直接在我们的组件上存储
    `ProjectService` 的变化可观察对象。
- en: Now, we can use one of Angular's async core pipes in order to subscribe to the
    observable directly in our view.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 Angular 的一个异步核心管道来直接在我们的视图中订阅可观察对象。
- en: Exposing observables directly into the view and using the `async` pipe to subscribe
    to the observable comes with a main advantage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在视图中暴露可观察对象并使用 `async` 管道来订阅可观察对象带来主要优势。
- en: We don't need to deal with subscribing and unsubscribing in our component, as
    the `async` pipe will do that for us directly in the view.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在我们的组件中处理订阅和取消订阅，因为 `async` 管道将直接在视图中为我们完成这些操作。
- en: When a new value is emitted within the observable, the `async` pipe will cause
    the underlying binding to be updated. Also, if the view gets destroyed because
    of any reason, the `async` pipe will automatically unsubscribe from the observable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当在可观察对象中发出新值时，`async` 管道将导致底层绑定被更新。此外，如果视图因任何原因被销毁，`async` 管道将自动取消订阅可观察对象。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: By chaining RxJS operators together, we can bring an observable stream into
    the required shape without performing any subscription. Using the `async` pipe,
    we can then leave it up to the view to subscribe and unsubscribe from the transformed
    observable stream. This encourages us to write pure and stateless components,
    and when used correctly, this is a great practice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过链式使用 RxJS 操作符，我们可以在不执行任何订阅的情况下将可观察流转换为所需的形状。然后，使用 `async` 管道，我们可以让视图来订阅和取消订阅转换后的可观察流。这鼓励我们编写纯净和无状态的组件，并且当正确使用时，这是一种很好的实践。
- en: 'Let''s take a look at the view of our component created in the `projects-dashboard.html`
    file in the same directory as the `Component` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 `Component` 类所在的同一目录下的 `projects-dashboard.html` 文件中创建的组件视图：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see from the template that we use the `async` pipe to subscribe to the
    projects observable of our `Component` class. The `async` pipe will initially
    return `null`, but on any change in the observable, this will return the resolved
    value from the subscription. This means that we don't need to worry about subscribing
    to our project list observable. We can simply make use of the `async` pipe to
    subscribe and resolve directly in our view.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从模板中看到，我们使用 `async` 管道来订阅 `Component` 类的 `projects` 可观察对象。`async` 管道最初将返回
    `null`，但在任何可观察对象的变化时，这将返回订阅的解析值。这意味着我们不需要担心订阅我们的项目列表可观察对象。我们可以简单地利用 `async` 管道来订阅并在视图中直接解析。
- en: For the moment, we only displayed the project title and description, but in
    the next section, we will create a new project summary component that will deal
    with some more complex rendering.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只显示了项目标题和描述，但在下一节中，我们将创建一个新的项目摘要组件，该组件将处理一些更复杂的渲染。
- en: Project summary component
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目摘要组件
- en: In this section, we'll create a `project-summary` component that will provide
    some overview information for projects. Besides the title and description, this
    will also include an overview over the total efforts on the project tasks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个 `project-summary` 组件，该组件将为项目提供一些概述信息。除了标题和描述外，这还将包括对项目任务总努力的概述。
- en: Let's first build the component and make the necessary preparations so that
    we can display the total effort of the underlying tasks of the project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先构建组件并做好必要的准备，以便我们可以显示项目底层任务的总努力。
- en: 'We''ll start with the Component class on the `lib/projects-dashboard/project-summary/project-summary.js`
    path:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `lib/projects-dashboard/project-summary/project-summary.js` 路径上的 `Component`
    类开始：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you've probably already guessed, we reused the `EffortsTimeline` component
    that we created in the previous chapter. As our project summary will also include
    an efforts timeline, based on the same semantics as our total effort, there's
    no need to create a new component for this.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经猜到的，我们重用了在前一章中创建的 `EffortsTimeline` 组件。由于我们的项目摘要也将包括努力时间线，基于与总努力相同的语义，因此不需要为这个创建新的组件。
- en: What we need to do, though, is to accumulate all task efforts into an overall
    effort. Using the `Array.prototype.reduce` function, we can accumulate all task
    efforts relatively easy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要做的是将所有任务努力累积到一个整体努力中。使用 `Array.prototype.reduce` 函数，我们可以相对容易地累积所有任务努力。
- en: The resulting object from the reduce call needs to keep up with the format that
    is expected of an `efforts` object. As an initial value, we'll provide an `efforts`
    object with an estimated and effective time of zero. Then, the reduce callback
    will add any task effort values that are found in the project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 调用的结果对象需要符合预期的 `efforts` 对象的格式。作为初始值，我们将提供一个具有零估算时间和有效时间的 `efforts`
    对象。然后，`reduce` 回调将添加项目中的任何任务努力值。'
- en: 'Let''s look into the template to see how we''re going to use this total efforts
    data to display our `EffortsTimeline` component:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看模板，看看我们将如何使用这些总努力数据来显示我们的 `EffortsTimeline` 组件：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After displaying the title and description of the project, we included the `EffortsTimeline`
    component, which we bind to the `totalEfforts` member that we just constructed.
    This timeline will now display the total aggregated amount of efforts logged on
    the tasks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示项目的标题和描述后，我们包含了`EffortsTimeline`组件，并将其绑定到我们刚刚构建的`totalEfforts`成员。现在，这个时间线将显示在任务上记录的总聚合工作量。
- en: In addition to the timeline, we also rendered a formatted efforts text, such
    as the one that we already rendered in the `Efforts` component of the previous
    chapter. For this, we used the `FormatEffortsPipe` pipe.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了时间线之外，我们还渲染了格式化的努力文本，就像我们在上一章的`Efforts`组件中已经渲染的那样。为此，我们使用了`FormatEffortsPipe`管道。
- en: Now, what's still left to do is to integrate our `ProjectSummary` component
    into the `ProjectsDashboard` component.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要做什么呢？将我们的`ProjectSummary`组件集成到`ProjectsDashboard`组件中。
- en: 'Let''s look at the template modification in the `projects-dashboard.html` component
    template:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`projects-dashboard.html`组件模板中的模板修改：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see that we bind the `project` local view variable, which was created
    by the `NgFor` directive in conjunction with the `async` pipe, to the `project`
    input property of our `ProjectSummary` component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们将由`NgFor`指令与`async`管道一起创建的`project`局部视图变量绑定到`ProjectSummary`组件的`project`输入属性。
- en: We also used the `RouterLink` directive to establish the navigation onto the
    `ProjectDetails` view if the user clicks on one of the summary tiles.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`RouterLink`指令来在用户点击其中一个摘要磁贴时导航到`ProjectDetails`视图。
- en: 'The modifications in the `ProjectsDashboard` component class are negligible:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProjectsDashboard`组件类中的修改微乎其微：'
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The only modification that we applied to the `Component` class was to add the
    `ProjectSummary` component and the `ROUTER_DIRECTIVES` constant to the directives
    list of the component. The `ROUTER_DIRECTIVES` constant includes the `RouterOutlet`
    and `RouterLink` directives, and we use the latter in our template.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`Component`类所做的唯一修改是将`ProjectSummary`组件和`ROUTER_DIRECTIVES`常量添加到组件的指令列表中。`ROUTER_DIRECTIVES`常量包括`RouterOutlet`和`RouterLink`指令，我们在模板中使用后者。
- en: '![Project summary component](img/image00343.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![项目摘要组件](img/image00343.jpeg)'
- en: A projects dashboard displaying two project summary components with the aggregated
    total effort
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 显示两个项目摘要组件和聚合总工作量的项目仪表板
- en: Okay, so far so good. We created two new components and reused our `EffortsTimeline`
    component to create an aggregated view on the tasks efforts. In the next section,
    we will enrich our `ProjectSummary` component with a nice Chartist chart.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止一切顺利。我们创建了两个新的组件，并重用了我们的`EffortsTimeline`组件来创建任务工作量的聚合视图。在下一节中，我们将用漂亮的Chartist图表丰富我们的`ProjectSummary`组件。
- en: Creating your first chart
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个图表
- en: In this section, we will create our first chart using Chartist to provide a
    project activity overview over the past 24 hours. This bar chart will only provide
    some visual clues about the project activity, and our goal is not to make it provide
    detailed information. For this reason, we will configure it to hide any labels,
    scales, and grid lines. The only visible part should be the bars of the bar chart.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Chartist创建我们的第一个图表，以在过去24小时内提供项目活动概览。这个柱状图将只提供一些关于项目活动的视觉线索，我们的目标不是让它提供详细信息。因此，我们将配置它隐藏任何标签、刻度和网格线。唯一可见的部分应该是柱状图的柱子。
- en: Before we start creating the activity chart itself, we need to look at how we
    need to transform and prepare our data for the charts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始创建活动图表之前，我们需要看看我们需要如何转换和准备我们的数据以供图表使用。
- en: Let's look at what data we already have in our system. As far as the activities
    go, they all have a timestamp on them stored in the `time` field. However, for
    our chart, we want something else displayed. What we're looking for is a chart
    that displays one bar for each hour of the past 24 hours. Each bar should represent
    the count of activities in that timeframe.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们系统中已有的数据。就活动而言，它们都在`time`字段上有一个时间戳。然而，对于我们的图表，我们希望显示其他内容。我们正在寻找的是显示过去24小时内每个小时的图表，每个柱子代表该时间段的活动数量。
- en: 'The following illustration shows our source data, which is basically a time
    stream of activity events. On the lower arrow, we see the data that we need to
    end up with for our chart:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图显示了我们的源数据，它基本上是一系列活动事件的时序流。在下面的箭头中，我们看到我们需要用于我们图表的数据：
- en: '![Creating your first chart](img/image00344.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![创建你的第一个图表](img/image00344.jpeg)'
- en: An illustration displaying activities as a time stream where the dots represent
    activities. The lower arrow is showing a rasterized count by hour for the last
    24 hours.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显示活动作为时间流的插图，其中点代表活动。下方的箭头显示了过去24小时的按小时光栅化计数。
- en: 'Let''s implement a function that does the transformation outlined in this image.
    We''ll add this function to our `time-utilities` module on the `lib/utilities/time-utilities.js`
    path:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个执行图中概述的转换的函数。我们将把这个函数添加到我们的`time-utilities`模块上的`lib/utilities/time-utilities.js`路径：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s look at the input parameters of our newly-created function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们新创建的函数的输入参数：
- en: '`timeData`: This parameter is expected to be an array of objects that contains
    a `time` property that is set to the timestamp of the event that should be counted.
    The objects should also contain a `weight` property, which is used to count. Using
    this property, we can count one event as two or even count minus values to decrease
    the count in a raster.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeData`: 此参数预期是一个包含一个`time`属性的对象数组，该属性设置为应计数的事件的戳记。对象还应包含一个`weight`属性，用于计数。使用此属性，我们可以将一个事件计为两个，甚至可以计负值以减少光栅中的计数。'
- en: '`timeFrame`: This parameter specifies the time span of each raster in milliseconds.
    If we want to have 24 rasterized frames, each consisting of one hour this parameter
    needs to be set to 3,600,000 (1 h = 60 min = 3,600 s = 3,600,000 ms).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeFrame`: 此参数指定每个光栅的时间跨度（以毫秒为单位）。如果我们想有24个光栅化帧，每个帧包含一小时，则此参数需要设置为3,600,000（1小时=60分钟=3,600秒=3,600,000毫秒）。'
- en: '`quantity`: This parameter sets the amount of rasterized frames that should
    be present in the output array. In the case of 24 frames of one hour, this parameter
    should be set to 24.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity`: 此参数设置输出数组中应存在的光栅化帧的数量。在24帧一小时的案例中，此参数应设置为24。'
- en: '`now`: This is when our function is rasterizing time, starting at a given point
    in time backwards. The `now` parameter sets this point in time.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`now`: 这是我们函数在给定时间点向后光栅化时间的时候。`now`参数设置这个时间点。'
- en: '`fill`: This is how we can specify how we''d like our rasterized output array
    to be initialized. In the case of our activity counts, we want this to be set
    to `0`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill`: 这是我们指定如何初始化我们的光栅化输出数组的方式。在我们的活动计数的情况下，我们希望将其设置为`0`。'
- en: The function that we just created is necessary to create the activity chart.
    The transformation helps us prepare project activities for the input data of the
    chart.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的函数对于创建活动图表是必要的。这个转换帮助我们为图表的输入数据准备项目活动。
- en: 'It''s time to create our first chart component! Let''s start with a new template
    created on the `lib/projects-dashboard/project-summary/activity-chart/activity-chart.html`
    path:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建我们的第一个图表组件了！让我们从在`lib/projects-dashboard/project-summary/activity-chart/activity-chart.html`路径上创建的新模板开始：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we leave all the rendering up to Chartist, this is actually already all that
    we need. Chartist needs an element as a container to create the chart in. We set
    a `chartContainer` local view reference so that we can reference it from our component,
    and then pass it to Chartist.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将所有渲染都交给Chartist，这实际上已经是我们需要的一切。Chartist需要一个元素作为容器来创建图表。我们设置一个`chartContainer`本地视图引用，以便我们可以从我们的组件中引用它，然后将其传递给Chartist。
- en: 'Let''s move on with the chart creation, and flesh out the activity chart component
    by creating the `Component` class in `activity-chart.js` in the same directory
    as the template:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建图表，通过在模板相同的目录下创建`activity-chart.js`中的`Component`类来完善活动图表组件：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Chartist is available for almost all package managers, and it also comes bundled
    in the **UMD** module format (**Universal Module Format**), which, in fact, is
    a wrapper to enable **AMD** (**Asynchronous Module Definition**), CommonJS module
    format, and global export.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Chartist适用于几乎所有包管理器，并且它还以**UMD**模块格式（**通用模块格式**）捆绑提供，实际上这是一个包装器，用于启用**AMD**（**异步模块定义**）、CommonJS模块格式和全局导出。
- en: 'Using JSPM, we can simply install Chartist by executing the following command
    on the command line:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSPM，我们可以在命令行上执行以下命令来简单地安装Chartist：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After installing Chartist, we can directly import it using ES6 module syntax.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Chartist后，我们可以直接使用ES6模块语法导入它。
- en: We also import the rasterize function that we created so that we can use it
    later to convert our activities into the expected input format for our chart.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入了我们创建的光栅化函数，以便我们可以稍后使用它将我们的活动转换为图表预期的输入格式。
- en: As we rely on a view child as a container element to create our chart, we need
    to wait for the `AfterViewInit` lifecycle hook in order to construct the chart.
    At the same time, we need to rerender the chart if the input `activities` change.
    Using the `OnChanges` lifecycle hook, we can react on input changes and update
    our chart.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们依赖于视图子元素作为容器元素来创建我们的图表，我们需要等待`AfterViewInit`生命周期钩子来构建图表。同时，如果输入的`activities`发生变化，我们还需要重新渲染图表。使用`OnChanges`生命周期钩子，我们可以对输入变化做出反应并更新我们的图表。
- en: 'Let''s now look at the `createOrUpdateChart` function, which does exactly what
    its name already implies:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`createOrUpdateChart`函数，它确实如其名称所暗示的那样：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s look into the code in more detail and walk through it step by step:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看代码，并一步一步地走一遍：
- en: As we get called both from the `AfterViewInit` and `OnChanges` lifecycle, we
    need to make sure that both the `chartContainer` and `activities` inputs are ready
    before we continue.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们既从`AfterViewInit`又从`OnChanges`生命周期中被调用，我们需要确保在继续之前`chartContainer`和`activities`输入都已就绪。
- en: Now, it's time to convert the activity data that we receive as input into the
    rasterized form that is required for the chart that we'd like to create. We use
    `Array.prototype.map` to transform our activities into the `timeData` objects
    that are required by the `rasterize` function. We also pass the necessary parameters
    so that the function will rasterize into 24 frames, each consisting of one hour.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，是我们将接收到的活动数据转换为所需的栅格化形式的时候了，这是我们想要创建的图表所需的。我们使用`Array.prototype.map`将我们的活动转换为`timeData`对象，这些对象是`rasterize`函数所需的。我们还传递必要的参数，以便函数将栅格化到24帧，每帧包含一小时。
- en: If the `chart` member is already set to a chart that was previously created,
    we can use the `update` function on the Chartist chart object to only update with
    the new data.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`chart`成员已经设置为之前创建的图表，我们可以使用Chartist图表对象的`update`函数来仅用新数据更新。
- en: If there's no chart object already, we need to create a new chart. As a first
    parameter to the `Chartist.Bar` constructor, we'll pass the DOM element reference
    of our container view child. Chartist will create our chart in this container
    element. The second argument is our data, which we fill with the series that was
    just generated. In the chart options, we'll set everything to achieve a very plain-looking
    chart without any detailed information.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果还没有图表对象，我们需要创建一个新的图表。作为`Chartist.Bar`构造函数的第一个参数，我们将传递容器视图子元素的DOM元素引用。Chartist将在该容器元素中创建我们的图表。第二个参数是我们的数据，我们将用刚刚生成的系列填充它。在图表选项中，我们将设置一切以实现一个非常简单的图表，没有任何详细信息。
- en: 'This is great! We created our first chart component using Chartist! Now, we
    can go back to our `ProjectSummary` component and integrate the activity chart
    there to provide an activity overview:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！我们使用Chartist创建了第一个图表组件！现在，我们可以回到我们的`ProjectSummary`组件，并在其中集成活动图表以提供活动概述：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first change here is to include the `ActivityService` so that we can extract
    the required project activities to pass them to the `ActivityChart` component.
    We also need to import the `ActivityChart` component and declare it as a directive
    on the component.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个变化是包含`ActivityService`，这样我们就可以提取所需的计划活动并将它们传递给`ActivityChart`组件。我们还需要导入`ActivityChart`组件，并在组件中将其声明为指令。
- en: As our component relies on the project to be provided as input, which is subject
    to change, we need to implement the logic to extract activities in the `OnChanges`
    lifecycle hook of the component.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的组件依赖于作为输入提供的项目，该项目可能会发生变化，因此我们需要在组件的`OnChanges`生命周期钩子中实现提取活动的逻辑。
- en: Before we pass on the observable activities stream, we need to filter the activities
    that come through the stream so that we only get activities that are relevant
    to the current project. Again, we will use the `async` pipe in order to subscribe
    to the activities so that there's no need to use a subscribe form within the component.
    The `activities` property will be directly set to a filtered `Observable`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将活动流传递之前，我们需要过滤通过流来的活动，以便我们只得到与当前项目相关的活动。我们还将使用`async`管道来订阅活动，这样就不需要在组件中使用`subscribe`形式。`activities`属性将直接设置为过滤后的`Observable`。
- en: 'Let''s look at the changes in the view of the `ProjectSummary` component in
    order to enable our chart:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ProjectSummary`组件视图中的变化，以便启用我们的图表：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We add our `ActivityChart` component at the bottom of the already existing template.
    We also create the necessary binding to pass our activities into the component.
    Using the `async` pipe, we can resolve the observable stream and pass the filtered
    activities list into the `chart` component.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在现有模板的底部添加我们的`ActivityChart`组件。我们还创建了必要的绑定，将我们的活动传递到组件中。使用`async`管道，我们可以解析可观察的流并将过滤后的活动列表传递到`chart`组件中。
- en: Finally, our `ProjectSummary` component looks great and immediately provides
    a project insight by displaying the aggregated efforts timeline and a nice activity
    chart. In the next section, we'll dive a bit deeper into the charting capabilities
    of Chartist, and we will also provide some interactivity using Angular.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`ProjectSummary`组件看起来很棒，并立即通过显示聚合的努力时间线和漂亮的活动图表来提供项目洞察。在下一节中，我们将更深入地探讨Chartist的图表功能，并且我们还将使用Angular提供一些交互性。
- en: Visualizing open tasks
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化打开的任务
- en: In this section, we will create a chart component using Chartist, which will
    display the open task progress of projects over time. To do this, we'll use a
    line chart with a specific interpolation that provides quantized steps rather
    than lines with directly connected points.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Chartist创建一个图表组件，该组件将显示项目随时间推移的打开任务进度。为此，我们将使用具有特定插值的折线图，该插值提供量化步骤而不是直接连接点的线条。
- en: We are also providing some interactivity in that the user will be able to switch
    the displayed time frame using a toggle button. This allows us to reuse the `Toggle`
    component that we created in [Chapter 2](part0020.xhtml#aid-J2B81 "Chapter 2. Ready,
    Set, Go!"), *Ready, Set, Go!,* of this book.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一些交互性，用户将能够使用切换按钮切换显示的时间范围。这允许我们重用我们在本书第2章[“准备，出发，行动！”](part0020.xhtml#aid-J2B81
    "第2章。准备，出发，行动！")中创建的`Toggle`组件。
- en: Let's first look at the data that we have in our system and how we can transform
    it into the data needed by Chartist.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们系统中有的数据以及我们如何将其转换成Chartist所需的数据。
- en: We can rely on two data attributes of our tasks in order to draw them onto a
    timeline. The `created` attribute is set to the timestamp at the moment when the
    task was created. If a task is marked as done, the `done` attribute is set to
    the timestamp at that time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以依靠我们的任务的两个数据属性来将它们绘制到时间线上。`created`属性设置为任务创建时的戳记。如果任务被标记为完成，则`done`属性设置为那个时间的时间戳。
- en: 'As we''re only interested in the amount of open tasks at any given time, we
    can safely presume a model where we put all tasks onto a single timeline and where
    we are only concerned about the `created` and `done` timestamps as events. Let''s
    look at the following illustration to get a better understanding of the problem:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只对任何给定时间的打开任务数量感兴趣，我们可以安全地假设一个模型，其中我们将所有任务放在单个时间线上，并且我们只关心作为事件的`created`和`done`时间戳。让我们看看以下插图以更好地理解问题：
- en: '![Visualizing open tasks](img/image00345.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![可视化打开的任务](img/image00345.jpeg)'
- en: An illustration that shows how we can represent all task timelines on a single
    timeline using the created and done events. The created events count as a +1,
    while the done events count as -1.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个插图展示了我们如何使用创建和完成事件在单个时间线上表示所有任务的时间线。创建事件计为+1，而完成事件计为-1。
- en: The lower arrow is a representation of all tasks of the `created` and `done`
    events on a timeline. We can now use this information as input to our `rasterize`
    function in order to get the data that we need for our chart. As the `timeData`
    objects that are used as input for the rasterization also support a `weight` property,
    we can use this to represent the `created (+1)` or `done (-1)` events.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下箭头表示时间线上所有`created`和`done`事件的任务。现在我们可以使用这些信息作为输入到我们的`rasterize`函数中，以获取我们图表所需的数据。由于用作光栅化的输入的`timeData`对象也支持`weight`属性，我们可以使用它来表示`created
    (+1)`或`done (-1)`事件。
- en: We need to make a slight modification to our rasterize function. So far, the
    rasterize function only counts events together in frames. However, for the open
    task counts, we look into an accumulation over time. If the task count changes,
    we need to keep the value until it changes again. In transformation of activities
    in the previous topic, we didn't use this same logic. There, we only counted events
    inside frames, but there was no accumulation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对我们的rasterize函数进行轻微的修改。到目前为止，rasterize函数只按帧将事件一起计数。然而，对于打开的任务计数，我们查看时间上的累积。如果任务计数发生变化，我们需要保持该值直到它再次变化。在前面主题中活动转换时，我们没有使用这种相同的逻辑。在那里，我们只计算帧内的事件，但没有累积。
- en: 'Let''s look at the following illustration to see the difference as compared
    to the rasterization that we applied while processing activities:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下插图，以了解与我们在处理活动时应用的光栅化相比的差异：
- en: '![Visualizing open tasks](img/image00346.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![可视化开放任务](img/image00346.jpeg)'
- en: An illustration that shows how we can accumulate the open tasks count over time
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个说明我们如何随时间累积开放任务计数的插图
- en: We can count each `weight` property of the `timeData` objects (events) together
    over time. Only if there's a change of the accumulated value, we will write the
    current accumulated value into the rasterized output array.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随时间一起计算`timeData`对象（事件）的每个`weight`属性。只有当累积值发生变化时，我们才会将当前的累积值写入光栅化输出数组。
- en: 'Let''s open our `time-utilities` module and apply the changes to the `rasterize`
    function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们的`time-utilities`模块，并将更改应用到`rasterize`函数：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s walk through the changes that we applied to the `rasterize` function
    to allow accumulation of frames:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们对`rasterize`函数所做的更改，以允许累积框架：
- en: First of all, we added a new parameter to our function with the name `accumulate`.
    We used the ES6 default parameters to set the parameter to `false` if no value
    was passed into the function when called.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们在函数中添加了一个名为`accumulate`的新参数。我们使用ES6默认参数来设置当函数被调用而没有传入值时参数为`false`。
- en: We now define a new `accumulatedValue` variable, which we initialize with `0`.
    This variable will be used to keep track of the sum of all `weight` values over
    time.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在定义了一个新的`accumulatedValue`变量，并将其初始化为`0`。这个变量将用于跟踪随时间所有`weight`值的总和。
- en: The next bit of code is very important. If we want to accumulate the sum of
    all `weight` values over time, we need to make sure that these values come in
    sequence. In order to ensure this, we sort the `timeData` list by its items `time`
    attribute.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一段代码非常重要。如果我们想随时间累积所有`weight`值的总和，我们需要确保这些值按顺序到来。为了确保这一点，我们按`timeData`列表的`time`属性对它进行排序。
- en: In the `reduce` callback, we increase the `accumulatedValue` variable by the
    `weight` value of the current `timeData` object.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`reduce`回调中，我们将当前`timeData`对象的`weight`值增加到`accumulatedValue`变量上。
- en: If the `timeData` object falls into a rasterized frame, we do not increase this
    frame's count like we did before. In accumulation mode, we set the frames count
    to the current value in `accumulatedValue`. This will result in all changed accumulated
    values being reflected in the rasterized output array.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`timeData`对象落入一个光栅化框架中，我们不会像之前那样增加这个框架的计数。在累积模式下，我们将框架计数设置为`accumulatedValue`中的当前值。这将导致所有变化的累积值都反映在光栅化输出数组中。
- en: This is all the preparation that we need to process the date in order to render
    our open tasks chart. Let's move on and create the `Component` class of our new
    `chart` component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们处理数据以渲染我们的开放任务图表所需的所有准备工作。让我们继续前进，创建我们新的`chart`组件的`Component`类。
- en: Creating an open tasks chart
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建开放任务图表
- en: In the following component, we will utilize the refactored `rasterize` function
    of the previous topic. Using the new accumulate function, we can now track open
    task counts over time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下组件中，我们将利用之前主题中重构的`rasterize`函数。使用新的累积函数，我们现在可以跟踪随时间变化的开放任务计数。
- en: 'Let''s start with the `Component` class in a new `lib/projects-dashboard/tasks-chart/tasks-chart.js`
    file to implement our `Component` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从新文件`lib/projects-dashboard/tasks-chart/tasks-chart.js`中的`Component`类开始，以实现我们的`Component`类：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So far, this looks exactly like our first `chart` component where we visualized
    project activities. We also imported Chartist as we will use it to render our
    chart in the `createOrUpdateChart` function that we'll create shortly. The chart
    that we will create will contain much more detailed information. We will render
    both axis labels and some scales. In order to format our labels that basically
    contain timestamps, we use the Moment.js library once again.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这看起来就像我们的第一个`chart`组件，我们在其中可视化了项目活动。我们也导入了Chartist，因为我们将在不久后创建的`createOrUpdateChart`函数中使用它来渲染我们的图表。我们将创建的图表将包含更多详细的信息。我们将渲染轴标签和一些刻度。为了格式化基本上包含时间戳的标签，我们再次使用Moment.js库。
- en: We also use the `projects` input data and transform it with the amended `rasterize`
    utility function in order to prepare all the data for our line chart.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`projects`输入数据，并通过修改后的`rasterize`实用函数对其进行转换，以便为我们的折线图准备所有数据。
- en: 'Let''s move on and flesh out the `createOrUpdateChart` method of our component:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续完善组件的`createOrUpdateChart`方法：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Okay, that''s quite a bit of code here. Let''s walk through it step by step
    to gain a better understanding of what''s going on:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里有很多代码。让我们一步一步地走一遍，以便更好地理解正在发生的事情：
- en: First, we need to create our transformed series data by mapping the projects
    list. The series array should include one data array for each project. Each data
    array will contain the open project tasks over time.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要通过映射项目列表来创建我们的转换后的系列数据。系列数组应该包括每个项目的数据数组。每个数据数组将包含随时间变化的开放项目任务。
- en: As the `rasterize` function expects a list of `timeData` objects, we first need
    to transform the projects task list into this format. By reducing the task list,
    we create a single list of the `timeData` objects. The `reduce` function callback
    will generate one `timeData` object with a `weight` of 1 for each task. Additionally,
    it will generate a `timeData` object for each task marked as one with the `weight`
    value -1\. This will result in the desired `rimeData` array, which we can use
    to accumulate and rasterize.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`rasterize`函数期望一个`timeData`对象的列表，我们首先需要将项目任务列表转换成这种格式。通过减少任务列表，我们创建了一个包含单个`timeData`对象的列表。`reduce`函数回调将为每个任务生成一个具有`weight`值为1的`timeData`对象。此外，它将为标记为具有`weight`值-1的每个任务生成一个`timeData`对象。这将产生所需的`timeData`数组，我们可以使用它来累积和光栅化。
- en: After preparing the `timeData` list, we can call the `rasterize` function in
    order to create a list of open tasks over a certain amount of timeframes. We use
    a 10 minute timeframe (600000ms) and rasterize this with 144 frames. This makes
    a total of 24 hours.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在准备完`timeData`列表后，我们可以调用`rasterize`函数来创建一定时间段内的开放任务列表。我们使用10分钟的时间段（600000毫秒）并使用144帧进行光栅化。这总共是24小时。
- en: Besides the series data, we will also need labels for our chart. We create a
    new array and initialize this with 144 timestamps, all of which are set to the
    start of the 144 rasterized frames that we display on the chart.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了系列数据外，我们还需要为我们的图表提供标签。我们创建了一个新的数组，并用144个时间戳初始化这个数组，所有这些时间戳都设置为显示在图表上的144个光栅化帧的开始。
- en: Now, we have the series data and the labels ready, and all that's left to do
    is to render our chart.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了系列数据和标签，接下来要做的就是渲染我们的图表。
- en: Using the `lineSmooth` configuration, we can specify a special kind of interpolation
    for our line chart. The step interpolation will not connect each point in our
    line chart directly, but rather it will move in discrete steps to move from point
    to point. This is exactly what we're looking for to render the open task counts
    over time.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lineSmooth`配置，我们可以为我们的折线图指定一种特殊的插值。步进插值不会直接连接我们折线图中的每个点，而是会以离散的步骤从一个点到另一个点移动。这正是我们渲染开放任务随时间变化所需的方法。
- en: Setting the `fillHoles` option to `true` in the step interpolation is very important.
    Using this setting, we can actually tell Chartist that it should close any gaps
    within the data (actually null values) and connect the line to the next valid
    value. Without this setting, we'd see gaps on the chart between the task count
    changes in our data arrays.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤插值中将`fillHoles`选项设置为`true`非常重要。使用此设置，我们实际上可以告诉Chartist它应该关闭数据（实际上为null值）中的任何间隙，并将线条连接到下一个有效值。如果没有此设置，我们会在数据数组中的任务计数变化之间在图表上看到间隙。
- en: One last important thing in our code is the `labelInterpolationFnc` option that
    we set on the *x* axis configuration. This function can not only be used to format
    a label or interpolate any expression that may come along with the label, but
    it also allows us to return null instead. Returning null from this function will
    cause Chartist to skip the given label and the corresponding grid line. This is
    very useful if we'd like to skip certain labels by their value or by the index
    of the label. In our code, we ensure that we only render four labels of all 144
    generated labels.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的代码中，最后一项重要的事情是在*x*轴配置上设置的`labelInterpolationFnc`选项。此函数不仅可以用来格式化标签或插值可能伴随的任何表达式，而且还允许我们返回null。从这个函数返回null将导致Chartist跳过给定的标签和相应的网格线。如果我们想通过值或标签的索引跳过某些标签，这将非常有用。在我们的代码中，我们确保只渲染所有144个生成的标签中的四个。
- en: 'Let''s take a look at the rather simple template of our component in the `tasks-chart.html`
    file in the same folder as our `Component` class file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们组件在`tasks-chart.html`文件中的相对简单的模板，这个文件与我们的`Component`类文件位于同一文件夹中：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The same as with the `ActivityChart` component, we only create a simple chart
    container element, which we already reference in our `Component` class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ActivityChart`组件类似，我们只创建了一个简单的图表容器元素，这个元素我们已经在`Component`类中引用。
- en: 'This is basically all that we needed to do in order to create an open tasks
    chart using Chartist. However, there''s still some room for improvement here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是我们创建使用Chartist的开放任务图表所需做的所有事情。然而，这里还有一些改进的空间：
- en: '![Creating an open tasks chart](img/image00347.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个开放任务图表](img/image00347.jpeg)'
- en: Open tasks visualized with our tasks chart component using Chartist's step interpolation
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的任务图表组件和Chartist的步进插值可视化开放任务
- en: Creating a chart legend
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建图表图例
- en: Currently, there's no way to tell exactly which of the lines represents what
    project. We see one colored line for each project, but we can't associate these
    colors. What we need is a simple legend that helps our users to associate line
    chart colors to projects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们无法确切知道哪条线代表哪个项目。我们能看到每个项目有一条彩色线，但我们无法将这些颜色关联起来。我们需要的是一个简单的图例，帮助我们的用户将折线图的颜色与项目关联起来。
- en: 'Let''s look at the required code changes to implement legends on our chart.
    In the `Component` class of our `TasksChart` component, we need to perform the
    following modifications:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现图例所需的代码更改。在我们的`TasksChart`组件的`Component`类中，我们需要执行以下修改：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `OnChanges` lifecycle hook, we map the projects input to a list of objects
    that contain a `name` and `class` property, which will support us in rendering
    a simple legend. The template `` `tasks-chart__series--series-${index + 1}` ``
    string will generate the necessary class name to render the right color into our
    legend.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnChanges`生命周期钩子中，我们将项目输入映射到一个包含`name`和`class`属性的对象列表中，这将支持我们在图例中渲染简单的图例。模板字符串``tasks-chart__series--series-${index
    + 1}``将生成渲染图例中正确颜色的必要类名。
- en: 'Using this legend information, we can now go ahead and implement the necessary
    template changes to render the legend in our `chart` component:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个图例信息，我们现在可以继续实施必要的模板更改，以在我们的`chart`组件中渲染图例：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Well, that was a piece of cake, right? However, the result speaks for itself.
    We created a nice legend for the chart in just a couple of minutes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这很简单，对吧？然而，结果证明了一切。我们仅用几分钟就为图表创建了一个漂亮的图例：
- en: '![Creating a chart legend](img/image00348.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![创建图表图例](img/image00348.jpeg)'
- en: Open tasks chart with our added legend
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 带有我们添加的图例的开放任务图表
- en: Making tasks chart interactive
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使任务图表交互式
- en: Currently, we hardcoded the timeframe of our open task chart to be 144 frames,
    each of 10 minutes, making a total of 24 hours displayed to the user. However,
    maybe our users would want to change this view.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们硬编码了开放任务图表的时间范围为144帧，每帧10分钟，总共显示给用户24小时。然而，也许我们的用户想要改变这个视图。
- en: In this topic, we will create a simple input control using our `Toggle` component,
    which allows our users to change the timeframe settings of the chart.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将使用我们的`Toggle`组件创建一个简单的输入控制，允许我们的用户更改图表的时间范围设置。
- en: 'We will provide the following views as options:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供以下视图作为选项：
- en: '**Day:** This view will rasterize 144 frames, each consisting of 10 minutes,
    which makes a total of 24 hours'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日：**这个视图将渲染144帧，每帧10分钟，总共24小时'
- en: '**Week:** This view will rasterize 168 frames, each consisting of one hour,
    which makes a total of seven days'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周：**这个视图将渲染168帧，每帧一小时，总共七天'
- en: '**Year:** This view will rasterize 360 frames, each representing a full day'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**年：**这个视图将渲染360帧，每帧代表一整天'
- en: 'Let''s start with the implementation of our timeframe switch by modifying the
    `Component` class code of the `TasksChart` component:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修改`TasksChart`组件的`Component`类代码开始，实现我们的时间范围切换功能：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s go through these changes briefly:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地回顾一下这些更改：
- en: First of all, we added a constructor to our `Component` class in which we initialized
    three new members. The `timeFrames` member is set to an array of timeframe description
    objects. They contain the `name`, `timeFrame`, and `amount` properties, which
    are later used for the calculations. The `timeFrameNames` member contains a list
    of timeframe names, which is directly derived from the `timeFrames` list. Finally,
    we have a `selectedTimeFrame` member, which simply points to the first available
    timeframe object.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在`Component`类中添加了一个构造函数，在其中初始化了三个新的成员。`timeFrames`成员被设置为时间范围描述对象数组。它们包含`name`、`timeFrame`和`amount`属性，这些属性随后用于计算。`timeFrameNames`成员包含时间范围名称列表，该列表直接从`timeFrames`列表派生。最后，我们有一个`selectedTimeFrame`成员，它简单地指向第一个可用的时间范围对象。
- en: In the `createOrUpdateChart` function, we no longer rely on hardcoded values
    for the task count rasterization, but we refer to the data in the `selectedTimeFrame`
    object. By changing this object reference and calling the `createOrUpdateChart`
    function again, we can now switch the view on the underlying data dynamically.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`createOrUpdateChart`函数中，我们不再依赖于硬编码的任务计数光栅化值，而是引用`selectedTimeFrame`对象中的数据。通过更改此对象引用并再次调用`createOrUpdateChart`函数，我们现在可以动态地切换底层数据的视图。
- en: Finally, we added a new `onSelectedTimeFrameChange` method, which acts as a
    binding to the `Toggle` component, and this will be called whenever the user selects
    a different timeframe.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个新的`onSelectedTimeFrameChange`方法，它作为对`Toggle`组件的绑定，并且将在用户选择不同的时间范围时被调用。
- en: 'Let''s look at the necessary template changes to enable switching of timeframes:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看必要的模板更改，以启用时间范围的切换：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From the bindings to the `Toggle` component, you can already tell that we rely
    on the `timeFrameNames` member on our component to represent all selectable timeframes.
    We also bind to the `selectedButton` input property of the `Toggle` component
    using the `selectedTimeFrame.name` property. On changes of the selected button
    in the `Toggle` component, we call the `onSelectedTimeFrameChange` function, where
    the timeframe is switched and the chart is updated.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从绑定到`Toggle`组件，你可以看出我们依赖于组件上的`timeFrameNames`成员来表示所有可选的时间范围。我们还使用`selectedTimeFrame.name`属性绑定到`Toggle`组件的`selectedButton`输入属性。当`Toggle`组件中选定的按钮发生变化时，我们调用`onSelectedTimeFrameChange`函数，在那里时间范围被切换，图表被更新。
- en: This is all that we need to enable switching the timeframe on our chart. The
    user can now choose between the year, week, and day views.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要的一切，以启用在图表上切换时间范围。现在用户可以选择按年、周和日查看。
- en: 'Our `TasksChart` component is now ready to be integrated into our dashboard.
    We can achieve this with some small changes to the template of our `ProjectsDashboard`
    component:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`TasksChart`组件现在已准备好集成到我们的仪表板中。我们可以通过修改`ProjectsDashboard`组件的模板来实现这一点：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is basically all that we need to make, and after this change, our dashboard
    contains our nice chart displaying open task counts over time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是我们需要做的所有事情，在此更改之后，我们的仪表板包含了一个显示随时间推移的开放任务计数的漂亮图表。
- en: In the binding of the `TasksChart` projects input property, we use the `async`
    pipe once again to resolve the observable stream of projects directly in the view.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TasksChart`项目输入属性的绑定中，我们再次使用`async`管道直接在视图中解析项目观察流。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Chartist and how to use it in conjunction
    with Angular to create good looking and functional charts. We can leverage the
    power of both worlds, and create reusable chart components that are nicely encapsulated.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Chartist及其如何与Angular结合使用来创建外观美观且功能齐全的图表。我们可以利用两个世界的力量，创建可重用的封装良好的图表组件。
- en: Just like in most real cases, we always have a lot of data, but the one that
    we need in a particular case. We learned how we can transform existing data into
    a form that is optimized for visual representation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在大多数实际案例中一样，我们总是有很多数据，但在特定情况下我们只需要其中一部分。我们学习了如何将现有数据转换成适合视觉表示的形式。
- en: In the next chapter, we will look at building a plugin system in our application.
    This will allow us to develop portable functionality that is packaged into plugins.
    Our plugin system will load new plugins dynamically, and we will use it to develop
    a simple agile estimation plugin.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在应用程序中构建插件系统。这将允许我们开发打包成插件的便携式功能。我们的插件系统将动态加载新插件，我们将使用它来开发一个简单的敏捷估算插件。
