- en: Working with Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a gateway and two microservices using JHipster;
    now, let's see how we can further develop our microservices to include our domain
    model and additional business logic. Since we are converting our online shop monolith
    to a microservice architecture, we will see how the domain model we created using
    JDL can be converted into a microservice domain model. But before we can start,
    we need to set up some tools in order to work with microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in this chapter, we will see the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to set up JHipster Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run the microservice setup locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the domain model using JDL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating the domain model in JHipster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up JHipster Registry locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created our gateway and two microservice applications. The microservices
    have two different databases. So far, it has been easy and simple to create those
    with JHipster.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster provides two different options we have previously seen, Consul and
    JHipster Registry. For our use case, let's go with JHipster Registry. We have
    already learned about JHipster Registry in [Chapter 8](673932d7-7927-4a12-8c02-86197cc8d3aa.xhtml), *Introduction
    to Microservice Server-Side Technologies.* Now, we will see how to set up and
    start it in our local development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now, these three services basically act as Eureka clients. We need a service
    registry that registers and deregisters the application as and when the application
    is started and stopped, respectively; this is JHipster Registry. The Eureka server
    (JHipster Registry server) acts as a master to all the Eureka clients.
  prefs: []
  type: TYPE_NORMAL
- en: Since JHipster Registry, as the name suggests, acts as a registry service, all
    microservice applications and the gateway will register/deregister themselves
    when the application starts and stops.
  prefs: []
  type: TYPE_NORMAL
- en: Let's recap a little bit of what we learned already. The JHipster Registry is
    made up of a Eureka server and Spring Cloud Config server and they help in the
    following
  prefs: []
  type: TYPE_NORMAL
- en: '**The Eureka server **helps in service discovery and load balancing the requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Spring Cloud Config server** acts as a single place where we will manage
    the external properties of applications across environments. It also provides
    a dashboard for users. With this, users can manage and monitor the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes JHipster Registry an ideal choice for both monolithic and microservice
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: If you are developing microservice applications where different services are
    written in different languages, and if you prefer consistency over availability
    of services, then you can choose Consul.
  prefs: []
  type: TYPE_NORMAL
- en: There are three ways in which we can set up JHipster Registry to run locally.
  prefs: []
  type: TYPE_NORMAL
- en: We can either download the WAR file (pre-packaged) and run it directly, or clone
    our GitHub repository and run from there. We can also use a Docker container to
    run it. We will see how to do each of these now.
  prefs: []
  type: TYPE_NORMAL
- en: You can choose to use JHipster Registry while generating monolithic applications
    as well. Just select yes for the question Do you want to use the JHipster Registry
    to configure, monitor and scale your application? during generation.
  prefs: []
  type: TYPE_NORMAL
- en: Using a pre-packaged WAR file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download the latest version of the pre-packaged executable WAR file from the registry
    releases page ([https://github.com/jhipster/jhipster-registry/releases](https://github.com/jhipster/jhipster-registry/releases)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your terminal and then type the following command, replacing `<version>`
    with the latest one. If you are using Windows and do not have `curl` set up, you
    can also download the file by visiting the link in a browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download the latest WAR file from the JHipster Registry project.
    Once downloaded, we can run JHipster Registry using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we pass a few values to our registry server; they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since JHipster Registry is built on top of the JHipster application, it will
    have the default admin user. For that admin user, we provide the password with
    the Spring property `security.user.password`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the JWT token for the application in two ways. We can either
    set the information in the environment variable and use that, or else add this
    key value when we define the secret. This also uses the `spring config` property
    to set the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we tell the JHipster Registry where to find the central configurations
    that are available for the Spring Cloud Config server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we see what value to pass in here, we need to know about the Spring profiles
    in the context of `spring-cloud-config`. Spring Cloud Config supports `native` and
    `git` profiles by default.
  prefs: []
  type: TYPE_NORMAL
- en: In a `native` profile, the Cloud Config server expects its properties to be
    defined in a file, and we have to pass in the file location to the JHipster Registry.
    On the other hand, the `git` profile will expect `--spring.cloud.config.server.git.uri`
    to be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the sample JHipster config file for the the registry is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be seen in the Spring Cloud Configuration page of the Registry as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8e07533-0801-4208-9a96-c5446ee1a212.png)'
  prefs: []
  type: TYPE_IMG
- en: Just like the JHipster app provides `dev` and `prod` profiles, JHipster Registry
    also supports `dev` and `prod` profiles. By default, it will start in the `dev` profile
    when started, but we can make it run in a `prod` profile using  `--spring.profiles.active=prod,git`, passing
    in the `git` URL, and then defining the configuration properties there. For production
    mode, `git` is the preferred profile to use on a Spring Cloud Server.
  prefs: []
  type: TYPE_NORMAL
- en: Building from source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to work on leading-edge technology and are interested in exploring
    the latest features added to the JHipster Registry, then you can go a step further
    and clone the repository from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to your preferred folder and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once cloned, navigate to the folder using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application in dev mode as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run it in prod mode as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also package and run the WAR file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Docker mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also start JHipster Registry from the provided Docker image. The application
    that we generated already has the `docker-compose` file required.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the gateway application we created, look for the `docker-compose`
    file under `src/main/docker/jhipster-registry.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start the JHipster Registry by typing the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker compose` file (`src/main/docker/jhipster-registry.yml`) contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This defines the image as `jhipster-registry` with a version (the latest). It
    also defines a volume to mount the `central-config`, which is required by the
    Spring Cloud Config server to define the application properties for the microservice
    application and gateway. The environment variables such as the Spring profile,
    password for the admin, and cloud config search location are also defined here.
    The port in which it is exposed (`8761`) is also specified.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this needs Docker to be installed and running on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: In all preceding cases (when they are successful), it boots up JHipster Registry
    on port `8761` and uses native mode by default (unless otherwise changed explicitly).
    You can actually navigate to `http://localhost:8761` to access JHipster Registry
    and then log in to the application with the password that we used when we started
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Running a generated application locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So we are all set now. We have generated a gateway application, we have a microservice
    with an SQL DB that runs with H2 in a dev profile and MySQL in a prod profile
    (invoice application), we have a microservice with MongoDB (notification application),
    and finally we just finished setting up our JHipster Registry locally. Now it
    is time to start everything locally and see how seamless our microservice setup
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Gateway application pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We head over to terminal now and then go to the `e-commerce-app` folder. Navigate
    to the `online-store` folder and start the gateway application in dev mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start our Gateway application on port `8080`. Let''s open `http://localhost:8080`
    in our favorite browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b34359a-b72a-4ad4-9bb8-e5b6ff99a76f.png)'
  prefs: []
  type: TYPE_IMG
- en: Then we can click on the sign in button on the home page or `Account/sign in` from
    the top menu, and then enter the username and password as `admin` and `admin`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged in as an admin user, you can see the administration menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18d5069d-ba32-4469-bdf7-415cfe37f2e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the administration menu, you can find the following pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a89eeb0-f2d6-4559-bec3-8c4efe731566.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gateway**: The Gateway page will show the list of microservice applications
    for which this application acts as a gateway. It will also show the routes and
    the services that handle the route, and the available servers for the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b64e45f-7f30-4b41-902f-a899e61bb50b.png)'
  prefs: []
  type: TYPE_IMG
- en: Currently, there is no microservice application booted up, so the page is empty.
    We will see how this page is changed once we start our notification and invoice
    services.
  prefs: []
  type: TYPE_NORMAL
- en: '**User management**: This is similar to monolithic user management and holds
    the basic user information and management.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Metrics**: The Metrics page holds the information about JVM metrics and service/DB
    statistics. This is, again, similar to the monolithic application. Added to that,
    this also shows the metric statistics for the microservice applications registered.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Health**: The Health page shows the basic health information of the various
    services that we have in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a95d6deb-60a4-4873-a3dc-30e512e2c334.png)'
  prefs: []
  type: TYPE_IMG
- en: Similar to the monolithic application, it shows Disk space and Database. But
    added to that it also shows the health of the Discovery network (that is, the
    discoveryClient and the Eureka server). It also shows the microservice config
    server's health, which is `spring-cloud-config-server`, and then shows the health
    of the circuit breaker we use (Hystrix).
  prefs: []
  type: TYPE_NORMAL
- en: Configuration, Audits, Logs, and API pages are similar to the monolithic application
    we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster Registry pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have started the registry server at port `8761`, we can visit `http://localhost:8761`
    and log in with `admin` as the username and `admin` (the password that we have
    provided when starting the application) as the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon logging in, JHipster Registry shows the following information in the form
    of a dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf0453ee-976f-48c5-ab72-57d55afd1e1b.png)'
  prefs: []
  type: TYPE_IMG
- en: System status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This panel will show the environment in which the application is running and
    how long the application has been running (System uptime).
  prefs: []
  type: TYPE_NORMAL
- en: Below renew threshold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our applications will have to send heartbeat signals to the registry service
    to notify the registry that the application is alive and running. The registry
    services rely on this heartbeat signal to register and deregister the application.
    That is, the existence of the application is determined with the help of this
    heartbeat ping. This is what will happen in the renew phase.
  prefs: []
  type: TYPE_NORMAL
- en: However, when the Eureka server is booting up, it will try to get all the information
    about instance registries from the nearby service. If the nearby service fails
    for any reason, then it will try to connect to all of its peers to fetch the information.
    If the Eureka server was able to fetch the information for all the servers, then
    it will set the renewal threshold based on the information received. Based on
    this information, JHipster Registry will hold the information on whether the current
    level is below the renewal threshold specified and notify users in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Instances registered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This will show basic information about the instances that have been registered
    with the registry. Since we have only booted up the gateway service, we will see
    only one instance here. Basically, this will list all the instances that are connected
    to this registry service.
  prefs: []
  type: TYPE_NORMAL
- en: It shows the status of the system, the name of the system, and then the instance
    ID. The instance ID is generated based on the configuration in the `application.yml`
    of JHipster Registry. It assigns a random value.
  prefs: []
  type: TYPE_NORMAL
- en: General info and health
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It also shows general information about the JHipster Registry service and health
    information of the cluster of services, similar to the gateway health. The data
    here is fetched with the help of Spring Actuator health and metric endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Note the UNKNOWN in the **Health** section (refer to the preceding screenshot).
    It tells us that the Eureka server is not running in a highly available mode,
    or only one instance of JHipster Registry is running. When you boot another instance
    of the registry (that is, make the application highly available) it goes off.
  prefs: []
  type: TYPE_NORMAL
- en: Application listing page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This page lists the applications that are registered in the JHipster Registry
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to Administration | Gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c68e9920-23a1-4e30-b4c8-7f7bf3598e04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It shows the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The current instance ID and its name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current status of the instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version that is deployed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zone in which it is deployed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version number is fetched from the `build.gradle` or `pom.xml` for Gradle
    and Maven projects respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The zone here normally refers to an Amazon zone. It is used by Ribbon to route
    the request to the nearest server. This configuration is useless if you don't
    use Amazon, and this is why we force it to *primary* (otherwise the load balancing
    algorithm would be wrong).
  prefs: []
  type: TYPE_NORMAL
- en: All the pages in the administration module will have a drop-down menu that lists
    the various instances that are registered, and we can select that instance to
    view its metrics, health, configuration, and other information depending on the
    page we are on.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, this will show Registry''s JVM metrics and its service statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0657f768-31b3-454b-8218-653752c5e25a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can select any instance from the drop-down menu provided and see its statistics,
    thus, making JHipster Registry a single point of information that provides all
    the necessary insight into your microservice architecture. For example, upon selecting
    the Gateway application instance, we will get gateway-related information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57618e00-e5af-4658-9c91-1a6eeb491f9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Health page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The health page will list the health of the Registry itself and all the instances
    that are connected to it. For example, upon selecting the gateway application
    instance, we will get  gateway-related information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48a8763a-2e6c-4590-aab4-7ebf5e6f4e87.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuration page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the health and metrics pages, JHipster Registry will provide detailed
    configuration of all the instances connected to it and we can choose the instances
    from the drop-down menu:'
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows configuration screen for the Gateway application
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f49b534-e49c-4c7a-b48b-35f8bfcff894.png)'
  prefs: []
  type: TYPE_IMG
- en: Logs page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the preceding pages, the log page will also show the real-time logs
    of the application. This is really useful for debugging and getting more information
    when there is a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: The logs are formatted at the application level. The console here shows `tail
    -f` for consolidating logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows logs from the Gateway application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dc8fee6-d096-4d45-8e92-b7ac19c3af45.png)'
  prefs: []
  type: TYPE_IMG
- en: Swagger API endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The microservice architecture relies heavily on API calls between gateway and
    services, services and registry, and gateway and registries. So it is essential
    for developers and users to get to know the API endpoints that they can access,
    as well as the information required to access those endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be a lot of work. Fortunately, libraries such as Swagger come to the
    rescue. We just have to add the standard comments to the methods, and then the
    Swagger API will do the necessary work to extract information from them and convert
    them into a beautiful user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b9b74bb-9c3a-4e94-966d-64a09d6b3367.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image shows the default generated Swagger UI page. It lists all
    the endpoints available, and then provides the list of operations that it provides.
    It shows the playground where we can frame requests and test them for output.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the Swagger API docs are available only in development mode. If you
    are developing an API service and if there is a need to expose this to end users
    or external developers using your service, you can enable it in production by
    setting the swagger profile, along with `prod`, by setting `spring.profiles.active=prod,swagger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the other pages, this also lists the various instances that are
    connected to this registry service and we can select them from the drop-down menu
    (upper-right corner) to see what APIs are provided by various applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8291b0b3-59d3-41f8-8410-90af0bcfab02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The listed operations in the gateway API will provide the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01fc07f9-d529-4471-bece-a88c4b3db9ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It lists all the operations that are available in the `AccountResource` file.
    It shows the method type (`GET` / `POST` / `PUT` / `DELETE`), and then the endpoint
    and the method name that is present in the `AccountResource` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca90823e-e343-4ff6-9b8c-ee59f3c5b52d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Upon clicking any one of the endpoints, it shows detailed information about
    the response classes, response errors, response content type, and also how the
    response object is structured. In addition to this, it also shows how the model
    object is constructed. These are particularly helpful for end users who want to
    access these APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, there is an option to try out the endpoint upon clicking the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebbd03a7-a9ed-46b1-93c7-aaaa52cc89fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It shows the request and its response. It also shows how to frame the request,
    along with the authentication token. It provides the response code and the response
    header information that is returned by the server, which is also extremely useful
    for API programmers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e347b5a-f5cf-4b28-936f-bedc37248ead.png)'
  prefs: []
  type: TYPE_IMG
- en: Running invoice and notification applications locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have started the gateway and the registry services. We can then go to our
    invoice and notification application folders and then run them locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Open another terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will run them in `8081` and `8082` ports respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e38cf2c-0561-428a-84ad-c9cbf73ba485.png)'
  prefs: []
  type: TYPE_IMG
- en: Upon starting the application, it will also try to connect to JHipster Registry
    and register itself. You can watch for the preceding message once your server
    has started, to make sure that it is connected to JHipster Registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can alternatively test this via your Gateway application. Log in to your
    Gateway application and then navigate to Administration | Gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fe810da-73f5-4835-a2cd-b359544f3bb3.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see the two microservice applications, invoice and notification,
    are booted up and they are available at their respective URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check the JHipster Registry service to list the registered instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8c09632-408d-46eb-bd63-4be24e62b416.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, all the other pages in JHipster Registry will start to show the invoice
    and notification as one of the instances, and we can get their health, configuration,
    logs, and metrics right from JHipster Registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have followed along with the book, this will be the directory structure
    you will have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccd353fd-9500-4200-ad98-10e736fb2156.png)'
  prefs: []
  type: TYPE_IMG
- en: Modeling entities in JDL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have already used the JDL studio when we were setting up our monolithic
    application, it's time to update it.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, we will move the entities from a monolithic
    application to a gateway application, then, remove the invoice-related entities
    from the monolithic application, use them in our invoice microservice, and then
    update the related invoice references in that. Finally, we create entities for
    the notification microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows our new JDL entity model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b90e1c3-001b-4550-b64e-c1cfb3bd4e9c.png)'
  prefs: []
  type: TYPE_IMG
- en: The invoice is a perfect candidate to move out into a separate service. We can
    completely decouple invoice and its dependencies, but this will cause one problem
    in our current application—the `ProductOrder` entity is related to the `Invoice`
    table and we have to remove this dependency while keeping the relationship (but
    not as a foreign key) as an indirect key in `ProductOrder` that connects with
    the `Invoice` entity.
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved in two ways. We can change the foreign key into just another
    column in the `ProductOrder` entity, or create another entity called `InvoiceOrder`
    that just holds InvoiceIDs and `ProductOrder` IDs and map it to the `ProductOrder`
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: The former keeps the table structure more or less the same and allows easier
    migration. The latter will increase isolation at the cost of normalization, and
    they are heavily used in high-performance applications. As you see, both have
    their own merits and demerits. The approach you should take depends purely on
    your requirement. We will consider the first approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, we will remove the relationship from Product owner in JDL
    defined in `online-store.jh` as shown for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Remove the highlighted line and move all the invoice-related entities to the `invoice-jdl.jh` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, go to the Product Order entity, add an `invoiceId` field, and mark it
    as the `Long` type. It is an optional field and hence doesn''t need the required
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Entities for microservices can be tagged using the microservice keyword supported
    by JDL. This helps JHipster to identify entities that belong to a specific microservice.
    It follows the same JDL options syntax that we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<OPTION> <ENTITIES | * | all> [with <VALUE>] [except <ENTITIES>]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`microservice` keyword'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Followed by the names of the entity, comma separated if multiple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Followed by the `with` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Followed by the name of the microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should use different files for microservices' entities, so that we create
    two files, `invoice-jdl.jh` and `notification-jdl.jh`, that contain the entities
    related to invoice and notification respectively, along with the original.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we map the existing `Invoice` entity to the microservice in our JDL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it is time to create another JDL file to hold the notification service
    details. Create a file called **notification-jdl.jh** and add the entities for
    notifications into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we bind these entities to the `Notification` microservice, with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That is it. We have defined the domain model for our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Entity generation on microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our JDL is ready to use now. The next step will be generating the entities in
    the gateway and the services. To start with, we will download our JDL files from
    the JDL studio. Once downloaded, we will move the files into our gateway and microservice
    applications respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once moved, run the following command after navigating into the gateway application
    folder. This will create the entities for the gateway and also create the UI for
    the microservice entities in the gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `--skip-ui-grouping` flag disables the client-side entity component grouping
    behavior for microservices introduced in JHipster 5.x. This helps us to cherry-pick
    our changes from the monolithic application without many conflicts. This grouping
    behavior is useful when you have entities with the same name in different services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command for the notification service so that the backend
    for the entities are created there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command for the invoice service so that the backends for
    the entities are created there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: JHipster will ask about overwriting the modified files; please select the applicable
    ones. We will use `"a" ->`, which means that it will overwrite everything.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to cherry-pick any changes we made to entities originally in the
    monolith back to our gateway and microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to commit the changes in each of the services and gateway. You
    could also init the entire `e-commerce-app` folder as a `git` source if you like,
    by running `git init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Explaining the generated  code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the notification service, once we have generated the application, the following
    files were created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24baa8ee-5736-4ae8-9d4c-53d1c8f7ac89.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this will only generate the backend files and not the frontend
    files, since they are already generated in the gateway service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, running the `jhipster import-jdl` command in the invoice application
    will generate similar Java files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb672b0d-0c9f-4eab-85cf-7ac4cc798af7.png)'
  prefs: []
  type: TYPE_IMG
- en: Gateway application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Gateway application, the entire frontend (including the entities in
    microservices) will be generated. Since JHipster produces proxy-based microservices,
    all the frontend code will live in the Gateway application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0201c4c8-1f97-47ab-9aad-c6145d776a63.png)'
  prefs: []
  type: TYPE_IMG
- en: '`ProductOrder.Java` will remove the `Invoice` as a foreign key and then use
    the long value that we passed in here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So, the application is generated completely. Now, it is time to run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fire up three consoles (since we need to run three applications). If we have
    the applications running already, then we just need to compile them and Spring
    devtools will auto reload the applications. Make sure the registry is already
    running as well:'
  prefs: []
  type: TYPE_NORMAL
- en: In console 1, navigate to the gateway and then start the server with `./gradlew`
    if it is not already running, otherwise compile with `` `./gradlew compileJava`
    ``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In console 2, navigate to the invoice and then start the server with` ./gradlew` if
    it is not already running, otherwise compile with `./gradlew compileJava`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In console 3, navigate to the notification and then start the server with` ./gradlew` if
    it is not already running, otherwise compile with `./gradlew compileJava`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the generated pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the application has started successfully, it is time to spin up your favorite
    browser and navigate to the gateway server at `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Once logged in, you can see that the entities are generated in the gateway application
    and they are available under the entity nav menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'It includes all the gateway entities and also the microservice entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ccffb10-6c53-4ac5-9366-0e0860e8bd19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the invoice screen created in the gateway application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47eb47e0-b724-4685-bdc1-6048ea1ff23e.png)'
  prefs: []
  type: TYPE_IMG
- en: Try to create a few entities to verify that everything is working fine.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have done a lot of things in this chapter, let's recap what we have
    done so far.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully generated a gateway and two microservices. We have downloaded
    JHipster Registry and then started it locally. We have successfully segregated
    and generated the entity files for a notification and invoice service. We have
    finally booted up all our applications and saw how things are generated, and were
    able to create the microservice application. Last but not least, we have also
    committed all our changes to Git (in other words, reached a checkpoint).
  prefs: []
  type: TYPE_NORMAL
