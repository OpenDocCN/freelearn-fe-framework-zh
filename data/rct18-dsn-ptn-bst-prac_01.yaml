- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Taking Your First Steps with React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React入门第一步
- en: Hello, readers!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 亲爱的读者们！
- en: This book assumes that you already know what React is and what problems it can
    solve for you. You may have written a small/medium application with React, and
    you want to improve your skills and answer all your questions. You should know
    that React is maintained by the developers at Meta and hundreds of contributors
    within the JavaScript community. React is one of the most popular libraries for
    creating UIs, and it is well known to be fast, thanks to its smart way of working
    with the **Document Object Model** (**DOM**). It comes with JSX, a new syntax
    for writing markup in JavaScript, which requires you to change your thinking regarding
    the separation of concerns. It has many cool features, such as server-side rendering,
    which gives you the power to write universal applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设您已经了解React是什么以及它能为您解决什么问题。您可能已经使用React编写了一个小型/中型应用程序，并希望提高您的技能并解答所有疑问。您应该知道React由Meta的开发者和JavaScript社区内的数百名贡献者维护。React是创建UIs最受欢迎的库之一，它因其与**文档对象模型**（**DOM**）智能交互而闻名，速度快。它包含JSX，这是一种在JavaScript中编写标记的新语法，这要求您改变对关注点分离的看法。它有许多酷炫的功能，例如服务器端渲染，这使您能够编写通用应用程序。
- en: 'In this chapter, we will go through some basic concepts that are essential
    to master in order to use React effectively, but are straightforward enough for
    beginners to figure out:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些基本概念，这些概念对于有效地使用React至关重要，但对于初学者来说也足够简单，可以自行理解：
- en: The difference between imperative and declarative programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式编程和声明式编程之间的区别
- en: React components and their instances, and how React uses elements to control
    the UI flow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React组件及其实例，以及React如何使用元素来控制UI流程
- en: How React changed the way we build web applications, enforcing a different new
    concept of separation of concerns, and the reasons behind its unpopular design
    choice
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React如何改变我们构建Web应用程序的方式，强制执行不同的关注点分离新概念，以及其不受欢迎的设计选择背后的原因
- en: Why people feel JavaScript fatigue, and what you can do to avoid the most common
    errors developers make when approaching the React ecosystem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么人们会感到JavaScript疲劳，以及您如何避免在接近React生态系统时开发者最常犯的错误
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow this book, you need to have some experience in using the terminal
    to run a few Unix commands. Also, you need to install **Node.js**. You have two
    options: the first one is to download Node.js directly from the official website
    ([https://nodejs.org](https://nodejs.org)), and the second option (recommended)
    is to install **Node Version Manager** (**NVM**) from [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本书，您需要有一些使用终端运行Unix命令的经验。此外，您需要安装**Node.js**。您有两个选择：第一个是从官方网站直接下载Node.js（[https://nodejs.org](https://nodejs.org)），第二个选项（推荐）是从[https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)安装**Node版本管理器**（**NVM**）。
- en: 'If you decide to go with NVM, you can install any version of Node.js you want
    and switch the versions with the `nvm install` command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定使用NVM，您可以安装任何版本的Node.js，并通过`nvm install`命令切换版本：
- en: '`node` is an alias for the latest version:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`是最新版本的别名：'
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also install a global version of Node.js (`nvm` will install the latest
    version of Node.js locally to a user’s computer):'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以安装Node.js的全局版本（`nvm`将本地安装最新版本的Node.js到用户的计算机上）：
- en: '[PRE1]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or you can install a very specific version:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您可以安装一个非常具体的版本：
- en: '[PRE2]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After you have installed the different versions, you can switch between them
    by using the `nvm use` command:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了不同版本后，您可以通过使用`nvm use`命令在它们之间切换：
- en: '[PRE3]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, you can specify a default Node.js version by running the following
    command:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，您可以通过运行以下命令指定默认的Node.js版本：
- en: '[PRE4]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In short, here is a list of the requirements to complete the chapter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，以下是完成本章所需的条件列表：
- en: '**Node.js (19+)**: [https://nodejs.org](https://nodejs.org)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js (19+)**: [https://nodejs.org](https://nodejs.org)'
- en: '**NVM**: [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NVM**: [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)'
- en: '**VS Code**: [https://code.visualstudio.com](https://code.visualstudio.com)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VS Code**: [https://code.visualstudio.com](https://code.visualstudio.com)'
- en: '**TypeScript**: [https://www.npmjs.com/package/typescript](https://www.npmjs.com/package/typescript)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript**: [https://www.npmjs.com/package/typescript](https://www.npmjs.com/package/typescript)'
- en: 'You can find the code in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书的GitHub仓库中找到代码：[https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition)。
- en: Differentiating between declarative and imperative programming
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分声明式和命令式编程
- en: When reading the React documentation or blog posts about React, you will have
    undoubtedly come across the term **declarative**. One of the reasons why React
    is so powerful is that it enforces a declarative programming paradigm.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当阅读React文档或关于React的博客文章时，你无疑会遇到**声明式**这个术语。React之所以如此强大，其中一个原因就是它强制执行声明式编程范式。
- en: Therefore, to master React, it is essential to understand what declarative programming
    means and what the main differences between imperative and declarative programming
    are. The easiest way to approach this is to think about imperative programming
    as a way of describing how things work, and declarative programming as a way of
    describing what you want to achieve.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要精通React，理解声明式编程的含义以及命令式和声明式编程之间的主要区别是至关重要的。最简单的方法是将命令式编程视为描述事物如何工作的方式，将声明式编程视为描述你想要实现的方式。
- en: 'Entering a bar for a beer is a real-life example in the imperative world, where
    normally you will give the following instructions to the bartender:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式世界中，进入酒吧喝啤酒是一个现实生活中的例子，你通常会向酒吧服务员下达以下指示：
- en: Find a glass and collect it from the shelf.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找一个杯子并从架子上取下来。
- en: Place the glass under the tap.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把杯子放在水龙头下。
- en: Pull down the handle until the glass is full.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把手拉到杯满为止。
- en: Hand me the glass.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把杯子递给我。
- en: In the declarative world, you would just say, “Can I have a beer, please?”
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式世界中，你只需说，“请给我一杯啤酒，好吗？”
- en: The declarative approach assumes that the bartender already knows how to serve
    a beer, an important aspect of the way declarative programming works.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式方法假设酒吧服务员已经知道如何服务啤酒，这是声明式编程工作方式的一个重要方面。
- en: 'Let’s move into a JavaScript example. Here we will write a simple function
    that, given an array of lowercase strings, returns an array with the same strings
    in uppercase:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个JavaScript的例子。在这里，我们将编写一个简单的函数，给定一个小写字符串数组，返回一个包含相同字符串的大写数组：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An imperative function to solve the problem would be implemented as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的命令式函数可以这样实现：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, an empty array to contain the result is created. Then, the function loops
    through all the elements of the input array and pushes the uppercase values into
    the empty array. Finally, the output array is returned.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个空数组来存放结果。然后，函数遍历输入数组的所有元素，将大写值推入空数组。最后，返回输出数组。
- en: 'A declarative solution would be as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式解决方案如下：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The items of the input array are passed to a `map` function that returns a
    new array containing the uppercase values. There are some significant differences
    to note: the former example is less elegant, and it requires more effort to be
    understood. The latter is terser and easier to read, which makes a huge difference
    in big code bases, where maintainability is crucial.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数组的项被传递给一个`map`函数，该函数返回一个包含大写值的新数组。有一些值得注意的显著差异：前一个例子不太优雅，需要更多的努力才能理解。后者更简洁，更容易阅读，这在大型代码库中，维护性至关重要。
- en: Another aspect worth mentioning is that in the declarative example, there is
    no need to use variables or to keep their values updated during the execution.
    Declarative programming tends to avoid creating and mutating a state.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提到的方面是，在声明式示例中，不需要使用变量或在执行过程中更新它们的值。声明式编程倾向于避免创建和修改状态。
- en: 'As a final example, let’s see what it means for React to be declarative. The
    problem we will try to solve is a common task in web development: creating a toggle
    button.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，让我们看看React声明式意味着什么。我们将尝试解决的问题是在Web开发中常见的任务：创建一个切换按钮。
- en: Imagine a simple UI component such as a toggle button. When you click it, it
    turns green (on) if it was previously gray (off), and switches to gray (off) if
    it was previously green (on).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个简单的UI组件，比如切换按钮。当你点击它时，如果它之前是灰色（关闭），它会变成绿色（开启）；如果它之前是绿色（开启），它会变成灰色（关闭）。
- en: 'The imperative way of doing this would be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的命令式方法如下：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is imperative because of all the instructions needed to change the classes.
    In contrast, the declarative approach using React would be as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它是命令式的，因为需要所有这些指令来更改类。相比之下，使用React的声明式方法如下：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In declarative programming, developers only describe what they want to achieve,
    and there’s no need to list all the steps to make it work. The fact that React
    offers a declarative approach makes it easy to use, and consequently, the resulting
    code is simple, which often leads to fewer bugs and more maintainability.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式编程中，开发者只需描述他们想要实现的内容，无需列出所有使它工作的步骤。React提供声明式方法使得它易于使用，因此生成的代码简单，这通常会导致更少的错误和更高的可维护性。
- en: In the next section, you will learn how React elements work and you will get
    more context on how props are being passed on a React component.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习React元素的工作原理，并了解更多关于如何在React组件上传递props的上下文。
- en: How React elements work
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React元素的工作原理
- en: In this book, we assume that you are familiar with components and their instances,
    but there is another object you should know about if you want to use React effectively
    – the element. Elements are lightweight immutable descriptions of what should
    be rendered, while components are more complex stateful objects responsible for
    generating elements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们假设你已经熟悉组件及其实例，但如果你想要有效地使用React，你应该了解另一个对象——元素。元素是轻量级的不可变描述，用于表示应该渲染的内容，而组件则是更复杂的具有状态的对象，负责生成元素。
- en: Whenever you `call` **createClass**, **extend Component**, or **declare a stateless
    function**, you are creating a component. React manages all the instances of your
    components at runtime, and there can be more than one instance of the same component
    in memory at a given point in time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你`调用`**createClass**、**extend Component**或**声明一个无状态函数**时，你都在创建一个组件。React在运行时管理你组件的所有实例，在给定的时间点内存中可以存在同一组件的多个实例。
- en: As mentioned previously, React follows a declarative paradigm, and there’s no
    need to tell it how to interact with the DOM; you declare what you want to see
    on the screen, and React does the job for you. One of the tools that makes this
    process more expressive and readable is JSX, which allows you to write HTML-like
    syntax directly in your JavaScript code. JSX is not mandatory, but it’s widely
    used in the React community.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，React遵循声明式范式，无需告诉它如何与DOM交互；你只需声明你希望在屏幕上看到的内容，React就会为你完成工作。使这个过程更具表达性和可读性的一个工具是JSX，它允许你直接在JavaScript代码中编写类似HTML的语法。JSX不是必需的，但在React社区中广泛使用。
- en: To control the UI flow, React uses a particular type of object called an element.
    These elements are created using the `React.createElement()` function, or more
    commonly, with JSX syntax. Elements contain only the information that is strictly
    needed to represent the interface.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制UI流程，React使用一种称为元素的特殊类型的对象。这些元素是通过`React.createElement()`函数创建的，或者更常见的是，通过JSX语法。元素只包含严格需要表示界面的信息。
- en: 'Here is an example of an element created with JSX:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用JSX创建的元素的示例：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This JSX code is converted into JavaScript objects like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此JSX代码被转换成如下JavaScript对象：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The element’s type is crucial because it informs React on how to handle it.
    If the type is a string, the element represents a DOM node, while if it’s a function,
    the element represents a component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的类型至关重要，因为它告诉React如何处理它。如果类型是字符串，则元素表示一个DOM节点；如果是函数，则元素表示一个组件。
- en: You can nest DOM elements and components to create a render tree, representing
    the structure of your application’s user interface. By organizing your elements
    and components in a hierarchical manner, you can create complex and dynamic UIs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以嵌套DOM元素和组件来创建渲染树，表示应用程序用户界面的结构。通过以分层的方式组织你的元素和组件，你可以创建复杂和动态的UI。
- en: React uses a technique called the Virtual DOM, which is an in-memory representation
    of the actual DOM. It compares the current and new trees to minimize the number
    of actual DOM updates. This process is called reconciliation and is used by both
    React DOM and React Native to create UIs for their respective platforms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: React使用一种称为虚拟DOM的技术，它是实际DOM的内存表示。它比较当前树和新树，以最小化实际DOM更新的数量。这个过程称为协调，并由React DOM和React
    Native用于为其各自的平台创建UI。
- en: When an element’s type is a function, React invokes that function, passing in
    the element’s props to obtain the underlying elements. It recursively repeats
    this process on the result until it constructs a tree of DOM nodes that can be
    rendered on the screen.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个元素的类型是函数时，React 会调用该函数，并将元素的属性传递给它以获取底层元素。它会递归地重复此过程，直到构建出可以在屏幕上渲染的 DOM 节点树。
- en: In summary, elements play a crucial role in React’s declarative paradigm, allowing
    you to create complex user interfaces without manually managing the creation and
    destruction of DOM elements.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，元素在 React 的声明式范式中的作用至关重要，它允许你创建复杂用户界面，而无需手动管理 DOM 元素的创建和销毁。
- en: By understanding how elements and components work together, and how React efficiently
    updates the UI using the Virtual DOM and reconciliation, you’ll be well equipped
    to build dynamic and efficient web applications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解元素和组件如何协同工作，以及 React 如何使用虚拟 DOM 和协调高效地更新 UI，你将能够构建动态且高效的 Web 应用程序。
- en: Unlearning everything
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新学习一切
- en: When working with React for the first time, it’s essential to approach it with
    an open mind. This is because React represents a new way of designing web and
    mobile applications, breaking away from many traditional best practices.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次使用 React 时，以开放的心态去接近它是至关重要的。这是因为 React 代表了一种新的设计 Web 和移动应用程序的方式，打破了许多传统的最佳实践。
- en: In the last two decades, we’ve learned that separation of concerns is crucial,
    often involving separating logic from templates. We aim to write JavaScript and
    HTML in different files, and various templating solutions have been created to
    aid developers in achieving this goal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的二十年里，我们已经了解到关注点分离是至关重要的，这通常涉及到将逻辑与模板分离。我们的目标是把 JavaScript 和 HTML 写在不同的文件中，为此已经创建了各种模板解决方案来帮助开发者实现这一目标。
- en: 'However, the problem with this approach is that it often creates an illusion
    of separation. In reality, JavaScript and HTML are tightly coupled, no matter
    where they live. To illustrate this, let’s consider an example template:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法的缺点是它往往造成了一种分离的错觉。实际上，JavaScript 和 HTML 无论在哪里都是紧密耦合的。为了说明这一点，让我们考虑一个示例模板：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding snippet is taken from the Mustache website, one of the most popular
    templating systems.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段来自 Mustache 网站，这是最受欢迎的模板系统之一。
- en: The first row tells Mustache to loop through a collection of items. Inside the
    loop, there is some conditional logic to check whether the `#first` and `#link`
    properties exist and, depending on their values, a different piece of HTML is
    rendered. Variables are wrapped in curly braces.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行告诉 Mustache 遍历一个项目集合。在循环内部，有一些条件逻辑来检查 `#first` 和 `#link` 属性是否存在，并根据它们的值渲染不同的
    HTML 片段。变量被括在花括号中。
- en: If your application only has to display some variables, a templating library
    could represent a good solution, but when it comes to starting to work with complex
    data structures, things change. Templating systems and their **Domain-Specific
    Language** (**DSL**) offer a subset of features, and they try to provide the functionalities
    of a real programming language without reaching the same level of completeness.
    As shown in the example, templates highly depend on the models they receive from
    the logic layer to display the information.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序只需要显示一些变量，模板库可能是一个不错的解决方案，但当涉及到开始处理复杂的数据结构时，情况就改变了。模板系统和它们的 **领域特定语言**
    （**DSL**） 提供了一组功能，并试图提供与真实编程语言相同的功能，而不达到相同的完整性水平。正如示例所示，模板高度依赖于从逻辑层接收的模型来显示信息。
- en: On the other hand, JavaScript interacts with the DOM elements rendered by the
    templates to update the UI, even if they are loaded from separate files. The same
    problem applies to styles – they are defined in a different file, but they are
    referenced in the templates, and the CSS selectors follow the structure of the
    markup, so it is almost impossible to change one without breaking the other, which
    is the definition of **coupling**. That is why the classic separation of concerns
    ended up being more the separation of technologies, which is, of course, not a
    bad thing, but it doesn’t solve any real problems.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，JavaScript 与模板渲染的 DOM 元素交互，以更新 UI，即使它们是从不同的文件加载的。同样的问题也适用于样式 – 它们在不同的文件中定义，但在模板中被引用，CSS
    选择器遵循标记的结构，因此几乎不可能在不破坏另一个的情况下更改其中一个，这就是 **耦合** 的定义。这就是为什么经典的关注点分离最终变成了更多技术的分离，这当然不是一件坏事，但它并没有解决任何真正的问题。
- en: React tries to move a step forward by putting the templates where they belong
    – next to the logic. The reason it does that is that React suggests you organize
    your applications by composing small bricks called components. The framework should
    not tell you how to separate the concerns because every application has its own,
    and only the developers should decide how to limit the boundaries of their applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: React试图通过将模板放在它们应该的位置——逻辑旁边——向前迈出一大步。它这样做的原因是React建议你通过组合称为组件的小块来组织你的应用程序。框架不应该告诉你如何分离关注点，因为每个应用程序都有自己的，只有开发者应该决定如何限制它们应用程序的边界。
- en: The component-based approach drastically changes the way we write web applications,
    which is why the classic concept of separation of concerns is gradually being
    taken over by a much more modern structure. The paradigm enforced by React is
    not new, and it was not invented by its creators, but React has contributed to
    making the concept mainstream and, most importantly, popularized it in such a
    way that it is easier to understand for developers with different levels of expertise.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的方法彻底改变了我们编写Web应用程序的方式，这就是为什么经典的概念——关注点分离——正逐渐被一个更加现代的结构所取代。React强加的范式并不新鲜，它也不是由其创造者发明的，但React为使这个概念主流化做出了贡献，最重要的是，它以更容易被不同水平的专业开发者理解的方式普及了这个概念。
- en: 'Rendering a React component looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染React组件看起来像这样：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We all agree that it seems a bit weird in the beginning, but that is just because
    we are not used to that kind of syntax. As soon as we learn it and we realize
    how powerful it is; we understand its potential. Using JavaScript for both logic
    and templating not only helps us separate our concerns in a better way, but it
    also gives us more power and more expressivity, which is what we need to build
    complex UIs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都同意，一开始这看起来有点奇怪，但这仅仅是因为我们还不习惯那种语法。一旦我们学会了它，并意识到它的强大；我们就理解了它的潜力。使用JavaScript进行逻辑和模板化不仅帮助我们更好地分离关注点，而且还赋予我们更多的能力和表现力，这是我们构建复杂UI所需要的东西。
- en: That is why even if the idea of mixing JavaScript and HTML sounds weird in the
    beginning, it is vital to give React 5 minutes. The best way to get started with
    new technology is to try it on a small side project and see how it goes. In general,
    the right approach is always to be ready to unlearn everything and change your
    mindset if the long-term benefits are worth it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使混合JavaScript和HTML的想法一开始听起来很奇怪，但给React五分钟时间是至关重要的。开始使用新技术最好的方式是在一个小型项目上尝试，看看效果如何。一般来说，正确的做法总是准备好放弃一切，并改变你的思维方式，如果长期利益值得的话。
- en: 'There is another concept that is pretty controversial and hard to accept, and
    that the engineers behind React are trying to push to the community: moving the
    styling logic inside the component, too. The end goal is to encapsulate every
    single technology used to create our components and separate the concerns according
    to their domain and functionalities. Here is an example of a style object taken
    from the React documentation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个概念相当有争议，难以接受，那就是React背后的工程师试图推广给社区的：将样式逻辑也移入组件内部。最终目标是封装创建我们组件所使用的每一种技术，并根据它们的领域和功能来分离关注点。以下是一个从React文档中摘取的样式对象的例子：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This set of solutions, where developers use JavaScript to write their styles,
    is known as **#CSSinJS**, and we will talk about it extensively in *Chapter 6*,
    *Making Your Components Look Beautiful*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这套解决方案，其中开发者使用JavaScript编写他们的样式，被称为**#CSSinJS**，我们将在第6章*让你的组件看起来更美观*中详细讨论。
- en: In the next section, we will see how to avoid JavaScript fatigue, which is caused
    by the large number of configurations that are needed to run a React application
    (webpack mainly).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何避免由运行React应用程序所需的大量配置引起的JavaScript疲劳（主要是webpack）。
- en: Understanding JavaScript fatigue
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JavaScript疲劳
- en: There is a prevailing opinion that React consists of a vast set of technologies
    and tools, and if you want to use it, you are forced to deal with package managers,
    transpilers, module bundlers, and an infinite list of different libraries. This
    idea is so widespread and shared among people that it has been clearly defined
    and given the name **JavaScript fatigue**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种普遍的观点认为React由一套庞大的技术和工具组成，如果你想使用它，你就被迫处理包管理器、转译器、模块打包器和无穷无尽的库。这种想法已经非常普遍，并且被广泛传播，以至于它已经被明确定义并命名为**JavaScript疲劳**。
- en: Misconceptions about React
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于React的误解
- en: It is not hard to understand the reasons behind JavaScript fatigue. All the
    repositories and libraries in the React ecosystem are made using shiny new technologies,
    the latest version of JavaScript, and the most advanced techniques and paradigms.
    Moreover, there is a massive amount of React boilerplate code on GitHub, each
    with tens of dependencies to offer solutions for any problem.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 JavaScript 疲劳的原因并不难。React 生态系统中的所有存储库和库都是使用闪亮的新技术、JavaScript 的最新版本和最先进的技术和范式构建的。此外，GitHub
    上有大量的 React 模板代码，每个都有数十个依赖项，为任何问题提供解决方案。
- en: However, it is essential to understand that React is a pretty tiny library,
    and it can be used inside any page (or even inside JSFiddle) in the same way everyone
    used to use jQuery or Backbone, just by including the script on the page before
    the closing body element.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要理解 React 是一个非常小的库，它可以在任何页面（甚至 JSFiddle 内）中使用，就像人们以前使用 jQuery 或 Backbone
    一样，只需在关闭 body 元素之前在页面上包含脚本即可。
- en: Getting started with React without the fatigue
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无疲劳地开始使用 React
- en: 'React is split into two packages:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: React 被拆分为两个包：
- en: '**react**: Implements the core features of the library'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**react**：实现了库的核心功能'
- en: '**react-dom**: Contains all the browser-related features'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**react-dom**：包含所有与浏览器相关的功能'
- en: The reason behind this is that the core package is used to support different
    targets, such as React DOM in browsers and React Native on mobile devices. Running
    a React application inside a single HTML page does not require any package manager
    or complex operation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于核心包用于支持不同的目标，例如 React DOM 在浏览器上和在移动设备上的 React Native。在单个 HTML 页面内运行 React
    应用程序不需要任何包管理器或复杂的操作。
- en: 'Here are the URLs to be included in the HTML to start using React:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是开始使用 React 需要包含在 HTML 中的 URL：
- en: '[https://unpkg.com/react@18.2.0/umd/react.production.min.js](mailto:https://unpkg.com/react@18.2.0/umd/react.production.min.js)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unpkg.com/react@18.2.0/umd/react.production.min.js](mailto:https://unpkg.com/react@18.2.0/umd/react.production.min.js)'
- en: '[https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js](mailto:https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js](mailto:https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js)'
- en: For a simple UI, we could just use **createElement** (**_jsx** since React 17)
    and only when we start building something more complex can we include a transpiler
    to enable JSX and convert it into JavaScript. As the app grows, we may need a
    router, API endpoints, and external dependencies.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的 UI，我们只需使用 **createElement** （自 React 17 起称为 **_jsx**）即可，只有在开始构建更复杂的东西时，我们才需要包含一个转译器来启用
    JSX 并将其转换为 JavaScript。随着应用的成长，我们可能需要路由器、API 端点和外部依赖项。
- en: Advantages of the JavaScript ecosystem
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 生态系统的优势
- en: Despite the fast pace and constant change in the JavaScript ecosystem, it offers
    several advantages. The community plays a significant role in driving innovation
    and rapid evolution. As soon as a specification is announced or drafted, someone
    in the community implements it as a transpiler plugin or a polyfill, letting everyone
    else experiment with it while the browser vendors agree and start supporting it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 JavaScript 生态系统发展迅速且不断变化，但它提供了几个优势。社区在推动创新和快速演变中发挥着重要作用。一旦宣布或起草了规范，社区中就会有人将其实现为转译器插件或
    polyfill，让其他人可以在浏览器供应商达成一致并开始支持它之前进行实验。
- en: This makes JavaScript and the browser a unique environment compared to other
    languages or platforms. The downside is that things change quickly, but it is
    just a matter of finding the right balance between betting on new technologies
    versus staying safe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 JavaScript 和浏览器与其他语言或平台相比成为一个独特的环境。缺点是变化很快，但这只是找到一个正确平衡的问题，即在押注新技术和保持安全之间找到平衡。
- en: Bye to Create-React-App, welcome to Vite!
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再见 Create-React-App，欢迎 Vite！
- en: Recently, the React team decided to remove **create-react-app** from their official
    documentation, indicating that it is no longer the default method for setting
    up a new React project. Instead, React now recommends using a framework such as
    Next.js, Remix, or Gatsby for more comprehensive solutions. However, if these
    frameworks do not fit your needs and you are looking for a simpler alternative,
    you can opt for build tools like Vite or Parcel.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，React 团队决定从他们的官方文档中移除 **create-react-app**，这表明它不再是设置新 React 项目的默认方法。相反，React
    现在推荐使用像 Next.js、Remix 或 Gatsby 这样的框架，以获得更全面的解决方案。然而，如果你需要更简单的替代方案，可以选择 Vite 或
    Parcel 这样的构建工具。
- en: Vite as a solution
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vite 作为解决方案
- en: Vite is a build tool and development server created by Evan You, the creator
    of Vue.js. It leverages the native ES modules feature in modern browsers for fast
    development and efficient production builds.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Vite 是由 Vue.js 的创造者 Evan You 创建的一个构建工具和开发服务器。它利用现代浏览器中本地的 ES 模块功能，以实现快速开发和高效的生成构建。
- en: 'To use Vite with React, first, install Vite globally using the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Vite 与 React，首先，使用以下命令全局安装 Vite：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, create a new Vite project using the React TypeScript template:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 React TypeScript 模板创建一个新的 Vite 项目：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, move into the newly created project folder and start the development
    server:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，进入新创建的项目文件夹并启动开发服务器：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should see the project running on port **5173** by default.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到项目默认在端口 **5173** 上运行。
- en: '![](img/B18414_01.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_01.png)'
- en: 'Figure 1.1: Vite default application'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：Vite 默认应用
- en: 'If you want to change the port to `3000`, you can modify the `vite.config.ts`
    file like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将端口改为 `3000`，您可以像这样修改 `vite.config.ts` 文件：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By using Vite, you can scaffold and run a React application with minimal dependencies
    and still have access to all the features needed to build a complete React application
    using the most advanced techniques.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vite，您可以用最少的依赖来搭建和运行一个 React 应用程序，同时仍然可以访问构建完整的 React 应用程序所需的所有高级技术功能。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this first chapter, we have learned about some basic concepts that are very
    important for following the rest of the book, and that are crucial to working
    with React daily. We now know how to write declarative code, and we have a clear
    understanding of the difference between the components we create and the elements
    that React uses to display their instances on the screen.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了对于理解本书的其余部分非常重要的基本概念，这些概念对于日常使用 React 至关重要。我们现在知道如何编写声明式代码，并且对创建的组件与
    React 用于在屏幕上显示其实例的元素之间的区别有了清晰的理解。
- en: We learned the reasons behind the choice of locating logic and templates together,
    and why that unpopular decision has been a big win for React. We went through
    the reasons why it is common to feel fatigued in the JavaScript ecosystem, but
    we have also seen how to avoid those problems by following an iterative approach.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了将逻辑和模板放在一起选择的原因，以及为什么这个不受欢迎的决定对 React 来说是一个巨大的胜利。我们探讨了在 JavaScript 生态系统中为什么会普遍感到疲劳的原因，但我们也已经看到了如何通过遵循迭代方法来避免这些问题。
- en: Finally, we have seen what the new `create-vite` CLI is, and we are now ready
    to start writing some real code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了新的 `create-vite` CLI 是什么，我们现在可以开始编写一些真正的代码了。
- en: In the next chapter, you will learn TypeScript and how to use it in your projects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习 TypeScript 以及如何在项目中使用它。
- en: Join our community on Discord
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/React18DesignPatterns4e](https://packt.link/React18DesignPatterns4e)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/React18DesignPatterns4e](https://packt.link/React18DesignPatterns4e)'
- en: '![](img/QR_Code2450023176943770109.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/QR_Code2450023176943770109.png)'
