["```js\nnpm init vue@latest\n```", "```js\n<script setup lang=\"ts\"></script>\n<template>\n</template>\n<style scoped>\n… (truncated, unchanged)\n</style>\n```", "```js\n<template>  <header>\n    <h1><span class=\"icon\" aria-hidden=\"true\">✅</span> To do</h1>\n    <p>Building Real-world Web Applications with Vue.js 3</p>\n  </header>\n</template>\n<style scoped>\nheader {\n  border-bottom: #333 1px solid;\n  background-color: #fff;\n}\nheader::after {\n  content: \"\";\n  display: block;\n  height: 1px;\n  box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.75);\n}\nh1 {\n  font-size: 2rem;\n}\nh1 .icon {\n  font-size: 1rem;\n  vertical-align: middle;\n}\n</style>\n```", "```js\n<script lang=\"ts\" setup>defineProps<{\n  isChecked?: boolean | false\n}>()\n</script>\n<template>\n  <label :class=\"{ 'checked': isChecked }\">\n    <input type=\"checkbox\" :checked=\"isChecked\" />\n    <slot></slot>\n  </label>\n</template>\n<style scoped>\nlabel {\n  cursor: pointer;\n}\n.checked {\n  text-decoration: line-through;\n}\n</style>\n```", "```js\n    <script lang=\"ts\" setup>import ListItem from './ListItem.vue'</script><template><ul>  <ListItem :is-checked=\"false\">This is the slotted content</ListItem></ul></template>\n    ```", "```js\n    <script setup lang=\"ts\">import AppHeader from './components/AppHeader.vue';import TodoList from './components/TodoList.vue';</script><template>  <AppHeader />  <TodoList /></template><style scoped>… (truncated)</style>\n    ```", "```js\n<script lang='ts' setup>import ListItem from './ListItem.vue'\ntype Item = {\n  title: string,\n  checked?: boolean\n}\nconst listItems: Item[] = [\n  { title: 'Make a todo list app', checked: true },\n  { title: 'Predict the weather', checked: false },\n  { title: 'Play some tunes', checked: false },\n  { title: 'Let\\'s get cooking', checked: false },\n  { title: 'Pump some iron', checked: false },\n  { title: 'Track my expenses', checked: false },\n  { title: 'Organize a game night', checked: false },\n  { title: 'Learn a new language', checked: false },\n  { title: 'Publish my work' }\n]\n</script>\n```", "```js\n<template>  <ul>\n    <li\n      :key='key'\n      v-for='(item, key) in listItems'\n    >\n      <ListItem :is-checked='item.checked'>{{ item.title }}</ListItem>\n    </li>\n  </ul>\n</template>\n```", "```js\n<style scoped>ul {\n  list-style: none;\n}\nli {\n  margin: 0.4rem 0;\n}\n</style>\n```", "```js\nimport { ref } from 'vue'import type { Ref } from 'vue'\n```", "```js\nconst listItems: Ref<Item[]> = ref([  { title: 'Make a todo list app', checked: true },\n  { title: 'Predict the weather', checked: false },\n  { title: 'Play some tunes', checked: false },\n  { title: 'Let\\'s get cooking', checked: false },\n  { title: 'Pump some iron', checked: false },\n  { title: 'Track my expenses', checked: false },\n  { title: 'Organise a game night', checked: false },\n  { title: 'Learn a new language', checked: false },\n  { title: 'Publish my work' }\n])\n```", "```js\nconst updateItem = (item: Item): void => {  const updatedItem = findItemInList(item)\n  toggleItemChecked(updatedItem)\n}\nconst findItemInList = (item: Item): Item | undefined => {\n  return listItems.value.find(\n    (itemInList: Item) => itemInList.title === item.title\n  )\n}\nconst toggleItemChecked = (item: Item): void => {\n  item.checked = !item.checked\n}\n```", "```js\nconst updateItem = (item: Item): void => {  const updatedItem = findItemInList(item)\n  if (updatedItem) {\n    toggleItemChecked(updatedItem)\n  }\n}\n```", "```js\n<ListItem :is-checked='item.checked' v-on:click.prevent=\"updateItem(item)\">{{ item.title }}</ListItem>\n```", "```js\nimport { ref, computed function is very similar to ref, in the sense that it follows the same reactivity in updating the DOM when the value changes and you can even access the value using the .value property in the script block! The main difference is that a computed value is cached and only updates when one of the inputs changes.\nFor sorting the list, we can use the `listItems` as input and apply a simple JavaScript sorting function on the array. We can just add this line to define the `computed` value:\n\n```", "```js\n\nAs you can see, `computed` is a function that gets called on a change of the reactive value. In this case, `listItems.value`. We’ll simply apply a `sort` function to the collection.\nIn the template, we can now swap out `listItems` for the `sortedList` variable and you will see that checked items will be placed below the unchecked items.\nPreserving changes to the list\nWe have a final requirement to achieve now, and that is to preserve the state of the list on reloading and revisiting the app. We’ll keep it as simple as we can for now and use the `localStorage` API of the web browser to store and retrieve the state of the list.\nWe’ll first add the functions that we can use to write to `localStorage` and retrieve from `localStorage`:\n\n```", "```js\n\nThese two functions interface with browsers’ abilities to store a string of data, so we need to stringify and parse that object. We’re storing the data on the `list-items` key.\nNow we need to make sure we try and retrieve the data when the component gets loaded. There’s a function for it, called `onMounted` and it is part of the Vue.js core, so we can import it in a similar fashion to the `ref` and `computed` functions.\nThe `onMounted` function is what we call a life cycle hook. They are functions that get called at certain points in the *life cycle* of a component. The main life cycle events are triggered when a component gets mounted (or before), gets updated (or before), gets unmounted (or before), and gives an error. More information can be found here: [https://vuejs.org/api/composition-api-lifecycle.html#composition-api-lifecycle-hooks](https://vuejs.org/api/composition-api-lifecycle.html#composition-api-lifecycle-hooks).\nIn our case, we want the list to be retrieved in the browser when the component gets rendered (it would otherwise have no access to `localStorage`). So, we’ll import the function:\n\n```", "```js\n\n And we need to create a reactive variable to hold the items:\n\n```", "```js\n\n We’ll also create a function (`initListItems`) that will run once when mounted, and move the initialization of the `listItems` there. We’ll also make a change to the declaration of the `listItems` by wrapping it with a check on the existence of `storageItems`. If they do not exist, we will use the `listItems` as default and write the contents to `localStorage`:\n\n```", "```js\n\nNow, we add the following functions to retrieve any locally stored list items:\n\n```", "```js\n\nIn order to keep the changes in sync, we can now modify the `findItemInList` function to look in the `storageItems` collection rather than `listItems` and also write the change to the storage after the item has been updated. We’ll modify the `updateItem` and `findItemInList` functions as follows:\n\n```", "```js\n\nNow, in the template, we’re using a computed value, so we should update the computed function too in order to see `localStorage` as the input for our data:\n\n```", "```js\n\nWe’ve seen how we can use different components with specific uses to build a simple reactive app and how we can organize our code with readability and maintainability in mind. Vue.js encourages using Single File Components to structure your code.\nSingle File Components\nThe way that we have organized the app, with individual components having a single feature to fulfill is referred to as the **Single File Components** (**SFC**) philosophy.\nThis approach is designed to enhance code readability, maintenance, and reusability. With SFC, you can create reusable and modular components that can be easily shared and reused across different projects.\nTo be fair, we did cut some corners with the `TodoList.vue` component, since we could have abstracted the getting and setting of the `listItems` to a different component. For the sake of this example, however, it illustrates the capabilities in an acceptable way. There are no strict rules or guidelines for how you structure your components.\nNote that you can structure or restructure the contents of the script block in a way that makes sense to you. You have the freedom to group related sets together, which makes for very readable code that’s easy to refactor.\nThe Vue.js DevTools\nIf you’ve not yet installed the Vue.js DevTools, please refer back to the *Vue.js DevTools* section in [*Chapter 1*](B19563_01.xhtml#_idTextAnchor015), *Introduction to Vue.js*, to follow the instructions. We will take a close look at the DevTools using our Todo list application for reference.\nIf you have the browser plugin installed and you visit a website where Vue.js is detected, the icon in the toolbar will indicate that Vue.js is detected on that particular URL:\n![Figure 2.4 – Screenshot of Vue DevTools in the browser’s toolbar](img/B19563_02_04.jpg)\n\nFigure 2.4 – Screenshot of Vue DevTools in the browser’s toolbar\nIf you click it, it will refer you to opening the browser’s DevTools, where a tab dedicated to Vue is added.\nThe **Vue.js** tab offers a lot of ways of drilling down into a certain aspect of the rendered code and some time travel inspection methods. It offers an accessible representation of the inputs and outputs of a component, which can help you visualize how a component is rendered.\nSo, let’s zoom in on a particular element, by using the inspect mode.\nInspecting a component\nLet’s see if we can inspect a `ListItem` component. We have several ways of doing this: we can drill down into the DOM tree in the Vue.js panel, we can filter for the component name, and we can use the crosshair button to point out the component on the page.\n![Figure 2.5 – Drilling down into the DOM tree in the Vue.js panel](img/B19563_02_05.jpg)\n\nFigure 2.5 – Drilling down into the DOM tree in the Vue.js panel\nIn *Figure 2**.6*, we’ll use the filtering option to type the name of the component we want filtered. This works well when you’re not exactly sure what the structure of the application looks like.\n![Figure 2.6 – Filtering for the component name](img/B19563_02_06.jpg)\n\nFigure 2.6 – Filtering for the component name\nIn *Figure 2**.7*, we use the crosshair icon to select the element from the browser’s viewport. This works very well when you have a strong visual reference to a component!\n![Figure 2.7 – Using the crosshair to point out a component on the page](img/B19563_02_07.jpg)\n\nFigure 2.7 – Using the crosshair to point out a component on the page\nDepending on your use case, you may prefer one method over the other. For this example, feel free to try all of them out to see their effect.\nWhen you click in the component, you will see additional details, such as the props, extract of the setup function, event listeners, and the `onClick` event we registered with the `v-on` (or `@`) directive.\nApart from inspecting the props that the component was given, we can use the control buttons to scroll to and highlight the component on the page, inspect the render function for that component, highlight the generated DOM code, and even open the source file in the code editor!\n![Figure 2.8 – The various controls of Vue DevTools in the browser extension](img/B19563_02_08.jpg)\n\nFigure 2.8 – The various controls of Vue DevTools in the browser extension\nThose several ways of inspecting components are useful tools when debugging the state of a component. What makes them especially powerful is that you’re looking at the component from within the browser’s environment, which is also how users of your app experience and interact with your application!\nManipulating a component\nApart from inspecting, we can also manipulate the state of a component. We can’t modify the properties of a `ListItem`, since it’s read-only. Let’s take a look at the `TodoList` component.\nIf you inspect it, you’ll see two collections that power the list: the `sortedList` and `storageList` variables.\n![Figure 2.9 – The collections that power the contents of the list](img/B19563_02_09.jpg)\n\nFigure 2.9 – The collections that power the contents of the list\nAgain, `sortedList` is a computed property and cannot be manipulated.\n![Figure 2.10 – The values of the computed sortedList items cannot be modified](img/B19563_02_10.jpg)\n\nFigure 2.10 – The values of the computed sortedList items cannot be modified\nWhen we look at `storageList` and expand the collection, we see some modifiers. We can toggle the `checked` property and update the `title` property. Those changes even propagate to the values of the corresponding `sortedList`!\n![Figure 2.11 – The values of the storageItems items can be modified and propagate to the corresponding sortedList values](img/B19563_02_11.jpg)\n\nFigure 2.11 – The values of the storageItems items can be modified and propagate to the corresponding sortedList values\nWith the browser being dependent on the computed value, it means you see the effect in the browser as well. This is very useful for debugging different variants of the state of the user interface. You can also see the methods that are used in the component, available for inspection.\nIn other scenarios, we will touch upon different uses of Vue DevTools so you will slowly get more familiar with using them to more accurately debug or inspect the applications you build. When debugging any application state that affects the browser, Vue DevTools offers a very good set of features to help you analyze what is happening with the rendering of the application.\nTaking a look at the application, you’ll notice that the first item on our Todo list is checked, which now accurately represents the progress we’ve made. Let’s work on checking off the next items on the list!\nSummary\nAt this point, we’ve used the Vue CLI tool to create and customize our app boilerplate settings. We’ve been using two-way data binding, which translates to the reactivity in our applications. Using and applying the Single File Components philosophy, we can now apply this to build applications that are maintainable at any scale.\nWith Vue DevTools, we have learned a means of inspecting components and can apply this to debug our applications.\nIn the next chapter, we’ll connect our application with external APIs, giving it real-time data to work with.\n\n```"]