- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scaling Performance in Vue.js 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter depends solely on the knowledge of the previous chapters, where
    we explored the different libraries to develop large-scale and enterprise-ready
    applications with Vue.js 3\. This chapter will dive deeper into scaling an extensive
    Vue application. You will learn how to scale performance with asynchronous lazy
    loading, image compression, code splitting, tree shaking, and many other tricks
    to better increase the performance of your Vue.js 3 enterprise-ready application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need Vue.js performance optimization?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary reasons for poor Vue performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking your Vue.js application’s bundle size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the performance of an enterprise Vue application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’ve mastered each of these topics, you will be ready to get stuck into
    building your first enterprise-ready application with Vue 3.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with this chapter, I recommend you read through [*Chapter 1*](B17237_01.xhtml#_idTextAnchor015),
    *Getting Started with Vue.js 3*, where you will get an overview of Vue 3 and the
    Composition API, intensively used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need Vue.js performance optimization?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn why performance stability in an application is
    important and how to develop an application with performance in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an application without taking actionable steps to ensure the stable
    performance of the application can cost the application a lot. Developing an application
    that takes a while to load, navigate, submit, or take any user actions will result
    in losing users, thereby gradually losing on the initial plan of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the end users are not satisfied with the enterprise application’s user
    experience and load time, Vue.js performance, and efficiency. In this case, the
    time invested and the lines of code written don’t matter; the user might not return
    to the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some different facts from Kinsta that show how poor performance can
    affect the performance of an enterprise application on the market: [https://kinsta.com/blog/laravel-caching/](https://kinsta.com/blog/laravel-caching/).'
  prefs: []
  type: TYPE_NORMAL
- en: An online study ([https://kinsta.com/learn/page-speed/#slow-how-slow](https://kinsta.com/learn/page-speed/#slow-how-slow))
    found that it cost Amazon $1.6 billion in sales per year for every 1 second of
    load lag time.
  prefs: []
  type: TYPE_NORMAL
- en: Another Google study ([https://www.thinkwithgoogle.com/future-of-marketing/digital-transformation/the-google-gospel-of-speed-urs-hoelzle/](https://www.thinkwithgoogle.com/future-of-marketing/digital-transformation/the-google-gospel-of-speed-urs-hoelzle/))
    reported that if search results are slow even by a fraction of a second, people
    will search less. What this means is that a 400-millisecond delay leads to a 0.44%
    drop in search volume.
  prefs: []
  type: TYPE_NORMAL
- en: A further study shows that four out of five internet users will click away if
    a video stalls while loading.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding study shows that a slight sluggishness in your web page load time
    can have a massive impact on your users’ experience and the loss of a huge amount
    of funds.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know why we need performance stability in our application, in the
    next section, let’s look at the primary reasons behind poor Vue performance.
  prefs: []
  type: TYPE_NORMAL
- en: The primary reasons for poor Vue performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many known reasons behind poor Vue performance, and we will explore
    the primary and most notable reasons in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The apparent reason for a Vue application slowing down is in the structure.
    As an enterprise application, it’s evident that the bigger the application, the
    slower the application becomes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, one of the significant reasons behind poor performance in enterprise
    Vue applications may vary in different projects and how they deal with **server-side**
    **rendering** (**SSR**).
  prefs: []
  type: TYPE_NORMAL
- en: The primary reason for poor performance in any Vue **single-page application**
    (**SPA**) or SSR enterprise application is the bundle size. The larger the bundle
    size, the slower the Vue performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other common reasons behind poor performance in enterprise Vue applications,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Not structuring the CSS and JS files properly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not using third-party libraries wisely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwanted hits to API requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overlooking code splitting and lazy loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more reasons for poor performance, and we have just listed a few.
    Before we discuss how to resolve them, let’s explore how to check for the bundle
    size of an enterprise Vue application in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Checking your Vue application’s bundle size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bundle size is the total size of your Vue application that will be loaded
    by the browser. The larger the size, the slower your application loads.
  prefs: []
  type: TYPE_NORMAL
- en: There are two different ways to check your Vue bundle size when working with
    the Vue framework.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through each of these methods in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the `build` command with the `--report` flag to generate your application
    report. This method gives a visual representation of all the packages used and
    each bundle size. Further, with the information generated from this visual report,
    you can figure out how to replace any package that takes up more space and size
    than expected.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the `build` command will only build a report when `webpack-bundle-analyzer`
    is installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a report for your application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the package with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a script for the command in your `package.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And lastly, execute the following command to generate the report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running the preceding command, a file named `report.html` is created
    inside the `dist` folder. When you open the file, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.1 – Application bundle-size\uFEFF report](img/Figure_3.01_B17237.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Application bundle-size report
  prefs: []
  type: TYPE_NORMAL
- en: Running the npm build command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running the `build` method of your Vue application will generate a list of
    different chunks and bundle sizes. From this information, you can see additional
    warnings concerning which chunk has a bigger bundle size and how you can improve
    it. Here’s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Chunks and bundle sizes](img/Figure_3.02_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Chunks and bundle sizes
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned why we need Vue.js performance optimization, the
    primary reasons for poor performance, and the different ways to check Vue.js bundle
    size.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to optimize the performance of a Vue
    application using different standard methods.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the performance of an enterprise Vue application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the downsides of creating an enterprise application is the size of the
    application regarding the code base, the data size, and the speed it takes to
    respond to users’ actions.
  prefs: []
  type: TYPE_NORMAL
- en: One solution could be to implement a proper caching mechanism on both the backend
    and frontend of the enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: You will agree that it’s challenging to develop an application. Still, it is
    more challenging to create an application with optimized performance or even solve
    the performance bottleneck of an enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at some tips that you can implement to improve
    the performance of your enterprise Vue application.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous/lazy component loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with asynchronous/lazy components loading to lessen your challenges
    to explore Vue.js performance optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous/lazy components loading in Vue.js is a term used to describe loading
    modules/components when the user needs a module/component. In an enterprise application,
    it is unnecessary to load all the modules from the JavaScript bundle whenever
    the user visits the website, as doing so will cause a performance bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: In enterprise projects, you will agree that there are complex components with
    many modals, tooltips, and other interconnected components that will slow down
    the performance of your application if not lazy loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we explore how to lazy load components, you can check the actual JavaScript
    code used on your web page by following these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **DevTools**. The following screen will appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Sample of live DevTools in Chrome](img/Figure_3.03_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Sample of live DevTools in Chrome
  prefs: []
  type: TYPE_NORMAL
- en: Press *Cmd* + *Shift* + *P*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `Coverage`. Once you type it, the following message will appear at the
    bottom of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – A screenshot showing the Coverage tab](img/Figure_3.04_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – A screenshot showing the Coverage tab
  prefs: []
  type: TYPE_NORMAL
- en: Click **Record**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After recording and analyzing the web page, it will highlight some URLs in
    red, which shows that the URLs are not in use and can be lazy-loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – A screenshot showing different URLs when analyzing with DevTools](img/Figure_3.05_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – A screenshot showing different URLs when analyzing with DevTools
  prefs: []
  type: TYPE_NORMAL
- en: If lazy loading is appropriately implemented, the bundle size of your enterprise
    application can be reduced to 60%, thereby increasing the speed of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let’s explore how to enforce lazy loading. We can use Webpack dynamic
    imports over regular imports to separate the chunk of lazily loaded modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, this is how components/modules are imported in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By importing this module this way, Webpack will create a file named `photo.js`
    as a node to the `app.js` file in its dependency graph and bundle it together
    even when the user doesn’t need to use the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'But to improve things a little, we can use dynamic imports or lazy loading
    to achieve and overcome the performance bottleneck with the previous method. The
    following code block shows dynamic/lazy loading in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Lazy loading in Vue.js is one of the best practices to reduce the bundle size
    and optimize performance. Vue recommends that bundles should not exceed a size
    of 244 KiB, but you can also try to optimize your web page to make sure that it’s
    not very slow in performance, even with a bundle size a little higher than recommended.
    Develop a habit of knowing which modules you don’t need unless there’s an explicit
    user action, and download them lazily for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: WebP images and image compression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the primary reasons for large bundle sizes and slow applications is that
    images contribute a lot to an application’s bundle size. If images are not correctly
    optimized, it can increase the loading time of an application when the application
    renders images of considerable sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways to achieve image optimization, and we are going to
    discuss two of the popular methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Compressing images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing **content delivery network** (**CDN**) images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your enterprise application contains small images in number, these images
    will be served locally while applying a different compression algorithm to reduce
    the sizes of each image.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are thousands of online tools to compress images, and the following is
    the list of some popular ones:'
  prefs: []
  type: TYPE_NORMAL
- en: TinyPNG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressnow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image Compressor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adobe Photoshop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, the best compression algorithm used to reduce the si[zes of an image i](https://developers.google.com/speed/webp)s
    the WebP image format ([https://developers.google.com/speed/webp](https://developers.google.com/speed/webp)),
    which is developed and maintained by Google.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing CDN images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A CDN is used to optimize images. It provides transformation features for reducing
    image sizes by up to 70% without affecting the UI and pixelating. It’s also advisable
    to use a CDN when your enterprise application deals with extensive media use.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular CDN tools for image optimization are **Cloudinary** and **ImageKit**.
  prefs: []
  type: TYPE_NORMAL
- en: Media takes a considerable amount of space in any enterprise application and
    therefore can cause lagging and slow performance if not optimized and served appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '[Co](https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting)de splitting'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MDN explains the following ([https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting](https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting)):'
  prefs: []
  type: TYPE_NORMAL
- en: “Code splitting is the splitting of code into various bundles or components
    which can then be loaded on demand or in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: As an application grows in complexity or is maintained, CSS and JavaScripts
    files or bundles grow in byte size, especially as the number and size of included
    third-party libraries increases.”
  prefs: []
  type: TYPE_NORMAL
- en: When creating an enterprise application, there will always be many routes, files,
    and bundles that will increase the byte size of the enterprise application. Code
    splitting is the answer to separating and only loading smaller and on-demand files,
    thereby increasing the load time of your enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s our enterprise application has two pages and we implement it with the
    popular `vue-router` library, as we have here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: // routing.js
  prefs: []
  type: TYPE_NORMAL
- en: import Dashboard from './Dashboard.vue'
  prefs: []
  type: TYPE_NORMAL
- en: import Photo from './Photo.vue'
  prefs: []
  type: TYPE_NORMAL
- en: const routes = [
  prefs: []
  type: TYPE_NORMAL
- en: '{ path: ''/'', component: Dashboard }'
  prefs: []
  type: TYPE_NORMAL
- en: '{ path: ''/photo, component: Photo }'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Due to the coding standard in Vue.js, all the components in our script will
    be downloaded when the user visits any page. This activity causes slow performance
    due to the number of pages, the complexity of each page, and the large bundle
    size.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this issue, we can implement a proper route code splitting that will
    separate our large bundle into different route bundles, meaning each page will
    have its small bundle to download when a user visits that page.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the technique of dynamic imports, rather than importing the components
    directly as demonstrated previously, we can pass the dynamic route and lazy-load
    the component, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: // routing.js
  prefs: []
  type: TYPE_NORMAL
- en: const routes = [
  prefs: []
  type: TYPE_NORMAL
- en: '{ path: ''/'', component: () => import(''./Dashboard.vue'') }'
  prefs: []
  type: TYPE_NORMAL
- en: '{ path: ''/photo, component: () => import(''./Photo.vue'') }'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By following this method, you can halve your bundle size. Also, it is important
    to be sure which components can be used with dynamic imports.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dove deeper into scaling an extensive Vue application. We
    discussed how to scale performance with asynchronous lazy loading, image compression,
    code splitting, tree shaking, and many other tricks to better increase the performance
    of your Vue.js 3 enterprise-ready application.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered in detail why performance optimization is needed and what your
    enterprise application can lose if performance is not deliberately built into
    the application. We also discussed the reasons for poor performance in an enterprise
    application and how to fix them.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed how to check our Vue.js application’s bundle size, demonstrating
    this with simple instructions on how to generate package reports using Webpack
    and commands. We also discussed how to understand the report and discover how
    to improve an application from the generated report to further boost our enterprise
    application’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to handle a sizable enterprise-ready
    project, from managing larger file structures to using a micro frontend architecture.
    You will also learn how to handle the internationalization and localization of
    your Vue.js 3 project.
  prefs: []
  type: TYPE_NORMAL
