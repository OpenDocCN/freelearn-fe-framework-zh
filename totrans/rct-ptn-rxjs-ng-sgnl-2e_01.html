<html><head></head><body>
<div id="_idContainer013">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.2.1">Diving into the Reactive Paradigm</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Reactive patterns are reusable solutions to a commonly occurring problem using reactive programming. </span><span class="koboSpan" id="kobo.3.2">Behind all these patterns is a new way of thinking, a new architecture, new coding styles, and new tools. </span><span class="koboSpan" id="kobo.3.3">That’s what this entire book is based on – useful reactive patterns in </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">Angular applications.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Now, I know you are impatient to write your first reactive pattern in Angular, but before doing so, and in order to help you take full advantage of all the RxJS patterns and leverage the reactive paradigm, we will start by explaining in detail all the fundamentals and preparing the groundwork for the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Let’s start with a basic understanding of the reactive paradigm, its advantages, and the problems it solves. </span><span class="koboSpan" id="kobo.7.2">Best of all, let’s put a reactive mindset on and start thinking reactively. </span><span class="koboSpan" id="kobo.7.3">We will begin by highlighting the pillars and the advantages of the reactive paradigm. </span><span class="koboSpan" id="kobo.7.4">Then, we will explain the marble diagram and why it is useful. </span><span class="koboSpan" id="kobo.7.5">Finally, we will highlight the use of RxJS </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">in Angular.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Giving an insight into the fundamentals of the reactive paradigm is incredibly important. </span><span class="koboSpan" id="kobo.9.2">This will ensure you get the basics right, help you understand the usefulness of the reactive approach, and consequently help you determine which situation is best to use </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">it in.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we’re going to cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Exploring the pillars of </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">reactive programming</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Learning the marble diagram (our </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">secret weapon)</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Highlighting the use of RxJS </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">in Angular</span></span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">This chapter does not require any environment setup or </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">installation steps.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">All the code snippets in this chapter are just examples to illustrate the concept, so you will not need the code repository to follow along. </span><span class="koboSpan" id="kobo.22.2">However, if you’re interested, the code for the book can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">at </span></span><a href="https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">This book assumes that you have a basic understanding of Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">and RxJS.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.28.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.29.1">This book uses the new Angular documentation site, </span><a href="http://angular.dev"><span class="koboSpan" id="kobo.30.1">angular.dev</span></a><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">The previous documentation site, </span><a href="http://angular.io"><span class="koboSpan" id="kobo.32.1">angular.io</span></a><span class="koboSpan" id="kobo.33.1">, will soon be deprecated. </span><span class="koboSpan" id="kobo.33.2">Stay connected with the latest updates and resources by accessing the documentation through </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">this link.</span></span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.35.1">Exploring the pillars of reactive programming</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.36.1">Reactive programming</span></strong><span class="koboSpan" id="kobo.37.1"> is </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.38.1">among the major programming paradigms used by developers worldwide. </span><span class="koboSpan" id="kobo.38.2">Every programming paradigm solves some problems and has its own advantages. </span><span class="koboSpan" id="kobo.38.3">By definition, reactive programming is programming with asynchronous data streams and is based on observer patterns. </span><span class="koboSpan" id="kobo.38.4">So, let’s talk about these pillars of </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">reactive programming!</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.40.1">Data streams</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.41.1">Data streams</span></strong><span class="koboSpan" id="kobo.42.1"> are the spine</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.43.1"> of reactive </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.44.1">programming. </span><span class="koboSpan" id="kobo.44.2">Everything that may change or happen over time (you don’t know when exactly) is represented as asynchronous streams such as events, notifications, and messages. </span><span class="koboSpan" id="kobo.44.3">Reactive programming is about reacting to changes as soon as they </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">are emitted!</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">An excellent example of data streams is UI events. </span><span class="koboSpan" id="kobo.46.2">Let’s suppose that we have an HTML button and we want to execute an action whenever a user clicks on it. </span><span class="koboSpan" id="kobo.46.3">Here, we can think of the click event as </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">a stream:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.48.1">
//HTML code
&lt;button id='save'&gt;Save&lt;/button&gt;
//JS code
const saveElement = document.getElementById('save');
saveElement.addEventListener('click', processClick);
function processClick(event) {
  console.log('Hi');
}</span></pre> <p><span class="koboSpan" id="kobo.49.1">As implemented in the preceding code snippet, in order to react to the click event, we register an </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">EventListener</span></strong><span class="koboSpan" id="kobo.51.1"> event. </span><span class="koboSpan" id="kobo.51.2">Then, every time a click occurs, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">processClick</span></strong><span class="koboSpan" id="kobo.53.1"> method is called to execute a side effect. </span><span class="koboSpan" id="kobo.53.2">In our case, we are just logging </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">Hi</span></strong><span class="koboSpan" id="kobo.55.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">As you might have gathered, to be able to react when something happens and execute a side effect, you should listen to the streams to become notified. </span><span class="koboSpan" id="kobo.57.2">To get closer to reactive terminology, instead of </span><em class="italic"><span class="koboSpan" id="kobo.58.1">listen</span></em><span class="koboSpan" id="kobo.59.1">, we can say </span><em class="italic"><span class="koboSpan" id="kobo.60.1">observe</span></em><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">This leads us to the </span><em class="italic"><span class="koboSpan" id="kobo.62.1">observer</span></em><span class="koboSpan" id="kobo.63.1"> design pattern, which is</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.64.1"> at the heart of </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">reactive </span></span><span class="No-Break"><a id="_idIndexMarker004"/></span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">programming.</span></span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.67.1">Observer patterns</span></h2>
<p><span class="koboSpan" id="kobo.68.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">observer pattern</span></strong><span class="koboSpan" id="kobo.70.1"> is based on</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.71.1"> two</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.72.1"> main roles – a publisher and </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">a subscriber:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.74.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">publisher</span></strong><span class="koboSpan" id="kobo.76.1"> maintains a list </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.77.1">of subscribers and notifies them or propagates a change every time there is </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">an update</span></span></li>
<li><span class="koboSpan" id="kobo.79.1">On the other hand, a </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">subscriber</span></strong><span class="koboSpan" id="kobo.81.1"> performs an update or executes a side effect every time they receive a notification from </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">the publisher</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.83.1">The observer pattern is </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">illustrated here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.85.1"><img alt="Figure 1.1 – The observer pattern" src="image/B21180_01_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.86.1">Figure 1.1 – The observer pattern</span></p>
<p><span class="koboSpan" id="kobo.87.1">To get notified about the updates, you need to subscribe to the publisher. </span><span class="koboSpan" id="kobo.87.2">A real-world analogy would be a</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.88.1"> newsletter; you don’t get any</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.89.1"> emails from a specific newsletter if you don’t subscribe </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">This leads us to the building blocks of RxJS, which include </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.93.1">Observables</span></strong><span class="koboSpan" id="kobo.94.1">: These are a representation of the asynchronous data streams that notify the observers of </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">any change</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.96.1">Observers</span></strong><span class="koboSpan" id="kobo.97.1">: These are consumers of the data streams emitted </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">by Observables</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.99.1">RxJS combines the observer pattern with the iterator pattern and functional programming to process and handle asynchronous events. </span><span class="koboSpan" id="kobo.99.2">This was a reminder of reactive programming fundamentals, and it is crucial to know when to put a reactive implementation in place and when to </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">avoid it.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">In general, whenever you have to handle asynchronous tasks in your Angular application, always think of RxJS. </span><span class="koboSpan" id="kobo.101.2">The main advantages of RxJS over other asynchronous APIs are </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.103.1">RxJS makes dealing with event-based programs, asynchronous data calls, and callbacks an </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">easy task.</span></span></li>
<li><span class="koboSpan" id="kobo.105.1">Observables guarantee consistency. </span><span class="koboSpan" id="kobo.105.2">They emit multiple values over time so that you can consume continuous </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">data streams.</span></span></li>
<li><span class="koboSpan" id="kobo.107.1">Observables are lazy; they are not executed until you subscribe to them. </span><span class="koboSpan" id="kobo.107.2">This helps with writing declarative code that is clean, efficient, and easy to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">and maintain.</span></span></li>
<li><span class="koboSpan" id="kobo.109.1">Observables can be canceled, completed, and retrieved at any moment. </span><span class="koboSpan" id="kobo.109.2">This makes a lot of sense in many </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">real-world scenarios.</span></span></li>
<li><span class="koboSpan" id="kobo.111.1">RxJS provides many operators with a functional style to manipulate collections and optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">side effects.</span></span></li>
<li><span class="koboSpan" id="kobo.113.1">Observables push errors to the subscribers and provide a clean way to </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">handle errors.</span></span></li>
<li><span class="koboSpan" id="kobo.115.1">RxJS allows you to write clean and efficient code to handle asynchronous data in </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">your application.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.117.1">Now that we have </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.118.1">given some insight into the </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.119.1">reactive programming pillars and detailed the major advantages of RxJS, let’s explore the marble diagram, which is very handy for understanding and visualizing the </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">Observable execution.</span></span></p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.121.1">Learning about the marble diagram (our secret weapon)</span></h1>
<p><span class="koboSpan" id="kobo.122.1">RxJS ships with </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.123.1">more than one</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.124.1"> hundred </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">operators</span></strong><span class="koboSpan" id="kobo.126.1"> – these are among the building blocks of RxJS, useful for manipulating streams. </span><span class="koboSpan" id="kobo.126.2">All the reactive patterns that will be detailed later in this book are based on operators, and when it comes to explaining operators, it is better to refer to a visual representation – that’s where marble diagrams </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">come in!</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.128.1">Marble diagrams</span></strong><span class="koboSpan" id="kobo.129.1"> are visual representations of the operator’s execution, which will be used in all chapters to understand the behavior of RxJS operators. </span><span class="koboSpan" id="kobo.129.2">At first, it might seem daunting, but it is delightfully simple. </span><span class="koboSpan" id="kobo.129.3">You only have to understand the anatomy of the diagram and then you’ll </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.130.1">be good at reading and </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">translating it.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Marble diagrams represent the execution of an operator, so every diagram will include </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.134.1">Input Observable(s)</span></strong><span class="koboSpan" id="kobo.135.1">: Represents </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.136.1">one or many Observables given as input to </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">the operator</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.138.1">Operator</span></strong><span class="koboSpan" id="kobo.139.1">: Represents the operator to be executed with </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">its parameters</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.141.1">Output Observable</span></strong><span class="koboSpan" id="kobo.142.1">: Represents the Observable produced after the </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">operator’s execution</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.144.1">We can see the execution </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">illustrated here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.146.1"><img alt="Figure 1.2 – The operator execution" src="image/B21180_01_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.147.1">Figure 1.2 – The operator execution</span></p>
<p><span class="koboSpan" id="kobo.148.1">Now, let’s zoom in on the representation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">input/output Observables:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.150.1"><img alt="Figure 1.3 – The marble diagram elements" src="image/B21180_01_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.151.1">Figure 1.3 – The marble diagram elements</span></p>
<p><span class="koboSpan" id="kobo.152.1">The elements of these</span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.153.1"> diagrams include </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.155.1">The timeline</span></strong><span class="koboSpan" id="kobo.156.1">: Observables </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.157.1">are asynchronous streams that produce data over time. </span><span class="koboSpan" id="kobo.157.2">Therefore, the representation of time is crucial in the marble diagram, and it is represented as an arrow flowing from left </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">to right.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.159.1">The marble values</span></strong><span class="koboSpan" id="kobo.160.1">: These are the values emitted by the Observables over time. </span><span class="koboSpan" id="kobo.160.2">They are represented by </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">colored circles.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.162.1">The completion status</span></strong><span class="koboSpan" id="kobo.163.1">: The vertical line (|) represents the successful completion of </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">the Observables.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.165.1">The error status</span></strong><span class="koboSpan" id="kobo.166.1">: The </span><strong class="bold"><span class="koboSpan" id="kobo.167.1">X</span></strong><span class="koboSpan" id="kobo.168.1"> represents an error emitted by the Observable. </span><span class="koboSpan" id="kobo.168.2">Neither the values nor the vertical line representing completion will be </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">emitted thereafter.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.170.1">That’s all the elements you need to know about. </span><span class="koboSpan" id="kobo.170.2">Now, let’s put all the pieces together in a real </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">marble diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.172.1"><img alt="Figure 1.4 – An example of a marble diagram for a custom operator" src="image/B21180_01_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.173.1">Figure 1.4 – An example of a marble diagram for a custom operator</span></p>
<p><span class="koboSpan" id="kobo.174.1">As you may have guessed, we have a custom operator called </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">divideByTwo</span></strong><span class="koboSpan" id="kobo.176.1"> that will emit half of every received number. </span><span class="koboSpan" id="kobo.176.2">When the input Observable emits the values </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">4</span></strong><span class="koboSpan" id="kobo.178.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">8</span></strong><span class="koboSpan" id="kobo.180.1">, the output Observable produces </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">2</span></strong><span class="koboSpan" id="kobo.182.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.184.1"> respectively.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">However, when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">R</span></strong><span class="koboSpan" id="kobo.187.1"> value, which is non-numeric, is emitted, then an error is thrown, indicating abnormal termination. </span><span class="koboSpan" id="kobo.187.2">This case is not handled in the operator code. </span><span class="koboSpan" id="kobo.187.3">The input Observable continues the emission and then completes successfully. </span><span class="koboSpan" id="kobo.187.4">However, the value will never be processed because, after the error, the stream </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">is closed.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">At this point, we’ve </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.190.1">gone through all the elements composing the marble diagram. </span><span class="koboSpan" id="kobo.190.2">You will be able to understand the operators used in the chapters to come. </span><span class="koboSpan" id="kobo.190.3">Now, let’s shed some light on the use of RxJS </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">in Angular.</span></span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.192.1">Highlighting the use of RxJS in Angular</span></h1>
<p><span class="koboSpan" id="kobo.193.1">RxJS is practically a first-class citizen in Angular. </span><span class="koboSpan" id="kobo.193.2">It is part of the Angular ecosystem and is used in many features </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.194.1">to handle asynchronous tasks. </span><span class="koboSpan" id="kobo.194.2">The following are some examples of </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">these features:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.196.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">HttpClient</span></span><span class="No-Break"><a id="_idIndexMarker020"/></span><span class="No-Break"><span class="koboSpan" id="kobo.198.1"> module</span></span></li>
<li><span class="koboSpan" id="kobo.199.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">Router module</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.201.1">Reactive forms</span></span></li>
<li><span class="koboSpan" id="kobo.202.1">The </span><a id="_idIndexMarker021"/><span class="No-Break"><span class="koboSpan" id="kobo.203.1">Event emitter</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.204.1">We will discuss </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.205.1">each of the following concepts in the </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">subsequent subsections.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.207.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.208.1">We recommend taking a quick look at </span><a href="https://angular.dev/overview"><span class="koboSpan" id="kobo.209.1">https://angular.dev/overview</span></a><span class="koboSpan" id="kobo.210.1">, where you can find further details about the </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">aforementioned features.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.212.1">The HttpClient module</span></h2>
<p><span class="koboSpan" id="kobo.213.1">You might be familiar</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.214.1"> with the HttpClient API</span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.215.1"> provided by Angular that is used to communicate with a server over the HTTP protocol. </span><span class="koboSpan" id="kobo.215.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">HttpClient</span></strong><span class="koboSpan" id="kobo.217.1"> service is based on Observables that manage all transactions, which means that the result of calling API methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">GET</span></strong><span class="koboSpan" id="kobo.219.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">PATCH</span></strong><span class="koboSpan" id="kobo.221.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">POST</span></strong><span class="koboSpan" id="kobo.223.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">PUT</span></strong><span class="koboSpan" id="kobo.225.1"> will be </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">an Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">In the following code snippet, we have an example of an Angular service that injects the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">HttpClient</span></strong><span class="koboSpan" id="kobo.229.1"> service and fetches data from the server using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">HttpClient.get()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.231.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable} from 'rxjs';
import { Recipe } from '../model/recipe.model';
@Injectable()
export class RecipesService {
constructor(private http: HttpClient) { }
getRecipes(): Observable&lt;Recipe[]&gt; {
return this.http.get&lt;Recipe[]&gt;(`api/recipes/`);
}
}</span></pre> <p><span class="koboSpan" id="kobo.233.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">getRecipes()</span></strong><span class="koboSpan" id="kobo.235.1"> method – or, to be more accurate, the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">this.http.get&lt;Recipe&gt;(`api/recipes/`)</span></strong><span class="koboSpan" id="kobo.237.1"> – returns an Observable that you should subscribe to in order to send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">GET</span></strong><span class="koboSpan" id="kobo.239.1"> request to the server. </span><span class="koboSpan" id="kobo.239.2">Please note that this is an example of an HTTP transaction, and it is the same for all the other HTTP methods available in the API (</span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">POST</span></strong><span class="koboSpan" id="kobo.241.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">PUT</span></strong><span class="koboSpan" id="kobo.243.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">PATCH</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">, etc.).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.246.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.247.1">The code contains references to </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">recipe.model</span></strong><span class="koboSpan" id="kobo.249.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">getRecipes()</span></strong><span class="koboSpan" id="kobo.251.1"> – in </span><a href="B21180_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.252.1">Chapter 2</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.253.1">, Walking through Our Application</span></em><span class="koboSpan" id="kobo.254.1">, you will be introduced to the Recipe app that we will be working on throughout the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">the book.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">For those familiar with Promise-based HTTP APIs, you may be wondering about the advantages of using Observables in this context. </span><span class="koboSpan" id="kobo.256.2">For those who are not acquainted with Promises, </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">Promises</span></strong><span class="koboSpan" id="kobo.258.1"> are JavaScript objects that represent the eventual completion (or failure) of an asynchronous operation and its resulting value. </span><span class="koboSpan" id="kobo.258.2">They provide a cleaner and more structured way to work with asynchronous code compared to traditional callback-based approaches. </span><span class="koboSpan" id="kobo.258.3">However, there are a lot of advantages of using Observables over Promises, and the most important ones are listed </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.260.1">Observables are cancellable, so you can cancel the HTTP request whenever you want by calling the </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">unsubscribe method</span></span></li>
<li><span class="koboSpan" id="kobo.262.1">You can also retry HTTP requests when an error occurs or an exception </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">is thrown</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.264.1">The</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.265.1"> server’s </span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.266.1">response cannot be mutated by Observables, although this can be the case for chaining </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">then()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.268.1">on Promises.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.269.1">The Router module</span></h2>
<p><span class="koboSpan" id="kobo.270.1">The Router</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.271.1"> module available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">@angular/router</span></strong><span class="koboSpan" id="kobo.273.1"> package</span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.274.1"> uses Observables in router events and activated routes. </span><span class="koboSpan" id="kobo.274.2">We will look at </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">both here.</span></span></p>
<h3><span class="koboSpan" id="kobo.276.1">Router events</span></h3>
<p><span class="koboSpan" id="kobo.277.1">Router events</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.278.1"> allow you to intercept the navigation life cycle. </span><span class="koboSpan" id="kobo.278.2">They are defined in the Router </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">as Observables.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.280.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.281.1">We recommend taking a quick look at </span><a href="https://angular.dev/api/router/Event"><span class="koboSpan" id="kobo.282.1">https://angular.dev/api/router/Event</span></a><span class="koboSpan" id="kobo.283.1">, where you can find further details about </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">router events.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">The majority of Angular applications have a routing mechanism. </span><span class="koboSpan" id="kobo.285.2">Router events change frequently over time, and it makes sense to listen to changes to execute side effects. </span><span class="koboSpan" id="kobo.285.3">That’s why Observables are a flexible way in which to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">those streams.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">To intercept all the events the router goes through, first, you should inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">Router</span></strong><span class="koboSpan" id="kobo.289.1"> service, which provides URL manipulation capabilities. </span><span class="koboSpan" id="kobo.289.2">Then, subscribe to the events Observable available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">Router</span></strong><span class="koboSpan" id="kobo.291.1"> object and filter the events of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">RouterEvent</span></strong><span class="koboSpan" id="kobo.293.1"> using the RxJS </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">filter operator.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">The following is an example of an Angular service that injects the Router in the constructor, subscribes to the router events, and traces the event ID and path in </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">the console:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.297.1">
import { Injectable } from '@angular/core';
import { Router, RouterEvent } from '@angular/router';
import { filter } from 'rxjs/operators';
@Injectable()
export class CustomRouteService {
  constructor(public router: Router) {
    this.router.events.pipe(
      filter(event =&gt; event instanceof RouterEvent)
    ).subscribe((event: RouterEvent) =&gt; {
      console.log(`The current event is : ${event.id} |
        event.url`);
    });
  }
}</span></pre> <p><span class="koboSpan" id="kobo.298.1">This is a very basic </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.299.1">example, and you could introduce pretty much any specific behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">to it.</span></span></p>
<h3><span class="koboSpan" id="kobo.301.1">The activated route</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">ActivatedRoute</span></strong><span class="koboSpan" id="kobo.303.1"> is a router </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.304.1">service that you can inject into your components to retrieve information about a route’s path and parameters. </span><span class="koboSpan" id="kobo.304.2">Many properties are based on Observables. </span><span class="koboSpan" id="kobo.304.3">Here, you will find the implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">ActivatedRoute</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.306.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.307.1">
class ActivatedRoute {
  snapshot: ActivatedRouteSnapshot
  url: Observable&lt;UrlSegment[]&gt;
  params: Observable&lt;Params&gt;
  queryParams: Observable&lt;Params&gt;
  fragment: Observable&lt;string | null&gt;
  data: Observable&lt;Data&gt;
  outlet: string
  component: Type&lt;any&gt; | string | null
  routeConfig: Route | null
  root: ActivatedRoute
  parent: ActivatedRoute | null
  firstChild: ActivatedRoute | null
  children: ActivatedRoute[]
  pathFromRoot: ActivatedRoute[]
  paramMap: Observable&lt;ParamMap&gt;
  queryParamMap: Observable&lt;ParamMap&gt;
  toString(): string
}</span></pre> <p><span class="koboSpan" id="kobo.308.1">As you may have figured out, </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">url</span></strong><span class="koboSpan" id="kobo.310.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">params</span></strong><span class="koboSpan" id="kobo.312.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">queryParams</span></strong><span class="koboSpan" id="kobo.314.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">fragment</span></strong><span class="koboSpan" id="kobo.316.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">data</span></strong><span class="koboSpan" id="kobo.318.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">paramMap</span></strong><span class="koboSpan" id="kobo.320.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">queryParamMap</span></strong><span class="koboSpan" id="kobo.322.1"> are represented as Observables. </span><span class="koboSpan" id="kobo.322.2">All these parameters might change over time, so it makes sense to listen to these changes to register side effects or update </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">the values.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">Here’s an example of an Angular component that injects the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">ActivatedRoute</span></strong><span class="koboSpan" id="kobo.326.1"> class in the constructor</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.327.1"> and then in </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">ngOnInit()</span></strong><span class="koboSpan" id="kobo.329.1"> method, subscribes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">following properties:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.331.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">url</span></strong><span class="koboSpan" id="kobo.333.1"> property of </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">ActivatedRoute</span></strong><span class="koboSpan" id="kobo.335.1">, in order to log the current URL in </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">the console</span></span></li>
<li><span class="koboSpan" id="kobo.337.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">queryParams</span></strong><span class="koboSpan" id="kobo.339.1"> property of </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">ActivatedRoute</span></strong><span class="koboSpan" id="kobo.341.1">, in order to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">criteria</span></strong><span class="koboSpan" id="kobo.343.1"> parameter and store it in a local property </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">criteria</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
@Component({
  selector: 'app-recipes',
  templateUrl: './recipes.component.html'
})
export class RecipesComponent implements OnInit {
  criteria: string;
  constructor(private activatedRoute: ActivatedRoute) { }
  ngOnInit() {
    this.activatedRoute.url
      .subscribe(url =&gt; console.log('The URL changed to: '
        + url));
    this.activatedRoute.queryParams.subscribe(params =&gt; {
      this.processCriteria(params.criteria);
    });
  }
  processCriteria(criteria: string) {
    this.criteria = criteria;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.348.1">This example showcases the usage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">url</span></strong><span class="koboSpan" id="kobo.350.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">queryParams</span></strong><span class="koboSpan" id="kobo.352.1"> properties. </span><span class="koboSpan" id="kobo.352.2">For a comprehensive</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.353.1"> overview of all </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">ActivatedRoute</span></strong><span class="koboSpan" id="kobo.355.1"> properties and their functionalities, I encourage you to visit the Angular documentation page </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">at </span></span><a href="https://angular.dev/api/router/ActivatedRoute#properties"><span class="No-Break"><span class="koboSpan" id="kobo.357.1">https://angular.dev/api/router/ActivatedRoute#properties</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.358.1">.</span></span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.359.1">Reactive forms</span></h2>
<p><span class="koboSpan" id="kobo.360.1">Reactive forms </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.361.1">available under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">@angular/forms</span></strong><span class="koboSpan" id="kobo.363.1"> package</span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.364.1"> are based on Observables to track form control changes. </span><span class="koboSpan" id="kobo.364.2">Here’s the overview of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">FormControl</span></strong><span class="koboSpan" id="kobo.366.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">in Angular:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
class FormControl extends AbstractControl {
//other properties here
valueChanges: Observable&lt;any&gt;
s</span><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.369.1">tatusChanges: Observable&lt;any&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.370.1">The properties </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">valueChanges</span></strong><span class="koboSpan" id="kobo.372.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">statusChanges</span></strong><span class="koboSpan" id="kobo.374.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">FormControl</span></strong><span class="koboSpan" id="kobo.376.1"> are represented as Observables that trigger change events. </span><span class="koboSpan" id="kobo.376.2">Subscribing to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">FormControl</span></strong><span class="koboSpan" id="kobo.378.1"> value change is a way of triggering application logic within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">component</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.380.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Here’s an example that subscribes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">valueChanges</span></strong><span class="koboSpan" id="kobo.383.1"> Observable of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">FormControl</span></strong><span class="koboSpan" id="kobo.385.1"> property </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.386.1">called </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">rating</span></strong><span class="koboSpan" id="kobo.388.1"> and simply traces</span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.389.1"> the value </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">through </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">console.log(value)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.393.1">
import { Component, OnInit } from '@angular/core';
import { FormGroup } from '@angular/forms';
@Component({ ...})
export class MyComponent implements OnInit {
  form!: FormGroup;
  ngOnInit() {
    const ratingControl = this.form.get('rating');
    ratingControl?.valueChanges.subscribe(
      (value) =&gt; {
        console.log(value);
      }
    );
  }
}</span></pre> <p><span class="koboSpan" id="kobo.394.1">This way, you will </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.395.1">get the changed value as </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">an output.</span></span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.397.1">The Event emitter</span></h2>
<p><span class="koboSpan" id="kobo.398.1">The event emitter, which</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.399.1"> is part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">@angular/core</span></strong><span class="koboSpan" id="kobo.401.1"> package, is</span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.402.1"> used to emit data from a child component to a parent component through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">@Output()</span></strong><span class="koboSpan" id="kobo.404.1"> decorator. </span><span class="koboSpan" id="kobo.404.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">EventEmitter</span></strong><span class="koboSpan" id="kobo.406.1"> class extends the RxJS subject and registers handlers for events emitted by </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">this instance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.408.1">
class EventEmitter&lt;T&gt; extends Subject {
  constructor(isAsync?: boolean): EventEmitter&lt;T&gt;
  emit(value?: T): void
  subscribe(next?: (value: T) =&gt; void, error?: (error: any)
    =&gt; void, complete?: () =&gt; void): Subscription
}</span></pre> <p><span class="koboSpan" id="kobo.409.1">This is what happens under the hood when you create an event emitter and emit </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">a value.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">The following code block is an example of emitting the updated value of a </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">recipe rating:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
import { Component, Output } from '@angular/core';
import { EventEmitter } from 'events';
@Component({ ...})
export class RecipesComponent {
  constructor() {}
  @Output() updateRating = new EventEmitter();
  updateRecipe(value: string) {
    </span><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.414.1">this.updateRating.emit(value);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.415.1">So, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">EventEmitter</span></strong><span class="koboSpan" id="kobo.417.1"> smooths communication between components by allowing one component to emit custom events and another component to listen for and respond to those events. </span><span class="koboSpan" id="kobo.417.2">This mechanism plays a crucial role in enabling parent-child communication, sibling communication, and even communication between unrelated components in</span><a id="_idIndexMarker041"/> <span class="No-Break"><span class="koboSpan" id="kobo.418.1">Angular </span></span><span class="No-Break"><a id="_idIndexMarker042"/></span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">applications.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.420.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.421.1">In the previous code snippets, the subscription to the Observables was done explicitly for demonstration purposes. </span><span class="koboSpan" id="kobo.421.2">In a real-world example, we should include the unsubscription logic if we want to subscribe explicitly. </span><span class="koboSpan" id="kobo.421.3">We will shed light on this in </span><a href="B21180_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.422.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.423.1">, </span><em class="italic"><span class="koboSpan" id="kobo.424.1">Fetching Data </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.425.1">as Streams</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">.</span></span></p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.427.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.428.1">In this chapter, we walked you through the fundamentals of reactive programming and in which use cases it shines. </span><span class="koboSpan" id="kobo.428.2">Then, we explained the marble diagram that will be our reference for explaining RxJS operators in all the following chapters. </span><span class="koboSpan" id="kobo.428.3">Finally, we highlighted the use of reactive programming in Angular by illustrating concrete examples, implementations, </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">and advantages.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">Now that we have got the basics right, it is time to start preparing and explaining, in the next chapter, the application that we are going to build throughout this book, where we are going to implement all of the reactive patterns we will </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">learn progressively.</span></span></p>
</div>
</body></html>