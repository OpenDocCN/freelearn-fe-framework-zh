- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Filtering and Searching Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤和搜索数据
- en: In this chapter, we’ll continue applying the techniques we’ve already learned
    to another, more complex use case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续将我们已学到的技术应用到另一个更复杂的使用案例中。
- en: As we work through the chapter, we’ll learn how to adjust a component’s design
    using tests to show us where the design is lacking. Test-driven development really
    helps highlight design issues when the tests get knarly. Luckily, the tests we’ve
    already written give us the confidence to change course and completely reinvent
    our design. With each change, we simply run `npm test` and have our new implementation
    verified in a matter of seconds.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习本章内容的过程中，我们将学习如何通过测试调整组件的设计，以显示设计中的不足。测试驱动开发在测试变得复杂时，真正有助于突出设计问题。幸运的是，我们已编写的测试给了我们信心改变方向并完全重新设计。每次更改时，我们只需运行`npm
    test`，并在几秒钟内验证我们的新实现。
- en: In the current workflow, users start by adding a new customer and then immediately
    book an appointment for that customer. Now, we’ll expand on that by allowing them
    to choose an existing customer before adding an appointment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的流程中，用户首先添加一个新客户，然后立即为该客户预订一个预约。现在，我们将在此基础上扩展，允许他们在添加预约之前选择一个现有客户。
- en: We want users to be able to quickly search through customers. There could be
    hundreds, maybe thousands, of customers registered with this salon. So, we’ll
    build a `CustomerSearch` search component that will allow our users to search
    for customers by name and to page through the returned results.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户能够快速搜索客户。这个沙龙可能有数百甚至数千名注册客户。因此，我们将构建一个`CustomerSearch`搜索组件，允许我们的用户通过姓名搜索客户并浏览返回的结果。
- en: 'In this chapter, you’ll learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下主题：
- en: Displaying tabular data fetched from an endpoint
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示从端点获取的表格数据
- en: Paging through a large dataset
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型数据集中分页
- en: Filtering data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据过滤
- en: Performing actions with render props
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用渲染属性执行操作
- en: 'The following screenshot shows how the new component will look:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了新组件的外观：
- en: '![Figure 10.1 – The new CustomerSearch component ](img/Figure_10.01_B18423.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 新的CustomerSearch组件](img/Figure_10.01_B18423.jpg)'
- en: Figure 10.1 – The new CustomerSearch component
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 新的CustomerSearch组件
- en: By the end of the chapter, you’ll have built a relatively complex component
    using all the techniques you’ve learned so far.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将使用到目前为止所学到的所有技术构建一个相对复杂的组件。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter10)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter10)'
- en: Displaying tabular data fetched from an endpoint
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示从端点获取的表格数据
- en: In this section, we’ll get the basic form of the table in place, with an initial
    set of data retrieved from the server when the component is mounted.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置表格的基本形式，并在组件挂载时从服务器检索初始数据集。
- en: 'The server `GET` requests to `/customers`. There is a `searchTerm` parameter
    that takes the string the user is searching for. There is also an `after` parameter
    that is used to retrieve the next page of results. The response is an array of
    customers, as shown here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器对`/customers`的`GET`请求。有一个`searchTerm`参数，它接受用户正在搜索的字符串。还有一个`after`参数，用于检索下一页的结果。响应是一个客户数组，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Sending a request to `/customers` with no parameters will return the first 10
    of our customers, in alphabetical order by first name.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 发送不带参数的请求到`/customers`将返回我们客户的头10个，按姓氏字母顺序排列。
- en: This gives us a good place to start. When the component mounts, we’ll perform
    this basic search and display the results in a table.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个良好的起点。当组件挂载时，我们将执行这个基本搜索并在表格中显示结果。
- en: Skipping the starting point
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过起点
- en: If you’re following along using the GitHub repository, be aware that this chapter
    starts with a barebones `CustomerSearch` component already implemented, and it
    has already been hooked up to the `App` component. The component is displayed
    by clicking on the **Search appointments** button in the top menu.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用GitHub仓库进行跟随，请注意，本章从已经实现且已连接到`App`组件的裸骨`CustomerSearch`组件开始。该组件通过点击顶部菜单中的**搜索预约**按钮显示。
- en: 'Let’s start with our first test for the new `CustomerSearch` component. Follow
    these steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对新的`CustomerSearch`组件的第一个测试开始。按照以下步骤操作：
- en: 'Open `test/CustomerSearch.test.js` and add the first test. It checks that a
    table has been rendered with the four headings that we want to see. The code is
    illustrated in the following snippet:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`test/CustomerSearch.test.js`并添加第一个测试。它检查是否渲染了我们想要看到的四个标题的表格。代码如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That test should be simple to pass with the following definition for `CustomerSearch`
    in `src/CustomerSearch.js`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该测试应该很容易通过，以下是在`src/CustomerSearch.js`中对`CustomerSearch`的以下定义：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to display data, the component will need to make a `GET` request.
    Write out this next test, which specifies that behavior:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了显示数据，组件需要执行一个`GET`请求。编写出这个下一个测试，它指定了该行为：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To make that pass, add a `useEffect` hook to the component that performs the
    search. We need to use the same `useEffect` ceremony that we’ve seen before, using
    an inline function to ensure we don’t return a value and passing an empty array
    to the dependency list, which ensures the effect only runs when the component
    is first mounted. The code is illustrated in the following screenshot:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这一步通过，向组件添加一个执行搜索的`useEffect`钩子。我们需要使用之前看到的相同的`useEffect`仪式，使用内联函数以确保我们不返回值，并将空数组传递给依赖项列表，这确保了效果仅在组件首次挂载时运行。代码如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, it’s time to code what happens depending on the data returned. We’ll start
    by figuring out the display of a single row of data. Add a definition of `oneCustomer`
    at the top of the file, above the `describe` block, as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候编写根据返回的数据发生的事情的代码了。我们将从确定单行数据的显示开始。在文件顶部，在`describe`块上方添加`oneCustomer`的定义，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Make use of that definition in the next test, shown in the following code snippet,
    which verifies that the component displays all the customer data for a single
    customer row:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个测试中，使用该定义，如下所示，该测试验证组件显示单个客户行的所有客户数据：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To make this pass, we’ll need to use component state to pass data back from
    the `useEffect` hook into the next render cycle. Create a new state variable,
    `customers`, which has an initial value of the empty array (`[]`), as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这一步通过，我们需要使用组件状态将数据从`useEffect`钩子传递到下一个渲染周期。创建一个新的状态变量`customers`，其初始值为空数组（`[]`），如下所示：
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save the results of the search into `customers` by modifying the definition
    of `useEffect`, as shown here:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将搜索结果保存到`customers`中，通过修改`useEffect`的定义，如下所示：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We’re ready to display the data. We’ll do that with a new `CustomerRow` component
    that is responsible for displaying a single row of customer information. Add its
    implementation above the definition of `CustomerSearch`. Notice here how the final
    column is blank; it will hold action buttons that perform various operations on
    the specific customer record. We’ll use a separate test later to fill out that
    functionality:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备好显示数据了。我们将使用一个新的`CustomerRow`组件来显示单个客户信息的一行。在`CustomerSearch`定义上方添加其实现。注意这里最后一列是空的；它将包含执行特定客户记录上各种操作的按钮。我们将在稍后的单独测试中填充该功能：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All that’s left is to make use of this new component in `CustomerSearch`. Add
    the following `tbody` element, which renders `CustomerRow` for the first customer,
    if it exists. After adding this code, your test should now be passing:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的就是在这个`CustomerSearch`中利用这个新组件。添加以下`tbody`元素，如果存在，则渲染第一个客户的`CustomerRow`。添加此代码后，你的测试现在应该通过了：
- en: '[PRE10]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the final test in this section, let’s add a test to show that this works
    for multiple customers. For that, we need a new result set: `twoCustomers`. This
    can be placed at the top of the file, after `oneCustomer`, as shown in the following
    code snippet:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于本节最后的测试，让我们添加一个测试来显示这适用于多个客户。为此，我们需要一个新的结果集：`twoCustomers`。这可以放在文件顶部，在`oneCustomer`之后，如下所示：
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, add a test that makes use of this and checks that two rows are rendered,
    as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一个测试，利用这个功能并检查是否渲染了两行，如下所示：
- en: '[PRE12]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Making this pass is a one-liner; change the JSX to map over each customer,
    instead of pulling out just the first customer:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使这一步通过只需要一行代码；将JSX更改为映射每个客户，而不是仅提取第一个客户：
- en: '[PRE13]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This gives us a great base to build on for the remaining functionality we’ll
    build in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们构建本章剩余功能提供了一个很好的基础。
- en: In the next section, we’ll introduce the ability to move between multiple pages
    of search results.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍在多个搜索结果页面之间切换的能力。
- en: Paging through a large dataset
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在大型数据集中分页
- en: By default, our endpoint returns 10 records. To get the next 10 records, we
    can page through the result set by using the `after` parameter, which represents
    the last customer identifier seen. The server will skip through results until
    it finds that ID and returns results from the next customer onward.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的端点返回10条记录。为了获取下一组10条记录，我们可以通过使用表示已看到最后一个客户标识符的`after`参数来分页结果集。服务器将跳过结果，直到找到该ID，然后从下一个客户开始返回结果。
- en: We’ll add `after` parameter to the next search request.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个搜索请求中添加`after`参数。
- en: To support `after` IDs that we can pop each time the user clicks **Previous**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持每次用户点击**Previous**时可以弹出的`after` ID。
- en: Adding a button to move to the next page
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个按钮以跳转到下一页
- en: 'Let’s start with the `buttonWithLabel` helper that will match a button with
    that label. Follow these steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`buttonWithLabel`辅助函数开始，该函数将匹配具有该标签的按钮。按照以下步骤操作：
- en: 'In `test/reactTestExtensions.js`, add the following new helper function at
    the bottom of the file:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/reactTestExtensions.js`文件底部添加以下新的辅助函数：
- en: '[PRE14]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Back in `test/CustomerSearch.test.js`, update the import statement to include
    this new helper function, like so:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/CustomerSearch.test.js`中，更新导入语句以包括此新辅助函数，如下所示：
- en: '[PRE15]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Write the following test, which will let us get a **Next** button onto the
    page:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下测试，这将使我们能够在页面上获得一个**Next**按钮：
- en: '[PRE16]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a `SearchButtons` component that renders the `menu` element, just as
    we did in `App`. We’ll be expanding this menu bar with more buttons in subsequent
    tests. The code is illustrated here:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`SearchButtons`组件，渲染`menu`元素，就像我们在`App`中做的那样。我们将在后续测试中扩展此菜单栏，添加更多按钮。代码如下所示：
- en: '[PRE17]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, render that in `CustomerSearch`, above the table, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`CustomerSearch`中表格上方渲染它，如下所示：
- en: '[PRE18]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When the button is clicked, we want to take the last customer ID already displayed
    and send that back to the server. To make that choice obvious in our tests, we’ll
    use a new return value named `tenCustomers`, which mimics the default number of
    records coming back from the server API. Place this definition of `tenCustomers`
    at the top of the file, next to your other customer definitions, like so:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按钮被点击时，我们希望获取已显示的最后客户ID并将其发送回服务器。为了使我们的测试中这个选择明显，我们将使用一个新的返回值`tenCustomers`，该值模仿从服务器API返回的默认记录数。将此`tenCustomers`定义放置在文件顶部，靠近你的其他客户定义，如下所示：
- en: '[PRE19]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Making good use of Array.from
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 充分利用Array.from
- en: This definition uses a “clever” version of the `Array.from` function that takes
    each character of the string and creates an object using that character as input.
    We end up with 10 objects, each with an `id` property ranging from `0` to `9`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此定义使用了一个“巧妙”版本的`Array.from`函数，它将字符串的每个字符作为输入创建一个对象。我们最终得到10个对象，每个对象都有一个从`0`到`9`的范围的`id`属性。
- en: 'The next test checks that when the `GET` request with the last seen customer
    ID. Given our previous definition of `tenCustomers`, that is the customer with
    ID `9`. Notice in the following code snippet how `toHaveBeenLastCalledWith` is
    needed since this will be the second call to `global.fetch`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个测试检查当带有最后看到客户ID的`GET`请求。根据我们之前的`tenCustomers`定义，这是ID为`9`的客户。注意以下代码片段中`toHaveBeenLastCalledWith`的必要性，因为这将是对`global.fetch`的第二次调用：
- en: '[PRE20]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Avoiding unnecessary fields to highlight important implications
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 避免不必要的字段以突出重要含义
- en: 'The `tenCustomers` value is only a partial definition for each customer: only
    the `id` property is included. That’s not lazy: it’s intentional. Because the
    logic of taking the last ID is non-obvious, it’s important to highlight the `id`
    property as the key feature of this flow. We won’t worry about the other fields
    because our previous tests check their correct usage.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`tenCustomers`值只是每个客户的部分定义：只包含`id`属性。这不是懒加载：这是故意的。因为获取最后一个ID的逻辑不明显，所以突出`id`属性作为此流程的关键特性很重要。我们不会担心其他字段，因为我们的先前测试检查了它们的正确使用。'
- en: 'To make this pass, define a handler for the `fetch` request. It calculates
    the `after` request parameter by taking the last customer in the `customers` state
    variable, as illustrated in the following code snippet:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个通过，定义一个处理`fetch`请求的处理程序。它通过以下代码片段中所示的方式计算`after`请求参数，即从`customers`状态变量中获取最后一个客户：
- en: '[PRE21]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Give `SearchButtons` a `handleNext` prop and set that as the `onClick` handler
    on the button, like so:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给`SearchButtons`一个`handleNext`属性，并将其设置为按钮上的`onClick`处理程序，如下所示：
- en: '[PRE22]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Hook the handler up to `SearchButtons`, as follows. After this change, your
    test should be passing:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处理程序连接到`SearchButtons`，如下所示。此更改后，你的测试应该可以通过：
- en: '[PRE23]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Continue by adding the following test. It sets up two `fetch` responses using
    a sequence of `mockResolvedValueOnce` followed by `mockResolvedValue`. The second
    response only contains one record. The test asserts that this record is displayed
    after pressing the **Next** button:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续添加以下测试。它使用一系列`mockResolvedValueOnce`后跟`mockResolvedValue`来设置两个`fetch`响应。第二个响应只包含一条记录。测试断言在按下**下一步**按钮后显示此记录：
- en: '[PRE24]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To make this pass, modify `handleNext` to save its response into the `customers`
    state variable, as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个通过，修改`handleNext`以将其响应保存到`customers`状态变量中，如下所示：
- en: '[PRE25]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That’s it for our **Next** button. Before we move on to the **Previous** button,
    we need to correct a design issue.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的**下一步**按钮来说，这就结束了。在我们继续到**上一页**按钮之前，我们需要纠正一个设计问题。
- en: Adjusting the design
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整设计
- en: 'Look here at the similarities between the `handleNext` and `fetchData` functions.
    They are almost identical; the only place they differ is in the first parameter
    to the `fetch` call. The `handleNext` function has an `after` parameter; `fetchData`
    has no parameters:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看这里`handleNext`和`fetchData`函数之间的相似之处。它们几乎相同；它们唯一的不同之处在于`fetch`调用的第一个参数。`handleNext`函数有一个`after`参数；`fetchData`没有参数：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will be adding a `useEffect` hook’s ability to rerun when the state changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加`useEffect`钩子的能力，使其在状态变化时重新运行。
- en: We will introduce a new state variable, `queryString`, which `handleNext` will
    update and `useEffect` will listen for.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引入一个新的状态变量`queryString`，`handleNext`将更新它，`useEffect`将监听它。
- en: 'Let’s do that now. Proceed as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就来做这件事。按照以下步骤进行：
- en: 'Add that new variable now at the top of the `CustomerSearch` component, as
    shown in the following code snippet. Its initial value is the empty string, which
    is important:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将这个新变量添加到`CustomerSearch`组件的顶部，如下代码片段所示。它的初始值是空字符串，这很重要：
- en: '[PRE27]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Replace `handleNext` with the following function:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`handleNext`替换为以下函数：
- en: '[PRE28]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Update `useEffect` with the following definition, appending `queryString` to
    the **Uniform Resource Locator** (**URL**). Your tests should still be passing
    at this point:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下定义更新`useEffect`，将`queryString`附加到**统一资源定位符**（**URL**）。此时，你的测试应该仍然通过：
- en: '[PRE29]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That’s it for the **Next** button: you’ve seen how to write elegant tests for
    a complex piece of API orchestration logic, and we’ve refactored our production
    code to be elegant, too.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**下一步**按钮来说，你已经看到了如何为复杂的API编排逻辑编写优雅的测试，而且我们也已经重构了我们的生产代码以使其变得优雅。
- en: Adding a button to move to the previous page
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个按钮以跳转到上一页
- en: 'Let’s move on to the **Previous** button:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到**上一页**按钮：
- en: 'Write out the following test:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下测试：
- en: '[PRE30]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Make that pass by modifying `SearchButtons` to include the following button,
    just before the **Next** button:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改`SearchButtons`以包括以下按钮，在**下一步**按钮之前，使其通过：
- en: '[PRE31]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The next test mounts the component, clicks **Next**, and then clicks **Previous**.
    It expects another call to the endpoint to have been made, but this time identical
    to the initial page—in other words, with no query string. The code is illustrated
    here:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个测试挂载组件，点击**下一步**，然后点击**上一页**。它期望对端点的另一个调用已被执行，但这次与初始页面相同——换句话说，没有查询字符串。代码如下所示：
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To make this pass, start by defining a `handlePrevious` function, as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个通过，首先定义一个`handlePrevious`函数，如下所示：
- en: '[PRE33]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Modify `SearchButtons` to take a new `handlePrevious` prop, and set that as
    the `onClick` handler on the new button, like so:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`SearchButtons`以接受一个新的`handlePrevious`属性，并将该属性设置为新按钮的`onClick`处理程序，如下所示：
- en: '[PRE34]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Hook up the handler to `SearchButtons`, like so. After this, your test should
    be passing:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处理程序连接到`SearchButtons`，如下所示。在此之后，你的测试应该通过：
- en: '[PRE35]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The next test is one that’ll require us to do some thinking. It simulates clicking
    `anotherTenCustomers` just after the definition of `tenCustomers`, as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个测试需要我们进行一些思考。它模拟在`tenCustomers`定义之后立即点击`anotherTenCustomers`，如下所示：
- en: '[PRE36]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, add the next test, which checks that the **Previous** button still works
    after navigating to two more pages:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加下一个测试，该测试检查在导航到另外两个页面后，**上一页**按钮仍然有效：
- en: '[PRE37]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We’ll make this pass by maintaining a record of the query strings that were
    passed to the endpoint. For this specific test, we only need to know what the
    *previous* query string was. Add a new state variable to record that, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过维护传递给端点的查询字符串的记录来使这个通过。对于这个特定的测试，我们只需要知道*上一个*查询字符串是什么。添加一个新的状态变量来记录它，如下所示：
- en: '[PRE38]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Forcing design issues
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 强制设计问题
- en: 'You may recognize this as an overly complicated design. Let’s just go with
    it for now: we will simplify this again with another test.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这是一个过于复杂的设计。现在我们先这样进行：我们将在另一个测试中再次简化它。
- en: 'Change `handleNext` to save the previous query string, making sure that this
    happens before the call to `setQueryString`. Include `queryString` in the array
    passed to the second parameter of `useCallback` so that this callback is regenerated
    each time the value of `queryString` changes. The code is illustrated in the following
    snippet:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `handleNext` 修改为保存之前的查询字符串，确保在调用 `setQueryString` 之前完成。将 `queryString` 包含在传递给
    `useCallback` 第二个参数的数组中，以便每次 `queryString` 的值改变时，这个回调都会被重新生成。代码如下所示：
- en: '[PRE39]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, `handlePrevious` can use this value as the query string to pass to `fetchData`,
    as illustrated here. Your test should be passing at this point:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`handlePrevious` 可以使用这个值作为传递给 `fetchData` 的查询字符串，如下所示。此时，你的测试应该已经通过：
- en: '[PRE40]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That’s it for a basic **Previous** button implementation. However, what happens
    when we want to go back two or more pages? Our current design only has a “depth”
    of two additional pages. What if we want to support any number of pages?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基本的 **上一页** 按钮实现。然而，当我们想要后退两页或更多页时会发生什么？我们当前的设计只有两个额外的页面深度。如果我们想支持任意数量的页面怎么办？
- en: Forcing design changes using tests
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试强制设计更改
- en: We can use a test to force the design issue. The process of TDD helps us to
    ensure that we always take time to think about the simplest solution that solves
    all tests. So, if we add one more test that highlights the limits of the current
    design, that test becomes a trigger for us to stop, think, and reimplement.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用测试来强制设计问题。TDD 的过程帮助我们确保我们总是花时间思考最简单的解决方案，以解决所有测试。因此，如果我们添加一个强调当前设计局限性的测试，那么这个测试就成为了我们停止、思考和重新实现的触发器。
- en: In this case, we can use a stack of previous query strings to remember the history
    of pages. We’ll replace our two state variables, `queryString` and `previousQueryString`,
    with a single state variable, `queryStrings`, which is a stack of all previous
    query strings.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用之前查询字符串的堆栈来记住页面的历史。我们将用单个状态变量 `queryStrings` 替换我们的两个状态变量 `queryString`
    和 `previousQueryString`，`queryStrings` 是所有之前查询字符串的堆栈。
- en: 'Let’s get started with the test. Follow these steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始测试。按照以下步骤进行：
- en: 'Add this test, which asserts that the **Previous** button works for multiple
    presses:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试，它断言 **上一页** 按钮可以多次点击：
- en: '[PRE41]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For this to pass, start by adding a new `queryStrings` state variable, deleting
    `queryString` and `previousQueryStrings`, as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过这个测试，首先添加一个新的 `queryStrings` 状态变量，删除 `queryString` 和 `previousQueryStrings`，如下所示：
- en: '[PRE42]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Change `fetchData` as follows. If there are entries in the `queryStrings` array,
    it sets `queryString` to the last entry, and that value is then passed to the
    `fetch` call. If there’s nothing in the array, then `queryString` will be an empty
    string:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改 `fetchData`。如果 `queryStrings` 数组中有条目，它将 `queryString` 设置为最后一个条目，然后该值传递给
    `fetch` 调用。如果没有条目在数组中，那么 `queryString` 将是一个空字符串：
- en: '[PRE43]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Change `handleNext` as follows. It now *appends* the current query string to
    the previous query strings:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改 `handleNext`。现在它将当前的查询字符串 **附加** 到之前的查询字符串堆栈上：
- en: '[PRE44]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Change `handlePrevious` as follows. The last value is *popped off* the query
    string stack:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改 `handlePrevious`。最后一个值是从查询字符串堆栈中 **弹出** 的：
- en: '[PRE45]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You now have a relatively complete implementation for the **Next** and **Previous**
    buttons. You’ve also seen how tests can help you alter your design as you encounter
    issues with it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经有了相对完整的 **下一页** 和 **上一页** 按钮的实现。你也看到了测试如何帮助你遇到问题时改变你的设计。
- en: Next, we’ll continue building out our integration with the `searchTerm` parameter
    of the `/customers` HTTP endpoint.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续构建与 `/customers` HTTP 端点的 `searchTerm` 参数的集成。
- en: Filtering data
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据过滤
- en: In this section, we’ll add a textbox that the user can use to filter names.
    Each character that the user types into the search field will cause a new `fetch`
    request to be made to the server. That request will contain the new search term
    as provided by the search box.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一个文本框，用户可以使用它来过滤名称。用户在搜索字段中输入的每个字符都会导致向服务器发出一个新的 `fetch` 请求。该请求将包含由搜索框提供的新的搜索术语。
- en: 'The `/customers` endpoint supports a parameter named `searchTerm` that filters
    search results using those terms, as shown in the following code snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`/customers` 端点支持一个名为 `searchTerm` 的参数，它使用这些术语过滤搜索结果，如下面的代码片段所示：'
- en: '[PRE46]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let’s start by adding a text field into which the user can input a search term,
    as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加一个文本字段，用户可以在其中输入搜索词，如下所示：
- en: 'Add the following test to the `CustomerSearch` test suite, just below the last
    test. It simply checks for a new field:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到`CustomerSearch`测试套件中，在最后一个测试下方。它只是检查一个新的字段：
- en: '[PRE47]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `CustomerSearch`, update your JSX to add that input element at the top of
    the component, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CustomerSearch`中更新您的JSX，将输入元素添加到组件的顶部，如下所示：
- en: '[PRE48]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we want to check that the `placeholder` attribute for that field is set.
    We can do this by running the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想检查该字段的`placeholder`属性是否已设置。我们可以通过运行以下代码来完成此操作：
- en: '[PRE49]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To make that pass, add the placeholder to the input element in your JSX, like
    so:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，将占位符添加到您的JSX中的输入元素，如下所示：
- en: '[PRE50]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We want to hook this up to the DOM change event: we’ll make an `async` fetch
    request every time the value changes. For that, we’ll need a new helper. In `test/reactTestExtensions.js`,
    add the following definition for `changeAndWait`, just below the definition of
    `change`. This allows us to run effects when the DOM change event occurs:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想将其连接到DOM更改事件：每次值更改时，我们将进行一个`async`的fetch请求。为此，我们需要一个新的辅助函数。在`test/reactTestExtensions.js`中，在`change`定义下方添加以下`changeAndWait`定义。这允许我们在DOM更改事件发生时运行效果：
- en: '[PRE51]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Import the new helper at the top of `test/CustomerSearch.test.js`, like so:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/CustomerSearch.test.js`的顶部导入新的辅助函数，如下所示：
- en: '[PRE52]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Each time a new character is entered into the search box, we should perform
    a new search with whatever text is entered in the textbox. Add the following test:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当在搜索框中输入新字符时，我们应该使用文本框中输入的任何文本执行新的搜索。添加以下测试：
- en: '[PRE53]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Define a new `searchTerm` variable, as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的`searchTerm`变量，如下所示：
- en: '[PRE54]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add a new handler, `handleSearchTextChanged`, as follows. It stores the search
    term in the state because we’ll need to pull it back when moving between pages:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的处理程序，`handleSearchTextChanged`，如下所示。它将搜索词存储在状态中，因为我们将在在不同页面之间移动时需要将其拉回：
- en: '[PRE55]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Hook it up to the input element, like so:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其连接到输入元素，如下所示：
- en: '[PRE56]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we can use the `searchTerm` variable in `fetchData` to fetch the updated
    set of customers from the server, as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`fetchData`中使用`searchTerm`变量从服务器获取更新后的客户集，如下所示：
- en: '[PRE57]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we need to modify `useEffect` by adding `searchTerm` to the dependency
    list, as follows. After this, the test should be passing:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要通过将`searchTerm`添加到依赖列表中来修改`useEffect`，如下所示。之后，测试应该通过：
- en: '[PRE58]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We need to ensure that hitting the **Next** button will maintain our search
    term. Right now, it won’t. We can use the following test to fix that:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确保点击**下一个**按钮将保持我们的搜索词。目前，它不会。我们可以使用以下测试来修复这个问题：
- en: '[PRE59]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To make this pass, let’s force the behavior into `fetchData` with an addition
    to the `if` statement, as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，让我们通过向`if`语句添加一个附加项将行为强制进入`fetchData`，如下所示：
- en: '[PRE60]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We’ve made this test pass... but this is a mess! Any `if` statement with so
    many moving parts (variables, operators, conditions, and so on) is a signal that
    the design isn’t as good as it can be. Let’s fix it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过了这个测试...但这太乱了！任何包含这么多可变部分的`if`语句（变量、运算符、条件等）都是一个信号，表明设计并不像它本可以做到的那样好。让我们来修复它。
- en: Refactoring to simplify the component design
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化组件设计的重构
- en: The issue is the `queryString` data structure and its historical counterpart,
    the `queryStrings` state variable. The construction is complex.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`queryString`数据结构和它的历史对应物，`queryStrings`状态变量。构建是复杂的。
- en: How about we just store the *original data* instead—the ID of the customer in
    the last table row? Then, we can construct the `queryString` data structure immediately
    before fetching, since in reality, `queryString` is an input to the `fetch` request
    only. Keeping the raw data seems like it will be simpler.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否只存储*原始数据*呢——最后表格行中的客户ID？然后，我们可以在实际中立即构建`queryString`数据结构，因为实际上`queryString`只是`fetch`请求的输入。保留原始数据似乎会更简单。
- en: 'Let’s plan out our refactor. At each of the following stages, our tests should
    still be passing, giving us confidence that we’re still on the right path:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们规划一下我们的重构。在以下每个阶段，我们的测试都应该通过，这让我们有信心我们仍然走在正确的道路上：
- en: First, move the query string building logic from `handleNext` into `fetchData`,
    changing the values that are stored in `queryStrings` from query strings to customer
    IDs in the process.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将查询字符串构建逻辑从`handleNext`移动到`fetchData`中，在这个过程中将存储在`queryStrings`中的值从查询字符串更改为客户ID。
- en: Then, change the names of those variables, using your editor’s search and replace
    facility.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用您的编辑器的搜索和替换功能更改那些变量的名称。
- en: Finally, simplify the logic in `fetchData`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，简化`fetchData`中的逻辑。
- en: 'Doesn’t sound so hard, does it? Let’s begin, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来不难，对吧？让我们开始，如下所示：
- en: 'At the top of the component, replace the `queryStrings` variable with this
    new one:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件顶部，将`queryStrings`变量替换为这个新变量：
- en: '[PRE61]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Use your editor’s search and replace facility to change all occurrences of `queryStrings`
    to `lastRowIds`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你编辑器的搜索和替换功能将所有`queryStrings`的出现更改为`lastRowIds`。
- en: Likewise, change the call to `setQueryStrings` to a call to `setLastRowIds`.
    Your tests should still be passing at this point.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，将调用`setQueryStrings`改为调用`setLastRowIds`。在这个阶段，你的测试应该仍然通过。
- en: 'Delete the following line from `handleNext`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`handleNext`中删除以下行：
- en: '[PRE62]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'On the line below that, change the call to `fetchData` to pass in `after` instead
    of the now deleted `newQueryString`, as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一行中，将调用`fetchData`改为传入`after`而不是现在已删除的`newQueryString`，如下所示：
- en: '[PRE63]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the same function, rename `after` `currentLastRowId`. Your tests should still
    be passing at this point.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个函数中，将`after`重命名为`currentLastRowId`。在这个阶段，你的测试应该仍然通过。
- en: 'It’s time to simplify the logic within `fetchData`. Create a `searchParams`
    function that will generate the search parameters for us, given values for `after`
    and `searchTerm`. This can be defined outside of your component. The code is illustrated
    here:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候简化`fetchData`内部的逻辑了。创建一个`searchParams`函数，它将根据`after`和`searchTerm`的值为我们生成搜索参数。这可以在组件外部定义。代码如下所示：
- en: '[PRE64]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, update `fetchData` to use this new function in place of the existing
    query string logic, as shown here. At this point, your tests should be passing,
    with a vastly simpler and easier-to-understand implementation:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，更新`fetchData`以使用这个新函数替换现有的查询字符串逻辑，如下所示。在这个阶段，你的测试应该通过，实现大大简化且易于理解：  '
- en: '[PRE65]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You’ve now built a functional search component. You introduced a new helper,
    `changeAndWait`, and extracted out a `searchParams` function that could be reused
    in other places.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经构建了一个功能性的搜索组件。你引入了一个新的辅助函数`changeAndWait`，并提取了一个`searchParams`函数，该函数可以在其他地方重用。
- en: Next, we’ll add a final mechanism to the `CustomerSearch` component.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向`CustomerSearch`组件添加一个最终机制。
- en: Performing actions with render props
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用渲染属性执行操作
- en: Each row of the table will hold a `AppointmentForm` component, creating an appointment
    for that customer.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表的每一行将包含一个`AppointmentForm`组件，为该客户创建一个预约。
- en: We’ll display these actions by using a `CustomerSearch`. The parent component—in
    our case, `App`—uses this to insert its own rendering logic into the child component.
    `App` will pass a function that displays a button that causes a view transition
    in `App` itself.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用`CustomerSearch`来显示这些操作。父组件——在我们的例子中是`App`——使用这个来将其自己的渲染逻辑插入到子组件中。`App`将传递一个函数，该函数在`App`本身中显示一个按钮，导致视图转换。
- en: Render props are useful if the child component should be unaware of the context
    it’s operating in, such as the workflow that `App` provides.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子组件应该不知道它正在操作的环境，例如`App`提供的流程，那么渲染属性是有用的。
- en: Unnecessarily complex code alert!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 不必要的复杂代码警告！
- en: 'The implementation you’re about to see could be considered more complex than
    it needs to be. There are other approaches to solving this problem: you could
    simply have `CustomerSearch` render `AppointmentFormLoader` directly, or you could
    allow `CustomerSearch` to render the button and then invoke a callback such as
    `onSelect(customer)`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你即将看到的实现可能比必要的更复杂。还有其他解决这个问题的方法：你可以简单地让`CustomerSearch`直接渲染`AppointmentFormLoader`，或者你可以允许`CustomerSearch`渲染按钮，然后调用一个回调，例如`onSelect(customer)`。
- en: Render props are probably more useful to library authors than to any application
    authors since library components can’t account for the context they run within.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染属性可能对库作者更有用，而不是对任何应用程序作者，因为库组件无法考虑到它们运行的上下文。
- en: The testing techniques we need for render props are much more complex than anything
    we’ve seen so far, which you can take as another sign that there are “better”
    solutions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的渲染属性测试技术比我们迄今为止看到的任何技术都要复杂，你可以把这当作“更好的”解决方案的另一个迹象。
- en: 'To begin with, we’ll add the `renderCustomerActions` prop to `CustomerSearch`
    and render it in a new table cell. Follow these steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向`CustomerSearch`添加`renderCustomerActions`属性，并在新的表格单元格中渲染它。按照以下步骤操作：
- en: 'In `test/CustomerSearch.test.js`, write the following test:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/CustomerSearch.test.js`中编写以下测试：
- en: '[PRE66]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Set a default `renderCustomerActions` prop so that our existing tests won’t
    start failing when we begin using the new prop, as follows. This goes at the bottom
    of `src/CustomerSearch.js`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个默认的`renderCustomerActions`prop，这样我们的现有测试在开始使用新prop时不会开始失败，如下所示。这应该在`src/CustomerSearch.js`的底部进行：
- en: '[PRE67]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Destructure that prop in the top line of the `CustomerSearch` component, like
    so:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CustomerSearch`组件的顶部行解构那个prop，如下所示：
- en: '[PRE68]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Pass it through to `CustomerRow`, like so:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它传递给`CustomerRow`，如下所示：
- en: '[PRE69]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In `CustomerRow`, update the fourth `td` cell to call this new prop, as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CustomerRow`中，更新第四个`td`单元格以调用这个新prop，如下所示：
- en: '[PRE70]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'For the next test, we want to check that this render prop receives the specific
    customer record that applies to that row. Here’s how we can do this:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个测试，我们想要检查这个渲染prop是否接收了适用于该行的特定客户记录。我们可以这样做到：
- en: '[PRE71]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To make this pass, all you have to do is update the JSX call that you just
    wrote to include the customer as a parameter, as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个通过，你所要做的就是更新你刚才写的JSX调用，包括客户作为参数，如下所示：
- en: '[PRE72]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: That’s all there is to invoking the render prop inside the `CustomerSearch`
    component. Where it gets difficult is test-driving the implementation of the render
    prop itself, in the `App` component.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是调用`CustomerSearch`组件内的渲染prop的全部内容。难点在于测试驱动`App`组件中渲染prop的实现本身。
- en: Testing render props in additional render contexts
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在额外的渲染上下文中测试渲染prop
- en: Recall that the `App` component has a `view` state variable that determines
    which component the user is currently viewing on the screen. If they are searching
    for customers, then `view` will be set to `searchCustomers`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`App`组件有一个`view`状态变量，它决定了用户当前在屏幕上查看哪个组件。如果他们在搜索客户，那么`view`将被设置为`searchCustomers`。
- en: Pressing the `CustomerSearch` component should have the effect of setting `view`
    to `addAppointment`, causing the user’s screen to hide the `CustomerSearch` component
    and show the `AppointmentForm` component.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 按压`CustomerSearch`组件应该将`view`设置为`addAppointment`，导致用户的屏幕隐藏`CustomerSearch`组件并显示`AppointmentForm`组件。
- en: We also need to set the `App` component’s `customer` state variable to the customer
    that the user just selected in the `CustomerSearch` component.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将`App`组件的`customer`状态变量设置为用户在`CustomerSearch`组件中刚刚选择的客户。
- en: All of this will be done in the render prop that `App` passes to `customer`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都将由`App`传递给`customer`的渲染prop来完成。
- en: 'The big question is: how do we test-drive the implementation of this render
    prop?'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的问题是：我们如何测试驱动这个渲染prop的实现？
- en: 'There are a few different ways we could do it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取几种不同的方法来做这件事：
- en: You could render an actual `CustomerSearch` component within your `App` components,
    navigate to a customer, and click the `App` tests have a module-level mock for
    `CustomerSearch`, you’d need to create a new test suite for those tests, which
    increases maintenance overhead.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在`App`组件内部渲染实际的`CustomerSearch`组件，导航到客户，并点击`App`。如果你有一个模块级别的`CustomerSearch`模拟，你需要为这些测试创建一个新的测试套件，这增加了维护开销。
- en: You could modify the `CustomerSearch` mock to have some mechanism to trigger
    a render prop. This involves making the mock definition more complex than the
    standard form. That is an immediate red flag for me, for the reasons stated in
    [*Chapter 7*](B18423_07.xhtml#_idTextAnchor125), *Testing useEffect and Mocking
    Components*. This solution moves to the back of the pile.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以修改`CustomerSearch`模拟以具有触发渲染prop的机制。这涉及到使模拟定义比标准形式更复杂。这对我来说是一个直接的红旗，原因如[*第7章*](B18423_07.xhtml#_idTextAnchor125)中所述，*测试useEffect和模拟组件*。这个解决方案被放在了后面。
- en: You could pull out the render prop from your `CustomerSearch` component, render
    it, then find the **Create appointment** button and click it. This is the approach
    we’ll continue with.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从`CustomerSearch`组件中提取渲染prop，渲染它，然后找到**创建预约**按钮并点击它。这是我们将继续采用的方法。
- en: If we use our `render` and `renderAndWait` functions to render this additional
    prop, it will replace the rendered `App` component. We would then click the button
    and we’d observe nothing happening because `App` has gone.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用我们的`render`和`renderAndWait`函数来渲染这个额外的prop，它将替换已渲染的`App`组件。然后我们点击按钮，我们会观察到没有任何事情发生，因为`App`已经消失了。
- en: What we need is a second React root that can be used to just render that *additional*
    piece of the DOM. Our test can simply pretend that *it* is the `CustomerSearch`
    component.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个第二级React根，可以用来仅渲染那**额外**的DOM片段。我们的测试可以简单地假装**它**是`CustomerSearch`组件。
- en: 'To do this, we need a new render component that we’ll call `renderAdditional`.
    Let’s add that now and then write our test, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要一个新的渲染组件，我们将称之为`renderAdditional`。现在让我们添加它，然后编写以下测试：
- en: 'In `test/reactTestExtensions.js`, add the following function definition, just
    below the definition of `renderAndWait`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/reactTestExtensions.js`中，在`renderAndWait`定义下方添加以下函数定义：
- en: '[PRE73]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In `test/App.test.js`, update the `import` statement to pull in this new extension,
    like so:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/App.test.js`中，更新`import`语句以引入这个新扩展，如下所示：
- en: '[PRE74]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Locate the `search customers` nested `describe` block and add a `searchFor`
    helper function that calls the render prop for the supplied customer, as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到`search customers`嵌套的`describe`块，并添加一个`searchFor`辅助函数，该函数调用提供的客户的渲染属性，如下所示：
- en: '[PRE75]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, add the test. This renders the prop and checks that a button has been
    rendered, as illustrated in the following code snippet:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加测试。这会渲染属性并检查是否已渲染了一个按钮，如下面的代码片段所示：
- en: '[PRE76]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In `src/App.js`, add the following function just above the returned JSX:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/App.js`中，在返回的JSX上方添加以下函数：
- en: '[PRE77]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Set the prop on `CustomerSearch`, as follows. Your test should pass after this
    change:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CustomerSearch`上设置属性，如下所示。在此更改后，你的测试应该通过：
- en: '[PRE78]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Back in `test/CustomerSearch.test.js`, add the next test, as follows. This
    uses the same helper function, but this time clicks the button and verifies that
    `AppointmentFormLoader` was shown with the correct customer ID:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/CustomerSearch.test.js`中，添加以下测试。这使用相同的辅助函数，但这次点击按钮并验证是否显示了带有正确客户ID的`AppointmentFormLoader`：
- en: '[PRE79]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To make that pass, update `searchActions` in `src/App.js` to use the customer
    parameter that will be passed to it by `CustomerSearch`, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使它通过，更新`src/App.js`中的`searchActions`以使用`CustomerSearch`传递给它的客户参数，如下所示：
- en: '[PRE80]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'That’s all there is to it: you’ve now used `renderAdditional` to trigger your
    render props and check that it works as expected.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么多了：你现在已经使用了`renderAdditional`来触发你的渲染属性并检查它是否按预期工作。
- en: This technique can be very handy when working with third-party libraries that
    expect you to pass render props.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当与期望你传递渲染属性的三方库一起工作时，这个技术非常有用。
- en: That completes this feature; go ahead and manually test if you’d like to see
    it all in action.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了这个功能；如果你想要看到它全部的效果，请手动测试。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has explored building out a component with some complex user interactions
    between the user interface and an API. You’ve created a new table component and
    integrated it into the existing application workflow.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了构建一个组件，其中用户界面和API之间存在一些复杂的用户交互。你已经创建了一个新的表格组件，并将其集成到现有的应用程序工作流程中。
- en: You have seen how to make large changes to your component’s implementation,
    using your tests as a safety mechanism.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了如何通过使用测试作为安全机制来对组件的实现进行重大更改。
- en: You have also seen how to test render props using an additional render root—a
    technique that I hope you don’t have to use too often!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你还看到了如何使用额外的渲染根来测试渲染属性——我希望你不需要经常使用这个技术！
- en: In the next chapter, we’ll use tests to integrate React Router into our application.
    We’ll continue with the `CustomerSearch` component by adding the ability to use
    the browser location bar to specify search criteria. That will set us up nicely
    for introducing Redux and GraphQL later on.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用测试将React Router集成到我们的应用程序中。我们将继续使用`CustomerSearch`组件，通过添加使用浏览器地址栏指定搜索条件的能力。这将为我们引入Redux和GraphQL打下良好的基础。
- en: Exercises
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Disable the **Previous** button if the user is on the first page and disable
    the **Next** button if the current listing has fewer than 10 records on display.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户在第一页上，禁用**上一页**按钮；如果当前列表显示的记录少于10条，禁用**下一页**按钮。
- en: Extract the `searchParams` function into a separate module that handles any
    number of parameters and uses the `encodeURIComponent` JavaScript function to
    ensure the values are encoded correctly.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`searchParams`函数提取到一个单独的模块中，该模块可以处理任意数量的参数，并使用`encodeURIComponent` JavaScript函数来确保值被正确编码。
- en: The `/customers` endpoint supports a `limit` parameter that allows you to specify
    the maximum number of records that are returned. Provide a mechanism for the user
    to change the limit on each page.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/customers`端点支持一个`limit`参数，允许你指定返回的最大记录数。为用户提供一个机制，以便在每个页面上更改限制。'
