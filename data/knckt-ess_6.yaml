- en: Chapter 6. The Module Pattern – RequireJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。模块模式 - RequireJS
- en: We can say now that our application has all the functionality we mentioned in
    the [Chapter 1](ch01.html "Chapter 1. Refreshing the UI Automatically with KnockoutJS"),
    *Refreshing the UI Automatically with KnockoutJS*. What we have done in the last
    four chapters is a very good approach to solving code design in small projects.
    The code is tidy and the folder structure is also cohesive. The code is easy to
    read and follow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以说我们的应用程序具有我们在[第一章](ch01.html "Chapter 1. Refreshing the UI Automatically
    with KnockoutJS")中提到的所有功能，*使用KnockoutJS自动刷新UI*。我们在过去的四章中所做的是解决小型项目中的代码设计的一个很好的方法。代码整洁，文件夹结构也是连贯的。代码易于阅读和跟踪。
- en: However, when projects begin to grow this approach is not enough. You need to
    keep the code tidy, not just in the file and folder structure, but logically as
    well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当项目开始增长时，这种方法是不够的。你需要保持代码的整洁，不仅是在文件和文件夹结构上，还包括逻辑上。
- en: In this chapter, we are going to modularize our code to keep the different parts
    of our application isolated and reusable. We will also see how to keep our context
    cleaner.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将把我们的代码模块化，以保持应用程序的不同部分隔离和可重用。我们还将看到如何保持我们的上下文更清晰。
- en: Now the project begins to look more complex. It is important to know the tools
    that help you to debug the code when you find an error. In the first part of the
    chapter, you will learn about tools that can help you to inspect your KnockoutJS
    code. You will use a browser plugin (Chrome Extension) to analyze the code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目开始变得更加复杂。当你发现错误时，了解帮助你调试代码的工具是很重要的。在本章的第一部分，你将学习一些可以帮助你检查你的KnockoutJS代码的工具。你将使用一个浏览器插件（Chrome扩展）来分析代码。
- en: In the second part of the chapter, you will convert your files into modules.
    That will help you to keep each part of the application isolated from the others.
    You will use a pattern called 'dependency injection' to solve dependencies between
    modules. Learn more about this pattern at [http://en.wikipedia.org/wiki/Dependency_injection](http://en.wikipedia.org/wiki/Dependency_injection).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，你将把你的文件转换成模块。这将帮助你将应用程序的每个部分与其他部分隔离开来。你将使用一种叫做“依赖注入”的模式来解决模块之间的依赖关系。在[http://en.wikipedia.org/wiki/Dependency_injection](http://en.wikipedia.org/wiki/Dependency_injection)了解更多关于这个模式的信息。
- en: In the last part, you will learn how to create modules following the Asynchronous
    Module Definition (AMD) specification. To create modules following the AMD specification,
    you will use a library called RequireJS. This library will manage all dependencies
    between the different modules. For more about AMD, refer to [http://en.wikipedia.org/wiki/Asynchronous_module_definition](http://en.wikipedia.org/wiki/Asynchronous_module_definition).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一部分，你将学习如何创建遵循异步模块定义（AMD）规范的模块。为了创建遵循AMD规范的模块，你将使用一个叫做RequireJS的库。这个库将管理不同模块之间的所有依赖关系。有关AMD的更多信息，请参阅[http://en.wikipedia.org/wiki/Asynchronous_module_definition](http://en.wikipedia.org/wiki/Asynchronous_module_definition)。
- en: Installing the Knockout context debugger extension
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Knockout上下文调试器扩展
- en: In the previous chapters, you created a simple debugger to show the state of
    your view-model. This is very useful to see the state of our application quickly.
    With the debug binding, you don't need to open the extension tools to check what
    is happening to your data. But you often isolate just a part of the application
    or see what is happening with the models bound to a DOM element.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你创建了一个简单的调试器来显示你的视图模型的状态。这对于快速查看应用程序的状态非常有用。有了调试绑定，你不需要打开扩展工具来检查你的数据发生了什么变化。但是你经常只是隔离应用程序的一部分或查看绑定到DOM元素的模型发生了什么变化。
- en: In Google Chrome, you have a very good extension called **KnockoutJS context
    debugger**, which can be downloaded from [https://chrome.google.com/webstore/detail/knockoutjs-context-debugg/oddcpmchholgcjgjdnfjmildmlielhof](https://chrome.google.com/webstore/detail/knockoutjs-context-debugg/oddcpmchholgcjgjdnfjmildmlielhof).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Chrome中，你有一个非常好的扩展叫做**KnockoutJS上下文调试器**，可以从[https://chrome.google.com/webstore/detail/knockoutjs-context-debugg/oddcpmchholgcjgjdnfjmildmlielhof](https://chrome.google.com/webstore/detail/knockoutjs-context-debugg/oddcpmchholgcjgjdnfjmildmlielhof)下载。
- en: This extension allows you to view the bindings of each DOM node and trace online
    the changes in your view-model through the console. Install it and restart the
    Chrome browser.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展允许你查看每个DOM节点的绑定，并通过控制台在线跟踪你的视图模型的变化。安装它并重新启动Chrome浏览器。
- en: '![Installing the Knockout context debugger extension](img/7074OS_06_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![安装Knockout上下文调试器扩展](img/7074OS_06_01.jpg)'
- en: Check in chrome://extensions whether KnockoutJS context debugger has been installed
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 chrome://extensions 是否已安装 KnockoutJS 上下文调试器
- en: To check the context bound to your models, open **Chrome Developer Tools** by
    pressing *F12* and opening the **Elements** tab. You will see two panels. The
    left one has the DOM schema. The right panel has different tabs. By default, the
    **Styles** tab opens. Select the tab that says **Knockout context**. There, you
    should see all the bindings added to the root context.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查绑定到模型的上下文，请按 *F12* 打开 **Chrome 开发者工具** 并打开 **Elements** 标签。您会看到两个面板。左侧面板有
    DOM 结构。右侧面板有不同的标签。默认情况下，打开 **Styles** 标签。选择名为 **Knockout 上下文** 的标签。在那里，您应该看到添加到根上下文的所有绑定。
- en: '![Installing the Knockout context debugger extension](img/7074OS_06_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Knockout 上下文调试器扩展](img/7074OS_06_02.jpg)'
- en: How to show a KnockoutJS context that is bound to a DOM element
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如何显示绑定到 DOM 元素的 KnockoutJS 上下文
- en: If you select a `<tr>` element from your catalog, you will navigate deeper into
    the context and be inside the catalog item scope. You will not be able to see
    the `$root` context; you will see the `$data` context. You can navigate up through
    the `$parent` element or change the element in the DOM panel.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择目录中的 `<tr>` 元素，您将深入上下文并位于目录项范围内。您将无法看到 `$root` 上下文；您将看到 `$data` 上下文。您可以通过
    `$parent` 元素向上导航或更改 DOM 面板中的元素。
- en: '![Installing the Knockout context debugger extension](img/7074OS_06_03.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Knockout 上下文调试器扩展](img/7074OS_06_03.jpg)'
- en: You can easily inspect item context inside foreach bindings
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松检查 foreach 绑定中的项目上下文。
- en: You can also see the `ko` object. This is a good way to navigate through the
    Knockout API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到 `ko` 对象。这是浏览 Knockout API 的好方法。
- en: '![Installing the Knockout context debugger extension](img/7074OS_06_04.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Knockout 上下文调试器扩展](img/7074OS_06_04.jpg)'
- en: You can access the Knockout API and see methods, bindings, components, and so
    on
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问 Knockout API 并查看方法、绑定、组件等。
- en: Now locate the **KnockoutJS** tab (it is in the same collection as the **Elements**
    tab). Press the **Enable Tracing** button. This function allows you to follow
    real-time changes in the view-model. Changes are painted in the console.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在找到 **KnockoutJS** 标签（它与 **Elements** 标签在同一集合中）。按下 **启用跟踪** 按钮。此功能允许您跟踪视图模型的实时更改。更改将在控制台中显示。
- en: '![Installing the Knockout context debugger extension](img/7074OS_06_05.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Knockout 上下文调试器扩展](img/7074OS_06_05.jpg)'
- en: If you enable tracing, you can capture changes in the view-model through the
    console
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用跟踪，您可以通过控制台捕获视图模型的更改。
- en: Also, you can measure time and performance using the **Timeline** tab. You can
    see how much time the application uses to render DOM elements when a change is
    made in the model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用 **Timeline** 标签测量时间和性能。您可以看到应用程序在模型发生变化时用于渲染 DOM 元素的时间。
- en: '![Installing the Knockout context debugger extension](img/7074OS_06_06.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Knockout 上下文调试器扩展](img/7074OS_06_06.jpg)'
- en: With tracing enabled, you can record events and obtain useful information
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 启用跟踪功能后，您可以记录事件并获得有用信息。
- en: Now that you have learned about this plugin, we can delete (or keep, it's your
    choice) the debug binding we built before.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了这个插件，我们可以删除（或保留，这取决于您）之前构建的调试绑定。
- en: The console
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制台
- en: The **console** is one of the most important tools for developers. You can use
    it to check the state of our application while it is in use.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制台** 是开发人员最重要的工具之一。您可以使用它来检查应用程序在使用过程中的状态。'
- en: You can locate the JavaScript code and set breakpoints to check what is happening
    at a particular point. You can do this by locating the JavaScript file in the
    **Sources** tab. Just click the line you want to stop at. Then you can check the
    value of the variables and run the code step by step. Also, you can write the
    word `debugger` in the code to stop the program at this place.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定位 JavaScript 代码并设置断点，以检查特定点发生了什么。您可以在 **Sources** 标签中找到 JavaScript 文件。只需点击要停在的行即可。然后，您可以检查变量的值并逐步运行代码。此外，您还可以在代码中写入
    `debugger` 以在此处停止程序。
- en: '![The console](img/7074OS_06_07.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![控制台](img/7074OS_06_07.jpg)'
- en: You can set breakpoints in the code and check the values of variables
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在代码中设置断点并检查变量的值。
- en: If you navigate to the **Console** tab you will see the console itself. There,
    you can show information using the `console.log` function or check the console
    object documentation to see the best method you can use at each moment ([https://developer.mozilla.org/en-US/docs/Web/API/Console](https://developer.mozilla.org/en-US/docs/Web/API/Console)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您导航到**控制台**选项卡，您将看到控制台本身。在那里，您可以使用`console.log`函数显示信息，或者查看控制台对象文档以查看您可以在每个时刻使用的最佳方法（[https://developer.mozilla.org/en-US/docs/Web/API/Console](https://developer.mozilla.org/en-US/docs/Web/API/Console)）。
- en: If you write the word `window` in the console, you will see all the objects
    that are in the global scope.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在控制台中写入单词`window`，您将看到在全局范围内的所有对象。
- en: '![The console](img/7074OS_06_08.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![控制台](img/7074OS_06_08.jpg)'
- en: With the console, you can access variables in the current and global context
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制台，您可以访问当前和全局上下文中的变量
- en: You can write the word `vm` (the view-model) to see the `vm` object we have
    created.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以写入单词`vm`（视图模型）以查看我们创建的`vm`对象。
- en: '![The console](img/7074OS_06_09.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![控制台](img/7074OS_06_09.jpg)'
- en: All components are set in the global scope
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件都设置在全局范围内
- en: But you can also write `Product` or `ProductService` or anything we have created
    and you will see it. When you have a lot of information, to have all your objects
    at the top level can be chaotic. Defining namespaces and keeping a hierarchy is
    a good practice to keep your components isolated. You should keep just an entry
    point to the application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是您也可以写`Product`或`ProductService`或我们创建的任何内容，您都会看到它。当您有大量信息时，在顶层拥有所有对象可能会很混乱。定义命名空间并保持层次结构是保持组件隔离的良好实践。您应该只保留应用程序的一个入口点。
- en: The module pattern
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块模式
- en: This pattern allows us to focus on which part of the code is exposed out of
    the class (public elements) and which parts of the code are hidden to the final
    user (private elements).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式允许我们专注于哪些代码部分暴露给类外部（公共元素），以及代码的哪些部分对最终用户隐藏（私有元素）。
- en: This pattern is commonly used in JavaScript software development. It is applied
    in popular libraries like jQuery, Dojo, and ExtJS.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式通常用于JavaScript软件开发。它应用于像jQuery、Dojo和ExtJS等流行库中。
- en: 'This pattern has a very clear structure and is very easy to apply once you
    know how to use it. Let''s apply the module pattern in our application:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您知道如何使用它，此模式具有非常清晰的结构，并且非常容易应用。让我们在我们的应用程序中应用模块模式：
- en: 'First, define the name of your module. If you define the module in different
    files, it is important to define and initialize it applying a pattern that allows
    it to be extensible. Using the `||` operator in the initialization indicates that
    the `ModuleName` value will be assigned to itself if it has a value. If it hasn''t
    got a value it means that this is the first time it has been created, so assign
    to it a default value—in this case an empty object:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义模块的名称。如果您在不同的文件中定义模块，重要的是要应用允许其可扩展性的模式来定义和初始化它。在初始化中使用`||`运算符表示如果`ModuleName`值已经有值，则将其赋值给自身。如果它没有值，则意味着这是它第一次被创建，因此给它一个默认值—在这种情况下是一个空对象：
- en: '[PRE0]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, define each component of the module. It can be a function, a variable,
    or another module:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义模块的每个组件。它可以是函数、变量或另一个模块：
- en: '[PRE1]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, insert the dependencies of the module using the dependency injection
    pattern. This pattern passes all module dependencies as parameters and invokes
    the function immediately:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用依赖注入模式插入模块的依赖项。该模式将所有模块依赖项作为参数传递，并立即调用该函数：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This how a complete module looks:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是一个完整模块的样子：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To define a component, return the `component` object. The first pattern to
    define your component is to use the revealing module pattern. It consists of returning
    an object to the end of the function that contains only the public interface.
    These are singleton objects:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要定义组件，请返回`component`对象。定义组件的第一个模式是使用揭示模块模式。它包含在函数末尾返回一个仅包含公共接口的对象。这些是单例对象：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating the Shop module
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Shop模块
- en: To modularize our application, we are going to create a module called `Shop`
    that will contain our entire application. This module will contain other submodules
    and components. This hierarchical structure will help you to keep coherence in
    your code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序模块化，我们将创建一个名为`Shop`的模块，该模块将包含我们的整个应用程序。此模块将包含其他子模块和组件。此分层结构将帮助您保持代码的一致性。
- en: As the first approach, group your components by file and by type. This means
    that each component of the modules will be in a file and the files will be grouped
    by type in a folder. For example, there is a folder named `services`. This means
    that all services will be in this folder, and each service will be completely
    defined in one file. As a convention, the components will have the same name as
    the file in which they are, without the extension of course.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一种方法，按文件和类型分组你的组件。这意味着模块的每个组件都将在一个文件中，并且文件将在一个文件夹中按类型分组。例如，有一个名为`services`的文件夹。这意味着所有服务都将在这个文件夹中，并且每个服务将在一个文件中完全定义。按照惯例，组件将与它们所在的文件具有相同的名称，当然不包括扩展名。
- en: Actually, the files are already grouped by type so this is a job you don't need
    to do again. We are going to focus our efforts on converting our files into modules.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，文件已经按类型分组了，所以这是一个你不需要再做的工作。我们将把精力集中在将我们的文件转换为模块上。
- en: The ViewModel module
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图模型模块
- en: We have just one view-model in our application. This is a component where we
    can apply the singleton module approach.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中只有一个视图模型。这是一个可以应用单例模块方法的组件。
- en: 'We are going to carefully create our first module step by step:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将小心翼翼地逐步创建我们的第一个模块：
- en: Open the `viewmodel.js` file.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`viewmodel.js`文件。
- en: 'Define the `Shop` module, which is the top module of our application:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Shop`模块，这是我们应用程序的顶级模块：
- en: '[PRE5]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Initialize the `Shop` module by applying the extension pattern:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过应用扩展模式初始化`Shop`模块：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define the `ViewModel` component:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`ViewModel`组件：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Set the code from the unmodularized view-model version inside the module:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将未模块化的视图模型版本的代码放入模块中：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You have not converted other files into modules, but you are now going to add
    dependencies into the module:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还没有将其他文件转换为模块，但现在您将向模块添加依赖项：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At the end of the file, outside the module, initialize the template, validation,
    and objects:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾，模块外部，初始化模板、验证和对象：
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You need to update two methods in our view-model: the `activate` method and
    the `allCallbackSuccess` method. The reason you need to update these methods is
    because in the `allCallbackSuccess` method you need to run the `ko.applyBindings`
    method, and `allCallbackSuccess` has no access to the this object because it is
    out of the scope.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要更新我们的视图模型中的两个方法：`activate`方法和`allCallbackSuccess`方法。您需要更新这些方法的原因是因为在`allCallbackSuccess`方法中，您需要运行`ko.applyBindings`方法，而`allCallbackSuccess`无法访问此对象，因为它超出了范围。
- en: 'To solve this, we are going to use the same technique we used with the click
    binding to attach more parameters. We are going to use the `bind` JavaScript method
    to bind the `allCallbackSuccess` method to the this object. Therefore, we will
    be able to run the `ko.applyBindings` using the this object as done in the following
    code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们将使用与点击绑定相同的技术来附加更多参数。我们将使用`bind` JavaScript 方法将`allCallbackSuccess`方法绑定到这个对象上。因此，我们将能够像下面的代码一样使用此对象运行`ko.applyBindings`：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using this pattern you can convert any piece of code into an isolated and portable
    module. The next step is to create the `Models` module, the `Services` module,
    and the `Resources` module.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，您可以将任何代码片段转换为一个隔离的、可移植的模块。下一步是创建`Models`模块、`Services`模块和`Resources`模块。
- en: The Models module
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型模块
- en: 'As we have done with the view-model, we are going to convert each model into
    a component and we are going to wrap it inside a module called `Models`, the following
    steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对视图模型所做的一样，我们将每个模型转换为一个组件，并将其包装在一个名为`Models`的模块中，具体步骤如下：
- en: Open the `models/product.js` file.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`models/product.js`文件。
- en: 'Define our top-level module, `Shop`, and initialize it:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的顶层模块，`Shop`，并初始化它：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then create the `Models` namespace. It will be an object or the value it has
    before, in case it exists:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建`Models`命名空间。它将是一个对象，或者如果存在的话，它将是它之前的值：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define the product model with its dependencies. Remember, the first value is
    the product itself. This allows us to extend the model in case we use many files
    to define it. So, we define the product model as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用其依赖项定义产品模型。请记住，第一个值是产品本身。这样可以允许我们在使用多个文件定义它的情况下扩展模型。因此，我们将产品模型定义如下：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Pass the dependencies. This time you just need to use the Knockout dependency
    to use observables. Knockout is a global object and there is no need to add it
    to the dependencies, but it is a good practice to do it as in the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递依赖项。这次你只需要使用Knockout依赖项来使用observables。Knockout是一个全局对象，不需要将其添加到依赖项中，但最好像下面的代码那样做。
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, set the code we had in the `models/Product.js` file earlier:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在先前的`models/Product.js`文件中设置我们之前拥有的代码：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Follow the same steps to convert the `models/CartProduct.js` and `models/Customer.js`
    files into modules. Models are perfect candidates to apply the pattern we use
    to generate instantiable objects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对`models/CartProduct.js`和`models/Customer.js`文件执行相同的步骤以将其转换为模块。模型是应用我们用于生成可实例化对象的模式的完美候选对象。
- en: It is important that you keep the consistency between components and file names.
    Be sure that your files have the name of the component they contain with the `.js`
    extension.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要保持组件和文件名之间的一致性。确保你的文件名称与其包含的组件名称并带有`.js`扩展名。
- en: 'Here is the final result of converting the `models/CartProduct.js` file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将`models/CartProduct.js`文件转换为最终结果的步骤：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also take a look at the result of the `models/Customer.js` file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，查看`models/Customer.js`文件的结果：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Resources module
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源模块
- en: 'In terms of code, building a module that contains a model and building one
    that contains a resource is not so different. The module pattern applied is the
    same. Nevertheless, you don''t need to create instances of the resources. To apply
    CRUD operations to the models, you just need an object that handles this responsibility.
    Therefore, the resources will be singletons, as done in the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从编码角度来看，构建包含模型的模块和构建包含资源的模块并没有太大的不同。应用的模块模式是相同的。然而，你不需要创建资源的实例。要对模型应用 CRUD 操作，你只需要一个处理此责任的对象。因此，资源将是单例的，就像以下步骤中所做的那样：
- en: Open the `resources/ProductResource.js` file.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`resources/ProductResource.js`文件。
- en: 'Create the top hierarchy module:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建顶层层次模块：
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the `Resources` namespace:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Resources`命名空间：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define `ProductResource` using the module pattern:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模块模式定义`ProductResource`：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Set the dependencies. In this case, jQuery is the dependency you need. jQuery
    is a global object and you don't need to pass it as a dependency, but it's a good
    practice to do so.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置依赖关系。在这种情况下，jQuery 是你需要的依赖项。jQuery 是一个全局对象，不需要将其作为依赖项传递，但这样做是一个很好的实践。
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, set the following code in the `resources/ProductResource.js` file.
    Since in our application resources are singleton, extend the resource with the
    methods used in the following code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`resources/ProductResource.js`文件中设置以下代码。由于在我们的应用程序中资源是单例的，将资源与以下代码中使用的方法扩展起来：
- en: '[PRE23]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now apply the same steps to the `OrderResouce` component. You can see the final
    result in this piece of code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对`OrderResouce`组件应用相同的步骤。你可以在这段代码中看到最终结果：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Services module
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务模块
- en: 'Services are also singletons, like resources, so follow the same steps as the
    resources module:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 服务也是单例的，和资源一样，所以按照与资源模块相同的步骤进行操作：
- en: Open the `services/ProductService.js` file.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`services/ProductService.js`文件。
- en: 'Create the top hierarchy module:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建顶层层次模块：
- en: '[PRE25]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create the `Resources` namespace:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Resources`命名空间：
- en: '[PRE26]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define `ProductService`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`ProductService`：
- en: '[PRE27]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case the service has no dependencies.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，服务没有依赖关系。
- en: 'Finally, set the following code in the `services/ProductService.js` file. Since
    in the application the resources are singleton, extend the resource with the methods
    used in the following code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`services/ProductService.js`文件中设置以下代码。由于在应用程序中资源是单例的，将资源与以下代码中使用的方法扩展起来：
- en: '[PRE28]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Events, bindings, and Knockout components
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件、绑定和 Knockout 组件
- en: We are not going to modularize events, because they are specific to this application.
    It makes no sense to isolate something that is not portable. We will not modularize
    either bindings or components because they are injected into the Knockout object
    as part of the library, so they are isolated enough and they aren't part of the
    modules, but the Knockout object. But we need to update dependencies in all these
    files because different parts of the application are now isolated in the `Shop`
    module and its submodules.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算模块化事件，因为它们是特定于此应用程序的。孤立非可移植的东西是没有意义的。我们也不会将绑定或组件模块化，因为它们被注入到 Knockout 对象中作为库的一部分，所以它们已经足够孤立，它们不是模块的一部分，而是
    Knockout 对象的一部分。但我们需要更新所有这些文件中的依赖关系，因为应用程序的不同部分现在都隔离在`Shop`模块及其子模块中。
- en: Updating the add-to-cart-button component
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 add-to-cart-button 组件
- en: 'To update the component with new namespaces, update (overwrite) the references
    to the dependencies, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用新命名空间更新组件，更新（覆盖）对依赖项的引用，如下所示：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Updating events
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新事件
- en: 'Update those lines of code that have dependencies from the new modules, as
    follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新那些具有新模块依赖关系的代码行：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You have learned a very good pattern to manage dependencies without any external
    tools. You can use it in almost all your projects. It will work better if you
    combine all your files into one.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了一种非常好的模式，可以在没有任何外部工具的情况下管理依赖关系。您几乎可以在所有项目中使用它。如果您将所有文件合并到一个文件中，则其效果会更好。
- en: This book is not going to cover how to join and minify files to use them in
    a production environment. Joining and minifying files improves the performance
    of applications because minifying reduces the size of files and joining them reduces
    the number of HTTP calls to one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会涵盖如何合并和缩小文件以在生产环境中使用它们。合并和缩小文件可以提高应用程序的性能，因为缩小可以减少文件的大小，而合并可以减少 HTTP 调用的次数至一个。
- en: To do this you can use Node.js ([http://nodejs.org/](http://nodejs.org/)) and
    a build module like Grunt ([http://gruntjs.com/](http://gruntjs.com/)) or Gulp
    ([http://gulpjs.com/](http://gulpjs.com/)). If you are interested in learning
    about deployment practices like minification, combination of files, and so on,
    there is a large bibliography about Node.js and deployment tools on the Internet.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，您可以使用 Node.js ([http://nodejs.org/](http://nodejs.org/)) 和一个构建模块，如 Grunt
    ([http://gruntjs.com/](http://gruntjs.com/)) 或 Gulp ([http://gulpjs.com/](http://gulpjs.com/))。如果您有兴趣了解诸如缩小、文件组合等部署实践，互联网上有大量关于
    Node.js 和部署工具的参考文献。
- en: 'To access the code of this part of the chapter, go to the GitHub repository
    at:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章节代码的这一部分，请访问 GitHub 仓库：
- en: '[https://github.com/jorgeferrando/knockout-cart/tree/chapter6Part1](https://github.com/jorgeferrando/knockout-cart/tree/chapter6Part1).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/jorgeferrando/knockout-cart/tree/chapter6Part1](https://github.com/jorgeferrando/knockout-cart/tree/chapter6Part1)。'
- en: Using RequireJS to manage dependencies
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RequireJS 来管理依赖关系
- en: 'In the previous section, you learned how to isolate different parts of the
    code. You also grouped the files by type and component names, which follow a consistent
    pattern. However, you have not solved one important problem that grows in proportion
    to the size of the project. To give you a clue about what this problem is, let''s
    see our `index.html` file. Look at the part of the `<script>` tags section:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学会了如何隔离代码的不同部分。您还按类型和组件名称对文件进行了分组，这遵循了一致的模式。但是，您还没有解决一个随着项目规模增大而增长的重要问题。为了给您一个关于这个问题是什么的提示，让我们来看看我们的`index.html`文件。查看`<script>`标签部分的部分：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You need to keep dependencies between all these files manually. The complexity
    of doing this grows as the project does. Therefore, there is a problem when you
    need to know the dependencies of all your files. This can be handled easily in
    small projects, but when working on big projects this can be a nightmare. Also,
    if you load all your files at the beginning, starting your application can be
    penalized.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要手动维护所有这些文件之间的依赖关系。随着项目的增长，这样做的复杂性也在增加。因此，当您需要知道所有文件的依赖关系时，就会出现问题。这在小型项目中很容易处理，但在处理大型项目时，这可能是一场噩梦。此外，如果您在开始时加载所有文件，启动应用程序可能会受到惩罚。
- en: 'To solve this problem, there are multiple libraries that can help. We are going
    to use RequireJS (refer to [http://requirejs.org/](http://requirejs.org/) for
    more information), which is focused on loading scripts asynchronously and managing
    dependencies. It follows AMD to write different modules. This means it uses the
    `define` and `require` statements to define and load different modules. AMD libraries
    are focused on the client side of applications and help load JavaScript modules
    when needed. For more information on AMD, please visit the following link:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，有多个库可以帮助。我们将使用 RequireJS（有关更多信息，请参阅 [http://requirejs.org/](http://requirejs.org/)），它专注于异步加载脚本和管理依赖关系。它遵循
    AMD 来编写不同的模块。这意味着它使用`define`和`require`语句来定义和加载不同的模块。AMD 库专注于应用程序的客户端，并在需要时帮助加载
    JavaScript 模块。有关 AMD 的更多信息，请访问以下链接：
- en: '[http://en.wikipedia.org/wiki/Asynchronous_module_definition](http://en.wikipedia.org/wiki/Asynchronous_module_definition)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Asynchronous_module_definition](http://en.wikipedia.org/wiki/Asynchronous_module_definition)'
- en: This is very helpful because it optimizes the number of requests made. This
    enables the application to start faster and load just the modules that the user
    needs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有帮助，因为它优化了所发出请求的数量。这使得应用程序可以更快地启动，并且仅加载用户需要的模块。
- en: There is another pattern to define asynchronous modules, called CommonJS (learn
    more about it at [http://requirejs.org/docs/commonjs.html](http://requirejs.org/docs/commonjs.html)),
    which is used by default by Node.js modules. You can use this definition in the
    client-side application using Node.js and a library called **browserify** (learn
    more about it at [http://browserify.org/](http://browserify.org/)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种定义异步模块的模式，称为 CommonJS（在 [http://requirejs.org/docs/commonjs.html](http://requirejs.org/docs/commonjs.html)
    中了解更多信息），它默认由 Node.js 模块使用。你可以在客户端应用程序中使用这个定义，使用 Node.js 和一个叫做 **browserify**
    的库（在 [http://browserify.org/](http://browserify.org/) 中了解更多信息）。
- en: In this book, we are going to focus on RequireJS, because it doesn't require
    Node.js or any compilation and is commonly used in client-side applications.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将专注于 RequireJS，因为它不需要 Node.js 或任何编译，并且在客户端应用程序中经常使用。
- en: Updating the template engine
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新模板引擎
- en: Unfortunately, the `ExternalTemplateEngine` we have used until now is not AMD
    compatible. This is why you should use other solutions. There is a KnockoutJS
    extension called amd-helpers. You can download it from [https://github.com/rniemeyer/knockout-amd-helpers](https://github.com/rniemeyer/knockout-amd-helpers).
    Ryan Niemeyer is the author of this extension. He is a very famous Knockout developer
    and has a large following in the Knockout community. He has a blog called Knockmeout
    ([http://knockmeout.net](http://knockmeout.net)) which has a large number of articles
    about Knockout and good examples of how the amd-helpers library should be used.
    In this book, we are just going to use the template engine. But this extension
    has many other features.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们到目前为止使用的 `ExternalTemplateEngine` 不兼容 AMD。这就是为什么你应该使用其他解决方案。有一个叫做 amd-helpers
    的 KnockoutJS 扩展。你可以从 [https://github.com/rniemeyer/knockout-amd-helpers](https://github.com/rniemeyer/knockout-amd-helpers)
    下载它。Ryan Niemeyer 是这个扩展的作者。他是一个非常有名的 Knockout 开发者，在 Knockout 社区拥有很多粉丝。他有一个名为 Knockmeout
    的博客 ([http://knockmeout.net](http://knockmeout.net))，上面有大量关于 Knockout 的文章以及如何使用
    amd-helpers 库的良好示例。在本书中，我们只会使用模板引擎。但这个扩展有很多其他功能。
- en: RequireJS just loads JavaScript files natively. To load HTML files asynchronously,
    download the text extension from [https://github.com/requirejs/text](https://github.com/requirejs/text)
    and add it to the `vendors` folder. With this extension, you can load any kind
    of file as text.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS 只是原生加载 JavaScript 文件。要异步加载 HTML 文件，请从 [https://github.com/requirejs/text](https://github.com/requirejs/text)
    下载 text 扩展，并将其添加到 `vendors` 文件夹中。有了这个扩展，你可以加载任何类型的文件作为文本。
- en: Now, when we need to load a text file we just need to add the prefix `text!`
    before the path of the file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们需要加载文本文件时，只需在文件路径前加上前缀 `text!`。
- en: Configuring RequireJS
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 RequireJS
- en: 'To configure RequireJS, create a file at the same level as the `viewmodel.js`
    file lies. You can call it `main.js`, and follow these steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 RequireJS，请在与 `viewmodel.js` 文件位于相同级别的位置创建一个文件。你可以称之为 `main.js`，并按照以下步骤操作：
- en: 'Define the basic `config` method:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义基本的 `config` 方法：
- en: '[PRE32]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, define the base URL for the scripts. This is where RequireJS will look
    for scripts:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义脚本的基本 URL。这是 RequireJS 将查找脚本的地方：
- en: '[PRE33]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, define aliases for the paths of the vendor libraries in the `paths` attribute.
    This helps you to avoid writing long paths in our module dependencies. You don''t
    need to define the extension. RequireJS adds the extension for you:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `paths` 属性中为供应商库的路径定义别名。这样可以帮助你避免在模块依赖项中编写长路径。你不需要定义扩展名。RequireJS 会为你添加扩展名：
- en: '[PRE34]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Also, define dependencies inside the `shim` property. This tells RequireJS
    which files must be loaded before a library is loaded:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要在 `shim` 属性内定义依赖项。这告诉 RequireJS 必须在加载库之前加载哪些文件：
- en: '[PRE35]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define the file that should be called when the configuration is done. In this
    case the file is `app.js`. This file will be the entry point of the application
    and will trigger all the dependencies that load at the start of our project:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义配置完成后应调用的文件。在本例中，文件是 `app.js`。此文件将是应用程序的入口点，并触发项目启动时加载的所有依赖项：
- en: '[PRE36]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, remove all the `<script>` tags from the `index.html` file and reference
    the `vendors/require.min.js` file. This file uses a `data-main` attribute to reference
    the config file (`main.js`).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从 `index.html` 文件中删除所有 `<script>` 标签，并引用 `vendors/require.min.js` 文件。此文件使用
    `data-main` 属性引用配置文件（`main.js`）。
- en: '[PRE37]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using RequireJS in our project
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的项目中使用 RequireJS
- en: To convert our modules into RequireJS-compatible modules, we will define them
    using the AMD specification. This specification says that to define a module you
    need to call the `define` function. This function receives an array that contains
    strings. These strings represent paths or aliases from the configuration file
    for each dependency (files required in the module).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的模块转换为 RequireJS 兼容的模块，我们将使用 AMD 规范对它们进行定义。该规范指出，要定义一个模块，需要调用`define`函数。该函数接收一个包含字符串的数组。这些字符串表示每个依赖项（模块中所需的文件）的配置文件中的路径或别名。
- en: 'The second parameter that the `define` function needs is a function that will
    return the module. This function will have dependencies from the array as arguments.
    The good thing with this pattern is that code inside the `define` function will
    not be executed until all dependencies are loaded. The following is what the `define`
    function will look like:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`define`函数需要的第二个参数是一个将返回模块的函数。此函数将从数组中的依赖项作为参数。使用这种模式的好处是，在加载所有依赖项之前，`define`函数内部的代码不会被执行。以下是`define`函数的样子：'
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The function should always return the module variable, or whatever the module
    needs to return. If we don't set the `return` statement the module will return
    an undefined value.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该始终返回模块变量，或者模块需要返回的任何内容。如果我们没有设置`return`语句，模块将返回一个未定义的值。
- en: Defining the app.js file
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 app.js 文件
- en: 'When we defined the RequireJS configuration, we said that the entry point will
    be the `app.js` file. The following are the steps to create the `app.js` file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义了 RequireJS 配置时，我们说入口点将是`app.js`文件。以下是创建`app.js`文件的步骤：
- en: Create the `app.js` file.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`app.js`文件。
- en: Set the array of dependencies. Map these dependencies as arguments in the function.
    There are some files that just execute code and they return an undefined value.
    You don't need to map these files if they are at the end of the list of dependencies.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置依赖项数组。将这些依赖项映射为函数中的参数。有些文件只是执行代码，它们返回一个未定义的值。如果它们位于依赖项列表的末尾，你不需要映射这些文件。
- en: '[PRE39]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now define the body of the module. It will initialize global configurations
    and global behaviors. Finally, it will return the view-model:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义模块的主体。它将初始化全局配置和全局行为。最后，它将返回视图模型：
- en: '[PRE40]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first file has a lot of dependencies, which we should keep ordered. First
    we have defined the libraries, then the view-model, mocks, components, and finally
    events. Each of these files should also be defined as modules; when they are called,
    the dependencies will be loaded.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个文件有很多依赖项，我们应该保持有序。首先我们定义了库，然后是视图模型，模拟，组件，最后是事件。这些文件中的每一个也应该被定义为模块；当它们被调用时，依赖项将被加载。
- en: 'Notice how we have updated the template engine definition: the `defaultPath`
    value to define where the templates are, the `deffaultSuffix` value to define
    the extension of the templates, and the library used to load the templates (in
    our case text). Now, we should apply this pattern to the rest of the files.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何更新了模板引擎的定义：`defaultPath` 值用于定义模板所在的位置，`defaultSuffix` 值用于定义模板的扩展名，以及用于加载模板的库（在我们的情况下是
    text）。现在，我们应该将这个模式应用到其余的文件中。
- en: Converting a normal module into an AMD module
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将普通模块转换为 AMD 模块
- en: To convert a normal module, we will perform the following steps. Always apply
    the same steps for all our modules. We need to wrap them into the `define` function,
    list dependencies, and return the module we returned in our old one.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换普通模块，我们将执行以下步骤。始终对我们所有的模块应用相同的步骤。我们需要将它们包装到`define`函数中，列出依赖项，并返回我们在旧模块中返回的模块。
- en: Open the `viewmodel.js` file.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`viewmodel.js`文件。
- en: 'Create the `define` function:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`define`函数：
- en: '[PRE41]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add all dependencies:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所有依赖项：
- en: '[PRE42]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Export the module into the `define` function:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出模块到`define`函数中：
- en: '[PRE43]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When we write `knockout` as a dependency, RequireJS checks the configuration
    to find the alias. If the alias doesn't exist, it looks in the path we have set
    in the `baseUrl` attribute.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`knockout`作为依赖项时，RequireJS 将检查配置以找到别名。如果别名不存在，则它将查找我们在`baseUrl`属性中设置的路径。
- en: Now we should update all our files using this schema. Notice that elements that
    should be set as dependencies are the same elements we have set using the module
    pattern.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该更新所有使用这种模式的文件。注意，应该设置为依赖项的元素与我们使用模块模式设置的元素相同。
- en: Applying RequireJS to components
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 RequireJS 应用到组件
- en: We didn't modularize our bindings and components in the second part of the chapter.
    But this doesn't mean that we couldn't.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在本章的第二部分中将我们的绑定和组件模块化。但这并不意味着我们不能。
- en: We can use RequireJS not just to create modules, but also to load files asynchronously.
    In our case, bindings and components don't need to return an object. When these
    files are loaded, they extend the `ko` object and their job is done. A similar
    case occurs with events. We initialize events and the work is done. So these files
    just need to be wrapped into the `define` function. Add dependencies and load
    them in the `app.js` file as we did in the previous section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以使用 RequireJS 创建模块，还可以异步加载文件。在我们的情况下，绑定和组件不需要返回对象。当加载这些文件时，它们扩展了 `ko` 对象并完成了它们的工作。事件也是如此。我们初始化事件并完成工作。因此，这些文件只需要被包装到
    `define` 函数中。添加依赖项并像在上一节中那样在 `app.js` 文件中加载它们。
- en: 'In the case of the `add-to-cart-button` component, the code in the file will
    be the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `add-to-cart-button` 组件，在文件中的代码将是以下内容：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Applying RequireJS to mocks
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 RequireJS 应用于模拟
- en: 'In the case of mocks, we need to require the Mockjax and the Mockjson library,
    as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟的情况下，我们需要如下引入 Mockjax 和 Mockjson 库：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Applying RequireJS to bindings
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 RequireJS 应用于绑定
- en: 'Bindings are easy to convert. They just have jQuery and Knockout dependencies,
    as shown in the following manner:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定易于转换。它们只有 jQuery 和 Knockout 依赖项，如下所示：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Applying RequireJS to events
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 RequireJS 应用于事件
- en: 'Finally, we need to update the `events/cart.js` file. The confirm order event
    needs to update the view-model. We can require the `viewmodel` as a dependency
    and access its public interface:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新 `events/cart.js` 文件。确认订单事件需要更新视图模型。我们可以将 `viewmodel` 作为依赖项并访问其公共接口：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The limits of the application
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的限制
- en: 'Finally we have a modularized application. Nevertheless, it has some limitations:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们有了一个模块化的应用程序。尽管如此，它有一些限制：
- en: What is the behavior of the browser's back and forward buttons? If we try to
    use them our application doesn't work as it should.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器的后退和前进按钮的行为是什么？如果我们尝试使用它们，我们的应用程序不会按预期工作。
- en: If we want to split our application into pages, do we always have to show and
    hide templates in the same page?
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想将我们的应用程序分成多个页面，我们总是需要在同一个页面中显示和隐藏模板吗？
- en: As you can see, there is a lot of work to do. Knockout is good, but maybe it
    needs to collaborate with other libraries to solve other issues.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，还有很多工作要做。Knockout 很好，但也许它需要与其他库合作来解决其他问题。
- en: There is a copy of the code developed in this chapter at [https://github.com/jorgeferrando/knockout-cart/tree/chapter6RequireJS](https://github.com/jorgeferrando/knockout-cart/tree/chapter6RequireJS).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中开发的代码副本位于 [https://github.com/jorgeferrando/knockout-cart/tree/chapter6RequireJS](https://github.com/jorgeferrando/knockout-cart/tree/chapter6RequireJS)。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to build modules in our projects and how to
    load files on demand.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何在我们的项目中构建模块以及如何按需加载文件。
- en: We talked about the module pattern and AMD specification to build modules. You
    also learned how to debug KnockoutJS applications with the Chrome extension, Knockout
    context debugger.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈论了模块模式和 AMD 规范来构建模块。您还学习了如何使用 Chrome 扩展程序 Knockout 上下文调试器 调试 KnockoutJS 应用程序。
- en: Finally, we saw that when the application becomes bigger, it will need many
    libraries to cover all the requirements. RequireJS is a library that helps us
    with dependency management. Knockout is a library that helps us to apply the MVVM
    pattern in our projects in an easy way, but big applications need other features
    that Knockout doesn't provide.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们发现当应用程序变得更大时，它将需要许多库来满足所有需求。RequireJS 是一个帮助我们管理依赖关系的库。Knockout 是一个帮助我们在项目中轻松应用
    MVVM 模式的库，但是大型应用程序需要 Knockout 无法提供的其他功能。
- en: In the next two chapters, you are going to learn about a framework called Durandal.
    This framework that uses jQuery, Knockout, and RequireJS to apply the MVVM pattern.
    In addition, Durandal provides more patterns to solve other problems, like routing
    and navigation, and enables the addition of new features using plugins and widgets.
    We can say that Durandal is the big brother of KnockoutJS.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，您将学习一个称为 Durandal 的框架。这个框架使用 jQuery、Knockout 和 RequireJS 来应用 MVVM 模式。此外，Durandal
    提供了更多模式来解决其他问题，如路由和导航，并通过插件和小部件实现了添加新功能的能力。我们可以说 Durandal 是 KnockoutJS 的大哥。
