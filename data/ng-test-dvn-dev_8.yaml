- en: Chapter 8. Telling the World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。告诉世界
- en: The build up of TDD focused on fundamental components, namely the life cycle
    and process, using step-by-step walk-throughs. We have studied several applications
    from the ground up, understanding how to build Angular applications and use tools
    to test them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的构建侧重于基本组件，即生命周期和过程，使用逐步的演练。我们从头开始研究了几个应用程序，了解如何构建Angular应用程序并使用工具对其进行测试。
- en: It's time to expand further into the depths of Angular and integrate services,
    EventEmitters, and routes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进一步深入Angular的深处并集成服务、EventEmitters和路由了。
- en: 'This chapter will be slightly different from the others in a few ways:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章将在几个方面略有不同：
- en: Instead of building a brand new application, we will use the search application
    from [Chapter 7](ch07.html "Chapter 7. Flip Flop"), *Flip Flop*
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用[第7章](ch07.html "第7章。翻转") *翻转*中的搜索应用程序，而不是构建全新的应用程序
- en: We will add the unit tests for Angular routes and navigation that were skipped
    in previous chapters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将为之前章节中跳过的Angular路由和导航添加单元测试
- en: We will make the existing search application more modern by separating the commonly
    used actions into services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将通过将常用操作分离到服务中，使现有的搜索应用程序更加现代化
- en: We will take advantage of the Angular `EventEmitter` class to communicate between
    the different components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将利用Angular的`EventEmitter`类在不同的组件之间进行通信
- en: Getting ready to communicate
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好沟通
- en: We will follow a different approach in this chapter, as we've already learned the
    TDD approach. We developed a small project in the previous chapter, and our plan
    is to work with that project and make it better in order to present it to the
    world.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将采用不同的方法，因为我们已经学会了TDD方法。我们在上一章中开发了一个小项目，我们的计划是与该项目一起工作，并使其更好，以便向世界展示。
- en: So, before the walk-through, we will have to review and identify any problems
    and the scope for improvement of the project. To do so, we have to be confident
    of the code base of the search application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在演练之前，我们必须回顾并确定项目的任何问题和改进的范围。为此，我们必须对搜索应用程序的代码库有信心。
- en: Loading the existing project
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载现有项目
- en: To start with, we will copy the project from [Chapter 7](ch07.html "Chapter 7. Flip
    Flop"), *Flip Flop*, which was originally from [https://github.com/angular/quickstart](https://github.com/angular/quickstart), and
    rename it `angular-member-search`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从[第7章](ch07.html "第7章。翻转") *翻转*中复制项目，该项目最初来自[https://github.com/angular/quickstart](https://github.com/angular/quickstart)，并将其重命名为`angular-member-search`。
- en: 'Let''s proceed and get ready to run it:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续准备运行它：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To confirm the installation and run the project, the application will automatically
    run it in a web browser.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认安装并运行项目，应用程序将自动在Web浏览器中运行它。
- en: 'Here is the output we should get when we will run the project:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行项目时，我们应该得到以下输出：
- en: '![Loading the existing project](graphics/image_08_001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![加载现有项目](graphics/image_08_001.jpg)'
- en: Oh! We have our end-to-end test ready in the project. Before we go for an update,
    we have to be sure that the existing e2e tests are successful.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！我们的端到端测试已经准备就绪。在进行更新之前，我们必须确保现有的端到端测试成功。
- en: 'Let''s run the `e2e` test in a separate console:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在单独的控制台中运行`e2e`测试：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Yes, everything passes successfully:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，一切都成功通过了：
- en: '![Loading the existing project](graphics/image_08_002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![加载现有项目](graphics/image_08_002.jpg)'
- en: Unit testing
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: In the previous chapter, we started with the top-down approach. The goal was
    to elaborate on end-to-end testing based on what we had learned. We had the user
    scenario clear, we went through the tests, and our scenario passed our implementation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们从顶部开始。目标是根据我们所学到的知识详细说明端到端测试。我们清楚了用户场景，通过了测试，我们的场景通过了我们的实现。
- en: In the previous chapter, we only covered end-to-end testing. So, in this chapter,
    we'll cover unit tests as much as we can.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们只涵盖了端到端测试。因此，在本章中，我们将尽可能多地涵盖单元测试。
- en: Also, in the previous chapter, we mostly looked at Angular routes and navigation.
    So now, as a logical extension, we will look at how to test Angular routes and
    navigation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在上一章中，我们主要关注了Angular路由和导航。因此，作为一个逻辑延伸，我们将看看如何测试Angular路由和导航。
- en: Testing a component
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件测试
- en: 'Before we go ahead with the component test, we should discuss some points about testing
    Angular components. We already have a basic idea: in Angular, everything is a
    combination of some components. So it would be great for us to learn in more detail
    about Angular component testing.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行组件测试之前，我们应该讨论一些关于测试Angular组件的要点。我们已经有了一个基本的想法：在Angular中，一切都是一些组件的组合。因此，我们应该更详细地学习关于Angular组件测试的内容。
- en: We can test a component in various ways, based on its behavior and use case.
    We could even have test specs for multiple components when they work together
    as an application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据组件的行为和用例以各种方式进行组件测试。甚至当它们作为一个应用程序一起工作时，我们甚至可以为多个组件编写测试规范。
- en: Let's have a look at some of the ways of testing components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些测试组件的方法。
- en: Isolated testing
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 孤立测试
- en: Isolated testing, also known as solo testing, is named so because this type
    of test can run without the need to compile components according to test specs.
    If it doesn't compile, it will not have the compiled template in the test spec;
    only the component class and its methods. This means that if a component's features
    are not very DOM dependent, it can be tested in an isolated manner.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 孤立测试，也称为独立测试，之所以被命名为这样，是因为这种类型的测试可以在不需要根据测试规范编译组件的情况下运行。如果不编译，测试规范中将不会有编译后的模板；只有组件类及其方法。这意味着，如果一个组件的特性不太依赖于DOM，它可以以孤立的方式进行测试。
- en: Isolated testing is mostly used for complex feature or calculation testing,
    where it just initiates the component class and calls all the methods.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 孤立测试主要用于复杂功能或计算测试，它只是初始化组件类并调用所有方法。
- en: 'For example, take a look at the unit tests of [Chapter 6](ch06.html "Chapter 6. The
    First Step"), *The First Step*, where `AppComponent` was responsible for adding
    comments and increasing their likes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下[第6章](ch06.html "第6章。第一步")的单元测试，*第一步*，其中`AppComponent`负责添加评论并增加它们的喜欢：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Shallow testing
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浅层测试
- en: Isolated testing sometimes fulfills the requirements of the test spec, but not
    always. Most of the time, components have DOM dependent features. In such cases,
    it is important to render the component's template in the test specs so that we
    have the compiled template in the scope and test specs are able to interact with
    DOM.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 孤立测试有时可以满足测试规范的要求，但并非总是如此。大多数情况下，组件具有依赖于DOM的特性。在这种情况下，重要的是在测试规范中渲染组件的模板，以便我们在作用域中有编译后的模板，并且测试规范能够与DOM进行交互。
- en: For example, if we want to write a basic unit test for our `AppComponent`, which
    is mostly DOM dependent as there is no method in the component class, then we
    just need to compile the component and check that it is defined. In addition,
    we can have a test spec if the component's template has the correct text inside
    the `<h1>` element.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想为我们的`AppComponent`编写一个基本的单元测试，它大部分依赖于DOM，因为组件类中没有方法，那么我们只需要编译组件并检查它是否被定义。此外，我们可以在测试规范中检查组件的模板是否在`<h1>`元素内有正确的文本。
- en: 'The code will look as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将如下所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Integration testing
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'The following are some key points on integration testing:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于集成测试的关键点：
- en: The name *integration testing* should give us some idea of what kind of test
    it is. It is similar to shallow testing as it also needs to compile the component
    with the template and interact with the DOM.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称*集成测试*应该让我们对这是什么样的测试有一些了解。它类似于浅层测试，因为它也需要使用模板编译组件并与DOM交互。
- en: We will next look at our route and navigation test suite, where we will integrate
    the `AppComponent`, router, and navigation test suites.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将查看我们的路由和导航测试套件，其中我们将集成`AppComponent`、路由器和导航测试套件。
- en: We have a test suite ready for `AppComponent`, as it includes the `navbar` component
    and `router-outlet` component. All of these together work to fulfill the routing
    specs.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经为`AppComponent`准备好了一个测试套件，因为它包括`navbar`组件和`router-outlet`组件。所有这些组件一起工作，以满足路由规范。
- en: So, to get a confident test spec for a router, we should go with integration
    testing.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，要为路由器获得一个自信的测试规范，我们应该选择集成测试。
- en: We will look at an example of router testing with a detailed explanation in
    the following sections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细解释路由器测试的示例。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The main difference between integration testing and shallow testing is that
    integration testing works for the test suite of the complete application, or a
    small portion of the application, where multiple components work together to solve
    some purpose. It shares some similarities with end-to-end testing, but with a different
    approach.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试和浅层测试之间的主要区别在于，集成测试适用于完整应用程序的测试套件，或应用程序的一小部分，其中多个组件共同解决某个目的。它与端到端测试有一些相似之处，但采用了不同的方法。
- en: Karma configuration
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Karma配置
- en: In previous chapters, the default Karma configuration was used, but no explanation
    about this default configuration has been given yet. **File watching** is a useful
    default behavior that will now be reviewed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，使用了默认的Karma配置，但尚未解释过这个默认配置。**文件监视**是一个有用的默认行为，现在将进行审查。
- en: File watching
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件监视
- en: "File watching is enabled by default when the Karma `init` command is used.\
    \ \LFile watching in Karma is configured with the following definition in the\
    \ \L`karma.conf.js` file:"
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Karma的`init`命令时，默认情况下启用文件监视。Karma中的文件监视是通过`karma.conf.js`文件中的以下定义进行配置：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The file watching feature works as expected and watches the files defined in
    the configuration's `files` array. When a file is updated, changed, or deleted,
    Karma responds by rerunning the tests. From a TDD perspective, this is a great
    feature, as tests will continue to run without any manual intervention.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 文件监视功能按预期工作，并监视配置中`files`数组中定义的文件。当文件被更新、更改或删除时，Karma会重新运行测试。从TDD的角度来看，这是一个很好的功能，因为测试将继续在没有任何手动干预的情况下运行。
- en: 'The main point to watch out for is the addition of files. If the file being
    added doesn''t match the criteria in the `files` array, the `autoWatch` parameter
    won''t respond to the change. As an example, let''s consider that the files are
    defined as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的主要问题是添加文件。如果要添加的文件不符合`files`数组中的条件，`autoWatch`参数将无法响应更改。例如，让我们考虑以下文件的定义：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If this is the case, the watcher will find all the files and subdirectory files
    ending in `.js`. If a new file is in a different directory, not in `dir1`, then
    the watcher will not be able to respond to the new file because it is in a different
    directory from what it was configured in.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，监视程序将找到所有以`.js`结尾的文件和子目录文件。如果新文件位于不同的目录中，而不在`dir1`中，则监视程序将无法响应新文件，因为它位于与配置不同的目录中。
- en: Testing routers and navigation
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试路由器和导航
- en: We were introduced to Angular routers and navigation alongside the general components
    in [Chapter 7](ch07.html "Chapter 7. Flip Flop"), *Flip Flop*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](ch07.html "第7章。Flip Flop")*Flip Flop*中介绍了Angular路由器和导航以及一般组件。
- en: As we have discussed the different types of tests for Angular components, routers
    and navigation, we will look at integration testing. For that, we will use our
    application component test, that is, our base component, and we will then integrate
    navigation and `router-outlet` component tests with the application component
    to test the router.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过Angular组件、路由器和导航的不同类型的测试，我们将看一下集成测试。为此，我们将使用我们的应用组件测试，也就是我们的基础组件，然后将路由和`router-outlet`组件测试与应用组件集成，以测试路由器。
- en: Testing the app component
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试应用组件
- en: Before we go ahead with router testing, we will get ready with our application
    component tests. In the app component test, we will test whether the component
    is defined and initiated correctly, and then we will test the page title by selecting
    the DOM element.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行路由器测试之前，我们将准备好我们的应用组件测试。在应用组件测试中，我们将测试组件是否被正确定义和初始化，然后通过选择DOM元素来测试页面标题。
- en: 'We learned about shallow testing in previous sections; when we interact with
    DOM elements, we need shallow testing. The same goes here: as we will have to
    deal with DOM elements, we will use shallow testing as our application component
    test.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中学习了浅层测试；当我们与DOM元素交互时，我们需要进行浅层测试。在这里也是一样的：因为我们将要处理DOM元素，所以我们将使用浅层测试作为我们的应用组件测试。
- en: For shallow testing, we will need to depend on the `TestBed` Angular test API
    from Angular core testing, which will be used to compile and initiate the components
    in the test suite. Besides that, we will have to depend on the `ComponentFixture`
    module from core testing. We will need two more modules, named `By` and `DebugElement`,
    from the Angular core and platform APIs to interact with DOM elements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浅层测试，我们将需要依赖于Angular核心测试中的`TestBed` Angular测试API，它将用于编译和初始化测试套件中的组件。除此之外，我们还将需要依赖于核心测试中的`ComponentFixture`模块。我们还需要两个模块，名为`By`和`DebugElement`，来自Angular核心和平台API，用于与DOM元素交互。
- en: 'Our app component test will be located at `spec/unit/app.component.ts` and
    will look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用组件测试将位于`spec/unit/app.component.ts`，并且将如下所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we run this test, we will see the following result:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个测试，我们将看到以下结果：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our application component test is ready now; next, we will perform a router
    test, including `router-outlet` and navigation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用组件测试现在已经准备好了；接下来，我们将进行路由器测试，包括`router-outlet`和导航。
- en: Testing router
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试路由器
- en: The Angular router is not part of Angular core; it's a separate module that
    has to be imported before being used. It has some directives, such as `RouterOutlet`
    and `RouterLink`, which play an active role in fulfilling router activities. To
    test the router, first we will test these directives, in order to prepare the
    platform for testing the complete router.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器不是Angular核心的一部分；它是一个单独的模块，必须在使用之前导入。它有一些指令，比如`RouterOutlet`和`RouterLink`，在完成路由器活动时起着积极的作用。为了测试路由器，首先我们将测试这些指令，以准备好测试完整的路由器的平台。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We can test the router using the actual router module, but sometimes it creates
    some complexity for the entire routing system. Due to this, test specs may fail
    without providing an accurate error. To avoid this, it's recommended to create
    router stubs and use those for router testing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用实际的路由器模块来测试路由器，但有时会给整个路由系统带来一些复杂性。因此，测试规范可能会失败，而没有提供准确的错误。为了避免这种情况，建议创建路由器存根并将其用于路由器测试。
- en: Router stubs
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由器存根
- en: I had the router stubs idea from Angular's official testing docs. I liked the
    idea about the routing stubs and copied the `router-stubs` file from `angular.io/public/docs/_examples/testing/ts/testing/router-stubs.ts`
    in Angular's GitHub repository. The first router stubs directive is `RouterStubLinksDirective`,
    which is responsible for hosting the element or anchor link (`<a>`) to perform
    the `click` event for the directive's `onClick()` method. The URL bound to the
    `[routerLink]` attribute flows to the directive's `linkParams` property. When
    the anchor link (`<a>`) is clicked on, it should trigger the `onClick()` method,
    and it will set to the tentative `navigateTo` property.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我从Angular官方的测试文档中得到了路由存根的想法。我喜欢关于路由存根的想法，并从Angular的GitHub存储库中的`angular.io/public/docs/_examples/testing/ts/testing/router-stubs.ts`文件中复制了`router-stubs`文件。第一个路由存根指令是`RouterStubLinksDirective`，它负责托管元素或锚链接(`<a>`)来执行指令的`onClick()`方法。与`[routerLink]`属性绑定的URL流向指令的`linkParams`属性。当点击锚链接(`<a>`)时，它应该触发`onClick()`方法，并且将设置为临时的`navigateTo`属性。
- en: This `router-stubs` file has a dependency on the Angular router and relevant
    directives, including `RouterLink` and `RouterOutlet`, so we will need to import
    those.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`router-stubs`文件依赖于Angular路由和相关指令，包括`RouterLink`和`RouterOutlet`，因此我们需要导入它们。
- en: 'So, the router stubs will be located at `spec/unit/stub/router-stub.ts`, and
    the code will be as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，路由存根将位于`spec/unit/stub/router-stub.ts`，代码如下：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Beside the `RouterLinkStubDirective`, this stub should contain the `RouterOutletStubComponent`
    to support the `router-outlet` directive, and `RouterStub` to support the main
    router module:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`RouterLinkStubDirective`之外，这个存根应该包含`RouterOutletStubComponent`来支持`router-outlet`指令，以及`RouterStub`来支持主路由模块：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The router-outlet and navigation test
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由出口和导航测试
- en: As we know, the `router-outlet` and navigation (`RouterLink`) menus work together
    with the application landing page, that is, our application component. The testing
    mechanism will be of the same form. This means that we will test both of these
    modules with the application component.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，`router-outlet` 和导航 (`RouterLink`) 菜单与应用程序的登陆页面一起工作，也就是说，与我们的应用程序组件一起。测试机制将采用相同的形式。这意味着我们将测试这两个模块与应用程序组件。
- en: As mentioned a bit earlier, we will use an integration test here for `router-outlet`
    testing. We have our application component test suite ready; now it's time to
    integrate `router-outlet` and navigation (`RouterLink`), and we will have our
    integration test suite for the application component along with `router-outlet`
    and `RouterLink`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如稍早提到的，我们将在这里使用集成测试来进行`router-outlet`测试。我们已经准备好了应用程序组件的测试套件；现在是时候集成`router-outlet`和导航
    (`RouterLink`)，并且我们将有我们的应用程序组件的集成测试套件，以及`router-outlet`和`RouterLink`。
- en: We have the `navbar` component, which is basically a navigation component that contains
    the `RouterLink` to navigate through the router. We will have to import that component
    to our test suite for it to perform correctly. Besides the actual router module,
    we will have to import the `RouterStub` that we have created. To reiterate, `router-stubs`
    contains the `RouterOutletStubComponent` and `RouterLinkStubDirective` components.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`navbar`组件，基本上是一个导航组件，包含`RouterLink`来通过路由进行导航。我们将不得不将该组件导入到我们的测试套件中，以便它能够正确执行。除了实际的路由模块，我们还需要导入我们创建的`RouterStub`。再次强调，`router-stubs`包含`RouterOutletStubComponent`和`RouterLinkStubDirective`组件。
- en: After importing all the required components, we will have to declare them in
    the `TestBed` configuration. And, as a part of the setup, we will get all the
    `navLinks` from the `RouterLinkStubDirective` in the test suite's scope to test
    and bind `click` events to the `linkParams`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入所有必需的组件之后，我们将不得不在`TestBed`配置中声明它们。作为设置的一部分，我们将在测试套件的范围内从`RouterLinkStubDirective`中获取所有的`navLinks`来测试和绑定`click`事件到`linkParams`。
- en: 'The test suite''s setup will look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件的设置将如下所示：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For the test specs, first we will test the link parameters in the navigation
    menu. We have the `navLinks`, and we will match them with the `linkParams` of
    the `navLinks`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试规范，首先我们将测试导航菜单中的链接参数。我们有`navLinks`，我们将把它们与`navLinks`的`linkParams`进行匹配。
- en: Then, we will test the expected navigation while clicking on the navigation
    menu items. We will test that with the help of the `navigatedTo` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将测试在点击导航菜单项时预期的导航。我们将通过`navigatedTo`方法来测试。
- en: 'Our test specs will look as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试规范将如下所示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, we can say that this will cover the tests for `router-outlet` and routerLink,
    which will confirm that the router links are working as expected, and that we
    are able to navigate though the expected router after clicking on the navigation
    menu.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以说这将覆盖`router-outlet`和`routerLink`的测试，这将确认路由链接按预期工作，并且我们能够在点击导航菜单后导航到预期的路由。
- en: Implementing an integration test
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施集成测试
- en: Our test specs are ready. We have been planning for an integrated test, and
    we can perform one now. Here, we are combining the app component and `navbar`
    component, along with `router-outlet` and `routerLink`, to test the route and
    navigation. We have to interact with DOM elements with the help of the `debugElement`
    module from the browser platform API.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试规范已经准备好了。我们一直在计划进行集成测试，现在我们可以执行了。在这里，我们将组合应用组件和`navbar`组件，以及`router-outlet`和`routerLink`，来测试路由和导航。我们将使用浏览器平台API的`debugElement`模块与DOM元素进行交互。
- en: The test suite is ready--time to run the test.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件已经准备好了--是时候运行测试了。
- en: 'Let''s run it with the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下命令来运行它：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And all the test specs pass as expected. The result will be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试规范都按预期通过了。结果将如下：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: More tests...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多的测试...
- en: We just added some tests that will cover a few of the features that we have
    developed so far, mostly focused on the router (`router-outlet` and `routerLink`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加了一些测试，将覆盖到目前为止我们开发的一些功能，主要集中在路由器（`router-outlet`和`routerLink`）上。
- en: We will add more tests for members and the search feature, but we will update
    the behavior of the existing features of searching and member listing. Besides
    that, our current code base does not have proper decoupling between the components'
    features, which will make it complex to test features individually.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为成员和搜索功能添加更多的测试，但是我们将更新搜索和成员列表的现有功能的行为。除此之外，我们当前的代码库没有适当地解耦组件功能，这将使得单独测试功能变得复杂。
- en: We already have the end-to-end test, which will verify the output we expect
    from our components, but for unit testing, we will need to refactor the code and
    decouple them. We will cover the tests for the rest of the features after we update
    the behavior and refactor the correct code base.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了端到端测试，它将验证我们从组件中期望的输出，但是对于单元测试，我们需要重构代码并解耦它们。在更新行为并重构正确的代码库之后，我们将覆盖其余功能的测试。
- en: Recap of the application behavior
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用行为总结
- en: 'Let''s look at a quick overview of the search application:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看一下搜索应用的概述：
- en: 'Our search application invokes the Members component in the DOM. It contains
    two major parts: the search area and the result area.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的搜索应用在DOM中调用Members组件。它包含两个主要部分：搜索区域和结果区域。
- en: From the search area, we type a search query and submit it to get the expected
    result in the result area.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从搜索区域，我们输入搜索查询并提交以在结果区域获得预期结果。
- en: The resulting area lists down the member list based on the search query. We
    may have figured out that we get all the data during the initialization of the
    `Members` component; that's because we call the Members component's `search()`
    method with `ngOnInit()`, and it returns all the data as our logic has been set
    to return all data when no search query is set.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据搜索查询结果区域列出了成员列表。我们可能已经发现，在`Members`组件初始化时我们获取了所有数据；这是因为我们在`ngOnInit()`中调用了Members组件的`search()`方法，并且当没有设置搜索查询时，它会返回所有数据。
- en: By clicking on a member's name, we can see the detailed information about that
    member on the details page.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击成员的名字，我们可以在详细页面上看到关于该成员的详细信息。
- en: Updating the application behavior
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新应用程序行为
- en: According to the previous specification, it seems we have some incorrect behavior
    in the search feature. Right now, we are calling `search()` when initializing
    the members of the search component. This seems a bit wrong; we should start the
    search after entering the search query and/or clicking on the **Search** button.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 根据先前的规范，似乎我们在搜索功能中有一些不正确的行为。现在，我们在初始化搜索组件的成员时调用`search()`。这似乎有点不对；我们应该在输入搜索查询和/或点击**搜索**按钮后开始搜索。
- en: The expected behavior is that it will first load all the member data and then,
    after starting the search, the data list will be updated based on the search query.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 预期行为是首先加载所有成员数据，然后在开始搜索后，数据列表将根据搜索查询进行更新。
- en: To do so, let's update the `ngOnInit()` method in `members.component.ts` and
    add a new method, `getMember()`, to have the entire data list during component
    initiation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们更新`members.component.ts`中的`ngOnInit()`方法，并添加一个新方法`getMember()`，在组件初始化期间获取整个数据列表。
- en: 'The expected change will be as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的更改如下：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Identifying the problem
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别问题
- en: Based on the existing code, it seems we have defined the `getData()` method
    twice, in `members.component.ts` and `person.component.ts,` because in both the
    components, we had to call the JSON data source to get the member dataset.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 根据现有的代码，似乎我们在`members.component.ts`和`person.component.ts`中都定义了`getData()`方法，因为在这两个组件中，我们都需要调用JSON数据源来获取成员数据集。
- en: So, what's the problem with that? It's bad practice as it duplicates code, and
    duplication of code is hard to manage when the application becomes large and complex.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，问题是什么？这是一个不好的做法，因为它重复了代码，当应用程序变得庞大和复杂时，重复的代码很难管理。
- en: 'For example, now we have the following method twice:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现在我们有以下方法两次：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we have to to change the data source URL or API, we will have to change this
    method in two places. It's not so tough to change it twice, but what about 10-12
    times, or even more for a larger application?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须更改数据源URL或API，我们将不得不在两个地方更改此方法。两次更改并不那么困难，但是对于更大的应用程序来说，可能会更多次。
- en: Yes, it's a problem, and it needs a solution.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是一个问题，需要解决。
- en: Finding a solution
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找解决方案
- en: 'We''ve identified the problem, which is code duplication. We know the solution:
    we have to write the method in a common place and use it in both components. In
    short, we have to make this method reusable so that every component can share
    it.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了问题，即代码重复。我们知道解决方案：我们必须在一个共同的地方编写该方法，并在两个组件中使用它。简而言之，我们必须使这个方法可重用，以便每个组件都可以共享它。
- en: It seems simple, but we have to do it in the Angular way. We can't just move
    the method to a separate file and import that.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，但我们必须按照Angular的方式来做。我们不能只是将方法移到一个单独的文件中并导入它。
- en: Angular introduced services for such situations. We'll now look at some of those
    services with examples.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Angular为这种情况引入了服务。现在让我们通过示例来看一些这样的服务。
- en: Angular services
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular服务
- en: Angular services were introduced to write code shareable among components. So
    if we need a piece of code for many components, it's recommended to create a single
    reusable service, and wherever we need that piece of code, we can just inject
    that service to the component and use its methods as needed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Angular服务被引入以编写可在组件之间共享的代码。因此，如果我们需要为多个组件编写一段代码，建议创建一个可重用的单一服务，然后在需要该代码段的任何地方，只需将该服务注入到组件中，并根据需要使用其方法。
- en: "Services are used to abstract application logic. They are used to provide a\
    \ single responsibility for a particular action. Single responsibility allows\
    \ components to \Lbe easily tested and changed. This is because the focus is on\
    \ one component and \Lnot all the inner dependencies."
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 服务用于抽象应用程序逻辑。它们用于为特定操作提供单一职责。单一职责允许组件易于测试和更改。这是因为焦点在一个组件上，而不是所有内部依赖关系。
- en: Mostly, a service acts as the data source of any application. Whenever we need
    a piece of code to communicate with the server to get data (mostly JSON), we use
    a service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，服务充当任何应用程序的数据源。每当我们需要一段代码与服务器通信以获取数据（通常是JSON）时，我们使用服务。
- en: This is because most components need to access data, and everyone can inject
    the common service as required. So, we have a commonly used piece of code, which
    is actually the data layer for our application. We should move those parts to
    a service to make our application smart so that we can tell the world we are not
    duplicating code in any way.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为大多数组件需要访问数据，每个人都可以根据需要注入通用服务。因此，我们有一个常用的代码段，实际上是我们应用程序的数据层。我们应该将这些部分移至服务以使我们的应用程序更智能，以便我们可以告诉世界我们在任何方面都没有重复代码。
- en: We have service now?
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们现在有服务了？
- en: As planned, we have moved the `getData()` method from the `members.component.ts`
    and `person.component.ts` components to a new file so that we can get rid of code
    duplication.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 按计划，我们已将`members.component.ts`和`person.component.ts`组件中的`getData()`方法移至一个新文件，以便我们可以消除代码重复。
- en: Let's create a new file at `app/services/members.service.ts`, make a new class
    to export, called `MembersService`, and move the `getData()` method there. Besides
    moving the method, we will have to import `{ Http, Response }` from the Angular
    HTTP module as `getData` has a dependency on HTTP.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`app/services/members.service.ts`中创建一个新文件，创建一个新的类来导出，名为`MembersService`，并将`getData()`方法移至其中。除了移动方法之外，我们还需要从Angular
    HTTP模块中导入`{ Http, Response }`，因为`getData`依赖于HTTP。
- en: 'Observe the following code sample:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下代码示例：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have a service now, and we can start using it. Let's import and use it in
    the Members component.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个服务，可以开始使用它了。让我们在Members组件中导入并使用它。
- en: Wait; before that, we will have to import the service into the application module
    to have identification of it. As long as it's a service, we will have to identify
    it as a provider; the service will act as a service provider.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，在此之前，我们需要将服务导入到应用程序模块中以进行标识。只要它是一个服务，我们就必须将其标识为提供者；该服务将充当服务提供者。
- en: 'Our `app.module.ts` file will look like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`app.module.ts`文件将如下所示：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, to use the service in our component, we have to import and inject it into
    our MembersComponents with the service name `MembersService`. As long as we inject
    the service as the constructor of the component, we will have the service available
    to the entire component. To access the method, we need to call it `this.membersService.getData()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要在我们的组件中使用服务，我们必须将其导入并注入到我们的MembersComponents中，服务名称为`MembersService`。只要我们将服务作为组件的构造函数注入，我们就可以在整个组件中使用该服务。要访问该方法，我们需要调用`this.membersService.getData()`。
- en: 'So, our Members component will look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的成员组件将如下所示：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Time to run and look at the output and see how the service works with the Members
    component.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行并查看输出，看看服务如何与成员组件一起工作。
- en: Lets point the browser to `http://localhost:3000/members`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将浏览器指向`http://localhost:3000/members`。
- en: 'Oops! What happened? We are getting an error in the browser console:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！发生了什么？我们在浏览器控制台中收到了一个错误：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Based on the error, we have made a mistake: `SystemJS` (used as the module
    loaded) can''t inject `MembersService` as we missed adding something to the service
    to make it perfect. In Angular, we have to mention in every service whether it will
    be injectable; without doing so, we will not be able to inject that service into
    any component.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 根据错误，我们犯了一个错误：`SystemJS`（用作模块加载器）无法注入`MembersService`，因为我们忘记了添加一些内容使服务完美。在Angular中，我们必须在每个服务中说明它是否可注入；如果不这样做，我们将无法将该服务注入到任何组件中。
- en: And, for that, we will have to use the Angular **Injectable** decorator. We
    will take a look at it in brief.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将不得不使用Angular **Injectable**装饰器。我们将简要看一下它。
- en: Injectable services
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可注入服务
- en: The Injectable decorator is a part of the Angular core library, used when creating
    injectable services. Without defining it as injectable, it's not possible to identify
    the dependency of a service. To define it as injectable, we will have to use `@Injectable()`
    at the top of the class definition.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Injectable装饰器是Angular核心库的一部分，在创建可注入服务时使用。如果不将其定义为可注入的，就无法识别服务的依赖关系。要将其定义为可注入，我们必须在类定义的顶部使用`@Injectable()`。
- en: 'The code will look like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将如下所示：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have made the service injectable. Now, we should be fine to inject it into
    the Members component and point our browser to `http://localhost:3000/members`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使服务可注入。现在，我们应该可以将其注入到成员组件中，并将浏览器指向`http://localhost:3000/members`。
- en: 'Hurray! No more errors, and we are getting the expected data list:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！不再有错误，我们得到了预期的数据列表：
- en: '![Injectable services](graphics/image_08_003.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![可注入服务](graphics/image_08_003.jpg)'
- en: Seems like our service is injectable and working fine. It's time to implement
    it in the `PersonComponent`, as we need the data service on that component as
    well. The same as the Members component, let's import and inject it into the `PersonComponent`
    with the service name `membersService`. Again, we will have to access the data
    service method with `this.membersService.getData()`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的服务是可注入的，并且工作正常。现在是时候在`PersonComponent`中实现它，因为我们也需要在该组件上使用数据服务。与成员组件一样，让我们使用服务名称`membersService`将其导入并注入到`PersonComponent`中。同样，我们将不得不使用`this.membersService.getData()`来访问数据服务方法。
- en: 'Our `PersonComponent` will look like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PersonComponent`将如下所示：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Time to run and look at the output of how the service is working with the Members
    component.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行并查看服务与成员组件的输出了。
- en: 'We have our e2e test, which will confirm that everything is going well with
    the new changes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的端到端测试，它将确认新更改一切正常：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Yes, everything passes successfully:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，一切都顺利通过了：
- en: '![Injectable services](graphics/chapter_08_02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![可注入服务](graphics/chapter_08_02.jpg)'
- en: Yay! Our code refactoring hasn't affected our expected behavior.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 耶！我们的代码重构没有影响我们的预期行为。
- en: Services will serve you more
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务将为您提供更多
- en: To reap the complete benefits of services, we will move two more methods from
    the Members and Person components. Before that, those methods were component specific;
    now, by adding them to a service, those methods can be used from any component
    just by injecting the service.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用服务的全部优势，我们将从成员和人员组件中移动两个以上的方法。在此之前，这些方法是特定于组件的；现在，通过将它们添加到服务中，这些方法可以通过注入服务从任何组件中使用。
- en: Perhaps we will benefit later from this change but want to keep these methods
    decoupled from the components.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们以后会从这个改变中受益，但是希望将这些方法与组件解耦。
- en: 'The newly added code will look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 新添加的代码将如下所示：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Testing the service
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试服务
- en: The goal behind the code decoupling and separation was to make the code testable.
    We did so, and we have separated the data retrieval part from the Members component
    and made a service so that it will be easy to test. The service is injectable;
    other than that, it's similar to an angular component. So, to perform unit testing,
    we will test the methods that the service contains.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解耦和分离背后的目标是使代码可测试。我们这样做了，我们已经将数据检索部分从成员组件中分离出来，并创建了一个服务，以便易于测试。该服务是可注入的；除此之外，它与
    Angular 组件类似。因此，为了进行单元测试，我们将测试服务包含的方法。
- en: Testing service injection
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试服务注入
- en: Like other Angular components, we can test whether the service is defined well.
    But the main difference is that, as long as the service is injectable, we will
    need to inject it in the test specs to get the instance to test.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他 Angular 组件一样，我们可以测试服务是否定义良好。但主要区别在于，只要服务是可注入的，我们就需要在测试规范中注入它以获取要测试的实例。
- en: For a sample test spec, we can set it up so that it will import the `TestBed`
    and `inject`, and then configure the `TestingModule` using MembersService as the
    provider. Then, in the test spec, we will inject the service and check whether the
    service is defined as expected.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个样本测试规范，我们可以设置它导入 `TestBed` 和 `inject`，然后使用 MembersService 作为提供者配置 `TestingModule`。然后，在测试规范中，我们将注入服务并检查服务是否符合预期。
- en: 'Our sample test suite will look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的样本测试套件将如下所示：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For this test, the expected result will be true.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，预期结果将为 true。
- en: Testing HTTP requests
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 HTTP 请求
- en: To have a unit test for HTTP requests, we will have to use the async technique
    to keep the HTTP call asynchronous, and in Angular testing, we will use the `fakeAsync`
    module, which is an async module to use with mock HTTP requests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要对 HTTP 请求进行单元测试，我们将使用异步技术来保持 HTTP 调用异步，并在 Angular 测试中，我们将使用 `fakeAsync` 模块，这是一个用于模拟
    HTTP 请求的异步模块。
- en: Wait, "mock"?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，“模拟”？
- en: Well yes; to test HTTP requests in an Angular test suite, we don't need to make
    actual HTTP requests. To achieve the effect of an HTTP request, we can mock out
    our HTTP services; Angular has provided a mock service called **MockBackend**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 是的；要在 Angular 测试套件中测试 HTTP 请求，我们不需要进行实际的 HTTP 请求。为了实现 HTTP 请求的效果，我们可以模拟我们的 HTTP
    服务；Angular 提供了一个名为 **MockBackend** 的模拟服务。
- en: '`MockBackend` is a class that can be configured to provide mock responses for
    HTTP mock requests, and it will work exactly the same as HTTP services but without
    making the actual network requests.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockBackend` 是一个可以配置为为 HTTP 模拟请求提供模拟响应的类，它将与 HTTP 服务完全相同，但不会进行实际的网络请求。'
- en: After we have configured the `MockBackend`, it can be injected into HTTP. So,
    from our service where we used `http.get`, we'll have the expected data returned.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们配置了 `MockBackend` 之后，它可以被注入到 HTTP 中。因此，在我们使用 `http.get` 的服务中，我们将得到预期的数据返回。
- en: 'Our test suite with the HTTP request will look like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的带有 HTTP 请求的测试套件将如下所示：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, at first, besides importing the `MockBackend`, we are importing the `MockConnection`,
    which is used to subscribe to the backend connection and provide the connected
    data to the next steps. Then, we configure the `MockBackend`, which will return
    the HTTP object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，首先除了导入 `MockBackend` 外，我们还导入了 `MockConnection`，它用于订阅后端连接并将连接的数据提供给下一步。然后，我们配置了
    `MockBackend`，它将返回 HTTP 对象。
- en: 'Next, we will get ready with our test specs by injecting `MockBackend` and
    `MembersService`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过注入 `MockBackend` 和 `MembersService` 准备好我们的测试规范：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the test spec, we have injected `MockBackend`, in addition to the MembersService.
    `MockBackend` will subscribe to the `backend` service with the MockConnection object.
    MockConnection will create a new `ResponseOptions` object, where, with a `ResponseOptions`
    object we can configure our response properties.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试规范中，我们除了`MembersService`之外还注入了`MockBackend`。`MockBackend`将使用`MockConnection`对象订阅`backend`服务。`MockConnection`将创建一个新的`ResponseOptions`对象，在这个对象中，我们可以配置我们的响应属性。
- en: Here, we just set the `body` property of the response object and set the `body`
    value to a predefined `mockData` object.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只设置了响应对象的`body`属性，并将`body`值设置为预定义的`mockData`对象。
- en: Service stubs
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务存根
- en: We can test the service with stub data as well. For example, we can make a stubbed
    version of our `MembersService` called `MembersServiceSpy`, which will fake all
    the necessary features of that service.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用存根数据测试服务。例如，我们可以创建一个名为`MembersServiceSpy`的`MembersService`的存根版本，它将模拟该服务的所有必要功能。
- en: This fake service will return a resolved `Promise` with mock data, so we can
    just use this stubbed method for testing. It will create a spy for all of the
    methods we have in the service and return a separate `Promise` for every single
    method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个虚假服务将返回一个带有模拟数据的resolved `Promise`，因此我们可以只使用这个存根方法进行测试。它将为我们在服务中拥有的所有方法创建一个spy，并为每个单独的方法返回一个单独的`Promise`。
- en: 'The stubbed service will be located at `spec/unit/stub/members.service.stub.ts`,
    and it will be as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 存根服务将位于`spec/unit/stub/members.service.stub.ts`，代码如下：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Service test with stubbed data
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用存根数据测试服务
- en: Here, we will test the `MembersService` with stubbed data. To do so, we will
    need to import the stubbed service. And with the `TestBed` configuration, we will
    have to provide `MemberServiceSpy` as a service instead of an actual member service.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用存根数据测试`MembersService`。为此，我们需要导入存根服务。并且在`TestBed`配置中，我们将提供`MemberServiceSpy`作为服务，而不是实际的成员服务。
- en: 'The `MembersService` test suite''s code will look as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`MembersService`测试套件的代码如下所示：'
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Combining and running the service's tests
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合并运行服务的测试
- en: We have two test suites for the Members service here. We can bring both together
    and run the test.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里为Members服务有两个测试套件。我们可以将它们合并并运行测试。
- en: 'The full test suite''s code will look like the following code snippet:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的测试套件代码将如下代码片段所示：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The test suite for the Members service is ready to run. Let''s run it with
    this command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Members服务的测试套件已经准备好运行。让我们使用以下命令运行它：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All the test specs pass as expected. The result will be as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的测试规范都如预期般通过。结果将如下所示：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Communicating through the power of events
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过事件的力量进行通信
- en: Angular has more powerful event-handling capabilities compared to Angular 1.x.
    Angular 1.x has two-way data binding, whereas Angular doesn't recommend that.
    Angular handles the communication between data and templates through the power
    of events.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与Angular 1.x相比，Angular具有更强大的事件处理能力。Angular 1.x具有双向数据绑定，而Angular不推荐使用。Angular通过事件的力量处理数据和模板之间的通信。
- en: Angular projects stand on the combination of some components. To function, these
    components need to communicate with each other to share data and events. Mostly,
    components need to communicate when they have a parent-child relationship. There
    are a few ways in which Angular can communicate between parent and child components.
    The best is by handling custom events. We will look at details about custom events
    and see how they work with our search application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Angular项目依赖于一些组件的组合。为了正常运行，这些组件需要相互通信以共享数据和事件。大多数情况下，组件需要在它们具有父子关系时进行通信。Angular可以通过几种方式在父子组件之间进行通信。最好的方式是通过处理自定义事件。我们将详细了解自定义事件，并看看它们如何与我们的搜索应用程序一起工作。
- en: Angular events
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular事件
- en: As we know, Angular recommends one-way data binding, which means only from components
    to DOM elements. This is unidirectional data flow, and it is how Angular works.
    What about when we need data flow in the other direction--from DOM elements to
    components? Doing so depends on different events, such as clicks, keystrokes,
    mouseover, and touch. These events will bind with DOM elements to listen to user
    action and pass that action to the component.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，Angular推荐单向数据绑定，这意味着只能从组件到DOM元素。这是单向数据流，这就是Angular的工作原理。那么当我们需要在另一个方向上进行数据流时--从DOM元素到组件呢？这取决于不同的事件，例如点击，按键，鼠标悬停和触摸。这些事件将绑定到DOM元素上，以侦听用户操作并将该操作传递给组件。
- en: 'The event binding syntax consists of the target event with parentheses to the
    left-hand side of the equals sign. The component contains the target event as
    a method, so whenever the event triggers, it will call the method from the component.
    Let''s look at the event that we have in the search form:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 事件绑定语法由带有括号的目标事件组成，位于等号的左侧。组件包含目标事件作为方法，因此每当事件触发时，它将从组件调用该方法。让我们看看搜索表单中的事件：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Any element's events are the common targets, but it's a bit different with Angular,
    as Angular at first checks whether the target name matches with the event property
    of any known directives or components.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 任何元素的事件都是常见的目标，但在Angular中有点不同，因为Angular首先会检查目标名称是否与任何已知指令或组件的事件属性匹配。
- en: Custom events in Angular
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular中的自定义事件
- en: Custom events are raised by directives or components with Angular `EventEmitter`.
    Directives create an `EventEmitter` object and expose themselves as its property
    to be passed via the `@Output` decorator. We will look at details of `@Output`
    decorator next. After exposing an `EventEmitter` object as a property, the directives
    will call `EventEmitter.emit(value)` to fire the event and pass the value to the
    parent directives.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义事件是由Angular的指令或组件引发的，使用`EventEmitter`。指令创建一个`EventEmitter`对象，并将自己公开为其属性，以通过`@Output`装饰器传递。我们将在接下来查看`@Output`装饰器的细节。在将`EventEmitter`对象公开为属性之后，指令将调用`EventEmitter.emit(value)`来触发事件并将值传递给父指令。
- en: 'The custom directive/component class will define the custom event as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义指令/组件类将定义自定义事件如下：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Parent directives will listen for the event by binding to this property and
    will receive the value through the `$event` object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 父指令将通过绑定到此属性来监听事件，并通过`$event`对象接收值。
- en: 'The parent directive/component will contain the custom directive as follows,
    where it will contain the custom event as `someCustomEvent`, which will trigger
    the `doSomething()` method of the parent directives:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 父指令/组件将包含自定义指令，其中将包含自定义事件`someCustomEvent`，它将触发父指令的`doSomething()`方法。
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The parent directive/component will contain the `doSomething()` method, as
    shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 父指令/组件将包含`doSomething()`方法，如下所示：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The Output and EventEmitter APIs
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出和EventEmitter API
- en: Output is a decorator class from the Angular core that is used to pass custom
    events from a child to a parent component. To use it, we need to import it from
    `@angular/core`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Output是来自Angular核心的装饰器类，用于从子组件传递自定义事件到父组件。要使用它，我们需要从`@angular/core`中导入它。
- en: 'When we set a custom event as `@Output`, that event will be available to listen
    to in the parent component. This decorator will be placed inside the class, as
    follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将自定义事件设置为`@Output`时，该事件将在父组件中可供监听。该装饰器将放置在类内部，如下所示：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`EventEmitter` is also a core class of Angular. When we need to use it, we
    will have to import it from `@angular/core`. The `EventEmitter` API is used to
    notify the parent component by calling `EventEmitter.emit(value)` whenever the
    value changes in the child component. As we know, the parent component always
    listens to the custom event.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`也是Angular的核心类。当我们需要使用它时，我们必须从`@angular/core`导入它。`EventEmitter`
    API用于在子组件中的值发生变化时通过调用`EventEmitter.emit(value)`来通知父组件。正如我们所知，父组件总是监听自定义事件。'
- en: Planning further improvements
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步改进规划
- en: The search application we have so far is a simple search application. But we
    can make it better by keeping it as simple as it is. What I mean is, we can do
    this in the best way, like we were trying to decouple the data logic by separating
    the reusable code in the new service.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们拥有的搜索应用程序是一个简单的搜索应用程序。但是我们可以通过保持它的简单性来使其变得更好。我的意思是，我们可以以最佳方式做到这一点，就像我们试图通过将可重用代码分离到新的服务中来解耦数据逻辑一样。
- en: We still have a few more things to improve. It seems our application has not
    yet decoupled perfectly. Our components have not decoupled as we'd expected. We
    are talking about the `MembersComponent`, which contains the search feature and
    member listing feature.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有一些需要改进的地方。看起来我们的应用程序还没有完全解耦。我们的组件没有像我们期望的那样解耦。我们正在谈论包含搜索功能和成员列表功能的`MembersComponent`。
- en: We will follow the single responsibility principle here, which means every component
    should have a single responsibility. Here, `MembersComponent` has two. So we should
    break down this component to two separate components.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循单一责任原则，这意味着每个组件应该有单一责任。在这里，`MembersComponent`有两个责任。因此，我们应该将这个组件拆分为两个单独的组件。
- en: Let's break it down to two separate components, called `MembersComponent` and
    `SearchComponent`. In fact, we just made a plan for a new component called `SearchComponent`
    and brought the search feature over there from the Members component.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其拆分为两个单独的组件，称为`MembersComponent`和`SearchComponent`。实际上，我们刚刚为一个名为`SearchComponent`的新组件制定了计划，并从成员组件中将搜索功能移到了那里。
- en: 'Now let''s make a plan for the behavior expected from both components:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为两个组件期望的行为制定计划：
- en: The search component will have the responsibility of taking the user input as
    a search query and getting the expected search result using the service we have
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索组件将负责将用户输入作为搜索查询，并使用我们的服务获取预期的搜索结果
- en: We then pass the search result to the Members component
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们将搜索结果传递给成员组件
- en: The Members component will get the search result from the search component and
    will bind the data list to the DOM
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员组件将从搜索组件获取搜索结果，并将数据列表绑定到DOM
- en: Both components will communicate and exchange data using events
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个组件将使用事件进行通信和数据交换
- en: The plan is to make this simple app perfect by following best practices and
    using the built-in powers of Angular.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是通过遵循最佳实践和使用Angular的内置功能使这个简单的应用程序变得完美。
- en: The search component
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索组件
- en: As planned, we will have to separate the search feature from the Members component.
    To do that, let's create a new component called `SearchComponent` at `app/search/search.component.ts`
    and create the search component's template file. The template file will simply
    contain the search form.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 按计划，我们需要将搜索功能与成员组件分离。为此，让我们在`app/search/search.component.ts`创建一个名为`SearchComponent`的新组件，并创建搜索组件的模板文件。模板文件将简单包含搜索表单。
- en: The search component file will have to import and inject the `MembersService`,
    as that will be used to perform the search based on the search query. The component
    will have the search query and will request the service for search and get the
    search result.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件文件将需要导入和注入`MembersService`，因为它将用于根据搜索查询执行搜索。该组件将具有搜索查询，并将请求服务进行搜索并获取搜索结果。
- en: 'The search component''s code will look like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件的代码将如下所示：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The template of the search component will look like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件的模板将如下所示：
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As long as our application output doesn't break, we will have to bind the search
    component to the members list page, as it was before. So, we will have to append
    the search component to the template of the Members component. In that case, it
    will become the child component of the Members component.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们的应用程序输出不会出错，我们将不得不将搜索组件绑定到成员列表页面，就像以前一样。因此，我们将不得不将搜索组件附加到成员组件的模板中。在这种情况下，它将成为成员组件的子组件。
- en: 'The template of the Members component will look like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 成员组件的模板将如下所示：
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Enabling sharing between components
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用组件之间的共享
- en: Now we have two separate components, the search and Members components. The
    search component has been appended to the Members component, but search results
    are not available in the Members component.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个独立的组件，搜索和成员组件。搜索组件已附加到成员组件，但搜索结果在成员组件中不可用。
- en: Search and Members are separate components, and there is no bridge between them.
    Both have an isolated scope to contain their elements and variables.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索和成员是独立的组件，它们之间没有桥梁。两者都有隔离的范围来包含它们的元素和变量。
- en: To share data between components, we need to enable communication between them.
    As explained before, Angular events will come to our rescue for us to enable communication
    between the search and Members component. From the search component, we will need
    to use Angular custom events to communicate with its parent component, `MembersComponent`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在组件之间共享数据，我们需要启用它们之间的通信。如前所述，Angular事件将会拯救我们，使我们能够在搜索和成员组件之间启用通信。从搜索组件，我们需要使用Angular自定义事件与其父组件`MembersComponent`进行通信。
- en: Communicating with the parent component
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与父组件通信
- en: The search component is the child component of the Members component. They need
    to communicate with each other to share data. We will need to use custom events
    with the help of the Angular `EventEmiiter` API so that we can emit the search
    result from the search component after getting the result. And besides that, we
    will need to use the `@OutPut` decorator to set the search result as the output
    to use for the parent component.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件是成员组件的子组件。它们需要相互通信以共享数据。我们将需要使用自定义事件，借助Angular的`EventEmiiter` API来自搜索组件发出搜索结果。此外，我们还需要使用`@OutPut`装饰器将搜索结果设置为输出，以供父组件使用。
- en: To use both, we will need to import both from Angular core. Then, we will need
    to set `@Output` searchResult to a new instance of EventEmitter. This `@Output`
    decorator makes the `searchResult` property available as an event binding.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用两者，我们需要从Angular核心中导入两者。然后，我们需要将`@Output`搜索结果设置为EventEmitter的新实例。这个`@Output`装饰器使`searchResult`属性可用作事件绑定。
- en: When the search component updates the search result, we would like to tell the
    parent component that the `searchResult` event has happened. To do so, we will
    need to call `emit(data)` with the `searchResult` we have declared as the Emitter
    object with the Output decorator. The `emit()` method is used to notify every
    time the result has been passed via a custom event.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当搜索组件更新搜索结果时，我们希望告诉父组件`searchResult`事件已发生。为此，我们需要使用Output装饰器声明的Emitter对象调用`emit(data)`与我们声明的`searchResult`一起。`emit()`方法用于通过自定义事件通知每次结果已传递。
- en: Now, the Members component can fetch the `$event` object, as we've passed it
    into the template using `(searchRessult)="anyMethod($event);`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Members组件可以获取`$event`对象，因为我们已经将其传递到模板中，使用`(searchRessult)="anyMethod($event);`。
- en: 'After updating with `EventEmitter`, the search component will look like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后，带有`EventEmitter`的搜索组件将如下所示：
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now it's time to communicate with the `MembersComponent`. Let's declare the
    `onSearch()` method in the member component, which will accept the event as an
    argument.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候与`MembersComponent`通信了。让我们在成员组件中声明`onSearch()`方法，它将接受事件作为参数。
- en: 'The Members component will change to the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Members组件将更改为以下内容：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we are appending the search component from the members template, let's hook
    the `onSearch` function to the search component tag. We will call this `(searchResult)`--with
    parentheses around it--to tell Angular that this is an event binding.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在从成员模板中附加搜索组件，让我们将`onSearch`函数挂钩到搜索组件标记上。我们将称之为`(searchResult)`--在其周围加上括号--告诉Angular这是一个事件绑定。
- en: 'The template of the search component will look like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件的模板将如下所示：
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Check output after refactoring
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构后检查输出
- en: The search application will be rebranded into a store application instead of
    rewriting the search functionality that has already been written. In order to
    leverage the existing search project, it will be copied into a new project file.
    Then, the new project will use the tests to drive the development changes and
    refactoring. The refactoring steps have been left out, but a review of the code
    will show how the code and tests were modified to create the product application.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索应用将被重新打造成一个商店应用，而不是重写已经编写的搜索功能。为了利用现有的搜索项目，它将被复制到一个新的项目文件中。然后，新项目将使用测试来驱动开发变化和重构。重构步骤已被省略，但代码审查将展示代码和测试如何被修改以创建产品应用。
- en: Time to run it and see how the service works with the Members component. Let's
    point our browser to `http://localhost:3000/members`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行它，看看服务如何与Members组件一起工作。让我们将浏览器指向`http://localhost:3000/members`。
- en: '![Check output after refactoring](graphics/chapter_08_03.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![重构后检查输出](graphics/chapter_08_03.jpg)'
- en: 'We have the e2e test, which will confirm that everything''s going well with
    the new changes:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有端到端测试，将确认新更改一切顺利：
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Yes, we can see that everything passes successfully:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以看到一切都顺利通过了：
- en: '![Check output after refactoring](graphics/chapter_08_02.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![重构后检查输出](graphics/chapter_08_02.jpg)'
- en: Yes! Our code refactoring hasn't affected our expected behavior.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们的代码重构没有影响我们的预期行为。
- en: '**Current project directory**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前项目目录**'
- en: We have updated and refactored the code, for which we have some new components,
    services, and so on. Now, we will have a new project structure, separating the
    logic and decoupling the components.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新和重构了代码，为此我们有一些新的组件、服务等。现在，我们将有一个新的项目结构，将逻辑和组件解耦。
- en: 'Our current directory structure looks like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的目录结构如下：
- en: '![Check output after refactoring](graphics/image_08_004.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![重构后检查输出](graphics/image_08_004.jpg)'
- en: Moving ahead
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续前进
- en: In this book, I have tried to cover the topics to a certain level so that anyone
    can start with test-driven development based on Angular. But there are a lot of
    things we have skipped, most importantly, rxJS.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我尽量涵盖了一定程度的主题，以便任何人都可以基于Angular开始测试驱动开发。但我们跳过了很多重要的内容，尤其是rxJS。
- en: rxJS is a separate module based on reactive programming. So, we will need to
    be familiar with reactive programming to understand it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: rxJS是基于响应式编程的一个单独模块。因此，我们需要熟悉响应式编程才能理解它。
- en: Observables
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察对象
- en: HTTP requests by default return observables as responses in Angular instead
    of resolved promises. Since we didn't look at rxJS here, we skipped observables
    and converted the responses to promises. But we should learn how observables work
    with Angular.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，默认情况下，HTTP请求返回的是可观察对象而不是已解决的承诺。由于我们在这里没有涉及rxJS，我们跳过了可观察对象，并将响应转换为承诺。但我们应该学习可观察对象如何在Angular中工作。
- en: Publishing and subscribing
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布和订阅
- en: Publishing and subscribing messages is a powerful tool, but as with anything,
    when used the wrong way, it can lead to a mess.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 发布和订阅消息是一个强大的工具，但和任何东西一样，如果使用不当，可能会导致混乱。
- en: 'There are two ways in which messages can be published: emit or broadcast. It
    is important to know the difference, as both work slightly differently and they
    may affect the performance of our application.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种消息发布的方式：发射或广播。了解区别很重要，因为它们的工作方式略有不同，可能会影响我们应用的性能。
- en: Self-test questions
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: Q1\. A callback function refers to a function that is called after an asynchronous
    function completes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 回调函数指的是在异步函数完成后被调用的函数。
- en: 'True'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Q2\. Asynchronous functions always complete in the order in which they were
    called.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 异步函数总是按调用顺序完成。
- en: 'True'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Q3\. There is a module called `MockBackend` to fake HTTP calls in Angular for unit
    testing.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. Angular中有一个名为`MockBackend`的模块，用于在单元测试中伪造HTTP调用。
- en: 'True'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Q4\. In Angular, the `EventEmitter` API is used for component communication.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 在Angular中，`EventEmitter` API 用于组件通信。
- en: 'True'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored services in Angular and the power of events. We
    also saw some examples of the separation of code with services and events.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Angular中的服务和事件的强大功能。我们还看到了一些通过服务和事件分离代码的示例。
- en: In addition, we looked at different types of testing for Angular components
    and wrote unit tests for the Angular router, and we integrated it with application
    components and navigation. We also explored further configuration of Karma in
    order to use its features.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还研究了Angular组件的不同类型测试，并为Angular路由编写了单元测试，并将其与应用程序组件和导航集成。我们还进一步探讨了Karma的配置，以便使用其功能。
- en: Now that we're at the end of the book, it's time to apply our knowledge in the real
    world. Before leaving, let's have a quick recap of what we have learned. We learned
    about TDD, how TDD works with JavaScript context, and the available testing tools,
    techniques, and frameworks. We learned about Karma and Protractor with real Angular
    projects. And now we know how to write unit and e2e tests for Angular projects.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到达书的结尾，是时候将我们的知识应用到现实世界中了。在离开之前，让我们快速回顾一下我们学到了什么。我们学习了TDD，TDD如何在JavaScript环境中运行，以及可用的测试工具、技术和框架。我们了解了Karma和Protractor在真实的Angular项目中的使用。现在我们知道如何为Angular项目编写单元测试和端到端测试。
- en: This book showed you the path to practicing TDD; now it's your job to keep learning,
    improve on this knowledge, and practice more with complex projects to be more
    confident with TDD.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书向你展示了实践TDD的路径；现在轮到你继续学习，提高这方面的知识，并在复杂项目中进行更多实践，以便更加自信地应用TDD。
