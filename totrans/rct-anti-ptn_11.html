<html><head></head><body>
<section epub:type="frontmatter chapter" role="doc-chapter">
<h1 class="chapter-number" id="_idParaDest-157"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-158"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.2.1">Introducing Layered Architecture in React</span></h1>
<p><span class="koboSpan" id="kobo.3.1">As React applications grow in size and complexity, managing code efficiently becomes a challenge. </span><span class="koboSpan" id="kobo.3.2">The linear growth of features can lead to an exponential increase in complexity, making the code base difficult to understand, test, and maintain. </span><span class="koboSpan" id="kobo.3.3">Enter </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Layered Architecture</span></strong><span class="koboSpan" id="kobo.5.1">, a design </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.6.1">approach that’s not just confined to backend systems but is equally beneficial for client-side applications.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Structuring your React application in a layered manner solves several key problems:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.8.1">Separation of concerns</span></strong><span class="koboSpan" id="kobo.9.1">: Different</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.10.1"> layers handle different responsibilities, making the code base easier to navigate and understand</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.11.1">Reusability</span></strong><span class="koboSpan" id="kobo.12.1">: Business</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.13.1"> logic and data models become easily reusable across different parts of the application</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.14.1">Testability</span></strong><span class="koboSpan" id="kobo.15.1">: A layered </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.16.1">architecture makes it simpler to write unit and integration tests, leading to a more robust application</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.17.1">Maintainability</span></strong><span class="koboSpan" id="kobo.18.1">: As the </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.19.1">application scales, making changes or adding features becomes significantly easier when following a layered structure</span></li>
</ul>
<p><span class="koboSpan" id="kobo.20.1">In this chapter, we will explore the concept of layered architecture in the context of a React application, delving into the extraction of application concern layers, defining precise data models, and illustrating the use of strategy patterns. </span><span class="koboSpan" id="kobo.20.2">Through a step-by-step example, we’ll see how to practically implement these concepts and why they are indispensable for large-scale applications.</span></p>
<p><span class="koboSpan" id="kobo.21.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.22.1">Understanding the evolution of a React application</span></li>
<li><span class="koboSpan" id="kobo.23.1">Enhancing the Code Oven application</span></li>
<li><span class="koboSpan" id="kobo.24.1">Implementing the ShoppingCart component</span></li>
<li><span class="koboSpan" id="kobo.25.1">Delving into layered architec</span><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.26.1">ture</span></li>
</ul>
<h1 id="_idParaDest-159"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.27.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.28.1">A GitHub repository has been created to host all the code we discuss in the book. </span><span class="koboSpan" id="kobo.28.2">For this chapter, you can find the recommended structure at </span><a href="https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch11"><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch11</span></a><span class="koboSpan" id="kobo.30.1">.</span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.31.1">Understanding the evolution of a React application</span></h1>
<p><span class="koboSpan" id="kobo.32.1">Applications with different sizes </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.33.1">require different strategies. </span><span class="koboSpan" id="kobo.33.2">For small or one-off projects, you might find that all logic is just written inside React components. </span><span class="koboSpan" id="kobo.33.3">You may see one or only a few components in total. </span><span class="koboSpan" id="kobo.33.4">The code looks pretty much like HTML, with only some variables or states used to make the page “dynamic,” but overall, the code is easy to understand and change.</span></p>
<p><span class="koboSpan" id="kobo.34.1">As the application grows, and more and more code is added to the code base, without a proper way to organize it, the code base will soon get into an unmaintainable state. </span><span class="koboSpan" id="kobo.34.2">This means that even adding small features will be time-consuming as developers need more time to read the code.</span></p>
<p><span class="koboSpan" id="kobo.35.1">In this section, I’ll list several different ways we can structure our React application to make sure our code always remains in a healthy state, making it effortless to add new features and easy to extend or fix existing defects. </span><span class="koboSpan" id="kobo.35.2">We’ll start with a simple structure and gradually evolve it to handle scale problems. </span><span class="koboSpan" id="kobo.35.3">Let’s have a quick review of the steps to build frontend applications that s</span><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.36.1">cale.</span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.37.1">Single-component applications</span></h2>
<p><span class="koboSpan" id="kobo.38.1">To start, let’s talk about the simplest possible </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.39.1">approach to writing a React application – a single-component application.</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.40.1"><img alt="Figure 11.1: Single-component applic﻿ation" src="image/B31103_11_01.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.41.1">Figure 11.1: Single-component applic</span><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.42.1">ation</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.43.1">The mono-component undertakes a variety of tasks, ranging from fetching data from a remote server, managing its internal state, and handling domain logic, to rendering. </span><span class="koboSpan" id="kobo.43.2">This approach may be suitable for small applications with a single form or for those looking to understand the process of transitioning their application from another framework to React.</span></p>
<p><span class="koboSpan" id="kobo.44.1">However, you’ll soon realize that consolidating everything into a single component can make the code difficult to understand and manage. </span><span class="koboSpan" id="kobo.44.2">Everything being housed in one component can quickly become overwhelming, particularly when dealing with logic such as iterating</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.45.1"> over item lists to create individual components. </span><span class="koboSpan" id="kobo.45.2">This complexity highlights the need to decompose the mono-component into smaller, responsibility-focused compo</span><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.46.1">nents.</span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.47.1">Multiple-component applications</span></h2>
<p><span class="koboSpan" id="kobo.48.1">Deciding to split the component into several </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.49.1">components, with these structures reflecting what’s happening on the resulting HTML, is a good idea and it helps you to focus on one component at a time.</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.50.1"><img alt="Figure 11.2: Multiple-component application" src="image/B31103_11_02.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.51.1">Figure 11.2: Multiple-component application</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.52.1">Essentially, you’ll transition from a monolithic component to multiple components, each with a specific purpose. </span><span class="koboSpan" id="kobo.52.2">For example, one component may be dedicated to rendering a list, another to rendering a list item, and another solely for fetching data and passing data down to its children.</span></p>
<p><span class="koboSpan" id="kobo.53.1">It’s better </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.54.1">to have clear responsibilities. </span><span class="koboSpan" id="kobo.54.2">However, as your application expands, responsibilities extend beyond the view layer to include tasks such as sending network requests, reshaping data for the view to consume, and collecting data to send back to the server. </span><span class="koboSpan" id="kobo.54.3">Additionally, there might be logic to transform data once it’s fetched. </span><span class="koboSpan" id="kobo.54.4">Housing this calculation logic within views doesn’t seem appropriate as it’s not directly related to user interfaces. </span><span class="koboSpan" id="kobo.54.5">Moreover, some components may become cluttered with excessive internal </span><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.55.1">states.</span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.56.1">State management with Hooks</span></h2>
<p><span class="koboSpan" id="kobo.57.1">It’s a better idea to split this logic into</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.58.1"> separate places. </span><span class="koboSpan" id="kobo.58.2">Luckily, in React, you can</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.59.1"> define your own Hooks. </span><span class="koboSpan" id="kobo.59.2">This is a great way to share this state and the logic whenever state changes.</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.60.1"><img alt="Figure 11.3: State management with Hooks" src="image/B31103_11_03.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.61.1">Figure 11.3: State management with Hooks</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.62.1">Now you have a bunch of elements extracted from components. </span><span class="koboSpan" id="kobo.62.2">You have a few pure presentational components, some reusable Hooks that make other components stateful, and some container components (for data fetching, for example).</span></p>
<p><span class="koboSpan" id="kobo.63.1">At this stage, it’s </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.64.1">common to find calculations scattered across views, Hooks, or </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.65.1">various utility functions. </span><span class="koboSpan" id="kobo.65.2">The lack of structure can make further modifications quite challenging and prone to errors. </span><span class="koboSpan" id="kobo.65.3">For instance, if you’ve fetched some data for rendering, but the data schema differs in views, you’ll need to transform the data. </span><span class="koboSpan" id="kobo.65.4">However, the location for placing this transforming logic may not</span><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.66.1"> be clear.</span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.67.1">Extracting business models</span></h2>
<p><span class="koboSpan" id="kobo.68.1">So, you’ve started to become aware that</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.69.1"> extracting this logic into yet another place can bring you many benefits. </span><span class="koboSpan" id="kobo.69.2">For example, with that split, the logic can be cohesive and independent of any views. </span><span class="koboSpan" id="kobo.69.3">Then, you extract a few domain objects.</span></p>
<p><span class="koboSpan" id="kobo.70.1">These simple objects can handle data mapping (from one format to another), check nulls, and use fallback values as required. </span><span class="koboSpan" id="kobo.70.2">As the amount of these domain objects grows, you will find you need some inheritance or polymorphism to make things even cleaner. </span><span class="koboSpan" id="kobo.70.3">Thus you apply many design patterns you find helpful from other places to the frontend application:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.71.1"><img alt="Figure 11.4: Extracting business models" src="image/B31103_11_04.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.72.1">Figure 11.4: Extracting business models</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.73.1">Now, your code base has expanded with more elements, each having a clear boundary regarding their responsibilities. </span><span class="koboSpan" id="kobo.73.2">Hooks are employed for state management, while domain objects represent domain concepts, such as a user object encompassing an avatar, or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">PaymentMethod</span></strong><span class="koboSpan" id="kobo.75.1"> object representing the details of a payment method.</span></p>
<p><span class="koboSpan" id="kobo.76.1">As we segregate different </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.77.1">elements from the views, the code base scales accordingly. </span><span class="koboSpan" id="kobo.77.2">Eventually, it reaches a point where we need to structure the application to respond to changes more ef</span><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.78.1">ficiently.</span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.79.1">Layered frontend application</span></h2>
<p><span class="koboSpan" id="kobo.80.1">As the application continues to evolve, certain </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.81.1">patterns begin to emerge. </span><span class="koboSpan" id="kobo.81.2">You’ll notice a collection of objects that don’t belong to any user interface, and they remain indifferent to whether the underlying data originates from a remote service, local storage, or cache. </span><span class="koboSpan" id="kobo.81.3">Consequently, you’ll want to segregate them into distinct layers. </span><span class="koboSpan" id="kobo.81.4">We’ll need to introduce a better approach for these different parts of the application.</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.82.1"><img alt="Figure 11.5: Layered frontend application" src="image/B31103_11_05.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.83.1">Figure 11.5: Layered frontend application</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.84.1">As illustrated in </span><i class="italic"><span class="koboSpan" id="kobo.85.1">Figure 11</span></i><i class="italic"><span class="koboSpan" id="kobo.86.1">.5</span></i><span class="koboSpan" id="kobo.87.1">, we can allocate different parts to separate folders, each distinctly and physically isolated from the others. </span><span class="koboSpan" id="kobo.87.2">This way, if there’s a need to modify models, you won’t need to navigate through the views folder, and vice versa.</span></p>
<p><span class="koboSpan" id="kobo.88.1">That was a high-level overview of the evolution process, and you should have a taste of how you should structure your code or at least what the direction should be. </span><span class="koboSpan" id="kobo.88.2">In larger-scale applications, you’ll likely encounter a variety of modules and functions, each tailored to different aspects of the app. </span><span class="koboSpan" id="kobo.88.3">This could include a request module for handling network requests, or adapters designed to interface with various data vendors, such as Google’s login API or payment gateway clients.</span></p>
<p><span class="koboSpan" id="kobo.89.1">However, there will be </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.90.1">many details, such as how to define a model, how to access a model from views or Hooks, and so on. </span><span class="koboSpan" id="kobo.90.2">You need to consider this before applying the theory to your application.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.91.1">Read more</span></p>
<p class="callout"><span class="koboSpan" id="kobo.92.1">You can find a detailed explanation of Presentation Domain Data Layering</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.93.1"> here: </span><a href="https://martinfowler.com/bliki/PresentationDomainDataLayering.html"><span class="koboSpan" id="kobo.94.1">https://martinfowler.com/bliki/PresentationDomainDataLayering.html</span></a><span class="koboSpan" id="kobo.95.1">.</span></p>
<p><span class="koboSpan" id="kobo.96.1">In the following sections, I’ll guide you through expanding the Code Oven application we introduced in </span><a href="B21103_07.xhtml#_idTextAnchor176"><i class="italic"><span class="koboSpan" id="kobo.97.1">Chapter 7</span></i></a><span class="koboSpan" id="kobo.98.1">, to showcase essential patterns and design principles for large frontend </span><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.99.1">applications.</span></p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.100.1">Enhancing the Code Oven application</span></h1>
<p><span class="koboSpan" id="kobo.101.1">Recall that at the end </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.102.1">of </span><a href="B21103_07.xhtml#_idTextAnchor176"><i class="italic"><span class="koboSpan" id="kobo.103.1">Chapter 7</span></i></a><span class="koboSpan" id="kobo.104.1">, we developed the basic structure of a pizza store application named Code Oven, leveraging test-driven development to establish a solid foundation for the app.</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.105.1"><img alt="Figure 11.6: The Code Oven application" src="image/B31103_11_06.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.106.1">Figure 11.6: The Code Oven application</span></figcaption> </figure>
<p class="callout-heading"><span class="koboSpan" id="kobo.107.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.108.1">Remember that we employed the design mockup as a guide, not to implement all the details exhaustively. </span><span class="koboSpan" id="kobo.108.2">The primary goal remains to illustrate how to refactor the code while preserving its maintainability.</span></p>
<p><span class="koboSpan" id="kobo.109.1">Although we didn’t </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.110.1">delve much into feature implementation in that chapter, in this chapter, we’ll extend our setup further. </span><span class="koboSpan" id="kobo.110.2">We’ll explore how different architectural types can assist us in managing complexity.</span></p>
<p><span class="koboSpan" id="kobo.111.1">As a refresher, by the end of </span><a href="B21103_07.xhtml#_idTextAnchor176"><i class="italic"><span class="koboSpan" id="kobo.112.1">Chapter 7</span></i></a><span class="koboSpan" id="kobo.113.1">, our structure looked like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
export function PizzaShopApp() {
  const [cartItems, setCartItems] = useState&lt;string[]&gt;([]);
  const addItem = (item: string) =&gt; {
    setCartItems([...cartItems, item]);
  };
  return (
    &lt;&gt;
      &lt;h1&gt;The Code Oven&lt;/h1&gt;
      &lt;MenuList onAddMenuItem={addItem} /&gt;
      &lt;ShoppingCart cartItems={cartItems} /&gt;
    &lt;/&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.115.1">And we assumed the data to be in this shape:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
const pizzas = [
  "Margherita Pizza",
  "Pepperoni Pizza",
  "Veggie Supreme Pizza"
];</span></pre> <p><span class="koboSpan" id="kobo.117.1">While this setup allows consumers to browse what the restaurant offers, it would be significantly more useful if we enabled online ordering. </span><span class="koboSpan" id="kobo.117.2">However, one immediate issue is that the pizzas lack prices and descriptions, crucial for supporting online orders. </span><span class="koboSpan" id="kobo.117.3">Descriptions are also vital as they list the ingredients, informing consumers of what’s included.</span></p>
<p><span class="koboSpan" id="kobo.118.1">Saying that, it’s</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.119.1"> actually not practical to define menu data within the JavaScript code. </span><span class="koboSpan" id="kobo.119.2">Typically, we’d have a service hosting such data, providing more detailed information.</span></p>
<p><span class="koboSpan" id="kobo.120.1">To show this, suppose we have data hosted on the </span><a href="https://api.code-oven.com/menus"><span class="koboSpan" id="kobo.121.1">https://api.code-oven.com/menus</span></a><span class="koboSpan" id="kobo.122.1"> remote service, defined as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.123.1">
[
  {
    "id": "p1",
    "name": "Margherita Pizza",
    "price": 10.99,
    "description": "Classic pizza with tomato sauce and mozzarella",
    "ingredients": ["Tomato Sauce", "Mozzarella Cheese", "Basil", 
     "Olive Oil"],
    "allergyTags": ["Dairy"],
    "calories": 250,
    "category": "Pizza"
  },
  //...
</span><span class="koboSpan" id="kobo.123.2">]</span></pre> <p><span class="koboSpan" id="kobo.124.1">To bridge the gap between our app and this data, we need to define a type for the remote data, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.125.1">
type RemoteMenuItem = {
  id: string;
  name: string;
  price: number;
  description: string;
  ingredients: string[];
  allergyTags: string[];
  category: string;
  calories: number
}</span></pre> <p><span class="koboSpan" id="kobo.126.1">Now, to integrate this </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.127.1">remote menu data, we’ll utilize </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">useEffect</span></strong><span class="koboSpan" id="kobo.129.1"> to fetch the data, and then display the items once fetched. </span><span class="koboSpan" id="kobo.129.2">We’ll make these changes within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">MenuList</span></strong><span class="koboSpan" id="kobo.131.1"> component:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.132.1">
const MenuList = ({
  onAddMenuItem,
}: {
  onAddMenuItem: (item: string) =&gt; void;
}) =&gt; {
  const [menuItems, setMenuItems] = useState&lt;string[]&gt;([]);
  useEffect(() =&gt; {
    const fetchMenuItems = async () =&gt; {
      const result = await fetch('</span><a href="https://api.code-oven.com/menus');"><span class="koboSpan" id="kobo.133.1">https://api.code-oven.com/menus');</span></a><span class="koboSpan" id="kobo.134.1">
      const menuItems = await result.json();
      setMenuItems(menuItems.map((item: RemoteMenuItem) =&gt; item.
</span><span class="koboSpan" id="kobo.134.2">       name));
    }
    fetchMenuItems();
  }, [])
  return (
    &lt;div data-testid="menu-list"&gt;
      &lt;ol&gt;
        {menuItems.map((item) =&gt; (
          &lt;li key={item}&gt;
            {item}
            &lt;button onClick={() =&gt; onAddMenuItem(item)}&gt;Add&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ol&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.135.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">MenuList</span></strong><span class="koboSpan" id="kobo.137.1"> component fetches a list of menu items from an external API upon the initial render and displays this list. </span><span class="koboSpan" id="kobo.137.2">Each item comes with an </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">Add</span></strong><span class="koboSpan" id="kobo.139.1"> button, and clicking this button triggers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">onAddMenuItem</span></strong><span class="koboSpan" id="kobo.141.1"> function, passed as a prop to </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">MenuList</span></strong><span class="koboSpan" id="kobo.143.1">, with the item name as its argument.</span></p>
<p><span class="koboSpan" id="kobo.144.1">By mapping </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">RemoteMenuItem</span></strong><span class="koboSpan" id="kobo.146.1"> to a string</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.147.1"> after fetching the data, we ensure our tests continue to pass.</span></p>
<p><span class="koboSpan" id="kobo.148.1">Now, we aim to reveal the price and display the ingredients from the data to the UI components. </span><span class="koboSpan" id="kobo.148.2">However, given the potentially long list of ingredients, we’ll only show the first three to avoid occupying too much screen space. </span><span class="koboSpan" id="kobo.148.3">Also, we want to use lowercase </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">category</span></strong><span class="koboSpan" id="kobo.150.1"> and rename it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">type</span></strong><span class="koboSpan" id="kobo.152.1">.</span></p>
<p><span class="koboSpan" id="kobo.153.1">Initially, we</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.154.1"> define a new type to better structure our data:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.155.1">
type MenuItem = {
  id: string;
  name: string;
  price: number;
  ingredients: string[];
  type: string;
}</span></pre> <p><span class="koboSpan" id="kobo.156.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">MenuItem</span></strong><span class="koboSpan" id="kobo.158.1"> type includes the item’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">id</span></strong><span class="koboSpan" id="kobo.160.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">name</span></strong><span class="koboSpan" id="kobo.162.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">price</span></strong><span class="koboSpan" id="kobo.164.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">ingredients</span></strong><span class="koboSpan" id="kobo.166.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">type</span></strong><span class="koboSpan" id="kobo.168.1"> properties.</span></p>
<p><span class="koboSpan" id="kobo.169.1">Now, it’s time to update our </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">MenuList</span></strong><span class="koboSpan" id="kobo.171.1"> component to use this new type:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.172.1">
const MenuList = ({
  onAddMenuItem,
}: {
  onAddMenuItem: (item: string) =&gt; void;
}) =&gt; {
  const [menuItems, setMenuItems] = useState&lt;MenuItem[]&gt;([]);
  useEffect(() =&gt; {
    const fetchMenuItems = async () =&gt; {
      const result = await fetch("http://api.code-oven.com/menus");
      const menuItems = await result.json();
      setMenuItems(
        menuItems.map((item: RemoteMenuItem) =&gt; {
          return {
            id: item.id,
            name: item.name,
            price: item.price,
            type: item.category.toUpperCase(),
            ingredients: item.ingredients.slice(0, 3),
          };
        })
      );
    };
    fetchMenuItems();
  }, []);
  return (
    &lt;div data-testid="menu-list"&gt;
      &lt;ol&gt;
        {menuItems.map((item) =&gt; (
          &lt;li key={item.id}&gt;
            &lt;h3&gt;{item.name}&lt;/h3&gt;
            &lt;span&gt;${item.price}&lt;/span&gt;
            &lt;div&gt;
              {item.ingredients.map((ingredient) =&gt; (
                &lt;span&gt;{ingredient}&lt;/span&gt;
              ))}
            &lt;/div&gt;
            &lt;button onClick={() =&gt; onAddMenuItem(item.name)}&gt;Add
             &lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ol&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.173.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">MenuList</span></strong><span class="koboSpan" id="kobo.175.1"> component, we’ve now made use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">MenuItem</span></strong><span class="koboSpan" id="kobo.177.1"> type in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">useState</span></strong><span class="koboSpan" id="kobo.179.1"> Hook. </span><span class="koboSpan" id="kobo.179.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">fetchMenuItems</span></strong><span class="koboSpan" id="kobo.181.1"> function, triggered within </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">useEffect</span></strong><span class="koboSpan" id="kobo.183.1">, reaches out to the API, fetches the menu items, and maps over them to transform the data into the desired </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">MenuItem</span></strong><span class="koboSpan" id="kobo.185.1"> format. </span><span class="koboSpan" id="kobo.185.2">This transformation includes retaining only the first three items from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">ingredients</span></strong><span class="koboSpan" id="kobo.187.1"> array for each item.</span></p>
<p><span class="koboSpan" id="kobo.188.1">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">MenuItem</span></strong><span class="koboSpan" id="kobo.190.1"> component is then rendered as a list item within the component. </span><span class="koboSpan" id="kobo.190.2">We display the item’s name, price, and iterate over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">ingredients</span></strong><span class="koboSpan" id="kobo.192.1"> array to render each ingredient.</span></p>
<p><span class="koboSpan" id="kobo.193.1">While the code is</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.194.1"> functional, there’s a concern: we’ve intertwined network requests, data mapping, and rendering logic within a single component. </span><span class="koboSpan" id="kobo.194.2">It’s a sound practice to separate view-related code from non-view code, ensuring cleaner, more</span><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.195.1"> maintainable code.</span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.196.1">Refactoring the MenuList through a custom Hook</span></h2>
<p><span class="koboSpan" id="kobo.197.1">We’re no strangers to using </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.198.1">custom Hooks for data fetching – it’s a practice that enhances readability and organizes logic neatly. </span><span class="koboSpan" id="kobo.198.2">In our scenario, extracting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">menuItems</span></strong><span class="koboSpan" id="kobo.200.1"> state and the fetching logic into a separate Hook will declutter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">MenuList</span></strong><span class="koboSpan" id="kobo.202.1"> component.</span></p>
<p><span class="koboSpan" id="kobo.203.1">So, let’s create a Hook</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.204.1"> named </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">useMenuItems</span></strong><span class="koboSpan" id="kobo.206.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
const useMenuItems = () =&gt; {
  const [menuItems, setMenuItems] = useState&lt;MenuItem[]&gt;([]);
  useEffect(() =&gt; {
    const fetchMenuItems = async () =&gt; {
      const result = await fetch(
        "https://api.code-oven.com/menus"
      );
      const menuItems = await result.json();
      setMenuItems(
        menuItems.map((item: RemoteMenuItem) =&gt; {
          // ... </span><span class="koboSpan" id="kobo.207.2">transform RemoteMenuItem to MenuItem
        })
      );
    };
    fetchMenuItems();
  }, []);
  return { menuItems };
};</span></pre> <p><span class="koboSpan" id="kobo.208.1">Within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">useMenuItems</span></strong><span class="koboSpan" id="kobo.210.1"> Hook, we initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">menuItems</span></strong><span class="koboSpan" id="kobo.212.1"> state with an empty array. </span><span class="koboSpan" id="kobo.212.2">When the Hook mounts, it triggers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">fetchMenuItems</span></strong><span class="koboSpan" id="kobo.214.1"> function that fetches data from the specified URL. </span><span class="koboSpan" id="kobo.214.2">Following the fetch, a mapping operation is performed to convert each </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">RemoteMenuItem</span></strong><span class="koboSpan" id="kobo.216.1"> object to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">MenuItem</span></strong><span class="koboSpan" id="kobo.218.1"> object. </span><span class="koboSpan" id="kobo.218.2">The transformation details are omitted here, but it’s where we adapt the fetched data to the desired format. </span><span class="koboSpan" id="kobo.218.3">Subsequently, the transformed menu items are set to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">menuItems</span></strong><span class="koboSpan" id="kobo.220.1"> state.</span></p>
<p><span class="koboSpan" id="kobo.221.1">Now, in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">MenuList</span></strong><span class="koboSpan" id="kobo.223.1"> component, we</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.224.1"> can simply call </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">useMenuItems</span></strong><span class="koboSpan" id="kobo.226.1"> to obtain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">menuItems</span></strong><span class="koboSpan" id="kobo.228.1"> array:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">
const MenuList = ({
  onAddMenuItem,
}: {
  onAddMenuItem: (item: string) =&gt; void;
}) =&gt; {
  const { menuItems } = useMenuItems();
  //...
</span><span class="koboSpan" id="kobo.229.2">}</span></pre> <p><span class="koboSpan" id="kobo.230.1">This refactoring is quite beneficial, redirecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">MenuList</span></strong><span class="koboSpan" id="kobo.232.1"> back to a streamlined state and reinstating its single responsibility. </span><span class="koboSpan" id="kobo.232.2">However, when we shift our focus to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">useMenuItems</span></strong><span class="koboSpan" id="kobo.234.1"> Hook, particularly the data mapping segment, a few operations occur. </span><span class="koboSpan" id="kobo.234.2">It fetches data and trims off some unused fields such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">description</span></strong><span class="koboSpan" id="kobo.236.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">calories</span></strong><span class="koboSpan" id="kobo.238.1"> from the remote data. </span><span class="koboSpan" id="kobo.238.2">It also encapsulates the logic to retain only the first three ingredients. </span><span class="koboSpan" id="kobo.238.3">Ideally, we’d like to centralize this transformation logic into a common location, ensuring a tidy and mana</span><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.239.1">geable code structure.</span></p>
<h2 id="_idParaDest-168"><span class="koboSpan" id="kobo.240.1">Transitioning </span><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.241.1">to a class-based model</span></h2>
<p><span class="koboSpan" id="kobo.242.1">As touched upon in </span><a href="B21103_08.xhtml#_idTextAnchor212"><i class="italic"><span class="koboSpan" id="kobo.243.1">Chapter 8</span></i></a><span class="koboSpan" id="kobo.244.1">, employing </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.245.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">Anti-Corruption Layer</span></strong><span class="koboSpan" id="kobo.247.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.248.1">ACL</span></strong><span class="koboSpan" id="kobo.249.1">) pattern can be a strategic move for managing our data effectively. </span><span class="koboSpan" id="kobo.249.2">We’ll employ classes in TypeScript to</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.250.1"> encapsulate data and logic in a unified location, referred to as a model. </span><span class="koboSpan" id="kobo.250.2">A significant step in this direction would be transitioning our </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">MenuItem</span></strong><span class="koboSpan" id="kobo.252.1"> type definition into a class, hence centralizing all mapping logic within this class. </span><span class="koboSpan" id="kobo.252.2">This setup will serve as a dedicated hub for any future data shape alterations and related logic.</span></p>
<p><span class="koboSpan" id="kobo.253.1">Transitioning </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">MenuItem</span></strong><span class="koboSpan" id="kobo.255.1"> from a </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.256.1">type to a class is straightforward. </span><span class="koboSpan" id="kobo.256.2">We require a constructor to accept </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">RemoteMenuItem</span></strong><span class="koboSpan" id="kobo.258.1"> and some getter functions to access the data:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.259.1">
export class MenuItem {
  private readonly _id: string;
  private readonly _name: string;
  private readonly _type: string;
  private readonly _price: number;
  private readonly _ingredients: string[];
  constructor(item: RemoteMenuItem) {
    this._id = item.id;
    this._name = item.name;
    this._price = item.price;
    this._type = item.category;
    this._ingredients = item.ingredients;
  }
  // ... </span><span class="koboSpan" id="kobo.259.2">getter functions for id, name, price just returns the private 
          fields
  get type() {
    return this._type.toLowerCase();
  }
  get ingredients() {
    return this._ingredients.slice(0, 3);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.260.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">MenuItem</span></strong><span class="koboSpan" id="kobo.262.1"> class, we</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.263.1"> define private </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">readonly</span></strong><span class="koboSpan" id="kobo.265.1"> properties for </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">id</span></strong><span class="koboSpan" id="kobo.267.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">name</span></strong><span class="koboSpan" id="kobo.269.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">type</span></strong><span class="koboSpan" id="kobo.271.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">price</span></strong><span class="koboSpan" id="kobo.273.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">ingredients</span></strong><span class="koboSpan" id="kobo.275.1">. </span><span class="koboSpan" id="kobo.275.2">The constructor initializes these properties using values from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">RemoteMenuItem</span></strong><span class="koboSpan" id="kobo.277.1"> object passed to it. </span><span class="koboSpan" id="kobo.277.2">We then have getter methods for each property to provide read-only access to their values. </span><span class="koboSpan" id="kobo.277.3">Particularly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">ingredients</span></strong><span class="koboSpan" id="kobo.279.1"> getter returns only the first three items from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">ingredients</span></strong><span class="koboSpan" id="kobo.281.1"> array.</span></p>
<p><span class="koboSpan" id="kobo.282.1">Though, at a glance, this setup seems to have more code compared to a simple type definition, it effectively encapsulates the data and exposes it in a controlled manner. </span><span class="koboSpan" id="kobo.282.2">This aligns with the principles of immutability and encapsulation. </span><span class="koboSpan" id="kobo.282.3">The class structure’s beauty is its capability to house behaviors – in our case, the slicing logic for ingredients is tucked neatly within the class.</span></p>
<p><span class="koboSpan" id="kobo.283.1">With this new class in place, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">useMenuItems</span></strong><span class="koboSpan" id="kobo.285.1"> Hook becomes more streamlined:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
export const useMenuItems = () =&gt; {
  //...
</span><span class="koboSpan" id="kobo.286.2">  useEffect(() =&gt; {
    const fetchMenuItems = async () =&gt; {
      //...
</span><span class="koboSpan" id="kobo.286.3">      setMenuItems(
        menuItems.map((item: RemoteMenuItem) =&gt; {
          return new MenuItem(item);
        })
      );
    };
    fetchMenuItems();
  }, []);
  return { menuItems };
};</span></pre> <p><span class="koboSpan" id="kobo.287.1">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">useMenuItems</span></strong><span class="koboSpan" id="kobo.289.1"> Hook </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.290.1">merely maps over the fetched menu items, creating a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">MenuItem</span></strong><span class="koboSpan" id="kobo.292.1"> for each, which significantly tidies up the transformation logic previou</span><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.293.1">sly housed within the Hook.</span></p>
<h3><span class="koboSpan" id="kobo.294.1">The benefits of a class-based model</span></h3>
<p><span class="koboSpan" id="kobo.295.1">Transitioning to a </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.296.1">class-based model from a simple type comes with a set of advantages that could serve our application well in the long run:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.297.1">Encapsulation</span></strong><span class="koboSpan" id="kobo.298.1">: A class brings related properties and methods under one roof, thus promoting clear structure and organization. </span><span class="koboSpan" id="kobo.298.2">It also restricts direct data access, fostering better control and data integrity.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.299.1">Method behavior</span></strong><span class="koboSpan" id="kobo.300.1">: For complex behaviors or operations associated with a menu item, a class provides a structured platform to define these methods, whether they relate to data manipulation or other business logic.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.301.1">Inheritance and polymorphism</span></strong><span class="koboSpan" id="kobo.302.1">: In the case of a hierarchy or polymorphic behavior among menu items, a class structure is indispensable. </span><span class="koboSpan" id="kobo.302.2">It allows different menu item types to inherit from a common base class, overriding or extending behavior as needed.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.303.1">Consistent interface</span></strong><span class="koboSpan" id="kobo.304.1">: Classes ensure a consistent interface to the data, which is invaluable when multiple application parts interact with menu items.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.305.1">Read-only properties</span></strong><span class="koboSpan" id="kobo.306.1">: Classes enable the definition of read-only properties, thereby controlling data mutation. </span><span class="koboSpan" id="kobo.306.2">This is a crucial aspect of maintaining data integrity and working with </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.307.1">immutable data structures.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.308.1">Now, as we transition into expanding our application’s functionality with a shopping cart, it’s crucial to approach this new section with the lessons learned from our data modeling exercise. </span><span class="koboSpan" id="kobo.308.2">This will ensure a structured and effective implementation, paving the way for a user-friendl</span><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.309.1">y online ordering experience.</span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.310.1">Implementing the ShoppingCart component</span></h1>
<p><span class="koboSpan" id="kobo.311.1">As we venture into </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.312.1">the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.314.1"> component, we will aim to provide a seamless interface for users to review their selected items before proceeding to the checkout. </span><span class="koboSpan" id="kobo.314.2">Besides displaying the items, we also intend to reward our customers with some appealing discount policies.</span></p>
<p><span class="koboSpan" id="kobo.315.1">In </span><a href="B21103_07.xhtml#_idTextAnchor176"><i class="italic"><span class="koboSpan" id="kobo.316.1">Chapter 7</span></i></a><span class="koboSpan" id="kobo.317.1">, we defined a rudimentary </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.319.1"> component, as shown here:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
export const ShoppingCart = ({ cartItems }: { cartItems: string[] }) =&gt; {
  return (
    &lt;div data-testid="shopping-cart"&gt;
      &lt;ol&gt;
        {cartItems.map((item) =&gt; (
          &lt;li key={item}&gt;{item}&lt;/li&gt;
        ))}
      &lt;/ol&gt;
      &lt;button disabled={cartItems.length === 0}&gt;Place My Order
       &lt;/button&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.321.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.323.1"> component accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">cartItems</span></strong><span class="koboSpan" id="kobo.325.1"> prop, which is an array of strings. </span><span class="koboSpan" id="kobo.325.2">It returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">div</span></strong><span class="koboSpan" id="kobo.327.1"> tag containing an ordered list (</span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">&lt;ol&gt;</span></strong><span class="koboSpan" id="kobo.329.1">), where each item in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">cartItems</span></strong><span class="koboSpan" id="kobo.331.1"> array is rendered as a list item (</span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">&lt;li&gt;</span></strong><span class="koboSpan" id="kobo.333.1">). </span><span class="koboSpan" id="kobo.333.2">Below the list, a </span><strong class="bold"><span class="koboSpan" id="kobo.334.1">Place My Order</span></strong><span class="koboSpan" id="kobo.335.1"> button is rendered, which is disabled if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">cartItems</span></strong><span class="koboSpan" id="kobo.337.1"> array is empty.</span></p>
<p><span class="koboSpan" id="kobo.338.1">However, to </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.339.1">enhance the user experience, it’s crucial to display the price for each item and the total amount beneath the item list, yet above the </span><strong class="bold"><span class="koboSpan" id="kobo.340.1">Place My Order</span></strong><span class="koboSpan" id="kobo.341.1"> button. </span><span class="koboSpan" id="kobo.341.2">Here’s how we can augment our component to fulfill these requirements:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
export const ShoppingCart = ({ cartItems }: { cartItems: MenuItem[] }) =&gt; {
  const totalPrice = cartItems.reduce((acc, item) =&gt; (acc += item.price), 0);
  return (
    &lt;div data-testid="shopping-cart" className="shopping-cart"&gt;
      &lt;ol&gt;
        {cartItems.map((item) =&gt; (
          &lt;li key={item.id}&gt;
            &lt;h3&gt;{item.name}&lt;/h3&gt;
            &lt;span&gt;${item.price}&lt;/span&gt;
          &lt;/li&gt;
        ))}
      &lt;/ol&gt;
      &lt;div&gt;Total: ${totalPrice}&lt;/div&gt;
      &lt;button disabled={cartItems.length === 0}&gt;Place My Order
       &lt;/button&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.343.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.345.1"> component is now equipped to accept a </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">cartItems</span></strong><span class="koboSpan" id="kobo.347.1"> prop, which comprises an array</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.348.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">MenuItem</span></strong><span class="koboSpan" id="kobo.350.1"> objects (instead of a simple string). </span><span class="koboSpan" id="kobo.350.2">To compute the total price of items in the cart, we employ the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">reduce</span></strong><span class="koboSpan" id="kobo.352.1"> method. </span><span class="koboSpan" id="kobo.352.2">This method iterates over each item, accumulating their prices to present a total. </span><span class="koboSpan" id="kobo.352.3">The component then returns a JSX markup that renders a list of cart items, each displaying its name and price.</span></p>
<p><span class="koboSpan" id="kobo.353.1">This revamped </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.355.1"> component not only enhances the clarity of the order for users but also lays down a foundation for introducing discount policies, which we can explore as we co</span><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.356.1">ntinue refining our application.</span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.357.1">Applying discounts to Items</span></h2>
<p><span class="koboSpan" id="kobo.358.1">Let’s assume </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.359.1">we have different discount policies for different types of menu items. </span><span class="koboSpan" id="kobo.359.2">For instance, pizzas with more than three toppings receive a 10 percent discount, while large pasta dishes enjoy a 15 percent discount.</span></p>
<p><span class="koboSpan" id="kobo.360.1">To incorporate this, we initially attempt to extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">MenuItem</span></strong><span class="koboSpan" id="kobo.362.1"> class with a new field called </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">calculateDiscount</span></strong><span class="koboSpan" id="kobo.364.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">
export class MenuItem {
  //... </span><span class="koboSpan" id="kobo.365.2">the private fields
  constructor(item: RemoteMenuItem) {
    //... </span><span class="koboSpan" id="kobo.365.3">assignment
  }
  get calculateDiscount() {
    return this.type === 'pizza' &amp;&amp; this.toppings &gt;= 3 ? </span><span class="koboSpan" id="kobo.365.4">this.price * 
     0.1 : 0;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.366.1">However, we encounter a problem – since pasta dishes don’t have toppings, this leads to a type error.</span></p>
<p><span class="koboSpan" id="kobo.367.1">To resolve this, we first extract an interface named </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">IMenuItem</span></strong><span class="koboSpan" id="kobo.369.1">, and then have </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">PizzaMenuItem</span></strong><span class="koboSpan" id="kobo.371.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">PastaMenuItem</span></strong><span class="koboSpan" id="kobo.373.1"> classes implement this interface:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
export interface IMenuItem {
  id: string;
  name: string;
  type: string;
  price: number;
  ingredients: string[];
  calculateDiscount(): number;
}</span></pre> <p><span class="koboSpan" id="kobo.375.1">Next, we define</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.376.1"> an abstract class to implement the interface, allowing </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">PizzaMenuItem</span></strong><span class="koboSpan" id="kobo.378.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">PastaMenuItem</span></strong><span class="koboSpan" id="kobo.380.1"> to extend the abstract class respectively:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.381.1">
export abstract class AbstractMenuItem implements IMenuItem {
  private readonly _id: string;
  private readonly _name: string;
  private readonly _price: number;
  private readonly _ingredients: string[];
  protected constructor(item: RemoteMenuItem) {
    this._id = item.id;
    this._name = item.name;
    this._price = item.price;
    this._ingredients = item.ingredients;
  }
  static from(item: IMenuItem): RemoteMenuItem {
    return {
      id: item.id,
      name: item.name,
      price: item.price,
      category: item.type,
      ingredients: item.ingredients,
    };
  }
  //... </span><span class="koboSpan" id="kobo.381.2">the getter functions
  abstract calculateDiscount(): number;
}</span></pre> <p><span class="koboSpan" id="kobo.382.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">AbstractMenuItem</span></strong><span class="koboSpan" id="kobo.384.1"> class, we</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.385.1"> introduced a static </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">from</span></strong><span class="koboSpan" id="kobo.387.1"> method. </span><span class="koboSpan" id="kobo.387.2">This method takes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">IMenuItem</span></strong><span class="koboSpan" id="kobo.389.1"> instance and transforms it into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">RemoteMenuItem</span></strong><span class="koboSpan" id="kobo.391.1"> instance, preserving the necessary fields for our application.</span></p>
<p><span class="koboSpan" id="kobo.392.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">calculateDiscount</span></strong><span class="koboSpan" id="kobo.394.1"> method is declared as an abstract method, requiring its child classes to implement the actual discount calculation.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.395.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.396.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">abstract class</span></strong><span class="koboSpan" id="kobo.398.1"> serves</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.399.1"> as a base class for other classes and cannot be instantiated on its own. </span><span class="koboSpan" id="kobo.399.2">It’s a way to define a common interface and/or implementation for a set of derived classes. </span><span class="koboSpan" id="kobo.399.3">Abstract classes often contain abstract methods, which are declared without implementations, leaving it to derived classes to provide specific implementations. </span><span class="koboSpan" id="kobo.399.4">By doing so, abstract classes enable a common structure while ensuring that certain methods are implemented in derived classes, promoting a consistent behavior across all derived types. </span><span class="koboSpan" id="kobo.399.5">They are a key feature in object-oriented programming, supporting polymorphism and encapsulation.</span></p>
<p><span class="koboSpan" id="kobo.400.1">We need to override and</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.401.1"> put the actual </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">calculateDiscount</span></strong><span class="koboSpan" id="kobo.403.1"> logic in sub-classes. </span><span class="koboSpan" id="kobo.403.2">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">PizzaMenuItem</span></strong><span class="koboSpan" id="kobo.405.1">, it simply extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">AbstractMenuItem</span></strong><span class="koboSpan" id="kobo.407.1"> and implements </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">calculateDiscount</span></strong><span class="koboSpan" id="kobo.409.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
export class PizzaMenuItem extends AbstractMenuItem {
  private readonly toppings: number;
  constructor(item: RemoteMenuItem, toppings: number) {
    super(item);
    this.toppings = toppings;
  }
  calculateDiscount(): number {
    return this.toppings &gt;= 3 ? </span><span class="koboSpan" id="kobo.410.2">this.price * 0.1 : 0;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.411.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">PizzaMenuItem</span></strong><span class="koboSpan" id="kobo.413.1"> class extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">AbstractMenuItem</span></strong><span class="koboSpan" id="kobo.415.1">, inheriting its properties and methods. </span><span class="koboSpan" id="kobo.415.2">It defines a private </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">readonly</span></strong><span class="koboSpan" id="kobo.417.1"> property, </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">toppings</span></strong><span class="koboSpan" id="kobo.419.1">, to hold the number of toppings. </span><span class="koboSpan" id="kobo.419.2">In the constructor, it takes two arguments: </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">RemoteMenuItem</span></strong><span class="koboSpan" id="kobo.421.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">toppings</span></strong><span class="koboSpan" id="kobo.423.1"> (which indicates the number of toppings). </span><span class="koboSpan" id="kobo.423.2">It calls the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">AbstractMenuItem</span></strong><span class="koboSpan" id="kobo.425.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">item</span></strong><span class="koboSpan" id="kobo.427.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">super(item)</span></strong><span class="koboSpan" id="kobo.429.1"> and initializes </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">this.toppings</span></strong><span class="koboSpan" id="kobo.431.1"> with the passed-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">toppings</span></strong><span class="koboSpan" id="kobo.433.1"> argument.</span></p>
<p><span class="koboSpan" id="kobo.434.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">calculateDiscount</span></strong><span class="koboSpan" id="kobo.436.1"> method is implemented to return a 10% discount if the number of toppings is 3 or more. </span><span class="koboSpan" id="kobo.436.2">This method overrides the abstract </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">calculateDiscount</span></strong><span class="koboSpan" id="kobo.438.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">AbstractMenuItem</span></strong><span class="koboSpan" id="kobo.440.1">.</span></p>
<p><span class="koboSpan" id="kobo.441.1">Similarly, we can create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">PastaMenuItem</span></strong><span class="koboSpan" id="kobo.443.1"> class like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
export class PastaItem extends AbstractMenuItem {
  private readonly servingSize: string;
  constructor(item: RemoteMenuItem, servingSize: string) {
    super(item);
    this.servingSize = servingSize;
  }
  calculateDiscount(): number {
    return this.servingSize === "large" ? </span><span class="koboSpan" id="kobo.444.2">this.price * 0.15 : 0;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.445.1">The relationship of</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.446.1"> these classes can be visualized as in </span><i class="italic"><span class="koboSpan" id="kobo.447.1">Figure 11</span></i><i class="italic"><span class="koboSpan" id="kobo.448.1">.7</span></i><span class="koboSpan" id="kobo.449.1">:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.450.1"><img alt="Figure 11.7: Model classes" src="image/B31103_11_07.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.451.1">Figure 11.7: Model classes</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.452.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">AbstractMenuItem</span></strong><span class="koboSpan" id="kobo.454.1"> abstract</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.455.1"> class implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">IMenuItem</span></strong><span class="koboSpan" id="kobo.457.1"> interface and uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">RemoteMenuItem</span></strong><span class="koboSpan" id="kobo.459.1">. </span><span class="koboSpan" id="kobo.459.2">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">PizzaItem</span></strong><span class="koboSpan" id="kobo.461.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">PastaItem</span></strong><span class="koboSpan" id="kobo.463.1"> are extending </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">AbstractMenuItem</span></strong><span class="koboSpan" id="kobo.465.1"> and have their own logic for calculating the discount.</span></p>
<p><span class="koboSpan" id="kobo.466.1">Next, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">MenuList</span></strong><span class="koboSpan" id="kobo.468.1"> component, when adding items to the shopping cart, we create instances of the right class based on the item type:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.469.1">
export const MenuList = ({}) =&gt; {
  //...
</span><span class="koboSpan" id="kobo.469.2">  const [toppings, setToppings] = useState([]);
  const [size, setSize] = useState&lt;string&gt;("small");
  const handleAddMenuItem = (item: IMenuItem) =&gt; {
    const remoteItem = AbstractMenuItem.from(item);
    if (item.type === "pizza") {
      onAddMenuItem(new PizzaMenuItem(remoteItem, toppings.length));
    } else if (item.type === "pasta") {
      onAddMenuItem(new PastaItem(remoteItem, size));
    } else {
      onAddMenuItem(item);
    }
  };
  return (
    //...
</span><span class="koboSpan" id="kobo.469.3">  );
};</span></pre> <p><span class="koboSpan" id="kobo.470.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">handleAddMenuItem</span></strong><span class="koboSpan" id="kobo.472.1"> function</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.473.1"> transforms the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">IMenuItem</span></strong><span class="koboSpan" id="kobo.475.1"> object item into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">RemoteMenuItem</span></strong><span class="koboSpan" id="kobo.477.1"> object using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">AbstractMenuItem.from(item)</span></strong><span class="koboSpan" id="kobo.479.1"> method. </span><span class="koboSpan" id="kobo.479.2">Following this, it checks the type property of the item to determine whether it’s a pizza or pasta. </span><span class="koboSpan" id="kobo.479.3">If it’s a pizza, a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">PizzaMenuItem</span></strong><span class="koboSpan" id="kobo.481.1"> instance is created using </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">remoteItem</span></strong><span class="koboSpan" id="kobo.483.1"> and the selected number of toppings, and this new item is added to the cart via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">onAddMenuItem</span></strong><span class="koboSpan" id="kobo.485.1"> function. </span><span class="koboSpan" id="kobo.485.2">If the item is neither a pizza nor pasta, the original item is added to the cart directly through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">onAddMenuItem</span></strong><span class="koboSpan" id="kobo.487.1"> function.</span></p>
<p><span class="koboSpan" id="kobo.488.1">Lastly, within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.490.1"> component, we calculate the total discount value similarly to how we calculated the total price, and use it for rendering:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
export const ShoppingCart = ({ cartItems }: { cartItems: IMenuItem[] }) =&gt; {
  const totalPrice = cartItems.reduce((acc, item) =&gt; (acc += item.price), 0);
  const totalDiscount = cartItems.reduce(
    (acc, item) =&gt; (acc += item.calculateDiscount()),
    0
  );
  return (
    &lt;div data-testid="shopping-cart"&gt;
      {/* rendering the list */}
      &lt;div&gt;Total Discount: ${totalDiscount}&lt;/div&gt;
      &lt;div&gt;Total: ${totalPrice - totalDiscount}&lt;/div&gt;
      &lt;button disabled={cartItems.length === 0}&gt;Place My Order
       &lt;/button&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.492.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.494.1"> component </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.495.1">calculates </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">totalPrice</span></strong><span class="koboSpan" id="kobo.497.1"> by iterating over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">cartItems</span></strong><span class="koboSpan" id="kobo.499.1"> array and summing up the price of each item. </span><span class="koboSpan" id="kobo.499.2">Similarly, it calculates </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">totalDiscount</span></strong><span class="koboSpan" id="kobo.501.1"> by summing up the discounts for each item, obtained by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">calculateDiscount()</span></strong><span class="koboSpan" id="kobo.503.1"> method on each item. </span><span class="koboSpan" id="kobo.503.2">In the returned JSX, it renders a list and displays </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">totalDiscount</span></strong><span class="koboSpan" id="kobo.505.1"> and the final total price (which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">totalPr</span><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.507.1">ice</span></strong><span class="koboSpan" id="kobo.508.1"> minus </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">totalDiscount</span></strong><span class="koboSpan" id="kobo.510.1">) below the list.</span></p>
<p><span class="koboSpan" id="kobo.511.1">At this juncture, the function operates effectively. </span><span class="koboSpan" id="kobo.511.2">Nonetheless, there are several factors to contemplate – the discount is currently specified on each product: for instance, pizza has its own discount rule while pasta has its own. </span><span class="koboSpan" id="kobo.511.3">What would be our approach if we need to implement a store-wide discount, </span><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.512.1">such as a discount for a public holiday?</span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.513.1">Exploring the Strategy pattern</span></h2>
<p><span class="koboSpan" id="kobo.514.1">Suppose it’s a</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.515.1"> bustling Friday night, and we wish to offer a special discount on all pizzas and drinks. </span><span class="koboSpan" id="kobo.515.2">However, we don’t intend to apply additional discounts on items already discounted — for instance, a pizza with four toppings should only receive this specific special discount.</span></p>
<p><span class="koboSpan" id="kobo.516.1">Handling such arbitrary discounts can be complex, necessitating a decoupling of the calculation logic from the item type. </span><span class="koboSpan" id="kobo.516.2">Moreover, we’d like the flexibility to remove these discounts after Friday or after a certain period.</span></p>
<p><span class="koboSpan" id="kobo.517.1">We can use a design pattern called the </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">Strategy pattern</span></strong><span class="koboSpan" id="kobo.519.1"> to achieve flexibility here. </span><span class="koboSpan" id="kobo.519.2">The Strategy pattern is a behavioral design pattern that enables selecting an algorithm’s implementation at runtime. </span><span class="koboSpan" id="kobo.519.3">It encapsulates a family of algorithms and makes them interchangeable, allowing the client to choose the most suitable one without modifying the code.</span></p>
<p><span class="koboSpan" id="kobo.520.1">We’ll extract the logic into a separate entity, defining a strategy interface as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.521.1">
export interface IDiscountStrategy {
  calculate(price: number): number;
}</span></pre> <p><span class="koboSpan" id="kobo.522.1">This interface provides a blueprint for different discount strategies. </span><span class="koboSpan" id="kobo.522.2">For example, we could have a strategy with no discount:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
class NoDiscountStrategy implements IDiscountStrategy {
  calculate(price: number): number {
    return 0;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.524.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">NoDiscountStrategy</span></strong><span class="koboSpan" id="kobo.526.1"> class implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">IDiscountStrategy</span></strong><span class="koboSpan" id="kobo.528.1"> interface with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">calculate</span></strong><span class="koboSpan" id="kobo.530.1"> method that takes a price as input and returns zero, meaning no discount is applied.</span></p>
<p><span class="koboSpan" id="kobo.531.1">And for </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">SpecialDiscountStrategy</span></strong><span class="koboSpan" id="kobo.533.1"> component, a special discount strategy offering a 15% discount will be applied:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
class SpecialDiscountStrategy implements IDiscountStrategy {
  calculate(price: number): number {
    return price * 0.15;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.535.1">To utilize these strategies, we need to slightly modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">IMenuItem</span></strong><span class="koboSpan" id="kobo.537.1"> interface:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.538.1">
export interface IMenuItem {
  // ... </span><span class="koboSpan" id="kobo.538.2">other fields
  discountStrategy: IDiscountStrategy;
}</span></pre> <p><span class="koboSpan" id="kobo.539.1">We added </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">discountStrategy</span></strong><span class="koboSpan" id="kobo.541.1"> with type </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">IDiscountStrategy</span></strong><span class="koboSpan" id="kobo.543.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">IMenuItem</span></strong><span class="koboSpan" id="kobo.545.1"> interface. </span><span class="koboSpan" id="kobo.545.2">And because we moved the logic of calculating discount into strategy, we don’t</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.546.1"> need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">calculateDiscount</span></strong><span class="koboSpan" id="kobo.548.1"> abstract method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">AbstractMenuItem</span></strong><span class="koboSpan" id="kobo.550.1"> anymore and the class will no longer remain abstract, so we renamed it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">BaseMenuItem</span></strong><span class="koboSpan" id="kobo.552.1"> instead. </span><span class="koboSpan" id="kobo.552.2">Instead, it will incorporate a setter for the discount strategy and implement the discount calculation:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">
export class BaseMenuItem implements IMenuItem {
  // ... </span><span class="koboSpan" id="kobo.553.2">other fields
  private _discountStrategy: IDiscountStrategy;
  constructor(item: RemoteMenuItem) {
    // ... </span><span class="koboSpan" id="kobo.553.3">other fields
    this._discountStrategy = new NoDiscountStrategy();
  }
  // ... </span><span class="koboSpan" id="kobo.553.4">other getters
  set discountStrategy(strategy: IDiscountStrategy) {
    this._discountStrategy = strategy;
  }
  calculateDiscount() {
    return this._discountStrategy.calculate(this.price);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.554.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">BaseMenuItem</span></strong><span class="koboSpan" id="kobo.556.1"> class </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.557.1">now implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">IMenuItem</span></strong><span class="koboSpan" id="kobo.559.1"> interface and encapsulates a discount strategy, initially set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">NoDiscountStrategy</span></strong><span class="koboSpan" id="kobo.561.1">. </span><span class="koboSpan" id="kobo.561.2">It defines a setter to update the discount strategy, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">calculateDiscount</span></strong><span class="koboSpan" id="kobo.563.1"> method, which delegates the discount calculation to the encapsulated discount strategy’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">calculate</span></strong><span class="koboSpan" id="kobo.565.1"> method, passing the item’s price as an argument.</span></p>
<p><i class="italic"><span class="koboSpan" id="kobo.566.1">Figure 11</span></i><i class="italic"><span class="koboSpan" id="kobo.567.1">.8</span></i><span class="koboSpan" id="kobo.568.1"> should now give you a much clearer idea of what the relationships are:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.569.1"><img alt="Figure 11.8: The class diagram of all the classes" src="image/B31103_11_08.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.570.1">Figure 11.8: The class diagram of all the classes</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.571.1">As observed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">BaseMenuItem</span></strong><span class="koboSpan" id="kobo.573.1"> implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">IMenuItem</span></strong><span class="koboSpan" id="kobo.575.1"> interface and utilizes </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">IDiscountStrategy</span></strong><span class="koboSpan" id="kobo.577.1">. </span><span class="koboSpan" id="kobo.577.2">There are </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.578.1">multiple implementations of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">IDiscountStrategy</span></strong><span class="koboSpan" id="kobo.580.1"> interface for specific discount algorithms, and several classes extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">BaseMenuItem</span></strong><span class="koboSpan" id="kobo.582.1"> class.</span></p>
<p><span class="koboSpan" id="kobo.583.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">RemoteMenuItem</span></strong><span class="koboSpan" id="kobo.585.1"> type is used by all the classes implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">IMenuItem</span></strong><span class="koboSpan" id="kobo.587.1"> interface.</span></p>
<p><span class="koboSpan" id="kobo.588.1">Now, when we need to apply a particular strategy, it can be done effortlessly, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
export const MenuList = ({
  onAddMenuItem,
}: {
  onAddMenuItem: (item: IMenuItem) =&gt; void;
}) =&gt; {
  // ...
</span><span class="koboSpan" id="kobo.589.2">  const handleAddMenuItem = (item: IMenuItem) =&gt; {
    if (isTodayFriday()) {
      item.discountStrategy = new SpecialDiscountStrategy();
    }
    onAddMenuItem(item);
  };</span></pre> <p><span class="koboSpan" id="kobo.590.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">MenuList</span></strong><span class="koboSpan" id="kobo.592.1"> component, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">handleAddMenuItem</span></strong><span class="koboSpan" id="kobo.594.1"> function checks if today is Friday using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">isTodayFriday</span></strong><span class="koboSpan" id="kobo.596.1"> function. </span><span class="koboSpan" id="kobo.596.2">If it is, it sets </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">discountStrategy</span></strong><span class="koboSpan" id="kobo.598.1"> of the item to a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">SpecialDiscountStrategy</span></strong><span class="koboSpan" id="kobo.600.1"> before passing the item to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">onAddMenuItem</span></strong><span class="koboSpan" id="kobo.602.1"> function, which is received as a prop. </span><span class="koboSpan" id="kobo.602.2">This way, a special discount is applied to the menu item on Fridays.</span></p>
<p><span class="koboSpan" id="kobo.603.1">This setup grants us the desired flexibility. </span><span class="koboSpan" id="kobo.603.2">For instance, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">handleAddMenuItem</span></strong><span class="koboSpan" id="kobo.605.1"> function, depending on whether it’s Friday or the item is a pizza, we can easily switch the discount strategy:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.606.1">
const handleAddMenuItem = (item: IMenuItem) =&gt; {
  if (isTodayFriday()) {
    item.discountStrategy = new SpecialDiscountStrategy();
  }
  if(item.type === 'pizza') {
    item.discountStrategy = new PizzaDiscountStrategy();
  }
  onAddMenuItem(item);
};</span></pre> <p><span class="koboSpan" id="kobo.607.1">In this </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">handleAddMenuItem</span></strong><span class="koboSpan" id="kobo.609.1"> function, depending on certain conditions, a different discount strategy is</span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.610.1"> applied to the item before it’s passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">onAddMenuItem</span></strong><span class="koboSpan" id="kobo.612.1"> function. </span><span class="koboSpan" id="kobo.612.2">Initially, it checks if today is Friday using </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">isTodayFriday()</span></strong><span class="koboSpan" id="kobo.614.1"> and, if true, it assigns a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">SpecialDiscountStrategy</span></strong><span class="koboSpan" id="kobo.616.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">item.discountStrategy</span></strong><span class="koboSpan" id="kobo.618.1">. </span><span class="koboSpan" id="kobo.618.2">However, if the item is of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">pizza</span></strong><span class="koboSpan" id="kobo.620.1">, irrespective of the day, it overwrites </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">item.discountStrategy</span></strong><span class="koboSpan" id="kobo.622.1"> with a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">PizzaDiscountStrategy</span></strong><span class="koboSpan" id="kobo.624.1">.</span></p>
<p><span class="koboSpan" id="kobo.625.1">This approach keeps our discount logic modular and easy to adjust, catering to different scenarios with minimal code modification. </span><span class="koboSpan" id="kobo.625.2">As we’re extracting new logic components – Hooks, data models, domain logic (discount strategies), and views – out of the application code, it’s e</span><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.626.1">volving into a layered frontend application.</span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.627.1">Delving into layered architecture</span></h1>
<p><span class="koboSpan" id="kobo.628.1">Our application has transitioned </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.629.1">wonderfully to a more robust state, with clear, understandable, and modifiable logic, which is now also more test-friendly.</span></p>
<p><span class="koboSpan" id="kobo.630.1">A further refinement I envision is relocating the logic present in </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.632.1"> to a custom Hook. </span><span class="koboSpan" id="kobo.632.2">We can do this like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.633.1">
export const useShoppingCart = (items: IMenuItem[]) =&gt; {
  const totalPrice = useMemo(
    () =&gt; items.reduce((acc, item) =&gt; (acc += item.price), 0),
    [items]
  );
  const totalDiscount = useMemo(
    () =&gt; items.reduce((acc, item) =&gt; (acc += item.
</span><span class="koboSpan" id="kobo.633.2">     calculateDiscount()), 0),
    [items]
  );
  return {
    totalPrice,
    totalDiscount,
  };
};</span></pre> <p><span class="koboSpan" id="kobo.634.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">useShoppingCart</span></strong><span class="koboSpan" id="kobo.636.1"> Hook accepts an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">IMenuItem</span></strong><span class="koboSpan" id="kobo.638.1"> objects and computes two values – </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">totalPrice</span></strong><span class="koboSpan" id="kobo.640.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">totalDiscount</span></strong><span class="koboSpan" id="kobo.642.1">:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">totalPrice</span></strong><span class="koboSpan" id="kobo.644.1"> is calculated by reducing the items, summing up their </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">price</span></strong><span class="koboSpan" id="kobo.646.1"> property</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">totalDiscount</span></strong><span class="koboSpan" id="kobo.648.1"> is calculated by reducing the items, summing up the discount for each item obtained by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">item.calculateDiscount()</span></strong></li>
</ul>
<p><span class="koboSpan" id="kobo.650.1">Both calculations are wrapped in </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">useMemo</span></strong><span class="koboSpan" id="kobo.652.1"> to ensure they are only recomputed when the items array changes.</span></p>
<p><span class="koboSpan" id="kobo.653.1">With this </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.654.1">modification, </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.656.1"> becomes elegantly simplified and can easily utilize these values:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.657.1">
export const ShoppingCart = ({ cartItems }: { cartItems: IMenuItem[] }) =&gt; {
  const { totalPrice, totalDiscount } = useShoppingCart(cartItems);
  return (
    {/* JSX for the rendering logic */}
  );
};</span></pre> <p><span class="koboSpan" id="kobo.658.1">An alternative </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.659.1">approach would be employing the context and </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">useReducer</span></strong><span class="koboSpan" id="kobo.661.1"> Hook to manage all logic within context and Hooks, however, since we explored that in </span><a href="B21103_08.xhtml#_idTextAnchor212"><i class="italic"><span class="koboSpan" id="kobo.662.1">Chapter 8</span></i></a><span class="koboSpan" id="kobo.663.1">, I’ll leave further exploration to you (you can use both code examples provided in </span><a href="B21103_08.xhtml#_idTextAnchor212"><i class="italic"><span class="koboSpan" id="kobo.664.1">Chapter 8</span></i></a><span class="koboSpan" id="kobo.665.1"> and this chapter and try to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">context</span></strong><span class="koboSpan" id="kobo.667.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">useReducer</span></strong><span class="koboSpan" id="kobo.669.1"> to simplify </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.671.1">).</span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.672.1">The layered structure of the application</span></h2>
<p><span class="koboSpan" id="kobo.673.1">We’ve delved into organizing </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.674.1">components and models into separate files; it’s equally vital to continue refining our project structure. </span><span class="koboSpan" id="kobo.674.2">Functions with distinct responsibilities should reside in different folders, streamlining navigation through the application and saving time. </span><span class="koboSpan" id="kobo.674.3">Our application now exhibits a fresh structural anatomy:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.675.1">
src
├── App.tsx
├── hooks
│   ├── useMenuItems.ts
│   └── useShoppingCart.ts
├── models
│   ├── BaseMenuItem.ts
│   ├── IMenuItem.ts
│   ├── PastaItem.ts
│   ├── PizzaMenuItem.ts
│   ├── RemoteMenuItem.ts
│   └── strategy
│       ├── IDiscountStrategy.ts
│       ├── NoDiscountStrategy.ts
│       ├── SpecialDiscountStrategy.ts
│       └── TenPercentageDiscountStrategy.ts
└── views
    ├── MenuList.tsx
    └── ShoppingCart.tsx</span></pre> <p><span class="koboSpan" id="kobo.676.1">And that’s how the layers formed. </span><span class="koboSpan" id="kobo.676.2">Within the view layer, we have primarily pure TSX rendering straightforward tags. </span><span class="koboSpan" id="kobo.676.3">These views leverage Hooks for state and side effect management. </span><span class="koboSpan" id="kobo.676.4">Meanwhile, in the model layer, model objects encompass business logic, algorithms for </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.677.1">toggling between different discount strategies, and data shape transformations, among other functionalities. </span><span class="koboSpan" id="kobo.677.2">This structure promotes separation of concerns, making the code organized, reusable, and easier to maintain.</span></p>
<p><span class="koboSpan" id="kobo.678.1">It’s important to note the one-directional link here; the upper layer accesses the lower layer, but not vice versa. </span><span class="koboSpan" id="kobo.678.2">TSX uses Hooks for state management, and Hooks employ models for calculations. </span><span class="koboSpan" id="kobo.678.3">However, we can’t use JSX or Hooks in the model layer. </span><span class="koboSpan" id="kobo.678.4">This layering technique facilitates change or replacement in the underlying layers without impacting the upper layers, promoting a clean and maintainable structure.</span></p>
<p><span class="koboSpan" id="kobo.679.1">In our Code Oven application, as illustrated in </span><i class="italic"><span class="koboSpan" id="kobo.680.1">Figure 11</span></i><i class="italic"><span class="koboSpan" id="kobo.681.1">.9</span></i><span class="koboSpan" id="kobo.682.1">, the layout features a menu items list on the left and a shopping cart on the right. </span><span class="koboSpan" id="kobo.682.2">Within the shopping cart, each item displays detailed discount and price information on the page.</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.683.1"><img alt="Fig﻿ure 11.9: Final look and feel of the application" src="image/B31103_11_09.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.684.1">Fig</span><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.685.1">ure 11.9: Final look and feel of the application</span></figcaption> </figure>
<h2 id="_idParaDest-174"><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.686.1">Advantages of layered architecture</span></h2>
<p><span class="koboSpan" id="kobo.687.1">The layered architecture confers </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.688.1">numerous benefits:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.689.1">Enhanced maintainability</span></strong><span class="koboSpan" id="kobo.690.1">: The division of a component into distinct segments facilitates easier identification and rectification of defects in specific code sections, thus minimizing time spent and reducing the likelihood of engendering new bugs during modifications.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.691.1">Increased modularity</span></strong><span class="koboSpan" id="kobo.692.1">: This architecture is inherently more modular, promoting code reuse and simplifying the addition of new features. </span><span class="koboSpan" id="kobo.692.2">Even within each layer, such as views, the code tends to be more composable.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.693.1">Enhanced readability</span></strong><span class="koboSpan" id="kobo.694.1">: The logic within the code becomes significantly more understandable and navigable, an asset not only for the original developer but also for others who may interact with the code base. </span><span class="koboSpan" id="kobo.694.2">This clarity is central to effecting changes in the code.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.695.1">Improved scalability</span></strong><span class="koboSpan" id="kobo.696.1">: The reduced complexity within each module renders the application more scalable, making it easier to introduce new features or alterations without impacting the entire system—a critical advantage for large, complex applications projected to evolve over time.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.697.1">Tech-stack migration</span></strong><span class="koboSpan" id="kobo.698.1">: Albeit unlikely in most projects, should the need arise, the view layer can be replaced without altering the underlying models and logic, thanks to the encapsulation of</span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.699.1"> domain logic in pure JavaScript (or Ty</span><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.700.1">peScript) code, oblivious to the views’ existence.</span></li>
</ul>
<h1 id="_idParaDest-175"><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.701.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.702.1">In this chapter, we implemented layered architecture in our application, enhancing its maintainability, modularity, readability, scalability, and potential for tech-stack migration. </span><span class="koboSpan" id="kobo.702.2">By segregating logic, refining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.704.1"> component through a custom Hook, and organizing the application into distinct layers, we’ve significantly bolstered the code’s structure and ease of management. </span><span class="koboSpan" id="kobo.704.2">This architectural approach not only streamlines the current code base but also lays a solid foundation for future expansions and refinements.</span></p>
<p><span class="koboSpan" id="kobo.705.1">In the next chapter, we’ll look at the end-to-end journey of implementing an application from scratch, using the user acceptance test-driven development approach, doing refactoring, cleaning up along the way, and always keeping our code as clean as we can.</span></p>
</section>
</body></html>