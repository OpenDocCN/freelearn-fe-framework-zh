- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Building a Backend with a GraphQL API
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GraphQL API构建后端
- en: Up until now, we have only been interfacing with REST APIs. For more complex
    APIs that have deeply nested objects, we can use GraphQL to allow selective access
    to certain parts of large objects. In this chapter, we are first going to learn
    what GraphQL is and when it is useful. Then, we are going to experiment with making
    GraphQL queries and mutations. After that, we are going to implement GraphQL in
    a backend. Finally, we are going to briefly cover advanced GraphQL concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只与REST API进行交互。对于具有深层嵌套对象的更复杂API，我们可以使用GraphQL来允许对大型对象的部分进行选择性访问。在本章中，我们首先将学习什么是GraphQL以及它在何时有用。然后，我们将尝试制作GraphQL查询和突变。之后，我们将实现后端的GraphQL。最后，我们将简要介绍高级GraphQL概念。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What is GraphQL?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是GraphQL？
- en: Implementing a GraphQL API in a backend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后端实现GraphQL API
- en: Implementing GraphQL authentication and mutations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现GraphQL身份验证和突变
- en: Overview of advanced GraphQL concepts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级GraphQL概念概述
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016)*,
    Preparing for Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028)*,
    Getting to Know Node.js* *and MongoDB*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请从[*第1章*](B19385_01.xhtml#_idTextAnchor016)*，准备全栈开发*和[*第2章*](B19385_02.xhtml#_idTextAnchor028)*，了解Node.js*和*MongoDB*中安装所有要求。
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If you are having an issue with the code and steps
    provided in this book, please try using the versions mentioned in *Chapters 1*
    and *2.*
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是书中使用的版本。虽然安装较新版本不应有问题，但请注意，某些步骤在较新版本上可能有所不同。如果您在这本书提供的代码和步骤中遇到问题，请尝试使用*第1章*和*第2章*中提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch11](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch11).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch11](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch11)。
- en: If you cloned the full repository for the book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git init` in the
    root of the corresponding chapter folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您克隆了本书的完整仓库，Husky在运行`npm install`时可能找不到`.git`目录。在这种情况下，只需在相应章节文件夹的根目录中运行`git
    init`。
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/6gP0uM-XaVo](https://youtu.be/6gP0uM-XaVo).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在：[https://youtu.be/6gP0uM-XaVo](https://youtu.be/6gP0uM-XaVo)找到。
- en: What is GraphQL?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是GraphQL？
- en: Before we start learning how to use GraphQL, let’s first focus on what GraphQL
    is. Like REST, it is a way to query APIs. However, it is also much more than that.
    GraphQL includes a server-side runtime for executing queries and a type system
    to define your data. It works with many database engines and can be integrated
    into your existing backend.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习如何使用GraphQL之前，让我们首先关注什么是GraphQL。像REST一样，它是一种查询API的方式。然而，它远不止于此。GraphQL包括一个服务器端运行时来执行查询，以及一个类型系统来定义你的数据。它与许多数据库引擎兼容，并且可以集成到现有的后端中。
- en: 'GraphQL services are created by defining types (such as a `User` type), fields
    on types (such as a `username` field), and functions to resolve values of fields.
    Let’s assume we have defined the following `User` type with a function to get
    a username:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL服务是通过定义类型（如`User`类型）、类型上的字段（如`username`字段）以及解析字段值的函数来创建的。假设我们已定义以下带有获取用户名的函数的`User`类型：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We could then define a `Query` type and a function to get the current user:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个`Query`类型和一个获取当前用户的函数：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Info
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The **Query** type is a special type that defines the “entry point” into the
    GraphQL schema. It allows us to define which fields are allowed to be queried
    using the GraphQL API.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询**类型是一个特殊类型，它定义了GraphQL模式的“入口点”。它允许我们定义哪些字段可以使用GraphQL API进行查询。'
- en: 'Now that we have defined types with fields and functions to resolve those fields,
    we can make a GraphQL query to get the username of the current user. GraphQL queries
    look like JavaScript objects, but they only list the field names that you want
    to query. The GraphQL API will then return a JavaScript object that has the same
    structure as the query, but with the values filled in. Let’s find out how a query
    to get the username of the current user would look like:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了带有字段和解析这些字段的功能的类型，我们可以进行一个GraphQL查询来获取当前用户的用户名。GraphQL查询看起来像JavaScript对象，但它们只列出你想要查询的字段名。然后，GraphQL
    API将返回一个具有与查询相同结构的JavaScript对象，但填充了值。让我们看看获取当前用户用户名的查询将是什么样子：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That query would then return a JSON result that looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那个查询将返回一个类似以下的JSON结果：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, the result has the same shape as the query. This is one of
    the essential concepts of GraphQL: the client can specifically ask for the fields
    that it needs, and the server will return exactly those fields. If we need more
    data about a user, we can just add new fields to the type and query.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，结果与查询具有相同的形状。这是GraphQL的一个基本概念：客户端可以具体请求它需要的字段，服务器将返回确切的这些字段。如果我们需要更多关于用户的数据，我们只需向类型中添加新的字段并查询即可。
- en: GraphQL validates queries and results against the defined types. This ensures
    that we do not break the contract between the client and server. The GraphQL types
    serve as that contract between the client and server. After validating the query,
    it is executed by a GraphQL server, which then returns a result that looks exactly
    like the shape requested by the query. Each requested field executes a function
    on the server. These functions are called **resolvers**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL会验证查询和结果是否符合定义的类型。这确保了我们不会破坏客户端和服务器之间的契约。GraphQL类型充当客户端和服务器之间的契约。在验证查询后，它由GraphQL服务器执行，然后返回一个与查询请求的形状完全相同的结果。每个请求的字段在服务器上执行一个函数。这些函数被称为**解析器**。
- en: '![Figure 11.1 – Interaction between GraphQL client and server](img/B19385_11_1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – GraphQL客户端与服务器之间的交互](img/B19385_11_1.jpg)'
- en: Figure 11.1 – Interaction between GraphQL client and server
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – GraphQL客户端与服务器之间的交互
- en: 'Types and queries can also be deeply nested. For example, a user could have
    a field that returns all the posts that this user is an author of. We can then
    make a sub-selection of fields in those post objects as well. This works for objects
    within objects and even arrays of objects within objects, in multiple nesting
    levels. GraphQL will keep resolving fields until only simple values (scalars),
    such as strings and numbers are left. For example, the following query could fetch
    the IDs and titles of all posts that the current user created:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类型和方法也可以深层嵌套。例如，一个用户可能有一个字段，返回该用户是作者的帖子。然后我们可以对那些帖子对象中的字段进行子选择。这对于对象中的对象以及对象中的对象数组的嵌套级别也是适用的。GraphQL将继续解析字段，直到只剩下简单的值（标量），如字符串和数字。例如，以下查询可以获取当前用户创建的所有帖子的ID和标题：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Additionally, GraphQL allows us to define arguments for fields, which will
    be passed to the functions that resolve our fields. We can use arguments to, for
    example, get all posts with a certain tag. In GraphQL we can pass arguments to
    any field, even when they are deeply nested. Arguments can even be passed to single
    value fields, for instance, to transform a value. For example, the following query
    would get a post by ID and return the post title:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，GraphQL允许我们为字段定义参数，这些参数将被传递到解析我们字段的函数中。我们可以使用参数，例如，获取所有带有特定标签的帖子。在GraphQL中，我们可以向任何字段传递参数，即使它们是深层嵌套的。参数甚至可以传递给单个值字段，例如，用于转换值。例如，以下查询将根据ID获取帖子并返回帖子标题：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: GraphQL is especially useful if you build the backend yourself or with it in
    mind, as it can allow for patterns where deeply nested and interconnected data
    can be queried easily. However, if there are existing REST backends that you are
    not in control of, it is usually not worth it to add GraphQL as a separate, independent
    layer, due to its schema-based restrictions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己构建后端或者有这个想法，GraphQL特别有用，因为它可以允许查询深层嵌套和相互关联的数据。然而，如果你无法控制现有的REST后端，通常不值得添加GraphQL作为单独的、独立的层，因为它的基于模式的限制。
- en: Having learned about queries, let’s move on to mutations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了查询之后，让我们继续学习突变。
- en: Mutations
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突变
- en: 'In REST, any request could cause a side effect (such as writing data to the
    database). But, as we have learned, GET requests should only return data, and
    should not cause such side effects. Only POST/PUT/PATCH/DELETE requests should
    cause data in the database to change. In GraphQL, there is a similar concept:
    theoretically, any field function could cause the database state to change. However,
    in GraphQL, we define a mutation instead of a query to explicitly state that we
    want to change the database state. Besides being defined with the `mutation` keyword,
    mutations have the same structure as queries. There is one difference, though:
    queries fetch fields in parallel, while mutations run in series, executing the
    first field function first, then the next, and so on. This behavior ensures that
    we do not end up with race conditions in mutations.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST 中，任何请求都可能导致副作用（例如将数据写入数据库）。但是，正如我们所学的，GET 请求应该只返回数据，而不应引起此类副作用。只有 POST/PUT/PATCH/DELETE
    请求应该导致数据库中的数据发生变化。在 GraphQL 中，有一个类似的概念：理论上，任何字段函数都可能改变数据库状态。然而，在 GraphQL 中，我们定义一个突变而不是查询来明确表示我们想要改变数据库状态。除了用
    `mutation` 关键字定义外，突变与查询具有相同的结构。尽管如此，有一个区别：查询并行获取字段，而突变按顺序运行，首先执行第一个字段函数，然后是下一个，依此类推。这种行为确保我们在突变中不会出现竞争条件。
- en: Info
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In addition to the built-in **Query** type, there is also a **Mutation** type
    to define the allowed mutation fields.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的 **Query** 类型外，还有一个 **Mutation** 类型来定义允许的突变字段。
- en: Now that we have learned the basics of what GraphQL is and how it works, let’s
    get started using it in practice by implementing GraphQL in our blog application
    backend!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 GraphQL 是什么以及它是如何工作的基础知识，让我们开始在实际的博客应用程序后端中实现 GraphQL！
- en: Implementing a GraphQL API in a backend
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后端实现 GraphQL API
- en: 'We are now going to set up GraphQL in our existing blog application backend
    in addition to the REST API. Doing so will allow us to see how GraphQL compares
    to and differs from a REST API. Follow these steps to get started setting up GraphQL
    on the backend:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将设置 GraphQL 在我们现有的博客应用程序后端，除了 REST API 之外。这样做将允许我们看到 GraphQL 与 REST API
    的比较和差异。按照以下步骤开始设置后端上的 GraphQL：
- en: 'Copy the existing **ch10** folder to a new **ch11** folder, as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 **ch10** 文件夹复制到一个新的 **ch11** 文件夹中，如下所示：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Open the **ch11** folder in VS Code.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开 **ch11** 文件夹。
- en: First, let’s install a VS Code extension to add GraphQL language support. Go
    to the **Extensions** tab and search for the **GraphQL.vscode-graphql** extension
    developed by the GraphQL Foundation. Install the extension.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们安装一个 VS Code 扩展来添加 GraphQL 语言支持。转到 **Extensions** 选项卡，搜索由 GraphQL 基金会开发的
    **GraphQL.vscode-graphql** 扩展。安装扩展。
- en: 'Next, install the **graphql** and **@apollo/server** libraries in the backend
    using the following commands:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令在后端安装 **graphql** 和 **@apollo/server** 库：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Apollo Server is a production-ready GraphQL server implementation that supports
    multiple backend web frameworks, including Express.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Apollo Server 是一个生产就绪的 GraphQL 服务器实现，支持多个后端 Web 框架，包括 Express。
- en: 'Create a new **backend/src/graphql/** folder. Inside it, create a **backend/src/graphql/query.js**
    file, inside which we define a **Query** schema, which is the entry point of our
    GraphQL API (listing all supported queries for our backend), as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **backend/src/graphql/** 文件夹。在其内部，创建一个 **backend/src/graphql/query.js**
    文件，在其中我们定义一个 **Query** 模式，这是我们的 GraphQL API 的入口点（列出后端支持的所有查询），如下所示：
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is important to add a `#graphql` directive at the beginning of the template
    string, so that the string is recognized as GraphQL syntax and properly highlighted
    in a code editor. Inside our schema, we defined a `test` field, for which we define
    a resolver now.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在模板字符串的开头添加一个 `#graphql` 指令是很重要的，这样字符串就会被识别为 GraphQL 语法，并在代码编辑器中正确高亮显示。在我们的模式中，我们定义了一个
    `test` 字段，现在我们为它定义一个解析器。
- en: 'Define a **queryResolver** object which contains a function to resolve the
    **test** field to a static string:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含将 **test** 字段解析为静态字符串的函数的 **queryResolver** 对象：
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new **backend/src/graphql/index.js** file and import the **querySchema**
    and **queryResolver** there:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **backend/src/graphql/index.js** 文件，并在其中导入 **querySchema** 和 **queryResolver**：
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, export an array called **typeDefs**, which includes all schemas (for
    now, only the query schema) and an array called **resolvers**, which contains
    all resolvers (for now, only the query resolver):'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导出一个名为 **typeDefs** 的数组，它包含所有模式（目前只包含查询模式），以及一个名为 **resolvers** 的数组，它包含所有解析器（目前只包含查询解析器）：
- en: '[PRE11]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Edit **backend/src/app.js** and import **ApolloServer** and **expressMiddleware**
    from the **@****apollo/server** library:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/app.js** 并从 **@apollo/server** 库导入 **ApolloServer** 和 **expressMiddleware**：
- en: '[PRE12]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, import **typeDefs** and **resolvers**:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导入 **typeDefs** 和 **resolvers**：
- en: '[PRE13]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After all other middleware and before the route definitions, create a new Apollo
    server using the schema type definitions and defined resolvers:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有其他中间件和路由定义之前，使用模式类型定义和定义的解析器创建一个新的 Apollo 服务器：
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, after the server is ready, mount **expressMiddleware** to a **/graphql**
    route, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在服务器准备就绪后，将 **expressMiddleware** 挂载到 **/graphql** 路由上，如下所示：
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Start the backend in development mode by running the following command:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令以开发模式启动后端：
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Go to **http://localhost:3001/graphql** in your browser; you should see the
    Apollo interface to input a query on the left side, and the results on the right
    side.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中转到 **http://localhost:3001/graphql**；您应该看到左侧的 Apollo 接口，可以输入查询，以及右侧的结果。
- en: 'Remove all comments from the editor on the left and input the following GraphQL
    query:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧编辑器的所有注释中删除并输入以下 GraphQL 查询：
- en: '[PRE17]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Press the **Play** button to run the query, and you will see the following
    result:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 **Play** 按钮，运行查询，您将看到以下结果：
- en: '![Figure 11.2 – Successful execution of our first GraphQL query!](img/B19385_11_2.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 我们第一次 GraphQL 查询的成功执行！](img/B19385_11_2.jpg)'
- en: Figure 11.2 – Successful execution of our first GraphQL query!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 我们第一次 GraphQL 查询的成功执行！
- en: As you can see, our query for the `test` field returns our previously defined
    static string!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们对 `test` 字段的查询返回了我们之前定义的静态字符串！
- en: After implementing a basic field, let’s implement some fields that access our
    service functions and retrieve data from MongoDB.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现基本字段之后，让我们实现一些访问我们的服务函数并从 MongoDB 获取数据的字段。
- en: Implementing fields that query posts
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现查询帖子的字段
- en: 'Follow these steps to implement the fields to query posts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现查询帖子的字段：
- en: 'Edit **backend/src/graphql/query.js** and import the relevant service functions:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/graphql/query.js** 并导入相关的服务函数：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Adjust the schema to include a **posts** field, which returns an array of posts:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整模式以包含一个 **posts** 字段，它返回一个帖子数组：
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Additionally, define fields for querying posts by **author** and **tag**, both
    of which accept a required argument:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，定义用于通过 **author** 和 **tag** 查询帖子的字段，这两个字段都接受一个必需的参数：
- en: '[PRE20]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Lastly, define a field to query a post by **id**:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义一个通过 **id** 查询帖子的字段：
- en: '[PRE21]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have defined the schema, we still need to provide resolvers for
    all those fields. Thanks to our service functions, this is quite straightforward:
    we can simply call our service functions with the relevant arguments in **async**
    functions, as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了模式，我们仍然需要为所有这些字段提供解析器。多亏了我们的服务函数，这相当简单：我们可以在 **async** 函数中简单地调用我们的服务函数，并使用相关参数，如下所示：
- en: '[PRE22]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The resolver functions always receive the `parent` object as the first argument
    and an object with all arguments as a second argument.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解析器函数始终将 `parent` 对象作为第一个参数，将所有参数作为第二个参数的对象接收。
- en: Now we have successfully defined fields to query posts. However, the `Post`
    type is not defined yet, so our GraphQL queries will not work yet. Let’s do that
    next.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功定义了查询帖子的字段。然而，`Post` 类型尚未定义，因此我们的 GraphQL 查询目前还不能工作。让我们接下来做这件事。
- en: Defining the Post type
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 Post 类型
- en: 'After defining the `Query` type, we continue by defining the `Post` type, as
    follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 `Query` 类型之后，我们继续定义 `Post` 类型，如下所示：
- en: 'Create a new **backend/src/graphql/post.js** file, where we import the **getUserInfoById**
    function to resolve the author of a post later:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **backend/src/graphql/post.js** 文件，其中我们导入 **getUserInfoById** 函数以稍后解析帖子的作者：
- en: '[PRE23]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, define **postSchema**. Note that **Post** consists of **id**, **title**,
    **author**, **contents**, **tags**, and the **createdAt** and **updatedAt** timestamps:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义 **postSchema**。注意，**Post** 由 **id**、**title**、**author**、**contents**、**tags**
    以及 **createdAt** 和 **updatedAt** 时间戳组成：
- en: '[PRE24]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, we use `[String!]` for the tags, and not `[String!]!`, because
    the `tags` field can also be non-existent/`null`.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `[String!]` 作为标签，而不是 `[String!]!`，因为 `tags` 字段也可以不存在/`null`。
- en: The `createdAt` and `updatedAt` timestamps are too large to fit into a 32-bit
    signed integer, so their type needs to be `Float` instead of `Int`.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`createdAt` 和 `updatedAt` 时间戳太大，无法放入 32 位有符号整数中，因此它们的类型需要是 `Float` 而不是 `Int`。'
- en: 'Next, define a resolver for the **author** field that gets the user using the
    service function:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个用于获取用户的服务函数的 **author** 字段的解析器：
- en: '[PRE25]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The resolvers for getting posts are already part of the `Query` schema, so we
    do not need to define how to get a post here. GraphQL knows that the query fields
    return `Post` arrays and then allows us to resolve further fields on the posts.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取帖子的解析器已经是 `Query` 模式的组成部分，所以我们不需要在这里定义如何获取帖子。GraphQL 知道查询字段返回 `Post` 数组，然后允许我们进一步解析帖子上的字段。
- en: 'Edit **backend/src/graphql/index.js** and add the **postSchema** and **postResolver**:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/graphql/index.js** 并添加 **postSchema** 和 **postResolver**：
- en: '[PRE26]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After defining the `Post` type, let’s continue with the `User` type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 `Post` 类型之后，让我们继续定义 `User` 类型。
- en: Defining the User type
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义用户类型
- en: 'When defining the `Post` type, we used the `User` type to define the author
    of a post. However, we have not defined the `User` type yet. Let’s do that now:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义 `Post` 类型时，我们使用了 `User` 类型来定义帖子的作者。然而，我们尚未定义 `User` 类型。现在让我们来做这件事：
- en: 'Create a new **backend/src/graphql/user.js** file and import the **listPostsByAuthor**
    function here, as we are going to add a way to resolve the posts of a user when
    getting a user object, to show how GraphQL can deal with deeply nested relations:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **backend/src/graphql/user.js** 文件，并将 **listPostsByAuthor** 函数导入到这里，因为我们将要添加一种解析用户对象时获取用户帖子的方式，以展示
    GraphQL 如何处理深度嵌套的关系：
- en: '[PRE27]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define **userSchema**. Each **User** in our GraphQL schema has **username**
    and a **posts** field, in which we will resolve all posts that the user has written:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 **userSchema**。在我们的 GraphQL 模式中，每个 **User** 都有 **username** 和一个 **posts**
    字段，我们将解析用户所写的所有帖子：
- en: '[PRE28]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Info
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: We do not specify any other properties here, as we are only returning the username
    in our **getUserInfoById** service function. If we wanted to get the user ID here
    too, we would have to return it from that function. We are not just returning
    the full user object, as that could be a potential security vulnerability, exposing
    internal data such as the password (or billing info in some apps).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有指定任何其他属性，因为我们只在我们 **getUserInfoById** 服务函数中返回用户名。如果我们还想在这里获取用户 ID，我们就必须从该函数中返回它。我们不是返回完整的用户对象，因为这可能是一个潜在的安全漏洞，暴露内部数据，如密码（或某些应用程序中的账单信息）。
- en: 'Next, define **userResolver**, which gets all posts from the current user:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义 **userResolver**，它获取当前用户的所有帖子：
- en: '[PRE29]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Edit **backend/src/graphql/index.js** and add the **userSchema** and **userResolver**:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/graphql/index.js** 并添加 **userSchema** 和 **userResolver**：
- en: '[PRE30]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After defining the `User` type, let’s try out some deeply nested queries!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 `User` 类型之后，让我们尝试一些深度嵌套的查询！
- en: Trying out deeply nested queries
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试深度嵌套的查询
- en: Now that we have successfully defined our GraphQL schemas and resolvers, we
    can start querying our database using GraphQL!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功定义了我们的 GraphQL 模式和解析器，我们可以开始使用 GraphQL 查询我们的数据库了！
- en: 'For example, we can now get a full list of all posts, with their ID, title,
    and the username of the author, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们现在可以获取所有帖子的完整列表，包括它们的 ID、标题和作者的用户名，如下所示：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Execute the preceding query in the Apollo interface. As we can see, the query
    gets all posts, selects `id`, `title`, and `author` for each post, and then resolves
    `username` for each `author` instance. This query allows us to get all the data
    we need on the overview page in a single request, and we do not need to make separate
    requests to resolve the author usernames anymore!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Apollo 接口中执行前面的查询。正如我们所看到的，查询获取所有帖子，为每个帖子选择 `id`、`title` 和 `author`，然后为每个
    `author` 实例解析 `username`。这个查询允许我们在单个请求中获取我们需要的所有数据，我们不再需要单独的请求来解析作者的用户名了！
- en: Info
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: We did not specify the **password** field on the **User** type, so GraphQL will
    not allow us to access it, even if the resolver function returns a user object
    that contains the password.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在 `User` 类型中指定 **密码** 字段，所以 GraphQL 不会允许我们访问它，即使解析器函数返回一个包含密码的用户对象。
- en: 'Now, let’s try out a query that gets a post by ID and then finds other posts
    by the same author. This could be used to, for example, recommend other articles
    to view from the same author after someone has finished reading a post:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一个通过 ID 获取帖子并然后找到相同作者的其他帖子的查询。这可以用来，例如，在某人阅读完帖子后推荐同一作者的其他文章查看：
- en: 'We can automatically generate a query in the Apollo interface by clearing the
    contents of the **Operation** textbox and then selecting **Query** from **Root
    Types** in the **Documentation** sidebar on the left. Now click on the **+** button
    next to the **postById** field on the left, which automatically defines a query
    variable for us, which looks as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过清空**操作**文本框的内容，然后在左侧的**文档**侧边栏中选择**根类型**下的**查询**，在 Apollo 接口中自动生成一个查询。现在点击左侧**postById**字段旁边的**+**按钮，它会自动为我们定义一个查询变量，看起来如下所示：
- en: '[PRE32]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: "![Figure 11.\uFEFF3 – Automatically generating a query using the Apollo interface](img/B19385_11_3.jpg)"
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 使用 Apollo 接口自动生成查询](img/B19385_11_3.jpg)'
- en: Figure 11.3 – Automatically generating a query using the Apollo interface
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 使用 Apollo 接口自动生成查询
- en: 'Within the post, we can now get the **title**, **contents**, and **author**
    values of the post:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在帖子内部，我们现在可以获取帖子的**标题**、**内容**和**作者**值：
- en: '[PRE33]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Inside the **author** field, we get **username** and the IDs and titles of
    their posts:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**作者**字段内部，我们获取**用户名**以及他们的帖子 ID 和标题：
- en: '[PRE34]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'At the bottom of the Apollo interface, there is a **Variables** section, which
    we need to fill with an ID that exists in our database:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Apollo 接口的底部，有一个**变量**部分，我们需要在其中填写数据库中存在的 ID：
- en: '[PRE35]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the query, and you will see that the post and author are resolved, and
    all posts written by that same author are also listed properly, as shown in the
    following screenshot:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行查询，你会看到帖子及其作者被解析，并且该作者所写的所有帖子也被正确列出，如下面的截图所示：
- en: "![Figure 11.\uFEFF4 – Running deeply nested queries in GraphQL](img/B19385_11_4.jpg)"
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 在 GraphQL 中运行深度嵌套查询](img/B19385_11_4.jpg)'
- en: Figure 11.4 – Running deeply nested queries in GraphQL
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 在 GraphQL 中运行深度嵌套查询
- en: Next, let’s learn how to provide arguments to fields by defining input types.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何通过定义输入类型为字段提供参数。
- en: Implementing input types
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现输入类型
- en: 'We have already learned how to define regular types in GraphQL, but what if
    we have a common way to provide arguments to fields? For example, the options
    to query posts are always the same (`sortBy` and `sortOrder`). We cannot use a
    regular type for this, instead, we need to define an input type. Follow these
    steps to implement query options in GraphQL:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何在 GraphQL 中定义常规类型，但如果我们有一个通用的方式为字段提供参数呢？例如，查询帖子的选项总是相同的（`sortBy` 和
    `sortOrder`）。我们不能使用常规类型，相反，我们需要定义一个输入类型。按照以下步骤在 GraphQL 中实现查询选项：
- en: 'Edit **backend/src/graphql/query.js** and define an input type in the schema:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/graphql/query.js** 并在模式中定义一个输入类型：
- en: '[PRE36]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, use the input type as an argument to fields, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用输入类型作为字段的参数，如下所示：
- en: '[PRE37]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, edit the resolvers to pass on **options** to the service functions:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑解析器以传递**选项**到服务函数：
- en: '[PRE38]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Try out the following query to see whether the posts are sorted properly:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试以下查询以查看帖子是否按正确顺序排序：
- en: '[PRE39]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Set the following variables:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置以下变量：
- en: '[PRE40]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run the query by pressing the **Play** button, and you should see that the response
    is sorted by the **updatedAt** timestamp ascending!
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下**播放**按钮运行查询，你应该会看到响应按**updatedAt**时间戳升序排序！
- en: Now that we have successfully implemented functionality to query our database
    using GraphQL, let’s move on to implementing a way to create a new post using
    GraphQL Mutations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功实现了使用 GraphQL 查询数据库的功能，接下来让我们继续实现使用 GraphQL 创建新帖子的方法。
- en: Implementing GraphQL authentication and mutations
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现GraphQL认证和突变
- en: We are now going to implement a way to create new posts using GraphQL. To define
    fields that change the database state, we need to create them under the `mutation`
    type. Before we can do that, however, we first need to implement authentication
    in GraphQL, so that we can access the currently logged-in user when creating a
    post.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现使用 GraphQL 创建新帖子的方法。为了定义改变数据库状态的字段，我们需要在 `mutation` 类型下创建它们。然而，在我们这样做之前，我们首先需要在
    GraphQL 中实现认证，这样我们就可以在创建帖子时访问当前登录的用户。
- en: Adding authentication to GraphQL
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将认证添加到 GraphQL
- en: 'Because we are using GraphQL with Express, we can use any Express middleware
    with GraphQL and pass it to our resolvers as `context`. As such, we can use the
    existing `express-jwt` middleware to parse the JWT. Let’s get started adding authentication
    to GraphQL now:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在使用 Express 与 GraphQL，所以我们可以使用任何 Express 中间件与 GraphQL，并将其传递给我们的解析器作为 `context`。因此，我们可以使用现有的
    `express-jwt` 中间件来解析 JWT。现在让我们开始为 GraphQL 添加认证：
- en: 'Our current configuration of the **requireAuth** middleware ensures that the
    user is logged in and throws an error if they are not. However, this is an issue
    when passing the **auth** context to GraphQL, because not all queries require
    authentication. We are now going to create a new **optionalAuth** middleware that
    does not require credentials to process a request. Edit **backend/src/middleware/jwt.js**
    and define the following new middleware:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们当前的**requireAuth**中间件配置确保用户已登录，如果他们未登录则抛出错误。然而，当将**auth**上下文传递给GraphQL时，这是一个问题，因为并非所有查询都需要身份验证。我们现在将创建一个新的**optionalAuth**中间件，它不需要凭证来处理请求。编辑**backend/src/middleware/jwt.js**并定义以下新中间件：
- en: '[PRE41]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, edit **backend/src/app.js** and import the **optionalAuth** middleware
    there:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑**backend/src/app.js**，并在其中导入**optionalAuth**中间件：
- en: '[PRE42]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Edit the **app.use()** call where we defined the **/graphql** route and add
    the **optionalAuth** middleware to it, similarly to how we did it for routes:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑我们定义**/graphql**路由的**app.use()**调用，并向其中添加**optionalAuth**中间件，类似于我们对路由所做的那样：
- en: '[PRE43]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, add a second argument to the Apollo **expressMiddleware**, defining a
    **context** function that provides **req.auth** to the GraphQL resolvers as context:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向Apollo **expressMiddleware**添加第二个参数，定义一个**context**函数，该函数将**req.auth**作为上下文提供给GraphQL解析器：
- en: '[PRE44]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, let’s move on to implementing mutations in GraphQL.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续在GraphQL中实现突变。
- en: Implementing mutations
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现突变
- en: 'Now that we have added authentication to GraphQL, we can define our mutations.
    Follow these steps to create mutations for signup, login, and creating posts:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为GraphQL添加了身份验证，我们可以定义我们的突变。按照以下步骤创建注册、登录和创建帖子的突变：
- en: 'Create a new **backend/src/graphql/mutation.js** file and import **GraphQLError**
    (for throwing an **UNAUTHORIZED** error when the user is not logged in), as well
    as the **createUser**, **loginUser**, and **createPost** functions:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**backend/src/graphql/mutation.js**文件，并导入**GraphQLError**（在用户未登录时抛出**UNAUTHORIZED**错误），以及**createUser**、**loginUser**和**createPost**函数：
- en: '[PRE45]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define **mutationSchema**, in which we first define fields to sign up and log
    in users. The **signupUser** field returns a user object, and the **loginUser**
    field returns a JWT:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义**mutationSchema**，在其中我们首先定义注册和登录用户的字段。**signupUser**字段返回一个用户对象，而**loginUser**字段返回一个JWT：
- en: '[PRE46]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, define a field to create a new post from some given **title**, **contents**
    (optional), and **tags** (optional). It returns a newly created post:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个字段，用于从给定的**标题**、**内容**（可选）和**标签**（可选）创建一个新的帖子。它返回一个新创建的帖子：
- en: '[PRE47]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Define the resolver, in which we first define the **signupUser** and **loginUser**
    fields, which are quite straightforward:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义解析器，在其中我们首先定义**signupUser**和**loginUser**字段，它们相当直接：
- en: '[PRE48]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we define the **createPost** field. Here, we first access the arguments
    passed to the field, and as a third argument to the resolver function, we get
    the context we created earlier:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义**createPost**字段。在这里，我们首先访问传递给字段的参数，并且作为解析函数的第三个参数，我们得到之前创建的上下文：
- en: '[PRE49]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If the user is not logged in, the **auth** context will be **null**. We throw
    an error in that case and do not create a new post:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户未登录，**auth**上下文将为**null**。在这种情况下，我们会抛出一个错误，并且不会创建新的帖子：
- en: '[PRE50]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Otherwise, we use **auth.sub** (which contains the user ID) and the provided
    arguments to create a new post:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们使用**auth.sub**（其中包含用户ID）和提供的参数来创建一个新的帖子：
- en: '[PRE51]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Edit **backend/src/graphql/index.js** and add the **mutationSchema** and **mutationResolver**:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**backend/src/graphql/index.js**，并添加**mutationSchema**和**mutationResolver**：
- en: '[PRE52]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: After implementing mutations, let’s learn how to use them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现突变之后，让我们学习如何使用它们。
- en: Using mutations
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用突变
- en: 'After defining the possible mutations, we can use them by running them in the
    Apollo interface. Follow these steps to first sign up a user, then log them in,
    and finally create a post – all using GraphQL:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义可能的突变之后，我们可以在Apollo界面中运行它们。按照以下步骤首先注册一个用户，然后登录，最后创建一个帖子——所有这些操作都使用GraphQL：
- en: 'Go to **http://localhost:3001/graphql** to view the Apollo interface. Define
    a new mutation that signs up a user with a given username and password, and returns
    the username if the signup was successful:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**http://localhost:3001/graphql**查看Apollo界面。定义一个新的突变，用于使用给定的用户名和密码注册用户，并在注册成功时返回用户名：
- en: '[PRE53]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Tip
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use the **Documentation** section on the left by going back to **Root
    Types**, clicking on **Mutation**, and then clicking on the **+** icon next to
    **signupUser**. Then, click on the **+** icon next to the **username** field.
    This will automatically create the preceding code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过回到 **Root Types**，点击 **Mutation**，然后点击 **signupUser** 旁边的 **+** 图标来使用左侧的
    **Documentation** 部分。然后，点击 **username** 字段旁边的 **+** 图标。这将自动创建前面的代码。
- en: 'Edit the variables at the bottom and enter a username and password:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑底部的变量并输入用户名和密码：
- en: '[PRE54]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Execute the **SignupUser** mutation by pressing the play button.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按播放按钮执行 **SignupUser** 突变。
- en: 'Next, create a new mutation to log in a user:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的突变来登录用户：
- en: '[PRE55]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Enter the same variables as before and press the play button, the response contains
    a JWT. Copy and store the JWT somewhere for later use.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入与之前相同的变量并按播放按钮，响应包含 JWT。复制并存储 JWT 以供以后使用。
- en: 'Define a new mutation to create a post. This mutation returns **Post**, so
    we can get the **id**, **title**, and **username** values for **author**:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的突变来创建帖子。这个突变返回 **Post**，因此我们可以获取 **id**、**title** 和 **author** 的 **username**
    值：
- en: '[PRE56]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is an example of where GraphQL really shines. We can resolve the username
    of the author after creating the post to see whether it was really created with
    the correct user, because we can access the resolvers defined for `Post`, even
    in mutations! As you can see, GraphQL is very flexible.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是 GraphQL 真正发光的地方。在创建帖子后，我们可以解析作者的用户名，以查看它是否真的是由正确的用户创建的，因为我们可以访问为 `Post`
    定义的解析器，即使在突变中也可以！正如你所看到的，GraphQL 非常灵活。
- en: 'Enter the following variables:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下变量：
- en: '[PRE57]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Select the **Headers** tab, press the **New header** button, enter **Authorization**
    for **header key**, and **Bearer <Paste previously copied JWT here>** for **value**.
    Then press the **Play** button to submit the mutation.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Headers** 选项卡，点击 **New header** 按钮，输入 **Authorization** 作为 **header key**，并将
    **Bearer <粘贴之前复制的 JWT**> 作为 **value**。然后点击 **Play** 按钮提交突变。
- en: '![Figure 11.5 – Adding the Authorization header in the Apollo interface](img/B19385_11_5.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 在 Apollo 接口中添加授权头](img/B19385_11_5.jpg)'
- en: Figure 11.5 – Adding the Authorization header in the Apollo interface
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 在 Apollo 接口中添加授权头
- en: In the response, you can see that the post was successfully created, and the
    author is set and resolved correctly!
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在响应中，你可以看到帖子已成功创建，作者已正确设置和解析！
- en: Having implemented GraphQL queries and mutations for our blog applications,
    let’s wrap up the chapter by giving an overview of advanced GraphQL concepts.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的博客应用程序实现了 GraphQL 查询和突变之后，让我们通过概述高级 GraphQL 概念来结束本章。
- en: Overview of advanced GraphQL concepts
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 GraphQL 概念概述
- en: 'Out of the box, GraphQL comes with a set of scalar types:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，GraphQL 附带一组标量类型：
- en: '**Int**: A signed 32-bit integer'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Int**：有符号的 32 位整数'
- en: '**Float**: A signed double-precision floating-point value'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Float**：有符号的双精度浮点值'
- en: '**String**: A UTF-8 encoded character sequence'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**String**：UTF-8 编码的字符序列'
- en: '**Boolean**: Can be true or false'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Boolean**：可以是 true 或 false'
- en: '**ID**: A unique identifier, serialized as a **String**, but meant to signify
    that it is not human readable'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID**：一个唯一的标识符，序列化为 **String**，但表示它不是人类可读的'
- en: 'GraphQL also allows the definition of enums, which are a special kind of scalar.
    They are restricted to certain values. For example, we could have the following
    enum to distinguish different types of posts:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 还允许定义枚举，枚举是一种特殊的标量类型。它们被限制在特定的值范围内。例如，我们可以定义以下枚举来区分不同类型的帖子：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In Apollo, enums will be handled as strings that can only have certain values,
    but this may be different in other GraphQL implementations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Apollo 中，枚举将被处理为只能具有特定值的字符串，但在其他 GraphQL 实现中可能会有所不同。
- en: Many GraphQL implementations also allow defining custom scalar types. Apollo,
    for example, supports the definition of custom scalar types.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 GraphQL 实现也允许定义自定义标量类型。例如，Apollo 支持自定义标量类型的定义。
- en: Fragments
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 片段
- en: 'When the same kind of fields are regularly accessed, we can create a fragment
    to simplify and standardize access to them. For example, if we often resolve users,
    and users have fields such as `username`, `profilePicture`, `fullName`, and `biography`,
    we could create the following fragment:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当同类型的字段经常被访问时，我们可以创建一个片段来简化并标准化对这些字段的访问。例如，如果我们经常解析用户，并且用户有 `username`、`profilePicture`、`fullName`
    和 `biography` 等字段，我们可以创建以下片段：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This fragment can then be used in queries. For example, see this snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段可以在查询中使用。例如，看看这个片段：
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Fragments are especially useful when the same kind of field structure is used
    multiple times in the same query. For example, if an author had `followedBy` and
    `follows` fields, we could resolve all users like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当相同的字段结构在同一个查询中多次使用时，片段特别有用。例如，如果一个作者有 `followedBy` 和 `follows` 字段，我们可以这样解析所有用户：
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Introspection
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询反射
- en: Introspection allows us to query the defined schemas themselves to get a feeling
    for the data that the server can provide for us. It is essentially querying the
    schemas defined by the GraphQL server. We can use the `__schema` field to get
    all schemas. A schema consists of `types`, which have `name` values.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 查询反射使我们能够查询定义的架构本身，以了解服务器为我们提供的数据。本质上，这是查询由 GraphQL 服务器定义的架构。我们可以使用 `__schema`
    字段来获取所有架构。架构由 `types` 组成，这些 `types` 有 `name` 值。
- en: 'For example, we can use the following query to get all types defined by our
    server:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下查询来获取我们服务器上定义的所有类型：
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you execute this query on our server, you will get (among other types) our
    defined `Query`, `Post`, `User`, and `Mutation` types.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在我们服务器上执行此查询，你将获得（包括其他类型）我们定义的 `Query`、`Post`、`User` 和 `Mutation` 类型。
- en: Introspection queries are very powerful, and you can get a lot of information
    about the possible queries and mutations from it. Actually, the Apollo interface
    uses introspection to render the **Documentation** sidebar and to auto-complete
    fields for us!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 查询反射非常强大，你可以从中获取有关可能查询和突变的大量信息。实际上，Apollo 接口使用反射来渲染 **文档** 侧边栏，并为我们自动完成字段！
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned what GraphQL is and how it can be more flexible
    than REST while requiring less boilerplate code, especially when querying deeply
    nested objects. Then, we implemented GraphQL in our backend and created various
    types, queries, and mutations. We also learned how to integrate JWT authentication
    in GraphQL. Finally, we wrapped up the chapter by learning about advanced concepts,
    such as the type system, fragments, and introspection.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 GraphQL 是什么以及它如何比 REST 更灵活，同时需要更少的样板代码，尤其是在查询深度嵌套对象时。然后，我们在后端实现了
    GraphQL 并创建了各种类型、查询和突变。我们还学习了如何在 GraphQL 中集成 JWT 身份验证。最后，我们通过学习高级概念，如类型系统、片段和查询反射来结束本章。
- en: In the next chapter, [*Chapter 12*](B19385_12.xhtml#_idTextAnchor232)*, Interfacing
    with GraphQL on the Frontend Using Apollo Client*, we are going to learn how to
    access and integrate GraphQL in our frontend using React and the Apollo Client
    library.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第12章*](B19385_12.xhtml#_idTextAnchor232)“使用 Apollo 客户端在前端与 GraphQL 交互”，我们将学习如何使用
    React 和 Apollo 客户端库访问和集成 GraphQL。
