<html><head></head><body>
		<div id="_idContainer064">
			<h1 id="_idParaDest-58" class="chapter-number"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.2.1">Leveraging Computed Properties and Methods in Vue.js</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we learned about </span><strong class="old"><span class="koboSpan" id="kobo.4.1">Vue</span></strong><span class="koboSpan" id="kobo.5.1"> directives and spent most of our time in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">&lt;template&gt;</span></strong><span class="koboSpan" id="kobo.7.1"> section of our component. </span><span class="koboSpan" id="kobo.7.2">In this chapter, we are going to move our focus to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.9.1"> tag and learn how to ensure that the logic of our component </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">is abstracted.</span></span></p>
			<p><span class="koboSpan" id="kobo.11.1">This chapter aims to introduce you to two features: </span><strong class="old"><span class="koboSpan" id="kobo.12.1">methods</span></strong><span class="koboSpan" id="kobo.13.1"> and </span><strong class="old"><span class="koboSpan" id="kobo.14.1">computed</span></strong><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">These Vue.js features are essential to ensuring that your component logic remains performant and readable. </span><span class="koboSpan" id="kobo.15.3">We will go over the components that we created in previous chapters and use the preceding techniques to make them easier to read. </span><span class="koboSpan" id="kobo.15.4">Throughout the chapter, we will also continue to add further details to features that we have learned about in previous chapters, such as Refs variables </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">and directives.</span></span></p>
			<p><span class="koboSpan" id="kobo.17.1">This chapter is going to be broken down into the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">following sections:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.19.1">Abstracting functionality </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">using methods</span></span></li>
				<li><span class="koboSpan" id="kobo.21.1">Creating dynamic data using </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">computed properties</span></span></li>
				<li><span class="koboSpan" id="kobo.23.1">Learning the difference between methods and </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">computed properties</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.25.1">By the end of this chapter, you will be able to abstract your logic within methods, create reactive variables using computed properties, and most importantly, understand the difference </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">between them.</span></span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.27.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.28.1">To be able to follow this chapter, you should use a branch called </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">CH05</span></strong><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">To pull this branch, run the following command or use your GUI software of choice to support you in </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">this operation:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.32.1">
git switch CH05</span></pre>
			<p><span class="koboSpan" id="kobo.33.1">The code files for the chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">at </span></span><a href="https://github.com/PacktPublishing/Vue.js-3-for-Beginners"><span class="No-Break"><span class="koboSpan" id="kobo.35.1">https://github.com/PacktPublishing/Vue.js-3-for-Beginners</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.36.1">.</span></span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.37.1">Abstracting functionality using methods</span></h1>
			<p><span class="koboSpan" id="kobo.38.1">Most of the</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.39.1"> components shown within tutorials and training, such as the ones shared in this book so far, always appear to be easy to read and extremely small, but this is not always the case. </span><span class="koboSpan" id="kobo.39.2">Components written in real </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.40.1">applications can easily get bloated with logic and become very hard to read. </span><span class="koboSpan" id="kobo.40.2">Most of the time, this complexity is the result of multiple iterations and </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">feature changes.</span></span></p>
			<p><span class="koboSpan" id="kobo.42.1">It is very important to try and keep the components as clean as possible. </span><span class="koboSpan" id="kobo.42.2">The easiest way to achieve this is by abstracting the logic from the HTML and moving it within </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.44.1">, but what can we use to simplify </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">our components?</span></span></p>
			<p><span class="koboSpan" id="kobo.46.1">This is where methods come in handy. </span><span class="koboSpan" id="kobo.46.2">Methods are JavaScript functions that can be used within a Vue.js component instance. </span><span class="koboSpan" id="kobo.46.3">Methods can be described as helpers that allow you to perform an action within </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">your component.</span></span></p>
			<p><span class="koboSpan" id="kobo.48.1">Methods could be used in a wide variety of cases, from fetching data from an API to validating user input, and will be our go-to Vue.js feature to simplify our </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">component’s logic.</span></span></p>
			<p><span class="koboSpan" id="kobo.50.1">Writing methods while using the Composition API syntax is extremely simple as methods are just simple </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">JavaScript functions.</span></span></p>
			<p><span class="koboSpan" id="kobo.52.1">It is time to check out the correct branch from our repository as previously mentioned in the </span><em class="italic"><span class="koboSpan" id="kobo.53.1">Technical requirements</span></em><span class="koboSpan" id="kobo.54.1"> section and see methods </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">in action.</span></span></p>
			<p><span class="koboSpan" id="kobo.56.1">We are going to look at the HTML of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">SocialPost.vue</span></strong><span class="koboSpan" id="kobo.58.1"> component within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">components/molecules</span></strong><span class="koboSpan" id="kobo.60.1"> folders and try to find some logic that can be extracted. </span><span class="koboSpan" id="kobo.60.2">What we are looking for is any JavaScript code that we have written within the HTML elements of our components that can be turned into </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">a function:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.62.1">
&lt;template&gt;
&lt;div
  class="SocialPost"
  :class="{ SocialPost__selected: selected}"
  @click="</span><strong class="old"><span class="koboSpan" id="kobo.63.1">selected = !selected"</span></strong><span class="koboSpan" id="kobo.64.1">
&gt;
  &lt;div class="header"&gt;
    &lt;img class="avatar" :src="avatarSrc" /&gt;
    &lt;div class="name"&gt;{{ username }}&lt;/div&gt;
    &lt;div class="userId"&gt;{{ userId }}&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="post" v-text="post"&gt;&lt;/div&gt;
  &lt;button
    v-show="comments.length &gt; 0"
    @click="</span><strong class="old"><span class="koboSpan" id="kobo.65.1">showComments = !showComments"</span></strong><span class="koboSpan" id="kobo.66.1">
  &gt;
    Show Comments
  &lt;/button&gt;
  &lt;SocialPostComments
    v-if="showComments"
    :comments="comments"
  /&gt;
&lt;/div&gt;
&lt;/template&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.67.1">When you</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.68.1"> analyze a component, the best candidates for</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.69.1"> refactoring into methods are </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">as follows:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.71.1">Logic associated with events (</span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">click, change)</span></span></li>
				<li><span class="koboSpan" id="kobo.73.1">Logic that requires a parameter (</span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">loop index)</span></span></li>
				<li><span class="koboSpan" id="kobo.75.1">Logic that performs a </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">side effect</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.77.1">In our preceding code, we have two instances of click events that have some logic associated with them: </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">@click="selected = !selected"</span></strong><span class="koboSpan" id="kobo.79.1"> within the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">&lt;DIV&gt;</span></strong><span class="koboSpan" id="kobo.81.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">@click="showComments = !showComments"</span></strong><span class="koboSpan" id="kobo.83.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">Show </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">Comments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.86.1"> button.</span></span></p>
			<p><span class="koboSpan" id="kobo.87.1">These </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.88.1">are great candidates to be refactored as that logic should not live within the DOM  (Document Object Model) but be moved out </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.89.1">within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.91.1"> tag of our component. </span><span class="koboSpan" id="kobo.91.2">Refactoring this code is done in two simple steps. </span><span class="koboSpan" id="kobo.91.3">First, we will create a method within our </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.93.1"> and then we will replace the logic with our newly </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">created method.</span></span></p>
			<p><span class="koboSpan" id="kobo.95.1">Let’s create two functions within our component logic called </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">onSelectedClick</span></strong> <span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">and</span></strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">onShowCommentClick</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.100.1">Let’s update </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">our code:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.102.1">
&lt;script setup &gt;
import { onMounted, ref } from 'vue';
import SocialPostComments from './SocialPostComments.vue';
const selected = ref(false);
</span><strong class="old"><span class="koboSpan" id="kobo.103.1">const onSelectedClick = () =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.104.1">  selected.value = !selected.value;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.105.1">}</span></strong><span class="koboSpan" id="kobo.106.1">
const showComments = ref(false);
</span><strong class="old"><span class="koboSpan" id="kobo.107.1">const onShowCommentClick = () =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.108.1">  showComments.value = !showComments.value;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.109.1">}</span></strong><span class="koboSpan" id="kobo.110.1">
...
</span><span class="koboSpan" id="kobo.110.2">&lt;/script&gt;</span></pre>
			<p class="callout-heading"><span class="koboSpan" id="kobo.111.1">Prefix your event handler with “on”</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.112.1">You may have noticed that I have prefixed the event method name with the word “on” and suffixed it with the event name (click). </span><span class="koboSpan" id="kobo.112.2">This is good practice as it makes the code more readable and helps you identify methods that are associated </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">with events.</span></span></p>
			<p><span class="koboSpan" id="kobo.114.1">Thanks to the</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.115.1"> Composition API syntax, we </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.116.1">can group our functionalities by adding the methods right below the Ref's initialization, making our code clean and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">to read.</span></span></p>
			<h3><span class="koboSpan" id="kobo.118.1">Read and write Ref in the &lt;script&gt; tag</span></h3>
			<p><span class="koboSpan" id="kobo.119.1">You may have noticed that the code has something different from the logic that we used in the HTML. </span><span class="koboSpan" id="kobo.119.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">selected</span></strong><span class="koboSpan" id="kobo.121.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">showComments</span></strong><span class="koboSpan" id="kobo.123.1"> Refs have a different syntax as they are followed </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">.value</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.127.1">Adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">.value</span></strong><span class="koboSpan" id="kobo.129.1"> to a</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.130.1"> Ref is a requirement when reading and writing Ref within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.132.1"> tag and does not apply to Reactive variables, which</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.133.1"> can be accessed with </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">normal variables.</span></span></p>
			<p><span class="koboSpan" id="kobo.135.1">Let’s see a visual to help clarify the difference between Ref </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">and Reactive:</span></span></p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<span class="koboSpan" id="kobo.137.1"><img src="image/B21130_05_01_BW.jpg" alt="Figure 5.1: Table displaying the differences when reading and writing Ref and Reactive within the &lt;script&gt; and &lt;template&gt; tags"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.138.1">Figure 5.1: Table displaying the differences when reading and writing Ref and Reactive within the &lt;script&gt; and &lt;template&gt; tags</span></p>
			<p><span class="koboSpan" id="kobo.139.1">I know that this may be confusing at first, but by the end of the book, you will have mastered this difference as we will iterate and use this multiple times in the course of </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">our development.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.141.1">Why do Ref need .value</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.142.1">Vue reactivity is built on top of the proxy object that listens for “get” and “set” events of a variable. </span><span class="koboSpan" id="kobo.142.2">This proxy is not available in primitive values such as string, number, and Booleans (the type used with ref). </span><span class="koboSpan" id="kobo.142.3">To overcome this, these primitives are transformed into objects with a single property </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">.value</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.146.1">Now that our </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.147.1">methods have been created, it is time to call them. </span><span class="koboSpan" id="kobo.147.2">We</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.148.1"> are going to call these methods from the HTML of our component. </span><span class="koboSpan" id="kobo.148.2">To do so, we are going to remove the previous logic that was assigned to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">@click</span></strong><span class="koboSpan" id="kobo.150.1"> event and replace it with the methods that we </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">just created.</span></span></p>
			<p><span class="koboSpan" id="kobo.152.1">Our main </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.154.1"> will look </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">like this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
&lt;div
  class="SocialPost"
  :class="{ SocialPost__selected: selected}"
  </span><strong class="old"><span class="koboSpan" id="kobo.157.1">@click="onSelectedClick"</span></strong><span class="koboSpan" id="kobo.158.1">
&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.159.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">Show Comments</span></strong><span class="koboSpan" id="kobo.161.1"> button will transform </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">into this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.163.1">
&lt;button
  v-show="comments.length &gt; 0"
  </span><strong class="old"><span class="koboSpan" id="kobo.164.1">@click="onShowCommentClick"</span></strong><span class="koboSpan" id="kobo.165.1">
&gt;
  Show Comments
&lt;/button&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.166.1">As shown in the preceding code, the logic associated with our click events has been moved into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">script&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.169.1"> tag.</span></span></p>
			<p><span class="koboSpan" id="kobo.170.1">The change we made may seem very irrelevant and not worth it, but small readability improvements such as this one contribute to a code that is not only easy to read but also easy </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">to change.</span></span></p>
			<p><span class="koboSpan" id="kobo.172.1">Let’s modify our component one more time and assume that we have been tasked to trigger a log using </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">console.log</span></strong><span class="koboSpan" id="kobo.174.1"> every time the </span><strong class="old"><span class="koboSpan" id="kobo.175.1">Show Comments</span></strong><span class="koboSpan" id="kobo.176.1"> button is clicked. </span><span class="koboSpan" id="kobo.176.2">If we had not abstracted the logic out of the HTML, achieving this would have been very complicated and verbose. </span><span class="koboSpan" id="kobo.176.3">However, luckily for us, the methods are now easily accessible within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.178.1"> tag of</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.179.1"> our component and they can easily </span><a id="_idIndexMarker263"/><span class="No-Break"><span class="koboSpan" id="kobo.180.1">be expanded:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.181.1">
const showComments = ref(false);
const onShowCommentClick = () =&gt; {
  </span><strong class="old"><span class="koboSpan" id="kobo.182.1">console.log("Showing comments");</span></strong><span class="koboSpan" id="kobo.183.1">
  showComments.value = !showComments.value;
}</span></pre>
			<p><span class="koboSpan" id="kobo.184.1">Adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">console.log</span></strong><span class="koboSpan" id="kobo.186.1"> could not be easier. </span><span class="koboSpan" id="kobo.186.2">We We modified the methods methods using our existing JavaScript knowledge, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">preceding code.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.188.1">Your turn</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.189.1">Try to create your own methods. </span><span class="koboSpan" id="kobo.189.2">My suggestions would be to try and add </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">console.log</span></strong><span class="koboSpan" id="kobo.191.1"> to a message when one of the components mounts (you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">onMounted</span></strong><span class="koboSpan" id="kobo.193.1">) or continue to practice using Ref and Reactive by creating a method that logs how many posts and comments the </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">application has.</span></span></p>
			<p><span class="koboSpan" id="kobo.195.1">You should now be able to refactor your components by using methods and improve the readability of your code. </span><span class="koboSpan" id="kobo.195.2">Breaking down complex code into smaller functions will help us keep our components maintainable. </span><span class="koboSpan" id="kobo.195.3">In the next section, we are going to look at a similar feature offered by Vue.js called </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">computed properties.</span></span></p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.197.1">Creating dynamic data using computed properties</span></h1>
			<p><span class="koboSpan" id="kobo.198.1">In the</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.199.1"> previous section, we</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.200.1"> learned how to simplify our component by abstracting the logic of</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.201.1"> our click events. </span><span class="koboSpan" id="kobo.201.2">We are going to continue on the subject of “refactoring” and introduce a new feature called </span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.202.1">computed properties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.204.1">When people first learn about computed properties, they usually compare them to methods due to their similarities, but in reality, this feature is more closely related to props and Ref </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">than methods.</span></span></p>
			<p><span class="koboSpan" id="kobo.206.1">Computed properties can be described </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">as follows:</span></span></p>
			<p class="author-quote"><span class="koboSpan" id="kobo.208.1">Computed properties enable you to create a dynamic property that can be used to modify, manipulate, and display your component data (refs, reactive, and properties). </span><span class="koboSpan" id="kobo.208.2">- </span><a href="https://blog.logrocket.com/"><span class="koboSpan" id="kobo.209.1">https://blog.logrocket.com/</span></a></p>
			<p><span class="koboSpan" id="kobo.210.1">So far, we </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.211.1">have used Ref, Reactive, and props to pass and display data within our application, but there are times when the data received may need to be formatted, or when we need to create new </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">data altogether.</span></span></p>
			<p><span class="koboSpan" id="kobo.213.1">When the </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.214.1">need for dynamic p</span><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.215.1">roperties arises, a computed property is the correct feature </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">to use.</span></span></p>
			<p><span class="koboSpan" id="kobo.217.1">Before we start to modify the Companion App, let’s introduce a couple of real-life examples to help better understand computed properties and </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">their goal.</span></span></p>
			<ul>
				<li><em class="italic"><span class="koboSpan" id="kobo.219.1">Scenario 1 – </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.220.1">student list</span></em></span><p class="list-inset"><span class="koboSpan" id="kobo.221.1">Let’s assume we receive data from an API that returns all students from a school, but we just want to filter out female students. </span><span class="koboSpan" id="kobo.221.2">We can use a computed property to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">filtered array.</span></span></p></li>
				<li><em class="italic"><span class="koboSpan" id="kobo.223.1">Scenario 2 – toggle on </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.224.1">array length</span></em></span><p class="list-inset"><span class="koboSpan" id="kobo.225.1">In this case, we have been asked to show a button only if five or more entries exist in our</span><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.226.1"> list. </span><span class="koboSpan" id="kobo.226.2">We can use computed properties to check the length of our entries and create a new property with a </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">Boolean value.</span></span></p></li>
				<li><em class="italic"><span class="koboSpan" id="kobo.228.1">Scenario 3 – </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.229.1">concatenate values</span></em></span><p class="list-inset"><span class="koboSpan" id="kobo.230.1">Imagine an application that has a first name and last name as properties, and you wish to have access to a variable including the full name.</span><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.231.1"> Well, we can use a computed property to create this value, which will depend on the first and </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">second names.</span></span></p></li>
				<li><em class="italic"><span class="koboSpan" id="kobo.233.1">Scenario 4 – </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.234.1">snippets</span></em></span><p class="list-inset"><span class="koboSpan" id="kobo.235.1">Have you ever encountered a blog in which you see just a small part of the blog post and can click “show more” to show the full article? </span><span class="koboSpan" id="kobo.235.2">Well, to achieve this, we can create computer properties that take our blog post and just return a certain number </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">of characters.</span></span></p></li>
			</ul>
			<p><span class="koboSpan" id="kobo.237.1">If you re-read </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.238.1">the preceding example, you may notice that they all have something in common. </span><span class="koboSpan" id="kobo.238.2">In fact, all the scenarios that </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.239.1">we proposed have the </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">following similarities:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.241.1">They all create a new piece of data / value that is required within </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">the component</span></span></li>
				<li><span class="koboSpan" id="kobo.243.1">They do not produce any </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">side effect</span></span></li>
				<li><span class="koboSpan" id="kobo.245.1">They all depend on another piece of data (props, Refs, </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">or Reactive)</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.247.1">The preceding bullets are present in all of the scenarios that I proposed, not because of my choice, but because they are the prerequisites of </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">com</span><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.249.1">puted properties.</span></span></p>
			<p><span class="koboSpan" id="kobo.250.1">A computed property is simply a feature that allows us to use one or more existing pieces of data (Refs, Reactive, and props) to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">new value.</span></span></p>
			<p><span class="koboSpan" id="kobo.252.1">It is time to start and look at some examples to be able to learn how and when to use </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">this feature.</span></span></p>
			<p><span class="koboSpan" id="kobo.254.1">The syntax of a computed property is </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">the following:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.256.1">
import { computed } from 'vue'
const test = computed( ... </span><span class="koboSpan" id="kobo.256.2">);</span></pre>
			<p><span class="koboSpan" id="kobo.257.1">When using a computed property, we need to first import it from Vue and then assign it to a new constant. </span><span class="koboSpan" id="kobo.257.2">The computed property accesses a callback that is going to include the logic required to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">new variable.</span></span></p>
			<p><span class="koboSpan" id="kobo.259.1">Let’s see a simple example and show how a computed property that creates a full name would </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">look like:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.261.1">
&lt;script setup&gt;
import { ref, computed } from 'vue'
const name = ref("Simone");
const surname = ref("Cuomo");
</span><strong class="old"><span class="koboSpan" id="kobo.262.1">const fullName = computed( () =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.263.1">  return `${name.value} ${surname.value}`;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.264.1">} );</span></strong><span class="koboSpan" id="kobo.265.1">
&lt;/script&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.266.1">In the </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.267.1">preceding code, we have created a new dynamic property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">fullName</span></strong><span class="koboSpan" id="kobo.269.1">. </span><span class="koboSpan" id="kobo.269.2">This will act just like a normal property and </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.270.1">can be used everywhere without </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">our components.</span></span></p>
			<p><span class="koboSpan" id="kobo.272.1">Just like we said before, the computed property fulfills our requirements, which are as follows: it creates new data (</span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">fullName</span></strong><span class="koboSpan" id="kobo.274.1">), depends on another value (</span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">name</span></strong><span class="koboSpan" id="kobo.276.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">surname</span></strong><span class="koboSpan" id="kobo.278.1">), and returns </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">a value.</span></span></p>
			<h3><span class="koboSpan" id="kobo.280.1">Adding computed properties to the companion application</span></h3>
			<p><span class="koboSpan" id="kobo.281.1">It is now </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.282.1">time to update our component and see how we can leverage computed properties to simplify our code </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">even further.</span></span></p>
			<p><span class="koboSpan" id="kobo.284.1">Just like in the previous section, we are going to continue to modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">SocialPost.vue</span></strong><span class="koboSpan" id="kobo.286.1"> file. </span><span class="koboSpan" id="kobo.286.2">Let’s review the file and try to see what a good candidate would be for a </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">computed property:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.288.1">
&lt;template&gt;
  &lt;div
    class="SocialPost"
    :class="{ SocialPost__selected: selected}"
    @click="onSelectedClick"
  &gt;
    &lt;div class="header"&gt;
    &lt;img class="avatar" :src="avatarSrc" /&gt;
    &lt;div class="name"&gt;{{ username }}&lt;/div&gt;
    &lt;div class="userId"&gt;{{ userId }}&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="post" v-text="post"&gt;&lt;/div&gt;
  &lt;button
    </span><strong class="old"><span class="koboSpan" id="kobo.289.1">v-show="comments.length &gt; 0"</span></strong><span class="koboSpan" id="kobo.290.1">
    @click="onShowCommentClick"
  &gt;
    Show Comments
  &lt;/button&gt;
  &lt;SocialPostComments
    v-if="showComments"
    :comments="comments"
  /&gt;
&lt;/div&gt;
&lt;/template&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.291.1">From the</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.292.1"> preceding code, we can see that the logic associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">v-show</span></strong><span class="koboSpan" id="kobo.294.1"> directive has been highlighted. </span><span class="koboSpan" id="kobo.294.2">This is our best candidate to be turned into a </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">computed property.</span></span></p>
			<p><span class="koboSpan" id="kobo.296.1">Computed properties need to return a value that depends on another value and has no side effect, and the preceding highlighted logic does just that. </span><span class="koboSpan" id="kobo.296.2">In fact, it returns a boolean of </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">true</span></strong><span class="koboSpan" id="kobo.298.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">false</span></strong><span class="koboSpan" id="kobo.300.1">, it depends on the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">comments</span></strong><span class="koboSpan" id="kobo.302.1">, and it does nothing else that can be defined as a </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">side effect.</span></span></p>
			<p><span class="koboSpan" id="kobo.304.1">Just like methods, to be able to convert this logic into a computed property, we need to move its logic into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.306.1"> tag of our component. </span><span class="koboSpan" id="kobo.306.2">Let’s see the steps required to </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">achieve this:</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.308.1">First, we need to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">computed</span></strong><span class="koboSpan" id="kobo.310.1"> at the top of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">script&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.313.1"> tag:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.314.1">
import { onMounted, ref, </span><strong class="old"><span class="koboSpan" id="kobo.315.1">computed </span></strong><span class="koboSpan" id="kobo.316.1">} from 'vue';</span></pre></li>
				<li><span class="koboSpan" id="kobo.317.1">Then, we create a function that uses a </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">computed property:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.319.1">
const hasComments = computed( );</span></pre></li>
				<li><span class="koboSpan" id="kobo.320.1">Next, we are going to add our logic as the first argument of the computed method as </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">a callback:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.322.1">
const hasComments = computed(</span><strong class="old"><span class="koboSpan" id="kobo.323.1">() =&gt; {</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.324.1">  return props.comments.length &gt; 0;</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.325.1">}</span></strong><span class="koboSpan" id="kobo.326.1">);</span></pre></li>
				<li><span class="koboSpan" id="kobo.327.1">Last, we replace the existing logic in the HTML with the new </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">computed property:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.329.1">
&lt;button</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.330.1">
  v-show="</span><strong class="old"><span class="koboSpan" id="kobo.331.1">hasComments</span></strong><span class="koboSpan" id="kobo.332.1">"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.333.1">
  @click="onShowCommentClick"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.334.1">
&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.335.1">
  Show Comments</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.336.1">
&lt;/button&gt;</span></pre></li>
			</ol>
			<p><span class="koboSpan" id="kobo.337.1">With </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.338.1">the preceding code, we have now created a new property within our component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">hasComments</span></strong><span class="koboSpan" id="kobo.340.1">. </span><span class="koboSpan" id="kobo.340.2">This property, just like every other Vue.js variable, is responsive and will change as soon as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">comments</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.342.1">array changes.</span></span></p>
			<h3><span class="koboSpan" id="kobo.343.1">Increasing performance with cached values</span></h3>
			<p><span class="koboSpan" id="kobo.344.1">Creating</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.345.1"> computed properties not only improves the readability of our component but also improves the performance of our application by caching </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">the value.</span></span></p>
			<p><span class="koboSpan" id="kobo.347.1">What this means is that the actual function included within the computed property just gets run once, when the component mounts, but it does not run again when the component renders unless the dependent </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">value changes.</span></span></p>
			<p><span class="koboSpan" id="kobo.349.1">This may not bring a massive improvement to our simple example, but it does make a big difference in large applications where the computed property could actually be a large array with 100s </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">of entries!</span></span></p>
			<h3><span class="koboSpan" id="kobo.351.1">Formatting your data</span></h3>
			<p><span class="koboSpan" id="kobo.352.1">Computed properties</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.353.1"> are not very common among other major frameworks and they are seen as a new technique/feature for most Vue.js developers. </span><span class="koboSpan" id="kobo.353.2">Due to their unique nature, it can be hard at times to grasp and use them in real life. </span><span class="koboSpan" id="kobo.353.3">To ensure that the topic has been fully understood, we are going to create a couple of extra examples that make use of </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">computed properties.</span></span></p>
			<p><span class="koboSpan" id="kobo.355.1">If you open the file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">TheWelcome.vue</span></strong><span class="koboSpan" id="kobo.357.1"> and check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">posts</span></strong><span class="koboSpan" id="kobo.359.1"> Reactive value, you will notice that there are extra parameters in the object. </span><span class="koboSpan" id="kobo.359.2">In fact, the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">likes</span></strong><span class="koboSpan" id="kobo.361.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">retweets</span></strong><span class="koboSpan" id="kobo.363.1"> has been added to </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">our posts.</span></span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<span class="koboSpan" id="kobo.365.1"><img src="image/B21130_05_02.jpg" alt="Figure 5.2: The posts Reactive property including extra likes and retweets entries"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.366.1">Figure 5.2: The posts Reactive property including extra likes and retweets entries</span></p>
			<p><span class="koboSpan" id="kobo.367.1">In this section, we are going to create a new dynamic property that will hold the total number of interactions. </span><span class="koboSpan" id="kobo.367.2">We are going to do so by adding all the different interactions, including comments, likes, </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">and </span></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">retweets.</span></span></p>
			<p><span class="koboSpan" id="kobo.370.1">This new </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.371.1">computed property will be called </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">interactions</span></strong><span class="koboSpan" id="kobo.373.1">, and in the case in which our post has 2 comments, 2 likes, and 1 retweet, it will return a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">5</span></strong><span class="koboSpan" id="kobo.375.1"> (2 + 2 + </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">1).</span></span></p>
			<p><span class="koboSpan" id="kobo.377.1">This example should help you understand that the computed property is not just a way to prettify your component, but is actually a powerful tool that helps you enhance the features of </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">your application.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.379.1">Give it a try</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.380.1">Why don’t you give it a try and attempt to create the computed property by yourself? </span><span class="koboSpan" id="kobo.380.2">Creating this computed property will require you to put into practice everything you learned until now, so why not take a </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">little challenge?</span></span></p>
			<p><span class="koboSpan" id="kobo.382.1">Successfully creating a computed property to display our interaction requires a couple of steps. </span><span class="koboSpan" id="kobo.382.2">The following diagram shows how the data flows through the component, and it will help contextualize the steps we will have to take to fully define our </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">computed property.</span></span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<span class="koboSpan" id="kobo.384.1"><img src="image/B21130_05_03_BW.jpg" alt="Figure 5.3: Data flow from the parent component to the computed property"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.385.1">Figure 5.3: Data flow from the parent component to the computed property</span></p>
			<p><span class="koboSpan" id="kobo.386.1">Throughout </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.387.1">this book, we have already covered each of the preceding entries, but this will be the first time that we are using them all together in one single exercise. </span><span class="koboSpan" id="kobo.387.2">Generating a full data flow like this will be very common in your development life, so it is beneficial to get some </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">early practice.</span></span></p>
			<p><span class="koboSpan" id="kobo.389.1">Let’s go over the preceding data flow one step at </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">a time:</span></span></p>
			<ol>
				<li> <strong class="old"><span class="koboSpan" id="kobo.391.1">Set data in the </span></strong><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.392.1">parent component</span></strong></span><p class="list-inset"><span class="koboSpan" id="kobo.393.1">Let’s open TheWelcome.vue and check the parameters available in the posts Reactive within the &lt;</span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">script&gt;</span></span><span class="No-Break"><span class="koboSpan" id="kobo.395.1"> tag:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.396.1">
{ username: "Username one",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.397.1">
  userId: "usernameId1",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.398.1">
  avatar: "https://i.pravatar.cc/40",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.399.1">
  post: "This is my post",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.400.1">
  comments: [</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.401.1">
    "great post",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.402.1">
    "amazing post"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.403.1">
  ],</span></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.404.1">  likes: 2,</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.405.1">  retweets: 1,</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.406.1">
  tags: [</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.407.1">
    "tag 1"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.408.1">
  ]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.409.1">
  }</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.410.1">As shown</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.411.1"> in the preceding code, the properties of likes and retweets are already set </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">for us.</span></span></p></li>
				<li><strong class="old"><span class="koboSpan" id="kobo.413.1">The new properties are added to the instance of the </span></strong><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.414.1">child component</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.416.1">As explained in a previous chapter, a component requires properties to be passed to it, before it can use them. </span><span class="koboSpan" id="kobo.416.2">So, in our case, we need to add the new likes and retweets properties to the instances </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">of &lt;SocialPost&gt;:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.418.1">
&lt;SocialPost</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.419.1">
:username="posts[0].username"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.420.1">
:userId="posts[0].userId"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.421.1">
:avatarSrc="posts[0].avatar"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.422.1">
:post="posts[0].post"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.423.1">
:comments="posts[0].comments"</span></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.424.1">:likes="posts[0].likes"</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.425.1">:retweets="posts[0].retweets"</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.426.1">
&gt;&lt;/SocialPost&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.427.1">The preceding example shows how you can add it to the first entry and how you can replicate the same for the </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">second one.</span></span></p></li>
				<li><strong class="old"><span class="koboSpan" id="kobo.429.1">The new properties are read by the child component </span></strong><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.430.1">using definedProps:</span></strong></span><p class="list-inset"><span class="koboSpan" id="kobo.431.1">To achieve </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.432.1">this step, we need to open the SocialPost.vue file and add the new properties of likes and retweets in the list of definedProps. </span><span class="koboSpan" id="kobo.432.2">These are both going to be </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">Number types:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.434.1">
const props = defineProps({</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.435.1">
  username: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.436.1">
  userId: Number,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.437.1">
  avatarSrc: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.438.1">
  post: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.439.1">
  comments: Array,</span></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.440.1">  likes: Number,</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.441.1">  retweets: Number,</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.442.1">
});</span></pre></li>
				<li><strong class="old"><span class="koboSpan" id="kobo.443.1">Create a new computed property that uses the </span></strong><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.444.1">new properties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.446.1">The computed function is going to use the newly created properties and create a new dynamic property </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">called interactions:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.448.1">
const interactions = computed( ()=&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.449.1">
  const comments = props.comments.length;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.450.1">
  return comments + props.likes + props.retweets;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.451.1">
});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.452.1">Just like every computed property, our preceding function creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">interactions</span></strong><span class="koboSpan" id="kobo.454.1"> value using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">computed()</span></strong><span class="koboSpan" id="kobo.456.1"> function and returns a value, which, in our case, is the sum of </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">different properties.</span></span></p></li>
				<li><span class="koboSpan" id="kobo.458.1">The</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.459.1"> computed value is added </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">&lt;template&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.463.1">
&lt;div class="interactions"&gt;Interactions: {{ interactions }}&lt;/div&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.464.1">Here, we used our knowledge of string interpolation to print the value of interactions within </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">the component.</span></span></p></li>
				<li><strong class="old"><span class="koboSpan" id="kobo.466.1">Style </span></strong><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.467.1">the HTML</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.469.1">The last step requires us to style the HTML. </span><span class="koboSpan" id="kobo.469.2">This can be done by using plain CSS within the &lt;style&gt; tag of </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">our component:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.471.1">
.interactions {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.472.1">
  font-weight: bold;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.473.1">
  margin-top: 8px;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.474.1">
}</span></pre></li>
			</ol>
			<p><span class="koboSpan" id="kobo.475.1">After following the steps defined previously, our new property for </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">interactions</span></strong><span class="koboSpan" id="kobo.477.1"> is fully set up and available within our companion application, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">following screenshot.</span></span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<span class="koboSpan" id="kobo.479.1"><img src="image/B21130_05_04.jpg" alt="Figure 5.4: Companion application screenshot showing interactions"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.480.1">Figure 5.4: Companion application screenshot showing interactions</span></p>
			<p><span class="koboSpan" id="kobo.481.1">Computed properties </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.482.1">will be a vital part of your Vue.js application and it is vital to understand when you should use them and how to </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">use them.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.484.1">Your turn</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.485.1">Try to create your own computed property. </span><span class="koboSpan" id="kobo.485.2">Open up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">TheHeader.vue</span></strong><span class="koboSpan" id="kobo.487.1"> file and try to replace the current implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">Welcome {{ username }}</span></strong><span class="koboSpan" id="kobo.489.1"> with a new computed property </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">welcomeMessage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.493.1">In this section, we learned how to enhance our components by creating dynamic properties using computed properties. </span><span class="koboSpan" id="kobo.493.2">We have explained the three factors that make a computed property, which are as follows: it produces no side effect, creates a new variable, and depends on other component variables. </span><span class="koboSpan" id="kobo.493.3">Finally, we went over two different coding exercises to better understand the meaning and usage of </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">computed properties.</span></span></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.495.1">Learning the difference between methods and computed properties</span></h1>
			<p><span class="koboSpan" id="kobo.496.1">During my career, I </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.497.1">have seen many people misusing methods and computed properties. </span><span class="koboSpan" id="kobo.497.2">In this section, we are going to clarify the difference between the two features and provide you with a guide that you can revisit during the course of your </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">early career.</span></span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.499.1">Technical differences</span></h2>
			<p><span class="koboSpan" id="kobo.500.1">It may be a </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.501.1">good starting point to re-iterate what we discussed in the previous two sections and see side by side what </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.502.1">the</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.503.1"> technical differences are between these two </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">Vue.js features:</span></span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<span class="koboSpan" id="kobo.505.1"><img src="image/B21130_05_05_BW.jpg" alt="Figure 5.5: A table showing the technical differences between methods and computed properties"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.506.1">Figure 5.5: A table showing the technical differences between methods and computed properties</span></p>
			<p><span class="koboSpan" id="kobo.507.1">Let’s focus on some of the main differences displayed in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.508.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.509.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">:</span></span></p>
			<ul>
				<li><strong class="old"><span class="koboSpan" id="kobo.511.1">Time of initialization</span></strong><span class="koboSpan" id="kobo.512.1">: Methods can be initialized on demand by the user, while computed properties are triggered during the component creation </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">life cycle.</span></span></li>
				<li><strong class="old"><span class="koboSpan" id="kobo.514.1">Parameters and dependencies</span></strong><span class="koboSpan" id="kobo.515.1">: While methods can accept parameters, computed properties can just use other component props and data that are </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">called dependencies.</span></span></li>
				<li><strong class="old"><span class="koboSpan" id="kobo.517.1">Evaluation</span></strong><span class="koboSpan" id="kobo.518.1">: Methods </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.519.1">are evaluated every time they are called, making them very expensive, while computed properties are cached and just re-evaluated if any of their dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">are updated.</span></span></li>
				<li><strong class="old"><span class="koboSpan" id="kobo.521.1">Side effect</span></strong><span class="koboSpan" id="kobo.522.1">: Side</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.523.1"> effects occur when a method or a function modifies a value or triggers an action outside of its local scope. </span><span class="koboSpan" id="kobo.523.2">So, for example, triggering an API call is a side effect, or changing a variable that is not returned by the method is a </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">side effect.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.525.1">The </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.526.1">goal of a computed property is to create a new variable and it should never include any side effect, while the main scope of methods is to produce </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">side effects.</span></span></p>
			<p><span class="koboSpan" id="kobo.528.1">If someone were asked to define the difference between computed properties and methods in a single sentence, I would say </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">the following:</span></span></p>
			<p><span class="koboSpan" id="kobo.530.1">Methods are helper functions that allow you to complete an action, while computed properties allow you to create a new </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">component property.</span></span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.532.1">How to spot them in your component</span></h2>
			<p><span class="koboSpan" id="kobo.533.1">In the previous </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.534.1">section, we spoke about the technical differences between methods and computed properties, while in this section we will see where we would find these helpers within </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">a component.</span></span></p>
			<p><span class="koboSpan" id="kobo.536.1">Knowing where computed properties and methods are used within the component structure will help you make the correct choice. </span><span class="koboSpan" id="kobo.536.2">To better see whether we can make the correct choice, we are going to use a dummy component. </span><span class="koboSpan" id="kobo.536.3">This component has a few placeholders delimited </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">???</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.540.1">Spend a couple of minutes to try and understand whether this is going to be methods or computed properties and why you have made this choice. </span><span class="koboSpan" id="kobo.540.2">When you are ready, you can read my explanation</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.541.1"> and see whether it matches </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">your choices:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.543.1">
&lt;script setup&gt;
import { reactive } from 'vue'
const post = reactive({
  title: '',
  content: '',
showOnlySnippets: true
});
const fetchBlog = </span><strong class="old"><span class="koboSpan" id="kobo.544.1">//???;</span></strong><span class="koboSpan" id="kobo.545.1">
const onShowAll = </span><strong class="old"><span class="koboSpan" id="kobo.546.1">//???;</span></strong><span class="koboSpan" id="kobo.547.1">
const snippets = </span><strong class="old"><span class="koboSpan" id="kobo.548.1">//???;</span></strong><span class="koboSpan" id="kobo.549.1">
onMounted(() =&gt; {
  fetchBlog();
} );
&lt;/script&gt;
&lt;template&gt;
  &lt;h1&gt;{{ post.title }}&lt;/h1&gt;
  &lt;p v-if="post.showOnlySnippets"&gt;{{ snippets }}&lt;/p&gt;
  &lt;p v-else&gt;{{ post.content }}&lt;/p&gt;
  &lt;button @click="onShowAll" &gt;Show All&lt;/button&gt;
&lt;/template&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.550.1">The first placeholder is </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">fetchBlog</span></strong><span class="koboSpan" id="kobo.552.1">. </span><span class="koboSpan" id="kobo.552.2">This is going to be a method. </span><span class="koboSpan" id="kobo.552.3">The decision is based on the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">fetchBlog</span></strong><span class="koboSpan" id="kobo.554.1"> is not only going to trigger a side effect, contacting an external API, but it is also called in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">onMounted</span></strong><span class="koboSpan" id="kobo.556.1"> life cycle. </span><span class="koboSpan" id="kobo.556.2">As we previously defined, only methods can be triggered </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">on demand.</span></span></p>
			<p><span class="koboSpan" id="kobo.558.1">The second one is </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">onShowAll</span></strong><span class="koboSpan" id="kobo.560.1">. </span><span class="koboSpan" id="kobo.560.2">This is going to run an action, something that will be triggered when the user clicks a button. </span><span class="koboSpan" id="kobo.560.3">Again, in this instance, we are going to define this as a method because it is triggered by an event, will include a side effect, and will </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">accept parameters.</span></span></p>
			<p><span class="koboSpan" id="kobo.562.1">Lastly, we</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.563.1"> have </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">snippets</span></strong><span class="koboSpan" id="kobo.565.1">. </span><span class="koboSpan" id="kobo.565.2">This variable is used in the template just like a variable. </span><span class="koboSpan" id="kobo.565.3">As we should know by now, creating dynami</span><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.566.1">c variables is the perfect match for a computed property. </span><span class="koboSpan" id="kobo.566.2">In this instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">snippets</span></strong><span class="koboSpan" id="kobo.568.1"> is going to be a computed property that will depend on the </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">blog content.</span></span></p>
			<p><span class="koboSpan" id="kobo.570.1">Let’s see what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">updates</span></strong><span class="koboSpan" id="kobo.572.1"> script may </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">look like:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.574.1">
&lt;script setup&gt;
import { reactive } from 'vue'
const post = reactive({
  title: '',
  content: '',
  showOnlySnippets: true
});
const fetchBlog = </span><strong class="old"><span class="koboSpan" id="kobo.575.1">() =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.576.1">  fetch('fakeApi.com').then( result =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.577.1">    post.title = result.title;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.578.1">    post.content = result.content;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.579.1">  } );</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.580.1">}</span></strong><span class="koboSpan" id="kobo.581.1">;
const onShowAll = </span><strong class="old"><span class="koboSpan" id="kobo.582.1">(event) =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.583.1">  post.showOnlySnippets = false;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.584.1">}</span></strong><span class="koboSpan" id="kobo.585.1">;
const snippets = computed( </span><strong class="old"><span class="koboSpan" id="kobo.586.1">() =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.587.1">  return post.content.slice(0, 100);</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.588.1">}</span></strong><span class="koboSpan" id="kobo.589.1"> );
onMounted(() =&gt; {
  fetchBlog();
} );
&lt;/script&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.590.1">With all the </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.591.1">examples we have covered so far, you should have obtained a good understanding of these two </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">different features.</span></span></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.593.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.594.1">In this chapter, we have introduced methods and used them to clean up the components of our Companion App. </span><span class="koboSpan" id="kobo.594.2">We learned the difference between Refs and Reactive and learned how to use them within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.596.1"> section of components, and then we moved forward and learned how to create dynamic properties using computed properties. </span><span class="koboSpan" id="kobo.596.2">To complete the chapter, we fortified our knowledge of these two topics by going over a few </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">more examples.</span></span></p>
			<p><span class="koboSpan" id="kobo.598.1">In the next chapter, we are going to learn how to create and manage events using Vue event handling. </span><span class="koboSpan" id="kobo.598.2">Up until now, we have focused on the individual components, but with the introduction of events and events handling, we will be able to define two-way communication between components. </span><span class="koboSpan" id="kobo.598.3">Event propagation is an essential skill to have to be able to develop scalable and clear </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">component-based applications.</span></span></p>
		</div>
	</body></html>