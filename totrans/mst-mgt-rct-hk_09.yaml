- en: '*Chapter 6*: Introducing Global State Libraries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned about several patterns used to share state among components
    so far. The rest of this book will introduce various global state libraries that
    use such patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into the libraries, we will recap the challenges associated with
    global states and discuss two aspects of libraries: where the state resides and
    how to control re-renders. With this in hand, we will be able to understand the
    characteristics of global state libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with global state management issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the data-centric and component-centric approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing re-renders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are expected to have moderate knowledge of React, including React hooks.
    Refer to the official site at [https://reactjs.org](https://reactjs.org) to learn
    more.
  prefs: []
  type: TYPE_NORMAL
- en: To run the code snippets, you need a React environment, for example, Create
    React App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  prefs: []
  type: TYPE_NORMAL
- en: Working with global state management issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is designed around the concept of components. In the component model,
    everything is expected to be reusable. Global state is something that exists outside
    of components. It's often true that we should avoid using a global state where
    possible because it requires an extra dependency on a component. However, a global
    state is sometimes very handy and allows us to be more productive. For some app
    requirements, global state fits well.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two challenges when designing a global state:'
  prefs: []
  type: TYPE_NORMAL
- en: The first challenge is how to read a global state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global state tends to have multiple values. It's often the case that a component
    using a global state doesn't need all the values in it. If a component re-renders
    when a global state is changed but the changed values are not relevant to the
    component, it's an extra re-render. Extra re-renders are not desirable, and global
    state libraries should provide a solution for them. There are several approaches
    to avoiding extra re-renders, and we will discuss them in more detail in the *Optimizing
    re-renders* section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second challenge is how to write or update a global state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, global state is likely to have multiple values, some of which may be
    nested objects. It might not be a good idea to have a single global variable and
    accept arbitrary mutations. The following code block shows an example of a global
    variable and one arbitrary mutation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The mutation `globalVariable.b.d = 9` in the example may not work for a global
    state because there's no way to detect the change and trigger React components
    to re-render.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To have more control over how to write a global state, we often provide functions
    to update a global state. It''s also often necessary to hide a variable in a closure
    so that the variable can''t be mutated directly. The following code block shows
    an example of creating two functions for reading and writing a variable in a closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `createContainer` function creates `globalContainer`, which holds `getState`
    and `setState` functions. `getState` is a function to read a global state and
    `setState` is a function to update a global state. There are several ways to implement
    functions such as `setState` to update a global state. We will look at concrete
    examples in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Global versus General State Management
  prefs: []
  type: TYPE_NORMAL
- en: This book focuses on *global* state management; *general* state management is
    out of scope. In the field of general state management, popular approaches include
    the one-way data flow approach, as in Redux ([https://redux.js.org](https://redux.js.org)),
    and the state machine-based approach, as in XState ([https://xstate.js.org](https://xstate.js.org)).
    General state management approaches are useful not only for a global state but
    also for a local state.
  prefs: []
  type: TYPE_NORMAL
- en: Notes about Redux and React Redux
  prefs: []
  type: TYPE_NORMAL
- en: Redux has been a big player in a global state management. Redux solves state
    management with one-way data flow with a global state in mind. However, Redux
    itself has nothing to do with React. It's React Redux ([https://react-redux.js.org](https://react-redux.js.org))
    that binds React and Redux. While Redux itself doesn't have a capability or a
    notion to avoid extra re-renders, React Redux has such a capability.
  prefs: []
  type: TYPE_NORMAL
- en: Because Redux and React Redux were so popular, some people overused them in
    the past. This was due to the lack of React Context before React 16.3, and there
    were no other popular options. Such people (mis-)used React Redux mainly for (legacy)
    Context, without needing the one-way data flow. With React Context since React
    16.3 and the `useContext` hook since React 16.8, we can easily solve use cases
    to avoid prop drilling and extra re-renders. That brings us to microstate management
    â€“ our focus in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, technically speaking, React Redux minus Redux is within the scope of
    this book. Redux itself is a great solution for general state management, and
    along with React Redux, it solves the global state issues we discussed in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the general challenges when it comes to global
    state libraries. Next up, we will learn about where state resides.
  prefs: []
  type: TYPE_NORMAL
- en: Using the data-centric and component-centric approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Global state can technically be divided into two types: data-centric and component-centric.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will discuss both these approaches in detail.
    Then, we will also talk about some exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the data-centric approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you design an app, you may have a data model as a singleton in your app
    and you may already have the data to deal with. In this case, you would define
    components and connect the data and the components. The data can be changed from
    the outside, such as by other libraries or from other servers.
  prefs: []
  type: TYPE_NORMAL
- en: For the data-centric approach, module state would fit better, because module
    state resides in JavaScript memory outside React. Module state can exist before
    React starts rendering or even after all React components are unmounted.
  prefs: []
  type: TYPE_NORMAL
- en: Global state libraries using the data-centric approach would provide APIs to
    create module state and to connect the module state to React components. Module
    state is usually wrapped in a `store` object, which has methods to access and
    update a `state` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the component-centric approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the data-centric approach, with the component-centric approach, you can
    design components first. At some point, some components may need to access shared
    information. As we discussed in the *Effectively using local states* section in
    [*Chapter 2*](B17780_02_Final_VK_ePub.xhtml#_idTextAnchor035), *Using Local and
    Global States*, we can lift state and pass it down with props (a.k.a. prop drilling).
    If prop drilling won't work as a solution, that's when we can introduce a global
    state. Certainly, we can start by designing a data model first, but in the component-centric
    approach, the data model is fairly tied to components.
  prefs: []
  type: TYPE_NORMAL
- en: For the component-centric approach, component state, which holds a global state
    in the component lifecycle, fits better. This is because when all the corresponding
    components are unmounted, a global state is gone too. This capability allows us
    to have two or more global states that exist in JavaScript memory because they
    are in different component subtrees (or different portals).
  prefs: []
  type: TYPE_NORMAL
- en: Global state libraries using a data-centric approach provide a factory function
    to create functions that initialize a global state for use in React components.
    A factory function doesn't directly create a global state, but by using the generated
    functions, we let React handle a global state lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the exceptions of both approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we have described are typical use cases, and there are always some exceptions.
    The data-centric approach and the component-centric approach are not really two
    sides of the same coin. In reality, you can use one of two approaches or a hybrid
    of the two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Module state is often used as a singleton pattern, but you can create multiple
    module states for subtrees. You can even control the lifecycles of them.
  prefs: []
  type: TYPE_NORMAL
- en: Component state is often used to provide a state in a subtree, but if you put
    the provider component at the root of the tree and there's only one tree in JavaScript
    memory, it can be treated like a singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Component state is often implemented with the `useState` hook, but if we need
    to have a mutable variable or `store`, an implementation with the `useRef` hook
    is possible. The implementation might be more complicated than using `useState`,
    but it still comes under the component lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about two approaches for using a global state. Module
    state is mainly for use with the data-centric approach, and component state is
    mainly for use with the component-centric approach. Next, we will learn about
    several patterns to optimize re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing re-renders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Avoiding extra re-renders is a major challenge when it comes to a global state.
    This is a big point to consider when designing a global state library for React.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, a global state has multiple properties, and they can be nested objects.
    See the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With this `state` object, let''s assume two components `ComponentA` and `ComponentB`,
    which use `state.b.c` and `state.e.g`, respectively. The following is pseudocode
    of the two components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s suppose we change `state` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This changes the `a` property of `state`, but it doesn't change either `state.b.c`
    or `state.e.g`. In this case, the two components don't need to re-render.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of optimizing re-renders is to specify which part of `state` is used
    in a component. We have several approaches to specify the part of `state`. This
    section describes three approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a selector function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting property access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atoms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss each of these now.
  prefs: []
  type: TYPE_NORMAL
- en: Using a selector function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One approach is using a selector function. A selector function takes a `state`
    variable and returns a part of the `state` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose we have a `useSelector` hook that takes a selector
    function and returns part of `state`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If `state.b.c` is `2`, then `Component` will show `2`. Now that we know that
    this component cares only about `state.b.c`, we can avoid extra re-renders only
    when `state.a` is changed.
  prefs: []
  type: TYPE_NORMAL
- en: '`useSelector` will be used to compare the selector function''s result every
    time `state` is changed. Hence, it''s important that the selector function returns
    the referentially equal result when given the same input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The selector function is so flexible that it can return not only a part of
    `state`, but also any derived value. For example, it can return a doubled value,
    like here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A Note about Selector and Memoization
  prefs: []
  type: TYPE_NORMAL
- en: If a value returned by the selector function is a primitive value such as a
    number, there are no issues. However, if the selector function returns a derived
    object value, we need to make sure to return a referentially equal object with
    the so-called memoization technique. You can read more about memoization at [https://en.wikipedia.org/wiki/Memoization](https://en.wikipedia.org/wiki/Memoization).
  prefs: []
  type: TYPE_NORMAL
- en: As a selector function is a means to explicitly specify which part of a component
    will be used, we call this a manual optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting property access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can we do render optimization automatically, without using a selector function
    to explicitly specify which part of a state is to be used in a component? There
    is something called state usage tracking, which is used to detect property access
    and use the detected information for render optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose we have a `useTrackedState` hook that has the state
    usage tracking capability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This works as `trackedState` can detect that the `.b.c` property is accessed,
    and `useTrackedState` only triggers re-renders when the `.b.c` property value
    is changed. This is automatic render optimization, whereas `useSelector` is manual
    render optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, the previous code block example is contrived. This example
    can easily be implemented with `useSelector`, the manual render optimization.
    Let''s look at another example using two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, this is surprisingly difficult to implement with a single `useSelector`
    hook. If we were to write a selector, it would require memoization or a custom
    equality function, which are complicated techniques. However, if we use `useTrackedState`,
    it works without such complicated techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `useTrackedState` requires Proxy ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy))
    to trap the property access to the `state` object. If this is implemented properly,
    it can replace most use cases of `useSelector` and can do the automatic render
    optimization. However, there's a subtle case where the automatic render optimization
    doesn't work perfectly. Let's take a closer look in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between useSelector and useTrackedState
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some use cases in which `useSelector` works better than `useTrackedState`.
    Because `useSelector` can create any derived values, it can derive state into
    simpler values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between the working of `useSelector` and `useTrackedState` can
    be seen with the help of a simple example. The following is an example component
    with `useSelector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to create the same component with `useTrackedState`, it would be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Functionality-wise, this component with `useTrackedState` works fine, but it
    will trigger re-renders every time `state.a` is changed. On the contrary, with
    `useSelector`, it will trigger re-renders only when `isSmall` is changed, which
    means it's better render optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Using atoms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's another approach, which we call using atoms. An atom is a minimal unit
    of state used to trigger re-renders. Instead of subscribing to the whole global
    state and trying to avoid extra re-renders, atoms allow you to subscribe granularly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose we have a `useAtom` hook that only subscribes to
    an atom. An `atom` function would create such a unit (that is, `atom`) of a `state`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If atoms are completely separated, it''s almost equivalent to having separate
    global states. However, we could create a derived value with atoms. For example,
    say we would like to sum the `globalState` values. The pseudocode would be the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To make this work, we need to track the dependency and re-evaluate the derived
    value when a dependency atom is updated. We will look closely at how such an API
    is implemented in [*Chapter 8*](B17780_08_Final_VK_ePub.xhtml#_idTextAnchor100),
    *Use Case Scenario 2 â€“ Jotai*.
  prefs: []
  type: TYPE_NORMAL
- en: The approach using atoms can be seen as something between a manual approach
    and an automatic approach. While the definition of atoms and derived values is
    explicit (manual), the dependency tracking is automatic.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the various patterns for optimizing re-renders.
    It's important for a global state library to design how to optimize re-renders.
    It often affects the library API, and understanding how to optimize re-renders
    is also worthwhile for library users.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, before diving into the actual implementation of global state
    libraries, we learned about some basic challenges associated with it, and some
    categories to differentiate global state libraries. When choosing a global state
    library, we can see how the library lets us read a global state and write a global
    state, where the library stores a global state, and how the library optimizes
    re-renders. These are important aspects to understand which libraries work well
    for certain use cases, and they should help you to choose a library that suits
    your needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the Zustand library, a library that
    takes a data-centric approach and optimizes re-renders with selector functions.
  prefs: []
  type: TYPE_NORMAL
