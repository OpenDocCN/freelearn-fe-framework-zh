- en: Some Practical Scenarios
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些实际场景
- en: 'With seven chapters under our belt, you should feel pretty good. What you have
    learned thus far is a direct consequence of the apps we have built in the last
    few chapters. We believe you should now have an adequate understanding of the
    framework, how it works, and what it supports. Armed with this knowledge, as soon
    as we start to build some decent-sized apps, there are some common problems/patterns
    that invariably surface, such as these:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握七个章节之后，你应该感觉相当不错。到目前为止你所学的都是直接来源于我们在前几章中构建的应用。我们相信你现在应该对框架、其工作原理以及它支持的内容有了足够的了解。有了这些知识，当我们开始构建一些规模较大的应用时，一些常见的问题/模式不可避免地会出现，例如这些：
- en: How do we authenticate the user and control his/her access (authorize)?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何验证用户并控制其访问权限（授权）？
- en: How do we make sure that the app is performing well enough?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何确保应用性能足够好？
- en: My app requires localized content. What do I do?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的应用需要本地化内容。我该怎么办？
- en: What tools can I use to expedite app development?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以使用哪些工具来加速应用开发？
- en: I have an AngularJS app. How do I migrate it?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我有一个AngularJS应用。我该如何迁移它？
- en: And some more!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以及更多！
- en: In this chapter, we will try to address such common scenarios and provide some
    working solutions and/or prescriptive guidance to handle such use cases.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试解决这些常见场景，并提供一些可行的解决方案和/或指导性建议来处理这些用例。
- en: 'The topics we will cover in this chapter include:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括：
- en: '**Angular seed projects**: You will learn how some seed projects in Angular
    can help us when starting a new engagement.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular种子项目**：你将学习到一些Angular种子项目如何在开始新的项目时帮助我们。'
- en: '**Authenticating Angular applications**: This is a common requirement. We look
    at how to support cookie- and token-based authentication in Angular.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证Angular应用**：这是一个常见需求。我们来看如何在Angular中支持基于cookie和token的认证。'
- en: '**Angular performance**: A customary performance section is a must as we try
    to detail what makes Angular performant and things you can do to make your apps
    faster.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular性能**：在尝试详细说明是什么使Angular性能良好以及你可以做些什么来使你的应用更快时，一个常规的性能部分是必须的。'
- en: '**Migrating AngularJS apps to Angular**: AngularJS and Angular are altogether
    different beasts. In this chapter, you will learn how to gradually migrate an
    AngularJS app to Angular.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将AngularJS应用迁移到Angular**：AngularJS和Angular是完全不同的东西。在本章中，你将学习如何逐步将AngularJS应用迁移到Angular。'
- en: Let's start at the beginning!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一开始吧！
- en: Building a new app
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建新的应用
- en: 'Imagine a scenario here: we are building a new application and given the super
    awesomeness of the Angular framework, we have unanimously decided to use Angular.
    Great! What next? Next is the mundane process of setting up the project.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景：我们正在构建一个新的应用，鉴于Angular框架的超级强大，我们一致决定使用Angular。太好了！接下来是什么？接下来是设置项目的平凡过程。
- en: 'Although a mundane activity, it''s still a critical part of any engagement.
    Setting up a new project typically involves:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个平凡的活动，但它仍然是任何合作的关键部分。设置新项目通常涉及：
- en: Creating a standard folder structure. This is at times influenced by the server
    framework (such as *RoR*, *ASP.Net*, *Node.js*, and others).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建标准文件夹结构。有时这会受到服务器框架（如*ROR*、*ASP.Net*、*Node.js*等）的影响。
- en: Adding standard assets to specific folders.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标准资产添加到特定文件夹中。
- en: 'Setting up the build, which in the case that, we are developing an Angular-based
    web application, includes:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置构建，如果我们正在开发基于Angular的Web应用，这包括：
- en: Compiling/transpiling content if using TypeScript
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用TypeScript，则编译/转换内容
- en: Configuring the Module loader
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置模块加载器
- en: Dependency management in terms of framework and third-party components
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在框架和第三方组件方面的依赖管理
- en: Setting up unit/E2E testing
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置单元/E2E测试
- en: Configuring builds for different environments such as dev, test, and production.
    Again, this is influenced by the server technology involved.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置不同环境（如开发、测试和生产）的构建。这再次受到所涉及的服务器技术的影响。
- en: Code bundling and minification.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码打包和压缩。
- en: There is a lot of stuff to do.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工作要做。
- en: What if we can short-circuit the overall setup process? This is indeed possible;
    we just need a **seed project** or a **starter site**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以缩短整体设置过程会怎样？这确实可能；我们只需要一个**种子项目**或**启动站点**。
- en: Seed projects
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 种子项目
- en: Angular CLI as a built and scaffolding tool is awesome! But, it is not the only
    option out there. There are a number of *seed projects/starter sites* that can
    get us up and running in no time. Some seed projects integrate the framework with
    a specific backend and some only dictate/provide Angular-specific content. Some
    come preconfigured with vendor-specific libraries/frameworks (such as *LESS*,
    *SASS*, *Bootstrap*, and others), whereas others just provide a plain vanilla
    setup.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 作为构建和脚手架工具非常棒！但是，它并不是唯一的选择。有许多*种子项目/入门网站*可以在短时间内帮助我们开始。一些种子项目将框架与特定的后端集成，而另一些则仅规定/提供Angular特定的内容。一些预先配置了供应商特定的库/框架（如*LESS*、*SASS*、*Bootstrap*等），而另一些则只提供纯
    vanilla 设置。
- en: 'Some of the notable seed projects worth exploring are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得探索的知名种子项目如下：
- en: '**Angular Starter** ([http://bit.ly/ng-starter](http://bit.ly/ng-starter)):
    This seed repo serves as an Angular starter for anyone looking to get up and running
    with Angular and TypeScript fast. It uses Webpack (module bundler) to build our
    files and assist with boilerplate. It''s a complete build system with a substantial
    number of integrations.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular Starter** ([http://bit.ly/ng-starter](http://bit.ly/ng-starter))：这个种子仓库为那些希望快速开始使用
    Angular 和 TypeScript 的人提供了一个 Angular 入门。它使用 Webpack（模块打包器）来构建我们的文件并帮助处理样板代码。它是一个完整的构建系统，具有大量的集成。'
- en: '**Angular Seed** ([http://bit.ly/ng-starter-seed](http://bit.ly/ng-starter-seed)):
    Another seed project similar to Angular Starter. This seed project uses gulp for
    build automation, and the module bundler system is not as advanced as Webpack.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular Seed** ([http://bit.ly/ng-starter-seed](http://bit.ly/ng-starter-seed))：与
    Angular Starter 类似的另一个种子项目。这个种子项目使用 gulp 进行构建自动化，其模块打包系统不如 Webpack 先进。'
- en: These projects along with Angular CLI provide a head start when building with
    Angular.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目以及 Angular CLI 为使用 Angular 进行构建提供了良好的起点。
- en: 'If the app is tied to a specific backend stack, we have two choices, which
    are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序与特定的后端堆栈相关联，我们有两种选择，如下所示：
- en: Use one of these seed projects and integrate it with the backend manually.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些种子项目之一，并手动将其与后端集成。
- en: Find a seed project/implementation that does it for us. There is a good chance
    you will find such seed projects.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到一个为我们完成这项工作的种子项目/实现。有很大机会你会找到这样的种子项目。
- en: Angular performance
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 性能
- en: Angular has been designed with performance in mind. Every part of the framework,
    starting from the framework footprint, initial load time, memory utilization,
    change detection plus data binding, and DOM rendering, has been tweaked or is
    being tweaked for better performance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是以性能为设计理念的。框架的每个部分，从框架占用空间、初始加载时间、内存使用、变更检测加上数据绑定，到DOM渲染，都经过了调整或正在调整以实现更好的性能。
- en: The next few sections are dedicated to understanding how performant Angular
    is and the tricks it uses to achieve some impressive performance gains.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将致力于了解 Angular 的性能以及它用来实现一些令人印象深刻的性能提升的技巧。
- en: Byte size
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节大小
- en: '*The Byte size* of the framework is a good starting point for performance optimization.
    While the world is moving towards high-speed internet, a sizable population among
    us is on a slow connection and are using their mobile to connect to the web. We
    may not think too much about a few KB here or there, but it does matter!'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的*字节大小*是性能优化的良好起点。虽然世界正在向高速互联网发展，但我们中相当一部分人仍然在使用慢速连接，并通过手机连接到网络。我们可能不会太在意这里或那里的几KB，但这确实很重要！
- en: While the byte size of Angular out of the box is bigger than AngularJS, there
    are techniques that can drastically reduce the size of an Angular bundle.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Angular的默认字节大小比AngularJS大，但有一些技术可以大幅减少Angular打包的大小。
- en: To start with, the standard techniques of *minification* and *gzipping* can
    reduce this gap substantially. And with Angular, we can do some nifty tricks with
    *module bundler/loaders* to reduce the Angular bundle size even more.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，标准的压缩和gzip压缩技术可以显著减少这个差距。并且，在 Angular 中，我们可以通过使用*模块打包器/加载器*来执行一些巧妙的技巧，进一步减少
    Angular 打包的大小。
- en: '**Tree shaking** may be a quirky name for a process, but it literally does
    what it says! As we build apps using TypeScript (or ES2015), containing *modules*
    and *exports*, a module bundler such as *Rollup* ([http://rollupjs.org](http://rollupjs.org))
    can perform static code analysis on such code, determine what parts of the code
    are never used, and remove them before bundling the release bits. Such module
    bundlers, when added to the app''s build process, can analyze the framework bit,
    any third-party library, and the app code to remove any dead code before creating
    bundles. *Tree shaking can result in enormous size reduction as you don''t bundle
    framework bits that you don''t use.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**摇树**可能是一个古怪的过程名称，但它确实做到了它所说的！当我们使用 TypeScript（或 ES2015）构建应用程序，包含 *模块* 和 *导出*
    时，模块打包器（如 *Rollup* ([http://rollupjs.org](http://rollupjs.org)））可以对这样的代码进行静态代码分析，确定代码中哪些部分从未使用过，并在打包发布前将其删除。这样的模块打包器，当添加到应用程序的构建过程中时，可以分析框架代码、任何第三方库和应用程序代码，在创建包之前删除任何死代码。*摇树可以导致巨大的尺寸缩减，因为你不会打包你不使用的框架代码。*'
- en: One of the biggest framework pieces that can be removed from the framework bundle
    is the *compiler*. Yes, you read right, it's the compiler!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从框架包中移除的最大框架组件之一是 *编译器*。是的，你没听错，就是编译器！
- en: For curious readers, the compiler is the single biggest framework piece, contributing
    roughly 50% in size to the Angular bundle (In Angular *v2.0.0*).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的读者，编译器是最大的框架组件，大约占 Angular 包大小的 50%（在 Angular *v2.0.0* 中）。
- en: Using tree shaking together with **Ahead-of-Time** (**AoT**) compilation, we
    can just get rid of the Angular compiler (in the browser) altogether.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 结合使用摇树和 **提前编译**（**AoT**），我们可以完全去除浏览器中的 Angular 编译器。
- en: With AoT compilation, the view templates (HTML) are compiled beforehand on the
    server side. This compilation again is done as part of the app's build process
    where a server version of the Angular compiler (a node package) compiles every
    view in the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AoT 编译，视图模板（HTML）在服务器端预先编译。这次编译作为应用程序构建过程的一部分进行，其中服务器版本的 Angular 编译器（一个节点包）编译应用程序中的每个视图。
- en: With all the templates compiled, there is no need to send the Angular compiler
    bits to the client side at all. Tree shaking can now just get rid of the compiler
    and create a far slimmer framework package. Angular CLI supports AoT compilation
    and can be used for production builds.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有模板编译完成后，就无需将 Angular 编译器代码发送到客户端。现在，摇树可以去除编译器，创建一个更精简的框架包。Angular CLI 支持
    AoT 编译，可用于生产构建。
- en: Read more about AoT in the framework documentation available at [http://bit.ly/ngx-aot](http://bit.ly/ngx-aot).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 AoT 的信息，请参阅框架文档，可在 [http://bit.ly/ngx-aot](http://bit.ly/ngx-aot) 找到。
- en: Initial load time and memory utilization
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始加载时间和内存使用
- en: The initial load time for any web app with a full-fledged JavaScript framework
    is typically slow. This effect is more pronounced on mobile devices, where the
    JavaScript engine may not be as powerful as a desktop client. For a better user
    experience, it becomes imperative that the framework initial load time is optimized,
    especially for mobile devices.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有完整 JavaScript 框架的 Web 应用程序的初始加载时间通常较慢。在移动设备上，这种影响更为明显，因为 JavaScript 引擎可能没有桌面客户端强大。为了提供更好的用户体验，优化框架的初始加载时间变得至关重要，尤其是在移动设备上。
- en: Out of the box, **Angular 2 was five times faster than AngularJS** when it came
    to initial load time and re-rendering the view. These numbers are getting better
    as the Angular team evolves the framework.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**Angular 2 在初始加载时间和视图重渲染方面比 AngularJS 快五倍**。随着 Angular 团队对框架的改进，这些数字正在变得更好。
- en: Further, AoT compilation too can improve the initial load time of the application
    as a time-consuming activity (view compilation) is not required.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，AoT 编译也可以提高应用程序的初始加载时间，因为不需要进行耗时活动（视图编译）。
- en: The same holds true for memory utilization. Angular fares better here too, and
    things will get even better with future releases.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内存使用，这也同样适用。Angular 在这里表现也更好，未来的版本将使事情变得更好。
- en: 'If you are planning to switch to Angular, this is something that you should
    look forward to: a performant framework built for the future.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划切换到 Angular，这是你应该期待的事情：一个为未来构建的高性能框架。
- en: 'The next three performance improvements that we are going to talk about have
    been made possible because of a single architectural decision: *the creation of
    a separate renderer layer*.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的下一个性能改进是由于一个单一架构决策而成为可能的：*创建一个单独的渲染层*。
- en: The Angular rendering engine
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular渲染引擎
- en: The biggest disadvantage of AngularJS was that the framework was tied to the
    browser DOM. The directives, the binding, and the interpolations all worked against
    the DOM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS最大的缺点是框架绑定到浏览器DOM上。指令、绑定和插值都是针对DOM工作的。
- en: 'With Angular, the biggest architectural change that came in was a separate
    rendering layer. Now, an Angular app has two layers:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular，最大的架构变化是引入了一个独立的渲染层。现在，一个Angular应用有两个层：
- en: '**Application layer**: This is the layer our code resides in. It uses an abstraction
    build over the renderer layer to interact with it. The Renderer class we saw in
    Chapter 6, *Angular Directives in Depth*, is the interface that we use to interact
    with the rendering layer.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：这是我们的代码所在的一层。它通过在渲染层之上构建的抽象来与它交互。我们在第6章“深入理解Angular指令”中看到的Renderer类是我们用来与渲染层交互的接口。'
- en: '**Rendering layer**: This layer is responsible for translating requests from
    the application layer into rendered components, and reacting to user input and
    view updates.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染层**：这一层负责将应用层的请求转换为渲染组件，并对用户输入和视图更新做出反应。'
- en: The default renderer implementation for the renderer is `DomRenderer`, which
    runs inside the browser. But there are other rendering abstractions too and we
    will discuss them in the following section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的渲染器实现是`DomRenderer`，它在浏览器内部运行。但还有其他渲染抽象，我们将在下一节中讨论。
- en: Server-side rendering
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: '**Pre-rendering** on the server side is yet another technique for improving
    the initial load time of an Angular app. This technique is really helpful on mobile
    devices, as it improves the perceived load time considerably.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器端预渲染**是提高Angular应用初始加载时间的另一种技术。这项技术在移动设备上特别有帮助，因为它显著提高了感知的加载时间。'
- en: Server-side rendering takes care of the initial page load before client-side
    rendering kicks in (and handles view rendering henceforth).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染负责在客户端渲染启动之前处理初始页面加载（并从此处理视图渲染）。
- en: In such a scenario, when the user requests for a view/page, a piece of software
    on the server generates a fully materialized HTML page with data pre-bound to
    the view and sends it to the client along with a small script. The app view is
    therefore immediately rendered, ready for interaction. While the framework loads
    in the background, the small script that was sent along the first time captures
    all user inputs and makes them available to the framework, allowing it to replay
    the interactions once it is loaded.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当用户请求一个视图/页面时，服务器上的一块软件生成一个完全实例化的HTML页面，其中数据预先绑定到视图，并将其与一小段脚本一起发送到客户端。因此，应用视图可以立即渲染，准备交互。当框架在后台加载时，第一次发送的小脚本捕获所有用户输入，并使它们对框架可用，允许它在加载后重放这些交互。
- en: '**Angular Universal**, as it is touted, allows rendering and sharing of the
    view both on the server and the client side.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular Universal**，正如其名，允许在服务器和客户端上渲染和共享视图。'
- en: Server-side rendering is only made possible because of separation of the rendering
    layer described previously. The initial view is generated by a renderer implementation
    on the server, named `ServerDomRenderer`. There is a Node.js plugin ([http://bit.ly/ng-universal-node](http://bit.ly/ng-universal-node))
    that can be used in a number of node web frameworks such as *Express*, *Hapi*,
    *Sail*, and others.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染之所以成为可能，是因为之前描述的渲染层的分离。初始视图由服务器上的渲染器实现生成，名为`ServerDomRenderer`。有一个Node.js插件（[http://bit.ly/ng-universal-node](http://bit.ly/ng-universal-node)），可以在多个Node.js
    Web框架中使用，如*Express*、*Hapi*、*Sail*等。
- en: Look at the Angular design docs for Angular Universal ([http://bit.ly/ng-universal-design](http://bit.ly/ng-universal-design))
    and the embedded YouTube videos at the top of the design doc to learn more about
    server-side rendering.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Angular Universal的设计文档（[http://bit.ly/ng-universal-design](http://bit.ly/ng-universal-design)）和设计文档顶部的嵌入YouTube视频，以了解更多关于服务器端渲染的信息。
- en: Performance is not the only benefit with server-side rendering. As it turns
    out, search indexers too like pre-rendered HTML content. Server-side rendering
    is really useful in areas such as **search engine optimization (SEO)** and deep
    linking, which allows easy content sharing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染不仅带来了性能上的好处。实际上，搜索引擎索引器也喜欢预渲染的HTML内容。服务器端渲染在搜索引擎优化（SEO）和深度链接等领域非常有用，这允许轻松的内容共享。
- en: Offloading work to a web worker
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将工作卸载到Web Worker
- en: Offloading work to a **web worker** is a neat idea, again made possible due
    to the separation of the rendering layer from the application layer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将工作委托给**web worker**是一个很好的想法，这再次得益于渲染层与应用层之间的分离。
- en: '*Web workers* provide a mechanism for running scripts in background threads.
    These threads can execute work that does not involve the browser DOM. Be it a
    CPU-intensive task or a remote XHR invocation, all can be delegated to web workers.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*Web workers*提供了一种在后台线程中运行脚本的方法。这些线程可以执行不涉及浏览器DOM的工作。无论是CPU密集型任务还是远程XHR调用，都可以委托给web
    workers。'
- en: In today's world, CPUs with multiple cores are the norm, but JavaScript execution
    is still single-threaded. There is a need for a standard/mechanism to utilize
    these idle cores for our apps. Web workers fit the bill perfectly, and since most
    modern browsers support them, we all should be writing code that utilizes web
    workers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今世界，多核CPU已成为常态，但JavaScript执行仍然是单线程的。我们需要一个标准/机制来利用这些空闲核心为我们的应用程序服务。Web workers完美地满足了这一需求，并且由于大多数现代浏览器都支持它们，我们都应该编写利用web
    workers的代码。
- en: 'Sadly, that''s not happening. Web workers are still not mainstream, and there
    are good reasons for that. Web workers impose a good number of restrictions on
    what is allowed and what is not. These limitations include:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，这种情况并没有发生。Web workers仍然不是主流，这有很好的原因。Web workers对允许和不允许的内容施加了许多限制。这些限制包括：
- en: '**No direct access to DOM**: Web workers cannot directly manipulate the DOM.
    In fact, web workers do not have access to multiple globals such as *window* and
    *document*, and others are not available on the web worker thread. This severely
    limits the number of use cases where a web worker can be utilized.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无法直接访问DOM**：Web workers不能直接操作DOM。实际上，web workers无法访问多个全局变量，如*window*和*document*，以及其他在web
    worker线程上不可用。这严重限制了web worker可以使用的用例数量。'
- en: '**Browser support**: Web workers are only available for modern/evergreen browsers
    (IE 10+).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器支持**：Web workers仅适用于现代/持续更新的浏览器（IE 10+）。'
- en: '**Inter-process communication**: Web workers do not share the memory with your
    main browser process, and hence need to communicate with the main thread (UI thread)
    only through *message passing* (serialized data). Adding to that, the message
    passing mechanism is asynchronous in nature, adding another layer of complexity
    to the communication model.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程间通信**：Web workers不与你的主浏览器进程共享内存，因此只能通过*消息传递*（序列化数据）与主线程（UI线程）通信。此外，消息传递机制本质上是异步的，这给通信模型增加了另一层复杂性。'
- en: Clearly, web workers are hard to use.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，web workers难以使用。
- en: Angular tries to alleviate these limitations by integrating the web worker usage
    into the framework itself. It does that by running the complete application in
    the web worker thread, except the rendering part.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Angular试图通过将web worker的使用集成到框架本身中来减轻这些限制。它是通过在web worker线程中运行整个应用程序来实现的，除了渲染部分。
- en: The framework takes care of the communication between the application code running
    inside the web worker and the renderer running inside the main UI thread. From
    a developer's perspective, there are no visible differences.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 框架负责在web worker内部运行的应用代码与主UI线程内运行的渲染器之间的通信。从开发者的角度来看，没有明显的区别。
- en: 'This is again made possible due to the separation of the renderer layer in
    Angular. The following diagram shows the layers that run on the app main thread
    and what runs inside the web worker:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样得益于Angular中渲染层的分离。以下图表显示了在应用主线程上运行的层以及在内置web worker中运行的层：
- en: '![](img/00078.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: Go through this talk ([http://bit.ly/yt-ng-web-worker](http://bit.ly/yt-ng-web-worker))
    from Jason Teplitz to learn about what web workers have to offer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观看Jason Teplitz的这次演讲([http://bit.ly/yt-ng-web-worker](http://bit.ly/yt-ng-web-worker))来了解web
    workers能提供什么。
- en: Performant mobile experience
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效的移动体验
- en: Angular's rendering abstraction again opens up a host of integration avenues,
    especially on the mobile platform. Rather than running an app on a mobile browser,
    Angular renderers can be created that can tap the device's native UI capabilities.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的渲染抽象再次开辟了许多集成途径，尤其是在移动平台上。而不是在移动浏览器上运行应用程序，Angular渲染器可以被创建出来，可以调用设备的原生UI功能。
- en: 'Two notable projects in this domain are renderers for platforms:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域有两个值得注意的项目：平台渲染器：
- en: '**ReactNative** ([http://bit.ly/rnative](http://bit.ly/rnative)): A renderer
    for ReactNative ([http://bit.ly/ng-rnative](http://bit.ly/ng-rnative)). It allows
    the writing of Angular apps using ReactNative''s rendering capabilities.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReactNative** ([http://bit.ly/rnative](http://bit.ly/rnative))：一个ReactNative的渲染器([http://bit.ly/ng-rnative](http://bit.ly/ng-rnative))。它允许使用ReactNative的渲染能力编写Angular应用。'
- en: '**NativeScript** ([https://www.nativescript.org/](https://www.nativescript.org/)):
    Angular and NativeScript teams have collaborated to create a renderer for NativeScript
    ([http://bit.ly/ng-native-script](http://bit.ly/ng-native-script)).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NativeScript** ([https://www.nativescript.org/](https://www.nativescript.org/))：Angular和NativeScript团队合作创建了一个NativeScript的渲染器([http://bit.ly/ng-native-script](http://bit.ly/ng-native-script))。'
- en: App platforms such as *ReactNative* and *NativeScript* already do a superb job
    of providing JavaScript-based APIs for the native mobile platforms (iOS and Android),
    allowing us to utilize a single code base with a familiar language. Angular renderers
    take things a step further. With Angular integration, a good amount of code can
    be shared across browsers and mobile devices. Things may only differ in terms
    of view templates and view-related services such as dialogs, popups, and others.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如*ReactNative*和*NativeScript*这样的应用平台已经出色地提供了针对原生移动平台（iOS和Android）的基于JavaScript的API，使我们能够使用熟悉的语言利用单一代码库。Angular渲染器更进一步。通过Angular集成，大量代码可以在浏览器和移动设备之间共享。可能只有视图模板和与视图相关的服务（如对话框、弹出窗口等）有所不同。
- en: Look at the documentation for the respective renderers to understand how they
    work and the features they support.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看相应渲染器的文档，以了解它们的工作原理和支持的功能。
- en: Next up on the line, we have framework improvements in terms of *change detection*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论框架在*变更检测*方面的改进。
- en: Change detection improvements
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测改进
- en: One of the major performance improvements in Angular over AngularJS is in how
    *change detection* works in Angular. Out of the box, Angular change detection
    is insanely fast, and it can be tweaked even further for better results.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular相对于AngularJS的几个主要性能改进中，Angular中*变更检测*的工作方式是一个亮点。Angular的变更检测默认情况下非常快，并且可以进一步调整以获得更好的结果。
- en: The next few sections talk about Angular change detection in depth. It's an
    important topic to understand when building anything at scale. It also helps us
    debug scenarios where it may seem that change detection is not working as advertised.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将深入讨论Angular的变更检测。在构建任何大规模应用时，这是一个重要的理解主题。它还有助于我们调试那些看起来变更检测没有按预期工作的场景。
- en: Let's start the discussion by understanding what change detection is and why
    it is important.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解什么是变更检测以及为什么它很重要开始讨论。
- en: Change detection
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测
- en: Angular's *data binding engine* does a great job of binding the view with the
    model data (component data). These are live bindings where Angular keeps the view
    in sync with model changes. Any time the model changes, the binding engine re-renders
    parts of the view that are dependent on the model. To manage this view-model synchronization,
    Angular needs to know when the model changed and what changed exactly. This is
    what **change detection** is all about. During app execution, Angular frequently
    does what we call **change detection runs** to determine what changed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的*数据绑定引擎*在将视图与模型数据（组件数据）绑定方面做得很好。这些是实时绑定，Angular会保持视图与模型变化同步。每当模型发生变化时，绑定引擎都会重新渲染依赖于模型的视图部分。为了管理这种视图-模型同步，Angular需要知道模型何时发生变化以及具体发生了什么变化。这就是*变更检测*的全部内容。在应用执行期间，Angular会频繁地进行我们所说的*变更检测运行*，以确定发生了什么变化。
- en: If you are from AngularJS, a *change detection run* is roughly equivalent to
    **digest cycles**, except that in Angular there are **no cycles**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自AngularJS，一个*变更检测运行*大致相当于**消化周期**，只不过在Angular中**没有循环**。
- en: While this problem of keeping the model and view in sync may sound simple, it's
    a tough nut to crack. Unlike the component tree, the interconnection between multiple
    models can be complex. Changes in one component model can trigger changes in multiple
    component models. Furthermore, these interconnections may have cycles. A single
    model property could be bound to multiple views. All these complex scenarios need
    to be managed using a robust change detection infrastructure.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然保持模型和视图同步的问题听起来很简单，但实际上是一个难题。与组件树不同，多个模型之间的相互连接可能很复杂。一个组件模型的变化可能会触发多个组件模型的变化。此外，这些相互连接可能存在循环。单个模型属性可能绑定到多个视图。所有这些复杂场景都需要使用强大的变更检测基础设施来管理。
- en: In the next few sections, we explore how the Angular change detection infrastructure
    works, when change detection triggers, and how can we influence change detection
    behavior in Angular.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨Angular变更检测基础设施的工作原理、变更检测何时触发，以及我们如何影响Angular中的变更检测行为。
- en: Change detection setup
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测设置
- en: 'It all starts with Angular setting up change detectors for every component
    rendered on the view. Since every Angular app is a hierarchy of components, these
    change detectors are also set up in the same hierarchy. The following diagram
    highlights the **change detector hierarchy** of the *Workout Builder* app at a
    point in time:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切都始于Angular为视图上渲染的每个组件设置变更检测器。由于每个Angular应用都是组件的层次结构，这些变更检测器也在相同的层次结构中设置。以下图表突出显示了在某个时间点*Workout
    Builder*应用的**变更检测器层次结构**：
- en: '![](img/00079.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00079.jpeg)'
- en: A *change detector* attached to a component has the responsibility of detecting
    changes in the component. It does that by parsing the binding on the component's
    template HTML and setting up the necessary change detection watches.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 附属于组件的*变更检测器*负责检测组件中的变更。它是通过解析组件模板HTML中的绑定并设置必要的变更检测监视来做到这一点的。
- en: Remember, the detector only sets up watches on model properties used in the
    template, not on all component properties.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，检测器只为模板中使用的模型属性设置监视，而不是所有组件属性。
- en: Another important point worth highlighting here is that *change detection is
    set up one way, from model to view*. Angular does not have the concept of two-way
    data binding and hence the preceding figure is a directed tree without cycles.
    This also makes change detection more predictable. Interleaving model and view
    updates are disallowed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得强调的重要观点是，*变更检测是从模型到视图单向设置的*。Angular没有双向数据绑定的概念，因此前面的图是一个没有环的有向树。这也使得变更检测更加可预测。不允许模型和视图更新交织。
- en: When does change detection kick in?
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测何时启动？
- en: Does Angular constantly check for changes in the model data? Considering the
    fact that the component properties we bind the view to do not inherit from any
    special class, Angular has no way of knowing which property changed. The only
    way out for Angular is to constantly query each data-bound property to know its
    current value and compare it against its old value for changes. Highly inefficient
    to say the least!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是否始终检查模型数据中的变更？考虑到我们绑定的视图组件属性不继承任何特殊类，Angular无法知道哪个属性发生了变化。Angular的唯一出路是不断查询每个数据绑定属性以了解其当前值，并将其与旧值进行比较以检测变更。至少可以说，这是非常低效的！
- en: Angular does better than that, as change detection runs get executed only at
    specific times during app execution. Think carefully about any web application;
    what causes a view to update?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的表现优于这一点，因为变更检测只在应用执行过程中的特定时间执行。仔细思考任何Web应用；是什么原因导致视图更新？
- en: 'A view can get updated due to:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以因为以下原因而更新：
- en: '**User input/browser events**: We click on a button, enter some text, or scroll
    the content. Each of these actions can update the view (and the underlying model).'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户输入/浏览器事件**：我们点击按钮、输入一些文本或滚动内容。这些操作中的每一个都可以更新视图（以及底层的模型）。'
- en: '**Remote XHR requests**: This is another common reason for view updates. Getting
    data from a remote server to show on the grid and getting user data to render
    a view are examples of this.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程XHR请求**：这是视图更新的另一个常见原因。从远程服务器获取数据以显示在网格上，以及获取用户数据以渲染视图都是这种情况的例子。'
- en: '**setTimeout and setInterval timers**: As it turns out, we can use `setTimeout`
    and `setInterval` to execute some code asynchronously and at specific intervals.
    Such code can also update the model. For example, a `setInterval` timer may check
    for stock quotes at regular intervals and update the stock price on the UI.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setTimeout和setInterval计时器**：实际上，我们可以使用`setTimeout`和`setInterval`来异步执行某些代码并在特定间隔执行。这样的代码也可以更新模型。例如，一个`setInterval`计时器可能会定期检查股票报价，并在UI上更新股票价格。'
- en: For obvious reasons, Angular change detection too kicks in only when any of
    these conditions occur.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于显而易见的原因，Angular的变更检测也只有在以下任何条件发生时才会启动。
- en: The interesting part here is not when Angular's change detection kicks in but
    how Angular is able to intercept all *browser events*, *XHR requests*, and `setTimeout`
    and `setInterval` functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分不是Angular的变更检测何时启动，而是Angular如何能够拦截所有*浏览器事件*、*XHR请求*以及`setTimeout`和`setInterval`函数。
- en: 'This feat in Angular is performed by a library called `zone.js`. As the documentation
    describes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中完成这一壮举的是一个名为`zone.js`的库。正如文档所描述的：
- en: '"A Zone is an execution context that persists across async tasks."'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '"区域是一个在异步任务中持续存在的执行上下文。"'
- en: 'One of the basic abilities of this library is that it can hook into a piece
    of code and trigger callbacks when code execution starts and when it ends. The
    code being monitored could be a sequence of calls that are both synchronous and
    asynchronous in nature. Consider this example, which highlights the usage:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的一项基本能力是它可以钩入一段代码，并在代码执行开始和结束时触发回调。被监控的代码可能是一系列既同步又异步的调用。考虑以下示例，它突出了使用情况：
- en: '[PRE0]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We wrap a piece of code inside a call to the `zone.run` call. This code calls
    the `doWork` function synchronously twice, interleaved with a `setTimeout` call
    that invokes the same function after a lapse of 200 milliseconds.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一段代码包裹在`zone.run`调用中。这段代码同步地调用`doWork`函数两次，并在两次调用之间插入一个`setTimeout`调用，该调用在200毫秒后再次调用相同的函数。
- en: 'By wrapping this sequence inside `zone.run`, we can know when the call execution
    is complete. In zone terminology, these are **turns**. The code before `zone.run`
    sets up a subscriber that gets called when execution is complete, using the `zone.onMicrotaskEmpty`
    function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这个序列包裹在`zone.run`中，我们可以知道调用执行何时完成。在区域术语中，这些是**轮次**。`zone.run`之前的代码设置了一个订阅者，当执行完成时会被调用，使用`zone.onMicrotaskEmpty`函数：
- en: 'If we execute the preceding code, the logs look as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行前面的代码，日志看起来如下：
- en: '[PRE1]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `onMicrotaskEmpty` subscription is executed twice, once after the sequential
    execution completes (defined inside `run` callback) and one after the asynchronous
    `setTimeout` execution is complete.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMicrotaskEmpty`订阅执行了两次，一次是在顺序执行完成后（定义在`run`回调中），另一次是在异步`setTimeout`执行完成后。'
- en: Angular change detection uses the same technique to execute our code within
    zones. This code could be an *event handler*, which internally makes more synchronous
    and asynchronous calls before completing, or it could be a `setTimeout`/`setInterval`
    operation that may again require a UI update.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的变更检测使用相同的技巧在区域中执行我们的代码。这段代码可能是一个*事件处理器*，它在完成之前内部进行更多的同步和异步调用，或者它可能是一个`setTimeout`/`setInterval`操作，可能还需要更新UI。
- en: 'The Angular change detection framework subscribes to the `onMicrotaskEmpty`
    observable for the executing zone, and kicks in change detection whenever a turn
    is complete. The following diagram highlights what happens when code similar to
    the one just described is run on a button click:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Angular变更检测框架订阅执行区域的`onMicrotaskEmpty`可观察对象，并在每次轮次完成后启动变更检测。以下图示突出了当运行类似前面描述的代码在按钮点击时发生的情况：
- en: '![](img/00080.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.jpeg)'
- en: During the execution of the code block, if the zone library determines that
    the call is asynchronous in nature, it spawns a new micro task that has its own
    life cycle. It is the completion of these micro tasks that also triggers `onMicrotaskEmpty`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块执行过程中，如果区域库确定该调用是异步的，它将产生一个新的微任务，该任务有自己的生命周期。这些微任务的完成也会触发`onMicrotaskEmpty`。
- en: 'If you want to know how the change detection trigger looks inside Angular,
    here is an excerpt from the Angular source code (simplified further):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道Angular内部变更检测触发器是如何工作的，以下是Angular源代码的摘录（进一步简化）：
- en: '[PRE2]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ApplicationRef` class tracks all the change detectors attached throughout
    the app and triggers a change detection cycle when the application-level zone
    object fires the `onMicrotaskEmpty` event. We will shortly touch upon what happens
    during this change detection.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationRef`类跟踪整个应用程序中附加的所有变更检测器，并在应用程序级别的区域对象触发`onMicrotaskEmpty`事件时触发变更检测周期。我们很快就会涉及到这个变更检测期间发生的事情。'
- en: '*Zone.js* gets the ability to track execution context across any asynchronous
    call because it overrides the default browser API. The override, also termed **monkey
    patching**, overrides the *event subscription*, *XHR requests*, and `setTimeout`/`setInterval`
    API. In the example highlighted previously, the `setTimeout` we invoke is a monkey-patched
    version of the original browser API.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*Zone.js* 通过覆盖默认浏览器API获得了跟踪任何异步调用执行上下文的能力。这种覆盖，也称为**猴子补丁**，覆盖了*事件订阅*、*XHR请求*以及`setTimeout`/`setInterval`
    API。在前面突出显示的例子中，我们调用的`setTimeout`是原始浏览器API的猴子补丁版本。'
- en: Now that we know how change detectors are set up and when this activity kicks
    in, we can look at how it works.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了变更检测器的设置方式和何时启动这项活动，我们可以看看它是如何工作的。
- en: How does change detection work?
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行变更检测？
- en: Once the change detectors are set up and the browser API is monkey-patched to
    trigger change detection, the real change detection kicks in. This is quite a
    simple process.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦变化检测器设置完成并且浏览器 API 被猴子补丁以触发变化检测，真正的变化检测就开始了。这是一个相当简单的过程。
- en: As soon as any of the asynchronous event callbacks are triggered (the execution
    of an event handler is also an async activity), Angular first executes the application
    code we attached to the callback. This code execution may result in some model
    updates. After the execution of the callback, Angular needs to respond to the
    changes by triggering a *change detection run*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦任何异步事件回调被触发（事件处理器的执行也是一种异步活动），Angular 首先执行我们附加到回调的应用程序代码。这段代码的执行可能会导致一些模型更新。在回调执行之后，Angular
    需要通过触发一个 *变化检测运行* 来响应这些变化。
- en: In a change detection run, starting from the top of the component tree, every
    change detector evaluates its respective component's template bindings to see
    if the value of the binding expression has changed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在变化检测运行中，从组件树的顶部开始，每个变化检测器都会评估其相应组件的模板绑定，以查看绑定表达式的值是否已更改。
- en: 'There are some things that we need to highlight regarding this execution:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个执行，我们需要强调以下几点：
- en: Angular does a strict equality check (using `===`) to detect changes. Since
    it's not a deep comparison, for a binding that refers to an object, Angular will
    only update the view when the object reference changes.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 使用严格的相等性检查（使用 `===`）来检测变化。由于它不是深度比较，对于引用对象的绑定，Angular 只在对象引用发生变化时更新视图。
- en: The change detection flow is unidirectional (starting from root), from parent
    to child in a top-down fashion. The detectors on the parent component run before
    the child detectors.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化检测流程是单向的（从根开始），以自顶向下的方式从父到子。父组件上的检测器在子组件检测器之前运行。
- en: 'By default, the change detection algorithm navigates the complete tree, irrespective
    of where the change was triggered in the tree. This implies all binding is evaluated
    on every change detection run:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，变化检测算法遍历整个树，而不管变化是在树的哪个位置触发的。这意味着每次变化检测运行时都会评估所有的绑定：
- en: '![](img/00081.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: A binding evaluation on every run may seem inefficient, but it is not. Angular
    employs some advance optimizations to make this check super fast. Still, if we
    want to tweak this behavior, we do have some switches that can reduce the number
    of checks performed. We will touch upon this topic soon.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行都进行绑定评估可能看起来效率不高，但实际上并非如此。Angular 采用一些高级优化来使这个检查非常快。尽管如此，如果我们想调整这种行为，我们确实有一些开关可以减少执行的检查次数。我们很快就会涉及到这个话题。
- en: Change detectors only track properties that are part of template bindings, not
    the complete object/component properties.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化检测器只跟踪模板绑定中的属性，而不是完整的对象/组件属性。
- en: To detect changes in the bound value, the change detectors need to track the
    previous value of the expression evaluated during the last change detection run.
    Clearly, some amount of bookkeeping is required for every template binding we
    use.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了检测绑定值的更改，变化检测器需要跟踪在上次变化检测运行期间评估的表达式的上一个值。显然，对于每个我们使用的模板绑定，都需要进行一些记录。
- en: The obvious next question would be what happens when a change is detected (by
    a change detector)?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，接下来的问题会是当检测到变化（由变化检测器检测）时会发生什么？
- en: Since all the hard work of setting up change detection and identifying changes
    has already been done, this step just involves updating the component state and
    synchronizing the component DOM.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设置变化检测和识别更改的所有艰苦工作已经完成，这一步只是涉及更新组件状态和同步组件 DOM。
- en: 'There are a few more observations worth highlighting here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些值得强调的观察结果：
- en: 'First and foremost, Angular separates the model update step from the DOM update.
    Consider this code snippet, which is invoked when someone clicks on a button:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首要的是，Angular 将模型更新步骤与 DOM 更新步骤分离。考虑以下代码片段，它在有人点击按钮时被调用：
- en: '[PRE3]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Assuming that both `firstName` and `lastName` are bound to the component view,
    a change to `firstName` does not update the DOM binding immediately. Instead,
    Angular waits for the `doWork` function to complete before triggering a change
    detection run and DOM update.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `firstName` 和 `lastName` 都绑定到组件视图，对 `firstName` 的更改不会立即更新 DOM 绑定。相反，Angular
    会等待 `doWork` 函数完成，然后触发变化检测运行和 DOM 更新。
- en: Secondly, a change detection run does not (and should not) update the model
    state. This avoids any cycles and cascading updates. A change detection run is
    only responsible for evaluating the bindings and updating the view. This also
    means that we should not update the model state during change detection. If we
    update the model during change detection, Angular throws an error.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，一个变更检测运行不会（也不应该）更新模型状态。这避免了任何循环和级联更新。变更检测运行只负责评估绑定和更新视图。这也意味着我们不应该在变更检测期间更新模型状态。如果我们更新模型，Angular
    会抛出一个错误。
- en: 'Let''s see an example of this behavior:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个行为的例子：
- en: 'Open `start.component.html` from the 7 Minute Workout app and update the last
    `div` to:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 7 分钟健身应用中的 `start.component.html`，并将最后一个 `div` 更新为：
- en: '[PRE4]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And, add a `changeDetectionDone` function to the component implementation (`start.component.ts`),
    which looks like:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在组件实现（`start.component.ts`）中添加一个 `changeDetectionDone` 函数，其看起来如下：
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the app, load the start page, and then look at the browser console. Angular
    has logged a number of errors that look like the following:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用，加载起始页面，然后查看浏览器控制台。Angular 记录了许多看起来如下所示的错误：
- en: '[PRE6]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are changing the state of the component when calling the `changeDetectionDone`
    function (inside an interpolation), and Angular throws an error because it does
    not expect the component state to update.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `changeDetectionDone` 函数（在一个插值内）时，我们正在改变组件的状态，Angular 会抛出一个错误，因为它没有预料到组件状态会更新。
- en: 'This change detection behavior is enabled only when **production mode** in
    Angular is disabled. *Production mode* can be enabled by calling the `enableProdMode()`
     function before bootstrapping the application (in `bootstrap.ts`). When enabled,
    Angular behaves a bit differently. It turns off assertions and other checks within
    the framework. Production mode also affects the change detection behavior. In
    non-production mode, Angular traverses the component tree twice to detect changes.
    If on the second pass any binding expression has changed, it throws an error.
    In contrast, when in production mode, change detection tree traversal is done
    only once. The change detection error that we saw on the console will not show
    up if we enable production mode. This can lead to an inconsistency between the
    model and view state. Something we should be aware of! The bottom line is that
    we cannot alter the state of a component when change detection is in progress.
    A direct corollary: if we are using a function inside the binding expression,
    function executions should be stateless, without any side effects.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变更检测行为仅在 Angular 的**生产模式**被禁用时启用。*生产模式*可以通过在启动应用之前调用 `enableProdMode()` 函数来启用（在
    `bootstrap.ts` 中）。启用后，Angular 的行为会有所不同。它会关闭框架内的断言和其他检查。生产模式也会影响变更检测行为。在非生产模式下，Angular
    会遍历组件树两次以检测变更。如果在第二次遍历中任何绑定表达式已更改，它会抛出一个错误。相比之下，在生产模式下，变更检测树遍历只执行一次。我们在控制台上看到的变更检测错误如果启用生产模式将不会显示。这可能导致模型和视图状态之间不一致。这是我们应意识到的事情！底线是，我们不能在变更检测进行时改变组件的状态。一个直接的推论是：如果我们在一个绑定表达式中使用函数，函数执行应该是无状态的，没有副作用。
- en: Lastly, this change detection traversal from root to leaf node executes only
    once during the change detection run.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，这个从根节点到叶节点的变更检测遍历在变更检测运行期间只执行一次。
- en: A pleasant surprise for folks with an AngularJS background! *The digest cycle
    count in Angular is 1*. Angular developers will never face "the digest iterations
    exceeded exception!" A far more performant change detection system!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有 AngularJS 背景的人来说，这是一个令人愉快的惊喜！*Angular 中的消化周期计数为 1*。Angular 开发者永远不会遇到“消化迭代超出异常”！一个性能更优的变更检测系统！
- en: Change detection performance
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测性能
- en: Let's talk about change detection performance. If you think checking the complete
    component tree every time for change is inefficient, you will be surprised to
    know how fast it is. Due to some optimization around how expressions are evaluated
    and compared, Angular can perform thousands of checks in a couple of milliseconds.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈变更检测性能。如果你认为每次检查整个组件树以查找变更是不高效的，你将会惊讶地知道它是多么快。由于一些关于表达式评估和比较的优化，Angular
    可以在几毫秒内执行数千次检查。
- en: Under the hood, for every expression involved in the view binding, Angular generates
    a change detection function that specifically targets a particular binding. While
    it may seem counter intuitive at first, Angular does not have a common function
    for determining whether an expression has changed. Instead, it's like writing
    our own change detection function for every property that we bind to. This allows
    the JavaScript VM to optimize the code, resulting in improved performance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，对于每个涉及视图绑定的表达式，Angular 都会生成一个专门针对特定绑定的变更检测函数。虽然一开始可能看起来有些反直觉，但 Angular 并没有用于确定表达式是否已更改的通用函数。相反，它就像为每个我们绑定的属性编写我们自己的变更检测函数。这允许
    JavaScript VM 优化代码，从而提高性能。
- en: 'Want to learn more about it? Check out this video by Victor Savkin: [https://youtu.be/jvKGQSFQf10](https://youtu.be/jvKGQSFQf10).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于它的信息？查看维克多·萨金（Victor Savkin）的这段视频：[https://youtu.be/jvKGQSFQf10](https://youtu.be/jvKGQSFQf10)。
- en: In spite of all this optimization, there may still be cases where traversing
    the complete component tree may not be performant enough. This is especially true
    when we have to render a large dataset on the view, keeping the bindings intact.
    The good news is that the Angular change detection mechanism can be tweaked.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管进行了所有这些优化，但仍可能存在一些情况，遍历完整的组件树可能不足以高效。这尤其在我们需要在视图中渲染大量数据集并保持绑定完整时更为明显。好消息是，Angular
    的变更检测机制可以进行微调。
- en: The reason Angular needs to do the complete tree walk is that model changes
    in one place may trigger model changes at other places. In other words, a model
    change may have a cascading effect, where interconnected model objects are also
    updated. Since Angular has no way to know what exactly changed, it checks the
    complete component tree and associated model.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 需要遍历整个树的原因是，一个地方的模式变化可能会在其他地方触发模式变化。换句话说，模式变化可能产生级联效应，相互连接的模式对象也会被更新。由于
    Angular 无法知道确切发生了什么变化，它检查完整的组件树和相关模式。
- en: If we can help Angular determine what parts of the application state are updated,
    Angular can be pretty smart about what part of the component tree it traverses
    to detect changes. We do this by storing the app data in some special data structures
    that help Angular decide what components need to be checked for changes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以帮助 Angular 确定应用程序状态中哪些部分被更新，Angular 就可以非常智能地决定遍历组件树以检测更改的部分。我们通过将应用程序数据存储在某些特殊的数据结构中来实现这一点，这些数据结构帮助
    Angular 决定哪些组件需要检查更改。
- en: There are three ways in which we can make Angular change detection smarter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种方法可以使 Angular 的变更检测更智能。
- en: Using immutable data structures
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不可变数据结构
- en: '**Immutable objects/collections** are objects that cannot be changed once created.
    Any property change results in a new object being created. This is what `immutable.js`,
    a popular library for immutable data structures, has to say:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变对象/集合**是创建后不能更改的对象。任何属性更改都会导致创建一个新的对象。这是 `immutable.js`，一个流行的不可变数据结构库，对此所说的话：'
- en: Immutable data cannot be changed once created, leading to much simpler application
    development, no defensive copying, and enabling advanced memoization and change
    detection techniques with simple logic.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据一旦创建就不能更改，这导致应用程序开发更加简单，无需进行防御性复制，并允许使用简单的逻辑实现高级记忆化和变更检测技术。
- en: Let's try to understand how immutable data structures help in the Angular context
    with an example.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来尝试理解不可变数据结构如何在 Angular 上下文中提供帮助。
- en: 'Imagine we are building a set of components to collect employee information
    for a **Human Resource** (**HR**) software. The employee component view looks
    something like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一组组件来收集人力资源（**HR**）软件的员工信息。员工组件视图看起来可能像这样：
- en: '[PRE7]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It has sections for taking personal, professional, and address information.
    The `summary` components provide a read-only view of the employee data being entered.
    Each of the components has a property called `model`, highlighting what part of
    employee data these components manipulate. Each of these components'' summary,
    professional, personal, and address internally may have other child components.
    This is how the component tree looks:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它有用于收集个人、专业和地址信息的部分。`summary` 组件提供了正在输入的员工数据的只读视图。每个组件都有一个名为 `model` 的属性，突出显示这些组件操作员工数据的哪些部分。这些组件的摘要、专业、个人和地址内部可能还有其他子组件。这就是组件树的外观：
- en: '![](img/00082.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.jpeg)'
- en: What happens when we update an employee's personal information? With standard
    objects (mutable), Angular cannot make any assumption about the shape of data
    and what has changed; hence, it does the complete tree walk.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新员工的个人信息时会发生什么？使用标准对象（可变）时，Angular无法对数据的形状和变化做出任何假设；因此，它执行完整的树遍历。
- en: 'How does immutability help here? When using an immutable data structure, any
    change to an object''s properties results in a new object being created. For example,
    if we create an immutable object using a popular library, `Immutable.js`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性在这里是如何帮助的？当使用不可变数据结构时，对对象属性任何的更改都会导致创建一个新的对象。例如，如果我们使用流行的库`Immutable.js`创建不可变对象：
- en: '[PRE8]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Changes to either the `name` or `age` property of `personalInfo` create a new
    object:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`personalInfo`的`name`或`age`属性的变化会创建一个新的对象：'
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This immutability comes in handy if each of the employee model properties (`personal`,
    `professional`, `home`, and `work`) is immutable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个员工模型属性（`personal`、`professional`、`home`和`work`）都是不可变的，这种不可变性将非常有用。
- en: 'Take, for instance, the `PersonalInfo` component definition that binds to personal
    info data:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以`PersonalInfo`组件定义为例，它绑定到个人信息数据：
- en: '[PRE10]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the only thing `PersonalInfo` depends upon is the `model` property, and
    the `model` property binds to an immutable object, Angular only needs to do a
    check for changes if the `model` reference changes. Otherwise, the complete `PersonalInfo`
    component subtree can be skipped.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`PersonalInfo`仅依赖于`model`属性，且`model`属性绑定到一个不可变对象，因此Angular只有在`model`引用发生变化时才需要进行变更检查。否则，可以跳过完整的`PersonalInfo`组件子树。
- en: By setting the `PersonalInfo` component property `changeDetection` to `ChangeDetectionStrategy.OnPush`,
    we instruct Angular to trigger change detection only when the component's inputs
    change.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`PersonalInfo`组件的`changeDetection`属性设置为`ChangeDetectionStrategy.OnPush`，我们指示Angular仅在组件的输入属性发生变化时触发变更检测。
- en: 'If we change the change detection strategy to `OnPush` for each of the Employee
    component children and update the employee''s personal info, only the `PersonalInfo`
    component subtree is checked for changes:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将Employee组件子代中的每个组件的变更检测策略更改为`OnPush`并更新员工的个人信息，则只有`PersonalInfo`组件子树会检查变更：
- en: '![](img/00083.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.jpeg)'
- en: For a large component tree, such an optimization will improve the app/view performance
    many times over.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型组件树，这种优化将大大提高应用/视图性能。
- en: When set to `OnPush`, Angular triggers change detection only when the component's
    input property changes or there is an event raised inside the component or its
    children.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置为`OnPush`时，Angular仅在组件的输入属性发生变化或组件内部或其子代中引发事件时触发变更检测。
- en: Developing applications using immutable data structures departs from the standard
    development paradigm where the application state is totally mutable. What we have
    highlighted in this section is how Angular takes advantage of immutable data structures
    to optimize the change detection process.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变数据结构开发应用程序与完全可变的传统应用程序状态开发范式不同。本节中我们强调的是Angular如何利用不可变数据结构来优化变更检测过程。
- en: '*Observables* are another kind of data structure that can help us optimize
    Angular change detection.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**可观察对象**是另一种可以帮助我们优化Angular变更检测的数据结构。'
- en: Using Observables
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可观察对象
- en: '**Observables** are data structures that trigger events when their internal
    state changes. The Angular *eventing infrastructure* extensively uses *Observables*
    to communicate the components'' internal state to the outside world.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**可观察对象**是当其内部状态发生变化时触发事件的 数据结构。Angular广泛使用**可观察对象**来将组件的内部状态与外部世界进行通信。'
- en: While we have used Observable output properties (the `EventEmitter` class) to
    raise events, *input **properties* too can take Observables. Such observable inputs
    can help Angular optimize change detection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用了可观察的输出属性（`EventEmitter`类）来触发事件，但输入**属性**也可以接受可观察对象。这种可观察的输入可以帮助Angular优化变更检测。
- en: When using observables, the change detection switch still remains `ChangeDetectionStrategy.OnPush`.
    But this time, only if a component input triggers an event (as they are observables)
    will Angular perform the dirty check. When the input triggers an event, the complete
    component tree path, starting from the affected component to the root, is marked
    for verification.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用可观察对象时，变更检测开关仍然保持为`ChangeDetectionStrategy.OnPush`。但这次，只有当组件输入触发事件（因为它们是可观察的）时，Angular才会执行脏检查。当输入触发事件时，从受影响的组件到根组件的完整组件树路径将被标记为待验证。
- en: When performing the view update, Angular will only sync the affected path and
    ignore the rest of the tree.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行视图更新时，Angular只会同步受影响的路径，并忽略树中的其余部分。
- en: Manual change detection
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动更改检测
- en: 'We can actually disable change detection on a component completely and trigger
    manual change detection when required. To disable change detection, we just need
    to inject the component-specific change detector (the `ChangeDetectorRef` class
    instance) into the component and call the `detach` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以完全禁用组件上的更改检测，并在需要时手动触发更改检测。要禁用更改检测，我们只需将特定于组件的更改检测器（`ChangeDetectorRef`类实例）注入到组件中，并调用`detach`函数：
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the onus is on us to inform Angular when the component should be checked
    for changes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，责任在我们身上，我们需要通知Angular何时应该检查组件的更改。
- en: We can reattach the component to the change detection tree by using the `reattach`
    function on `ChangeDetectorRef.`
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`ChangeDetectorRef`上使用`reattach`函数将组件重新附加到更改检测树。
- en: We seldom need to disable the standard change detector setup, unless there are
    situations where standard change detection becomes an expensive affair.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少需要禁用标准更改检测设置，除非有情况使得标准更改检测变得代价高昂。
- en: Take, for example, a public chatroom app, which is receiving messages from thousands
    of people connected to it. If we constantly keep pulling the messages and refreshing
    the DOM, the app may become unresponsive. In such a scenario, we can disable change
    detection on parts of the chat app component tree and manually trigger change
    detection to update the UI at specific intervals.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个公共聊天室应用程序为例，它正在接收来自连接到它的数千人的消息。如果我们不断拉取消息并刷新DOM，应用程序可能会变得无响应。在这种情况下，我们可以禁用聊天应用程序组件树的部分更改检测，并手动在特定间隔触发更改检测以更新UI。
- en: While we have seen three ways to tweak change detection behavior, the good thing
    is that these are not exclusive. Parts of the component tree can use immutable
    data structures, parts can use Observables, parts can employ manual change detection,
    and the rest can still use the default change detection. And Angular will happily
    oblige!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经看到了三种调整更改检测行为的方法，但好事是这些方法并不是互斥的。组件树的部分可以使用不可变数据结构，部分可以使用Observables，部分可以采用手动更改检测，其余部分仍然可以使用默认的更改检测。Angular会欣然从命！
- en: Enough on change detection for now. We may never need it unless we are building
    some large views with a chatty UI. Such scenarios require us to squeeze every
    bit of performance out of the change detection system, and the system is ready
    for it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 关于更改检测就先说这么多。除非我们正在构建一些具有嘈杂UI的大型视图，否则我们可能永远不需要它。这些场景要求我们从更改检测系统中挤出每一分性能，系统已经为此做好了准备。
- en: 'Next, we will have a look at another common requirement that most apps invariably
    have: authenticating their users.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨大多数应用程序不可避免地具有的另一个常见要求：认证用户。
- en: Handling authentication and authorization
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理认证和授权
- en: Most, if not all, apps have a requirement to authenticate/authorize their users.
    We may argue that authentication and authorization are more of a server concern
    than a client one, and that is correct. Still, the client side needs to adapt
    and integrate with the authentication and authorization requirement imposed by
    the server.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数，如果不是所有应用程序，都有对用户进行认证/授权的要求。我们可能会认为认证和授权更多地是服务器的问题，而不是客户端的问题，这是正确的。尽管如此，客户端仍需要适应并与服务器强加的认证和授权要求集成。
- en: In a typical app execution workflow, the app first loads some partial views
    then makes calls to pull data from the server, and finally binds data to its view.
    Clearly, *the views* and *the remote data API* are two assets that need to be
    secured.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的应用程序执行工作流程中，应用程序首先加载一些部分视图，然后调用服务器以获取数据，最后将数据绑定到其视图上。显然，*视图*和*远程数据API*是两种需要被保护的资源。
- en: 'To guard these resources, we need to understand how a typical application is
    secured on the server. There are primarily two broad approaches to securing any
    web applications: *cookie-based authentication* and *token-based authentication*.
    Each of them requires different handling on the client part. The next two sections
    describe how we can integrate with either of these approaches.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护这些资源，我们需要了解典型应用程序在服务器上的安全保护方式。主要有两种广泛的方法来保护任何Web应用程序：*基于cookie的认证*和*基于令牌的认证*。每种方法在客户端部分都需要不同的处理。接下来的两个部分将描述我们如何集成这两种方法之一。
- en: Cookie-based authentication
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于cookie的认证
- en: 'This authentication mechanism is the easiest to implement if the server stack
    supports it. It''s non-intrusive and may require bare minimum changes to the Angular
    application. **Cookie-based authentication** involves setting the browser cookie
    to track the user authentication session. The following sequence diagram explains
    a typical cookie-based authentication workflow:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器堆栈支持它，这种身份验证机制是最容易实现的。它不会干扰应用，并且可能只需要对 Angular 应用进行最小程度的修改。**基于 Cookie
    的身份验证**涉及设置浏览器 Cookie 以跟踪用户身份验证会话。以下序列图解释了一个典型的基于 Cookie 的身份验证工作流程：
- en: '![](img/00084.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00084.jpeg)'
- en: 'Here is how a typical authentication workflow works:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个典型的身份验证工作流程是如何工作的：
- en: When trying to access a secured resource from the browser, if the user is not
    authenticated, the server sends an HTTP 401 Unauthorized status code. A user request
    is an unauthorized request if there is no cookie attached to the request or the
    cookie is expired/invalid.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当尝试从浏览器访问受保护资源时，如果用户未认证，服务器会发送 HTTP 401 未授权状态码。如果请求中没有附加 Cookie 或 Cookie 已过期/无效，则用户请求是一个未经授权的请求。
- en: This unauthorized response is intercepted by the server or, at times, by the
    client framework (Angular in our case) and it typically results in a 302 redirect
    (if intercepted by the server). The redirect location is the URL to the login
    page (the login page allows anonymous access).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种未经授权的响应被服务器拦截，有时甚至被客户端框架（在我们的案例中是 Angular）拦截，通常会导致 302 重定向（如果由服务器拦截）。重定向位置是登录页面的
    URL（登录页面允许匿名访问）。
- en: The user then enters the username and password on the login page and does a
    POST to the login endpoint.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，用户在登录页面上输入用户名和密码，并对登录端点进行 POST 请求。
- en: The server validates the credentials, sets a browser cookie, and redirects the
    user to the originally requested resource.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器验证凭据，设置浏览器 Cookie，并将用户重定向到最初请求的资源。
- en: Henceforth, the authentication cookie is a part of every request (added by the
    browser automatically), and the server uses this cookie to confirm his identity
    and whether the user is authenticated.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从此以后，身份验证 Cookie 成为每个请求的一部分（由浏览器自动添加），服务器使用此 Cookie 来确认其身份以及用户是否已认证。
- en: As we can see, with this approach, the Angular infrastructure is not involved,
    or the involvement is minimal. Even the login page can be a standard HTML page
    that just sends data to the login endpoint for authentication. If the user lands
    on the Angular app, it implicitly means that the user has been authenticated.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用这种方法，Angular 基础设施不参与，或者参与度很小。甚至登录页面也可以是一个标准的 HTML 页面，它只是将数据发送到登录端点进行身份验证。如果用户进入
    Angular 应用，这隐含地意味着用户已经通过认证。
- en: The cookie-based authentication flow may vary depending on the server framework,
    but the general pattern of setting a cookie and attaching a cookie with every
    subsequent request remains the same.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Cookie 的身份验证流程可能因服务器框架而异，但设置 Cookie 并在随后的每个请求中附加 Cookie 的一般模式保持不变。
- en: In a cookie-based application authentication, if the application wants to get
    the user context, a server endpoint (such as `/user/details`) is exposed that
    returns the logged in user's specific data. The client application can then implement
    a service such as `UserService` that loads and caches the user profile data.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Cookie 的应用程序身份验证中，如果应用程序想要获取用户上下文，则会暴露一个服务器端点（例如 `/user/details`），该端点返回已登录用户的特定数据。然后客户端应用程序可以实现一个服务，如
    `UserService`，用于加载和缓存用户配置文件数据。
- en: The scenario described here assumes that the API server (the server that returns
    data) and the site where the application is hosted are in a single domain. That
    may not always be the case. Even for *Personal Trainer*, the data resides on the
    *MongoLab* servers and the application resides on a different server (even if
    it is local). And we already know that this is a cross-domain access and it comes
    with its own set of challenges.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的场景假设 API 服务器（返回数据的服务器）和应用程序托管网站位于单个域中。这并不总是情况。即使是 *Personal Trainer*，数据也驻留在
    *MongoLab* 服务器上，而应用程序驻留在不同的服务器上（即使它是本地的）。我们已经知道这是一个跨域访问，并且它带来了一组自己的挑战。
- en: In such a setup, even if the API server is able to authenticate the request
    and send a cookie back to the client, the client application still does not send
    the authentication cookie on a subsequent request.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置中，即使 API 服务器能够认证请求并将 Cookie 发送回客户端，客户端应用程序在随后的请求中仍然不会发送身份验证 Cookie。
- en: To fix this, we need to set a variable, `withCredentials`, to `true` on each
    XHR request. This can be enabled at the global level by overriding `BaseRequestOptions`
    (the `withCredentials` property). The framework uses the `BaseRequestOptions`
    class to set the default values for every HTTP request.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要在每个XHR请求中将变量`withCredentials`设置为`true`。这可以通过覆盖`BaseRequestOptions`（`withCredentials`属性）在全局级别启用。框架使用`BaseRequestOptions`类为每个HTTP请求设置默认值。
- en: 'This can also be enabled on a per-request level by passing in the `withCredentials:true`
    flag in each HTTP request method as the last parameter:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过在每个HTTP请求方法中将`withCredentials:true`标志作为最后一个参数传递到每个请求级别来启用：
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The last parameter to every HTTP function, including `get`, `post`, and `put`,
    is an options object. This allows us to override the options for the request being
    made.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP函数的最后一个参数，包括`get`、`post`和`put`，都是一个选项对象。这允许我们覆盖正在进行的请求的选项。
- en: Once this flag is enabled, the client browser will start attaching the authentication
    cookie for the cross-domain requests.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用此标志，客户端浏览器将开始为跨域请求附加认证Cookie。
- en: The server too needs to have **cross-origin resource sharing** (**CORS**) enabled
    and needs to respond in a specific manner for the request to succeed. It should
    set the **access-control-allow-credentials** header to true and the **access-control-allow-origin**
    header to the host site making the request.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器也需要启用**跨源资源共享**（**CORS**），并且需要以特定的方式响应才能使请求成功。它应该将**access-control-allow-credentials**头部设置为true，并将**access-control-allow-origin**头部设置为发出请求的主机站点。
- en: Check out the MDN documentation ([http://bit.ly/http-cors](http://bit.ly/http-cors))
    to learn about this scenario in detail.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 查看MDN文档（[http://bit.ly/http-cors](http://bit.ly/http-cors)）以详细了解此场景。
- en: 'Cookie-based authentication is definitely less work on the client side, but
    there are times when you have to revert to token-based access. This could be because:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Cookie的认证在客户端确实减少了工作量，但有时您不得不回退到基于令牌的访问。这可能是因为：
- en: Cookies and cross-domain requests do not play nicely across browsers. Specifically,
    IE8 and IE9 do not support them.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookie和跨域请求在浏览器中表现不佳。特别是，IE8和IE9不支持它们。
- en: The server may not support generating cookies, or the server only exposes token-based
    authentication.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器可能不支持生成Cookie，或者服务器只公开基于令牌的认证。
- en: Token-based solutions are easy to integrate with a native mobile application
    and desktop clients.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于令牌的解决方案很容易与原生移动应用程序和桌面客户端集成。
- en: Tokens are not susceptible to cross-site request forgery (CSRF) attacks.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌不易受到跨站请求伪造（CSRF）攻击。
- en: To know more about CSRF, look at the CRSF Prevention cheat sheet at [http://bit.ly/csrf-cs](http://bit.ly/csrf-cs).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于CSRF的信息，请查看[http://bit.ly/csrf-cs](http://bit.ly/csrf-cs)的CRSF预防cheat
    sheet。
- en: The next section talks about supporting token-based authentication.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论支持基于令牌的认证。
- en: Token-based authentication
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于令牌的认证
- en: '**Token-based access** is all about sending a token (typically in HTTP headers)
    with each request instead of a cookie. A simplified token-based workflow looks
    something like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于令牌的访问**完全是关于在每个请求中发送一个令牌（通常在HTTP头部），而不是一个Cookie。简化的基于令牌的工作流程看起来大致如下：'
- en: '![](img/00085.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: Many public APIs (such as *Facebook* and *Twitter*) use token-based authentication.
    The format of the token, where it goes, and how it is generated depends on the
    protocol used and the server implementation. Popular services that use token-based
    authentication implement the **OAuth 2.0** protocol for token generation and exchange.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公共API（如*Facebook*和*Twitter*）使用基于令牌的认证。令牌的格式、位置以及如何生成取决于所使用的协议和服务器实现。使用基于令牌的认证的流行服务实现了用于令牌生成和交换的**OAuth
    2.0**协议。
- en: In a typical token-based authentication setup, the views are available publicly
    but the API is secured. If the application tries to pull data through API calls
    without attaching the appropriate token to the outgoing request, the server returns
    an *HTTP 401 Unauthorized* status code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的基于令牌的认证设置中，视图是公开的，但API是受保护的。如果应用程序尝试通过不将适当的令牌附加到发出的请求的API调用来获取数据，服务器将返回一个*HTTP
    401未授权*状态码。
- en: Enabling token authentication is a good amount of work in Angular. It involves
    setting up a login page/component, guard conditions, authentication service, and
    authentication context shared across the application.  If you embark on this journey,
    make sure to look for Angular libraries/module that makes this integration easier.
    The `ngx-auth` library ([http://bit.ly/ngx-auth](http://bit.ly/ngx-auth)) can
    be a good starting point.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中启用token认证是一项相当多的工作。它包括设置登录页面/组件、守卫条件、认证服务和跨应用共享的认证上下文。如果你开始这段旅程，确保寻找使这种集成更简单的Angular库/模块。`ngx-auth`库（[http://bit.ly/ngx-auth](http://bit.ly/ngx-auth)）可以是一个好的起点。
- en: That's all about authentication, but what about authorization? Once the user
    context is established, we still need to make sure that the user is only able
    to access parts that he/she is allowed to. *Authorization* is still missing.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于认证的所有内容，但关于授权呢？一旦建立了用户上下文，我们仍然需要确保用户只能访问他/她被允许访问的部分。*授权*仍然缺失。
- en: Handling authorization
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理授权
- en: Like authentication, authorization support too needs to be implemented on both
    the server and client side, more so on the server than the client. Remember, anyone
    can hack into the JavaScript code and circumvent the complete authentication/authorization
    setup. So, always tighten your server infrastructure irrespective of whether the
    client has the necessary checks in place or not.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与认证一样，授权支持也需要在服务器和客户端上实现，尤其是在服务器端。记住，任何人都可以破解JavaScript代码并绕过完整的认证/授权设置。所以，无论客户端是否设置了必要的检查，都要始终加强你的服务器基础设施。
- en: This still does not mean that we do not do any authorization checks on the client.
    For standard users, this is the first line of defense against unwarranted access.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们在客户端不做任何授权检查。对于标准用户来说，这是防止未经授权访问的第一道防线。
- en: 'When working on an authorization requirement for any application, there are
    three essential elements that are part of the setup:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在为任何应用程序设置授权需求时，有三个基本元素是设置的一部分：
- en: The resources that need to be secured/authorized
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要受到保护/授权的资源
- en: A list of roles and users that are part of these roles
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属于这些角色的角色和用户列表
- en: A mapping between the resources and the roles that define who can access what
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源与定义谁可以访问什么的角色之间的映射
- en: From an Angular app perspective, the resources are the pages and, sometimes,
    sections of pages that need to be restricted to specific roles. If the user is
    in a specific role, depending upon the role-resource mapping, they get access
    to some pages; otherwise, they are denied access.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从Angular应用程序的角度来看，资源是需要限制到特定角色的页面和，有时，页面的部分。如果用户属于特定角色，根据角色-资源映射，他们可以访问某些页面；否则，他们将无法访问。
- en: While authorization in an Angular application can be implemented in a number
    of ways, we will outline a generic implementation that can be further customized
    to suit your needs in the future.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Angular应用程序中授权可以通过多种方式实现，但我们将概述一个通用的实现，该实现可以进一步定制以满足未来的需求。
- en: Adding authorization support
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加授权支持
- en: To enable authorization, the first thing that we need to do is expose the logged
    in user data, including his/her roles, throughout the application.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用授权，我们首先需要做的是在整个应用程序中公开登录用户数据，包括他的/她的角色。
- en: Sharing user authentication context
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享用户认证上下文
- en: 'User context can be shared using an Angular service, which can then be injected
    into components that require the authorization context. Look at this service interface:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Angular服务共享用户上下文，然后可以将该服务注入到需要授权上下文的组件中。看看这个服务接口：
- en: '[PRE13]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `SessionContext` service tracks the user login session and provides details
    such as:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionContext`服务跟踪用户登录会话并提供如下详细信息：'
- en: The logged in user (`currentUser`)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录用户（`currentUser`）
- en: Whether the user is authenticated (`isAuthenticated`)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否已认证（`isAuthenticated`）
- en: The `isUserInRole` function, which returns `true` or `false` based on whether
    the user is part of any of the roles passed into the `roles` parameter
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isUserInRole`函数，根据用户是否是传递给`roles`参数的任何角色的成员，返回`true`或`false`'
- en: With such a service in place, we can add authorization for routes, thereby restricting
    access to some routes to specific roles only.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的服务到位后，我们可以为路由添加授权，从而仅将某些路由的访问限制到特定角色。
- en: Restricting routes
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制路由
- en: 'Like authentication, the `canActivate` guard check can also be used for authorization.
    Implement a class with the `CanActivate` interface and inject the `SessionContext`
    service into the constructor; then, check whether the user belongs to a specific
    role in the `canActivate` function using the `SessionContext` service. Check out
    the following code snippet:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Only users with roles of *Contributor* and *Admin* now have access to routes
    that have this guard condition.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when a page has view elements that are rendered based on the
    user's role?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally rendering content based on roles
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditionally rendering content is easy to implement. We just need to show/hide
    HTML elements based on the user role. We can build a *structural directive* such
    as `ng-if` that can verify that the user belongs to a role before rendering the
    content. The directive''s usage looks like:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code checks whether the user is in an admin role before rendering
    a Site Setting hyperlink.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'The directive implementation mimics how `ng-if` works, except that our show/hide
    logic depends upon the `SessionContext` service. Here is a sample implementation
    for the `a2beRolesAllowed` directive:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a trivial implementation that uses `SessionContext` and the roles passed
    as input (`a2beRolesAllowed`) to show/hide a fragment.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of authentication and authorization implementation.
    The reference implementation walkthrough should help us build authentication and
    authorization into our apps. With this basic understanding in place, any setup
    can be tweaked to handle other custom authentication/authorization scenarios.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now time to address the elephant in the room: migrating from *AngularJS*
    to *Angular*. If you are starting afresh on Angular, you can very well skip the
    next section.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: From the Angular's migration guide *"Angular is the name for the Angular of
    today and tomorrow. AngularJS is the name for all v1.x versions of Angular.*"
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Migrating AngularJS apps
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have been working extensively on AngularJS, Angular poses some pertinent
    questions:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Should I migrate my old AngularJS apps to the latest Angular version?
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should the migration happen?
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the migration one-shot or can it be done in an incremental fashion?
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the effort involved?
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can I do something today that helps with the migration in the future?
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am starting a new AngularJS app today. What should I do to make the migration
    seamless in the future?
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every such query needs to be addressed to make sure the transition is as smooth
    as possible. No one likes surprises later in the game! In the coming sections,
    we will try to answer a number of such questions. As part of the learning, we
    will also walk you through migrating the AngularJS version of the *Trainer* app
    (developed for the first version of this book) to Angular. This will help everyone
    make some informed decisions on when and how to migrate to Angular.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '"Should I migrate or not" is something that we will address first.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Should I migrate?
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just because Angular is here doesn't mean AngularJS is gone. AngularJS is still
    being developed, albeit not at the same pace as Angular. Google is still committed
    to supporting AngularJS for a good amount of time. The AngularJS team is working
    on version 1.7 currently and plan to release it before June 2018\. After that,
    1.7 will enter the **Long Term Support** (**LTS**) period, where the focus will
    only be on bug fixes.  We can learn more about it from their blog post at [http://bit.ly/ng1-lte-support](http://bit.ly/ng1-lte-support).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, AngularJS will continue to be supported and hence should not be a major
    concern for migration. The move to Angular can be decided based on what Angular
    has to offer over its predecessor.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Angular
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is designed for the future and overcomes a number of shortcomings in
    its predecessor. In this section, we emphasize what makes Angular a better framework
    than AngularJS.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Things you should be aware of while making a decision to move to Angular:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '**Better behavioral encapsulation**: Admittedly, while AngularJS *scopes* seem
    to be god sent when we started learning AngularJS, we have now realized how difficult
    it is to manage the hierarchical nature of scopes. Component-based development
    in Angular provides a better encapsulation in terms of the state of the application.
    A component manages its own state, takes input, and raises events; a clear demarcation
    of responsibilities that are easy to reason with!'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less of the framework in app code**: You don''t need special objects such
    as a *scope.* DI works with annotation (in TypeScript). You don''t set up watches.
    All in all, when reading a component code, you will not find framework-level constructs
    in it.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smaller framework API to explore**: AngularJS had a host of directives that
    one had to be aware of. With Angular template syntax, directives related to browser
    events are gone. This reduces the number of directives that one needs to be aware
    of.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Angular is faster compared to its predecessor. A complete
    section of this book was dedicated to understanding what makes Angular a high-performance
    framework.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile-friendly**: Angular tries to optimize the user''s mobile experience
    by utilizing technologies such as server-side rendering and web workers. Angular
    applications on mobile are more performant that those of its predecessor.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform**: Angular targets running on most devices and across platforms.
    You can use Angular to build applications for web and mobile. As we learned earlier,
    the separation of the rendering layer has open up a great number of possibilities
    in terms of where Angular can be utilized.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a true sense, Angular supersedes its predecessor, and in a perfect world,
    everyone should be working on a better framework/technology. But migration is
    never easy, especially in this case, where the two frameworks differ a lot.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: What we recommend is even if you do not plan to migrate to Angular today, build
    your AngularJS apps in ways that allow easy migration to Angular in future.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The next section talks about the principles and practices to follow for AngularJS
    today, allowing easy migration in the future.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Developing AngularJS apps today for easy migration
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new Angular is a paradigm shift and the way we develop components in Angular
    is quite different from AngularJS. For easy migration, Angular too should embrace
    component-based development. This can be achieved if we follow some guidelines/principles
    while building AngularJS apps. The next few sections detail these guidelines.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The advice listed here is highly recommended even if you do not plan to migrate
    to Angular. These recommendation bits will make AngularJS code more modular, organized,
    and testable.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: One component per file
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This can be anything: an AngularJS *controller*, *directive*, *filter*, or
    *service*. One component per file allows better organization of code and easy
    migration, allowing us to clearly identify how much progress has been made.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding inline anonymous functions
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use named functions instead to declare controllers, directives, filters, and
    services. A declaration such as this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Should be converted to this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The advantages of using named functions are ease of debugging and ease of migration
    to TypeScript. Using named functions also requires that the dependencies be registered
    using the `$inject` function property.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '`$inject`-based dependency declaration safeguards against minification and
    adds to the readability of the functions.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid exposing global name functions with this approach, it is advisable
    to wrap the function in an **Immediately Invoked Function Expression** (**IIFE**):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Avoiding $scope!
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes, you read it right; avoid the `$scope`/`$rootScope` object or using scopes
    directly!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem with AngularJS scopes is their hierarchical nature. Accessing
    the parent scope from the child scope gives us tremendous flexibility, but it
    comes at a cost. This can unknowingly create unwarranted dependencies that make
    the app really hard to debug and, of course, migrate. In contrast, in Angular,
    a view is bound to its component implementation and cannot access data outside
    its boundary implicitly. Therefore, if you plan to migrate to Angular, *avoid
    scopes at all costs*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of techniques that can be used to remove the `$scope` object
    dependency. The next few subsections elaborate on some techniques that can help
    us avoid AngularJS scopes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Using controller as (controller aliasing) syntax everywhere
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularJS 1.3+ has the *controller as* syntax for *controllers*, *directives*,
    and *routes*. *controller as* syntax allows AngularJS data binding expressions
    to work against a controller's instance properties instead of the current *scope*'s
    object properties. With the controller as paradigm in place, we never need to
    interact with the scope directly, and hence future migration becomes easy.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: While controller aliasing gets rid of scope access, scopes are still there in
    AngularJS. The complete AngularJS data binding infrastructure depends upon scopes.
    Controller aliasing just puts an indirection between our code and scope access.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following syntax for *controller as* in views:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And the corresponding controller implementation:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`WorkoutListController` as `workoutList` creates an alias `workoutList` for
    `WorkoutListController` on the current scope, hence allowing us to bind to the
    `workouts` property defined on the controller.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Route definition too allows controller aliasing using the `controllerAs` property
    in a *route definition object*:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, directives too can use `controllerAs`, and together with the `bindToController`
    property on the *directive definition object*, we can get rid of any direct scope
    access.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the Angular documentation on controllers, routes, and directives to
    get a basic understanding of the controller as syntax. Also, look at the following
    posts for some more detailed samples on this topic: [http://bit.ly/ng1-controller-as](http://bit.ly/ng1-controller-as) and [http://bit.ly/ng1-bind-to](http://bit.ly/ng1-bind-to).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding ng-controller
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If scopes can be avoided, so can controllers!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: This may again seem counterintuitive, but the approach has real benefits. What
    we ideally want to do is emulate component behavior in AngularJS. Since the closest
    thing to components in AngularJS is *element directives* (with `restrict='E'`),
    we should utilize *element directives* everywhere.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: An AngularJS element directive with its own template and isolated scope can
    very well behave like an Angular component and only be dependent on its internal
    state for its view binding. We just don't need `ng-controller`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the use of `ng-controller` for audio tracking from the AngularJS version
    of the *Personal Trainer* app:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Instead of using `WorkoutAudioController`, an element directive can encapsulate
    the workout audio''s view and behavior. Such a directive can then replace the
    complete `ng-controller` declaration and its view:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When replacing `ng-controller` with an element directive, the scope variables
    that the controller depends upon should be passed to the directive using the `bindToController`
    property on the *directive definition object—*something like this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This topic has been extensively covered in these two blogs posts by Tero: [http://bit.ly/ng2-no-controllers](http://bit.ly/ng2-no-controllers)
    and [http://bit.ly/ng2-refactor-to-component](http://bit.ly/ng2-refactor-to-component).
    Must-read posts with a wealth of information!'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Building using the AngularJS 1.5+ component API
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularJS 1.5+ has a **component API** that allows us to create directives that
    can be easily migrated to Angular. The component API is preconfigured with sensible
    defaults, hence incorporating the best practices when it comes to building truly
    isolated and reusable directives.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Look at the component API at [http://bit.ly/ng1-dev-guide-components](http://bit.ly/ng1-dev-guide-components) and
    this informative post by Tod Motto at [http://bit.ly/1MahwNs](http://bit.ly/1MahwNs) to
    learn about the component API.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate what has been emphasized earlier, these steps are not just targeted
    towards easy Angular migration but also towards making AngularJS code better.
    Component-based UI development is a better paradigm than what we are used to with
    AngularJS.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: We highly recommend that you go through the AngularJS style guide ([http://bit.ly/ng1-style-guide](http://bit.ly/ng1-style-guide)).
    This guide contains a wealth of tips/patterns that allow us to build better AngularJS
    apps, and is in sync with the guidelines provided previously for easy Angular
    migration.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we have decided to migrate, it's time to decide what to migrate.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: What to migrate?
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an app in maintenance mode, where most of the development activity revolves
    around bug fixes and some enhancements, it would be prudent to stick to AngularJS.
    Remember the old saying *if it ain't broke, don't fix it*.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: If the app is being actively developed and has a clear long-term roadmap, migrating
    to Angular is worth considering. As we dig deeper into the intricacies of migration,
    we will realize the time and effort involved in the process. While the Angular
    team has worked really hard to make this migration smooth, by no stretch of the
    imagination is this a trivial job. It is going to take a good amount of time and
    effort to perform the actual migration.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The silver lining here is that we do not need to migrate everything at once.
    We can work slowly towards migrating parts of the AngularJS code base to Angular.
    Both the frameworks can coexist and can depend on each other too. This also allows
    us to develop new parts of applications in Angular. How cool is that?
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: But again, this flexibility comes at a cost—the cost of bytes. As both frameworks
    are downloaded, the page bytes do increase, something that we should be aware
    of.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Also, while the coexistence of both the frameworks allows us to migrate without
    much disruption, we cannot make it a perpetual activity. Eventually, AngularJS
    has to go, and the sooner it does the better.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: During migration, the best thing that can be done is to carve out new SPAs within
    the existing application. For example, we can build the Admin area of an app entirely
    using Angular, with a separate host page, but still share the common infrastructure
    of style sheets, images, and even AngularJS services if we refactor the code a
    bit. As we will learn later, migrating services to Angular is the easiest.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Breaking an application into multiple smaller ones introduces full-page refreshes,
    but this is a cleaner approach when it comes to migration.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Taking all of this into consideration, if we have decided to migrate and identified
    areas of migration, you need to do the prep work for migration.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for Angular migration
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the big brave world of Angular migration! A successful migration
    strategy involves making sure that we do the groundwork beforehand, avoiding any
    late surprises.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: As prep work, the first step is to analyze the application from a third-party
    library dependency perspective.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Identifying third-party dependencies
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any third-party library that an AngularJS app uses needs a migration strategy
    too. These could be either jQuery-based libraries or AngularJS libraries.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: jQuery libraries
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jQuery libraries in AngularJS were consumed by creating a directive wrapper
    over them. We will have to migrate such directives to Angular.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS libraries
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Migrating AngularJS libraries is a bit of a tricky affair. AngularJS has a massive
    ecosystem, and Angular too has been around for some time and now has a healthy
    community. When migrating, each AngularJS library needs to be substituted with
    an Angular alternative.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not find a perfect upgrade path for a specific library, we can either:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Customize a similar component/library available out there
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the more radical approach of building our own library from the ground up
    in Angular
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these choices has trade-offs in terms of time and complexity.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Another choice that needs to be made is the development language. Should we
    use TypeScript, ES2015, or plain old JavaScript (ES5)?
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Choice of language
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We would definitely recommend TypeScript. It's a super awesome language that
    integrates very well with Angular and vastly reduces the verbosity of Angular
    declarations. Also, given that it can coexist with JavaScript, it makes our lives
    easier. Even without Angular, TypeScript is one language that we should embrace
    for the web platform.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: In the coming sections, we will migrate the AngularJS *Personal Trainer* app
    to Angular. The app is currently available on *GitHub* at [http://bit.ly/a1begit](http://bit.ly/a1begit).
    This app was part of the first version of this book, *AngularJS by Example*, and
    was built using JavaScript.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: We are again going to follow the checkpoint-based approach for this migration.
    The checkpoints that we highlight during the migration have been implemented as
    GitHub branches. Since we will be interacting with a *Git* repository for v1 code
    and using *Node.js* tools for the build, please set up Git and Node.js on your
    development box before proceeding further.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Migrating AngularJS's Personal Trainer
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we even begin the migration process, we need to set up the v1 *Personal
    Trainer* locally.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: The code for the migrated app can be downloaded from the GitHub site at [https://github.com/chandermani/angularjsbyexample](https://github.com/chandermani/angularjsbyexample).
    Since we migrate in chunks, we have created multiple checkpoints that map to **GitHub
    branches** dedicated to migration. Branches such as `ng6-checkpoint8.1`, `ng6-checkpoint8.2`,
    and so on highlight this progression. During the narration, we will highlight
    the branch for reference. These branches will contain the work done on the app
    up to that point in time.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: The *7 Minute Workout* code is available inside the repository folder named
    `trainer`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Setting up AngularJS's Personal Trainer locally
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps and you will be up and running in no time:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line, clone the v1 GitHub repository:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Navigate to the new Git repo and check out the `ng6-base` branch to get started:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since the app loads its workout data from **MongoDB** hosted in **mLab **([https://mlab.com/](https://mlab.com/)),
    you need an mLab account to host workout-related data. Set up an mLab account
    by signing up with them. Once you have an mLab account, you need to retrieve your
    API key from mLab's management portal. Follow the instructions provided in the
    API documentation ([http://bit.ly/mlab-docs](http://bit.ly/mlab-docs)) to get
    your API key.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have the API key, update this line in `app/js/config.js` with your
    API key:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And add some seed workout data into your mLab instance. The instructions to
    add the seed data into mLab are available in the source code file, `app/js/seed.js`.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, install the necessary *npm packages* required for v1 *Personal Trainer*:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Install `http-server`; it will act as a development server for our v1 app:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Verify that the setup is complete by starting the `http-server` from the `app`
    folder:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: And open the browser location `http://localhost:8080`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: The v1 *Personal Trainer* start page should show up. Play around with the app
    to verify that the app is working fine. Now, the migration can begin.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Identifying dependencies
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step before we begin migrating v1 *Personal Trainer* is to identify
    the external libraries that we are using in the AngularJS version of Personal
    Trainer.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'The external libraries that we are using in v1 are:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '`angular-media-player`'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angular-local-storage`'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angular-translate`'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angular-ui-bootstrap`'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`owl. carousel`'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries such as `angular-media-player` and `angular-local-storage` are easy
    to migrate/replace. We have already done this in earlier chapters of this book.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: The `angular-translate` library can be replaced with `ngx-translate`, and as
    we will see in the coming sections, it is not a very challenging task.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: We use `angular-ui-bootstrap` for **modal dialogs** in *Personal Trainer v1*.
    We replace it with `ngx-modialog` ([http://bit.ly/ngx-modialog](http://bit.ly/ngx-modialog))
    as the only control we were using from `angular-ui-bootstrap` was the dialog control.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have sorted out the external dependencies, let's decide the language
    to use.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: While the existing code base is JavaScript, we love TypeScript. Its type safety,
    its terse syntax, and how well it plays with Angular makes it our language of
    choice. Hence, it's going to be TypeScript all the way.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that tilts the decision in favor of TypeScript is that we do not
    need to migrate the existing code base to TypeScript. Anything we migrate/build
    new, we build it in TypeScript. Legacy code still remains in JavaScript.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Let's start. As a first migration task, we need to set up a module loader for
    our v1 Personal Trainer.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the module loader
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are going to create a number of new Angular components spread across
    numerous small files, adding direct script reference is going to be tedious and
    error-prone. Angular CLI also is not of much help here as it cannot manage the
    existing codebase implemented in JavaScript.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a **module loader**. A module loader (*ES6 modules* and not Angular)
    can help us with:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Creating isolated/reusable modules based on some common module formats
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the script loading order based on dependencies
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing bundling/packaging of a module and on-demand loading for dev/production
    deployments
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the **SystemJS** module loader for this migration.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'Install SystemJS from the command line using:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: All the commands need to be executed from the `trainer/app` folder.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: We open `index.html` and remove all the script references of our app scripts.
    All script references with the source as `src='js/*.*'` should be removed, except
    `angular-media-player.js` and `angular-local-storage.js`, as they are external
    libraries.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: We are not removing script references for third-party libraries, but
    only app files.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'Add SystemJS configurations after all third-party script references:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Remove the `ng-app` attribute on the `body` tag, keeping the `ng-controller`
    declaration intact:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `ng-app` way of bootstrapping has to go as we switch to the `angular.bootstrap`
    function for manual bootstrapping. Manual bootstrapping helps when we bring Angular
    into the mix.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `SystemJS.import` call loads the application by loading the first
    app module (JavaScript) defined in `js/app.js`. We are going to define this JavaScript
    module shortly.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `app.module.js` in the same folder as `app.js` and
    copy the complete contents of `app.js` into `app.module.js`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Remember to get rid of the `use strict` statement. The TypeScript compiler does
    not like it.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: All the app module definitions are now in `app.module.js`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, clear `app.js` and add the following imports and bootstrap code:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have added *ES6 import statements* to `app.js`. These are the same scripts
    that were earlier referenced in `index.html`. SystemJS now loads these script
    files when loading `app.js`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Moving all of the AngularJS module declarations into a new file, `app.module.js`,
    and importing it first into `app.js` makes sure that the AngularJS modules are
    defined before any of the `import` statements are executed.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Do not confuse *ES6 modules* and *AngularJS modules* defined/accessed using
    `angular.module('name')`. These two are altogether different concepts.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: The last few lines bootstrap the AngularJS application using the `angular.bootstrap`
    function.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Module loading is enabled now; let's enable TypeScript too.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Enabling TypeScript
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable TypeScript, install the TypeScript compiler using *npm*:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, open `package.json` and add these lines inside the script configuration:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The new script's properties that we just added provide a shortcut for commonly
    executed commands.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: To enable IDE IntelliSense for JavaScript libraries, we need to install their
    type definitions. **Type definitions** or **typings** are files that define the
    public interface for a TypeScript/JavaScript library. These type definitions help
    IDEs provide IntelliSense around the library functions. Typings are available
    for most of the popular JavaScript libraries and for frameworks/libraries written
    in TypeScript.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install typings for the libraries we use. From the command line, execute:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, copy `overrides.d.ts` from `checkpoint8.1` to the local `app` folder.
    This helps TypeScript compiler to handle the global `angular` object used in `app.js` and
    other places.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to set up some configurations for the TypeScript compiler. Create
    a file called `tsconfig.json` (in the `trainer/app` folder) and copy the configuration
    from the `ng6-checkpoint8.1` repo branch (also available remotely at [http://bit.ly/ng6be-8-1-tsconfig](http://bit.ly/ng2be-8-1-tsconfig)).
    Run the compiler using:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This should start the TypeScript compiler, and there should be no errors reported.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Keep this command running in a separate console window at all times during development.
    The compiler will continuously watch for changes to the TypeScript file and rebuild
    the code if changes are detected.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Change the extension of the `app.js` and `app.module.js` files to `app.ts` and
    `app.module.ts`. The TypeScript compiler detects these changes and compiles the
    TypeScript files. After compilation, the compiler produces two files for each
    TypeScript file. One is the compiled JavaScript file (such as `app.js`) and the
    other is a map file (`app.js.map`) for debugging purposes.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: We have not set up an elaborate build for this exercise as our primary focus
    is on migration. For your own apps, the initial setup steps may vary depending
    upon how the build is already set up.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we test our new changes, `config.js` needs to be fixed because we have
    enabled strict DI check-in AngularJS through:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Replace the `config.js` content with updated content available in `ng6-checkpoint8.1`
    or at [http://bit.ly/ng6be-8-1-configjs](http://bit.ly/ng2be-8-1-configjs) (and
    remember to set the API key again). The update fixes the `config` function and
    makes it minification-friendly. Time to test the app!
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the TypeScript compiler is running in one console; run `http-server
    -c-1` in a new console window.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `http://localhost:8080` the app start page should load.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Commit/save your local changes.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'If things work fine, you can even commit your local changes to your git repo.
    This will help you track what has changed over time as we migrate the app piece
    by piece. The implementation till this point is available in the `ng6-checkpoint8.1`
    GitHub branch. If you are facing problems, compare the `ng6-base` and `ng6-checkpoint8.1`
    branches to understand the changes made. Since the code is hosted in GitHub, we
    can use the *GitHub compare* interface to compare commits in a single branch.
    See the documentation on how to do it here: [http://bit.ly/github-compare](http://bit.ly/github-compare).
    The link at [http://bit.ly/ng6be-compare-base-8-1](http://bit.ly/ng6be-compare-base-8-1) shows
    a comparison between `ng6-base` and `ng6-checkpoint8.1`. You can ignore the diff
    view for `app.js` and `app.module.js`, generated as part of the TypeScript compilation.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Time to introduce Angular!
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Adding Angular
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start by installing Angular and dependent *npm modules* for our app. We will
    update the `package.json` file with the necessary packages first.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Copy the updated package file from [http://bit.ly/ng6be-8-2-package-json](http://bit.ly/ng6be-8-2-package-json)
    into your local installation.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json` now references some new packages related to Angular. Install
    the referenced packages by calling:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you are having trouble with installing packages with `npm install`, delete
    the `node_modules` folder and run `npm install` again.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add a few library references that Angular is dependent upon (and are
    not loaded using SystemJS) in `index.html` before the `system.src.js` script reference
    (two in total):'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As it stands now, the SystemJS configuration has been set up in the `index.html`
    file itself. Since Angular requires some decent amount of configuration, we are
    going to create a separate *SystemJS configuration file* instead, and reference
    that in `index.html`.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this script reference after the `system.src.js` reference:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, clear the `script` section containing the call to the `System.config`
    function and replace it with the following:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Copy the `systemjs.config.js` from [http://bit.ly/ng6be-8-2-system-js-config](http://bit.ly/ng6be-8-2-system-js-config) and
    place it in the same folder as `package.json`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, update `tsconfig.json` and add a new property called `moduleResolution`
    to `compilerOptions`:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This instructs TypeScript to look for type definitions in the `node_modules`
    folder. Remember, Angular typings are bundled as part of the Angular library itself,
    and hence a separate type definition import is not required.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Angular-specific references have been added, we need to modify
    the existing bootstrap process to also load Angular.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: The ngUpgrade Library
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To support gradual migration from AngularJS to Angular, the Angular team has
    released a library, `ngUpgrade`. The library contains a set of services that allow
    AngularJS and Angular to be loaded in tandem and play well together. This library
    has services that can help:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap an app with both the AngularJS and Angular frameworks loaded. This
    is the first thing we are going to do.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporate an Angular component in an AngularJS view.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporate an AngularJS component in an Angular view, albeit with some limitations.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share dependencies across the frameworks.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The primary tool in this library is* `UpgradeModule`. As the platform documentation
    summarizes:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '"This is a module that contains utilities for bootstrapping and managing hybrid
    applications that support both Angular and AngularJS code."'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: As we make progress with our migration efforts, the role of `UpgradeModule`
    becomes clearer.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to bootstrap the hybrid AngularJS and Angular app using `UpgradeModule`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the hybrid app
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To bootstrap a hybrid application, we must bootstrap both the Angular and AngularJS
    parts of the application. The sequence involves the process is as follows:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap the Angular app
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, using`UpgradeModule`, bootstrap the AngularJS app
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since Angular has just been added, we need to define the root app module for
    Angular.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file, `app-ng1.module.js`, and copy the complete content of `app.module.ts`
    to the new file. We will use the `app.module.ts` file to define an Angular module
    and hence the existing AngularJS module has been shifted to a new file.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, remember to update the `import` statement in `app.ts` in line with the
    changes:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Let's now add the Angular root module definition to `app.module.ts`.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Replace the content of `app.module.ts` with the Angular module definition. Copy
    the new definition from `ng6-checkpoint8.2` (GitHub location: [http://bit.ly/ng6be-8-2-app-module-ts](http://bit.ly/ng6be-8-2-app-module-ts)).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AppModule` implementation defines a function, `ngDoBootstrap`:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The Angular framework invokes this function as part of the application bootstrap.
    This function internally uses the `bootstrap` function of `UpgradeModule` to bootstrap
    the AngularJS app. This function takes the same argument as the `angular.bootstrap`
    function takes.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'While we have defined the root module for Angular, we still have not defined
    the entry point for the Angular application. Create a new file, `main.ts`, in
    the app folder and add the following code:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This code, when executed, instructs the Angular framework to bootstrap the application
    with `AppModule`. The statement `import './app'` helps in loading all the script
    references in `app.ts`. Before proceeding, do remember to remove the AngularJS
    application bootstrapping code from `app.ts` (the complete `angular.element` block).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Refresh your app and make sure it works as before. Do watch out for errors in
    the TypeScript compiler console window or browser console log.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We now have a hybrid app up and running. Both frameworks are
    now working in tandem.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Look at the `ng6-checkpoint8.2` branch if you are facing issues upgrading to
    Angular. Again, you can also compare the git branches `ng6-checkpoint8.1` and
    `ng6- checkpoint8.2` to understand what has changed ([http://bit.ly/ng6be-compare-8-1-8-2](http://bit.ly/ng6be-compare-8-1-8-2)).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: The migration process can start now. We can start by migrating a part of an
    AngularJS view/directive to Angular.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Angular components into AngularJS views
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common migration pattern involves migrating lower-level AngularJS directives/views
    to Angular components. If we visualize the AngularJS HTML view structure as a
    tree of directives, we start at the leaf. We migrate parts of a directive/view
    to an Angular component and then embed the component inside the AngularJS view
    template. This Angular component is injected into the AngularJS view as an *element
    directive*.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: The closest thing to **Angular components** that AngularJS has is **element
    directives**. During migration, we are either migrating element directives or
    controller-view pairs.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a bottom-up approach to migrating view/directives to Angular components.
    The following diagram highlights how the AngularJS view hierarchy gradually transforms
    into an Angular component tree:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
- en: Let's migrate something small and get a feel for how things work. `ExerciseNavController`
    and its corresponding view fit the bill.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Migrating our first view to Angular component
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ExerciseNavController` is part of *Workout Builder* and is located inside
    `trainer/app/js/WorkoutBuilder/exercise.js`. The corresponding view is served
    from `trainer/app/partials/workoutbuilder/left-nav-exercises.html`.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary purpose of this controller-view pair is to show the list of available
    exercises when building a workout (available user path `http://localhost:8080/#/builder/workouts/new`):'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
- en: Clicking on any of these exercise names adds the exercise to the workout being
    constructed.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with creating a component for the preceding view.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting on the new component, add a new *Workout Builder* module (`WorkoutBuilderModule`)
    to the application. Copy the module definition from `ng6-checkpoint8.3` in the
    `WorkoutBuilder` folder (GitHub location: [http://bit.ly/ng6be-8-3-workout-builder-module-ts](http://bit.ly/ng6be-8-3-workout-builder-module-ts)).
    Also, import the newly created module in `app.module.ts`.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: Instead of inlining the complete code here, we suggest copying the `exercise-nav.component.ts`
    file from GitHub branch `ng6-checkpoint8.3` ([http://bit.ly/ng6be-8-3-exercise-nav-component-ts](http://bit.ly/ng6be-8-3-exercise-nav-component-ts))
    and adding it to the `WorkoutBuilder` folder locally. The file has already been
    referenced in `WorkoutBuilderModule`. We also add `ExerciseNavComponent` to `entryComponents`
    array as the component will be used from AngularJS module directly.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: From an implementation standpoint, let's look at some relevant parts.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Contrasting template syntaxThe Angular team has published an excellent reference
    ([http://bit.ly/ng2-a1-a2-quickref](http://bit.ly/ng2-a1-a2-quickref)) that details
    the common view syntaxes in AngularJS and their equivalents in Angular. Highly
    recommended when migrating an AngularJS app!
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, if you look at the `exercise-nav.component.ts` file, the component
    template is similar to `left-nav-exercises.html` used in AngularJS, except there
    is no `ng-controller` and the template bindings are Angular-based:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we focus on the component implementation (`ExercisesNavComponent`), the
    first striking thing is the component''s dependencies:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`WorkoutService` and `WorkoutBuilderService` are AngularJS services injected
    into Angular components.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Nice! If that is your initial reaction, we can't blame you. The ease with which
    we can inject AngularJS service into Angular is pretty cool! But the story is
    still incomplete. There is no magic happening here. Angular cannot access AngularJS
    services unless it is told where to look. To help Angular, we need to create *factory
    provider* wrappers for the AngularJS service.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Injecting AngularJS dependencies into Angular
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we allow an AngularJS service to be used in Angular, we are *upgrading*
    the service. The way it is done is by creating a **factory provider wrapper**
    over the existing AngularJS service and registering the wrapper with an Angular
    module or component.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Let's create wrappers for the two AngularJS services, `WorkoutService` and `WorkoutBuilderService`,
    that we have used in the last section.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: 'A factory provider for an AngularJS service can be created using Angular''s
    dependency injection API. Here is an example of a factory provider for `WorkoutService`:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this code, `$injector` is the AngularJS *injector service* and we are referencing
    the injector in the Angular execution context. The call to  `injector.get('WorkoutService');`
    in the previous factory function retrieves the service from AngularJS realm.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: 'The provider created can then be registered with the app module:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The shortcoming of this approach is that we have to define the factory function
    (`workoutServiceFactory`) and provider (`workoutServiceProvider`) for each service.
    That is too much code!
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can create a generic factory provider and factory function implementation,
    which can take any AngularJS service and register it with the same name (*string
    token*) in Angular. We have already done the hard work and created a new class, `UpgradeHelperService.`
    Download it from the codebase for `ng6-checkpoint8.3` ([http://bit.ly/ng6be-upgrade-helper-service-ts](http://bit.ly/ng6be-upgrade-helper-service-ts)).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation exposes a function, `upgradeService`, which takes one argument,
    the name of the AngularJS service, and returns a factory provider instance. The
    factory provider implementation internally uses a *string token* to register the
    dependency. To create a factory provider for an AngularJS service, we just need
    to call:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Service dependencies at times have other dependencies, and hence it''s better
    if we bring in all the service dependencies from AngularJS in one go. Register
    all the existing AngularJS dependencies as factory providers in `app.module.ts`:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Back to component integration! As the new  `ExercisesNavComponent` is rendered
    inside an AngularJS view, it needs to be registered as an *AngularJS directive*.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Registering Angular components as directives
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ExercisesNavComponent` can be converted into an AngularJS directive using
    `ngUpgrade` library function `downgradeComponent.` As the function name suggests,
    we are downgrading an Angular component into an AngularJS element directive.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app.ts` and add the highlighted lines:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `downgradeComponent` function returns a *factory function* containing the
    *directive definition object*. We register the component as an AngularJS directive,
    `exerciseNav`.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: Every Angular component is registered as an *element directive* when used in
    AngularJS.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: The component implementation is complete. We now need to clean up the old code
    and inject the new directive into the view.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: Delete the definition of `ExercisesNavController` from `exercise.js`.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the content of `left-nav-exercises.html` (located in the `partials`
    folder) with:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: And we are good to go.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Note that we do not get rid of `left-nav-exercises.html` as AngularJS still
    loads `left-nav-exercises.html` as part of the route transition, but the view
    inside is an Angular component.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try out the new implementation. Create a new workout and try to
    add exercises from the left nav. The functionality should work as before.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: Look at `ng6-checkpoint8.3` in case you are facing issues upgrading to Angular.
    You can compare the git branches `ng6-checkpoint8.2` and `ng6-checkpoint8.3` to
    understand what has changed ([http://bit.ly/ng6be-compare-8-2-8-3](http://bit.ly/ng6be-compare-8-2-8-3)).
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: While we have only migrated a trivial component, this exercise highlights how
    easy it is to convert/downgrade an Angular component to the AngularJS directive
    and use it in an AngularJS view. The overall encapsulation of an Angular component
    makes this chore easy.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 'This downgraded component can even take an input from the parent scope using
    the familiar Angular property binding syntax:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add to that, the event raised by the component can be subscribed by the AngularJS
    container scope too:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We now have an Angular component running inside AngularJS using services initially
    designed for AngularJS. A promising start to our migration journey!
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: Before we move any further, it's time to highlight how this collaboration works
    and the rules of engagement.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: Rules of engagement
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The migration story from AngularJS to Angular is only possible because these
    frameworks can coexist, and possibly share data. There are some touch points where
    the boundaries can be crossed. To have a better sense of how a hybrid application
    works and what is achievable in such a setup, we need to understand the areas
    of collaboration between the two frameworks.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three areas that need discussion:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Template interleaving in the DOM
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change detection
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Angular components and AngularJS directives can coexist in a DOM, the
    question we need to answer is who owns what parts of the DOM?
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS directives and Angular components
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to ownership of a DOM element, the golden rule is:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: Every DOM element is owned/managed by exactly one of the Angular frameworks.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: Take our previous migration example. The view that is part of `ExercisesNavComponent`
    is managed by Angular, whereas the container view (`left-nav-exercises.html`)
    is managed by AngularJS.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: 'Things get a bit tricky at the boundaries of these directives and components.
    Consider the declaration inside `left-nav-exercises.html`:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Who owns this? The short answer is AngularJS.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is an Angular component, the host element is owned by AngularJS.
    This means all AngularJS template syntax works:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As these components and directives coexist in the same view, they often need
    to communicate. There are two ways to manage this communication:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the templating capabilities of AngularJS and Angular:'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Angular component embedded inside an AngularJS view can take inputs from
    the parent scope using event and property binding
  id: totrans-600
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In a similar fashion, if a directive is injected into an Angular component view,
    it too can get inputs from the parent component and call the parent component
    function (through its isolated scope)
  id: totrans-601
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using shared services; we saw an example of this previously as we injected the
    `WorkoutService` and `WorkoutBuilderService` AngularJS services into `ExercisesNavComponent`
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting AngularJS directives into Angular is a bit tricky. To be able to inject
    an AngularJS directive into an Angular template, the directive needs to abide
    by some rules. We will talk about these rules in the coming sections.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Sharing functionality using services is far more flexible compared to sharing
    through view templates. Injecting services across framework boundaries requires
    us to register the service across both frameworks and let Angular take care of
    the rest. Let's learn how dependency injection works across boundaries.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Resource sharing and dependency injection
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How dependencies are registered in a hybrid app is driven by how DI works in
    these two frameworks. For AngularJS, there is only one global injector, whereas
    Angular has a concept of hierarchical injectors. In a hybrid environment, the
    least common denominator is the global injector that both the frameworks support.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Sharing an AngularJS service
  id: totrans-607
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the factory provider example earlier, AngularJS services can be
    registered with Angular by creating a wrapper factory provider.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: Since dependency injection in AngularJS is string token-based, the corresponding
    providers too use string tokens to locate dependencies in Angular.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at the example of dependency registration share earlier, the dependency
    was registered with a help of a helper class:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And it was injected using the `Inject` decorator (with a string token):'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Sharing an Angular service
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Services from Angular too can be injected into AngularJS. Since AngularJS only
    has a global injector, the dependency is registered at the global level. The `ngUpgrade`
    library has a `downgradeInjectable` function for this. The `downgradeInjectable` function
    creates a factory function than can be consumed by the AngularJS module''s `factory`
    API:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`MyService` can now be injected across the AngularJS app, like any other service.'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following diagram; it summarizes what we have discussed:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  id: totrans-619
  prefs: []
  type: TYPE_IMG
- en: One last topic of this discussion is change detection.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Change detection
  id: totrans-621
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a hybrid application, change detection is managed by Angular. If we are used
    to calling `$scope.$apply()` in our code, we don't need to do it in a hybrid application.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed how Angular change detection works. The Angular framework
    takes care of triggering AngularJS change detection by internally calling `$rootScope.$apply()`
    on standard triggering points.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the rules of engagement, it is easier to comprehend how
    things work, what's feasible, and what's not.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Let's set some bigger/meatier targets and migrate the start and finish pages
    of the v1 app.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the start and finish pages
  id: totrans-626
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The finish page migration is easy to do, and I suggest you do it yourself. Create
    a folder called `finish` inside the `js` folder, and create two files, `finish.component.ts`
    and  `finish.component.html`. Implement the component by looking at the existing
    implementation (or copy it from `ng6-checkpoint8.4`).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: Add the component to the `declarations` and `entryComponents` array on  `AppModule`
    (`app.module.ts`). And then, fix the route for the finish to load the finish component.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to also downgrade `FinishComponent` using the `downgradeComponent`
    function (check `app.ts`) and to fix the AngularJS *finish route* to use the new
    directive:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Lastly, remember to delete the finish HTML template from the `partials/workout`
    folder.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: If you are stuck in migrating the finish page, compare the `ng6-checkpoint8.3`
    and `ng6-checkpoint8.4` git branches to understand what has changed in the `8.4`
    branch ([http://bit.ly/ng6be-compare-8-3-8-4](http://bit.ly/ng2be-compare-8-3-8-4)).
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: The finish page was easy, the start page is not! While the start page seems
    to be an easy target, there are some challenges that require some head-scratching.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: Look at the start page template (`partials/workout/start.html`); the biggest
    issue with the start page is that it uses a third-party library, *angular-translate*,
    to localize the content of the page. Since we are migrating the complete page/view
    to Angular, we need a mechanism to handle these AngularJS library dependencies.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '*angular-translate* comes with a *filter* (*pipe* in the Angular world) and
    a directive, both named `translate`. Their job is to translate string tokens into
    localized string literals.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: If the *start* page becomes an Angular component, we need to convert the filter
    into an Angular pipe and, in some way, make the `translate` directive work in
    Angular.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 'We have at least these two choices to handle this migration scenario:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Create a new filter, also upgrade the v1 `translate` directive using `UpgradeModule`
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a suitable replacement for *angular-translate* in the Angular world
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the first choice seems to be the easiest, it has some serious limitations.
    Angular imposes some stringent requirements around how a directive can be upgraded
    to Angular.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading an AngularJS directive does not mean the directive has been migrated.
    Angular instead allows us to use an AngularJS element directive as is inside Angular
    component views.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS directive upgrade
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At times, the parts of an application may be migrated in a top-down fashion;
    a higher-order view is converted into a component. In such a case, instead of
    migrating all the custom directives that are part of the AngularJS view, we just
    upgrade them to Angular components using some interfaces and functions defined
    in the  `UpgradeModule`. The following diagram illustrates this migration path:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
- en: The Angular framework puts some restrictions on what can be upgraded to an Angular
    component. Here is an excerpt from the Angular migration guide.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: 'To be Angular compatible, an AngularJS component directive should configure
    these attributes:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '`restrict: ''E''`. Components are usually used as elements.'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope: {}` - an isolate scope. In Angular, components are always isolated
    from their surroundings, and you should do this in AngularJS too.'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bindToController: {}`. Component inputs and outputs should be bound to the
    controller instead of using the `$scope`.'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controller and controllerAs`. Components have their own controllers.'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template or templateUrl`. Components have their own templates.'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Component directives may also use the following attributes:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '`transclude: true/{}`, if the component needs to transclude content from elsewhere'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require`, if the component needs to communicate with some parent component''s
    controller'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Component directives should not use the following attributes:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '`compile`. This will not be supported in Angular.'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace`: True. Angular never replaces a component element with the component
    template. This attribute is also deprecated in AngularJS.'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`priority` and `terminal`. While AngularJS components may use these, they are
    not used in Angular and it is better not to write code that relies on them.'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only AngularJS directives that can be upgraded to Angular are element directives,
    given that all other conditions are met.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: With this sizeable laundry list, upgrading an AngularJS directive to Angular
    is difficult when compared to an Angular component downgrade. More often than
    not, we have to do an actual code migration of an AngularJS directive if the parent
    view has been migrated to Angular.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `angular-translate` source code, we realize it uses the `$compile`
    service; therefore, the upgrade option is ruled out. We need to find an alternative
    library.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: We do have an internationalization library for Angular, `ngx-translate` ([http://www.ngx-translate.com/](http://www.ngx-translate.com/)).
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: Replacing angular-translate with ngx-translate
  id: totrans-663
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*ngx-translate* is an internationalization library that targets Angular. This
    library can replace v1 *angular-translate*.'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the npm package for `ngx-translate` and `ngx-translate/http-loader`:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The *http-loader* loads the localization files from the server.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `systemjs.config.js` to include the `*ngx-translate*` library. Add entries
    to the `map` property:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As described in the `ngx-translate` documentation, we need to configure the
    translate module and HTTP loader. Open `app.module.ts` and add the highlighted
    code:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The preceding provider declaration sets up a loader that loads the translation
    files (`.json`) from the `i18n` folder. The `HttpClientModule` import is required
    for the translate library to load translations from the server. Remember to copy
    the translation files (`*.json`) from git branch `ng6-checkpoint8.4` ([http://bit.ly/ng6be-8-4-i18n](http://bit.ly/ng6be-8-4-i18n)).
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these import statements to `app.module.ts` to keep the TypeScript compiler
    happy:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `ngx-translate` library is now ready to be used. The first thing that we
    are going to do is set the default translation language as soon as the application
    bootstraps.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: Using ngDoBootstrap for initialization
  id: totrans-676
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Angular, luckily the `AppModule` already defines a function, `ngDoBootstrap`,
    that the framework calls when bootstrapping an AngularJS application—a perfect
    place to do `ngx-translate` initialization. Update the `ngDoBootstrap` function
    in `app.module.ts` with the following code snippet:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The code tries to determine the current browser language and sets the current
    language for translations accordingly. Make note of how we get hold of `TranslateService`.
    The `UpgradeModule` object holds the reference to Angular's *root injector*, which
    in turn loads `TranslateService` from `ngx-translate`.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: With the background work done for the start component, copy the start page implementation
    from the `ng6-checkpoint8.4` branch ([http://bit.ly/ng6be-8-4-start](http://bit.ly/ng6be-8-4-start))
    into a new folder `app/js/start`.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: Then, add the start component declaration to `app.module.ts`.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 'Like other components registered as an AngularJS directive before use, add
    this statement to `app.ts`:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The start template file now uses the `translate` pipe (the name of the pipe
    is the same as the AngularJS filter `translate`).
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'The start page also has three pipes, `search`, `orderBy`, and `secondsToTime`:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Copy the implementation for these pipes together with the definition of the
    shared module (`shared.module.ts`) from `ng6-checkpoint8.4` ([http://bit.ly/ng6be-8-4-shared](http://bit.ly/ng6be-8-4-shared))
    and add it to the `js/shared` folder locally. Also, remember to import the shared
    module (`shared.module.ts`) into the app module (`app.module.ts`). We will not
    dwell on any of the pipe implementation here, as we have done that already in
    earlier chapters.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: Start and finish component implementation is complete. Let's integrate them
    into the app.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the start and finish pages
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start/finish views are loaded as part of route change, so we need to fix the
    route definition in `config.js`. Update the start and finish route definitions
    to:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The route template HTML is a part of the AngularJS view. Since we have registered
    both `StartComponent` and `FinishComponent` as AngularJS directives, the route
    loads the correct components.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: If you have already migrated the finish page, you do not need to redo the route
    setup for finish as described.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: A few more fixes are pending before we can test the implementation.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: Remember to copy the translation files `de.json` and `en.json` from the `ng6-checkpoint8.4`
    folder `i18n` ([http://bit.ly/ng6-8-4-i18n](http://bit.ly/ng6be-8-4-i18n)). Now,
    we are ready to test what we have developed.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: If not started, start the TypeScript compiler and HTTP-server, and then launch
    the browser. The start and finish pages should load just fine. But the translations
    do not work! Clicking on the language translation links on the top nav has no
    effect. Content always renders in English.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: We now are at checkpoint `ng6-checkpoint8.4`. If you are stuck, compare the
    git branches `ng6-checkpoint8.3` and `ng6-checkpoint8.4` to understand what changed
    ([http://bit.ly/ng6be-compare-8-3-8-4](http://bit.ly/ng6be-compare-8-3-8-4)).
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: The translations still do not work because the top nav code (`root.js`) that
    enables translation is still using the older library. We need to get rid of angular-translate
    (the v1 library) altogether. Having two libraries doing the same work is not something
    we want, but removing it is also not that simple.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: Getting rid of angular-translate
  id: totrans-699
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get rid of the angular-translate (v1) library, we need to:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: Remove the angular-translate's directive/filter references from all AngularJS
    views
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get rid of any code that uses this library
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting rid of the v1 directive/filter altogether is a difficult task. No can
    we use the v2 `ngx-translate` pipe in the AngularJS view. Also, migrating every
    view using the v1 translate directive/filter to Angular at one shot is feasible.
    There has to be a better solution out there? And there is!
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: Why not write a new AngularJS filter that uses ngx-translate's translation service
    (`TranslateService`) for translations and then use the new filter everywhere?
    Problems solved!
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: Let's call this filter `ngxTranslate`. We replace all references to the `translate`
    filter in the v1 view with `ngxTranslate`. All v1 `translate` directive references
    too are replaced with an `ngxTranslate` filter.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the filter implementation looks:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create a file called `ngx-translate.filter.ts` in the `shared` folder and add
    the preceding implementation. The filter uses `TranslateService` to localized
    content. To make the service discoverable in AngularJS, it needs to be downgraded
    using the `ngUpgrade` module method `downgradeInjectable`. Open  `app.ts` and
    add the following lines:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This code registers `TranslateService` using a string token, `'TranslateService'`,
    in AngularJS. The first import statement also loads the new filter at runtime.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: To test this implementation, there are a few more steps needed.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, replace all references to `translate` (directive and filter)
    across the AngularJS view with `ngxTranslate`. There are references in these files:
    `description-panel.html`, `video-panel.html`, `workout.html` (in the folder `partials/workout`),
    and `index.html`. Replacing the filter in the interpolation is a simple exercise.
    For the `translate` directive, replace it with interpolation. For example, in
    `partials/workout/description-panel.html`, the line of code is as follows:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It then becomes the following:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Remember to quote the string token (`'RUNNER.STEPS'`) inside the interpolation.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: Finally, copy the updated `root.js` from [http://bit.ly/ng6be-8-5-root-js](http://bit.ly/ng6be-8-5-root-js).
    We have replaced all references to the `$translate` service with `TranslateService` and
    refactored the code to use the new service. `root.js` contains the implementation
    for the v1 `RootController`.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: We are good to go now. Try out the new implementation; the app should load translation
    using the *ngx-translate* library.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: We can now delete all references to *angular-translate*. There are references
    in `index.html`, `app-ng1.module.ts`, and `config.js`.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: The migration of the start and finish pages is complete.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: Compare the branches `ng6-checkpoint8.4` and `ng6-checkpoint8.5` to understand
    the new changes in `ng6-checkpoint8.5` ([http://bit.ly/ng6be-compare-8-4-8-5](http://bit.ly/ng2be-compare-8-4-8-5)).
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: We will stop here and direct you to the other GitHub branches pertaining to
    migration. All branches starting with `ng6-checkpoint*` are the migration branches.
    Try to migrate the pending views and compare them with the GitHub branch changes.
    Remember, a working version of the app has already been developed in Angular,
    and hence there is a good reference point. Look at the `README.md` file for each
    branch to know what part of the application was migrated to Angular.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, let's summarize our learnings from the migration that we did.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: Learning
  id: totrans-724
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We hope this migration exercise has provided enough insight into the process.
    You can now gauge the complexity, the time, and the effort required to migrate
    elements from AngularJS to Angular. Let''s highlight what we have learned as part
    of this process:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration is time-consuming**: Migration is by no stretch of the imagination
    a trivial exercise. Each page/view presents its own challenges that we need to
    overcome. Some elements are easy to migrate and some are not. The best thing you
    can do today if you are developing in AngularJS would be to follow the advice
    from the *Developing AngularJS apps today for easy migration* section.'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Migrate third-party libraries first**: Migrating third-party libraries can
    be quite challenging. The reasons are manifold:'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such libraries are used across pages
  id: totrans-728
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They may not be upgradable to Angular (using `UpgradeAdapter`)
  id: totrans-729
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating each view that uses such a library may not be feasible when the library
    is extensively used
  id: totrans-730
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It's better to identify all third-party dependencies in your app and find a
    suitable alternative for them in the Angular world. If possible, develop some
    **proof of concept** (**POC**) with the new library to understand how different
    the new library is from the existing implementation.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: '**Libraries with overlap may exist**: While migrating, there could be scenarios
    where both AngularJS and Angular versions of a library coexist. Minimize this
    time period and migrate to the newer version as soon as possible.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It is easier to integrate Angular components into AngularJS than the other
    way round**: While migrating, migrate the complete view to Angular. Due to the
    restriction imposed by Angular, it becomes very difficult to have a parent Angular
    component with embedded AngularJS element directives. With such limitations, a
    bottom-up approach to migrating works better than a top-down approach.'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anything non-UI-related is easy to migrate**: For *Personal Trainer*, we
    migrate the services last as they can be easily migrated.'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature parity better AngularJS and Angular**: Angular may not have every
    feature that AngularJS supports. In such a case, we need workarounds to achieve
    the desired behavior.'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That completes our migration story. With this, it's time to conclude the chapter
    and summarize our lessons from it.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-737
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained some useful insight into a number of practical issues
    surrounding Angular development. These tips/guidelines can be extremely handy
    when building real-life applications using the framework.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by exploring the concept of *seed projects* and how these
    projects can get us up and running in no time. We looked at some popular seed
    projects that can serve as a base for any new Angular app development.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: In spite of being a server-side concern, authentication and authorization do
    affect the client implementation. The section on authentication/authorization
    covered how to handle authentication in both cookie- and token-based setups.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the ever-so-important topic of performance, where you learned ways
    to optimize an Angular app's performance.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we migrated the v1 *Personal Trainer* to Angular. The gradual migration
    process taught us the intricacies of migration, the challenges faced, and the
    workaround done.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: The book is coming to a close, but for everyone reading it, the journey has
    just begun. It's time to put theories into practice, hone our newly acquired skills,
    build something useful with Angular, and share it with the world. The more you
    invest in Angular, the more rewarding the framework is. Let's get started!
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
