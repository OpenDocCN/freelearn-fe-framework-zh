- en: 1.21 Gigawatt – Flux Pattern Explained
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.21吉瓦 – Flux模式解释
- en: 'Let''s first off explain our title. What do we mean by 1.21 Gigawatt? I''m
    going to quote the character Doc Brown from the movie *Back to the Future* ([http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu](http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu)):'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们先来解释一下我们的标题。我们所说的1.21吉瓦是什么意思？我将引用电影《回到未来》中的角色Doc Brown的话（[http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu](http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu)）:'
- en: '"Marty, I''m sorry, but the only power source capable of generating 1.21 gigawatts
    of electricity is a bolt of lightning."'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '"马蒂，我很抱歉，但唯一能够产生1.21吉瓦电力的电源是一道闪电。"'
- en: 'Why are we talking about the movie Back to the Future? This is where the name
    Flux comes from. It''s time for another quote from the same movie:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要谈论电影《回到未来》？这就是Flux这个名字的由来。现在，是时候从同一部电影中引用另一句话了：
- en: '"Yes! Of course! November 5, 1955! That was the day I invented time-travel.
    I remember it vividly. I was standing on the edge of my toilet hanging a clock,
    the porcelain was wet, I slipped, hit my head on the sink, and when I came to
    I had a revelation! A vision! A picture in my head! A picture of this! This is
    what makes time travel possible: the **flux** capacitor!"'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的！当然！1955年11月5日！那就是我发明时间旅行的日子。我记忆犹新。我站在马桶边缘挂钟，瓷器是湿的，我滑倒了，头撞到了水槽上，当我醒来时，我有一个启示！一个愿景！一个脑海中的画面！这就是这个画面！这就是使时间旅行成为可能的原因：**flux**电容器！"'
- en: So as you can see, there is an explanation for the name Flux. It obviously allows
    us to travel in time. At least for Redux, which we will write about later in this
    book, time travel is possible through something called time-travel debugging.
    Whether that needs a bolt of lightning is for you to find out dear reader.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你所看到的，Flux这个名字有一个解释。它显然允许我们进行时间旅行。至少对于Redux来说，我们将在本书的后面部分讨论，时间旅行可以通过称为时间旅行调试的东西来实现。是否需要一道闪电，亲爱的读者，将由你来发现。
- en: Flux is an architectural pattern created by Facebook. It came about as it was
    perceived that the MVC pattern simply did not scale. It did not scale for large
    code bases as they tended to become fragile, generally complicated as more and
    more features were added, and most of all, unpredictable. Now let's hang on that
    word for a second, unpredictable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Flux是由Facebook创建的一种架构模式。它是在人们意识到MVC模式根本无法扩展的情况下出现的。对于大型代码库来说，它无法扩展，因为它们往往变得脆弱，随着越来越多的功能被添加，通常变得复杂，最重要的是，不可预测。现在让我们暂停一下，关注一下“不可预测”这个词。
- en: 'Large systems were thought to become unpredictable due to their bidrectional
    data flow between models and views when the number of models and views really
    grew, as depicted in the following diagram:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 人们认为大型系统变得不可预测，因为当模型和视图的数量真正增长时，它们在模型和视图之间出现了双向数据流，如下面的图所示：
- en: '![](img/100fc94f-7809-4ac9-b96d-d4b6ed0853d0.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/100fc94f-7809-4ac9-b96d-d4b6ed0853d0.png)'
- en: Here, we can see that the number of models and views is starting to grow. Everything
    is somewhat under control as long as one model talks to one view and vice versa.
    This is, however, seldom the case. In the preceding diagram, we see that suddenly
    a view can talk to more than one model and vice versa, which means we have a cascading
    effect on the system and we suddenly lose control. Sure, it doesn't look so bad
    with just one deviating arrow, but imagine that this one is suddenly ten arrows,
    then we have a real problem on our hands.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到模型和视图的数量开始增长。只要一个模型与一个视图通信，反之亦然，一切似乎都在控制之中。然而，这种情况很少发生。在前面的图中，我们可以看到视图突然可以与多个模型通信，反之亦然，这意味着系统出现了级联效应，我们突然失去了控制。当然，只有一个偏离的箭头看起来并不那么糟糕，但想象一下，如果这是一十个箭头，那么我们真的会遇到大问题。
- en: It is the very fact that we allow bidrectional data flows to happen that things
    get complicated and we lose predictability. The medicine or cure for that is thought
    to be a simpler type of data flow, a unidirectional flow. Now, there are some
    key players involved in enabling undirectional data flow, which brings us to what
    this chapter is meant to teach us.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为我们允许双向数据流发生，事情才变得复杂，我们失去了可预测性。针对这种情况的药物或治疗方法被认为是一种更简单的数据流类型，即单向流。现在，有一些关键角色参与启用单向数据流，这把我们带到了本章旨在教给我们的内容。
- en: 'In this chapter, we will learn:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: What an action and an action creator are
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作和动作创建者的定义
- en: How the dispatcher plays a central role in your application as a hub for messages
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发器如何在您的应用程序中扮演中心角色，作为消息的中心
- en: State management with a store
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存储进行状态管理
- en: How to put our knowledge of Flux into practice by coding up a Flux application
    flow
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过编写 Flux 应用程序流程来将我们对 Flux 的知识付诸实践
- en: Core concepts overview
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心概念概述
- en: At the core of the Flux pattern is a unidirectional data flow. It uses some
    core concepts to achieve this flow. The main idea is when an event is created
    on a UI, through the interaction of a user, an action is created. This action
    consists of an intent and a payload. The intent is what your are trying to achieve.
    Think of the intent as a verb. Add an item, remove an item, and so on. The payload
    is the data change that needs to happen to achieve our intent. If we are trying
    to add an item, then the payload is the newly created item. The action is then
    propagated in the flow with the help of a dispatcher. The action and its data
    eventually end up in a store.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 模式的核心是一个单向数据流。它使用一些核心概念来实现这种流。主要思想是当在 UI 上创建一个事件，通过用户的交互，会创建一个动作。这个动作由意图和有效载荷组成。意图是你试图实现的目标。将意图视为一个动词。添加项目、删除项目等等。有效载荷是需要发生以实现我们意图的数据更改。如果我们试图添加一个项目，那么有效载荷就是新创建的项目。然后，在调度器的帮助下，动作在流程中传播。动作及其数据最终进入存储。
- en: 'The concepts that make up the Flux pattern are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 构成 Flux 模式的概念包括：
- en: Action and action creators, where we set up an intention and a payload of data
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作和动作创建者，其中我们设置了一个意图和数据有效载荷
- en: The dispatcher, our spider in the web that is able to send messages left and
    right
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器，我们网络中的蜘蛛，能够左右发送消息
- en: The store, our central place for state and state management
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储，我们中央的状态和状态管理的地方
- en: 'All these together form the Flux pattern and promote unidirectional data flow.
    Consider the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些共同构成了 Flux 模式，并促进了单向数据流。考虑以下图示：
- en: '![](img/01e73ee8-9f3d-4376-8718-597c54d94836.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01e73ee8-9f3d-4376-8718-597c54d94836.png)'
- en: 'What is depicted here is a undirectional data flow. The data flows from **View**
    to **Action**, from **Action** to **Dispatcher**, from **Dispatcher** to **Store**.
    There are two possible ways that the flow is triggered:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的是一个非方向性数据流。数据从**视图**流向**动作**，从**动作**流向**调度器**，从**调度器**流向**存储**。触发流程有两种可能的方式：
- en: The application is loaded a first time, in which the data is pulled from the
    **Store** to populate the view.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序首次加载时，数据将从**存储**中拉取以填充视图。
- en: A user interaction happens in the view that leads to an intent to change something.
    The intent is encapsulated in an **Action**, and thereafter sent to the **Store**,
    via the **Dispatcher**. At the **Store**, it may be persisted in a database, through
    an **API** or saved as an application state, or both.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图中发生用户交互，导致改变某物的意图。这个意图封装在一个**动作**中，然后通过**调度器**发送到**存储**。在**存储**中，它可能通过**API**持久化到数据库中，或保存为应用程序状态，或者两者兼而有之。
- en: Let's dive into each concept in more detail, together with highlighting some
    code examples, in the upcoming sections.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的章节中更详细地探讨每个概念，同时突出一些代码示例。
- en: A uniform data flow
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一数据流
- en: 'Let''s introduce all parties involved in our uniform data flow by starting
    from the very top and slowly work our way down, concept by concept. We will build
    an application consisting of two views. In the first view, the user will select
    an item from a list. This should result in an action being created. This action
    will then be dispatched, by the dispatcher. The action and its payload will end
    up in a store. The other view meanwhile listens to changes from the store. When
    an item is selected, the second view will be made aware and can therefore indicate
    in its UI that a specific item has been selected. On a high level, our application
    and its flow will look like the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最顶层开始介绍我们统一数据流中的所有参与者，并逐步向下，概念到概念。我们将构建一个包含两个视图的应用程序。在第一个视图中，用户将从列表中选择一个项目。这应该会导致创建一个动作。然后，通过调度器，这个动作将被分发。动作及其有效载荷将最终进入存储。与此同时，另一个视图监听存储的变化。当选择一个项目时，第二个视图将得知并可以在其用户界面中指示已选择特定项目。从高层次来看，我们的应用程序及其流程将如下所示：
- en: '![](img/7d4d0bd5-2b05-4d97-b471-d26c97a9f49c.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d4d0bd5-2b05-4d97-b471-d26c97a9f49c.png)'
- en: Action – capture the intent
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作 – 捕获意图
- en: An action is something as simple as an intent with accompanying data, that is,
    a message. How does an action come about though? An action comes about when a
    user interacts with a UI. The user may select a specific item in a list or a press
    a button with the intention of submitting a form. Submitting the form should,
    in turn, lead to a product being created.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是像意图伴随数据一样简单的东西，即消息。然而，动作是如何产生的呢？动作是在用户与UI交互时产生的。用户可能在列表中选择一个特定的项目，或者按下按钮以提交表单。提交表单应该反过来导致创建一个产品。
- en: 'Let''s look at two different actions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两种不同的动作：
- en: Selecting an item in a list, here we are interested in saving the index of our
    selected item
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中选择一个项目，我们感兴趣的是保存所选项目的索引
- en: Saving a todo to a todo list
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将待办事项保存到待办事项列表
- en: 'An action is represented by an object. The object has two properties of interest:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 动作由一个对象表示。该对象有两个有趣的属性：
- en: 'The type: This is a unique string that tells us the intention of the action,
    for example, `SELECT_ITEM`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型：这是一个唯一的字符串，告诉我们动作的意图，例如，`SELECT_ITEM`
- en: 'The data: This is the data we mean to persist, for example, the numerical index
    of a selected item'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据：这是我们打算持久化的数据，例如，所选项目的数值索引
- en: 'Given our first example action, a code representation of that action would
    look like the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们的第一个示例动作，该动作的代码表示如下：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: OK, so we have prepared our action, which we can also think of as a message.
    We want the message to be sent so that the selected item is highlighted in the
    UI. As this is a undirectional flow, we need to follow a charted course and pass
    our message over to the next party, which is the dispatcher.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们已经准备好了我们的动作，我们也可以将其视为消息。我们希望消息被发送，以便在UI中突出显示所选项目。由于这是一个单向流，我们需要遵循既定的路线，并将我们的消息传递给下一方，即调度器。
- en: Dispatcher – the spider in the web
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器 – 网络中的蜘蛛
- en: 'Think of the dispatcher as the spider in the web that handles messages being
    passed to it. You can also think of the dispatcher as a mailman who promises that
    your message will reach its target destination. A dispatcher lives, for one thing,
    to dispatch messages to anyone who will listen. There is usually just one `dispatcher`
    in a Flux architecture and a typical usage looks something like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将调度器视为网络中处理传递给它的消息的蜘蛛。你也可以将调度器视为一个邮递员，他承诺你的消息将到达目标目的地。调度器存在的一个原因是为了将消息发送给任何愿意监听的人。在一个Flux架构中通常只有一个`dispatcher`，典型的用法看起来像这样：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Listening to the dispatcher
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听调度器
- en: 'We have established that the dispatcher dispatches a message to anyone who
    will listen. Now it is time to be that listener. The dispatcher needs a `register`
    or `subscribe` method so that you, who listens, have the ability to listen for
    incoming messages. The setup for that usually looks something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定调度器将消息发送给任何愿意监听的人。现在是我们成为那个监听者的时刻。调度器需要一个`register`或`subscribe`方法，这样你，作为监听者，就有能力监听传入的消息。这种设置的通常看起来是这样的：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, when you set up a listener this way, it will have the capability to listen
    to any message type being sent. You want to narrow this down; usually, a listener
    is specified to only handle a few message types around a certain theme. Your listener
    most likely looks something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你以这种方式设置监听器时，它将能够监听任何正在发送的消息类型。你希望缩小这个范围；通常，监听器被指定为只处理围绕某个主题的少数几种消息类型。你的监听器可能看起来像这样：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'OK, so we are able to filter out only the message types we care about, but
    before actually filling in some code we need to think about who this listener
    is. The answer is simple: it is the store.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们能够过滤出我们关心的消息类型，但在实际填写代码之前，我们需要考虑这个监听者是谁。答案是简单的：它是存储。
- en: The store – managing state, data retrieval, and callbacks
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储 – 管理状态、数据检索和回调
- en: 'It''s easy to think of the store as the place where our data lives. That is,
    however, not all it is. What the store''s responsibilities are can be expressed
    by this list:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 容易将存储视为我们的数据所在的地方。然而，这并不是它的全部。存储的职责可以通过以下列表来表示：
- en: Holder of state
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持有状态
- en: Manages the state, able to update it if need be
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理状态，能够在需要时更新它
- en: Able to handle side effects such as fetching/persisting data through HTTP
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理副作用，例如通过HTTP获取/持久化数据
- en: Handles callbacks
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理回调
- en: 'As you can see, that is a bit more than just storing the state. Let''s now
    reconnect to what we were doing when we set up a listener with the `dispatcher`.
    Let''s move that code into our store file, `store.js`, and let''s persist our
    message content in our store:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这不仅仅是存储状态。现在让我们重新连接到我们在设置`dispatcher`监听器时所做的操作。让我们将这段代码移动到我们的存储文件`store.js`中，并将我们的消息内容持久化到存储中：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: OK, so now the store is being told about the new index, but an important piece
    is missing, how do we tell the UI? We need a way to tell the UI that something
    has changed. A change means that the UI should reread its data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以现在存储已经被告知新的索引，但缺少一个重要的部分，我们如何告诉UI？我们需要一种方法来告诉UI发生了变化。变化意味着UI应该重新读取其数据。
- en: The view
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: 'To tell the view that something has happened and act on it, three things need
    to happen:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉视图发生了什么并对其采取行动，需要发生三件事：
- en: The view needs to register with the store as a listener
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图需要向存储注册为监听器
- en: The store needs to send off an event conveying that a change has happened
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储需要发出一个事件，传达已发生更改
- en: The view needs to reload its data
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图需要重新加载数据
- en: 'Starting with the store, we need to build it out so that you can register as
    a listener to its events. We therefore add the `addListener()` method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从存储开始，我们需要构建它，以便您可以注册为它的事件监听器。因此，我们添加了`addListener()`方法：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we also add the ability to emit an event with the addition
    of the `emitChange()` method. You can easily switch out this implementation to
    use an `EventEmitter` or similar. So now is the time to hook up our view to the
    store. We do so by calling the `addListener()` method like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们还添加了通过添加`emitChange()`方法来发出事件的能力。您可以通过轻松切换此实现来使用`EventEmitter`或类似的东西。所以现在是我们将视图连接到存储的时候了。我们通过调用`addListener()`方法来实现这一点：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we implement the `notifyChanged()` method, which when
    called invokes the `getSelectedItem()` method from the store and thereby receives
    the new value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实现了`notifyChanged()`方法，当调用该方法时，它会从存储中调用`getSelectedItem()`方法，从而接收新的值。
- en: 'At this point, we have described the whole chain: how one view receives a user
    interaction, turns that into an action, which is then dispatched to a store, which
    updates the store''s state. The store then emits an event that the other view
    is listening to. When the event is received, in the view the state from the store
    is reread and the view is then free to render this state, which it just read in,
    the way it sees fit.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经描述了整个链：一个视图如何接收用户交互，将其转换为动作，然后将其分发给存储，存储更新其状态。存储随后发出一个事件，另一个视图正在监听这个事件。当接收到事件时，视图会重新读取存储的状态，然后视图可以自由地以它认为合适的方式渲染它刚刚读取的状态。
- en: 'We have described two things here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们描述了两件事：
- en: How to set up the flow
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置流程
- en: How the information flows in Flux
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux中信息流的方式
- en: 'Setting up the flow can be depicted with the following diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 设置流程可以用以下图表表示：
- en: '![](img/8f71e618-477b-4d27-a8d6-3704673d6609.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f71e618-477b-4d27-a8d6-3704673d6609.png)'
- en: 'As for the second scenario, how the information flows through the system, it
    can be depicted in the following way:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个场景，信息在系统中的流动可以以下方式表示：
- en: '![](img/754e1c56-ddb8-4214-8af8-2d461f20fa18.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/754e1c56-ddb8-4214-8af8-2d461f20fa18.png)'
- en: Demoing a uniform data flow
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示统一数据流
- en: 'Ok, so we have described the parts our application consists of:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们已经描述了我们的应用程序由哪些部分组成：
- en: A view where a user is able to select an index
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户可以从中选择索引的视图
- en: A dispatcher that allows us to send a message
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个允许我们发送消息的分发器
- en: A store that contains our selected index
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含我们选择索引的存储
- en: A second view where the selected index is read from the store
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从存储中读取选择索引的第二个视图
- en: Let's build a real app from all of this. The following code is found in the
    code repository under `Chapter2/demo`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从所有这些构建一个真正的应用程序。以下代码位于代码库中的`Chapter2/demo`目录下。
- en: Creating a selection view
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建选择视图
- en: 'First off we need our view in which we will perform the selection:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要我们的视图，在其中我们将执行选择操作：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have bolded the `selectIndex()` method above that we intend to use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面的`selectIndex()`方法上加了粗体，这是我们打算使用的。
- en: Adding the dispatcher
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加分发器
- en: 'Next off we need a dispatcher that is able to take our message, like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个能够接收我们的消息的分发器：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding the store
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加存储
- en: 'The store will act as the data source for our state but will also be able tell
    any listeners when a change to the store happens:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 存储将作为我们状态的数据源，但也可以告诉任何监听器存储何时发生变化：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding a selected view
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个选择视图
- en: 'This view will register itself with the store and ask for updates to its content.
    If there are any updates it will be notified and the data from the store will
    be read and this view will communicate what the store value now is:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图将向存储注册自己并请求其内容的更新。如果有任何更新，它将收到通知，并从存储中读取数据，然后这个视图将传达存储的当前值：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running the demo
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行演示
- en: 'Before we can run our demo we need an application file, `app.js`. The `app.js`
    file should require in our views and also carry out the selection:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够运行我们的演示之前，我们需要一个应用程序文件，`app.js`。`app.js`文件应该引入我们的视图并执行选择：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To run our demo we need to compile it. Above we are using ES2015 modules. To
    compile those we will use `webpack`. We need to install `webpack` by typing the
    following in our terminal:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行我们的演示，我们需要编译它。上面我们使用ES2015模块。为了编译这些模块，我们将使用`webpack`。我们需要在终端中键入以下内容来安装`webpack`：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we have done so we need to create `webpack.config.js` file where we tell
    Webpack how to compile our files and where to place the resulting bundle. That
    file looks like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们需要创建一个`webpack.config.js`文件，告诉Webpack如何编译我们的文件以及将结果包放在哪里。这个文件看起来如下：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This tells Webpack that `app.js` is the entry point to our application and it
    should crawl all the dependencies when creating the output file, `bundle.js`.
    Webpack will by default place `bundle.js` in the `dist` directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Webpack，`app.js`是应用程序的入口点，它应该在创建输出文件`bundle.js`时爬取所有依赖项。Webpack默认将`bundle.js`放在`dist`目录中。
- en: 'One more thing, we need an HTML file that we will name `index.html`. We will
    place under the `dist` folder. It should look like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再说一件事，我们需要一个名为`index.html`的HTML文件。我们将将其放在`dist`文件夹下。它应该看起来像这样：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, to run our application, we need to compile it with Webpack and start
    a HTTP server and start up a browser. We will do all that with the following command
    from the `demo` directory:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了运行我们的应用程序，我们需要用Webpack编译它，启动一个HTTP服务器并启动一个浏览器。我们将使用以下命令从`demo`目录中完成所有这些：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, start a browser and navigate to `http://localhost:5000`. You should see
    the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动一个浏览器并导航到`http://localhost:5000`。你应该看到以下内容：
- en: '![](img/e6e36d83-970c-4c21-a65c-331129d78474.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6e36d83-970c-4c21-a65c-331129d78474.png)'
- en: All of this demonstrates how to views can be made to communicate using a dispatcher
    and a store.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都展示了如何通过使用`dispatcher`和存储使视图能够进行通信。
- en: Adding more actions to our flow
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的流程中添加更多动作
- en: Let's do a reality check here. We haven't built the Flux flow as prettily as
    we could make it. The overall picture is correct but it'd be nice if we can clean
    it up a bit to make room for more actions so we get a real sense of how the application
    should grow from here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里做一个现实检查。我们没有像我们本可以做的那样把Flux流程做得那么漂亮。整体图景是正确的，但如果我们可以稍微清理一下，为更多的动作腾出空间，那么我们就能真正感受到应用程序应该如何从这里开始增长。
- en: Cleaning up the view
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理视图
- en: 'The first order of business is to have a look at our first view and how it
    reacts to user interactions. It looks like this currently:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是看看我们的第一个视图以及它是如何响应用户交互的。它目前看起来是这样的：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Adding a few more actions into the mix means we would extend the view with
    a few methods like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合中添加更多动作意味着我们需要扩展视图以包含一些方法，如下所示：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'OK, so now we get how we can add actions. It looks a little ugly though with
    all these calls to the `dispatcher` and magic strings, so we clean this up a bit
    by creating a file with constants, called `product.constants.js`, which consists
    of the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以现在我们知道了如何添加动作。不过，由于所有这些对`dispatcher`和魔法字符串的调用，它看起来有点丑陋，所以我们通过创建一个包含常量的文件来清理一下，这个文件叫做`product.constants.js`，它包含以下代码：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s do one more thing. Let''s move the `dispatcher` into a `product.actions.js`;
    this is generally known as an action creator. This will contain the `dispatcher`
    and refer to our `product.constants.js` file. So let''s create said file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做一些事情。让我们把`dispatcher`移动到`product.actions.js`文件中；这通常被称为动作创建器。这将包含`dispatcher`并引用我们的`product.constants.js`文件。所以让我们创建这个文件：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With these constructs, we can clean up our view considerably to look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些结构，我们可以大大清理我们的视图，使其看起来像这样：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Cleaning up the store
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理存储
- en: There are improvements we can make to on the store. There is no need to write
    all the code we do currently. In fact, there are libraries out there that do a
    better job of handling certain functionality.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在存储上做一些改进。实际上，没有必要编写我们目前所做的所有代码。事实上，有一些库在处理某些功能方面做得更好。
- en: Before we apply all those changes we have in mind, let's recap what our store
    can do and what features still need to be in place after the cleanup work.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用所有这些我们心中的变化之前，让我们回顾一下我们的商店能做什么，以及清理工作之后还需要哪些功能。
- en: 'Let''s remind ourselves, what our store is capable of so far:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提醒自己，我们的商店目前能做什么：
- en: 'Handles state changes: It handles the state changes; the store is able to change
    the state regardless of whether it is creating, updating, listing, or removing
    state.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理状态变化：它处理状态变化；商店能够在创建、更新、列出或删除状态时改变状态。
- en: 'Subscribable: It lets you subscribe to it; it''s important for the store to
    have a subscription functionality so a view, for example, can listen to the store''s
    state when it changes. A suitable reaction by the view is, for example, rerendering
    based on new data.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅功能：它允许您订阅它；对于商店来说，拥有订阅功能非常重要，这样视图就可以在状态改变时监听商店的状态。视图的一个合适的反应是，例如，根据新数据重新渲染。
- en: 'Can communicate a state change: It can send an event that its state has been
    changed; this goes together with being able to subscribe to the store, but this
    is the very act of actually notifying a listener that a state has changed.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通信状态变化：它可以发送一个事件，表明其状态已更改；这与能够订阅商店的能力相一致，但这实际上是通知监听器状态已更改的行为。
- en: Adding EventEmitter
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加`EventEmitter`
- en: The two last bullets can really be condensed into one theme, namely eventing,
    or the ability to register to and fire off events.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个要点实际上可以归纳为一个主题，即事件处理，或者注册和触发事件的能力。
- en: 'So what does a cleanup of the store look like, and why would we need to clean
    it up? The reason for cleaning it up is it makes for simpler code. There is a
    standard library that is often used when constructing a store, called `EventEmitter`.
    The library handles just what we mentioned previously, namely it is able to register
    and fire off events. It is a simple implementation of the pub-sub pattern. Basically,
    `EventEmitter` allows you to subscribe to certain events and also allows you to
    trigger events. For more information on the pattern itself, have a look at the
    following link: [https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，商店的清理看起来是什么样子，我们为什么需要清理它？清理的原因是它使代码更简单。在构建商店时，经常使用的一个标准库是`EventEmitter`。这个库处理的就是我们之前提到的，即它能够注册和触发事件。这是一个简单的发布/订阅模式的实现。基本上，`EventEmitter`允许您订阅某些事件，并允许您触发事件。有关该模式的更多信息，请参阅以下链接：[https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)。
- en: You could definitely write your own code for this, but it's nice to be able
    to use a dedicated library so you can focus on other things that matter, such
    as solving business problems.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您当然可以为此编写自己的代码，但能够使用一个专门的库来专注于其他重要的事情，比如解决业务问题，这会很好。
- en: 'We decided to use the `EventEmitter` library and we do so in the following
    way:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定使用`EventEmitter`库，并且我们以以下方式使用它：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This makes our code a little cleaner because we no longer need to hold an internal
    list of subscribers. There are more changes we can make though, so let us talk
    about that in the next section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的代码更加简洁，因为我们不再需要保留一个内部订阅者列表。尽管如此，我们还可以做出更多改变，所以让我们在下一节中讨论这一点。
- en: Adding to and cleaning up the register method
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和清理注册方法
- en: 'One of the store''s jobs has been to handle eventing, especially when the store
    wants to convey to a view that a change has happened to its state. In the `store.js`
    file, other things were happening as well, things like registering ourselves with
    the `dispatcher` and being able to receive dispatched actions. We used these actions
    to alter the state of the store. Let''s remind ourselves what that looked like:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 商店的一个任务就是处理事件，特别是当商店想要向视图传达其状态发生变化时。在`store.js`文件中，还有其他事情在进行，比如用`dispatcher`注册自己并能够接收分发的动作。我们使用这些动作来改变商店的状态。让我们提醒自己这看起来是什么样子：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we are only supporting one action, namely `SELECT_INDEX`. There are two
    things we need to do here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只支持一个动作，即`SELECT_INDEX`。这里我们需要做两件事：
- en: Add the other two actions, `CREATE_PRODUCT` and `REMOVE_PRODUCT`, and the accompanying
    functions `createProduct()` and `removeProduct()`
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加其他两个动作`CREATE_PRODUCT`和`REMOVE_PRODUCT`，以及相应的函数`createProduct()`和`removeProduct()`
- en: Stop using magic strings and start using our constants file
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止使用魔法字符串，开始使用我们的常量文件
- en: Use the store we created in the `store-event-emitter.js` file
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们在 `store-event-emitter.js` 文件中创建的存储
- en: 'Let''s implement the suggested changes from our preceding list:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实施我们前面列表中的建议更改：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Further improvements
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步改进
- en: There are definitely more improvements we can make to this code. We did use
    ES2015 imports to import other files, but most of our code was written in ES5
    so why not use most of what ES2015 gives us? Another improvement we can make is
    introducing immutability and making sure our store is not mutated but transitions
    from one state to another.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定可以对这段代码进行更多的改进。我们确实使用了 ES2015 导入来导入其他文件，但大部分代码是用 ES5 编写的，所以为什么不使用 ES2015
    提供的大部分功能呢？我们可以做出的另一个改进是引入不可变性，并确保我们的存储不被修改，而是从一个状态过渡到另一个状态。
- en: 'Let''s have a look at the store file, primarily because that is where we can
    add the most ES2015 syntax. Our revealing module pattern looks like this currently:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看存储文件，主要是因为那里我们可以添加最多的 ES2015 语法。我们的模块揭示模式目前看起来是这样的：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It can be replaced with a simple class and instead of instantiating an `EventEmitter`,
    we can inherit from it. In all fairness, we could have used ES2015 inheritance
    or the merge library to not have to create a separate `EventEmitter` instance,
    but this shows how elegant ES2015 can make things:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用一个简单的类来替换，而不是实例化一个 `EventEmitter`，我们可以从它继承。公平地说，我们本可以使用 ES2015 继承或合并库来避免创建单独的
    `EventEmitter` 实例，但这展示了 ES2015 可以如何使事情变得优雅：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Adding immutability
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加不可变性
- en: 'The other thing we can undertake is adding immutability. The reasons for using
    immutability in the first place are to make your code more predictable, and some
    frameworks can use this for simpler change detection and can rely on reference
    checking over dirty checking. This was the case when AngularJS got its whole change
    detection mechanism changed when Angular was written. From a practical standpoint,
    this means that there are functions we can target in our store and apply immutable
    principles on. The first principle is to not mutate but create an entirely new
    state, instead of where the new state is *the old state + the state change*. A
    simple example of this is the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的另一件事是添加不可变性。最初使用不可变性的原因是为了使你的代码更具可预测性，并且一些框架可以使用这一点来进行更简单的变更检测，并依赖于引用检查而不是脏检查。当
    AngularJS 在 Angular 被编写时，其整个变更检测机制发生了变化，这就是这种情况。从实际的角度来看，这意味着我们可以在存储中针对某些函数并应用不可变原则。第一个原则是不修改，而是创建一个全新的状态，而不是新的状态是
    *旧状态 + 状态变更*。一个简单的例子如下：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we are creating a new variable, `newState`, rather than mutating our
    `oldState` variable. There are functions that will help us with this, called `Object.assign`
    and the function filter. We can use these for updating scenarios, as well as adding
    or removing things from a list. Let us use these and rewrite part of our store
    code. Let''s highlight the code we mean to change:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的变量 `newState`，而不是修改我们的 `oldState` 变量。有一些函数可以帮助我们完成这个任务，称为 `Object.assign`
    和 `filter` 函数。我们可以使用这些函数来更新场景，以及从列表中添加或删除事物。让我们使用这些函数并重写我们存储代码的一部分。让我们突出显示我们打算更改的代码：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s apply `Object.assign` and `filter()`, and remember to not mutate things.
    The end result should look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用 `Object.assign` 和 `filter()`，并记住不要修改任何东西。最终结果应该看起来像这样：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can see that the `createProduct()` method uses an ES2015 construct, namely
    the spread parameter, `...`, which takes a list and turns its members into a comma-separated
    list of items. `Object.assign()` is used to copy over all the values from an object
    so we store the value of an object rather than its reference. The `removeProduct()`
    method becomes very simple when we use the filter method. We simply create a projection
    that does not include the product that we should remove; removing has never been
    this easy or elegant. We haven't mutated anything.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`createProduct()` 方法使用了 ES2015 的一个构造，即扩展运算符 `...`，它将一个列表的成员转换成一个以逗号分隔的项目列表。我们使用
    `Object.assign()` 来复制对象中的所有值，因此我们存储的是对象值而不是其引用。当我们使用过滤方法时，`removeProduct()` 方法变得非常简单。我们只需创建一个不包括我们要删除的产品的新投影；删除从未如此简单或优雅。我们没有对任何东西进行修改。
- en: Summarizing
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Our cleanup started with the view; we wanted to remove a direct connection to
    the dispatcher and also stop having to use magic strings as this is quite error
    prone, and it's easy to misspell. Instead, we can rely on constants. To remedy
    this, we created an action creator class that talked to the dispatcher instead.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的清理工作从视图开始；我们想要移除与 `dispatcher` 的直接连接，并停止使用魔法字符串，因为这很容易出错，也容易拼错。相反，我们可以依赖常量。为了解决这个问题，我们创建了一个与
    `dispatcher` 通信的动作创建器类。
- en: We also created a constants module to remove the magic strings.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个常量模块来移除魔法字符串。
- en: Furthermore, we improved the store by starting to use `EventEmitter`. Finally,
    we further improved the store by adding more actions to it and also started to
    refer to the constants.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们通过开始使用 `EventEmitter` 来改进了商店。最后，我们通过向其中添加更多动作并开始引用常量来进一步改进了商店。
- en: At this point, our solution is ready for more actions to be added to it and
    we should feel pretty clear on what files we need to add to, as we support more
    and more user interactions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的解决方案已经准备好添加更多操作，我们应该对需要添加哪些文件有相当清晰的认识，因为我们支持越来越多的用户交互。
- en: Lastly, we added improvements around ES2015 and immutability, which made our
    code look a lot cleaner. With this foundation, we are now ready to go from static
    data to involve working with side effects and Ajax in the upcoming section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 ES2015 和不可变性方面进行了改进，这使得我们的代码看起来干净得多。有了这个基础，我们现在可以准备好从静态数据过渡到涉及副作用和 Ajax
    的下一节。
- en: 'Let us summarize all our improvements in a diagram showing the constructs added
    to our flow:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个显示我们流程中添加的结构的图表来总结我们的所有改进：
- en: '![](img/0dbe10b0-0de5-4ebd-b1b0-a23271451d5e.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0dbe10b0-0de5-4ebd-b1b0-a23271451d5e.png)'
- en: It is clear that using an action creator isn't strictly necessary but it does
    clean up the code quite a bit, and the same goes for using an `EventEmitter` in
    the store; it's nice but not necessary.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，使用动作创建器并不是严格必要的，但它确实使代码更加整洁，同样，在商店中使用 `EventEmitter` 也是如此；它很好，但不是必要的。
- en: Adding AJAX calls
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 AJAX 调用
- en: 'So far, we have only been dealing with static data in our Flux flow. The time
    has now come to add real data connections to the flow and thereby real data. It
    is time to start talking to APIs through AJAX and HTTP. Fetching data is quite
    easy nowadays, thanks to the fetch API and libraries such as RxJS. What you need
    to think about when incorporating it in the flow is:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在我们 Flux 流中处理静态数据。现在，是时候向流程添加真实的数据连接和真实数据了。是时候开始通过 AJAX 和 HTTP 与 API
    通信了。由于有了 fetch API 和像 RxJS 这样的库，获取数据现在相当简单。在将它们融入流程时，你需要考虑的是：
- en: Where to place the HTTP call
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 调用的放置位置
- en: How to ensure that the store is updated and interested views are notified
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保商店更新并且通知感兴趣的视图
- en: 'We have a point at which we register the store to the `dispatcher`, with this
    piece of code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个注册商店到 `dispatcher` 的点，使用以下代码：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we do this for real, that is, call an API to persist this product, `createProduct()`
    would be where we would do the API call, like so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的这样做，也就是说，调用 API 来持久化此产品，`createProduct()` 就是我们进行 API 调用的地方，如下所示：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Calling `fetch()` returns a `Promise`. Let''s use async/await however, as it
    makes the call much more readable. The difference in code can be seen in the following
    example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `fetch()` 返回一个 `Promise`。但是，让我们使用 async/await，因为它使调用更加易读。代码中的差异可以在以下示例中看到：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Replacing what happens in `createProduct()` with this adds code with a lot
    of noise so it is a good idea to wrap your HTTP interactions in an API construct
    like so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个替换 `createProduct()` 中的内容会增加很多噪音，所以将你的 HTTP 交互包装在一个 API 构造中是个好主意，如下所示：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now let us replace the `createProduct()` method content with the call to our
    API construct like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将 `createProduct()` 方法的内容替换为对 API 构造的调用，如下所示：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That''s not really enough though. Because we created a product through an API
    call, we should dispatch an action that forces the product list to be reread.
    We don''t have such an action or supporting method in a store to handle it, so
    let''s add one:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不够。因为我们通过 API 调用创建了一个产品，所以我们应该分发一个动作来强制重新读取产品列表。我们没有在商店中处理这种情况的动作或支持方法，所以让我们添加一个：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now let''s add the required method in the store and the case to handle it:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在商店中添加所需的方法和处理它的案例：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can see that the `CREATE_PRODUCT` case will call the corresponding API method
    `createProduct()`, which on completion will dispatch the `GET_PRODUCTS` action.
    The reason for doing so is that when we successfully manage to create a product,
    we need to read from the endpoint to get an updated version of the products list.
    We don't see that in detail, but it is being invoked through us calling `getProducts()`.
    Again, it is nice to have a wrapper on everything being dispatched, that wrapper
    being an action creator.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`CREATE_PRODUCT` 情况将调用相应的 API 方法 `createProduct()`，在完成之后将分派 `GET_PRODUCTS`
    动作。这样做的原因是，当我们成功创建一个产品时，我们需要从端点读取以获取产品列表的更新版本。我们没有看到详细情况，但它是通过我们调用 `getProducts()`
    来触发的。再次强调，有一个包装器来包装所有被分派的操作是件好事，这个包装器就是一个动作创建器。
- en: 'The full file looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 整个文件看起来像这样：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: An even bigger solution
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更大的解决方案
- en: 'So far, we have been describing a solution that consists of only a product''s
    topic and communication has only taken place from one view to another. In a more
    realistic application, we would have a lot of topics such as user management,
    orders, and so on; exactly what they are called is dependent on the domain of
    your application. As for views, it is quite possible that you will have a ton
    of views listening to another view, as in this example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在描述一个只包含产品主题和通信只发生在视图之间的解决方案。在一个更现实的应用中，我们会有很多主题，比如用户管理、订单等等；它们的确切名称取决于你应用程序的领域。至于视图，完全有可能你会有很多视图在监听另一个视图，就像这个例子一样：
- en: '![](img/6da86ae3-4750-451a-8e0c-f0118a549cc3.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6da86ae3-4750-451a-8e0c-f0118a549cc3.png)'
- en: 'This describes an application that contains four different view components
    around their own topic. The **Customers view** contains a list of customers and
    it allows us to alter which customer we currently want to focus on. The other
    three supporting views show **Orders**, **Messages**, and **Friends** and their
    content depends on which customer is currently highlighted. From a Flux standpoint,
    the **Orders**, **Messages**, and **Friends** views can easily register with the
    store to know when things gets updated so they can fetch/refetch the data they
    need. However, imagine that the supporting views themselves want to support CRUD
    actions; then they would need their own set of constants, action creator, API,
    and store. So now your application would need to look something like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了一个包含四个不同视图组件的应用程序，这些组件围绕它们自己的主题。**客户视图**包含客户列表，并允许我们更改我们当前想要关注的客户。其他三个辅助视图显示**订单**、**消息**和**朋友**，它们的内容取决于当前突出显示的客户。从
    Flux 的角度来看，**订单**、**消息**和**朋友**视图可以轻松注册到存储中，以便知道何时更新，这样它们就可以获取/重新获取所需的数据。然而，想象一下，辅助视图本身也想支持
    CRUD 操作；那么，它们就需要自己的常量集、动作创建器、API 和存储。因此，现在你的应用程序可能看起来像这样：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Two interesting situations exist here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在两种有趣的情况：
- en: You have a self-contained view; all CRUD actions happen within it
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个自包含的视图；所有的 CRUD 操作都发生在这个视图内
- en: You have a view that needs to listen to other views
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个需要监听其他视图的视图
- en: For the first situation, a good rule of thumb is to create its own set of constants,
    action creator, API, and store.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种情况，一个好的经验法则是创建它自己的常量集、动作创建器、API 和存储。
- en: For the second situation, ensure your view registers itself with the store of
    that topic. For example, if the friends view needs to listen to the customer view,
    then it needs to register itself with the customer store.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种情况，确保你的视图将自己注册到该主题的存储中。例如，如果朋友视图需要监听客户视图，那么它需要将自己注册到客户存储中。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We set out trying only to explain the Flux architecture pattern. It would have
    been very easy to start mentioning how it fits with React and how there are nice
    libraries and tools that support Flux and React. That would, however, have taken
    our focus away from explaining the pattern from a more framework-agnostic viewpoint.
    Therefore, the rest of this chapter set out to explain core concepts such as actions,
    action creator, dispatcher, store, and uniform data flow. Little by little, we
    improved the code to start using constants, action creators, and a nice supporting
    library such as `EventEmitter`. We explained how HTTP fits into this and, lastly,
    we discussed how we could build out our application. There is a lot more that
    can be said about Flux, but we chose to limit the scope to understanding the fundamentals
    so we can compare its approach as we dive into Redux and NgRx in later chapters,
    which is the main focus of this book.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的目标只是解释 Flux 架构模式。提到它与 React 的结合以及有哪些优秀的库和工具支持 Flux 和 React，那会非常简单。然而，那样做可能会使我们的注意力从更框架无关的角度解释模式上转移。因此，本章的其余部分旨在解释核心概念，如动作、动作创建者、调度器、存储和统一数据流。我们逐步改进代码，开始使用常量、动作创建者以及像
    `EventEmitter` 这样的优秀支持库。我们解释了 HTTP 如何融入其中，最后讨论了如何构建我们的应用程序。关于 Flux 有很多可以说的，但我们选择限制范围，以便理解基础知识，这样我们就可以在后续章节深入探讨
    Redux 和 NgRx 时进行比较，而这本书的主要关注点就是这些内容。
