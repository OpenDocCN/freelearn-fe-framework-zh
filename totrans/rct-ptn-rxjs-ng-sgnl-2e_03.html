<html><head></head><body>
<div id="_idContainer031">
<h1 class="chapter-number" id="_idParaDest-43"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-44"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.2.1">Fetching Data as Streams</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The way you manage your application’s data has a huge impact on your UI performance and the user experience. </span><span class="koboSpan" id="kobo.3.2">As far as I’m concerned, great user experience and performant UIs are no longer an option nowadays – they are key determinants of user satisfaction. </span><span class="koboSpan" id="kobo.3.3">Furthermore, managing data efficiently optimizes the code and enhances its quality, which consequently minimizes maintenance and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">improvement costs.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">So, how can we manage our data efficiently? </span><span class="koboSpan" id="kobo.5.2">Well, this is what we will be answering in the following chapters. </span><span class="koboSpan" id="kobo.5.3">There are a few reactive patterns that come in handy in many use cases, and we will start by exploring the most basic reactive pattern for displaying values received from a REST endpoint to allow users to read and interact </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">with them.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">To begin, we will explain the requirement that we’re going to implement in the recipe application. </span><span class="koboSpan" id="kobo.7.2">Then, we will introduce the classic pattern to retrieve data, followed by the different approaches that you can use to manage unsubscriptions and all the important technical concepts surrounding them. </span><span class="koboSpan" id="kobo.7.3">We will also learn about a new feature of Angular 14+, which is standalone components. </span><span class="koboSpan" id="kobo.7.4">Following this, we will explain the reactive pattern to fetch data, and highlight the advantages of the reactive pattern over the classic one. </span><span class="koboSpan" id="kobo.7.5">Finally, we will learn about the new built-in control flow introduced in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">Angular 17.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">So, in this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Defining the data </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">fetch requirement</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Exploring the classic pattern for </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">fetching data</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Exploring the reactive pattern for </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">fetching data</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Highlighting the advantages of the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">reactive pattern</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Diving into the built-in control flow in </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Angular 17</span></span></li>
</ul>
<h1 id="_idParaDest-45"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">This chapter assumes that you have a basic understanding of HttpClient, Angular components, Angular modules, </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">and routing.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">We’ll be using a mocked REST API backend built with JSON Server, which allows you to spin up a REST API server with a fully working API. </span><span class="koboSpan" id="kobo.24.2">We’ll not be learning how to use JSON Server, but if you are interested in learning more, you can find further information </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">at </span></span><a href="https://github.com/typicode/json-server"><span class="No-Break"><span class="koboSpan" id="kobo.26.1">https://github.com/typicode/json-server</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.27.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">You can access the project source code for this chapter in the GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">at </span></span><a href="https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap03"><span class="No-Break"><span class="koboSpan" id="kobo.30.1">https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap03</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.31.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">The project is composed of </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">two folders:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">recipes-book-api</span></strong><span class="koboSpan" id="kobo.35.1">: This contains the mocked RESTful server already </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">set up.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">recipes-book-front</span></strong><span class="koboSpan" id="kobo.38.1">: This contains the frontend application that was built with Angular 17 and RxJS 7. </span><span class="koboSpan" id="kobo.38.2">As a third-party dependency, we’ve added </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">bootstrap</span></strong><span class="koboSpan" id="kobo.40.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">primeng</span></strong><span class="koboSpan" id="kobo.42.1"> libraries to help us build beautiful UI components quickly. </span><span class="koboSpan" id="kobo.42.2">Please refer to the previous chapter’s </span><em class="italic"><span class="koboSpan" id="kobo.43.1">Technical requirements</span></em><span class="koboSpan" id="kobo.44.1"> section for the environment and </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">dependencies setup.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.46.1">The project complies with the standard Angular style guide, which can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">at </span></span><a href="https://angular.dev/style-guide#"><span class="No-Break"><span class="koboSpan" id="kobo.48.1">https://angular.dev/style-guide#</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.49.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">The first time you run the apps, you will need to install dependencies beforehand. </span><span class="koboSpan" id="kobo.50.2">You only have to run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">npm i</span></strong><span class="koboSpan" id="kobo.52.1"> command in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">recipes-book-api</span></strong><span class="koboSpan" id="kobo.54.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">recipes-book-front</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.56.1"> folders.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Once dependencies are installed, you need to start the server by running the following command in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">recipes-book-api</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.59.1"> folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.60.1">
npm run server: start</span></pre> <p><span class="koboSpan" id="kobo.61.1">The server will be running </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">at http://localhost:8081</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">Then, you start the frontend by running the following command in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">recipes-book-front</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.66.1"> folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.67.1">
ng serve --proxy-config proxy.config.json</span></pre> <p><span class="koboSpan" id="kobo.68.1">You can read more about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">--proxy-config</span></strong><span class="koboSpan" id="kobo.70.1"> parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">at </span></span><a href="https://angular.dev/tools/cli/serve#proxying-to-a-backend-server"><span class="No-Break"><span class="koboSpan" id="kobo.72.1">https://angular.dev/tools/cli/serve#proxying-to-a-backend-server</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.73.1">.</span></span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.74.1">Defining the data fetch requirement</span></h1>
<p><span class="koboSpan" id="kobo.75.1">First, let’s define the requirement we are</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.76.1"> going to implement in a reactive way. </span><span class="koboSpan" id="kobo.76.2">We want to display the list of recipes retrieved from the mocked backend on the home page, progressively building the user story detailed in the </span><em class="italic"><span class="koboSpan" id="kobo.77.1">View one – the landing page</span></em><span class="koboSpan" id="kobo.78.1"> section of </span><a href="B21180_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.79.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.80.1">, </span><em class="italic"><span class="koboSpan" id="kobo.81.1">Walking through </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.82.1">Our Application</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.84.1"><img alt="Figure 3.1 – The landing page view" src="image/B21180_02_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.85.1">Figure 3.1 – The landing page view</span></p>
<p><span class="koboSpan" id="kobo.86.1">To do this, we need to fetch the list of recipes beforehand to display it to the user as cards, right? </span><span class="koboSpan" id="kobo.86.2">So, the list of recipes represents the first data that we need to request, which is available in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">recipes-book-api</span></strong><span class="koboSpan" id="kobo.88.1"> server through the </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">following endpoint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.90.1">
GET /api/recipes</span></pre> <p><span class="koboSpan" id="kobo.91.1">Please don’t forget to start the server as detailed in the </span><em class="italic"><span class="koboSpan" id="kobo.92.1">Technical requirements</span></em><span class="koboSpan" id="kobo.93.1"> section. </span><span class="koboSpan" id="kobo.93.2">Once the server is started, you can check the result of the fetch API </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">http://localhost:8081/api/recipes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">In the following sections, we</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.98.1"> will see how we can implement the fetching data requirement in both classic and reactive styles to understand the basic differences between them, and to see the benefits the reactive programming gives us over the </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">imperative one.</span></span></p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.100.1">Exploring the classic pattern for fetching data</span></h1>
<p><span class="koboSpan" id="kobo.101.1">Let’s first have a look at the implementation of the classic pattern for fetching the list </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">of recipes.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.103.1">Defining the structure of your data</span></h2>
<p><span class="koboSpan" id="kobo.104.1">First and foremost, we need to</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.105.1"> define the structure of our data so that we can strongly type it. </span><span class="koboSpan" id="kobo.105.2">This will allow us to take advantage of TypeScript’s type-checking features and catch type </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">errors early.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">We can use the Angular CLI to generate the </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">Recipe</span></strong><span class="koboSpan" id="kobo.109.1"> model underneath the </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">src/app/ </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">core/model</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.112.1"> folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.113.1">
$ ng g i Recipe</span></pre> <p><span class="koboSpan" id="kobo.114.1">For convention purposes, we will change the name of the generated file from </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">recipe.ts</span></strong><span class="koboSpan" id="kobo.116.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">recipe.model.ts</span></strong><span class="koboSpan" id="kobo.118.1">. </span><span class="koboSpan" id="kobo.118.2">Then, we will populate the interface with the specific properties of </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">Recipe</span></strong><span class="koboSpan" id="kobo.120.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.122.1">
export interface Recipe {
id: number;
title: string;
ingredients: string;
tags?: string;
imageUrl: string;
cookingTime?: number;
prepTime?: number;
yield: number;
steps?: string;
rating:number;
}</span></pre> <p><span class="koboSpan" id="kobo.123.1">One by one, we enter the properties of the recipe we are going to use, followed by the type of each property. </span><span class="koboSpan" id="kobo.123.2">The description of each property is detailed in </span><em class="italic"><span class="koboSpan" id="kobo.124.1">View two – the New Recipe interface</span></em><span class="koboSpan" id="kobo.125.1"> section of </span><a href="B21180_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.126.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.127.1">, </span><em class="italic"><span class="koboSpan" id="kobo.128.1">Walking through </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.129.1">Our Application</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">For optional properties, we placed a </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.132.1">question mark (</span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">?</span></strong><span class="koboSpan" id="kobo.134.1">) just before the property’s type annotation when declaring the interface to tell TypeScript that the property </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">is optional.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.136.1">Creating the fetching data service</span></h2>
<p><span class="koboSpan" id="kobo.137.1">The next step is to create an Angular service named </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">RecipesService</span></strong><span class="koboSpan" id="kobo.139.1"> that will be responsible for managing all the</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.140.1"> operations around the recipes. </span><span class="koboSpan" id="kobo.140.2">This service will encapsulate the </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">create, read, update, and delete</span></strong><span class="koboSpan" id="kobo.142.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.143.1">CRUD</span></strong><span class="koboSpan" id="kobo.144.1">) operations and make them available to the </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.145.1">various UI components. </span><span class="koboSpan" id="kobo.145.2">In this chapter, we will only implement the read (</span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">fetch) operation.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">Now, why do we create a service? </span><span class="koboSpan" id="kobo.147.2">Well, we do it to increase modularity and to ensure the reusability of the service over the </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">other components.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">To generate the service underneath the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">core/services</span></strong><span class="koboSpan" id="kobo.151.1"> folder, we execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">ng g s</span></strong><span class="koboSpan" id="kobo.153.1"> command under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">core/services</span></strong><span class="koboSpan" id="kobo.155.1"> folder </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.157.1">
$ ng g s Recipes</span></pre> <p><span class="koboSpan" id="kobo.158.1">Now that the service is generated successfully, let’s create and implement the method that will have the responsibility of fetching the data. </span><span class="koboSpan" id="kobo.158.2">We will inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">HttpClient</span></strong><span class="koboSpan" id="kobo.160.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">RecipesService</span></strong><span class="koboSpan" id="kobo.162.1"> and define a method to retrieve the data. </span><span class="koboSpan" id="kobo.162.2">The service will look </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.164.1">
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { Recipe } from '../model/recipe.model';
import { environment } from 'src/environments/environment';
const BASE_PATH = environment.basePath
@Injectable({
providedIn: 'root'
})
export class RecipesService {
constructor(private http: HttpClient) { }
getRecipes(): Observable&lt;Recipe[]&gt; {
return this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`);
}
}</span></pre> <p><span class="koboSpan" id="kobo.165.1">Let’s break down what is going on at the level of </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">RecipesService</span></strong><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">It’s nothing fancy – we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">getRecipes()</span></strong><span class="koboSpan" id="kobo.169.1"> method that gets the list of recipes over HTTP and returns a strongly typed HTTP response: </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">Observable&lt;Recipe[]&gt;</span></strong><span class="koboSpan" id="kobo.171.1">. </span><span class="koboSpan" id="kobo.171.2">This Observable represents the data stream that will be created when you issue the HTTP GET request. </span><span class="koboSpan" id="kobo.171.3">When you subscribe to it, it will </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.172.1">emit the list of recipes as a JSON array and then completes. </span><span class="koboSpan" id="kobo.172.2">So, the stream represented by this HTTP request will be completed after emitting the response </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">data once.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">As a best practice, we externalized </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">BASE_PATH</span></strong><span class="koboSpan" id="kobo.176.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">environment.ts</span></strong><span class="koboSpan" id="kobo.178.1"> file because, in many cases, the server’s base path depends on the environment (such as testing or production). </span><span class="koboSpan" id="kobo.178.2">This way, it is easier to update the paths in one place rather than updating all the services </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">using it.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.180.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.181.1">Starting from Angular 15, the environment files are not shipped by default anymore. </span><span class="koboSpan" id="kobo.181.2">However, you can choose to generate them on demand by executing </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">$ ng </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">g environments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">We’ve also injected the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">HttpClient</span></strong><span class="koboSpan" id="kobo.187.1"> dependency in the constructor </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.189.1">
constructor(private http: HttpClient) { }</span></pre> <p><span class="koboSpan" id="kobo.190.1">This technique is known as </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">constructor injection</span></strong><span class="koboSpan" id="kobo.192.1">. </span><span class="koboSpan" id="kobo.192.2">Angular’s built-in dependency injection system will automatically provide the</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.193.1"> injected dependencies when an instance of the component or service </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">is created.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">Plus, starting from version 14, Angular’s</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.196.1"> dependency injection system provided the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">inject()</span></strong><span class="koboSpan" id="kobo.198.1"> utility function. </span><span class="koboSpan" id="kobo.198.2">This allows you to manually resolve and retrieve dependencies within a component or a service </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">like so:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.200.1">
private http= inject(HttpClient);</span></pre> <p><span class="koboSpan" id="kobo.201.1">This approach is useful when you need to dynamically resolve dependencies or perform conditional dependency injection based on </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">runtime conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">We will use the constructor injection technique throughout the book. </span><span class="koboSpan" id="kobo.203.2">However, should you wish to adopt the newer approach, you have the flexibility to </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">do so.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.205.1">Creating Angular standalone components</span></h2>
<p><span class="koboSpan" id="kobo.206.1">Now, we should create the component </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.207.1">responsible for displaying the list of recipes named </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.209.1"> under </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">src/app/recipe-list</span></strong><span class="koboSpan" id="kobo.211.1">. </span><span class="koboSpan" id="kobo.211.2">Before that, though, let’s just stop here and explain a super interesting new type of component introduced in Angular 14: the </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">standalone component.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">By definition, a </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">standalone component</span></strong><span class="koboSpan" id="kobo.215.1"> is a self-contained</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.216.1"> component that doesn’t belong to any </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">NgModule</span></strong><span class="koboSpan" id="kobo.218.1"> and can be used by either other standalone components or </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">module-based components.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">Before Angular 14, we only had one way to </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">create components:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.222.1">
  $ ng g c recipesList</span></pre> <p><span class="koboSpan" id="kobo.223.1">This command will create a component named </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.225.1"> and add it to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">NgModule</span></strong><span class="koboSpan" id="kobo.227.1">. </span><span class="koboSpan" id="kobo.227.2">Which module, though? </span><span class="koboSpan" id="kobo.227.3">If you specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">--module</span></strong><span class="koboSpan" id="kobo.229.1"> in the command line, followed by the path of your module, then the CLI will add the component in that specific module. </span><span class="koboSpan" id="kobo.229.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">--module</span></strong><span class="koboSpan" id="kobo.231.1"> option is not set, then the CLI will check whether there’s a module in the same directory; if not, it will check in the nearest parent directory. </span><span class="koboSpan" id="kobo.231.2">If neither of those options is the case, it will generate a new module file in the same directory as the component and declare the component in that </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">new module.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">In short, the CLI will always end up </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.234.1">associating the component to a module and adding it to the module’s declaration array; otherwise, you will get a </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">compilation error.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">However, starting from Angular 14, you can decide to create a standalone component that doesn’t belong to any </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">NgModule</span></strong><span class="koboSpan" id="kobo.238.1"> by mentioning the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">--standalone</span></strong><span class="koboSpan" id="kobo.240.1"> flag in the </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">command line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.242.1">
  $ ng g c recipesList --standalone</span></pre> <p><span class="koboSpan" id="kobo.243.1">Using this in our project, </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.245.1"> won’t be added to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">NgModule</span></strong><span class="koboSpan" id="kobo.247.1">, and will contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">standalone: true</span></strong><span class="koboSpan" id="kobo.249.1"> flag inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">@Component</span></strong><span class="koboSpan" id="kobo.251.1"> decorator, as well as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">imports</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.253.1"> property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.254.1">
@Component({
  selector: 'app-recipes-list',
  standalone: true,
  imports: [],
  templateUrl: './recipes-list.component.html',
  styleUrls: ['./recipes-list.component.scss'],
})</span></pre> <p><span class="koboSpan" id="kobo.255.1">If the standalone component depends on other components, whether module-based or standalone, you should mention those components in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">imports</span></strong><span class="koboSpan" id="kobo.257.1"> array; otherwise, you will get a </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">compilation error.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">Standalone components can also be used by module-based components or other standalone components. </span><span class="koboSpan" id="kobo.259.2">Plus, they can be used when loading routes, and in lazy loading. </span><span class="koboSpan" id="kobo.259.3">It’s also worth knowing that you can create standalone directives and standalone pipes </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">So far, so good! </span><span class="koboSpan" id="kobo.261.2">Now, why should you care? </span><span class="koboSpan" id="kobo.261.3">There are a few good reasons we should adopt standalone components in </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">our projects:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.263.1">Less code means less </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.264.1">boilerplate to write, and hence, quicker build times, plus better code organization, testing, </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">and maintainability.</span></span></li>
<li><span class="koboSpan" id="kobo.266.1">It is easier to understand the component’s dependencies as they are mentioned directly in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">imports</span></strong><span class="koboSpan" id="kobo.268.1"> property of the standalone component. </span><span class="koboSpan" id="kobo.268.2">For a module-based component, you will have to scan your component’s code and then check the module’s dependencies that are shared by all the components belonging to </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">that module.</span></span></li>
<li><span class="koboSpan" id="kobo.270.1">The power of standalone components lies in their isolation and self-contained nature. </span><span class="koboSpan" id="kobo.270.2">You only import what is needed by your component, while module-based components sometimes import useless dependencies used by other components in the </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">same module.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.272.1">Let’s suppose that we have a module “M” that imports “A,” “B,” and “C” components and “S1,” “S2,” and “S3” services, and we have a “D” component that does not belong to that module but depends on the component “B.” </span><span class="koboSpan" id="kobo.272.2">As “B” is a module-based component, then “D” should import the entire module ‘M’; this leads to unnecessary dependencies as “D” does not need the components “A” and “B” or the services “S1” and “S2.” </span><span class="koboSpan" id="kobo.272.3">So, integrating standalone components gives us more flexibility to only import the components and services required, since standalone components are self-contained and have their own sets of dependencies and logic. </span><span class="koboSpan" id="kobo.272.4">Consequently, it eliminates redundant code, leading to a more </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">optimized app.</span></span></p></li>
<li><span class="koboSpan" id="kobo.274.1">It makes the learning curve for beginner Angular developers </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">less steep.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.276.1">We will be using standalone components in our recipe app to adopt a modular and self-contained approach. </span><span class="koboSpan" id="kobo.276.2">We will only keep the app component as a module-based component, even though we can</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.277.1"> bootstrap the application using a standalone component. </span><span class="koboSpan" id="kobo.277.2">Here’s a schema representing our </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">component’s dependencies:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.279.1"><img alt="Figure 3.2 – The recipe app's components’ dependencies" src="image/B21180_03_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.280.1">Figure 3.2 – The recipe app's components’ dependencies</span></p>
<p><span class="koboSpan" id="kobo.281.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">AppComponent</span></strong><span class="koboSpan" id="kobo.283.1"> parent component is a module-based component that imports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">HeaderComponent</span></strong><span class="koboSpan" id="kobo.285.1"> standalone component in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">AppModule</span></strong><span class="koboSpan" id="kobo.287.1"> imports declaration. </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">HeaderComponent</span></strong><span class="koboSpan" id="kobo.289.1"> uses some PrimeNG external dependencies, so it needs to be imported in the component’s </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">imports declaration.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">HomeComponent</span></strong><span class="koboSpan" id="kobo.292.1"> is a standalone component that will be routed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">AppComponent</span></strong><span class="koboSpan" id="kobo.294.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">HomeComponent</span></strong><span class="koboSpan" id="kobo.296.1"> imports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.298.1"> standalone component in the component’s imports declaration. </span><span class="koboSpan" id="kobo.298.2">The latter uses some PrimeNG external dependencies, so it needs to be imported in the component’s imports declaration. </span><span class="koboSpan" id="kobo.298.3">All the code is available in the </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">GitHub repository.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.300.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.301.1">For more information </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.302.1">on standalone components, you can </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">check </span></span><a href="https://angular.dev/reference/migrations/standalone"><span class="No-Break"><span class="koboSpan" id="kobo.304.1">https://angular.dev/reference/migrations/standalone</span></span></a></p>
<p><span class="koboSpan" id="kobo.305.1">Hopefully, the concept of standalone components is clear, so let’s move on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">following step.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.307.1">Injecting and subscribing to the service in your component</span></h2>
<p><span class="koboSpan" id="kobo.308.1">In this section, we will inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">RecipesService</span></strong><span class="koboSpan" id="kobo.310.1"> service in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.312.1"> component </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.313.1">and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">getRecipes()</span></strong><span class="koboSpan" id="kobo.315.1">method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">ngOnInit()</span></strong><span class="koboSpan" id="kobo.317.1"> (when the component is initialized). </span><span class="koboSpan" id="kobo.317.2">We will also make a read operation against the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">API server.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">In order to get the data emitted, we need to subscribe to the returned Observable from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">getRecipes()</span></strong><span class="koboSpan" id="kobo.321.1"> method. </span><span class="koboSpan" id="kobo.321.2">Then, we bind the data to a local array property created in our component, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">recipes</span></strong><span class="koboSpan" id="kobo.323.1">. </span><span class="koboSpan" id="kobo.323.2">The component’s code will look </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
import { Component, OnInit } from '@angular/core';
import { Observable } from 'rxjs';
import { Recipe } from '../core/model/recipe';
import { RecipesService } from '../core/services/recipes.
</span><span class="koboSpan" id="kobo.325.2">Service';
@Component({
selector: 'app-recipes-list',
standalone: true,
imports: [CommonModule],
templateUrl: './recipes-list.component.html',
styleUrls: ['./recipes-list.component.scss']
})
export class RecipesListComponent implements OnInit {
recipes!: Recipe[];
constructor(private service: RecipesService) { }
ngOnInit(): void {
this.service.getRecipes().subscribe(result =&gt; {
this.recipes = result;
});
}
}</span></pre> <p><span class="koboSpan" id="kobo.326.1">Now that we’ve retrieved the</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.327.1"> data and stored it in a local property, let’s see how we will display it in </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">the UI.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.329.1">Displaying the data in the template</span></h2>
<p><span class="koboSpan" id="kobo.330.1">Now we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">recipes</span></strong><span class="koboSpan" id="kobo.332.1"> property (which is available in the component) in our HTML template to display the list of </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.333.1">recipes in our UI. </span><span class="koboSpan" id="kobo.333.2">In our case, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">DataView</span></strong><span class="koboSpan" id="kobo.335.1"> PrimeNG component to display the list of recipes as cards in a grid layout (further details about this component can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">at </span></span><a href="https://primeng.org/dataview"><span class="No-Break"><span class="koboSpan" id="kobo.337.1">https://primeng.org/dataview</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.338.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">Of course, our goal is to focus not on the template code, but on the manipulation of the data inside it. </span><span class="koboSpan" id="kobo.339.2">As you can see in the following example, we passed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">recipes</span></strong><span class="koboSpan" id="kobo.341.1"> array to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">value</span></strong><span class="koboSpan" id="kobo.343.1"> input of the data view component (you can also use structural directives to render a data view component with pure HTML if you don’t want to include a </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">third-party dependency):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.345.1">
&lt;div class="card"&gt;
&lt;p-dataView #dv [value]="recipes" [paginator]="true"
[rows]="9"    filterBy="name" layout="grid"&gt;
/** Extra code here **/
&lt;/p-dataView&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.346.1">This is the basic pattern for collecting data, which you would have discovered back when you started learning about Angular, so you have likely seen something like </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">this before.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">Now there’s just one thing left – you should handle the unsubscription of the Observable, as this code manages subscriptions manually. </span><span class="koboSpan" id="kobo.348.2">Otherwise, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">Observable</span></strong><span class="koboSpan" id="kobo.350.1"> subscription will stay alive after the component has been destroyed, and the memory’s reference will</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.351.1"> not be released, causing memory leaks. </span><span class="koboSpan" id="kobo.351.2">That’s why you should always be careful of this when manually subscribing to Observables inside </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">Angular components.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.353.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.354.1">Although </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">HttpClient</span></strong><span class="koboSpan" id="kobo.356.1"> Observables unsubscribe automatically after the server request responds or times out, we will still demonstrate how to handle their unsubscription to secure our implementation and showcase best practices. </span><span class="koboSpan" id="kobo.356.2">This will also serve as a showcase for handling unsubscription with </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">other Observables.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.358.1">Managing unsubscriptions</span></h2>
<p><span class="koboSpan" id="kobo.359.1">There are two commonly used ways to </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.360.1">manage unsubscriptions: the imperative pattern and the declarative reactive pattern. </span><span class="koboSpan" id="kobo.360.2">Let’s look at both patterns </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">in detail.</span></span></p>
<h3><span class="koboSpan" id="kobo.362.1">Imperative unsubscription management</span></h3>
<p><span class="koboSpan" id="kobo.363.1">Imperative unsubscription means that </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.364.1">we manually call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">unsubscribe()</span></strong><span class="koboSpan" id="kobo.366.1"> method on the subscription object that we manage ourselves. </span><span class="koboSpan" id="kobo.366.2">The following code snippet </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">illustrates this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
export class RecipesListComponent implements OnInit,
OnDestroy {
  recipes!: Recipe[];
  subscription: Subscription;
  constructor(private service: RecipesService) { }
ngOnInit(): void {
  this.subscription=this.service.getRecipes()
  .subscribe(result =&gt; {
    this.recipes = result;
});
}
ngOnDestroy(): void {
  this.subscription?.unsubscribe();
}</span></pre> <p><span class="koboSpan" id="kobo.369.1">Here, we simply store the</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.370.1"> subscription inside a variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">subscription</span></strong><span class="koboSpan" id="kobo.372.1"> and unsubscribe from it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">ngOnDestroy()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.374.1">lifecycle hook.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">This works fine, but it is not a recommended pattern. </span><span class="koboSpan" id="kobo.375.2">There is a better way, using the power </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">of RxJS.</span></span></p>
<h3><span class="koboSpan" id="kobo.377.1">Declarative unsubscription management</span></h3>
<p><span class="koboSpan" id="kobo.378.1">The second unsubscription method is cleaner and far </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.379.1">more declarative, using the RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">takeUntil</span></strong><span class="koboSpan" id="kobo.381.1"> operator. </span><span class="koboSpan" id="kobo.381.2">However, before we dive into this pattern, let’s gain an understanding of the role of </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">takeUntil</span></strong><span class="koboSpan" id="kobo.383.1"> using the following </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">marble diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.385.1"><img alt="Figure 3.3 – The takeUntil marble diagram" src="image/B21180_03_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.386.1">Figure 3.3 – The takeUntil marble diagram</span></p>
<p><span class="koboSpan" id="kobo.387.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.389.1"> operator emits values from the source Observable (the first timeline) until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">Observable</span></strong><span class="koboSpan" id="kobo.391.1"> notifier, which is given as input (the second timeline), emits a value. </span><span class="koboSpan" id="kobo.391.2">At that time, </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.393.1"> will stop the emission and complete. </span><span class="koboSpan" id="kobo.393.2">In the marble diagram, the source Observable emitted the values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">a</span></strong><span class="koboSpan" id="kobo.395.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">b</span></strong><span class="koboSpan" id="kobo.397.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">c</span></strong><span class="koboSpan" id="kobo.399.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">d</span></strong><span class="koboSpan" id="kobo.401.1"> – so </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.403.1"> will emit them, respectively. </span><span class="koboSpan" id="kobo.403.2">After that, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Observable</span></strong><span class="koboSpan" id="kobo.405.1"> notifier emits </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">z</span></strong><span class="koboSpan" id="kobo.407.1">, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.409.1"> will stop emitting values and will </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">be completed.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">In our application, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">takeUntil</span></strong><span class="koboSpan" id="kobo.413.1"> operator will help us keep the subscription alive for a period that we define. </span><span class="koboSpan" id="kobo.413.2">We </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.414.1">want it to be alive until the component has been destroyed, so we will create an RxJS subject that will emit a value when the component has been destroyed. </span><span class="koboSpan" id="kobo.414.2">Then, we will pass this subject to </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">takeUntil</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.416.1">as input:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
export class RecipesListComponent implements OnInit,
OnDestroy {
  recipes!: Recipe[];
  destroy$ = new Subject&lt;void&gt;();
  constructor(private service: RecipesService) { }
ngOnInit(): void {
  this.service.getRecipes().pipe(
    takeUntil(this.destroy$)).
</span><span class="koboSpan" id="kobo.417.2">    subscribe(result =&gt; {
    this.recipes = result;
  });
}
ngOnDestroy(): void {
  this.destroy$.next();
  this.destroy$.complete();
}
}</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.418.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.419.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">$</span></strong><span class="koboSpan" id="kobo.421.1"> sign is an informal convention that is used to indicate that the variable is </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">an Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">The first thing you might notice </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.424.1">here is that it’s less code than the first approach. </span><span class="koboSpan" id="kobo.424.2">Furthermore, when we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">unsubscribe()</span></strong><span class="koboSpan" id="kobo.426.1"> on a returned subscription object (the first way), there’s no way we can be notified that the unsubscription happened. </span><span class="koboSpan" id="kobo.426.2">However, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.428.1">, we will be notified of the Observable completion through the </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">completion handler.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">It is worth noting that this implementation can be further enhanced by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">takeUntilDestroyed</span></strong><span class="koboSpan" id="kobo.432.1"> operator introduced in Angular 16. </span><span class="koboSpan" id="kobo.432.2">This operator simplifies Observable subscription management in your Angular components and directives. </span><span class="koboSpan" id="kobo.432.3">It automatically completes subscriptions when the associated component or directive is destroyed, eliminating the need for manual cleanup in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">ngOnDestroy</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.434.1">lifecycle hook.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">You only have to import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">takeUntilDestroyed</span></strong><span class="koboSpan" id="kobo.437.1"> operator from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">@angular/core/rxjs-interop</span></strong><span class="koboSpan" id="kobo.439.1"> package </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';</span></pre> <p><span class="koboSpan" id="kobo.442.1">Then, we use this operator within the pipe operator of our subscription. </span><span class="koboSpan" id="kobo.442.2">The previous code will look like this after </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">takeUntilDestroyed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.446.1">
export class RecipesListComponent {
  recipes!: Recipe[];
  constructor(private service: RecipesService) {
    this.service.getRecipes().pipe(takeUntilDestroyed())
      .subscribe(result=&gt;this.recipes = result);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.447.1">As you can see, the manual cleanup code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">ngOnDestroy</span></strong><span class="koboSpan" id="kobo.449.1"> lifecycle hook has been removed along with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">destroy$</span></strong><span class="koboSpan" id="kobo.451.1"> subject, resulting in a more concise and readable </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">component implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">takeUntilDestroyed()</span></strong><span class="koboSpan" id="kobo.455.1"> operator will automatically handle the subscription cleanup when </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">RecipesListComponent</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.457.1">is destroyed.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">Apart from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">takeUntil</span></strong><span class="koboSpan" id="kobo.460.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">takeUntilDestroyed</span></strong><span class="koboSpan" id="kobo.462.1"> operators, there are other operators that manage unsubscription for you in a more reactive way. </span><span class="koboSpan" id="kobo.462.2">The following are </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">some examples:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">take(X)</span></strong><span class="koboSpan" id="kobo.465.1">: This emits </span><em class="italic"><span class="koboSpan" id="kobo.466.1">x</span></em><span class="koboSpan" id="kobo.467.1"> values</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.468.1"> and then completes (will no longer emit values). </span><span class="koboSpan" id="kobo.468.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">take(3)</span></strong><span class="koboSpan" id="kobo.470.1"> will emit three values from the given Observable and then complete. </span><span class="koboSpan" id="kobo.470.2">However, bear in mind that if your network is slow and the </span><em class="italic"><span class="koboSpan" id="kobo.471.1">xth</span></em><span class="koboSpan" id="kobo.472.1"> emission didn’t happen, then you have to </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">unsubscribe manually.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">first()</span></strong><span class="koboSpan" id="kobo.475.1">: This emits the first value and </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">then completes.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">last()</span></strong><span class="koboSpan" id="kobo.478.1">: This emits the last value and </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">then completes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.480.1">This was the classic pattern that we have all learned as a beginner, and it is a relatively valid way for fetching data. </span><span class="koboSpan" id="kobo.480.2">To sum up, the following diagram describes all the steps that we </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">walked through:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.482.1"><img alt="Figure 3.4 – The classic pattern workflow" src="image/B21180_03_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.483.1">Figure 3.4 – The classic pattern workflow</span></p>
<p><span class="koboSpan" id="kobo.484.1">However, there is another</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.485.1"> pattern that we can use, which is much more declarative and reactive and has many advantages. </span><span class="koboSpan" id="kobo.485.2">We’ll discover </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">it next!</span></span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.487.1">Exploring the reactive pattern for fetching data</span></h1>
<p><span class="koboSpan" id="kobo.488.1">The idea behind this reactive pattern is to keep </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.489.1">and use the Observable as a stream throughout the application. </span><span class="koboSpan" id="kobo.489.2">Don’t worry – this will become more apparent to you as you explore this section. </span><span class="koboSpan" id="kobo.489.3">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">get started.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.491.1">Retrieving data as streams</span></h2>
<p><span class="koboSpan" id="kobo.492.1">To start using the reactive pattern, instead</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.493.1"> of defining a method to retrieve our data, we will declare a variable inside </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">our service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.495.1">
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Recipe } from '../model/recipe';
import { environment } from 'src/environments/environment';
const BASE_PATH = environment.basePath
@Injectable({
providedIn: 'root'
})
export class RecipesService {
recipes$ = this.http.get&lt;Recipe[]&gt;(
`${BASE_PATH}/recipes`);
constructor(private http: HttpClient) { }
}</span></pre> <p><span class="koboSpan" id="kobo.496.1">Here, we are declaring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">recipes$</span></strong><span class="koboSpan" id="kobo.498.1"> variable as the result of HTTP GET, which is either an Observable or the data stream. </span><span class="koboSpan" id="kobo.498.2">Think of every piece of data that changes over time as a stream and declare it </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.499.1">as an Observable in a separate service. </span><span class="koboSpan" id="kobo.499.2">This will make it accessible throughout the app and give us more flexibility to manipulate it in different parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">the application.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.501.1">Defining the stream in your component</span></h2>
<p><span class="koboSpan" id="kobo.502.1">Now, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.504.1">, we are going to do the same thing we did in the classic pattern – that is, declare a </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.505.1">variable holding the stream returned from our service. </span><span class="koboSpan" id="kobo.505.2">However, this time, the variable is the Observable we created </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">RecipesService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.509.1">
import { Component, OnDestroy, OnInit } from '@angular/core';
import { RecipesService } from '../core/services/recipes.
</span><span class="koboSpan" id="kobo.509.2">Service';
@Component({
selector: 'app-recipes-list',
standalone: true,
imports: [CommonModule],
templateUrl: './recipes-list.component.html',
styleUrls: ['./recipes-list.component.css']
})
export class RecipesListComponent implements OnInit {
recipes$= this.service.recipes$;
constructor(private service: RecipesService) { }
}</span></pre> <p><span class="koboSpan" id="kobo.510.1">But wait! </span><span class="koboSpan" id="kobo.510.2">We need to</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.511.1"> subscribe in order to get the emitted data, right? </span><span class="koboSpan" id="kobo.511.2">That’s absolutely correct. </span><span class="koboSpan" id="kobo.511.3">Let’s see how we will </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">do it.</span></span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.513.1">Using the async pipe in your template</span></h2>
<p><span class="koboSpan" id="kobo.514.1">For this pattern, we will not subscribe </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.515.1">manually but instead, use a better way, the async pipe. </span><span class="koboSpan" id="kobo.515.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.516.1">async pipe</span></strong><span class="koboSpan" id="kobo.517.1"> makes rendering values </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.518.1">emitted from the </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">Observable easier.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">First of all, it automatically subscribes to the input Observable. </span><span class="koboSpan" id="kobo.520.2">Then, it returns the latest value emitted. </span><span class="koboSpan" id="kobo.520.3">Best of all, when the component has been destroyed, it automatically unsubscribes to avoid any potential memory leaks. </span><span class="koboSpan" id="kobo.520.4">This means there is no need to manually clean up any subscriptions when the component has been destroyed. </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">That’s amazing!</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">So, in the template, we bind to an Observable using the async pipe. </span><span class="koboSpan" id="kobo.522.2">As </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">recipes</span></strong><span class="koboSpan" id="kobo.524.1"> describes the array variable that the values are emitted into, we can use it in the template </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.526.1">
&lt;div *ngIf="recipes$ |async as recipes" class="card"&gt;
&lt;p-dataView #dv [value]="recipes" [paginator]="true"
[rows]="9"    filterBy="name" layout="grid"&gt;
/** Extra code here **/
&lt;/p-dataView&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.527.1">As you may have noticed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.529.1"> element contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">*ngIf</span></strong><span class="koboSpan" id="kobo.531.1"> structural directive. </span><span class="koboSpan" id="kobo.531.2">This directive conditionally renders its </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.532.1">child elements based on the truthiness of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">recipes$ | </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">async</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.535.1"> expression.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">recipes$ | async</span></strong><span class="koboSpan" id="kobo.538.1"> expression subscribes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">recipes$</span></strong><span class="koboSpan" id="kobo.540.1"> Observable and asynchronously renders the child elements of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.542.1"> element (which is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">DataView</span></strong><span class="koboSpan" id="kobo.544.1"> component in our case) when the Observable emits a value. </span><span class="koboSpan" id="kobo.544.2">It also unsubscribes and cleans up the subscription </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.545.1">when the element is removed from the </span><strong class="bold"><span class="koboSpan" id="kobo.546.1">DOM</span></strong><span class="koboSpan" id="kobo.547.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.548.1">Document </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.549.1">Object Model</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">*ngIf</span></strong><span class="koboSpan" id="kobo.553.1"> directive is followed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">as recipes</span></strong><span class="koboSpan" id="kobo.555.1">, which assigns the emitted value from the Observable to the local </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">recipes</span></strong><span class="koboSpan" id="kobo.557.1"> variable. </span><span class="koboSpan" id="kobo.557.2">This allows us to access the emitted value within the scope of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.559.1"> element and its children using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">recipes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1"> variable.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">By using the async pipes, we don’t need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">ngOnInit</span></strong><span class="koboSpan" id="kobo.564.1"> lifecycle hook, as we will not subscribe to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">Observable</span></strong><span class="koboSpan" id="kobo.566.1"> notifier in </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">ngOnInit()</span></strong><span class="koboSpan" id="kobo.568.1"> and unsubscribe from </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">ngOnDestroy()</span></strong><span class="koboSpan" id="kobo.570.1"> as we did in the classic pattern. </span><span class="koboSpan" id="kobo.570.2">Instead, we simply set a local property in our component and we are good to go – we don’t need to handle the subscription and unsubscription on </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">our own!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.572.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.573.1">The full code of the HTML template is available in the </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.575.1">To sum up this pattern, the following diagram describes all the steps we </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">walked through:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.577.1"><img alt="Figure 3.5 – The reactive pattern workflow" src="image/B21180_03_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.578.1">Figure 3.5 – The reactive pattern workflow</span></p>
<p><span class="koboSpan" id="kobo.579.1">Now that we have explained the</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.580.1"> reactive pattern in action, in the next section, let’s review </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">its advantages.</span></span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.582.1">Highlighting the advantages of the reactive pattern</span></h1>
<p><span class="koboSpan" id="kobo.583.1">I think you might have guessed the first advantage</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.584.1"> of the reactive pattern – we don’t have to manually manage subscriptions and unsubscriptions, and what a relief – but there are a lot of other advantages. </span><span class="koboSpan" id="kobo.584.2">Let’s look at the other advantages in </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">more detail.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.586.1">Using the declarative approach</span></h2>
<p><span class="koboSpan" id="kobo.587.1">Let’s shed light on why we don’t explicitly use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">subscribe()</span></strong><span class="koboSpan" id="kobo.589.1"> method. </span><span class="koboSpan" id="kobo.589.2">What’s wrong with </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">subscribe()</span></strong><span class="koboSpan" id="kobo.591.1">? </span><span class="koboSpan" id="kobo.591.2">Well, subscribing to</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.592.1"> a stream inside our component means we are allowing imperative code to leak into our functional and reactive code. </span><span class="koboSpan" id="kobo.592.2">Using the RxJS Observables does not make our code reactive and </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">declarative systematically.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">But what does declarative mean, exactly? </span><span class="koboSpan" id="kobo.594.2">Well, first, we will nail down some key terms. </span><span class="koboSpan" id="kobo.594.3">Then, let’s iterate </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">from there:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.596.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.597.1">pure function</span></strong><span class="koboSpan" id="kobo.598.1"> is a function that will always return identical outputs for identical inputs, no matter</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.599.1"> how many times it is called. </span><span class="koboSpan" id="kobo.599.2">In other words, the function will always predictably produce the </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">same output.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.601.1">Declarative</span></strong><span class="koboSpan" id="kobo.602.1"> refers to the use of declared </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.603.1">functions to perform actions. </span><span class="koboSpan" id="kobo.603.2">You rely upon pure functions that can define an event flow. </span><span class="koboSpan" id="kobo.603.3">With RxJS, you can see this in the form of Observables </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">and </span></span><span class="No-Break"><a id="_idIndexMarker097"/></span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">operators.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.606.1">So, why should you care? </span><span class="koboSpan" id="kobo.606.2">Well, you should care because the declarative approach using RxJS operators and Observables has many advantages, namely, </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.608.1">It makes your code cleaner and </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">more readable.</span></span></li>
<li><span class="koboSpan" id="kobo.610.1">It makes your code easier to test because it </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">is predictable.</span></span></li>
<li><span class="koboSpan" id="kobo.612.1">It makes you able to cache the stream output given a certain input, and this will enhance performance. </span><span class="koboSpan" id="kobo.612.2">We will explore this in more detail in </span><a href="B21180_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.613.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.614.1">, </span><em class="italic"><span class="koboSpan" id="kobo.615.1">Sharing Data between Angular Components</span></em><span class="koboSpan" id="kobo.616.1">, </span><a href="B21180_09.xhtml#_idTextAnchor146"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.617.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.618.1">, </span><em class="italic"><span class="koboSpan" id="kobo.619.1">Demystifying Multicasting</span></em><span class="koboSpan" id="kobo.620.1">, and </span><a href="B21180_10.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.621.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.622.1">, </span><em class="italic"><span class="koboSpan" id="kobo.623.1">Boosting Performance with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.624.1">Reactive Caching</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.626.1">It enables you to leverage RxJS operators and transform and combine streams coming from different services or even within the same service. </span><span class="koboSpan" id="kobo.626.2">This is what we will see in </span><a href="B21180_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.627.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.628.1">, </span><em class="italic"><span class="koboSpan" id="kobo.629.1">Combining Streams</span></em><span class="koboSpan" id="kobo.630.1">, and </span><a href="B21180_06.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.631.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.632.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.633.1">Transforming Streams</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.635.1">It helps you react easily to user interactions in order to execute </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">an action.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.637.1">So, more declarative means more reactive. </span><span class="koboSpan" id="kobo.637.2">However, be careful. </span><span class="koboSpan" id="kobo.637.3">This doesn’t mean you can’t ever call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">subscribe()</span></strong><span class="koboSpan" id="kobo.639.1"> method. </span><span class="koboSpan" id="kobo.639.2">It is unavoidable in some situations to trigger the </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">Observable</span></strong><span class="koboSpan" id="kobo.641.1"> notifier. </span><span class="koboSpan" id="kobo.641.2">But try to ask yourself: do I really need to subscribe here? </span><span class="koboSpan" id="kobo.641.3">Can I instead compose multiple streams together, or use RxJS operators, to achieve what I need without subscribing? </span><span class="koboSpan" id="kobo.641.4">Aside from cases where it is unavoidable, never </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">subscribe()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.645.1">Now, let’s move to the change detection concept and see how it can </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">improve performance.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.647.1">Using the change detection strategy of OnPush</span></h2>
<p><span class="koboSpan" id="kobo.648.1">The other really cool thing is that we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">changeDetection</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.650.1">strategy, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">OnPush</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.653.1">Change detection</span></strong><span class="koboSpan" id="kobo.654.1"> is one of the</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.655.1"> most powerful features of Angular. </span><span class="koboSpan" id="kobo.655.2">It is about detecting when the component’s data </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.656.1">changes and then automatically re-rendering the view or updating the DOM to reflect that change. </span><span class="koboSpan" id="kobo.656.2">The default strategy of “check always” means that, whenever any data is mutated or changed, Angular will run the change detector to update the DOM. </span><span class="koboSpan" id="kobo.656.3">So, it is automatic until </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">explicitly deactivated.</span></span></p>
<p><span class="koboSpan" id="kobo.658.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">OnPush</span></strong><span class="koboSpan" id="kobo.660.1"> strategy, Angular will only run the change detector when one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">following occurs:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.662.1">Condition 1</span></em><span class="koboSpan" id="kobo.663.1">: A reference of a component’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">@Input</span></strong><span class="koboSpan" id="kobo.665.1"> property changes (bear in mind that when the input property object is mutated directly, then the reference of the object will not change and, consequently, the change detector will not run. </span><span class="koboSpan" id="kobo.665.2">In this case, we should return a new reference of the property object to trigger the </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">change detection).</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.667.1">Condition 2</span></em><span class="koboSpan" id="kobo.668.1">: A component event handler is emitted or </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">gets triggered.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.670.1">Condition 3</span></em><span class="koboSpan" id="kobo.671.1">: A bound Observable via the async pipe emits a </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">new value.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.673.1">Therefore, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">ChangeDetection</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.675.1">OnPush</span></strong><span class="koboSpan" id="kobo.676.1"> strategy minimizes any change detection cycles and will only check for changes to re-render our components in the preceding cases. </span><span class="koboSpan" id="kobo.676.2">This strategy applies to all child directives and cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">be overridden.</span></span></p>
<p><span class="koboSpan" id="kobo.678.1">In our scenario, we only need the change detector to run if we get a new value; otherwise, we get useless updates. </span><span class="koboSpan" id="kobo.678.2">So, our scenario matches </span><em class="italic"><span class="koboSpan" id="kobo.679.1">Condition 3</span></em><span class="koboSpan" id="kobo.680.1">. </span><span class="koboSpan" id="kobo.680.2">The good news is that we can use the change detection </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">onPush</span></strong><span class="koboSpan" id="kobo.682.1"> strategy </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.684.1">
import { ChangeDetectionStrategy, Component} from
'@angular/ core';
@Component({
  selector: 'app-recipes-list',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './recipes-list.component.html',
  styleUrls: ['./recipes-list.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})</span></pre> <p><span class="koboSpan" id="kobo.685.1">If we remember to use the async pipe</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.686.1"> as much as possible, we will see a couple </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">of advantages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.688.1">We will make it easier to later switch from the default change detection strategy to </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">OnPush</span></strong><span class="koboSpan" id="kobo.690.1"> if we </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">need to</span></span></li>
<li><span class="koboSpan" id="kobo.692.1">We will run into fewer change detection cycles </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">OnPush</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.695.1">In general, using the async pipe will help you to achieve a high-performing UI, and it will have a lot of impact if your view is doing </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">multiple tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">And here’s the output of our UI after all of that work in </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">the chapter:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.699.1"><img alt="Figure 3.6 – An overview of the list of recipes" src="image/B21180_03_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.700.1">Figure 3.6 – An overview of the list of recipes</span></p>
<p><span class="koboSpan" id="kobo.701.1">So, after all that, in a nutshell, using the reactive pattern for fetching data will improve the performance of your application, the change detection strategy, and the code clarity and readability. </span><span class="koboSpan" id="kobo.701.2">As well as that, it will make the code more declarative and reactive, it will make it easier to leverage RxJS operators, and it will make it easier to react to </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">user actions.</span></span></p>
<p><span class="koboSpan" id="kobo.703.1">Now that we’ve established the</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.704.1"> reactive pattern, let’s conclude this chapter by exploring an intriguing feature introduced in Angular 17, understanding its benefits, and applying it in practice within our </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">recipe</span></span><span class="No-Break"><span class="koboSpan" id="kobo.706.1"> app.</span></span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.707.1">Diving into the built-in control flow in Angular 17</span></h1>
<p><span class="koboSpan" id="kobo.708.1">Before Angular 17, control flow within </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.709.1">templates was predominantly managed using structural directives. </span><span class="koboSpan" id="kobo.709.2">Let’s start by exploring the </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">structural directives.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.711.1">Structural directives</span></h2>
<p><span class="koboSpan" id="kobo.712.1">Structural directives are responsible for </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.713.1">altering the structure of the DOM and orchestrating how elements are added, removed, or repeated based on certain conditions. </span><span class="koboSpan" id="kobo.713.2">Here’s the list of available directives in Angular to control the execution of </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">the template:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">*ngIf</span></strong><span class="koboSpan" id="kobo.716.1">: This structural directive is used to conditionally include or exclude elements from the DOM based on the truthiness of an expression. </span><span class="koboSpan" id="kobo.716.2">For instance, consider the following code snippet, which displays the message </span><strong class="bold"><span class="koboSpan" id="kobo.717.1">No items found</span></strong><span class="koboSpan" id="kobo.718.1"> if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">items</span></strong><span class="koboSpan" id="kobo.720.1"> array </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">is empty:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.722.1">
&lt;div *ngIf="items.length === 0"&gt;No items found &lt;/div&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.723.1">To display alternative content when the condition is false, we can use an </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">else</span></strong><span class="koboSpan" id="kobo.725.1"> statement, </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">like so:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.727.1">&lt;div *ngIf="items.length === 0; else itemsFound"&gt;
  &lt;div&gt;No items found&lt;/div&gt;
&lt;/div&gt;
&lt;ng-template #itemsFound&gt;
  &lt;div&gt;Items found&lt;/div&gt;
&lt;/ng-template&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.728.1">In this code, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">items</span></strong><span class="koboSpan" id="kobo.730.1"> array is not empty, the content inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">else </span></strong><span class="koboSpan" id="kobo.732.1">block defined by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">ng-template</span></strong><span class="koboSpan" id="kobo.734.1"> element with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">#itemsFound</span></strong><span class="koboSpan" id="kobo.736.1"> reference will be displayed, indicating </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.737.1">Items found</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">.</span></span></p></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">*ngFor</span></strong><span class="koboSpan" id="kobo.740.1">: This structural directive is used for iteration. </span><span class="koboSpan" id="kobo.740.2">It repeats a section of HTML for each item in an</span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.741.1"> iterable collection. </span><span class="koboSpan" id="kobo.741.2">For example, this code renders a list of products one </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">by one:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.743.1">
&lt;ul&gt;
  &lt;li *ngFor="let product of products"&gt;
    {{ product.name }}
  &lt;/li&gt;
&lt;/ul&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.744.1">In order to improve performance, you can optionally add a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">trackBy</span></strong><span class="koboSpan" id="kobo.746.1"> function that provides a unique identifier for each item in the list. </span><span class="koboSpan" id="kobo.746.2">This is achieved by modifying the previous code, shown </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.748.1">&lt;ul&gt;
  &lt;li *ngFor="let product of products; trackBy:
    trackProduct"&gt;{{ product.name }}
  &lt;/li&gt;
&lt;/ul&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.749.1">Then, define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">trackProduct</span></strong><span class="koboSpan" id="kobo.751.1"> function in your component class to return the unique identifier of each product item </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.753.1">trackProduct(index: number, product: Product) {
  return product ? </span><span class="koboSpan" id="kobo.753.2">product.id : undefined;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.754.1">This way, Angular can more efficiently track changes within the list. </span><span class="koboSpan" id="kobo.754.2">It will only update the DOM elements that actually changed, instead of re-rendering the entire list for minor changes. </span><span class="koboSpan" id="kobo.754.3">This leads to a smoother user experience, especially when dealing with large or frequently </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">updated lists.</span></span></p></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">ngSwitch</span></strong><span class="koboSpan" id="kobo.757.1">: This structural</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.758.1"> directive is used to conditionally include or exclude elements from the DOM based on the evaluated value of a provided expression. </span><span class="koboSpan" id="kobo.758.2">It is commonly used when there are multiple conditions to be evaluated. </span><span class="koboSpan" id="kobo.758.3">Here’s an example that renders different views based on </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">user roles:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.760.1">
&lt;div [ngSwitch]="userRole"&gt;
  &lt;admin-dashboard *ngSwitchCase="admin" &gt;
    &lt;/admin-dashboard&gt;
  &lt;user-dashboard *ngSwitchCase="'user'" &gt;
    &lt;/user-dashboard&gt;
  &lt;guest-dashboard *ngSwitchDefault &gt;
    &lt;/guest-dashboard&gt;
&lt;/div&gt;</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.761.1">Now that we’ve explored the structural directives in Angular, which provided a mechanism for dynamically altering the structure of the DOM based on certain conditions, we can delve into the next evolution of control flow management within Angular templates. </span><span class="koboSpan" id="kobo.761.2">With the release of Angular version 17, a new paradigm emerges: the built-in control flow. </span><span class="koboSpan" id="kobo.761.3">Let’s delve into the details of this exciting new feature and explore how it enhances the Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">development experience.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.763.1">Built-in control flows</span></h2>
<p><span class="koboSpan" id="kobo.764.1">Built-in control flows offer a more concise and </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.765.1">declarative way to manage control flow logic directly within your component templates, eliminating the need for structural directives. </span><span class="koboSpan" id="kobo.765.2">Here are the new built-in control </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">flow statements.</span></span></p>
<h3><span class="koboSpan" id="kobo.767.1">Built-in if statement</span></h3>
<p><span class="koboSpan" id="kobo.768.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">@if</span></strong><span class="koboSpan" id="kobo.770.1"> statement conditionally renders </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.771.1">content based on a </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">Boolean expression.</span></span></p>
<p><span class="koboSpan" id="kobo.773.1">Let’s consider the previous example </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">*ngIf</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.777.1">
&lt;div *ngIf="items.length === 0; else itemsFound"&gt;
  &lt;div&gt;No items found&lt;/div&gt;
&lt;/div&gt;
&lt;ng-template #itemsFound&gt;
  &lt;div&gt;Items found&lt;/div&gt;
&lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.778.1">Using the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">@if</span></strong><span class="koboSpan" id="kobo.780.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">@else</span></strong><span class="koboSpan" id="kobo.782.1"> statements, the example will now look </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.784.1">
@if (items.length === 0) {
  &lt;div&gt; No items found &lt;/div&gt;
} @else {
&lt;div&gt; Items found &lt;/div&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.785.1">As you may have noticed, there are differences in syntax between the two code blocks. </span><span class="koboSpan" id="kobo.785.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">@if</span></strong><span class="koboSpan" id="kobo.787.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">@else</span></strong><span class="koboSpan" id="kobo.789.1"> statements replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">*ngIf</span></strong><span class="koboSpan" id="kobo.791.1"> directive and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">ng-template</span></strong><span class="koboSpan" id="kobo.793.1"> element by providing a more intuitive and JavaScript-like syntax for handling conditional rendering within component templates. </span><span class="koboSpan" id="kobo.793.2">You can optionally use an </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">@else</span></strong><span class="koboSpan" id="kobo.795.1"> statement to provide alternative content when the condition evaluates </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">to false.</span></span></p>
<p><span class="koboSpan" id="kobo.797.1">Furthermore, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">*ngIf</span></strong><span class="koboSpan" id="kobo.799.1"> requires importing </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">CommonModule</span></strong><span class="koboSpan" id="kobo.801.1"> to function properly, </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">@if</span></strong><span class="koboSpan" id="kobo.803.1"> is a standalone statement that can be directly used within the template without any </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">additional imports.</span></span></p>
<p><span class="koboSpan" id="kobo.805.1">Additionally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">@if</span></strong><span class="koboSpan" id="kobo.807.1"> block may </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.808.1">have one or more associated </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">@else</span></strong><span class="koboSpan" id="kobo.810.1"> blocks. </span><span class="koboSpan" id="kobo.810.2">After an </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">@if</span></strong><span class="koboSpan" id="kobo.812.1"> block, you can optionally chain any number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">@else if</span></strong><span class="koboSpan" id="kobo.814.1"> blocks and one </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">@else</span></strong><span class="koboSpan" id="kobo.816.1"> block </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.818.1">
@if (age &gt;= 18) {
  You are an adult.
</span><span class="koboSpan" id="kobo.818.2">} @else if (age &gt;= 13) {
  You are a teenager.
</span><span class="koboSpan" id="kobo.818.3">} @else {
  You are a child.
</span><span class="koboSpan" id="kobo.818.4">}</span></pre> <h3><span class="koboSpan" id="kobo.819.1">Built-in for-loop statement</span></h3>
<p><span class="koboSpan" id="kobo.820.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">@for</span></strong><span class="koboSpan" id="kobo.822.1"> statement iterates over a </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.823.1">collection of data and renders content for </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">each item.</span></span></p>
<p><span class="koboSpan" id="kobo.825.1">Let’s take the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">*ngFor</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.827.1">example again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.828.1">
&lt;ul&gt;
  &lt;li *ngFor="let product of products; trackBy:
    trackProduct"&gt;{{ product.name }}
  &lt;/li&gt;
&lt;/ul&gt;</span></pre> <p><span class="koboSpan" id="kobo.829.1">Using the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">@for</span></strong><span class="koboSpan" id="kobo.831.1"> statement, the example will look </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.833.1">
@for (product of products; track product.id) {
  {{ product.name }}
}</span></pre> <p><span class="koboSpan" id="kobo.834.1">Replacing the previously optional </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">trackBy</span></strong><span class="koboSpan" id="kobo.836.1"> function used with </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">*ngFor</span></strong><span class="koboSpan" id="kobo.838.1"> is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">track</span></strong><span class="koboSpan" id="kobo.840.1"> function within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">@for</span></strong><span class="koboSpan" id="kobo.842.1"> statement. </span><span class="koboSpan" id="kobo.842.2">Both approaches serve the same core purpose, enabling Angular to efficiently track changes within your iterated lists by focusing on the unique identifier of each item</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.843.1"> rather than its position in </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">the array.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.845.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.846.1">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">trackBy</span></strong><span class="koboSpan" id="kobo.848.1"> was optional, its absence often led to performance issues. </span><span class="koboSpan" id="kobo.848.2">However, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">track</span></strong><span class="koboSpan" id="kobo.850.1"> is now mandatory within </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">@for</span></strong><span class="koboSpan" id="kobo.852.1"> loops, ensuring optimal rendering speed </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">by default.</span></span></p>
<p><span class="koboSpan" id="kobo.854.1">A significant advantage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">track</span></strong><span class="koboSpan" id="kobo.856.1"> is its ease of use compared to </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">trackBy</span></strong><span class="koboSpan" id="kobo.858.1">. </span><span class="koboSpan" id="kobo.858.2">You can directly include an expression representing the unique identifier of each item within the template itself, eliminating the need for a separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">trackBy</span></strong><span class="koboSpan" id="kobo.860.1"> method in your component class (</span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">trackProduct</span></strong><span class="koboSpan" id="kobo.862.1"> in the previous example). </span><span class="koboSpan" id="kobo.862.2">This streamlines your code and </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">improves readability.</span></span></p>
<p><span class="koboSpan" id="kobo.864.1">The transition to </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">track</span></strong><span class="koboSpan" id="kobo.866.1"> is designed to be seamless for developers who have already implemented </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">trackBy</span></strong><span class="koboSpan" id="kobo.868.1"> functions and wish to migrate without removing those methods. </span><span class="koboSpan" id="kobo.868.2">They can seamlessly retain the existing methods and simply update the template </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.870.1">
@for (product of products; track trackProduct($index, product) {
  {{ product.name }}
}</span></pre> <p><span class="koboSpan" id="kobo.871.1">This ensures backward compatibility and a smooth </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">transition process.</span></span></p>
<p><span class="koboSpan" id="kobo.873.1">In essence, </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">track</span></strong><span class="koboSpan" id="kobo.875.1"> offers a mandatory and simplified approach to change tracking within </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">@for</span></strong><span class="koboSpan" id="kobo.877.1"> loops, promoting optimal performance and a more concise syntax in your </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">Angular applications.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.879.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.880.1">It is worth mentioning that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">@for</span></strong><span class="koboSpan" id="kobo.882.1"> statement uses a new diffing algorithm and offers a more optimized implementation compared to </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">*ngFor</span></strong><span class="koboSpan" id="kobo.884.1">. </span><span class="koboSpan" id="kobo.884.2">This enhancement results in up to 90% faster runtime according to community framework benchmarks. </span><span class="koboSpan" id="kobo.884.3">For more information, refer </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">to </span></span><a href="https://krausest.github.io/js-framework-benchmark/current.html"><span class="No-Break"><span class="koboSpan" id="kobo.886.1">https://krausest.github.io/js-framework-benchmark/current.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.887.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.888.1">Furthermore, the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">@for</span></strong><span class="koboSpan" id="kobo.890.1"> loop has a </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.891.1">shortcut to deal with empty collections, referred to as the optional </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">empty</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.894.1"> block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.895.1">
@for (product of products; track product.id) {
  {{ product.name }}
} @empty {
  Empty list of products
}</span></pre> <p><span class="koboSpan" id="kobo.896.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">@empty</span></strong><span class="koboSpan" id="kobo.898.1"> block offers a convenient and efficient way to display informative messages or alternative content when no data is available. </span><span class="koboSpan" id="kobo.898.2">It promotes a better user experience and keeps your component </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">logic well-organized.</span></span></p>
<p><span class="koboSpan" id="kobo.900.1">We went into a bit of detail there, so to summarize, here are the key benefits of the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">for</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.903.1"> statement:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.904.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">@for</span></strong><span class="koboSpan" id="kobo.906.1"> syntax offers a cleaner and more readable way to iterate over lists, display alternative content when no data is available, and define unique identifiers for the </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">list items.</span></span></li>
<li><span class="koboSpan" id="kobo.908.1">By requiring </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">track</span></strong><span class="koboSpan" id="kobo.910.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">@for</span></strong><span class="koboSpan" id="kobo.912.1"> guarantees efficient DOM updates, leading to a smoother </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">user experience.</span></span></li>
<li><span class="koboSpan" id="kobo.914.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">@for</span></strong><span class="koboSpan" id="kobo.916.1"> loop leverages a new, optimized diffing algorithm compared to </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">*ngFor</span></strong><span class="koboSpan" id="kobo.918.1">. </span><span class="koboSpan" id="kobo.918.2">This has led to significant performance improvements, as evidenced by </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">community benchmarks.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.920.1">In essence, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">@for</span></strong><span class="koboSpan" id="kobo.922.1"> statement </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.923.1">provides an all-around upgrade for iterating over collections in your Angular applications. </span><span class="koboSpan" id="kobo.923.2">It empowers developers with a cleaner, more performant, and more user-friendly way to manage data </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">within templates.</span></span></p>
<h3><span class="koboSpan" id="kobo.925.1">Built-in switch statement</span></h3>
<p><span class="koboSpan" id="kobo.926.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">@switch</span></strong><span class="koboSpan" id="kobo.928.1"> statement selects content based on a </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">matching expression.</span></span></p>
<p><span class="koboSpan" id="kobo.930.1">Let’s take the previous</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.931.1"> example </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">*ngSwitch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.935.1">
&lt;div [ngSwitch]="userRole"&gt;
  &lt;admin-dashboard *ngSwitchCase="admin" &gt;
    &lt;/admin-dashboard&gt;
  &lt;user-dashboard *ngSwitchCase="'user'" &gt;
    &lt;/user-dashboard&gt;
  &lt;guest-dashboard *ngSwitchDefault &gt;
    &lt;/guest-dashboard&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.936.1">Using the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">@switch</span></strong><span class="koboSpan" id="kobo.938.1"> statement, it will now look </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.940.1">
@switch (userRole) {
  @case ('admin') { &lt;admin-dashboard/&gt; }
  @case ('user') { &lt;user-dashboard/&gt; }
  @default { &lt;guest-dashboard/&gt; }
}</span></pre> <p><span class="koboSpan" id="kobo.941.1">As you may have noticed, both </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">@switch</span></strong><span class="koboSpan" id="kobo.943.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">*ngSwitch</span></strong><span class="koboSpan" id="kobo.945.1"> achieve conditional rendering in Angular templates. </span><span class="koboSpan" id="kobo.945.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">@switch</span></strong><span class="koboSpan" id="kobo.947.1"> offers a more concise and modern approach that aligns better with current JavaScript practices. </span><span class="koboSpan" id="kobo.947.2">This syntax is more intuitive and closer to standard</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.948.1"> JavaScript switch statements, making code easier to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">and maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.950.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">@default</span></strong><span class="koboSpan" id="kobo.952.1"> block is optional and can be excluded. </span><span class="koboSpan" id="kobo.952.2">In the absence of a matching </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">@case</span></strong><span class="koboSpan" id="kobo.954.1"> and if there’s no </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">@default</span></strong><span class="koboSpan" id="kobo.956.1"> block provided, nothing will </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">be displayed.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.958.1">Including built-in control flows in our recipe app</span></h2>
<p><span class="koboSpan" id="kobo.959.1">Now that we’ve learned </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.960.1">about the new built-in control flow, let’s take advantage of it and update our template code with this </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">new syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.962.1">The HTML code of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">RecipesListComponent.html</span></strong><span class="koboSpan" id="kobo.964.1"> file uses the Angular structural directives </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">*ngIf</span></strong><span class="koboSpan" id="kobo.966.1"> (used to conditionally render the data view when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">recipes$ </span></strong><span class="koboSpan" id="kobo.968.1">Observable returns a value) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">*ngFor</span></strong><span class="koboSpan" id="kobo.970.1"> (used to iterate over the list of recipes and render a card for each recipe). </span><span class="koboSpan" id="kobo.970.2">Here is the </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.972.1">
&lt;div *ngIf="recipes$ | async as recipes" class="card"&gt;
  &lt;p-dataView #dv [value]="recipes" [paginator]="true"
  [rows]="9" filterBy="name" layout="grid"&gt;
      &lt;ng-template let-recipes pTemplate="gridItem"&gt;
        &lt;div class="grid grid-nogutter"&gt;
          &lt;div class="col-12" class="recipe-grid-item card"
          *ngFor="let recipe of recipes"&gt;
            /** Extra code here **/
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/ng-template&gt;
  &lt;/p-dataView&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.973.1">Now, let’s update this code using </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.974.1">the new built-in </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">control flow:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.976.1">
@if (recipes$ | async; as recipes) {
  &lt;div class="card"&gt;
    &lt;p-dataView #dv [value]="recipes" [paginator]="true"
    [rows]="9" filterBy="name" layout="grid"&gt;
      &lt;ng-template let-recipes pTemplate="gridItem"&gt;
        &lt;div class="grid grid-nogutter"&gt;
          @for (recipe of recipes; track recipe.id) {
            &lt;div class="col-12"
            class="recipe-grid-item card"&gt;
/** Extra code here **/
            &lt;/div&gt;
                }
        &lt;/div&gt;
      &lt;/ng-template&gt;
    &lt;/p-dataView&gt;
  &lt;/div&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.977.1">We replaced </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">*ngIf</span></strong><span class="koboSpan" id="kobo.979.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">@if</span></strong><span class="koboSpan" id="kobo.981.1"> to conditionally render the data view when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">recipes$</span></strong><span class="koboSpan" id="kobo.983.1"> Observable returns </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">a value.</span></span></p>
<p><span class="koboSpan" id="kobo.985.1">We also replaced </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">*ngFor</span></strong><span class="koboSpan" id="kobo.987.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">@for</span></strong><span class="koboSpan" id="kobo.989.1"> to iterate over the list of recipes and render a card for each recipe. </span><span class="koboSpan" id="kobo.989.2">We included within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">@for</span></strong><span class="koboSpan" id="kobo.991.1"> statement the track function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">track recipe.id</span></strong><span class="koboSpan" id="kobo.993.1">. </span><span class="koboSpan" id="kobo.993.2">The recipe’s ID is the unique identifier of </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">the recipe.</span></span></p>
<p><span class="koboSpan" id="kobo.995.1">We now have a refreshed template</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.996.1"> that not only is more performant but also aligns seamlessly with the latest version </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">of Angular.</span></span></p>
<p><span class="koboSpan" id="kobo.998.1">Additionally, if you have existing projects, you can easily migrate them to leverage the new built-in flow syntax by using the following </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">migration schematic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1000.1">
ng generate @angular/core:control-flow</span></pre> <h2 id="_idParaDest-65"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.1001.1">Benefits of built-in control flow</span></h2>
<p><span class="koboSpan" id="kobo.1002.1">There are several benefits to </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.1003.1">using Angular’s built-in control flow syntax, </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">as follows:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1005.1">Improved readability</span></em><span class="koboSpan" id="kobo.1006.1">: The syntax aligns more closely with JavaScript, making the code easier to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">and maintain.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1008.1">Reduced boilerplate</span></em><span class="koboSpan" id="kobo.1009.1">: You can remove the need for separate directive imports </span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">and properties.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1011.1">Built-in availability</span></em><span class="koboSpan" id="kobo.1012.1">: No additional imports are required; the feature is readily available out of the box in </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">your templates.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1014.1">Enhanced type safety</span></em><span class="koboSpan" id="kobo.1015.1">: The compiler provides more robust type narrowing, resulting in improved type safety and </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">error detection.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1017.1">Performance improvements</span></em><span class="koboSpan" id="kobo.1018.1">: While performance improvements can vary depending on your application’s structure and data size, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">@for</span></strong><span class="koboSpan" id="kobo.1020.1"> statement utilizes a more streamlined diffing algorithm compared to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">*ngFor</span></strong><span class="koboSpan" id="kobo.1022.1">. </span><span class="koboSpan" id="kobo.1022.2">This can potentially lead to smoother rendering and a better user experience, especially when dealing with large or frequently </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">updated lists.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1024.1">In short, the built-in control flow </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.1025.1">syntax fosters a more intuitive, concise, and performant approach to writing Angular templates. </span><span class="koboSpan" id="kobo.1025.2">It promotes code readability, reduces boilerplate, and offers enhanced </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">type safety.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.1027.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1028.1">In this chapter, we explored the classic and reactive patterns for fetching data. </span><span class="koboSpan" id="kobo.1028.2">We learned about the imperative way in which to manage unsubscriptions and the reactive pattern. </span><span class="koboSpan" id="kobo.1028.3">We explained some useful RxJS operators, and also shed light on the advantages of using the reactive pattern and learned about all the technical aspects around it. </span><span class="koboSpan" id="kobo.1028.4">We also learned about standalone components, a new edition to Angular, as well as how to create them, and what their benefits are. </span><span class="koboSpan" id="kobo.1028.5">Lastly, we delved into the new built-in control flow introduced in Angular 17, covering its various applications, syntax, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1029.1">associated benefits.</span></span></p>
<p><span class="koboSpan" id="kobo.1030.1">Now that we have retrieved our data as RxJS streams, in the next chapters, let’s start playing with those streams to react to user actions using RxJS streams and, consequently, build our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">RecipesApp</span></strong><span class="koboSpan" id="kobo.1032.1"> application in a reactive way. </span><span class="koboSpan" id="kobo.1032.2">In the next chapter, we will focus on the reactive patterns for error handling and the different strategies that </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">are available.</span></span></p>
</div>
</body></html>