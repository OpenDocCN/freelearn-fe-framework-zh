- en: '*Chapter 6*: CSS and Built-In Styling Methods'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：CSS和内置样式方法'
- en: What makes the difference between a great and a bad UI? Some people may answer
    "features!" and others may say "speed of interaction!" but I would personally
    define it as a good combination of a great design and ease of use. Your web application
    could potentially be the most powerful app in the world. Still, it would be difficult
    for your users to make it work as intended if the UI is not well designed and
    implemented. So here comes the concept of styling.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀UI和糟糕UI之间的区别是什么？有些人可能会回答“功能！”而其他人可能会说“交互速度！”但我会个人定义为优秀设计和易用性的良好结合。你的Web应用可能潜在地是世界上功能最强大的应用。然而，如果UI设计不佳且实现不当，用户很难按照预期使用它。因此，样式概念应运而生。
- en: 'We all know what CSS is: *a basic set of rules telling the browser how to render
    HTML content graphically*. While this seems an easy task, the CSS ecosystem has
    evolved a lot during recent years, and so has all the tooling that helps developers
    build great user interfaces with modular, lightweight, and performant CSS rules.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道CSS是什么：*一组基本规则，告诉浏览器如何图形化渲染HTML内容*。虽然这似乎是一个简单的任务，但CSS生态系统在近年来已经发生了很大的变化，所有帮助开发者使用模块化、轻量级和性能良好的CSS规则构建优秀用户界面的工具也发生了变化。
- en: In this chapter, we will look at several approaches to writing CSS rules. That
    will pave the way to [*Chapter 7*](B16985_07_Final_SB_epub.xhtml#_idTextAnchor081),
    *Using UI Frameworks*, where we'll implement UIs using external UI frameworks
    and utilities to make the developer experience even smoother.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨编写CSS规则的不同方法。这将为[*第7章*](B16985_07_Final_SB_epub.xhtml#_idTextAnchor081)，“使用UI框架”，铺平道路，我们将使用外部UI框架和实用工具实现UI，以使开发者的体验更加流畅。
- en: Attention
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter is not intended to teach you how to write CSS rules in any specific
    technology or language. Instead, we will look at the technologies Next.js integrates
    out of the box for writing modular, maintainable, and performant CSS styles. If
    any of the following technologies arouse your interest, I'd recommend reading
    the official documentation before moving any further into implementing a UI with
    them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的不是教你如何在任何特定的技术或语言中编写CSS规则。相反，我们将探讨Next.js默认集成的编写模块化、可维护和性能良好的CSS样式的技术。如果你对以下任何技术感兴趣，我建议在进一步实现UI之前先阅读官方文档。
- en: 'We will look in detail at the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨以下主题：
- en: Styled JSX
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Styled JSX
- en: CSS modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS模块
- en: How to integrate the SASS preprocessor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何集成SASS预处理器
- en: By the end of the chapter, you will have learned about the three different built-in
    styling methods, their differences, and how to configure them for your needs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解三种不同的内置样式方法，它们之间的区别，以及如何根据你的需求进行配置。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，你需要在本地机器上安装Node.js和npm。
- en: 'If you prefer, you can use an online IDE such as [https://repl.it](https://repl.it)
    or [https://codesandbox.io](https://codesandbox.io); they both support Next.js,
    and you don''t need to install any dependency on your computer. As for the other
    chapters, you can find the code base for this chapter on GitHub: https://github.com/PacktPublishing/Real-World-Next.js.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以使用在线IDE，例如[https://repl.it](https://repl.it)或[https://codesandbox.io](https://codesandbox.io)；它们都支持Next.js，你不需要在电脑上安装任何依赖。至于其他章节，你可以在GitHub上找到本章的代码库：https://github.com/PacktPublishing/Real-World-Next.js。
- en: Exploring and using Styled JSX
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索和使用Styled JSX
- en: In this section, we will explore Styled JSX, a built-in styling mechanism provided
    by default by Next.js.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Styled JSX，这是Next.js默认提供的内置样式机制。
- en: If you don't want to learn a new styling language such as **SASS** or **LESS**
    and want to integrate a bit of JavaScript into your CSS rules, you might be interested
    in **Styled JSX**. It's a **CSS-in-JS** library (meaning that we can use JavaScript
    to write CSS properties) created by Vercel, the company behind Next.js, that allows
    you to write CSS rules and classes that are scoped to a specific component.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想学习新的样式语言，例如**SASS**或**LESS**，并且想在CSS规则中集成一些JavaScript，那么你可能对**Styled JSX**感兴趣。它是由Next.js背后的公司Vercel创建的**CSS-in-JS**库（这意味着我们可以使用JavaScript来编写CSS属性），允许你编写作用域特定组件的CSS规则和类。
- en: 'Let me explain this concept with an easy example. Let''s say that we have a
    `Button` component, and we want to style it using Styled JSX:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我用一个简单的例子来解释这个概念。假设我们有一个`Button`组件，我们想使用Styled JSX来为其添加样式：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we're using a very generic `button` class name, which is likely
    to cause some conflicts with other components using the same class name, right?
    The answer is no! Here's why Styled JSX is so powerful. Not only does it allow
    you to write highly dynamic CSS thanks to JavaScript, but it also makes sure that
    the rule you're declaring won't affect any component other than the one you're
    writing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们使用了一个非常通用的`button`类名，这很可能会与其他使用相同类名的组件产生冲突，对吧？答案是：不会！这就是为什么Styled JSX如此强大的原因。它不仅允许你通过JavaScript编写高度动态的CSS，而且还确保你声明的规则不会影响你正在编写的组件以外的任何组件。
- en: 'So, if we now want to create a new component called `FancyButton`, we can use
    the same class name and, thanks to Styled JSX, it won''t override the `Button`
    components styles when both are rendered on page:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们现在想要创建一个名为`FancyButton`的新组件，我们可以使用相同的类名，并且由于Styled JSX，当两者都在页面上渲染时，它不会覆盖`Button`组件的样式：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The same happens with HTML selectors. If we''re writing a `Highlight` component,
    we can simply use Styled JSX to style the whole component without even declaring
    a specific class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也发生在HTML选择器上。如果我们正在编写一个`Highlight`组件，我们可以简单地使用Styled JSX来为整个组件添加样式，甚至不需要声明一个特定的类：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In that case, the `<span>` style we wrote will be applied to the `Highlight`
    component only and won't affect any other `<span>` element inside of your pages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们编写的`<span>`样式只会应用于`Highlight`组件，而不会影响你页面中的任何其他`<span>`元素。
- en: 'If you want to create a CSS rule that will be applied to all components, you
    can just use the `global` prop, and Styled JSX will apply that rule to all the
    HTML elements matching your selector:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个应用于所有组件的CSS规则，你只需使用`global`属性，并且Styled JSX会将该规则应用于所有匹配你的选择器的HTML元素：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous example, we added the `global` prop to our style declaration,
    so now, every time we use a `<span>` element, it will inherit the styles we declared
    inside of our `Highlight` component. Of course, this can be risky, so make sure
    that's what you want.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们在我们的样式声明中添加了`global`属性，因此现在每次我们使用一个`<span>`元素时，它都会继承我们在`Highlight`组件内部声明的样式。当然，这可能会有些风险，所以请确保这是你想要的。
- en: If you're wondering how to get started using Styled JSX and why we haven't covered
    this package's installation yet... that's because Styled JSX is built into Next.js,
    so you can start using it right after initializing the project!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道如何开始使用Styled JSX以及为什么我们还没有介绍这个包的安装...那是因为Styled JSX是内置在Next.js中的，所以你可以在项目初始化后立即开始使用它！
- en: 'In the next section, we''ll look at a more *classic* approach for writing CSS
    rules: CSS modules.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个部分，我们将探讨编写CSS规则的一个更*经典*的方法：CSS模块。
- en: CSS modules
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS模块
- en: In the previous section, we saw a CSS-in-JS library, meaning that we had to
    write our CSS definitions in JavaScript, transforming those styling rules to plain
    CSS at runtime or compile time, depending on which library we choose and how we
    configure it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个部分，我们看到了一个CSS-in-JS库，这意味着我们必须在JavaScript中编写我们的CSS定义，根据我们选择的库以及如何配置它，在运行时或编译时将这些样式规则转换为纯CSS。
- en: While I personally like the CSS-in-JS approach, I eventually recognized that
    it has some significant drawbacks to consider when choosing the styling method
    for a new Next.js app.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我个人喜欢CSS-in-JS的方法，但我最终意识到，在选择新Next.js应用的样式方法时，它有一些显著的缺点需要考虑。
- en: Many CSS-in-JS libraries don't provide good IDE/code editor support, making
    things way harder for developers (no syntax highlighting, autocomplete, linting,
    and so on). Also, using CSS-in-JS forces you to adopt more and more dependencies,
    making your application bundle bigger and slower.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多CSS-in-JS库没有提供良好的IDE/代码编辑器支持，这使得开发者的工作变得更加困难（没有语法高亮、自动完成、代码检查等等）。此外，使用CSS-in-JS迫使你采用越来越多的依赖项，使得你的应用程序包更大、速度更慢。
- en: 'Talking about performance, here''s another big drawback: even if we pre-generate
    CSS rules on the server side, we would need to re-generate them after React hydration
    on the client side. That adds a high runtime cost, making the web application
    slower and slower, and it will only worsen when we add more features to our app.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到性能，这里还有一个很大的缺点：即使我们在服务器端预先生成CSS规则，我们仍然需要在客户端的React hydration之后重新生成它们。这会增加很高的运行时成本，使得网络应用程序变得越来越慢，而且当我们向我们的应用程序添加更多功能时，情况只会变得更糟。
- en: 'But here comes an excellent alternative to Styled-JSX: CSS modules. In the
    previous section, we talked about locally-scoped CSS rules and how Styled-JSX
    makes it easy to create CSS classes with the same names but different purposes
    (avoiding naming collisions). CSS modules bring the same concept to the table
    by writing plain CSS classes, then importing them to your React components without
    any runtime cost.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个出色的替代方案：CSS模块。在前一节中，我们讨论了局部作用域的CSS规则以及Styled-JSX如何使创建具有相同名称但不同目的的CSS类变得容易（避免命名冲突）。CSS模块通过编写纯CSS类并将它们导入React组件而不产生任何运行时成本，将同样的概念带到了桌面上。
- en: 'Let''s look at an elementary example: a simple landing page with a blue background
    and welcome text. Let''s start by creating a new Next.js app, then creating the
    `pages/index.js` file as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个基本的例子：一个简单的蓝色背景和欢迎文本的着陆页。让我们先创建一个新的Next.js应用，然后创建`pages/index.js`文件，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, we''re importing our CSS classes from a plain CSS file ending
    with `.module.css`. Even though `Home.module.css` is a CSS file, CSS modules transform
    its content into a JavaScript object, where every key is a class name. Let''s
    look at the `Home.module.css` file in detail:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在从以`.module.css`结尾的纯CSS文件中导入我们的CSS类。尽管`Home.module.css`是一个CSS文件，但CSS模块将其内容转换为一个JavaScript对象，其中每个键都是一个类名。让我们详细看看`Home.module.css`文件：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And after running it, here''s the result:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，这里是结果：
- en: '![Figure 6.1 – Home page styled with CSS modules'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – 使用CSS模块设计的首页'
- en: '](img/Figure_6.01_B16985.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.01_B16985.jpg)'
- en: Figure 6.1 – Home page styled with CSS modules
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 使用CSS模块设计的首页
- en: 'As mentioned before, those classes are component-scoped. If you inspect the
    generated HTML page, your landing page will contain a `div` with a class that
    looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些类是组件作用域的。如果您检查生成的HTML页面，您的着陆页将包含一个看起来像这样的`div`类：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, CSS modules generated unique class names for our rules. Even
    if we now create new classes using the same generic `title` and `homepage` names
    in other CSS files, there won't be any naming collision thanks to that strategy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，CSS模块为我们的规则生成了唯一的类名。即使我们现在在其他CSS文件中使用相同的通用`title`和`homepage`名称创建新类，由于这种策略，也不会有任何命名冲突。
- en: 'But there might be cases where we want our rules to be global. For instance,
    if we try to render the home page we just created, we will notice that the font
    family is still the default one. There''s also the default `body` margin, and
    we might want to override those default settings. We can quickly solve that problem
    by creating a new `styles/globals.css` file with the following content:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但可能存在我们希望我们的规则是全局的情况。例如，如果我们尝试渲染我们刚刚创建的首页，我们会注意到字体仍然是默认的。还有默认的`body`边距，我们可能想要覆盖这些默认设置。我们可以通过创建一个包含以下内容的新的`styles/globals.css`文件来快速解决这个问题：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can then import it into our `pages/_app.js` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其导入到我们的`pages/_app.js`文件中：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we try to render the home page now, we will see that the default `body`
    margin has disappeared, and the font now is a sans-serif one:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试渲染首页，我们会看到默认的`body`边距已经消失，现在字体是sans-serif类型的：
- en: '![Figure 6.2 – Home page styled with global CSS module styles'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – 使用全局CSS模块样式设计的首页'
- en: '](img/Figure_6.02_B16985.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.02_B16985.jpg)'
- en: Figure 6.2 – Home page styled with global CSS module styles
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 使用全局CSS模块样式设计的首页
- en: 'We can also use the `:global` keyword to create globally available CSS rules,
    for example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`:global`关键字来创建全局可用的CSS规则，例如：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There''s also another excellent CSS module feature that I''d like you to consider
    when testing out that styling method: **selector composition**.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个我想要您在测试这种样式方法时考虑的出色的CSS模块功能：**选择器组合**。
- en: 'In fact, you can create a very generic rule and then override some of its properties
    by using the `composes` property:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，您可以通过创建一个非常通用的规则，然后使用`composes`属性来覆盖其中的一些属性：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The main idea of CSS modules is to provide a straightforward way to write modular
    CSS classes with zero runtime costs in every language. Thanks to **PostCSS modules**
    ([https://github.com/madyankin/postcss-modules](https://github.com/madyankin/postcss-modules)),
    you can use CSS modules in basically every language (PHP, Ruby, Java, and so on)
    and templating engine (Pug, Mustache, EJS, and so on).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CSS模块的主要思想是提供一个简单直接的方式来编写模块化的CSS类，在每种语言中都具有零运行时成本。多亏了**PostCSS模块**([https://github.com/madyankin/postcss-modules](https://github.com/madyankin/postcss-modules))，您几乎可以在任何语言（PHP、Ruby、Java等）和模板引擎（Pug、Mustache、EJS等）中使用CSS模块。
- en: 'We''ve only scratched the surface of CSS modules and why they are an excellent
    solution for writing modular, lightweight, classes with zero runtime cost. If
    you want to learn more about CSS module specifications, you can look at the official
    repository: [https://github.com/css-modules/css-modules](https://github.com/css-modules/css-modules).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了CSS模块的表面以及为什么它们是编写模块化、轻量级、无运行时成本的类的优秀解决方案。如果你想了解更多关于CSS模块规范的信息，你可以查看官方仓库：[https://github.com/css-modules/css-modules](https://github.com/css-modules/css-modules)。
- en: Just like Styled JSX, CSS modules are available out of the box in every Next.js
    installation, so once you bootstrap your project, you can get started using them
    immediately. Still, you might need to tweak the default configuration to add,
    remove, or edit some features, and Next.js makes this step easy too.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Styled JSX一样，CSS模块在每次Next.js安装中都是现成的，所以一旦你启动了你的项目，你就可以立即开始使用它们。尽管如此，你可能需要调整默认配置来添加、删除或编辑一些功能，而Next.js也使得这一步骤变得简单。
- en: In fact, Next.js compiles CSS modules using **PostCSS**, a popular tool for
    compiling CSS at build time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Next.js使用**PostCSS**编译CSS模块，这是一个在构建时编译CSS的流行工具。
- en: 'By default, it is configured by Next.js to include the following features:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Next.js已经配置了以下功能：
- en: '*Autoprefixer*: It adds vendor prefixes to your CSS rules using values from
    `::placeholder` selector, it will compile it to make it compatible with all the
    browsers where the selector is slightly different, such as `:-ms-input-placeholder`,
    `::-moz-placeholder`, and so on. You can learn more about that feature at [https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Autoprefixer*：它使用`::placeholder`选择器的值为你添加供应商前缀到CSS规则中，它将编译它以使其与所有选择器略有不同的浏览器兼容，例如`:-ms-input-placeholder`、`::-moz-placeholder`等等。你可以了解更多关于这个功能的信息：[https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer)。'
- en: '*Cross-browser flexbox bug fixes*: PostCSS follows a community-curated list
    of flexbox issues (which can be found at [https://github.com/philipwalton/flexbugs](https://github.com/philipwalton/flexbugs))
    and adds some workarounds for making it work correctly on every browser.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跨浏览器flexbox错误修复*：PostCSS遵循社区维护的flexbox问题列表（可以在[https://github.com/philipwalton/flexbugs](https://github.com/philipwalton/flexbugs)找到），并为使其在所有浏览器上正确工作添加了一些解决方案。'
- en: '*IE11 compatibility*: PostCSS compiles new CSS features, making them available
    on older browsers such as IE11\. Still, there''s an exception: CSS variables are
    not compiled, as it is not safe to do so. If you really need to support older
    browsers and still want to use them, you can jump to the next section (*Integrating
    SASS with Next.js*) and use SASS/SCSS variables.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IE11兼容性*：PostCSS编译新的CSS功能，使其在旧浏览器（如IE11）上可用。然而，有一个例外：CSS变量不会被编译，因为这并不安全。如果你真的需要支持旧浏览器并且还想使用它们，你可以跳到下一节（*将SASS与Next.js集成*）并使用SASS/SCSS变量。'
- en: 'We can edit the PostCSS default configuration by creating a `postcss.config.json`
    file inside of our project root, then adding the default Next.js configuration:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在项目根目录中创建一个`postcss.config.json`文件来编辑PostCSS的默认配置，然后添加默认的Next.js配置：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From this point, we can edit the configuration as we prefer, adding, removing,
    or changing any property.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，我们可以根据喜好编辑配置，添加、删除或更改任何属性。
- en: 'In the next section, we will see how to integrate another popular CSS preprocessor:
    **Sass**.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何集成另一个流行的CSS预处理器：**Sass**。
- en: Integrating SASS with Next.js
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SASS与Next.js集成
- en: 'SASS is probably one of the most loved and used CSS preprocessors out there,
    and Next.js did an excellent job making it possible to integrate it with ease.
    In fact, just like CSS modules and Styled JSX, SASS is supported out of the box;
    we just need to install the `sass npm` package inside of our Next.js project,
    and we''re ready to go:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SASS可能是最受欢迎和使用的CSS预处理器之一，Next.js也做得很好，使得它能够轻松地与之集成。事实上，就像CSS模块和Styled JSX一样，SASS也是现成的；我们只需在我们的Next.js项目中安装`sass
    npm`包，就可以开始了：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this point, you can start using CSS modules with SASS and SCSS syntax, just
    like we did in the previous section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以开始使用CSS模块和SASS/SCSS语法，就像我们在上一节中做的那样。
- en: 'Let''s look at a simple example. If we open the `pages/index.js` file from
    the previous section, we can just change the CSS import to look as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子。如果我们打开上一节中的`pages/index.js`文件，我们只需将CSS导入更改如下：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we need to rename our `styles/Home.module.css` file to `styles/Home.module.scss`
    and we're ready to edit that file using the Sass (or SCSS) specific syntax.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们的`styles/Home.module.css`文件重命名为`styles/Home.module.scss`，然后我们就可以使用Sass（或SCSS）特定的语法编辑该文件了。
- en: Thanks to SASS and SCSS syntax, we can take advantage of a large set of features
    that makes our code even more modular and easy to maintain.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了SASS和SCSS语法，我们可以利用一组丰富的功能，使我们的代码更加模块化且易于维护。
- en: Pay Attention to the Names!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意名称！
- en: SASS and SCSS are two different syntaxes for the same CSS preprocessor. However,
    they both provide enhanced ways for writing CSS styles such as `for` variables,
    loops, mixins, and many other features.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SASS和SCSS是同一CSS预处理器（预处理器）的两种不同语法。然而，它们都提供了增强的CSS样式编写方式，例如`for`变量、循环、混入以及许多其他功能。
- en: While the names may look similar, and the final purpose remains the same, the
    main difference is that SCSS (Sassy CSS) extends the CSS syntax by adding those
    features available in every `.scss` file. Any standard `.css` file can be renamed
    as `.scss` without any problem, as the CSS syntax is valid in `.scss` files.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然名称可能看起来很相似，最终目的也相同，但主要区别在于SCSS（Sassy CSS）通过添加每个`.scss`文件中可用的那些功能来扩展CSS语法。任何标准的`.css`文件都可以无任何问题重命名为`.scss`，因为CSS语法在`.scss`文件中是有效的。
- en: SASS is an older syntax that is not compatible with standard CSS. It doesn't
    use curly brackets or semicolons; it just uses indentation and new lines to separate
    properties and nested selectors.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: SASS是一种较旧的语法，与标准CSS不兼容。它不使用花括号或分号；它只使用缩进和换行来分隔属性和嵌套选择器。
- en: Both of those syntaxes need to be transpiled into vanilla CSS in order to be
    used on regular web browsers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种语法都需要被转换成纯CSS，以便在常规网页浏览器中使用。
- en: 'Let''s take the CSS module `compose` property as an example. We''ve previously
    seen how to create new CSS classes extending an existing one:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以CSS模块的`compose`属性为例。我们之前已经看到如何创建新的CSS类，它扩展了现有的一个：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With SCSS, we can choose between many different approaches, such as using the
    `@extend` keyword (which works just like the `compose` keyword from CSS modules):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SCSS，我们可以选择多种不同的方法，例如使用`@extend`关键字（它的工作方式与CSS模块中的`compose`关键字类似）：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, we can change our class names a bit and take advantage of the
    **selector nesting** feature:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以稍微改变一下类名，并利用**选择器嵌套**功能：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: SCSS ships with a large set of features, such as loops, mixins, functions, and
    more, allowing any developer to write complex UIs with ease.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SCSS附带了一组丰富的功能，例如循环、混入、函数等，使得任何开发者都能轻松编写复杂的UI。
- en: Even though Next.js integrates it natively, you may still need to enable or
    disable some specific feature or edit the default SASS configuration.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Next.js原生集成了它，但你可能仍然需要启用或禁用某些特定功能或编辑默认的SASS配置。
- en: 'You can easily do that by editing the `next.config.js` configuration file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编辑`next.config.js`配置文件轻松做到这一点：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you're interested in learning more about SASS and SCSS, I'd highly recommend
    looking at the official documentation at [https://sass-lang.com](https://sass-lang.com).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于SASS和SCSS的信息，我强烈建议查看官方文档[https://sass-lang.com](https://sass-lang.com)。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The CSS ecosystem has evolved a lot in recent years, and the Next.js team keeps
    the framework up to date with the most modern, performant, and modular solutions
    for writing CSS styles.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，CSS生态系统已经发生了很大的变化，Next.js团队不断更新框架，以提供最现代、性能最佳和模块化的CSS样式编写解决方案。
- en: In this chapter, we've looked at three different built-in solutions, and of
    course, any one of them has some trade-offs compared with the others.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了三种不同的内置解决方案，当然，与其它方案相比，任何一种方案都有一些权衡。
- en: Styled JSX, for instance, is definitely one of the easiest ways of writing CSS
    rules. You can interoperate with JavaScript, dynamically change some CSS rules
    and properties depending on the user actions, and so on, but it also has some
    significant drawbacks. Like most CSS-in-JS libraries, Styled JSX first renders
    on the server side but re-renders the whole generated CSS on the client right
    after React hydration occurs. That adds some runtime cost to your application,
    making your application less performant and more challenging to scale. Also, it
    makes it impossible for the browser to cache your CSS rules, as they get regenerated
    on every request for server-side and client-side rendered pages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Styled JSX 确实是编写 CSS 规则最容易的方法之一。你可以与 JavaScript 交互，根据用户操作动态更改一些 CSS 规则和属性，等等，但它也有一些显著的缺点。像大多数
    CSS-in-JS 库一样，Styled JSX 首先在服务器端渲染，但在 React 活化后立即在客户端重新渲染整个生成的 CSS。这会给你的应用程序增加一些运行时成本，使应用程序的性能降低，并且更难以扩展。此外，它使得浏览器无法缓存你的
    CSS 规则，因为它们在服务器端和客户端渲染的每个请求中都会被重新生成。
- en: SASS and SCSS syntaxes are well integrated into Next.js, and they give you tons
    of great features for writing complex UIs with zero runtime cost. In fact, Next.js
    will compile all the `.scss` and `.sass` files to plain CSS at build time, making
    it possible for the browser to cache all your styling rules. However, we should
    consider that we can't see the production-optimized plain CSS output until the
    final build phase. Unlike CSS modules, where what we write is really close to
    what we get in the final production bundle, the vast set of features provided
    by SASS could potentially produce a huge final CSS file, and it's not always easy
    to predict the compiler output while writing deeply nested rules, loops, and so
    on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SASS 和 SCSS 语法与 Next.js 集成得很好，并且它们为你提供了大量的功能，用于以零运行时成本编写复杂的 UI。实际上，Next.js 会在构建时将所有的
    `.scss` 和 `.sass` 文件编译成纯 CSS，使得浏览器能够缓存所有的样式规则。然而，我们应该考虑的是，我们无法在最终构建阶段看到生产优化的纯
    CSS 输出。与 CSS 模块不同，我们在最终生产包中得到的确实非常接近我们编写的代码，SASS 提供的庞大功能集可能会生成一个巨大的最终 CSS 文件，并且在编写深层嵌套规则、循环等时，预测编译器的输出并不总是容易。
- en: Ultimately, CSS modules and PostCSS seems to be an excellent option for writing
    modern CSS styles. The produced output is more easily predictable, and PostCSS
    automatically polyfills modern CSS features for older browsers (down to IE11).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，CSS 模块和 PostCSS 似乎是为编写现代 CSS 样式提供了一个极好的选择。生成的输出更容易预测，并且 PostCSS 会自动为旧浏览器（甚至到
    IE11）填充现代 CSS 功能。
- en: In the next chapter, will see how to integrate external UI libraries, making
    it even easier to write style and feature-rich components and UIs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何集成外部 UI 库，这将使编写样式丰富和功能齐全的组件和 UI 更加容易。
