- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Mastering Reactive Programming in Angular
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中精通响应式编程
- en: Reactive programming helps improve your applications’ performance and allows
    Angular to make better use of the change detection mechanism, reducing the number
    of times your application needs to be re-rendered.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程有助于提高您应用程序的性能，并允许Angular更好地利用变更检测机制，减少应用程序需要重新渲染的次数。
- en: In this chapter, you’ll learn about reactive programming. You will learn what
    reactive programming is and how it can be used to improve your Angular applications.
    You will also learn about the RxJS library and how it can manage asynchronous
    data streams reactively. This chapter will teach you how to use different RxJS
    operators, create reusable RxJS operators, reuse sets of RxJS operators, and map
    other Observables into view models using RxJS.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解响应式编程。您将学习响应式编程是什么以及如何使用它来改进您的Angular应用程序。您还将了解RxJS库以及它如何反应性地管理异步数据流。本章将教会您如何使用不同的RxJS操作符，创建可重用的RxJS操作符，重用一组RxJS操作符，以及使用RxJS将其他Observables映射到视图模型中。
- en: You will also learn about Angular Signals and how Signals are used to reactively
    manage synchronous data streams. Lastly, you will learn how to combine RxJS and
    Signals, when to use RxJS, and when Signals reign supreme.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将了解Angular Signals以及如何使用Signals来反应性地管理同步数据流。最后，您将学习如何结合RxJS和Signals，何时使用RxJS，以及何时Signals占据主导地位。
- en: By the end of this chapter, you’ll be able to reactively manage data streams
    and know everything there is to know about Angular Signals.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够反应性地管理数据流，并了解有关Angular Signals的一切。
- en: 'This chapter will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is reactive programming?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是响应式编程？
- en: Reactive programming using RxJS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJS进行响应式编程
- en: Reactive programming using Angular Signals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular Signals进行响应式编程
- en: Combining Signals and RxJS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合Signals和RxJS
- en: What is reactive programming?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是响应式编程？
- en: '**Reactive programming** is a declarative programming paradigm like functional,
    modular, procedural, or **object-orientated programming** (**OOP**). A **programming
    paradigm** is a set of rules and principles specifying how you write your code.
    It is similar to architectural and design patterns, but they operate on a different
    level of abstraction.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式编程**是一种像函数式、模块化、过程式或**面向对象编程**（**OOP**）一样的声明式编程范式。**编程范式**是一组规则和原则，它指定了您编写代码的方式。它与建筑和设计模式类似，但它们在抽象的不同层面上运作。'
- en: Programming paradigms are high-level concepts that dictate the overall style,
    structure, and approach to writing code, whereas architectural and design patterns
    provide reusable templates or blueprints for structuring code, handling communication
    between components, managing relationships, and solving other common design challenges
    within your code base.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编程范式是指导编写代码的整体风格、结构和方法的宏观概念，而架构和设计模式则提供了可重用的模板或蓝图，用于结构化代码、处理组件之间的通信、管理关系以及解决代码库中其他常见的设计挑战。
- en: Reactive programming deals with data streams and the propagation of changes.
    In simple terms, reactive programming dictates how you handle events and data
    changes that can happen at any given time, also known as **asynchronous changes**.
    As the name already implies, you are reacting to changes with reactive programming.
    With reactive programming, the dependent parts of your code will automatically
    be notified of events and data changes so that these parts can react to changes
    automatically. You can think of reactive programming as a system where changes
    are pushed to the parts of your code that need to react upon the changes instead
    of you pulling the current state, checking if it changed, and then updating the
    dependent code accordingly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程处理数据流和变化的传播。简单来说，响应式编程决定了您如何处理可能在任何给定时间发生的事件和数据变化，也称为**异步变化**。正如其名称所暗示的，您使用响应式编程来对变化做出反应。使用响应式编程，代码的依赖部分将自动通知事件和数据变化，以便这些部分可以自动对变化做出反应。您可以将响应式编程视为一个系统，其中变化被推送到需要根据变化做出反应的代码部分，而不是您拉取当前状态，检查是否已更改，然后相应地更新依赖代码。
- en: Highlights of reactive programming
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式编程的亮点
- en: Reactive systems optimize resource allocation by subscribing to and processing
    data only when it changes, reducing unnecessary processing and improving overall
    system performance. This approach allows for a more responsive and scalable system
    while conserving computational resources, making it particularly advantageous
    for handling asynchronous data streams efficiently. Some common examples where
    you can use reactive programming to handle data streams and events are HTTP requests,
    form changes, and browser events such as clicks, mouse movements, and keyboard
    events.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式系统通过仅在数据发生变化时订阅和处理数据来优化资源分配，减少了不必要的处理，提高了整体系统性能。这种方法允许系统更加响应和可扩展，同时节省计算资源，使其在高效处理异步数据流方面特别有利。你可以使用反应式编程来处理数据流和事件的常见示例包括HTTP请求、表单更改以及浏览器事件，如点击、鼠标移动和键盘事件。
- en: Reactive programming also promotes composability by enabling developers to easily
    compose complex behaviors from simpler ones. Through operators such as `map`,
    `filter`, `merge`, and more, reactive systems allow you to transform, combine,
    and manipulate data streams.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程通过允许开发者轻松地将更简单的行为组合成更复杂的组合，从而促进了可组合性。通过`map`、`filter`、`merge`等运算符，反应式系统允许你转换、组合和操作数据流。
- en: This inherent modularity empowers developers to build more modular and flexible
    applications where different data streams can be seamlessly integrated, transformed,
    and adapted to create sophisticated and easily maintainable systems. This emphasis
    on composability fosters code reusability and promotes the creation of highly
    scalable and adaptable applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种固有的模块化使开发者能够构建更模块化和灵活的应用程序，其中不同的数据流可以无缝集成、转换和适应，以创建复杂且易于维护的系统。这种对可组合性的强调促进了代码的可重用性，并促进了高度可扩展和适应性强应用的创建。
- en: Another important part of reactive programming is handling events and data changes
    that are non-blocking; this is mainly where the performance boost comes from when
    you start programming reactively. **Non-blocking code** ensures multiple tasks,
    events, and data changes can be executed in parallel. In other words, non-blocking
    code runs the code without waiting for the task to finish, so your code continues
    to the next lines of code directly after the task has started. In contrast, **blocking
    code** will wait until the code has finished before moving to the next line of
    code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个反应式编程的重要部分是处理非阻塞的事件和数据变化；这主要是在你开始进行反应式编程时性能提升的地方。**非阻塞代码**确保多个任务、事件和数据变化可以并行执行。换句话说，非阻塞代码在任务开始后直接运行代码，而不需要等待任务完成，因此你的代码在任务开始后直接继续到下一行代码。相比之下，**阻塞代码**会在代码完成之前等待，然后才移动到下一行代码。
- en: Drawbacks of reactive programming
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反应式编程的缺点
- en: Reactive programming is great, but it is not only sunshine and roses; there
    are also some drawbacks to reactive programming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程很棒，但它不仅仅是阳光和玫瑰；反应式编程也有一些缺点。
- en: Reactive systems can become complex, and the learning curve, especially for
    junior developers, can be steep. Besides some difficult concepts, reactive programming
    can be complicated to debug and harder to test with automated tests. Especially
    when you’re writing unit testing for your applications, a highly reactive system
    can give you some headaches.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式系统可能会变得复杂，学习曲线，尤其是对于初级开发者来说，可能会很陡峭。除了一些难以理解的概念外，反应式编程可能难以调试，并且使用自动化测试进行测试也更困难。特别是当你为你的应用程序编写单元测试时，高度反应式系统可能会给你带来一些头疼。
- en: You now know what reactive programming is and how it can improve your application’s
    performance and allow you to handle events and data streams effectively. Reactive
    programming provides easy composability of data streams and events and runs your
    code in a non-blocking approach. You also know what challenges reactive programming
    can bring to your code base and that it can be challenging for junior developers
    to understand some reactive patterns. Now, let’s learn more about how reactive
    programming is used within Angular applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经了解了什么是反应式编程以及它如何提高你的应用程序性能并有效地处理事件和数据流。反应式编程提供了数据流和事件的简单可组合性，并以非阻塞的方式运行你的代码。你还知道反应式编程可能给你的代码库带来哪些挑战，以及对于初级开发者来说，理解一些反应式模式可能具有挑战性。现在，让我们更多地了解反应式编程在Angular应用程序中的应用。
- en: Reactive programming in Angular
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式编程在Angular中的应用
- en: Reactive programming is integral to the Angular framework. Angular heavily relies
    on *Observables* (we will explain Observables in detail in the next section) and
    has the **RxJS** library built into it to manage Observable data streams in a
    robust and composable manner. **Observables** are a reactive design pattern because
    you have the Observable, or publisher of data, and the subscribers or receivers
    of the data stream. Subscribers are automatically notified when the Observable
    emits a new value and can act upon it accordingly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是 Angular 框架的核心。Angular 强烈依赖于 *观察者*（我们将在下一节中详细解释观察者）并且内置了 **RxJS** 库，以强大和可组合的方式管理观察者数据流。**观察者**是一种响应式设计模式，因为它包含了观察者，即数据发布者，以及订阅者或数据流的接收者。当观察者发出新的值时，订阅者会自动收到通知并相应地采取行动。
- en: 'Observables are utilized in many different aspects within the Angular framework.
    Here are some examples where you can find Observables within the Angular framework:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者（Observables）在 Angular 框架中被广泛应用于多个方面。以下是一些例子，展示了在 Angular 框架中你可以找到观察者的地方：
- en: '**HTTP requests**: Within the Angular framework, HTTP requests return Observables
    by default. HTTP requests in vanilla JavaScript are handled with Promises.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP 请求**：在 Angular 框架中，HTTP 请求默认返回观察者。在纯 JavaScript 中，HTTP 请求是通过 Promise
    处理的。'
- en: '`events` Observable. With the router `events` Observable, you can listen for
    events such as `NavigationStart`, `NavigationEnd`, `GuardCheckStart`, and `GuardCheckEnd`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`events` 观察者。使用路由 `events` 观察者，你可以监听诸如 `NavigationStart`、`NavigationEnd`、`GuardCheckStart`
    和 `GuardCheckEnd` 等事件。'
- en: '`valueChanges` Observable is exposed by the Angular framework. With this Observable,
    you can react to changes within the form or form fields.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 框架暴露了 `valueChanges` 观察者。使用这个观察者，你可以对表单或表单字段中的变化做出响应。
- en: '`ViewChildren` decorator, the `QueryList` object it returns has a `changes`
    event. This `changes` event is an Observable that notifies you when the selection
    that’s made by `ViewChildren` has changed.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewChildren` 装饰器，它返回的 `QueryList` 对象有一个 `changes` 事件。这个 `changes` 事件是一个观察者，当
    `ViewChildren` 选择的项发生变化时，它会通知你。'
- en: These examples are just some instances where the Angular framework relies on
    Observables. In the code of applications made with Angular and within libraries
    that are commonly used in combination with Angular, you’ll come across Observables
    in many instances.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子只是 Angular 框架依赖观察者的几个实例。在用 Angular 制作的应用程序代码中，以及与 Angular 常常一起使用的库中，你会在许多地方遇到观察者。
- en: 'Besides Observables, Angular also uses reactive programming in other ways,
    such as when handling browser events with the `@``Hostlistener()` decorator:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了观察者之外，Angular 还以其他方式使用响应式编程，例如在处理浏览器事件时使用 `@Hostlistener()` 装饰器：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, we used the `@Hostlistener()` decorator to listen
    for `keydown` events and handle them reactively. Another place where Angular uses
    the reactive programming paradigm is with **Angular Signals**, which was introduced
    in Angular 16\. Angular Signals is a system that tracks value changes and notifies
    interested consumers accordingly. The Signals API comes with computed properties
    and effects that are automatically updated or run when a Signal value changes.
    Signals are excellent for handling synchronous values reactively, whereas RxJS
    shines in handling asynchronous data streams. We will dive deeper into the topic
    of Signals in the *Reactive programming with Angular Signals* section of this
    chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码片段中，我们使用了 `@Hostlistener()` 装饰器来监听 `keydown` 事件并对其进行响应式处理。Angular 使用响应式编程范式的另一个地方是
    **Angular Signals**，这是在 Angular 16 中引入的。Angular Signals 是一个跟踪值变化并相应地通知感兴趣消费者的系统。Signals
    API 包含了计算属性和效果，这些属性和效果会在 Signal 值变化时自动更新或运行。Signals 适用于处理同步值的响应式，而 RxJS 在处理异步数据流方面表现出色。我们将在本章的
    *使用 Angular Signals 进行响应式编程* 部分更深入地探讨 Signals。 '
- en: Now that you know that Angular has reactive programming embedded within the
    framework, from Observables and RxJS to event handling and the new Angular Signals,
    let’s move on to the next section and learn how to use RxJS to its fullest within
    Angular applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解到 Angular 框架内置了响应式编程，从观察者和 RxJS 到事件处理和新的 Angular Signals，让我们继续下一节，学习如何在
    Angular 应用程序中充分利用 RxJS。
- en: Reactive programming using RxJS
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxJS 进行响应式编程
- en: Regarding reactive programming in the context of Angular applications, RxJS
    stands at its core. **RxJS** is short for **Reactive Extensions Library for JavaScript**.
    As the name reveals, it’s a library for handling reactivity within JavaScript,
    and it is built-in and used by default within the Angular framework.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用程序的上下文中，关于响应式编程，RxJS 处于核心地位。**RxJS** 代表 **Reactive Extensions Library
    for JavaScript**。正如其名所示，它是一个用于处理 JavaScript 中响应性的库，并且它是内置的，默认情况下在 Angular 框架中使用。
- en: 'RxJS is used to create, consume, modify, and compose asynchronous and event-based
    data streams. At its core, RxJS revolves around four major concepts: Observables,
    Observers, Subjects, and operators. Let’s dive deep into these concepts individually,
    starting with Observables.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 用于创建、消费、修改和组合异步和基于事件的流数据。在其核心，RxJS 围绕四个主要概念：可观测量、观察者、主题和操作符。让我们逐一深入探讨这些概念，从可观测量开始。
- en: What are Observables?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是可观测量？
- en: '**Observables** are the cornerstone of RxJS. You can see Observables as a stream
    or a pipeline that emits different values over time in an asynchronous manner.
    To receive the values emitted by the Observable data stream, you subscribe to
    the Observable.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**可观测量**是 RxJS 的基石。你可以将可观测量视为一个流或管道，它以异步方式在一段时间内发出不同的值。要接收可观测量数据流发出的值，你需要订阅可观测量。'
- en: Now, imagine an Observable data stream as a water pipe. When you turn on the
    tap (subscribe), water (data) flows through the pipe (Observable), and you receive
    drops of water (values) at your end. The water (data) might already be flowing
    before you turn on the tab (subscribe) unless you installed a special system;
    you will only receive water (data) from the moment you have your tab running (subscribe)
    up to the moment you close the tab (unsubscribe). The water (data) might keep
    running to other tabs (subscribers) if they are open. So, in short, to receive
    values from the data flow, you need to subscribe, and all values emitted before
    you subscribe are lost unless you have special logic in place to store these values.
    To stop receiving values, you need to unsubscribe and the data emitting the values
    flows like a stream.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一个可观测量数据流就像一个水管。当你打开水龙头（订阅）时，水（数据）会通过水管（可观测量）流动，你在你的末端接收水滴（值）。水（数据）可能在你打开水龙头（订阅）之前就已经流动了，除非你安装了特殊的系统；你将只从你打开水龙头（订阅）的那一刻起接收水（数据），直到你关闭水龙头（取消订阅）。如果其他水龙头（订阅者）是打开的，水（数据）可能还会流向其他水龙头。简而言之，要接收数据流中的值，你需要订阅，而你之前订阅之前发出的所有值都将丢失，除非你有特殊的逻辑来存储这些值。要停止接收值，你需要取消订阅，并且发出值的流就像一条河流一样。
- en: 'Observables come in two types: *hot and cold Observables*. **Cold Observables**
    are unicast, meaning they start fresh for each subscriber. It’s like a movie on
    Netflix; when someone starts the movie, the movie will start from the beginning.
    If someone else starts the same movie on another account or TV, the movie will
    also start from the beginning. Everyone watching gets their own unique viewing
    experience from the moment they start watching.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测量有两种类型：*热可观测量和冷可观测量*。**冷可观测量**是单播的，意味着每个订阅者都会从头开始。就像 Netflix 上的电影一样；当有人开始播放电影时，电影将从开头开始。如果有人在另一个账户或电视上开始播放同一部电影，电影也将从开头开始。每个人从开始观看的那一刻起都会获得独特的观看体验。
- en: On the other hand, **hot Observables** are multicast, meaning there is one stream
    of data broadcasted to every subscriber. Hot Observables can be compared to live
    television. Different people can tune in to the live show (the data stream), but
    everything you already missed is gone and will not be replayed for you. Everyone
    watching experiences the same content simultaneously, even if they didn’t start
    watching from the beginning.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，**热可观测量**是多播的，意味着有一个数据流被广播给每个订阅者。热可观测量可以与现场电视相比较。不同的人可以收听现场节目（数据流），但你已经错过的内容将不会为你重播。即使他们没有从开始观看，观看的人也会同时体验到相同的内容。
- en: Now that you clearly understand Observables and know the difference between
    hot and cold Observables, let’s learn about Observers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经清楚地理解了可观测量，并且知道了热可观测量和冷可观测量之间的区别，让我们来学习观察者。
- en: Subscribing to Observables with Observers
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用观察者订阅可观测量
- en: '**Observers** are the entities that subscribe to an Observable and receive
    the Observable values in the data stream. You can think of the Observer as the
    person (or subscriber) watching a live show or putting on a Netflix movie. Subscribers
    have two tasks: subscribing to the streams they want to receive and unsubscribing
    from streams they do not want or need to receive anymore.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察者**是订阅可观察对象并接收数据流中可观察对象值的实体。你可以将观察者视为观看现场表演或播放Netflix电影的人（或订阅者）。订阅者有两个任务：订阅他们想要接收的流，并取消订阅他们不再想要或需要的流。'
- en: One of the most crucial parts is successfully unsubscribing from subscriptions
    the Observer doesn’t need anymore. Not unsubscribing Observables is probably the
    most considerable risk when using Observables in your code and is the most common
    source of problems. You will run into memory leaks if you don’t clean up your
    subscription correctly. Memory leaks will result in strange behavior and a slower
    application and can eventually crash your application if it runs out of memory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最关键的部分是成功取消不再需要的订阅。不取消可观察对象可能是使用代码中的可观察对象时最大的风险，也是最常见的错误来源。如果你没有正确清理你的订阅，你会遇到内存泄漏。内存泄漏会导致应用程序出现奇怪的行为，运行速度变慢，并最终在内存耗尽时崩溃你的应用程序。
- en: Let’s imagine that you have a subscription to a magazine that is delivered to
    your house every week. If you move to a new address, you need to *unsubscribe*
    from the subscription and create a *new subscription* on the new address. If you
    don’t unsubscribe from the old address and only begin a new subscription for the
    new address, you will start to pay double, and the magazine will be delivered
    to both addresses. If you keep repeating this process, you will eventually run
    out of money, and your life will crash. Within your applications, it’s the same,
    only you don’t pay with money but with memory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你有一个订阅的杂志，每周都会送到你家。如果你搬到了一个新的地址，你需要从订阅中*取消订阅*，并在新的地址上创建一个新的*订阅*。如果你不取消旧地址的订阅，而只是为新地址开始一个新的订阅，你将开始支付双倍费用，杂志将同时送到两个地址。如果你继续重复这个过程，你最终会耗尽资金，你的生活将崩溃。在你的应用程序中，情况相同，只是你不用金钱支付，而是用内存。
- en: When you create a subscription inside a component, you must unsubscribe when
    the component is destroyed. Otherwise, the subscription will keep running. The
    next time you open the same component, a second subscription starts because the
    old one is still running. As a result, all values will be received by two Observers.
    If you keep repeating this process, you’ll end up with many Observers receiving
    the same value while you only need a single Observer to receive the values. When
    there are too many Observers, the application will run out of memory to process
    all the values, and the app will crash.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在组件内部创建一个订阅时，必须在组件销毁时取消订阅。否则，订阅将继续运行。下次你打开相同的组件时，将启动第二个订阅，因为旧的订阅仍在运行。结果，所有值都将被两个观察者接收。如果你继续重复这个过程，最终会有许多观察者接收相同的值，而你只需要一个观察者来接收这些值。当观察者太多时，应用程序将耗尽处理所有值的内存，应用程序将崩溃。
- en: Unsubscribing from Observables
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消可观察对象的订阅
- en: 'Unsubscribing from Observables can be done in many different ways. Most commonly,
    in an Angular application, you can unsubscribe inside the `ngOnDestroy` life cycle
    hook. You can unsubscribe manually like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 取消可观察对象的订阅可以以许多不同的方式完成。在Angular应用程序中，你通常可以在`ngOnDestroy`生命周期钩子内部取消订阅。你可以手动取消订阅，如下所示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we subscribed to an Observable inside the `ngOnInit`
    life cycle hook and manually unsubscribed in the `ngOnDestroy` life cycle hook
    by calling the `unsubscribe()` and `complete()` methods on the Observable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在`ngOnInit`生命周期钩子内部订阅了一个可观察对象，并在`ngOnDestroy`生命周期钩子中通过在可观察对象上调用`unsubscribe()`和`complete()`方法手动取消订阅。
- en: This approach may not be the best option when multiple Observables are inside
    your component. If you have five Observables, you must unsubscribe and complete
    all five Observables manually. Doing all subscriptions manually increases the
    risk of missing an Observable, and it will result in a large `ngOnDestroy` method
    with a lot of repetitive code inside.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的组件内部有多个可观察对象时，这种方法可能不是最佳选择。如果你有五个可观察对象，你必须手动取消和完成所有五个可观察对象的订阅。手动完成所有订阅会增加遗漏一个可观察对象的风险，并导致`ngOnDestroy`方法中包含大量重复代码的大方法。
- en: You also need a local property for all Observables, further polluting your file
    with boilerplate code. In that case, you would need to save the Observable subscription
    in a property so that you can unsubscribe from the subscription in the `ngOnDestroy`
    method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要为所有Observables创建一个本地属性，这会进一步污染你的文件，增加样板代码。在这种情况下，你需要将Observable订阅保存在一个属性中，以便你可以在`ngOnDestroy`方法中取消订阅。
- en: Another better option is to create a `Subscription` object and add all your
    subscriptions to this object by using the `add()` method on the `Subscription`
    object. In this case, you only have to unsubscribe from the `Subscription` object,
    and it will unsubscribe and complete all subscriptions that have been added to
    the `Subscription` object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更好的选择是创建一个`Subscription`对象，并通过在`Subscription`对象上使用`add()`方法将所有订阅添加到这个对象中。在这种情况下，你只需要从`Subscription`对象中取消订阅，它将自动取消订阅并完成添加到`Subscription`对象中的所有订阅。
- en: 'Here’s an example of how you can use the `Subscription` object approach:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个如何使用`Subscription`对象方法的示例：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code snippet, we created a `subscriptions` property and assigned
    it to the `Subscription` object. Next, we used the `subscriptions` property and
    added all the subscriptions to the `subscriptions` property using the `add` method
    of the `Subscription` class. Lastly, inside `ngOnDestroy`, we called the `unsubscribe()`
    method on the `subscriptions` object, which will unsubscribe and complete all
    the inner subscriptions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个`subscriptions`属性并将其分配给`Subscription`对象。接下来，我们使用`subscriptions`属性，并通过`Subscription`类的`add`方法将所有订阅添加到`subscriptions`属性中。最后，在`ngOnDestroy`方法内部，我们调用`subscriptions`对象的`unsubscribe()`方法，这将取消订阅并完成所有内部订阅。
- en: Using the `Subscription` class is a good approach, but the syntax of adding
    the active subscriptions to the `Subscription` class looks messy. When you start
    to use RxJS pipeable operators, there is an approach that is more in line with
    the rest of your code. We will discuss pipeable operators in more detail later
    in this section, but for now, I want to show you how you can use them to unsubscribe
    automatically from your subscriptions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Subscription`类是一个不错的选择，但将活动订阅添加到`Subscription`类的语法看起来很杂乱。当你开始使用RxJS可连接操作符时，有一种方法更符合你代码的其他部分。我们将在本节稍后更详细地讨论可连接操作符，但现在，我想向你展示如何使用它们来自动取消订阅。
- en: Unsubscribing with the takeUntil() operator
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`takeUntil()`操作符取消订阅
- en: 'First, we will take a look at the `takeUntil()` operator. You can add the `takeUntil()`
    operator inside the RxJS pipe method, which is changed on your Observables. The
    `takeUntil()` operator unsubscribes your subscriptions automatically upon a trigger.
    This trigger is commonly an RxJS `Subject` (we will discuss `Subject` in more
    detail later in this section). When we call the next method on this `Subject`,
    the `takeUntil()` operator will be triggered and unsubscribe from the subscription:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看`takeUntil()`操作符。你可以在RxJS管道方法内部添加`takeUntil()`操作符，该操作符用于你的Observables。`takeUntil()`操作符会在触发器触发时自动取消你的订阅。这个触发器通常是RxJS的`Subject`（我们将在本节稍后更详细地讨论`Subject`）。当我们调用这个`Subject`的下一个方法时，`takeUntil()`操作符将被触发并取消订阅：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we created a `Subject` Observable and named it `destroy$`.
    Next, we used the `pipe()` function on our Observable, and inside the `pipe()`
    function, we added the `takeUntil()` operator. The `takeUntil()` operator received
    the `destroy$` property as a parameter and will be triggered once we call the
    `next()` method on the `destroy$` property. Lastly, inside the `ngOnDestroy` life
    cycle method, we called the `next()` method on the `destroy$` property and finished
    by calling the `complete()` method to complete the `destroy$` Observable itself.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个名为`destroy$`的`Subject` Observable。然后，我们在我们的Observable上使用`pipe()`函数，并在`pipe()`函数内部添加了`takeUntil()`操作符。`takeUntil()`操作符接收`destroy$`属性作为参数，一旦我们调用`destroy$`属性的`next()`方法，它就会被触发。最后，在`ngOnDestroy`生命周期方法内部，我们调用`destroy$`属性的`next()`方法，并通过调用`complete()`方法完成对`destroy$`
    Observable本身的完成。
- en: 'Using the `takeUntil()` operator is the preferred solution for many Angular
    developers to unsubscribe. This is because it works perfectly well in combination
    with the RxJS `pipe` function and other pipeable operators. There is one last
    option to unsubscribe that I want to show: the `takeUntilDestroyed()` operator.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`takeUntil()`操作符是许多Angular开发者取消订阅的首选解决方案。这是因为它与RxJS的`pipe`函数和其他可连接操作符配合得非常好。我想展示的最后一种取消订阅的选项是`takeUntilDestroyed()`操作符。
- en: Unsubscribing with the takeUntilDestroyed() operator
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `takeUntilDestroyed()` operator was added by Angular in version 16\. It
    can be used to automatically unsubscribe when the component is destroyed. When
    you declare your subscription inside the injection context (inside the constructor
    or where you declare your properties), you only have to add the `takeUntilDestroyed()`
    operator, and it will manage everything for you:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: protected readonly destroy = inject(DestroyRef);
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: ngOnInit() {
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: this.observable$.pipe(takeUntilDestroyed(this.destroy)).subscribe(…);
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: const subject = new Subject<number>();
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'subject.subscribe({next: (v) => console.log(`A: ${v}`)});'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(1);
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'subject.subscribe({next: (v) => console.log(`B: ${v}`)});'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(2);
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '// Logs:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: // A:1, A:2, B:2
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: const subject = new BehaviorSubject(0); //initial value 0
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'subject.subscribe({next: (v) => console.log(`A: ${v}`)});'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(1);
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'subject.subscribe({next: (v) => console.log(`B: ${v}`)});'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(2);
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '// Logs:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: // A:0, A:1, B:1, A:2, B:2
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: const subject = new ReplaySubject(100, 500);
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: subject.subscribe({
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'next: (v) => console.log(`A: ${v}`),'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: let i = 1;
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: setInterval(() => subject.next(i++), 200);
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: setTimeout(() => {
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: subject.subscribe({
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'next: (v) => console.log(`B: ${v}`),'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '}, 1000);'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: // Logs
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: // A:1, A:2, A:3, A:4, A:5, B:3, B:4, B:5, A:6, B:6
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: const subject = new AsyncSubject();
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: subject.subscribe({
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'next: (v) => console.log(`A: ${v}`),'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(1);
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(2);
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: subject.subscribe({
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'next: (v) => console.log(`B: ${v}`),'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(3);
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: subject.complete();
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '// Logs:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: // A:3, B3
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'of() operator with three values: 1, 2, and 3. We subscribed to the Observable
    stream that was created with the of() operator and logged the values. This subscription
    will result in three separate logs: value: 1, value: 2, and value: 3. As you can
    see, the of() operator is a pretty simple and straightforward way to create an
    Observable stream.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Another commonly used creational operator is the `from()` operator. The `from()`
    operator creates an Observable stream of an array, iterable, Promise, or strings.
    If you transform a string into an Observable stream using the `from()` operator,
    the string will be emitted character by character. Here’s an example of using
    the `from()` operator:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we used the `from()` operator to create an Observable
    stream from an array and a Promise.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful creational operator is the `fromEvent()` operator. The `fromEvent()`
    operator creates an Observable from an event target such as *click* or *hover*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: const amountExclVat = of(100);
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: const vatPercentage = of(20);
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: combineLatest([amountExclVat, vatPercentage]).subscribe({
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'next: ([amount, percentage]) => {'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: console.log(‹Total:', amount * (percentage / 100 + 1));
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'combineLatest({ amount: amountExclVat, percentage: vatPercentage }).subscribe({'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'next: (data) => { console.log(''Total:'', data.amount * (data.percentage /
    100 + 1)) }'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: const a = new Subject();
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: const b = new Subject();
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: combineLatest([a, b]).subscribe({
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'next: ([a, b]) => { console.log(‹data›, a, b) }'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: a.next(1);
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: setTimeout(() => { b.next(2) }, 5000);
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: setTimeout(() => { a.next(10) }, 10000);
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'forkJoin({ posts: this.http.get(''…''), post2: this.http.get(''…)}).subscribe(console.log);'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'concat() operator is used when you have multiple inner Observables, and the
    order of the emission and completion of these inner Observables is essential.
    So, if you have two inner Observables, concat() will emit all the values of the
    first inner Observable until that Observable is completed. All the values that
    have been emitted by the second Observable before the first Observable has been
    completed will not be emitted by concat().When the first Observable has been completed,
    the `concat()` operator subscribes to the second Observable and starts to emit
    the values emitted by the second Observable. If you have even more inner Observables,
    this process will be repeated, and `concat()` will subscribe to the next Observable
    when the previous Observable is completed:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: const a = new Subject();
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const b = new Subject();
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: merge(a, b).subscribe(console.log);
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b.next('B:1');
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a.next('A:1');
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a.next('A:2');
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b.next('B:2');
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// Logs: B:1, A:1, A:2, B:2'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: const observable = of(1, 1, 2, 3, 4, 4, 5);
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: observable.pipe(
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: distinctUntilChanged(),
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: filter(value => value < 5),
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: map(value => value as number * 10)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe(results => {console.log('results:', results)});
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '// Logs: 10, 20, 30, 40'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ngOnInit() {
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: this.urlObservable.pipe(
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: map((url) => this.http.get(url)),
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: concatAll()
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe((data) => { console.log('data ==>', data) })
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: this.urlObservable.pipe(
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: concatMap((url) => this.http.get(url)),
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe(……)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: const clicks = fromEvent(document, 'click');
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: clicks.pipe(
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: concatMap(() => interval(1000).pipe(take(4))),
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe(number => console.log(number));
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: const clicks = fromEvent(document, 'click');
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: clicks.pipe(
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: mergeMap(() => interval(1000).pipe(take(4))),
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe(x => console.log(x));
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: const clicks = fromEvent(document, 'click');
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: clicks.pipe(
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: switchMap(() => interval(1000).pipe(take(4))),
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe(x => console.log(x));
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: const clicks = fromEvent(document, 'click');
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: clicks.pipe(
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: exhaustMap(() => interval(1000).pipe(take(4))),
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe(x => console.log(x));
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: export const discardOdd = () => pipe(
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'filter((v: number) => !(v % 2)),'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: of(1, 2, 4, 5, 6, 7).pipe(discardOddDoubleEven()).subscribe(console.log);
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: const discardOddDoubleEven = () => pipe(
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'filter((v: number) => !(v % 2)),'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'map((v: number) => v * 2)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: expenses = signal<ExpenseModel[]>([ …… ]);
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <div class="container">
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: <h1>Expenses Overview</h1>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: <table>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: <tr>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: <th>Description</th>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: ……
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: </tr>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '@for (expense of expenses(); track expense.id){'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: <tr>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: <td>{{ expense.description }}</td>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: ……
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: </tr>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: </table>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'date: new FormControl<string | null>(null, [Validators.required]),'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'tags: new FormArray<FormControl<string | null>>(['
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: new FormControl(''),
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '])'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: showAddExpenseModal = signal(false);
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <bt-libs-modal [shown]=" showAddExpenseModal()" (shownChange)=" showAddExpenseModal.set(false)"
    [title]="'Add expenses'">
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '<bt-libs-ui-add-expense-form #form (addExpense)="onAddExpense($event)" />'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: </bt-libs-modal>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'onAddExpense(expenseToAdd: ExpenseModel) {'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: this.expenses.update(expenses => [...expenses, expenseToAdd]);
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: this. showAddExpenseModal.set(false);
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <button (click)="showAddExpenseModal.set(true)">Add expense</button>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'const count: WritableSignal<number> = signal(0);'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'const double: Signal<number> = count Signal and a computed Signal named double.
    The computed Signal uses the computed function, and the count Signal is used inside
    the callback of the computed function. When the value of the count Signal changes
    to 1, the value of the computed Signal is automatically updated to 2.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to know that the computed Signal will only update when the Signal
    it depends on has a new stable value. Notice how I say *stable value*; this is
    because Signals provide their updates asynchronously and work a bit like the RxJS
    `switchMap` operator, which cancels the previous data stream if a new stream comes
    in before the old stream is finished. So, if you update the Signal multiple times
    in a row without pause in between, the Signal will not stabilize its value, and
    as a result, the computed Signal will only run on the last value change of the
    Signal.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Computed signals are very powerful and also very efficient. The computed Signal
    will not compute a value until the computed value is read for the first time.
    Next, the computed Signal will cache its value, and when you read the computed
    Signal again, it will simply return the cached value without running any computations.
    If the Signal value that the computed signal uses to derive its value from changes,
    the computed Signal will run a new computation and update its value.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Because computed Signals cache their results, you can safely use computationally
    expensive operations such as filtering and mapping arrays inside the callback
    function of your computed Signals. Just like regular Signals, computational Signals
    notify all consumers when their values change. As a result, all consumers of computed
    Signals will show the latest computed value.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add a computed Signal to `ExpensesOverviewComponent` for the total
    amount, including VAT:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, we used the `computed` function, and inside the callback of
    the `computed` function, we used the `expenses` Signal to retrieve the current
    list of expenses. We can use the `Array.reduce` function on the `expenses` array
    to retrieve the total costs, including VAT. You can access the computed signal
    the same as you would a regular signal:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s create a new table row in the HTML template to display the total value.
    You can add the table row below the `for` loop in the HTML template:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Suppose you add a new expense using the add expense form. In that case, you’ll
    notice that the total amount is automatically updated because the computed Signal
    uses the `expenses` Signal to evaluate the total amount. When the `expenses` Signal
    changes, the computed Signal will also be updated based on the `expenses` Signal.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing that is good to know about computed Signals is that only Signals
    that are used during the computation are tracked. For example, let’s say you add
    a Signal to control if you show or hide the table row summary and another for
    the corresponding button text:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can now use the following `showSummary` Signal inside the computed Signal
    like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this scenario, the computed Signal will only track the `expenses` Signal
    if the `showSummary` Signal is set to `true`. If the `showSummary` Signal is set
    to `false`, the `expenses` Signal is never reached within the `computed` function,
    and because of that, it will not be tracked for changes. So, if you update the
    `expenses` Signal while the `showSummary` Signal is set to `false`, the computed
    Signal will not calculate a new value.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what computed Signals are, how to use them within your code,
    and how computed Signals update their values, let’s explore Signal effects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Signal effects
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '**Signal effects** are side effects that run each time a Signal changes. You
    can perform any logic you want inside a Signal effect. Some use cases for a Signal
    effect would be logging, updating local storage, showing notifications, or performing
    DOM manipulations that can’t be handled from within the HTML template.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a Signal effect by using the `effect` function and providing
    the `effect` function with a callback:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: effect(() => {
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: if (this.showSummary()) {
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: console.log(‹Updated expenses:›, this.expenses());
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: effect = effect(() => {
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: console.log(Summary:', this. showSummary ());
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: console.log('Expenses:', untracked(this.expenses()));
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: injector = inject(Injector);
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: effect(() => {
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: console.log(‹Updated expenses:›, this.expenses());
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '}, { injector: this.injector });'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: expenseEffect = effect(() => {
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: console.log(‹Updated expenses:›, this.expenses());
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '}, { manualCleanup to true, you have to call the destroy() function on the
    effect:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can also hook into the cleanup of a Signal effect by using a callback function.
    This can be useful when you want to perform some logic when the Signal effect
    is cleaned up. Here’s an example of the `onCleanup` callback:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Besides `manualCleanup` and the `onCleanup` callback, there is one last configuration
    option for the Signal effects. By default, you are not allowed to update Signals
    inside a Signal effect; this is because this can easily result in infinite executions
    of the Signal effect. However, you can circumvent this by setting the `allowSignalWrites`
    property on the Signal effect:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now that you know all about Signal effects, how to use them, and how you can
    trigger or configure them, let’s learn about Signal component inputs.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Signal component inputs
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Since Angular 17.1, you can also use Signals as component input instead of using
    the `@Input()` decorator. Using the `ngOnChanges` life cycle hook.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of a Signal input and compare it to the `@Input()` decorator
    (you don’t have to add the example in the monorepo, it’s just for explanatory
    purposes):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, the Signal input has a much more straightforward approach to
    declaring input properties. You declare a property and assign it with an `input()`
    function; optionally, you can add the arrow syntax to add a type to the Signal
    input. If you want to provide an initial value to your Signal input, you can provide
    it as a function parameter, like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Just as with the input decorator, you can also make the input required, use
    an input alias, or create a transform function on the input:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, you can make the input required and provide the Signal input
    with a configuration object to give it an alias and transform function. The Signal
    input uses a simpler syntax, helps improve the change detection mechanism, and
    allows you to remove the `ngOnChanges` life cycle hook.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: When you combine the Signal input with computed Signals, you can remove the
    `ngOnChanges` life cycle hook because all properties that need to be updated upon
    the input of a specific property can now automatically be updated by using a computed
    Signal based on the input Signal. Any additional logic you want to run can be
    declared inside a Signal effect that reacts to the Signal input.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know more about Signal inputs, let’s learn about Signal queries,
    which are used to interact with HTML elements reactively.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Signal queries
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you need to select HTML elements from your template and interact with
    them inside your component class. In Angular, this is commonly achieved by using
    the `@ContentChild`, `@ContentChildren`, `@ViewChild`, or `@ViewChildren` decorator.
    In Angular 17.2, a new Signal-based approach was introduced that allows you to
    interact with HTML elements reactively and combine them with computed Signals
    and Signal effects. Using the Signal-based approach instead of decorators offers
    some additional advantages:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: You can make the query results more predictable.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All Signal-based queries return a Signal and when there are multiple values,
    the Signals returns a regular array. The decorators return a variety of return
    types and when your query returns multiple values, they return a query list instead
    of a regular array.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal-based queries can be used for HTML elements that change over time because
    they are rendered conditionally or outputted in a `for` loop. The directive approach
    has issues with both scenarios and doesn’t automatically notify you when the template
    is updated.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript can automatically infer the type of the queried HTML element or component.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you know about the advantages of query-based Signals compared to the
    directive approach, let’s explore the syntax of query-based Signals. Instead of
    defining a directive, the Signal-based approach works with simple functions. There
    are four different functions: `viewChild()`, `contentChild()`, `viewChildren()`,
    and `contentChildren()`. You provide the functions with your query selector, similar
    to the query selectors you can use in combination with decorators. Here’s an example
    of how to use Signal queries:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding example, we used the `viewChild()` query Signal to retrieve
    the `<div>` element with the `#el` ID defined on it and the `<my-component>` element.
    Alternatively, if you want to retrieve multiple elements with the same selector,
    you can use the `viewChildren()` function.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: With that, you know how to query template elements using the new Signal-based
    approach. You also learned what advantages the new Signals-based approach has
    over decorators. Decorators can still be used if you prefer them or have them
    within your codebase.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about Signals. You learned how to create, read,
    and update Signals using the `set()` and `update()` methods. Then, we added some
    Signals in `ExpensesOverviewComponent` and learned about computed Signals. Lastly,
    you learned about Signal effects, Signal component inputs, and query Signals.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, you learned about RxJS; in the next section, you will
    learn how you can combine RxJS and Signals.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Combining Signals and RxJS
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ve seen how Signals and RxJS can help you manage data
    changes reactively. Both Signals and RxJS allow you to react when values change
    and create new values by combining multiple data streams or performing side effects
    based on data changes. So, the following questions might arise: Do signals replace
    RxJS? And when do I use Signals, and when do I use RxJS?'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: RxJS can sometimes feel daunting and complex, so some developers might be tempted
    to replace RxJS with Signals completely. While this might be possible for some
    applications, both RxJS and Signals have their place within your applications
    and solve different problems and needs. In many scenarios, you can devise a solution
    for your problem using Signals or RxJS, but one of the two will do a better job
    at solving the problem and will handle it with much fewer lines of code. Signals
    are not here to replace RxJS, yet Signals will complement it and, in many scenarios,
    work together with your RxJS code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Signals and RxJS are supposed to co-exist, Angular created two RxJS
    interoperability functions: `toSignal` function.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Using toSignal
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toSignal` function is used to transform an Observable into a Signal. The
    `toSignal` function is very similar to the `ASYNC` pipe, only with more flexibility
    and configuration options, and it can be used anywhere in the application. The
    syntax is pretty straightforward; you use the `toSignal` function and supply it
    with an Observable:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: injector = inject(Injector);
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: counter = toSignal(this.countObs$, toSignal function with an additional configuration
    object in which we provided the injector property. There may also be scenarios
    where you don’t want the toSignal function to automatically unsubscribe the Observable
    when the component or injection context is destroyed.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'You might want to stop the Observable earlier or later, depending on your system’s
    needs. For this scenario, you can provide the `toSignal` function with a `manualCleanup`
    configuration, similar to the Signal effect:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: counter = toSignal(this.countObs$, {undefined as your initial value might cause
    problems inside computed signals or Signal effects that use the Signal with the
    undefined value.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, some Observables emit a synchronous value upon subscription;
    think of `BehaviorSubject`, for example. If you use an Observable that emits a
    synchronous value upon subscription, you also need to configure this inside the
    `toSignal` function using the `requireSync` configuration:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By setting the `requireSync` option to `true`, the `toSignal` function enforces
    that the initial value upon subscription is received synchronously, skipping the
    initial `undefined` value and typing the Signal as `undefined`. Lastly, you can
    configure how the `toSignal` function should handle errors that happen in the
    Observable.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, if the Observable throws an error, the Signal will throw the error
    whenever the Signal is read. You can also set the `rejectErrors` option to `true`;
    in that case, the `toSignal` function will ignore the error and keep returning
    the last good value the Observable emitted:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: counter = toSignal(this.countObs$);
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: countObs$ = toObservable function behind the scenes, Angular will use a Signal
    effect to track the values of the Signal you use inside the toObservable function
    and emit the updated values to the Observable. Because Angular uses a Signal effect
    to update the values of the Observable, it will only emit stabilized changes in
    the Signal. So, if you set the Signal multiple times in a row without an interval,
    the Observable that’s created with toObservable will only emit the last value
    when the Signal is stabilized.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `toObservable` function uses the current injection context
    to create the Signal effect; if you declare the `toObservable` function outside
    the injection context or if you want to create the Signal effect inside another
    injection context, you can provide the `toObservable` function with an injection
    context:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: id = input(0);
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: product = toSignal(
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: toObservable(this.id).pipe(
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: switchMap((id) => this.service.getProduct(id as number)),
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: ),
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '{ initialValue: null }'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
