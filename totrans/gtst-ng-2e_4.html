<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Getting Started with Angular Components and Directives"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Getting Started with Angular Components and Directives</h1></div></div></div><p>By this point, we're already familiar with the core building blocks that Angular provides for the development of single-page applications and the relations between them. However, we've touched only the surface by introducing the general idea behind Angular's concepts and the basic syntax used for their definition. In this chapter, we'll take a deep dive into Angular's components and directives.</p><p>In the following sections, we will cover these topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enforced separation of concerns of the building blocks that Angular provides for developing applications.</li><li class="listitem" style="list-style-type: disc">The appropriate use of directives or components when interacting with the DOM.</li><li class="listitem" style="list-style-type: disc">Built-in directives and developing custom ones.</li><li class="listitem" style="list-style-type: disc">An in-depth look at components and their templates.</li><li class="listitem" style="list-style-type: disc">Content projection.</li><li class="listitem" style="list-style-type: disc">View children versus content children.</li><li class="listitem" style="list-style-type: disc">The component's life cycle.</li><li class="listitem" style="list-style-type: disc">Using template references.</li><li class="listitem" style="list-style-type: disc">Configuring Angular's change detection.</li></ul></div><div class="section" title="The &quot;Hello world!&quot; application in Angular"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>The "Hello world!" application in Angular</h1></div></div></div><p>Now, let's build our first "Hello world!" application in Angular. In order to get everything up and running as easy and quickly as possible, for our first application, we will use the ECMAScript 5 syntax with the transpiled bundle of Angular. First, create the <code class="literal">index.html</code> file with the following content:</p><pre class="programlisting">&lt;!-- ch4/es5/hello-world/index.html --&gt; &#13;
 &#13;
&lt;!DOCTYPE html&gt;&#13;
&lt;html lang="en"&gt;&#13;
&lt;head&gt;&#13;
  &lt;meta charset="UTF-8"&gt;&#13;
  &lt;title&gt;&lt;/title&gt;&#13;
&lt;/head&gt;&#13;
&lt;body&gt;&#13;
  &lt;script src="https://unpkg.com/zone.js@0.6.25/dist/zone.js"&gt;&lt;/script&gt;&#13;
  &lt;script src="https://unpkg.com/reflect-metadata@0.1.3/Reflect.js"&gt;&lt;/script&gt;&#13;
  &lt;script src="https://unpkg.com/rxjs@5.0.1/bundles/Rx.js"&gt;&lt;/script&gt;&#13;
  &lt;script src="https://unpkg.com/@angular/core@2.2.0/bundles/core.umd.js"&gt;&lt;/script&gt;&#13;
  &lt;script src="https://unpkg.com/@angular/common@2.2.0/bundles/common.umd.js"&gt;&lt;/script&gt;&#13;
  &lt;script src="https://unpkg.com/@angular/compiler@2.2.0/bundles/compiler.umd.js"&gt;&lt;/script&gt;&#13;
  &lt;script src="https://unpkg.com/@angular/platform-browser@2.2.0/bundles/platform-browser.umd.js"&gt;&lt;/script&gt;&#13;
  &lt;script src="https://unpkg.com/@angular/platform-browser-dynamic@2.2.0/bundles/platform-browser-dynamic.umd.js"&gt;&lt;/script&gt;&#13;
  &lt;script src="./app.js"&gt;&lt;/script&gt;&#13;
&lt;/body&gt;&#13;
&lt;/html&gt;&#13;
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Note that the examples in this book are built with Angular 2.2.0. In case you're using a newer version of the framework there might be slight differences. For further information take a look at the changelog at
<a class="ulink" href="https://github.com/angular/angular/blob/master/CHANGELOG.md">https://github.com/angular/angular/blob/master/CHANGELOG.md</a>.</p></div></div><p>The preceding HTML file defines the basic structure of our page. Just before closing the <code class="literal">body</code> tag, we have references to a few script files: polyfills (zone.js and reflect-metadata) required by the framework, RxJS, the ES5 bundles of different packages of Angular, and the file that contains the application we're going to build.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>RxJS is used by Angular's core in order to allow us to empower the reactive programming paradigm in our applications. In the following content, we will take only a shallow look at how we can take advantage of observables. For further information, you can visit the RxJS GitHub repository at <a class="ulink" href="https://github.com/ReactiveX/rxjs">
https://github.com/ReactiveX/rxjs
</a>.</p></div></div><p>In the same directory where your <code class="literal">index.html</code> resides, create a file called <code class="literal">app.js</code> and enter the following content inside it:</p><pre class="programlisting">// ch4/es5/hello-world/app.js &#13;
 &#13;
var App = ng.core.Component({&#13;
  selector: 'my-app',&#13;
  template: '&lt;h1&gt;Hello {{target}}!&lt;/h1&gt;'&#13;
})&#13;
.Class({&#13;
  constructor: function () {&#13;
    this.target = 'world';&#13;
  }&#13;
});&#13;
&#13;
var AppModule = ng.core.NgModule({&#13;
  imports: [ng.platformBrowser.BrowserModule],&#13;
  declarations: [App],&#13;
  bootstrap: [App]&#13;
})&#13;
.Class({&#13;
  constructor: function () {}&#13;
});&#13;
&#13;
ng.platformBrowserDynamic&#13;
 .platformBrowserDynamic()&#13;
 .bootstrapModule(AppModule);&#13;
</pre><p>In the preceding snippet, we defined a component called <code class="literal">App</code> with an <code class="literal">my-app</code> selector. The component has the following template:</p><pre class="programlisting">'&lt;h1&gt;Hello {{target}}!&lt;/h1&gt;' &#13;
</pre><p>This syntax should already be familiar to you from AngularJS. When compiled in the context of the given component, the preceding snippet will interpolate the template with the result of the expression inside the curly brackets. In our case, the expression is simply the <code class="literal">target</code> variable.</p><p>To <code class="literal">Class</code>, we pass an object literal, which has a single method called <code class="literal">constructor</code>. This <span class="strong"><strong>DSL</strong></span> (<span class="strong"><strong>domain-specific language</strong></span>) provides an alternative way to define classes in ECMAScript 5. In the body of the <code class="literal">constructor</code> function, we add a property called <code class="literal">target</code> with a value of the <code class="literal">"world"</code> string. Right after that, we define our <code class="literal">AppModule</code> class. Note that every component on our application must be associated with a module. Inside the module, as explained in <a class="link" href="ch02.html" title="Chapter 2. The Building Blocks of an Angular Application">Chapter 2</a>, <span class="emphasis"><em>The Building Blocks of an Angular Application</em></span>, we define the declarations, imports, and the bootstrap component.</p><p>At the last line of the snippet, we invoke the <code class="literal">bootstrapModule</code> method of the object returned by the invocation of <code class="literal">ng.platformBrowserDynamic()</code>. As argument of <code class="literal">bootstrapModule</code>, we pass the <code class="literal">AppModule</code> we just defined.</p><p>Note that <code class="literal">bootstrapModule</code> is under the <code class="literal">ng.platformBrowserDynamic</code> namespace. This is due to the fact that the framework is built with different platforms in mind, such as the browser, NativeScript, and so on. By placing the bootstrap methods used by the different platforms under a separate namespace, Angular can implement different logic to initialize the application.</p><p>Now, if you open <code class="literal">index.html</code> with your browser, you should see some errors, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img alt="The &quot;Hello world!&quot; application in Angular" src="graphics/B06166_04_01.jpg"/></div><p>
</p><p>Figure 1</p><p>This happened because we missed something quite important. We didn't use the root component anywhere inside <code class="literal">index.html</code>. In order to finish the application, add the following HTML element after the open tag of the body element:</p><pre class="programlisting">&lt;my-app&gt;&lt;/my-app&gt; &#13;
</pre><p>Now, you can refresh your browser to see the following result:</p><p>
</p><div class="mediaobject"><img alt="The &quot;Hello world!&quot; application in Angular" src="graphics/2.jpg"/></div><p>
</p><p>Figure 2</p></div></div>
<div class="section" title="Using TypeScript"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Using TypeScript</h1></div></div></div><p>Although we already have an Angular application running, we can do much better! We didn't use any package manager or module loader. We spent all of <a class="link" href="ch03.html" title="Chapter 3. TypeScript Crash Course">
Chapter 3</a>, <span class="emphasis"><em>TypeScript Crash Course</em></span>, talking about TypeScript; however, we didn't write a single line of it in the preceding application. Although it is not required that you use TypeScript with Angular, it's more convenient to take advantage of all the bonuses that static typing provides. By using TypeScript, we can also use the Ahead-of-Time compilation in Angular.</p><div class="section" title="Setting up our environment"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Setting up our environment</h2></div></div></div><p>The core team of Angular developed a brand new CLI tool for Angular, which allows us to bootstrap our applications with a few commands. Although we will introduce it in the final chapter, by then, in order to boost our learning experience, we will use the code located at
<a class="ulink" href="https://github.com/mgechev/getting-started-with-angular">https://github.com/mgechev/getting-started-with-angular</a>. This repository includes all the examples in this book, in one big application. It has all the required dependencies declared in <code class="literal">package.json</code>, the definition of basic gulp tasks, such as the development server, the transpilation of your TypeScript code to ECMAScript 5, live-reload, and so on.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>The project that contains all the examples for this book is based on angular-seed (<a class="ulink" href="https://github.com/mgechev/angular-seed">https://github.com/mgechev/angular-seed</a>), which allows us to quickly bootstrap an Angular application.</p></div></div><p>In order to set up the <code class="literal">getting-started-with-angular</code> project, you'll need Git, Node.js v6.x.x, and npm up and running on your computer. If you have a different version of the Node.js installed, I recommend that you take a look at nvm (the Node.js version manager, which is available at <a class="ulink" href="https://github.com/creationix/nvm">https://github.com/creationix/nvm</a>) or n (<a class="ulink" href="https://www.npmjs.com/package/n">
https://www.npmjs.com/package/n
</a>). Using these tools, you'll be able to have multiple versions of Node.js on your machine and switch between them with a single command via the command line.</p></div><div class="section" title="Installing the sample project repository"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Installing the sample project repository</h2></div></div></div><p>Let's start by setting up the <code class="literal">getting-started-with-angular</code> project. Open your terminal and enter the following commands:</p><pre class="programlisting">
<span class="strong"><strong># Will clone the repository and save it to directory called&#13;
# getting-started-with-angular&#13;
$ git clone https://github.com/mgechev/getting-started-with-angular.git&#13;
$ cd getting-started-with-angular&#13;
$ npm install</strong></span>
</pre><p>The first line will clone the <code class="literal">getting-started-with-angular</code> project into a directory called <code class="literal">getting-started-with-angular</code>; after that we enter that directory.</p><p>The last step before being able to run the seed project is to install all the required dependencies using npm. This step may take a while depending on your Internet connection, so be patient and do not interrupt it. If you encounter any problems, do not hesitate to raise the issues at <a class="ulink" href="https://github.com/mgechev/getting-started-with-angular/issues">https://github.com/mgechev/getting-started-with-angular/issues</a>.</p><p>The last step left is to start the development server:</p><pre class="programlisting">
<span class="strong"><strong>$ npm start </strong></span>
</pre><p>When the process of the transpilation is completed, your browser will automatically open with <code class="literal">http://localhost:5555/dist/dev</code>. You should now see a view similar to what is shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img alt="Installing the sample project repository" src="graphics/3.jpg"/></div><p>
</p><p>Figure 3</p></div></div>
<div class="section" title="Playing with Angular and TypeScript"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Playing with Angular and TypeScript</h1></div></div></div><p>Now, let's play around with the files we already have. Navigate to the <code class="literal">app/ch4/ts/hello-world</code> directory inside <code class="literal">getting-started-with-angular</code>. Then, open <code class="literal">app.ts</code> and replace its content with the following snippet:</p><pre class="programlisting">// ch4/ts/hello-world/app.ts &#13;
 &#13;
import {Component, NgModule} from '@angular/core';&#13;
import {BrowserModule} from '@angular/platform-browser';&#13;
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';&#13;
&#13;
@Component({&#13;
  selector: 'my-app',&#13;
  templateUrl: './app.html'&#13;
})&#13;
class App {&#13;
  target: string;&#13;
  constructor() {&#13;
    this.target = 'world';&#13;
  }&#13;
}&#13;
&#13;
@NgModule({&#13;
  declarations: [App],&#13;
  imports: [BrowserModule],&#13;
  bootstrap: [App],&#13;
})&#13;
class AppModule {}&#13;
&#13;
platformBrowserDynamic().bootstrapModule(AppModule);&#13;
</pre><p>Let's take a look at the code line by line:</p><pre class="programlisting">import {Component, NgModule} from '@angular/core';&#13;
import {BrowserModule} from '@angular/platform-browser';&#13;
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';</pre><p>Initially, we import the <code class="literal">@Component</code> and <code class="literal">@NgModule</code> decorators from the <code class="literal">@angular/core</code> module, <code class="literal">BrowserModule</code> from <code class="literal">@angular/platform-browser</code> and the <code class="literal">platformBrowserDynamic</code> object from <code class="literal">@angular/platform-browser-dynamic</code>. Later, we use <code class="literal">@Component</code> to decorate the <code class="literal">App</code> class. To the <code class="literal">@Component</code> decorator, we pass the same object literal that we used in the ECMAScript 5 version of the application, but this time we reference to an external template.</p><p>As a next step, we define the view of the component. However, note that in this case, we use <code class="literal">templateUrl</code> instead of simply inlining the component's template.</p><p>Open <code class="literal">app.html</code> and replace the file's content with <code class="literal">&lt;h1&gt;Hello {{target}}!&lt;/h1&gt;</code>. The content of <code class="literal">app.html</code> should be the same as the inlined template we have used previously. Since we can use a template by both inlining it (with <code class="literal">template</code>) and setting its URL (<code class="literal">templateUrl</code>), in some sense, the component's API is similar to the AngularJS directives API.</p><p>In the last line of the snippet, we bootstrap the application by providing the root module.</p><p>Now, let's take a look at <code class="literal">index.html</code> in order to get a sense of what goes on when we start the application:</p><pre class="programlisting">&lt;!-- ch4/ts/hello-world/index.html --&gt; &#13;
&lt;!DOCTYPE html&gt; &#13;
&lt;html lang="en"&gt; &#13;
&lt;head&gt; &#13;
  &lt;meta charset="utf-8"&gt; &#13;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &#13;
  &lt;title&gt;&lt;%= TITLE %&gt;&lt;/title&gt; &#13;
  &lt;meta name="description" content=""&gt; &#13;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &#13;
  &lt;!-- inject:css --&gt; &#13;
  &lt;!-- endinject --&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
  &lt;my-app&gt;Loading...&lt;/my-app&gt; &#13;
  &lt;!-- inject:js --&gt; &#13;
  &lt;!-- endinject --&gt; &#13;
  &lt;%= INIT %&gt; &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>Note that inside the body of the page, we use the <code class="literal">my-app</code> element with content a text node with value <code class="literal">"Loading..."</code>. The <code class="literal">"Loading..."</code> label will be visible until the application gets bootstrapped and the main component gets rendered.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>There are template placeholders <code class="literal">&lt;%= INIT %&gt; </code> and <code class="literal">&lt;-- inject:js...</code> that inject content that is specific to individual demos. They are not Angular specific, but instead aim to prevent code duplications in the code samples attached to the book because of the shared structure between them. In order to see how this specific HTML file has been transformed, open <code class="literal">/dist/dev/ch4/ts/hello-world/index.html</code>.</p></div></div></div>
<div class="section" title="Using Angular directives"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Using Angular directives</h1></div></div></div><p>We have already built our simple "Hello world!" app. Now, let's start building something that is closer to a real-life application. By the end of this section, we'll have a simple application that lists a number of items we need to do and greets us at the header of the page.</p><p>Let's start by developing our <code class="literal">app</code> component. The two modifications from the preceding example that we need to make are renaming the <code class="literal">target</code> property to <code class="literal">name</code> and adding a list of <code class="literal">todos</code> to the component's controller definition:</p><pre class="programlisting">// ch4/ts/ng-for/detailed-syntax/app.ts &#13;
 &#13;
import {Component, NgModule} from '@angular/core';&#13;
import {BrowserModule} from '@angular/platform-browser';&#13;
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';&#13;
&#13;
@Component({&#13;
  selector: 'app',&#13;
  templateUrl: './app.html',&#13;
})&#13;
class App {&#13;
  todos: string[];&#13;
  name: string;&#13;
  constructor() {&#13;
    this.name = 'John';&#13;
    this.todos = ['Buy milk', 'Save the world'];&#13;
  }&#13;
}&#13;
&#13;
@NgModule({&#13;
  declarations: [App],&#13;
  imports: [BrowserModule],&#13;
  bootstrap: [App],&#13;
})&#13;
class AppModule {}&#13;
&#13;
platformBrowserDynamic().bootstrapModule(AppModule);&#13;
</pre><p>The only thing left is to update the template in order to consume the provided data. We're already familiar with the <code class="literal">ng-repeat</code> directive from AngularJS. It allows us to loop over a list of items using a microsyntax, which is later interpreted by AngularJS. However, the directive doesn't carry enough semantics, so it is hard to build tools that perform static code analysis and help us improve our development experience. Since the <code class="literal">ng-repeat</code> directive is quite useful, Angular kept the idea and improved it further in order to allow more sophisticated tooling by introducing further semantics on top of it. It allows IDEs and text editors to perform better static code analysis. Such support will prevent us from making typos in the code we write and allow us to have a smoother development experience.</p><p>In <code class="literal">app.html</code>, add the following content:</p><pre class="programlisting">&lt;!-- ch4/ts/ng-for/detailed-syntax/app.html --&gt; &#13;
 &#13;
&lt;h1&gt;Hello {{name}}!&lt;/h1&gt; &#13;
&lt;p&gt; &#13;
  Here's a list of the things you need to do: &#13;
&lt;/p&gt; &#13;
&lt;ul&gt; &#13;
  &lt;template ngFor let-todo [ngForOf]="todos"&gt; &#13;
    &lt;li&gt;{{todo}}&lt;/li&gt; &#13;
  &lt;/template&gt; &#13;
&lt;/ul&gt; &#13;
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The <code class="literal">template</code> element is a place where we can hold markup and make sure that it won't be rendered by the browser. This is quite useful if we need to embed the templates of our application directly into the markup of the page and let the template engine we're using to process them at some point. In the current example, this means that if the Angular's DOM compiler doesn't process the DOM tree, we will not see the list item inside the <code class="literal">ul</code> element.</p></div></div><p>Now, after you refresh your browser, you should see the following result:</p><p>
</p><div class="mediaobject"><img alt="Using Angular directives" src="graphics/4-2.jpg"/></div><p>
</p><p>Figure 4</p><p>So far, so good! The only new things left in the preceding snippets are the attributes of the <code class="literal">template</code> element that we're not familiar with, such as <code class="literal">ngFor</code>, <code class="literal">let-todo</code>, and <code class="literal">[ngForOf]</code>. Let's take a look at them.</p><div class="section" title="The ngFor directive"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>The ngFor directive</h2></div></div></div><p>The <code class="literal">ngFor</code> directive is a directive that allows us to loop over a collection of items and does exactly what <code class="literal">ng-repeat</code> does in AngularJS, but it brings some extra semantics. Note that the <code class="literal">ngForOf</code> attribute is surrounded by brackets. At first, these brackets may seem like invalid HTML. However, according to the HTML specification, their use is permitted in attribute names. The only thing the W3C validator will complain about is the fact that the <code class="literal">template</code> element doesn't own such attributes; however, browsers won't have problems processing the markup.</p><p>The semantics behind these brackets is that the value of the attribute surrounded by them is an expression, which needs to be evaluated.</p></div></div>
<div class="section" title="Improved semantics of the directives syntax"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Improved semantics of the directives syntax</h1></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter 1. Get Going with Angular">
Chapter 1</a>, <span class="emphasis"><em>Get Going with Angular</em></span>, we mentioned the opportunity for improved tooling in Angular. A big issue in AngularJS is the different ways in which we can use directives. This requires an understanding of the attribute values, which can be literals, expressions, callbacks, or a microsyntax. Starting with Angular 2, this problem is eliminated by introducing a few simple conventions that are built into the framework:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">propertyName="value"</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">[propertyName]="expression"</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">(eventName)="handler()"</code></li></ul></div><p>In the first line, the <code class="literal">propertyName</code> attribute accepts a string literal as a value. Angular will not process the attribute's value any further; it will use it the way it is set in the template.</p><p>The second syntax, <code class="literal">[propertyName]="expression"</code>, gives a hint to Angular that the value of the attributes should be handled as an expression. When Angular finds an attribute surrounded by brackets, it will interpret the expression in the context of the component associated with the template. In short, if we want to set a nonstring value or the result of an expression as value of given property, we will need to use this syntax.</p><p>The last example shows how we can bind to events. The semantics behind <code class="literal">(eventName)="handler()"</code> is that we want to handle all events called <code class="literal">eventName</code> that are triggered by the given component with the <code class="literal">handler()</code> expression.</p><p>We will discuss more examples later in this chapter.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Angular provides alternative canonical syntax, which allows us to define the bindings of the elements without using brackets. For instance, the property binding can be expressed using the following code:
<code class="literal">&lt;input [value]="foo"&gt;</code></p><p>It can also be expressed using this:
<code class="literal">&lt;input bind-value="foo"&gt;</code></p><p>Similarly, we can express the event bindings with the following code:
<code class="literal">&lt;button (click)="handle()"&gt;Click me&lt;/button&gt;</code></p><p>They can also be expressed using this:
<code class="literal">&lt;button on-click="handle()"&gt;Click me&lt;/button&gt;</code>
</p></div></div><div class="section" title="Declaring variables inside a template"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Declaring variables inside a template</h2></div></div></div><p>The last thing left from the preceding template is the <code class="literal">let-todo</code> attribute. Using this syntax, we are telling Angular that we want to declare a new variable called <code class="literal">todo</code> and bind it to the individual items from the collection we get from the evaluation of the expression set as a value of <code class="literal">[ngForOf]</code>.</p></div><div class="section" title="Using syntax sugar in templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Using syntax sugar in templates</h2></div></div></div><p>Although the template syntax provides much more meaning of the code to the IDEs or text editors we use, it is quite verbose. Angular provides an alternative syntax, which will be desugared to the one shown in the preceding snippet.</p><p>There are a few Angular directives that require the usage of a template element, for example, <code class="literal">ngForOf</code>, <code class="literal">ngIf</code>, and <code class="literal">ngSwitch</code>. Since such directives are used often, there's an alternative syntax for them. Instead of typing down the entire template element explicitly, we can simply prefix the directive with <code class="literal">*</code>. This will allow us to turn our <code class="literal">ngForOf</code> directive syntax usage into the following:</p><pre class="programlisting">&lt;!-- ch4/ts/ng-for/syntax-sugar/app.html --&gt; &#13;
 &#13;
&lt;ul&gt; &#13;
  &lt;li *ngFor="let todo of todos"&gt;{{todo}}&lt;/li&gt; &#13;
&lt;/ul&gt; &#13;
</pre><p>Later, this template will be desugared by Angular to the more verbose syntax described earlier. Since the less verbose syntax is easier to read and write, its use is considered as the best practice.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>The <code class="literal">*</code> character allows us to remove the <code class="literal">template</code> element and put the directive directly on the top-level child element of the <code class="literal">template</code> (in the preceding example, the list item, <code class="literal">li</code>).</p></div></div></div></div>
<div class="section" title="Defining Angular directives"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Defining Angular directives</h1></div></div></div><p>Now that we've built a simple Angular component, let's continue our journey by understanding the Angular directives.</p><p>Using Angular directives, we can apply different behavioral or structural changes over the DOM. In this example, we will build a simple tooltip directive.</p><p>In contrast to components, directives do not have views and templates. Another core difference between these two concepts is that the given HTML element may have only a single component but multiple directives on it. In other words, directives augment the elements compared to components that are the actual elements in our views.</p><p>Angular's official style guide's recommendation is to use directives as attributes, prefixed with a namespace. Keeping this in mind, we will use the tooltip directive in the following way:</p><pre class="programlisting">&lt;div saTooltip="Hello world!"&gt;&lt;/div&gt; &#13;
</pre><p>In the preceding snippet, we use the tooltip directive over the <code class="literal">div</code> element. As a namespace, its selector uses the <code class="literal">sa</code> string.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>Since the focus of the book is an efficient and intuitive learning of Angular's concepts, the code snippets may not completely align with the Angular style guide. However, for production applications, following best practices is essential. You can find the official Angular style guide at

<a class="ulink" href="https://angular.io/styleguide">https://angular.io/styleguide</a>
.</p></div></div><p>Now, let's develop a tooltip directive! Before implementing it, we need to import a couple of symbols from <code class="literal">@angular/core</code>. Open a new TypeScript file called <code class="literal">app.ts</code> and enter the following content; we'll fill the placeholders later:</p><pre class="programlisting">import {Directive, ElementRef, HostListener...} from '@angular/core'; &#13;
</pre><p>In the preceding line, we import the following definitions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ElementRef</code>: This allows us to inject the element reference (we're not limited to the DOM only) to the host element. In the sample usage of the preceding tooltip, we get an Angular wrapper of the <code class="literal">div</code> element, which holds the <code class="literal">saTooltip</code> attribute.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Directive</code>: This decorator allows us to add the metadata required for the new directives we define.</li><li class="listitem" style="list-style-type: disc"><code class="literal">HostListener(eventname)</code>: This is a method decorator that accepts an event name as an argument. During initialization of the directive, Angular will add the decorated method as an event handler for the <code class="literal">eventname</code> events fired by the host element.</li></ul></div><p>Let's look at the directive's implementation:</p><pre class="programlisting">// ch4/ts/tooltip/app.ts &#13;
 &#13;
@Directive({&#13;
  selector: '[saTooltip]'&#13;
})&#13;
export class Tooltip {&#13;
  @Input() saTooltip:string;&#13;
&#13;
  constructor(private el: ElementRef, private overlay: Overlay) {&#13;
    this.overlay.attach(el.nativeElement);&#13;
  }&#13;
&#13;
  @HostListener('mouseenter')&#13;
  onMouseEnter() {&#13;
    this.overlay.open(this.el, this.saTooltip);&#13;
  }&#13;
&#13;
  @HostListener('mouseleave')&#13;
  onMouseLeave() {&#13;
    this.overlay.close();&#13;
  }&#13;
}&#13;
</pre><div class="section" title="Setting the directive's inputs"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Setting the directive's inputs</h2></div></div></div><p>In the preceding example, we declared a directive with the <code class="literal">saTooltip</code> selector. Note that Angular's HTML compiler is case sensitive, which means that it will distinguish the <code class="literal">[satooltip]</code> and <code class="literal">[saTooltip]</code> selectors. After that, we declare the input of the directive using the <code class="literal">@Input</code> decorator over the <code class="literal">saTooltip</code> property. The semantics behind this code is that we declare a property called <code class="literal">saTooltip</code> and bind it to the value of the result that we got from the evaluation of the expression passed to the <code class="literal">saTooltip</code> attribute.</p><p>The <code class="literal">@Input</code> decorator accepts a single argument, that is, the name of the attribute we want to bind to. In case we don't pass an argument, Angular will create a binding between the attribute with the same name as the property itself. We will explain the concept of input and output in detail later in this chapter.</p></div><div class="section" title="Understanding the directive's constructor"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Understanding the directive's constructor</h2></div></div></div><p>The constructor declares two private properties: <code class="literal">el</code> of the <code class="literal">ElementRef</code> type and <code class="literal">overlay</code> of the <code class="literal">Overlay</code> type. The <code class="literal">Overlay</code> class implements logic to manage the tooltips' overlays and will be injected using the DI mechanism of Angular. In order to declare it as available for injection, we will need to declare the top-level component in the following way:</p><pre class="programlisting">@Component({ &#13;
  selector: 'app', &#13;
  templateUrl: './app.html', &#13;
  providers: [Overlay], &#13;
  // ... &#13;
}) &#13;
class App {} &#13;
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>We will take a look at the dependency injection mechanism of Angular in the next chapter, where we will explain the way in which we can declare the dependencies of our services, directives, and components.
The implementation of the <code class="literal">Overlay</code> class is not important for the purpose of this chapter. However, if you're interested in it, you can find the implementation at <code class="literal">ch4/ts/tooltip/app.ts</code>.</p></div></div></div><div class="section" title="Better encapsulation of directives with NgModules"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Better encapsulation of directives with NgModules</h2></div></div></div><p>In order to make the tooltip directive available to the Angular's compiler, we will need to explicitly declare where we intend to use it. For instance, take a look at the <code class="literal">AppModule</code> class at <code class="literal">ch4/ts/tooltip/app.ts</code>:</p><pre class="programlisting">@NgModule({&#13;
  declarations: [Tooltip, App],&#13;
  providers: [Overlay],&#13;
  imports: [BrowserModule],&#13;
  bootstrap: [App],&#13;
})&#13;
class AppModule {}&#13;
</pre><p>To the <code class="literal">@NgModule</code> decorator, we pass an object literal that has the <code class="literal">declarations</code> property. This property contains a list of all the directives that will be available in all component subtrees with roots any of the components listed in the <code class="literal">bootstrap</code> array. Another way to extend the list of available directives is to import a module. For instance, the module <code class="literal">BrowserModule</code> includes some very commonly used directives for the browser environment.</p><p>At first, it might seem annoying that you should explicitly declare all the directives that are used in your modules; however, this enforces better encapsulation. In AngularJS, all directives are in a global namespace. This means that all the directives defined in the application are accessible in all the templates. This brings in some problems, for example, name collision. In order to deal with this issue, we introduced naming conventions, for instance, the <code class="literal">"ng-"</code> prefix of all the directives defined by AngularJS and <code class="literal">"ui-"</code> for all directives coming with the Angular UI.</p><p>Currently, by explicitly declaring all the directives that are used within a given module, we create a namespace specific to the individual components' subtrees (that is, the directives will be visible to the given root component and all of its successor components). Preventing name collisions is not the only benefit we get; it also helps us with better semantics of the code that we produce, since we're always aware of the directives accessible by the given component when we know in which module it's declared. We can find all the accessible directives of the given component by following the path from the component to the top module and taking the union of all the values of <code class="literal">declarations</code> and the declarations of the modules' <code class="literal">imports</code>. Given that components are extended from directives, we need to explicitly declare all the used components as well.</p><p>Since Angular defines a set of built-in directives, <code class="literal">BrowserModule</code> exports them by exporting the module <code class="literal">CommonModule</code>, which contains them. This list of predefined directives includes <code class="literal">NgClass</code>, <code class="literal">NgFor</code>, <code class="literal">NgIf</code>, <code class="literal">NgStyle</code>, <code class="literal">NgSwitch</code>, <code class="literal">NgSwitchWhen</code>, and <code class="literal">NgSwitchDefault</code>. Their names are quite self-explanatory; we'll take a look at how we can use some of them later in this chapter.</p></div><div class="section" title="Using NgModules for declaring reusable components"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Using NgModules for declaring reusable components</h2></div></div></div><p>With NgModules, we can achieve a good degree of encapsulation. By explicitly exporting the public components, directives, pipes, and services, we can hide some of the implementation details of our modules. This way we can implement reusable modules and expose only their public interface, and we do not reveal any low-level components to the user of the module.</p><p>In order to get a better idea, let's take a look at the following example:</p><pre class="programlisting">@Component(...)&#13;
class ZippyHeader {&#13;
  @Input() header: string;&#13;
}&#13;
&#13;
@Component(...)&#13;
class Zippy {&#13;
  @Input() header: string;&#13;
  visible = true;&#13;
}&#13;
&#13;
@Component(...)&#13;
class App {}</pre><p>In the preceding snippet, we declare the components <code class="literal">Zippy</code>, <code class="literal">ZippyHeader</code>, and <code class="literal">App</code>. <code class="literal">Zippy</code> is a component that has a header and a content; we can toggle the visibility of the content by clicking on the header. In the component <code class="literal">ZippyHeader</code>, we can implement some logic for handling the click events and/or visualizing the header. In the <code class="literal">App</code> component, we use the <code class="literal">Zippy</code> component by passing text for it's header and content.</p><p>In order to create a working Angular application, we will need to declare an NgModule, which somehow references all the three components. We can approach this in two main ways:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare a single NgModule and include all the three components inside of its list of declarations.</li><li class="listitem">Declare two NgModules:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One that declares the <code class="literal">Zippy</code> and <code class="literal">ZippyHeader</code> components, called <code class="literal">ZippyModule</code>.</li><li class="listitem" style="list-style-type: disc">Another one that declares the <code class="literal">App</code> component and imports the module <code class="literal">ZippyModule</code>.</li></ul></div><p>
</p></li></ol></div><p>The second approach has a couple of advantages: in <code class="literal">ZippyModule</code>, we can declare both <code class="literal">Zippy</code> and <code class="literal">ZippyHeader</code>, but we can export only <code class="literal">Zippy</code> because <code class="literal">ZippyHeader</code> is used internally, within <code class="literal">Zippy</code>, and we don't have to expose it to the user. By declaring the module <code class="literal">ZippyModule</code>, we can import it into other modules in our application where we want to reuse the <code class="literal">Zippy</code> component, or we can even extract it as a separate npm module and reuse it in multiple applications.</p><p>The second approach will look like this:</p><pre class="programlisting">// ch4/ts/zippy/app.ts&#13;
&#13;
@Component(...)&#13;
class ZippyHeader {...}&#13;
&#13;
@Component(...)&#13;
class Zippy {...}&#13;
&#13;
@NgModule({&#13;
<span class="strong"><strong>  declarations: [Zippy, ZippyHeader],&#13;
  exports: [Zippy]</strong></span>&#13;
  imports: [CommonModule],&#13;
})&#13;
class ZippyModule {}&#13;
&#13;
@Component(...)&#13;
class App {...}&#13;
&#13;
@NgModule({&#13;
  imports: [BrowserModule, ZippyModule],&#13;
  declarations: [App],&#13;
  bootstrap: [App]&#13;
})&#13;
class AppModule {}&#13;
&#13;
platformBrowserDynamic().bootstrapModule(AppModule);</pre><p>In the preceding example, in the module <code class="literal">ZippyModule</code>, we declare both <code class="literal">Zippy</code> and <code class="literal">ZippyHeader</code>, but we export only <code class="literal">Zippy</code>. We also import the module <code class="literal">CommonModule</code> from <code class="literal">@angular/common</code> in order to reuse Angular's built-in directives (for instance, <code class="literal">NgIf</code> is exported by the <code class="literal">CommonModule</code>).</p><p>In the <code class="literal">AppModule</code>, all we need to do is to import <code class="literal">ZippyModule</code>, and this way, we'll be able to use all of its exports and providers. We'll discuss providers further in the next chapter.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Note that good practices suggest that we should implement each individual component into a separate file. For the sake of simplicity in the examples for this book, we've violated this practice. For a list of best practices, visit <a class="ulink" href="https://angular.io/styleguide">https://angular.io/styleguide</a>.</p></div></div></div><div class="section" title="Using custom element schema"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Using custom element schema</h2></div></div></div><p>Now, let's suppose we want to add a timer to our page and reuse a Web Component that we have already built. In this case, our application can look something like this:</p><pre class="programlisting">//  ch4/ts/custom-element/app.ts&#13;
&#13;
import {Component, NgModule} from '@angular/core';&#13;
import {BrowserModule} from '@angular/platform-browser';&#13;
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';&#13;
&#13;
@Component({&#13;
  selector: 'my-app',&#13;
  template: `&#13;
    &lt;h1&gt;Hello {{name}}&lt;/h1&gt;&#13;
    The current timeout is &lt;simple-timer&gt;&lt;/simple-timer&gt;&#13;
  `&#13;
})&#13;
class App {&#13;
  name: string = 'John Doe';&#13;
}&#13;
&#13;
@NgModule({&#13;
  imports: [BrowserModule],&#13;
  declarations: [App],&#13;
  bootstrap: [App]&#13;
})&#13;
class AppModule {}&#13;
&#13;
platformBrowserDynamic().bootstrapModule(AppModule);</pre><p>Now, if we run our application, we'll get the following error:</p><p>
</p><div class="mediaobject"><img alt="Using custom element schema" src="graphics/B06166_04_05.jpg"/></div><p>
</p><p>Figure 5</p><p>When Angular parses the template of the <code class="literal">App</code> component, it will find the <code class="literal">&lt;simple-timer&gt;&lt;/simple-timer&gt;</code>. It is not an element defined by the HTML specification and it doesn't match any of the selectors of the directives declared or imported in the <code class="literal">AppModule</code>, so the framework will throw an error.</p><p>So, how we can use Angular with custom components? The solution is to use the <code class="literal">schemas</code> property of the object literal we pass to <code class="literal">@NgModule</code>:</p><pre class="programlisting">import {..., CUSTOM_ELEMENTS_SCHEMA} from '@angular/core';&#13;
&#13;
//...&#13;
&#13;
@NgModule({&#13;
  imports: [BrowserModule],&#13;
  declarations: [App],&#13;
  schemas: [CUSTOM_ELEMENTS_SCHEMA],&#13;
  bootstrap: [App]&#13;
})&#13;
class AppModule {}</pre><p>This way we change the default schema that Angular uses for the validation of the elements and their attributes during parsing.</p><p>By default, the framework will throw an error if it finds an element that doesn't match the element selector of any of the imported or declared directive, or an element defined by the HTML5 spec.</p></div></div>
<div class="section" title="Creating custom Angular components"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Creating custom Angular components</h1></div></div></div><p>Now, let's build a simple to-do application in order to demonstrate the syntax to define components further.</p><p>Our to-do items will have the following format:</p><pre class="programlisting">interface Todo { &#13;
  completed: boolean; &#13;
  label: string; &#13;
} &#13;
</pre><p>Let's start by importing everything we will need:</p><pre class="programlisting">import {Component, NgModule, ViewEncapsulation} from '@angular/core'; &#13;
//...&#13;
</pre><p>Now, let's declare the component and the metadata associated with it:</p><pre class="programlisting">@Component({ &#13;
  selector: 'todo-app', &#13;
  templateUrl: './app.html', &#13;
  styles: [ &#13;
    `ul li { &#13;
      list-style: none; &#13;
    } &#13;
    .completed { &#13;
      text-decoration: line-through; &#13;
    }` &#13;
  ], &#13;
  encapsulation: ViewEncapsulation.Emulated &#13;
}) &#13;
</pre><p>Here, we specify that the selector of the <code class="literal">Todo</code> component will be the <code class="literal">todo-app</code> element. Later, we add the template URL, which points to the <code class="literal">app.html</code> file. After that, we use the <code class="literal">styles</code> property; this is the first time we encounter it. As we can guess from its name, it is used to set the styles of the component.</p><div class="section" title="Introducing the component's view encapsulation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Introducing the component's view encapsulation</h2></div></div></div><p>As we know, Angular is inspired from Web Components, whose core feature is the shadow DOM. The shadow DOM allows us to encapsulate the styles of our Web Components without allowing them to leak outside the component's scope; Angular provides this feature. If we want Angular's renderer to use the shadow DOM, we can use <code class="literal">ViewEncapsulation.Native</code>. However, at the time of writing this book, the shadow DOM was not supported by all browsers; if we want to have the same level of encapsulation without using the shadow DOM, we can use <code class="literal">ViewEncapsulation.Emulated</code>.</p><p>If we don't want to have any encapsulation at all, we can use <code class="literal">ViewEncapsulation.None</code>. By default, the renderer uses encapsulation of the type <code class="literal">Emulated</code>.</p></div><div class="section" title="Implementing the component's controllers"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Implementing the component's controllers</h2></div></div></div><p>Now, let's continue with the implementation of the application:</p><pre class="programlisting">// ch4/ts/todo-app/app.ts &#13;
class TodoCtrl { &#13;
  todos: Todo[] = [{ &#13;
    label: 'Buy milk', &#13;
    completed: false &#13;
  }, { &#13;
    label: 'Save the world', &#13;
    completed: false &#13;
  }];&#13;
  name: string = 'John'; &#13;
&#13;
  addTodo(label) { ... }&#13;
 &#13;
  removeTodo(idx) { ... } &#13;
&#13;
  toggleCompletion(idx) { ... } &#13;
} &#13;
</pre><p>Here is part of the implementation of the controller associated with the template of the <code class="literal">Todo</code> application. Inside the class declaration, we initialized the <code class="literal">todos</code> property to an array with two <code class="literal">todo</code> items.</p><p>Now, let's update the template and render these items. Here's how this is done:</p><pre class="programlisting">&lt;ul&gt; &#13;
  &lt;li *ngFor="let todo of todos; let index = index" [class.completed]="todo.completed"&gt; &#13;
    &lt;input type="checkbox" [checked]="todo.completed" &#13;
      (change)="toggleCompletion(index)"&gt; &#13;
    {{todo.label}} &#13;
  &lt;/li&gt; &#13;
&lt;/ul&gt; &#13;
</pre><p>In the preceding template, we iterate over all the <code class="literal">todo</code> items inside the <code class="literal">todos</code> property of the controller. For each <code class="literal">todo</code> item, we create a checkbox that can <code class="literal">toggle</code> the item's completion status; we also render the <code class="literal">todo</code> item's label with the interpolation directive. Here, we can note a syntax that was explained earlier:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We bind to the change event of the checkbox using <code class="literal">(change)="statement"</code>.</li><li class="listitem" style="list-style-type: disc">We bind to the property of the <code class="literal">todo</code> item using <code class="literal">[checked]="expr"</code>.</li></ul></div><p>In order to have a line across the completed <code class="literal">todo</code> items, we bind to the <code class="literal">class.completed</code> property of the element. Since we want to apply the <code class="literal">completed</code> class to all the completed to-do items, we use <code class="literal">[class.completed]="todo.completed"</code>. This way, we declare that we want to apply the <code class="literal">completed</code> class depending on the value of the <code class="literal">todo.completed</code> expression. Here is how our application looks now:</p><p>
</p><div class="mediaobject"><img alt="Implementing the component's controllers" src="graphics/6-5.jpg"/></div><p>
</p><p>Figure 6</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Similar to the class binding syntax, Angular allows us to bind to the element's styles and attributes. For instance, we can bind to the <code class="literal">td</code> element's <code class="literal">colspan</code> attribute using the following line of code:
<code class="literal">&lt;td [attr.colspan]="colspanCount"&gt;&lt;/td&gt; </code></p><p>In the same way, we can bind to any <code class="literal">style</code> property using this line of code:  <code class="literal">&lt;div [style.backgroundImage]="expression"&gt;&lt;/td&gt; </code>
</p></div></div></div><div class="section" title="Handling user actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Handling user actions</h2></div></div></div><p>So far, so good! Now, let's implement the <code class="literal">toggleCompletion</code> method. This method accepts the index of the to-do item as an argument:</p><pre class="programlisting">toggleCompletion(idx) { &#13;
  let todo = this.todos[idx]; &#13;
  todo.completed = !todo.completed; &#13;
} &#13;
</pre><p>In <code class="literal">toggleCompletion</code>, we simply toggle the <code class="literal">completed</code> boolean value associated with the current to-do item, which is specified by the index passed as an argument to the method.</p><p>Now, let's add a text input to add the new to-do items:</p><pre class="programlisting">&lt;p&gt; &#13;
  Add a new todo: &#13;
  &lt;input #newtodo type="text"&gt; &#13;
  &lt;button (click)="addTodo(newtodo.value); newtodo.value = ''"&gt; &#13;
    Add &#13;
  &lt;/button&gt; &#13;
&lt;/p&gt; &#13;
</pre><p>The input here defines a new variable called <code class="literal">newtodo</code>. Now, we can reference the input element using the <code class="literal">newtodo</code> identifier inside the template. Once the user clicks on the button, the <code class="literal">addTodo</code> method defined in the controller will be invoked with the value of the <code class="literal">newtodo</code> input as an argument. Inside the statement that is passed to the <code class="literal">(click)</code> attribute, we also reset the value of the <code class="literal">newtodo</code> input by setting it to the empty string.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Note that directly manipulating DOM elements is not considered as the best practice since it will prevent our component from running properly outside the browser environment. We will explain how we can migrate this application to Web Workers in 
<a class="link" href="ch08.html" title="Chapter 8. Tooling and Development Experience">Chapter 8</a>, 
<span class="emphasis"><em>Tooling and Development Experience</em></span>.</p></div></div><p>Now, let's define the <code class="literal">addTodo</code> method:</p><pre class="programlisting">addTodo(label) { &#13;
  this.todos.push({ &#13;
    label, &#13;
    completed: false &#13;
  }); &#13;
} &#13;
</pre><p>Inside it, we create a new to-do item using the object literal syntax.</p><p>The only thing left out of our application is to implement removal of the existing to-do items. Since it is quite similar to the functionality used to toggle the completion of the to-do items, I'll leave its implementation as a simple exercise for the reader.</p></div><div class="section" title="Using inputs and outputs"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Using inputs and outputs</h2></div></div></div><p>By refactoring our <code class="literal">todo</code> application, we will demonstrate how we can take advantage of the directives' inputs and outputs:</p><p>
</p><div class="mediaobject"><img alt="Using inputs and outputs" src="graphics/B06166_04_07.jpg"/></div><p>
</p><p>Figure 7</p><p>We can think of the inputs as properties (or even arguments) that the given directive accepts. The outputs could be considered as events that it triggers. When we use a directive provided by a third-party library, mostly, we care about its inputs and outputs because they define its API.</p><p>Inputs refer to values that parameterize the directive's behavior and/or view. On the other hand, outputs refer to events that the directive fires when something special happens.</p></div><div class="section" title="Determining of the inputs and outputs"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Determining of the inputs and outputs</h2></div></div></div><p>Now, let's divide our monolithic to-do application into separate components that communicate with each other. In the following screenshot, you can see the individual components, which when composed together, implement the functionality of the application:</p><p>
</p><div class="mediaobject"><img alt="Determining of the inputs and outputs" src="graphics/8-1.jpg"/></div><p>
</p><p>Figure 8</p><p>The outer rectangle represents the entire <code class="literal">Todo</code> application. The first nested rectangle contains the component that is responsible for entering labels of the new to-do items, and the one below it lists the individual items stored in the root component.</p><p>Having said this, we can define these three components as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">TodoApp</code>: This is responsible for maintaining the list of to-do items (adding new items and toggling the completion status).</li><li class="listitem" style="list-style-type: disc"><code class="literal">InputBox</code>: This is responsible for entering the label of the new to-do item. It has the following inputs and outputs:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inputs: a placeholder for the textbox and a label for the submit button.</li><li class="listitem" style="list-style-type: disc">Outputs: the content of the textbox once the submit button is clicked.</li></ul></div><p>
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">TodoList</code>: This is responsible for rendering the individual to-do items. It has the following inputs and outputs:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inputs: a list of to-do items.</li><li class="listitem" style="list-style-type: disc">Outputs: the completion status of a to-do item.</li></ul></div><p>
</p></li></ul></div><p>Now, let's begin with the implementation!</p></div><div class="section" title="Defining the inputs and outputs"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Defining the inputs and outputs</h2></div></div></div><p>Let's use a bottom-up approach, and start with the <code class="literal">InputBox</code> component. Before that, we need a couple of imports from Angular's <code class="literal">@angular/core</code> package:</p><pre class="programlisting">import { &#13;
  Component, &#13;
  Input, &#13;
  Output, &#13;
  EventEmitter &#13;
} from '@angular/core'; &#13;
</pre><p>In the preceding code, we import the <code class="literal">@Component</code>, <code class="literal">@Input</code>, and <code class="literal">@Output</code> decorators and the <code class="literal">EventEmitter</code> class. As their names state, <code class="literal">@Input</code> and <code class="literal">@Output</code> are used for declaring the directive's inputs and outputs. <code class="literal">EventEmitter</code> is a generic class (that is, accepting a type parameter), which when combined with the <code class="literal">@Output</code> decorator helps us emit outputs.</p><p>As the next step, let's take a look at the <code class="literal">InputBox</code> component's declaration:</p><pre class="programlisting">// ch4/ts/inputs-outputs/app.ts &#13;
 &#13;
@Component({ &#13;
  selector: 'text-input', &#13;
  template: ` &#13;
    &lt;input #todoInput [placeholder]="inputPlaceholder"&gt; &#13;
    &lt;button (click)="emitText(todoInput.value); &#13;
                     todoInput.value = '';"&gt; &#13;
      {{buttonLabel}} &#13;
    &lt;/button&gt; &#13;
  ` &#13;
}) &#13;
class InputBox {...} &#13;
</pre><p>Note that in the template, we declare a text input and keep a reference to it using the <code class="literal">todoInput</code> identifier, and set its placeholder property to the value that we got from the evaluation of the <code class="literal">inputPlaceholder</code> expression. The value of the expression is the value of the <code class="literal">inputPlaceholder</code> property defined in the component's controller. This is the first input that we need to declare:</p><pre class="programlisting">class InputBox { &#13;
  @Input() inputPlaceholder: string; &#13;
  ... &#13;
} &#13;
</pre><p>Similarly, we declare the other input of the <code class="literal">buttonLabel</code> component, which we use as a value of the label of the button:</p><pre class="programlisting">class InputBox { &#13;
  @Input() inputPlaceholder: string; &#13;
  @Input() buttonLabel: string; &#13;
  ... &#13;
} &#13;
</pre><p>In the preceding template, we bind the click event of the button to this  <code class="literal">emitText(todoInput.value); todoInput.value = '';</code> statement. The <code class="literal">emitText</code> method should be defined in the component's controller; once it is invoked, it should emit the value of the text input. Here is how we can implement this behavior:</p><pre class="programlisting">class InputBox { &#13;
  ... &#13;
  @Output() inputText = new EventEmitter&lt;string&gt;();&#13;
 &#13;
  emitText(text: string) { &#13;
    this.inputText.emit(text); &#13;
  } &#13;
} &#13;
</pre><p>Initially, we declare an output called <code class="literal">inputText</code>. As its value, we set a new instance of the type <code class="literal">EventEmitter&lt;string&gt;</code> that we create.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Note that all the outputs of all the components need to be instances of <code class="literal">EventEmitter</code>.</p></div></div><p>Inside the <code class="literal">emitText</code> method, we invoke the <code class="literal">emit</code> method of the <code class="literal">inputText</code> and as its argument we pass the value of the text input.</p><p>Now, let's define the <code class="literal">TodoList</code> component in the same fashion:</p><pre class="programlisting">@Component(...) &#13;
class TodoList { &#13;
  @Input() todos: Todo[]; &#13;
  @Output() toggle = new EventEmitter&lt;Todo&gt;();&#13;
 &#13;
  toggleCompletion(index: number) { &#13;
    let todo = this.todos[index]; &#13;
    this.toggle.emit(todo); &#13;
  } &#13;
} &#13;
</pre><p>Since the value of the object literal passed to the <code class="literal">@Component</code> decorator is not essential for the purpose of this section, we omitted it. The complete implementation of this example can be found at <code class="literal">ch4/ts/inputs-outputs/app.ts</code>. Let's take a look at the body of the <code class="literal">TodoList</code> class. Similarly, to the <code class="literal">InputBox</code> component, we define the <code class="literal">todos</code> input. We also define the <code class="literal">toggle</code> output by declaring the <code class="literal">toggle</code> property, setting its value to a new instance of the type <code class="literal">EventEmitter&lt;Todo&gt;</code> and decorating it with the <code class="literal">@Output</code> decorator.</p></div><div class="section" title="Passing inputs and consuming the outputs"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Passing inputs and consuming the outputs</h2></div></div></div><p>Now, let's combine the components we defined in the preceding section and implement our complete application.</p><p>The last component we need to take a look at is <code class="literal">TodoApp</code>:</p><pre class="programlisting">@Component({ &#13;
  selector: 'todo-app',&#13;
  template: ` &#13;
    &lt;h1&gt;Hello {{name}}!&lt;/h1&gt; &#13;
 &#13;
    &lt;p&gt; &#13;
      Add a new todo: &#13;
      &lt;input-box inputPlaceholder="New todo..." &#13;
        buttonLabel="Add" &#13;
        (inputText)="addTodo($event)"&gt; &#13;
      &lt;/input-box&gt; &#13;
    &lt;/p&gt; &#13;
 &#13;
    &lt;p&gt;Here's the list of pending todo items:&lt;/p&gt; &#13;
    &lt;todo-list [todos]="todos" (toggle)="toggleCompletion($event)"&gt;&lt;/todo-list&gt; &#13;
  ` &#13;
}) &#13;
class TodoApp {...} &#13;
</pre><p>Initially, we define the <code class="literal">TodoApp</code> class and decorate it with the <code class="literal">@Component</code> decorator. Note that in order to use the <code class="literal">InputBox</code> and <code class="literal">TodoList</code> components, we will need to include them in the <code class="literal">declarations</code> property of the decorator of the module, which declares <code class="literal">TodoApp</code>. The magic of how these components collaborate together happens in the template:</p><pre class="programlisting">&lt;input-box inputPlaceholder="New todo..." &#13;
  buttonLabel="Add" &#13;
  (inputText)="addTodo($event)"&gt; &#13;
&lt;/input-box&gt; &#13;
</pre><p>First, we use the <code class="literal">InputBox</code> component and pass values to the inputs <code class="literal">inputPlaceholder</code> and <code class="literal">buttonLabel</code>. Note that just like we saw earlier, if we want to pass an expression as a value to any of these inputs, we will need to surround them with brackets (that is, <code class="literal">[inputPlaceholder]="expression"</code>). In this case, the expression will be evaluated in the context of the component that owns the template, and the result will be passed as an input to the component that owns the given property.</p><p>Right after we pass the value for the <code class="literal">buttonLabel</code> input, we consume the <code class="literal">inputText</code> output by setting the value of the <code class="literal">(inputText)</code> attribute to the <code class="literal">addTodo($event)</code> expression. <span class="emphasis"><em>The value of </em></span>
<code class="literal">$event</code>
<span class="emphasis"><em> will equal the value we passed to the </em></span>
<code class="literal">emit</code>
<span class="emphasis"><em> method of the </em></span>
<code class="literal">inputText</code>
<span class="emphasis"><em> object inside the </em></span>
<code class="literal">emitText</code>
<span class="emphasis"><em> method of </em></span>
<code class="literal">InputBox</code> (in case we bind to a native event, the value of the event object will be the native event object itself).</p><p>In the same way, we pass the input of the <code class="literal">TodoList</code> component and handle its toggle output. Now, let's define the logic behind the <code class="literal">TodoApp</code> component:</p><pre class="programlisting">class TodoApp { &#13;
  todos: Todo[] = []; &#13;
  name: string = 'John';&#13;
 &#13;
  addTodo(label: string) { &#13;
    this.todos.push({ &#13;
      label, &#13;
      completed: false &#13;
    }); &#13;
  }&#13;
 &#13;
  toggleCompletion(todo: Todo) { &#13;
    todo.completed = !todo.completed; &#13;
  } &#13;
} &#13;
</pre><p>In the <code class="literal">addTodo</code> method, we simply push a new to-do item to the <code class="literal">todos</code> array. The implementation of <code class="literal">toggleCompletion</code> is even simpler: we toggle the value of the completed flag that is passed as an argument to the to-do item. Now, we are familiar with the basics of the components' inputs and outputs.</p></div><div class="section" title="Event bubbling"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Event bubbling</h2></div></div></div><p>In Angular, we have the same bubbling behavior we're used to in the DOM. For instance, let's suppose we have the following template:</p><pre class="programlisting">&lt;input-box inputPlaceholder="New todo..." &#13;
  buttonLabel="Add" &#13;
  (click)="handleClick($event)" &#13;
  (inputText)="addTodo($event)"&gt; &#13;
&lt;/input-box&gt; &#13;
</pre><p>The declaration of <code class="literal">input-box</code> looks like this:</p><pre class="programlisting">&lt;input #todoInput [placeholder]="inputPlaceholder"&gt; &#13;
&lt;button (click)="emitText(todoInput.value); &#13;
                 todoInput.value = '';"&gt; &#13;
  {{buttonLabel}} &#13;
&lt;/button&gt; &#13;
</pre><p>Once the user clicks on the button defined within the template of the <code class="literal">input-box</code> component, the <code class="literal">handleClick($event)</code> expression will be evaluated.</p><p>Further, the <code class="literal">target</code> property of the first argument of <code class="literal">handleClick</code> will be the button itself, but the <code class="literal">currentTarget</code> property will be the <code class="literal">input-box</code> element. The event will bubble the same way if we're not using Angular. At some point, it will reach the document unless a handler along the way doesn't stop its propagation.</p><p>In contrast, if we have a custom <code class="literal">@Output</code>, the event will not bubble and instead of a DOM event, the value of the <code class="literal">$event</code> variable will be the value that we pass to the emit method of the output.</p></div><div class="section" title="Renaming the inputs and outputs"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec67"/>Renaming the inputs and outputs</h2></div></div></div><p>Now, we will explore how we can rename the directives' inputs and outputs. Let's suppose that we have the following definition of the <code class="literal">TodoList</code> component:</p><pre class="programlisting">class TodoList { &#13;
  ... &#13;
  @Output() toggle = new EventEmitter&lt;Todo&gt;();&#13;
 &#13;
  toggle(index: number) { &#13;
    ... &#13;
  } &#13;
} &#13;
</pre><p>The output of the component is called <code class="literal">toggle</code>; the method that handles changes in the checkboxes responsible for toggling completion of the individual to-do items is also called <code class="literal">toggle</code>. This code will not be compiled, as in the <code class="literal">TodoList</code> controller we have two identifiers named in the same way. We have two options here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can rename the method.</li><li class="listitem" style="list-style-type: disc">We can rename the property.</li></ul></div><p>If we rename the property, this will change the name of the component's output as well. So, the following line of code will no longer work:</p><pre class="programlisting">&lt;todo-list [toggle]="foobar($event)"...&gt;&lt;/todo-list&gt; &#13;
</pre><p>What we can do instead is rename the <code class="literal">toggle</code> property and explicitly set the name of the output using the <code class="literal">@Output</code> decorator:</p><pre class="programlisting">class TodoList { &#13;
  ... &#13;
  @Output('toggle') toggleEvent = new EventEmitter&lt;Todo&gt;();&#13;
 &#13;
  toggle(index: number) { &#13;
    ... &#13;
  } &#13;
} &#13;
</pre><p>This way, we will be able to trigger the <code class="literal">toggle</code> output using the <code class="literal">toggleEvent</code> property.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Note that such renames could be confusing and are not considered as best practices. For a complete set of best practices, visit <a class="ulink" href="https://angular.io/styleguide">
https://
angular.io/styleguide
</a>.</p></div></div><p>Similarly, we can rename the component's inputs using the following code snippet:</p><pre class="programlisting">class TodoList { &#13;
  @Input('todos') todoList: Todo[]; &#13;
  @Output('toggle') toggleEvent = new EventEmitter&lt;Todo&gt;();&#13;
 &#13;
  toggle(index: number) { &#13;
    ... &#13;
  } &#13;
} &#13;
</pre><p>Now, it doesn't matter that we renamed the input and output properties of <code class="literal">TodoList</code>; it still has the same public interface:</p><pre class="programlisting">&lt;todo-list [todos]="todos" &#13;
  (toggle)="toggleCompletion($event)"&gt; &#13;
&lt;/todo-list&gt; &#13;
</pre></div><div class="section" title="An alternative syntax to define inputs and outputs"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec68"/>An alternative syntax to define inputs and outputs</h2></div></div></div><p>The <code class="literal">@Input</code> and <code class="literal">@Output</code> decorators are syntax sugar for easier declaration of the directive's inputs and outputs. The original syntax for this purpose is as follows:</p><pre class="programlisting">@Directive({ &#13;
  outputs: ['outputName: outputAlias'], &#13;
  inputs: ['inputName: inputAlias'] &#13;
}) &#13;
class Dir { &#13;
  outputName = new EventEmitter(); &#13;
} &#13;
</pre><p>Using <code class="literal">@Input</code> and <code class="literal">@Output</code>, the preceding syntax is equivalent to this:</p><pre class="programlisting">@Directive(...) &#13;
class Dir { &#13;
  @Output('outputAlias') outputName = new EventEmitter&lt;any&gt;(); &#13;
  @Input('inputAlias') inputName: any;&#13;
} &#13;
</pre><p>Although both have the same semantics, according to the best practices, we should use the latter one, because it is easier to read and understand.</p></div></div>
<div class="section" title="Explaining Angular's content projection"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Explaining Angular's content projection</h1></div></div></div><p>Content projection is an important concept when developing user interfaces. It allows us to project pieces of content into different places of the user interface of our application. Web Components solve this problem with the <code class="literal">content</code> element. In AngularJS, it is implemented with the infamous transclusion.</p><p>Angular is inspired by modern Web standards, especially Web Components, which led to the adoption of some of the methods of content projection used there. In this section, we'll look at them in the context of Angular using the <code class="literal">ng-content</code> directive.</p><div class="section" title="Basic content projection in Angular"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec69"/>Basic content projection in Angular</h2></div></div></div><p>Let's suppose we're building a component called <code class="literal">fancy-button</code>. This component will use the standard HTML button element and add some extra behavior to it. Here is the definition of the <code class="literal">fancy-button</code> component:</p><pre class="programlisting">@Component({ &#13;
  selector: 'fancy-button', &#13;
  template: '&lt;button&gt;Click me&lt;/button&gt;' &#13;
}) &#13;
class FancyButton { ... } &#13;
</pre><p>Inside of the <code class="literal">@Component</code> decorator, we set the inline template of the component together with its selector. Now, we can use the component with the following markup:</p><pre class="programlisting">&lt;fancy-button&gt;&lt;/fancy-button&gt; &#13;
</pre><p>On the screen, we will see a standard HTML button that has a label with the content <span class="strong"><strong>Click me</strong></span>. This is not a very flexible way to define reusable UI components. Most likely, the users of the fancy button will need to change the content of the label to something, depending on their application.</p><p>In AngularJS, we were able to achieve this result with <code class="literal">ng-transclude</code>:</p><pre class="programlisting">// AngularJS example &#13;
app.directive('fancyButton', function () { &#13;
  return { &#13;
    restrict: 'E', &#13;
    transclude: true, &#13;
    template: '&lt;button&gt;&lt;ng-transclude&gt;&lt;/ng-transclude&gt;&lt;/button&gt;' &#13;
  }; &#13;
}); &#13;
</pre><p>In the new Angular, we have the <code class="literal">ng-content</code> element:</p><pre class="programlisting">// ch4/ts/ng-content/app.ts &#13;
@Component({ &#13;
  selector: 'fancy-button', &#13;
  template: '&lt;button&gt;&lt;ng-content&gt;&lt;/ng-content&gt;&lt;/button&gt;' &#13;
}) &#13;
class FancyButton { /* Extra behavior */ } &#13;
</pre><p>Now, we can pass custom content to the fancy button by executing this:</p><pre class="programlisting">&lt;fancy-button&gt;Click &lt;i&gt;me&lt;/i&gt; now!&lt;/fancy-button&gt; &#13;
</pre><p>As a result, the content between the opening and the closing <code class="literal">fancy-button</code> tags will be placed where the <code class="literal">ng-content</code> directive resides.</p></div><div class="section" title="Projecting multiple content chunks"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec70"/>Projecting multiple content chunks</h2></div></div></div><p>Another typical use case of content projection is when we pass content to a custom Angular component or AngularJS directive and we want different parts of this content to be projected to different locations in the template.</p><p>For instance, let's suppose we have a <code class="literal">panel</code> component that has a title and a body, and we can use it in the following way:</p><pre class="programlisting">&lt;panel&gt;&#13;
  &lt;section class="panel-title"&gt;Sample title&lt;/section&gt;&#13;
  &lt;section class="panel-content"&gt;Content&lt;/section&gt;&#13;
&lt;/panel&gt;&#13;
</pre><p>The template of our <code class="literal">panel</code> component looks like this:</p><pre class="programlisting">&lt;div class="panel"&gt; &#13;
  &lt;div class="panel-title"&gt; &#13;
    &lt;!-- Project the content of panel-title here --&gt; &#13;
  &lt;/div&gt; &#13;
  &lt;div class="panel-content"&gt; &#13;
    &lt;!-- Project the content of panel-content here --&gt; &#13;
  &lt;/div&gt; &#13;
&lt;/div&gt;` &#13;
</pre><p>In AngularJS 1.5, we are able to do this using multi-slot transclusion, which was implemented in order to allow us to have a smoother transition to Angular 2 and later versions. Let's take a look at how we can proceed in Angular in order to define such a <code class="literal">panel</code> component:</p><pre class="programlisting">// ch4/ts/ng-content/app.ts &#13;
@Component({ &#13;
  selector: 'panel', &#13;
  styles: [ ... ], &#13;
  template: ` &#13;
    &lt;div class="panel"&gt; &#13;
      &lt;div class="panel-title"&gt; &#13;
        &lt;ng-content select=".panel-title"&gt;&lt;/ng-content&gt; &#13;
      &lt;/div&gt; &#13;
      &lt;div class="panel-content"&gt; &#13;
        &lt;ng-content select=".panel-content"&gt;&lt;/ng-content&gt; &#13;
      &lt;/div&gt; &#13;
    &lt;/div&gt;` &#13;
}) &#13;
class Panel { } &#13;
</pre><p>We have already described the <code class="literal">selector</code> and <code class="literal">styles</code> properties, so let's take a look at the component's template. We have a <code class="literal">div</code> element with the <code class="literal">panel</code> class, which wraps the two nested <code class="literal">div</code> elements, respectively – one for the title of <code class="literal">panel</code> and one for the content of <code class="literal">panel</code>.</p><p>In order to project the content of the <code class="literal">section</code> element with class name <code class="literal">panel-title</code> to where the title should be, we will need to use the <code class="literal">ng-content</code> element. As its <code class="literal">selector</code> attribute, we will need to use a CSS selector, which matches the element whose content we want to project (in this case, the selector should be <code class="literal">.panel-title</code> or <code class="literal">section.panel-title</code>).</p><p>In case we set the value of the <code class="literal">selector</code> attribute to <code class="literal">.panel-title</code>, it will match all the elements with classes <code class="literal">.panel-title</code>  that reside inside the target <code class="literal">panel</code> element. After this, <code class="literal">ng-content</code> will grab their content and set them as its own content.</p></div><div class="section" title="Nesting components"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec71"/>Nesting components</h2></div></div></div><p>We've already built a few simple applications as a composition of components and directives. We saw that components are basically directives with views, so we can implement them by nesting or composing other directives and components. The following figure illustrates this with a structural diagram:</p><p>
</p><div class="mediaobject"><img alt="Nesting components" src="graphics/B06166_04_09.jpg"/></div><p>
</p><p>Figure 9</p><p>The composition could be achieved by nesting directives and components within the components' templates, taking advantage of the nested nature of the used markup. For instance, let's say we have a component with the <code class="literal">sample-component</code> selector, which has the following definition:</p><pre class="programlisting">@Component({ &#13;
  selector: 'sample-component', &#13;
  template: '&lt;view-child&gt;&lt;/view-child&gt;' &#13;
}) &#13;
class Sample {} &#13;
</pre><p>The template of the <code class="literal">Sample</code> component has a single-child element with the tag name <code class="literal">view-child</code>.</p><p>On the other hand, we can use the <code class="literal">Sample</code> component inside the template of another component, and since it can be used as an element, we can also nest other components or directives inside of it:</p><pre class="programlisting">&lt;sample-component&gt; &#13;
  &lt;content-child1&gt;&lt;/content-child1&gt; &#13;
  &lt;content-child2&gt;&lt;/content-child2&gt; &#13;
&lt;/sample-component&gt; &#13;
</pre><p>This way, the <code class="literal">sample-component</code> component has two different types of successors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Successors defined within its template.</li><li class="listitem" style="list-style-type: disc">Successors passed as nested elements between its opening and closing tags.</li></ul></div><p>In the context of Angular, the direct children elements defined within the component's template are called <span class="strong"><strong>view children</strong></span> and the ones nested between its opening and closing tags are called <span class="strong"><strong>content children</strong></span>.</p></div><div class="section" title="Using ViewChildren and ContentChildren"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec72"/>Using ViewChildren and ContentChildren</h2></div></div></div><p>Let's take a look at the implementation of the <code class="literal">Tabs</code> component, which uses the following structure:</p><pre class="programlisting">&lt;tabs (changed)="tabChanged($event)"&gt; &#13;
  &lt;tab-title&gt;Tab 1&lt;/tab-title&gt; &#13;
  &lt;tab-content&gt;Content 1&lt;/tab-content&gt; &#13;
  &lt;tab-title&gt;Tab 2&lt;/tab-title&gt; &#13;
  &lt;tab-content&gt;Content 2&lt;/tab-content&gt; &#13;
&lt;/tabs&gt; &#13;
</pre><p>The preceding structure is composed of three components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Tab</code> component</li><li class="listitem" style="list-style-type: disc"><code class="literal">TabTitle</code> component</li><li class="listitem" style="list-style-type: disc"><code class="literal">TabContent</code> component</li></ul></div><p>Let's take a look at the implementation of the <code class="literal">TabTitle</code> component:</p><pre class="programlisting">@Component({ &#13;
  selector: 'tab-title', &#13;
  styles: [...], &#13;
  template: ` &#13;
    &lt;div class="tab-title" (click)="handleClick()"&gt; &#13;
      &lt;ng-content&gt;&lt;/ng-content&gt; &#13;
    &lt;/div&gt; &#13;
  ` &#13;
}) &#13;
class TabTitle { &#13;
  @Output() tabSelected: EventEmitter&lt;TabTitle&gt; = &#13;
    new EventEmitter&lt;TabTitle&gt;();&#13;
 &#13;
  handleClick() { &#13;
    this.tabSelected.emit(this); &#13;
  } &#13;
} &#13;
</pre><p>There's nothing new in this implementation. We define a <code class="literal">TabTitle</code> component, which has a single property called <code class="literal">tabSelected</code>. It is of the type <code class="literal">EventEmitter</code> and will be triggered once the user clicks on the tab title.</p><p>Now, let's take a look at the <code class="literal">TabContent</code> component:</p><pre class="programlisting">@Component({ &#13;
  selector: 'tab-content', &#13;
  styles: [...], &#13;
  template: ` &#13;
    &lt;div class="tab-content" [hidden]="!isActive"&gt; &#13;
      &lt;ng-content&gt;&lt;/ng-content&gt; &#13;
    &lt;/div&gt; &#13;
  ` &#13;
}) &#13;
class TabContent { &#13;
  isActive: boolean = false; &#13;
} &#13;
</pre><p>This has an even simpler implementation – all we do is project the DOM passed to the <code class="literal">tab-content</code> element inside <code class="literal">ng-content</code> and hide it once the value of the <code class="literal">isActive</code> property becomes <code class="literal">false</code>.</p><p>The interesting part of the implementation is the <code class="literal">Tabs</code> component itself:</p><pre class="programlisting">// ch4/ts/basic-tab-content-children/app.ts &#13;
@Component({ &#13;
  selector: 'tabs', &#13;
  styles: [...], &#13;
  template: ` &#13;
    &lt;div class="tab"&gt; &#13;
      &lt;div class="tab-nav"&gt; &#13;
        &lt;ng-content select="tab-title"&gt;&lt;/ng-content&gt; &#13;
      &lt;/div&gt; &#13;
      &lt;ng-content select="tab-content"&gt;&lt;/ng-content&gt; &#13;
    &lt;/div&gt; &#13;
  ` &#13;
}) &#13;
class Tabs { &#13;
  @Output('changed') &#13;
  tabChanged: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;(); &#13;
 &#13;
  @ContentChildren(TabTitle) &#13;
  tabTitles: QueryList&lt;TabTitle&gt;; &#13;
 &#13;
  @ContentChildren(TabContent) &#13;
  tabContents: QueryList&lt;TabContent&gt;; &#13;
 &#13;
  active: number;&#13;
  select(index: number) {...} &#13;
  ngAfterViewInit() {...} &#13;
} &#13;
</pre><p>In this implementation, we have a decorator that we haven't used yet: the <code class="literal">@ContentChildren</code> decorator. The <code class="literal">@ContentChildren</code> property decorator fetches the content children of the given component. This means that we can get references to all <code class="literal">TabTitle</code> and <code class="literal">TabContent</code> instances from within the instance of the <code class="literal">Tabs</code> component and get them in the order in which they are declared in the markup. There's an alternative decorator called <code class="literal">@ViewChildren</code>, which fetches all the view children of the given element. Let's take a look at the difference between view children versus content children before we explain the implementation further.</p></div><div class="section" title="ViewChild versus ContentChild"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec73"/>ViewChild versus ContentChild</h2></div></div></div><p>Although both concepts sound similar, they have quite different semantics. In order to understand them better, let's take a look at the following example:</p><pre class="programlisting">// ch4/ts/view-child-content-child/app.ts &#13;
@Component({ &#13;
  selector: 'user-badge', &#13;
  template: '...' &#13;
}) &#13;
class UserBadge {} &#13;
 &#13;
@Component({ &#13;
  selector: 'user-rating', &#13;
  template: '...' &#13;
}) &#13;
class UserRating {} &#13;
</pre><p>Here, we've defined two components: <code class="literal">UserBadge</code> and <code class="literal">UserRating</code>. Let's define a parent component, which comprises both the components:</p><pre class="programlisting">@Component({ &#13;
  selector: 'user-panel', &#13;
  template: '&lt;user-badge&gt;&lt;/user-badge&gt;'&#13;
}) &#13;
class UserPanel {...} &#13;
</pre><p>Note that the template of the view of <code class="literal">UserPanel</code> contains only the <code class="literal">UserBadge</code> component's selector. Now, let's use the <code class="literal">UserPanel</code> component in our application:</p><pre class="programlisting">@Component({ &#13;
  selector: 'app', &#13;
  template: `&lt;user-panel&gt; &#13;
    &lt;user-rating&gt;&lt;/user-rating&gt; &#13;
  &lt;/user-panel&gt;`&#13;
}) &#13;
class App {} &#13;
</pre><p>The template of our main <code class="literal">App</code> component uses the <code class="literal">UserPanel</code> component and nests the <code class="literal">UserRating</code> component inside it. Now, let's suppose we want to get a reference to the instance of the <code class="literal">UserRating</code> component that is used inside the <code class="literal">user-panel</code> element in the <code class="literal">App</code>'s template and a reference to the <code class="literal">UserBadge</code> component, which is used inside the <code class="literal">UserPanel</code>'s template. In order to do this, we can add two more properties to the <code class="literal">UserPanel</code> controller and add the <code class="literal">@ContentChild</code> and <code class="literal">@ViewChild</code> decorators to them with the appropriate arguments:</p><pre class="programlisting">class UserPanel { &#13;
  @ViewChild(UserBadge) &#13;
  badge: UserBadge; &#13;
 &#13;
  @ContentChild(UserRating) &#13;
  rating: UserRating;&#13;
 &#13;
  constructor() { &#13;
    // &#13;
  } &#13;
} &#13;
</pre><p>The semantics of the <code class="literal">badge</code> property declaration is "get the instance of the first child component of the type <code class="literal">UserBadge</code>, which is used inside the <code class="literal">UserPanel</code> template". Accordingly, the semantics of the <code class="literal">rating</code> property's declaration is "get the instance of the first child component of the type <code class="literal">UserRating</code>, which is nested inside the <code class="literal">UserPanel</code> host element".</p><p>Now, if you run this code, you'll note that the values of the <code class="literal">badge</code> and <code class="literal">rating</code> properties are still equal to the <code class="literal">undefined</code> value inside the controller's constructor. This is because they are still not initialized in this phase of the component's life cycle. The life cycle hooks that we can use in order to get a reference to these child components are <code class="literal">ngAfterViewInit</code> and <code class="literal">ngAfterContentInit</code>. We can use these hooks simply by adding definitions of the <code class="literal">ngAfterViewInit</code> and <code class="literal">ngAfterContentInit</code> methods to the component's controller. We will make a complete overview of the life cycle hooks that Angular provides shortly.</p><p>To recap, we can say that the content children of the given components are the child elements that are nested within the component's host element. In contrast, the view children directives of the given component are the elements used within its template.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>In order to get a platform independent reference to a DOM element, again, we can use <code class="literal">@ContentChild</code> and <code class="literal">@ViewChild</code>. For instance, if we have the following template: <code class="literal">&lt;input #todo&gt;</code> we can get a reference to the <code class="literal">input</code> by using: <code class="literal">@ViewChild('todo')</code>.</p></div></div><p>Since we are already familiar with the core differences between view children and content children now, we can continue with our tabs implementation.</p><p>In the tabs component, instead of using the <code class="literal">@ContentChild</code> decorator, we use <code class="literal">@ContentChildren</code>. We do this because we have multiple content children and we want to get them all:</p><pre class="programlisting">@ContentChildren(TabTitle) &#13;
tabTitles: QueryList&lt;TabTitle&gt;; &#13;
 &#13;
@ContentChildren(TabContent) &#13;
tabContents: QueryList&lt;TabContent&gt;; &#13;
</pre><p>Another main difference that we will note is that the types of the <code class="literal">tabTitles</code> and <code class="literal">tabContents</code> properties are <code class="literal">QueryList</code> with their respective type parameter and not the component's type itself. We can think of the <code class="literal">QueryList</code> data structure as a JavaScript array – we can apply the same high-order functions (<code class="literal">map</code>, <code class="literal">filter</code>, <code class="literal">reduce</code>, and so on) over it and loop over its elements; however, <code class="literal">QueryList</code> is also observable, that is, we can observe it for changes.</p><p>As the final step of our <code class="literal">Tabs</code> definition, let's take a peek at the implementation of the <code class="literal">ngAfterContentInit</code> and <code class="literal">select</code> methods:</p><pre class="programlisting">ngAfterContentInit() { &#13;
  this.tabTitles &#13;
    .map(t =&gt; t.tabSelected) &#13;
    .forEach((t, i) =&gt; { &#13;
      t.subscribe(_ =&gt; { &#13;
        this.select(i) &#13;
      }); &#13;
    }); &#13;
  this.active = 0; &#13;
  this.select(0); &#13;
} &#13;
</pre><p>In the first line of the method's implementation, we loop all <code class="literal">tabTitles</code> and take the observable's references. These objects have a method called <code class="literal">subscribe</code>, which accepts a callback as an argument. Once the <code class="literal">.emit()</code> method of the <code class="literal">EventEmitter</code> instance (that is, the <code class="literal">tabSelected</code> property of any tab) is called, the callback passed to the <code class="literal">subscribe</code> method will be invoked.</p><p>Now, let's take a look at the <code class="literal">select</code> method's implementation:</p><pre class="programlisting">select(index: number) { &#13;
  let contents: TabContent[] = this.tabContents.toArray(); &#13;
  contents[this.active].isActive = false; &#13;
  this.active = index; &#13;
  contents[this.active].isActive = true; &#13;
  this.tabChanged.emit(index); &#13;
} &#13;
</pre><p>In the first line, since <code class="literal">tabContents</code> is of the type <code class="literal">QueryList&lt;TabContent&gt;</code>, we get its array representation. After that, we set the <code class="literal">isActive</code> flag of the current active tab to <code class="literal">false</code> and select the next active one. In the last line in the <code class="literal">select</code> method's implementation, we trigger the selected event of the <code class="literal">Tabs</code> component by invoking <code class="literal">this.tabChanged.emit</code> with the index of the currently selected tab.</p></div></div>
<div class="section" title="Hooking into the component's life cycle"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Hooking into the component's life cycle</h1></div></div></div><p>Components in Angular have a well-defined life cycle, which allows us to hook into different phases of it and have further control over our application. We can do this by implementing specific methods in the component's controller. In order to be more explicit, thanks to the expressiveness of TypeScript, we can implement different interfaces associated with the life cycle's phases. Each of these interfaces has a single method, which is associated with the phase itself.</p><p>Although code written with explicit interface implementation will have better semantics, since Angular supports ES5 as well, within the component we can simply define methods with the same names as the life cycle hooks (but this time, prefixed with <code class="literal">ng</code>) and take advantage of duck typing.</p><p>The following diagram shows all the phases we can hook into:</p><p>
</p><div class="mediaobject"><img alt="Hooking into the component's life cycle" src="graphics/B06166_04_10.jpg"/></div><p>
</p><p>Figure 10</p><p>Let's take a look at the different life cycle hooks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">OnChanges</code>: This hook will be invoked once a change in the input properties of a given component is detected. For instance, let's take a look at the following component:</li></ul></div><pre class="programlisting">      @Component({ &#13;
        selector: 'panel', &#13;
        inputs: ['title'] &#13;
      }) &#13;
      class Panel {...} &#13;
</pre><p>We can use it like this:</p><pre class="programlisting">&lt;panel [title]="expression"&gt;&lt;/panel&gt; &#13;
</pre><p>Once the value of the expression associated with the <code class="literal">[title]</code> attribute is changed, the <code class="literal">ngOnChanges</code> hook will be invoked. We can implement it using this code snippet:</p><pre class="programlisting">@Component(...) &#13;
class Panel { &#13;
  ngOnChanges(changes) { &#13;
    Object.keys(changes).forEach(prop =&gt; { &#13;
      console.log(prop, 'changed. Previous value', changes[prop].previousValue); &#13;
    }); &#13;
  } &#13;
} &#13;
</pre><p>The preceding snippet will display all the changed bindings and their old values. In order to be more explicit in the implementation of the hook, we can use interfaces:</p><pre class="programlisting">import {Component, OnChanges} from '@angular/core'; &#13;
@Component(...) &#13;
class Panel implements OnChanges { &#13;
  ngOnChanges(changes) {...} &#13;
} &#13;
</pre><p>All the interfaces representing the individual life cycle hooks declare a single method with the name of the interface itself prefixed with <code class="literal">ng</code>. In the upcoming list, we'll use the term life cycle hook, both for interface and/or the method, except if we won't imply anything specifically for only one of them.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">OnInit</code>: This hook will be invoked once the given component is initialized. We can implement it using the <code class="literal">OnInit</code> interface with its <code class="literal">ngOnInit</code> method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">DoCheck</code>: This will be invoked when the change detector of the given component is invoked. It allows us to implement our own change detection algorithm for the given component. Note that <code class="literal">DoCheck</code> and <code class="literal">OnChanges</code> should not be implemented together on the same directive.</li><li class="listitem" style="list-style-type: disc"><code class="literal">OnDestroy</code>: If we implement the <code class="literal">OnDestroy</code> interface with its <code class="literal">ngOnDestroy</code> method, we can hook into the destroy life cycle phase of a component. This method will be invoked once the component is detached from the component tree.</li></ul></div><p>Now, let's take a look at the life cycle hooks associated with the component's content and view children:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AfterContentInit</code>: If we implement the <code class="literal">ngAfterContentInit</code> life cycle hook, we will be notified when the component's content is fully initialized. This is the phase when the properties decorated with <code class="literal">ContentChild</code> or <code class="literal">ContentChildren</code> will be initialized.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AfterContentChecked</code>: By implementing this hook, we'll be notified each time the content of the given component has been checked by the change detection mechanism of Angular.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AfterViewInit</code>: If we implement this life cycle hook with its <code class="literal">ngAfterViewInit</code> method, we will be notified when the component's view is initialized. This is the phase when the properties decorated with <code class="literal">ViewChild</code> or <code class="literal">ViewChildren</code> will be initialized.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AfterViewChecked</code>: This is similar to <code class="literal">AfterContentChecked</code>. The <code class="literal">AfterViewChecked</code> hook will be invoked once the view of our component is checked.</li></ul></div><div class="section" title="Order of execution of the life cycle hooks"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec74"/>Order of execution of the life cycle hooks</h2></div></div></div><p>In order to trace the order of execution of the callbacks associated with each hook, let's take a peek at the <code class="literal">ch4/ts/life-cycle/app.ts</code> example:</p><pre class="programlisting">@Component({ &#13;
  selector: 'panel', &#13;
  template: '&lt;ng-content&gt;&lt;/ng-content&gt;' &#13;
}) &#13;
class Panel { &#13;
  @Input() title: string;&#13;
  @Input() caption: string;&#13;
  ngOnChanges(changes) {...} &#13;
  ngOnInit() {...} &#13;
  ngDoCheck() {...} &#13;
  ngOnDestroy() {...} &#13;
  ngAfterContentInit() {...} &#13;
  ngAfterContentChecked() {...} &#13;
  ngAfterViewInit() {...} &#13;
  ngAfterViewChecked() {...} &#13;
} &#13;
</pre><p>The <code class="literal">Panel</code> component implements all the hooks without explicitly implementing the interfaces associated with them.</p><p>We can use the component in the following template:</p><pre class="programlisting">&lt;button (click)="toggle()"&gt;Toggle&lt;/button&gt; &#13;
&lt;div *ngIf="counter % 2 == 0"&gt; &#13;
  &lt;panel caption="Sample caption" &gt;Hello world!&lt;/panel&gt; &#13;
&lt;/div&gt; &#13;
</pre><p>In the preceding example, we have a panel and a button. Upon each click of the button, the panel will be either removed or appended to the view by the <code class="literal">ngIf</code> directive.</p><p>During the application initialization, if the result of the <code class="literal">"counter % 2 == 0"</code> expression is evaluated to <code class="literal">true</code>, the <code class="literal">ngOnChanges</code> method will be invoked. This happens because the values of the title and caption properties will be set for the first time.</p><p>Right after this, the <code class="literal">ngOnInit</code> method will be called, since the component has been initialized. Once the component's initialization is completed, the change detection will be triggered, which will lead to the invocation of the <code class="literal">ngDoCheck</code> method that allows us to hook custom logic for detecting changes in the state.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Note that you are not supposed to implement both <code class="literal">ngDoCheck</code> and <code class="literal">ngOnChanges</code> methods for the same component, since <code class="literal">ngOnChanges</code> will keep being called when the internal change detector detects changes. The example here does this for learning purposes only.</p></div></div><p>After the <code class="literal">ngDoCheck</code> method, the change detector will perform a check on the component's content (<code class="literal">ngAfterContentInit</code> and <code class="literal">ngAfterContentChecked</code> will be invoked in this order). Right after this, the same will happen for the component's view (<code class="literal">ngAfterViewInit</code> followed by <code class="literal">ngAfterViewChecked</code>).</p><p>Once the expression of the <code class="literal">ngIf</code> directive is evaluated to <code class="literal">false</code>, the entire component will be detached from the view, which will lead to the invocation of the <code class="literal">ngOnDestroy</code> hook.</p><p>On the next click, if the value of the expression of <code class="literal">ngIf</code> is equal to <code class="literal">true</code>, the same sequence of calls of the life cycle hooks as the one during the initialization phase will be executed.</p></div></div>
<div class="section" title="Defining generic views with TemplateRef"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Defining generic views with TemplateRef</h1></div></div></div><p>We are already familiar with the concepts of inputs, content children, and view children, and we also know when we can get a reference to them in the component's life cycle. Now, we will combine them and introduce a new concept-<code class="literal">TemplateRef</code>.</p><p>Let's take a step back and take a look at the last to-do application we developed earlier in this chapter. In the following screenshot, you can see what its UI looks like:</p><p>
</p><div class="mediaobject"><img alt="Defining generic views with TemplateRef" src="graphics/11-1.jpg"/></div><p>
</p><p>Figure 11</p><p>If we take a look at its implementation in <code class="literal">ch4/ts/inputs-outputs/app.ts</code>, we'll see that the template used to render the individual to-do items is defined inside the template of the entire to-do application.</p><p>What if we want to use a different layout to render the to-do items? We can do this by creating another component called <code class="literal">Todo</code>, which encapsulates the responsibility of rendering them. Then, we can define separate <code class="literal">Todo</code> components for the different layouts we want to support. This way, we need to have <span class="emphasis"><em>n</em></span> different components for <span class="emphasis"><em>n</em></span> different layouts, even though we need to change only their templates.</p><p>Angular comes with a more elegant solution. Earlier in this chapter, we have already discussed the template element. We said that it allows us to define a chunk of HTML that will not be processed by the browser. Angular allows us to reference such template elements and use them by passing them as content children.</p><p>Here is how we can pass the custom layout to our refactored <code class="literal">TodoApp</code> component:</p><pre class="programlisting">// ch4/ts/template-ref/app.ts &#13;
&lt;todo-app&gt; &#13;
  &lt;template let-todo&gt; &#13;
    &lt;input type="checkbox" [checked]="todo.completed" &#13;
      (change)="todo.completed = !todo.completed;"&gt; &#13;
    &lt;span [class.completed]="todo.completed"&gt; &#13;
      {{todo.label}} &#13;
    &lt;/span&gt;&lt;br&gt; &#13;
  &lt;/template&gt; &#13;
&lt;/todo-app&gt; &#13;
</pre><p>In the template, we declare a variable called <code class="literal">todo</code>. Later in the template, we can use it to specify the way in which we want to visualize the content.</p><p>Now, let's take a look at how we can get a reference to this template in the controller of the <code class="literal">TodoApp</code> component:</p><pre class="programlisting">// ch4/ts/template-ref/app.ts &#13;
class TodoApp { &#13;
  @ContentChild(TemplateRef) itemsTemplate: TemplateRef; &#13;
  // ... &#13;
} &#13;
</pre><p>All we do here is define a property called <code class="literal">itemsTemplate</code> and decorate it with the <code class="literal">@ContentChild</code> decorator. During the component's life cycle (more accurately, in <code class="literal">ngAfterContentInit</code>), the value of <code class="literal">itemsTemplate</code> will be set to a reference of the template that we passed as the content of the <code class="literal">todo-app</code> element.</p><p>There is one more problem though – we need the template in the <code class="literal">TodoList</code> component, since that's the place where we render the individual to-do items. What we can do is define another input of the <code class="literal">TodoList</code> component and pass the template directly from <code class="literal">TodoApp</code>:</p><pre class="programlisting">// ch4/ts/template-ref/app.ts &#13;
class TodoList { &#13;
  @Input() todos: Todo[]; &#13;
  <span class="strong"><strong>@Input() itemsTemplate: TemplateRef;</strong></span> &#13;
  @Output() toggle = new EventEmitter&lt;Todo&gt;(); &#13;
} &#13;
</pre><p>We need to pass it as an input from the template of <code class="literal">TodoApp</code>:</p><pre class="programlisting">... &#13;
&lt;todo-list [todos]="todos" &#13;
  [itemsTemplate]="itemsTemplate"&gt; &#13;
&lt;/todo-list&gt; &#13;
</pre><p>The only thing left is to use this template reference in the template of the <code class="literal">TodoList</code> application:</p><pre class="programlisting">&lt;!-- ... --&gt; &#13;
&lt;template *ngFor="let todo of todos; template: itemsTemplate"&gt;&lt;/template&gt; &#13;
</pre><p>We have explained the extended syntax of the <code class="literal">ngForOf</code> directive in the previous sections of this chapter. The preceding snippet shows one more property of this directive that we can set: the <code class="literal">ngForTemplate</code> property. By default, the template of the <code class="literal">ngForOf</code> directive is the element it is used on. By specifying a template reference to the <code class="literal">ngForTemplate</code> property, we can use the passed <code class="literal">TemplateRef</code> instead.</p></div>
<div class="section" title="Understanding and enhancing the change detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Understanding and enhancing the change detection</h1></div></div></div><p>We have already briefly described the change detection mechanism of the framework. We said that compared to AngularJS, where it runs in the context of the "scope", in Angular 2 and later versions, it runs in the context of the individual components. Another concept we mentioned is the zones, which basically intercept all the asynchronous calls that we make using the browser APIs and provide execution context for the change detection mechanism of the framework. Zones fix the annoying problem that we have in AngularJS, where when we use APIs outside of Angular, we needed to explicitly invoke the <code class="literal">digest</code> loop.</p><p>In <a class="link" href="ch01.html" title="Chapter 1. Get Going with Angular">
Chapter 1</a>, <span class="emphasis"><em>Get Going with Angular</em></span> and <a class="link" href="ch02.html" title="Chapter 2. The Building Blocks of an Angular Application">Chapter 2</a>, <span class="emphasis"><em>The Building Blocks of an Angular Application</em></span>, we discussed that the code that performs change detection over our components is being generated, either runtime (<span class="strong"><strong>Just-in-Time</strong></span>) or as part of our build process (<span class="strong"><strong>Ahead-of-Time</strong></span>). AoT compilation works great for environments with strict <span class="strong"><strong>CSP</strong></span> (<span class="strong"><strong>Content-Security-Policy</strong></span>) because of the disabled dynamic evaluation of JavaScript; it also provides much better performance since Angular will not have to compile the components' templates. We will explain it in detail in <a class="link" href="ch08.html" title="Chapter 8. Tooling and Development Experience">Chapter 8</a>, <span class="emphasis"><em>Tooling and Development Experience</em></span>.</p><p>In this section, we'll explore another property of the <code class="literal">@Component</code> decorator's configuration object, which provides us further control over the change detection mechanism of the framework by changing its strategy. By explicitly setting the strategy, we are able to prevent the change detection mechanism from running over a component's subtrees, which in some cases can bring great performance benefits.</p><div class="section" title="The order of execution of the change detectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec75"/>The order of execution of the change detectors</h2></div></div></div><p>Now, let's briefly describe the order in which the change detectors are invoked in a given component tree.</p><p>For this purpose, we will use the last implementation of the to-do application we have, but this time, we'll extract the logic to render the individual to-do items into a separate component called TodoItem. In the following diagram, we can see the application's structure:</p><p>
</p><div class="mediaobject"><img alt="The order of execution of the change detectors" src="graphics/B06166_04_12.jpg"/></div><p>
</p><p>Figure 12</p><p>At the top level is the <span class="strong"><strong>TodoApp</strong></span> component, which has two children: <span class="strong"><strong>InputBox</strong></span> and <span class="strong"><strong>TodoList</strong></span>. The <span class="strong"><strong>TodoList</strong></span> component renders the individual to-do items using the <span class="strong"><strong>TodoItem</strong></span> components. The implementation details are not important for our purpose, so we will ignore them.</p><p>Now, we need to realize that there is an implicit dependency between the state of the parent component and its children. For instance, the state of the <span class="strong"><strong>TodoList</strong></span> component depends completely on the to-do items that are located at its parent: the <span class="strong"><strong>TodoApp</strong></span> component. There's a similar dependency between <span class="strong"><strong>TodoItem</strong></span> and <span class="strong"><strong>TodoList</strong></span> since the <span class="strong"><strong>TodoList</strong></span> component passes the individual to-do items to a separate instance of the <span class="strong"><strong>TodoItem</strong></span> component. This means that if the list of to-do items in <span class="strong"><strong>TodoList</strong></span> changes, this will automatically reflect some of the <span class="strong"><strong>TodoItem</strong></span> components:</p><p>
</p><div class="mediaobject"><img alt="The order of execution of the change detectors" src="graphics/B06166_04_13.jpg"/></div><p>
</p><p>Figure 13</p><p>Owing to our last observation, the order of execution of the change detectors attached to the individual components is like the one shown in the preceding figure. Once the change detection mechanism run, initially it will perform a check over the <span class="strong"><strong>TodoApp</strong></span> component. Right after this, the <span class="strong"><strong>InputBox</strong></span> component will be checked for changes, followed by the <span class="strong"><strong>TodoList</strong></span> component. In the end, Angular will invoke the change detector of the <span class="strong"><strong>TodoItem</strong></span> component.</p><p>You can trace the order of execution in the <code class="literal">ch4/ts/change_detection_strategy_order/app.ts</code> example, where each individual component logs a message once its <code class="literal">ngDoCheck</code> method is invoked.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Note that only the components have an instance of a change detector attached to them; directives use the change detector of their parent component.</p></div></div></div><div class="section" title="Understanding Angular's change detection strategies"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec76"/>Understanding Angular's change detection strategies</h2></div></div></div><p>The change detection strategies that Angular provides are <code class="literal">Default</code> and <code class="literal">OnPush</code>. We will describe how we can take advantage of <code class="literal">OnPush</code> in detail, since it is very powerful when working with immutable data.</p><p>Now, let's import the TypeScript enum, which can be used to configure the strategy used for the individual components:</p><pre class="programlisting">// ch4/ts/change_detection_strategy_broken/app.ts &#13;
&#13;
import {ChangeDetectionStrategy} from '@angular/core'; &#13;
</pre><p>Now, we can configure the <code class="literal">TodoList</code> component to use the <code class="literal">OnPush</code> strategy:</p><pre class="programlisting">@Component({ &#13;
  selector: 'todo-list', &#13;
  changeDetection: ChangeDetectionStrategy.OnPush, &#13;
  template: `...`, &#13;
  styles: [...] &#13;
}) &#13;
class TodoList { ... } &#13;
</pre><p>This way, the change detection will be skipped until the component doesn't receive inputs that have different values. Note that comparison uses equality check, which means that it'll compare primitive types by their value and objects by comparing their references. You can go to <code class="literal">http://localhost:5555/dist/dev/ch4/ts/change_detection_strategy_broken/</code> and see the inconsistent behavior of the <code class="literal">TodoList</code> component. When you add a new to-do item in the input and click on the <span class="strong"><strong>Add</strong></span> button, it won't immediately appear in the list.</p><p>By default, the change detection will always check for changes.</p></div><div class="section" title="Introducing immutable data structures and OnPush"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec77"/>Introducing immutable data structures and OnPush</h2></div></div></div><p>Now, we will describe the <code class="literal">OnPush</code> change detection strategy. It is extremely useful when the result that the given component produces depends only on its inputs. In such cases, we can pass an immutable data to its inputs in order to make sure that it will not be mutated by any component. This way, by having a component that depends only on its immutable inputs and doesn't produce any side effects, we can make sure that it produces different user interfaces only once it receives different inputs (that is, with different reference).</p><p>In this section, we will apply the <code class="literal">OnPush</code> strategy to the <code class="literal">TodoList</code> component. Since it depends only on its inputs (the <code class="literal">todos</code> input), we want to make sure that its change detection will be performed only once it receives a new reference of the <code class="literal">todos</code> collection.</p><p>The essence of an immutable data is that it cannot change. This means that once we create the <code class="literal">todos</code> collection, we cannot change it; instead, the <code class="literal">add</code> (or, in our case, <code class="literal">push</code>) method will return a new collection-a copy of the initial collection with the new item included.</p><p>This may seem like a huge overhead-to copy the entire collection on each change. In big applications, this may have a big performance impact. However, we don't need to copy the entire collection. There are libraries that implement the immutable data structure using smarter algorithms, for example, persistent data structures. Persistent data structures are out of the scope of the current content. Further information about them can be found in most computer science textbooks for advanced data structures. The good thing is that we don't have to understand their implementation in depth in order to use them. There is a library called <span class="emphasis"><em>Immutable.js</em></span> that implements a few commonly used immutable data structures. In our case, we will use the immutable list. Generally, the immutable list behaves just like a normal list, but on each operation that is supposed to mutate it, it returns a new immutable list.</p><p>This means that if we have a list called <code class="literal">foo</code>, which is immutable, and append a new item to the list, we will get a new reference:</p><pre class="programlisting">let foo = List.of(1, 2, 3); &#13;
let changed = foo.push(4); &#13;
foo === changed // false &#13;
console.log(foo.toJS()); // [ 1, 2, 3 ] &#13;
console.log(changed.toJS()); // [ 1, 2, 3, 4 ] &#13;
</pre><p>In order to take advantage of immutability, we will need to install Immutable.js using npm.</p><p>The library is already a part of the project that contains the code for the book. You can find a reference to Immutable.js in <code class="literal">package.json</code>, located in the root of the project. You can take a look at <code class="literal">ch4/ts/change_detection_strategy/app.ts</code> to see how we include the immutable collections in our TypeScript application.</p><p>Now, it's time to refactor our to-do application and make it use immutable data.</p></div><div class="section" title="Using immutable data in Angular"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec78"/>Using immutable data in Angular</h2></div></div></div><p>Let's take a look at how we currently keep the to-do items in the <code class="literal">TodoApp</code> component:</p><pre class="programlisting">class TodoApp { &#13;
  todos: Todo[] = [...]; &#13;
  ... &#13;
} &#13;
</pre><p>We use an array of <code class="literal">Todo</code> items. The JavaScript array is mutable, which means that if we pass it to a component that uses the <code class="literal">OnPush</code> strategy, it is not safe to skip the change detection in case we get the same input reference. For instance, we may have two components that use the same list of to-do items. Both components can modify the list since it is mutable. This will lead to an inconsistent state for any of the components in case their change detection is not performed. That's why we need to make sure that the list that holds the items is immutable. All we need to do in the <code class="literal">TodoApp</code> component in order to make sure that it holds its data in an immutable data structure is this:</p><pre class="programlisting">// ch4/ts/change_detection_strategy/app.ts &#13;
class TodoApp { &#13;
  todos: Immutable.fromJS([{ &#13;
    label: 'Buy milk', &#13;
    completed: false &#13;
  }, { &#13;
    label: 'Save the world', &#13;
    completed: false &#13;
  }]);&#13;
  ... &#13;
} &#13;
</pre><p>In this way, we construct the <code class="literal">todos</code> property as an immutable list, which contains immutable objects; all we need to do is to invoke the function <code class="literal">fromJS</code> exported by Immutable.js. It will recursively turn any JavaScript object into an immutable object.</p><p>Next, since the mutation operations of the immutable list return a new list, we need to make a slight modification in <code class="literal">addTodo</code> and <code class="literal">toggleTodoCompletion</code>:</p><pre class="programlisting">... &#13;
addTodo(label: string) { &#13;
  this.todos = this.todos.push(Immutable.fromJS({ &#13;
    label, &#13;
    completed: false &#13;
  })); &#13;
}&#13;
&#13;
toggleCompletion(index: number) { &#13;
  this.todos = this.todos.update(index, todo =&gt; { &#13;
    return Immutable.fromJS({ &#13;
      label: todo.label, &#13;
      completed: !todo.completed &#13;
    });&#13;
  }); &#13;
} &#13;
... &#13;
</pre><p>The <code class="literal">addTodo</code> function looks exactly the same as before, except that we set the result of the <code class="literal">push</code> method as a value to the <code class="literal">todos</code> property.</p><p>In <code class="literal">toggleTodoCompletion</code>, we use the <code class="literal">update</code> method of the immutable list. As the first argument, we pass the index of the to-do item we want to modify, and the second argument is a callback that does the actual modification. Note that since we use immutable data in this case, we copy the modified to-do item. This is required because it tells the <code class="literal">update</code> method that the item with the given index has been changed (since it is immutable, it is considered as changed only when it has a new reference), which means that the entire list has been changed.</p><p>That was the complex part! Now, let's take a look at the <code class="literal">TodoList</code> component's definition:</p><pre class="programlisting">@Component({ &#13;
  selector: 'todo-list', &#13;
  changeDetection: ChangeDetectionStrategy.OnPush, &#13;
  template: `...`, &#13;
  styles: [...] &#13;
}) &#13;
class TodoList { &#13;
  @Input() todos: ImmutableList&lt;Todo&gt;; &#13;
  @Output() toggle = new EventEmitter&lt;number&gt;();&#13;
 &#13;
  toggleCompletion(index: number) { &#13;
    this.toggle.emit(index); &#13;
  } &#13;
} &#13;
</pre><p>Finally, we need to modify the way we access the properties of the immutable to-do items inside the templates:</p><pre class="programlisting">&lt;ul&gt;&#13;
  &lt;li *ngFor="let todo of todos; let index = index"&#13;
      [class.completed]="todo.get('completed')"&gt;&#13;
     &lt;input type="checkbox" [checked]="todo.get('completed')"&#13;
       (change)="toggleCompletion(index)"&gt;&#13;
    {{todo.get('label')}}&#13;
  &lt;/li&gt;&#13;
&lt;/ul&gt;</pre><p>The change we made here is that instead of using direct property access, such as <code class="literal">todo.completed</code>, we invoke the object's <code class="literal">get</code> method by passing the property the value we want to get as a string, in this case <code class="literal">"completed"</code>.</p><p>Inside the <code class="literal">@Component</code> decorator, we set the <code class="literal">changeDetection</code> property to the value of the <code class="literal">OnPush</code> strategy. This means that the component will run its change detector only when any of its inputs gets a new reference. Everything else, except the property access, inside of the template of the component stays exactly the same since <code class="literal">ngForOf</code> internally uses ES2015 iterators to loop over the items in the provided collection. They are supported by Immutable.js, so no changes in the template are required.</p><p>Since we need the index of the changed item instead of its reference (the one we use in the <code class="literal">update</code> method of the <code class="literal">todos</code> collection in <code class="literal">TodoApp</code>), we change the type of the output of the component to <code class="literal">EventEmitter&lt;number&gt;</code>. In <code class="literal">toggleCompletion</code>, we emit the index of the changed to-do item.</p><p>This is how we optimized our simple to-do application by preventing the change detection mechanism from running in the entire right subtree, in case the parent component hasn't pushed an input with a new reference.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Summary</h1></div></div></div><p>In this chapter, we went through the core building blocks of an Angular application: directives and components. We built a couple of sample components, which showed us the syntax to be used for the definition of these fundamental concepts. We also described the life cycle of each directive and the core set of features the given directive and component have. As the next step, we saw how we can enhance the performance of our application using the <code class="literal">OnPush</code> change detection strategy with an immutable data.</p><p>The next chapter is completely dedicated to the Angular services and the dependency injection mechanism of the framework. We will take a look at how we can define and instantiate custom injectors and how we can take advantage of the dependency injection mechanism in our directives and components.</p></div></body></html>