<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Building Blocks of an Angular Application</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we looked at the drivers for the design decisions behind Angular. We described the main reasons that led to the development of a brand new framework; Angular takes advantage of the newest web standards while keeping the past lessons in mind. Although we are familiar with the main drivers, we still haven't described the core concepts of the new framework. Angular took a different path from AngularJS and introduced a lot of changes in the fundamental building blocks used for the development of single-page applications.</p>
<p>The mission of this chapter is to describe the core of the framework and make a brief introduction to its main concepts. In the next couple of pages, we will also make an overview of how these concepts can be put together to help us build professional user interfaces for our web applications. The subsequent sections will give us an overview of everything that we will learn in more detail later in this book.</p>
<p>In this chapter, we will take a look at the following topics:</p>
<ul>
<li>A conceptual overview of the framework, showing how different concepts relate to each other.</li>
<li>Building a user interface as a composition of components.</li>
<li>What path the directives took in Angular, and how their interface changed compared to AngularJS.</li>
<li>The reasons for the enforced separation of concerns that led to the decomposition of the directives into two different concepts. In order to get a better sense of them, we will demonstrate the basic syntax for their definition.</li>
<li>An overview of the improved change detection, and how it involves the context that directives provide.</li>
<li>What zones are, and how they can make our daily development process easier.</li>
<li>What pipes are, and how they are related to the AngularJS filters.</li>
<li>Introduction to the brand new <strong>Dependency Injection</strong> (<strong>DI</strong>) mechanism in Angular and how it is related to the services.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A conceptual overview of Angular</h1>
                </header>
            
            <article>
                
<p>Before we dive into the different parts of Angular, let's get a conceptual overview of how everything fits together. Let's take a look at the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="201" width="125" src="assets/b74832ba-467d-4396-a393-72fdbc2722e1.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Figure 1</div>
<p><em>Figure 1</em> to <em>Figure 4</em> show the main Angular concepts and the connections between them. The main purpose of these diagrams is to illustrate the core blocks for building single-page applications with Angular, and their relations.</p>
<p><kbd>Component</kbd> is the main building block we will use to create the user interface of our applications with Angular. The Component block is a direct successor of directive, which is the primitive for attaching behavior to the DOM. Components extend directives by providing further features, such as a template, which can be used to render composition of directives. Inside the template, different expressions can reside:</p>
<div class="CDPAlignCenter CDPAlign"><img height="151" width="256" src="assets/b329a433-4d2b-44b5-9443-2b838f300cd4.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 2</div>
<p>The preceding diagram conceptually illustrates the <strong>Change Detection</strong> mechanism of Angular. It performs dirty checking, which evaluates the registered expressions in the context of specific UI components. Since the concept of scope has been removed from Angular, the execution context of the expressions are the instances of the controllers of the components associated with them.</p>
<p>The <strong>Change Detection</strong> mechanism can be enhanced using <strong>Differs</strong>; this is why there 's a direct relation between these two elements in the diagram.</p>
<p><strong>Pipes</strong> are another component of Angular. We can think of Pipes as the filters from AngularJS. Pipes can be used together with components. We can include them in the expressions that are defined in the context of any component.</p>
<p>Now, let's take a look at the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="233" width="389" src="assets/5983c214-5478-452c-a12c-81b7e9812fc7.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Figure 3</div>
<p>Directives and components delegate the business logic to Services. This enforces better separation of concerns, maintainability, and code reusability. Directives receive references to instances of specific services declared as dependencies using the <strong>DI</strong> mechanism of the framework and delegate the execution of the business-related logic to them. Both directives and components may use the <strong>DI</strong> mechanism not only to inject services but also to inject the DOM elements and/or other components or directives. Keep in mind that components extend directives, so the template of components is formed as composition of both components and directives.</p>
<p><strong>Modules</strong> (also known as <strong>NgModules</strong>) are a core concept that combines the building blocks into separate, logically related groups. NgModules are quite similar to the AngularJS modules, but bring more semantics on top. Note that NgModules are different from the ES2015 modules that we described in <a href="c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml">Chapter 4</a>, <em>TypeScript Crash Course</em>. The Angular modules are a framework feature, in contrast to the ES2015 modules, which are a language construct.</p>
<p>NgModules have the following responsibilities:</p>
<ul>
<li>Providing the context of the Angular template compiler</li>
<li>Providing a level of encapsulation where we can have components or directives, which are used only within the boundaries of a given module</li>
<li>In NgModules, we can configure the providers for the DI mechanism of the framework:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="165" width="283" src="assets/a73e7650-28b8-43f2-bf67-a80e9be36a78.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Figure 4</div>
<p>Lastly, the new router is used to define the routes in our application. Since directives do not own a template, only the components can be rendered by the router, representing the different views in our application. The router also uses a set of predefined directives, which allow us to define hyperlinks between the different views and the container where they should be rendered.</p>
<p>Now, we will look more closely at these concepts, and see how they work together to make Angular applications and how they've changed from their AngularJS predecessors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing directives</h1>
                </header>
            
            <article>
                
<p>AngularJS introduced the concept of directives in the development of single-page applications. The purpose of directives is to encapsulate the DOM-related logic and allow us to build user interfaces by composing them. This way, we are able to extend the syntax and the semantics of HTML. Initially, like most innovative concepts, directives were viewed controversially because they predispose us to write invalid HTML when using custom elements or attributes without the <kbd>data-</kbd> prefix. However, over time, this concept has gradually been accepted and has proved that it is here to stay.</p>
<p>Another drawback of the implementation of directives in AngularJS is the different ways that we can use them. This requires an understanding of the attribute values, which can be literals, expressions, callbacks, or microsyntax. This makes tooling essentially impossible.</p>
<p>Angular keeps the concept of directives, but takes the best parts from AngularJS and adds some new ideas and syntax to it. The main purpose of Angular's directives is to attach behavior to the DOM by extending it with the custom logic defined in an ES2015 class. We can think of these classes as controllers associated to the directives and think of their constructors as similar to the linking function of the directives from AngularJS. However, the new directives have limited configurability. They do not allow the association of a template with them, which makes most of the already known properties for defining directives unnecessary. The simplicity of the API does not limit the directives behavior, but only enforces stronger separation of concerns. To complement this simpler API, Angular introduced a richer interface for the definition of UI elements, called components. Components extend the functionality of directives by allowing them to own a template, through the <strong>component metadata</strong>. We will take a further look at components later in this book.</p>
<p>The syntax used for Angular directives involves ES2016 decorators; keep in mind that <strong>TypeScript is a superset of ES2016</strong>, so it has decorators as well. Here's a snippet which defines a simple directive:</p>
<pre>@Directive({ selector: '[tooltip]' })
export class Tooltip { 
  @Input() tooltip: string; 
  private overlay: Overlay;
 
  constructor(private el: ElementRef, manager: OverlayManager) { 
    this.overlay = manager.get(); 
  }
 
  @HostListener('mouseenter') onMouseEnter() { 
    this.overlay.open(this.el.nativeElement, this.tooltip); 
  }
 
  @HostListener('mouseleave') onMouseLeave() { 
    this.overlay.close(); 
  } 
} </pre>
<p>The directive can be used with the following markup in our template:</p>
<pre>&lt;div tooltip="42"&gt;Tell me the answer!&lt;/div&gt; </pre>
<p>Once the user points over the <kbd>Tell me the answer!</kbd> label, Angular will invoke the method defined under the <kbd>@HostListener</kbd> decorator in the definition of the directive. In the end, the <kbd>open</kbd> method of the overlay manager will be executed.</p>
<div class="packt_infobox">Since we can have multiple directives on a single element, the best practices state that we should use an attribute as a selector.</div>
<p>We can summarize that Angular kept the concept of directives by maintaining the idea of attaching a behavior to the DOM. The core differences with AngularJS are the new syntax, and the further separation of concerns introduced by bringing the components. In <a href="7bc2aa38-2853-468a-8e03-c25387eb03aa.xhtml"/><a href="1b60c28e-5f34-493d-8371-c69968f09020.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Getting Started with Angular Components and Directives</em>, we will take a further look at directives API. Now, let's take a look at the big change to Angular components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting to know Angular components</h1>
                </header>
            
            <article>
                
<p><strong>Model-View-Controller</strong> (<strong>MVC</strong>) is a micro-architectural pattern initially introduced for the implementation of user interfaces. As Angular developers, we use different variations of this pattern on a daily basis, most often, <strong>Model-View-ViewModel</strong> (<strong>MVVM</strong>). In MVC, we have the model, which encapsulates the business logic of our application, and the view, which is responsible for rendering the user interface, accepting user input, and delegating the user interaction logic to the controller. The view is represented as composition of components, which is formally known as the <strong>composite design pattern</strong>.</p>
<p>Let's take a look at the following structural diagram, which shows the composite design pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="272" width="634" src="assets/02a6bb04-ce29-4f38-aea4-963dd3509dbb.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Figure 5</div>
<p>Here, we have three classes:</p>
<ul>
<li>An abstract class called <kbd>Component</kbd>.</li>
<li>Two concrete classes called <kbd>Leaf</kbd> and <kbd>Composite</kbd>. The <kbd>Leaf</kbd> class is a simple terminal component in the component tree that we will build soon.</li>
</ul>
<p>The <kbd>Component</kbd> class defines an abstract operation called <kbd>operation</kbd>. Both <kbd>Leaf</kbd> and <kbd>Composite</kbd> inherit from the <kbd>Component</kbd> class, however, the <kbd>Composite</kbd> class also owns references to it. We can take this even further and allow <kbd>Composite</kbd> to own a list of references to instances of <kbd>Component</kbd>, as shown in the diagram. The components list inside <kbd>Composite</kbd> can hold references to different <kbd>Composite</kbd> or <kbd>Leaf</kbd> instances, or instances of other classes, which extend the <kbd>Component</kbd> class or any of its successors. We can have a different behavior of the <kbd>operation</kbd> methods of the individual <kbd>Component</kbd> instances invoked within the implementation of the <kbd>operation</kbd> method of <kbd>Composite</kbd>. This is because of the late-binding mechanism used for the implementation of polymorphism in object-oriented programming languages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Components in action</h1>
                </header>
            
            <article>
                
<p>Enough of theory! Let's build a component tree based on the class hierarchy illustrated in the preceding diagram. This way, we will demonstrate how we can take advantage of the composite pattern for building a user interface using simplified syntax. We will take a look at a similar example in the context of Angular in <a href="7bc2aa38-2853-468a-8e03-c25387eb03aa.xhtml"/><a href="1b60c28e-5f34-493d-8371-c69968f09020.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Getting Started with Angular Components and Directives</em>:</p>
<pre>Composite c1 = new Composite(); 
Composite c2 = new Composite(); 
Composite c3 = new Composite(); 
 
c1.components.push(c2); 
c1.components.push(c3); 
 
Leaf l1 = new Leaf(); 
Leaf l2 = new Leaf(); 
Leaf l3 = new Leaf(); 
 
c2.components.push(l1); 
c2.components.push(l2);  
c3.components.push(l3); </pre>
<p>The preceding pseudocode creates three instances of the <kbd>Composite</kbd> class and three instances of the <kbd>Leaf</kbd> class. The <kbd>c1</kbd> instance holds references to <kbd>c2</kbd> and <kbd>c3</kbd> inside the <kbd>components</kbd> list. The <kbd>c2</kbd> instance holds references to <kbd>l1</kbd> and <kbd>l2</kbd>, and <kbd>c3</kbd> holds reference to <kbd>l3</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="165" width="186" src="assets/d2630023-6b07-402b-abbd-6b2d2b787a3d.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Figure 6</div>
<p>The preceding diagram is a graphical representation of the component tree we built in the snippet. This is a simplified version of what the view in the modern JavaScript frameworks looks like. However, it illustrates the very basics of how we can compose directives and <kbd>components</kbd>. For instance, in the context of Angular, we can think of directives as instances of the <kbd>Leaf</kbd> class (since they don't own view and, thus, cannot compose other directives and <kbd>components</kbd>) and <kbd>components</kbd> as instances of the <kbd>Composite</kbd> class.</p>
<p>If we think more abstractly for the user interface in AngularJS, we can notice that we used quite a similar approach. The templates of our views compose different directives together in order to deliver a fully functional user interface to the end user of our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Components in Angular</h1>
                </header>
            
            <article>
                
<p>Angular took this approach by introducing new building blocks called components. Components extend the directive concept we described in the previous section and provide a broader functionality. Here is the definition of a basic <kbd>Hello world</kbd> component:</p>
<pre>@Component({ 
  selector: 'hello-world', 
  template: '&lt;h1&gt;Hello, {{target}}!&lt;/h1&gt;' 
}) 
class HelloWorld { 
  target: string; 
  constructor() { 
    this.target = 'world'; 
  } 
} </pre>
<p>We can use it by inserting the following markup in our view:</p>
<pre>&lt;hello-world&gt;&lt;/hello-world&gt; </pre>
<div class="packt_infobox">According to the best practices, we should use a selector of type element for components since we may have only a single component per DOM element.</div>
<p>We will take a look at the preceding syntax in more detail later in this book. Now let's briefly describe the functionality that this component provides. Once the Angular application is bootstrapped, it will look at all the elements in the DOM tree and process them. When it finds an element called <kbd>hello-world</kbd>, it will invoke the logic associated with its definition, which means that the template of the component will be rendered and the expression between the curly brackets will be evaluated. This will result in the <kbd>&lt;h1&gt;Hello, world!&lt;/h1&gt;</kbd> markup.</p>
<p>So, to summarize, the Angular core team separated out the directives from AngularJS into two different parts: components and directives. Directives provide an easy way to attach behavior to the DOM elements without defining a view. Components in Angular provide a powerful, and yet simple-to-learn API, which makes it easier to define the user interface of our applications. Angular components allow us to do the same amazing things as AngularJS directives, but with less typing and fewer things to learn. Components extend the Angular directive concept by adding a view to it. We can think of the relation between Angular components and directives the same way as the relation between <kbd>Composite</kbd> and <kbd>Leaf</kbd> from the diagram we saw in <em>Figure 5</em>.</p>
<p>Conceptually, we can present the relation between directives and Components as inheritance. <a href="1b60c28e-5f34-493d-8371-c69968f09020.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Getting Started with Angular Components and Directives</em>, describes these two concepts in further detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular modules</h1>
                </header>
            
            <article>
                
<p>In AngularJS, we have the concept of modules. Modules there are responsible for grouping pieces of related functionality together and registering it internally during the bootstrap process. Unfortunately, they didn't provide features such as encapsulation and lazy loading.</p>
<p>Angular introduced the NgModules as part of the fifth release candidate of the framework. The main purpose of the new modules is to give a context for the Angular compiler and achieve a good level of encapsulation. For instance, if we are building a library with NgModules, we can have a number of declarations, which are used internally but not exported as part of the public interface. Let's take a look at the following example:</p>
<pre>import {NgModule} from '@angular/core';
import {CommonModule} from '@angular/common';
import {Tab<span>Component</span>} from './tab.component';
import {TabItem<span>Component</span>} from './tab-item.component';

@NgModule({
  imports: [CommonModule],
  declarations: [Tab<span>Component</span>, TabItem<span>Component</span>],
  exports: [TabComponent]
})
class TabModule { }</pre>
<p>Do not worry if you're not familiar with the TypeScript syntax in the preceding example; we will take a deep dive into the language in the next chapter.</p>
<p>In the preceding code snippet, using the <kbd>@NgModule</kbd> decorator, we declare <kbd>TabModule</kbd>. Note that in the list of <kbd>declarations</kbd>, we include both <kbd>TabComponent</kbd> and <kbd>TabItemComponent</kbd>, but in the list of <kbd>exports</kbd>, we have only <kbd>TabComponent</kbd>. This way, we can achieve a level of encapsulation for our library. The users of the module will be able to use only <kbd>TabComponent</kbd>, so we don't have to worry about backward compatibility of the API of <kbd>TabItemComponent</kbd> since it's accessible only internally, within the boundaries of our module. Finally, by setting the <kbd>imports</kbd> property of the object literal passed to <kbd>@NgModule</kbd>, we can list modules that we want to use inside of the current module. This way, we will be able to take advantage of all the <kbd>exports</kbd> and providers (we'll discuss providers in <a href=""/><a href="3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml">Chapter 6</a>, <em>Dependency Injection in Angular</em>) declared by them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bootstrapping an Angular application</h1>
                </header>
            
            <article>
                
<p>Similar to AngularJS, before our application gets rendered, it goes through the bootstrap process. In Angular, we can bootstrap an application in different ways, depending on the used platform (for instance, web, NativeScript, and with JIT or AOT compilation enabled). Let's take a look at a simple example, of how we can bootstrap a web app, in order to get a better understanding of how the Angular modules can be used in the process:</p>
<pre>import {NgModule} from '@angular/core';
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';
import {BrowserModule} from '@angular/platform-browser';

import {AppComponent} from './app.component';

@NgModule({
  imports: [BrowserModule],
  bootstrap: [AppComponent],
  declarations: [AppComponent],
})
export class AppModule {}

platformBrowserDynamic().bootstrapModule(AppModule);</pre>
<p>With the <kbd>@NgModule</kbd> decorator in the preceding example, we declare <kbd>AppModule</kbd> and we also import <kbd>BrowserModule</kbd>. Note that this time, we provide a value to the <kbd>bootstrap</kbd> property, where we explicitly declare that we want <kbd>AppComponent</kbd> to be used for bootstrapping our application.</p>
<p>On the last line of the file, we invoke the <kbd>bootstrapModule</kbd> method of the object returned by the invocation of <kbd>platformBrowserDynamic</kbd> with the <kbd>AppModule</kbd> argument.</p>
<p>In recap, the modules in Angular have an important role: they not only group the building blocks of our application logically but also provide a way we can achieve encapsulation. Last, but not least, NgModules are heavily used in the bootstrap process of the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pipes</h1>
                </header>
            
            <article>
                
<p>In business applications, we often need to have different visual representations of the same piece of data. For example, if we have the number 100,000 and we want to format it as currency, most likely we won't want to display it as plain data; more likely, we'll want something like $100,000.</p>
<p>The responsibility for formatting data in AngularJS was assigned to filters. Another example for a data formatting requirement is when we use collections of items. For instance, if we have a list of items, we may want to filter it based on a predicate (a Boolean function); in a list of numbers, we may want to display only the prime numbers. AngularJS has a filter called filter, which allows us to do this. However, the duplication of the names often leads to confusion. This is one of the reasons the core team renamed the filter component to <strong>pipe</strong>. Also, the word <em>filter</em> predisposes us to think that filters are only responsible for filtering data, when they have the much more generic responsibility of formatting data.</p>
<p>The motivation behind the new name is the syntax used for pipes and filters:</p>
<pre>{{expression | decimal | currency}} </pre>
<p>In the preceding example, we apply the <kbd>decimal</kbd> and <kbd>currency</kbd> pipes to the value returned by <kbd>expression</kbd>. The entire expression between the curly braces looks like the Unix pipe syntax.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining pipes</h1>
                </header>
            
            <article>
                
<p>The syntax for defining pipes is similar to the one used for the definition of modules, directives, and components. In order to create a new pipe, we can use the ES2015 decorator, <kbd>@Pipe</kbd>. It allows us to add metadata to a class, declaring it as a pipe. All we need to do is provide a name for the pipe and define the data formatting logic.</p>
<p>During runtime, once the Angular expression interpreter finds out that a given expression includes a call of a pipe, it will retrieve it out of the pipe's collection allocated within the component and invoke it with appropriate arguments.</p>
<p>The following example illustrates how we can define a simple pipe called <kbd>lowercase1</kbd>, which transforms the given string, passed as argument to its lowercase representation:</p>
<pre>@Pipe({ name: 'lowercase1' }) 
class LowerCasePipe1 implements PipeTransform { 
  transform(value: string): string { 
    if (!value) return value; 
    if (typeof value !== 'string') { 
      throw new Error('Invalid pipe value', value); 
    } 
    return value.toLowerCase(); 
  } 
} </pre>
<p>Using the TypeScript syntax, we implement the <kbd>PipeTransform</kbd> interface and define the <kbd>transform</kbd> method declared inside it. We will explain the TypeScript interfaces in the next chapter.</p>
<p>Now, let's demonstrate how we can use the <kbd>lowercase1</kbd> pipe inside a component:</p>
<pre>@Component({ 
  selector: 'app', 
  template: '&lt;h1&gt;{{"SAMPLE" | lowercase1}}&lt;/h1&gt;' 
}) 
class App {} 

@NgModule({
  declarations: [App, LowerCasePipe1],
  bootstrap: [App],
  imports: [BrowserModule]
})
class AppModule {}

platformBrowserDynamic().bootstrapModule(AppModule);</pre>
<p>We can use the <kbd>App</kbd> component with the following markup:</p>
<pre>&lt;app&gt;&lt;/app&gt; </pre>
<p>The result we will see on the screen is the <kbd>sample</kbd> text within an <kbd>h1</kbd> element. Note that we're including a reference to <kbd>LowerCasePipe1</kbd> in the <kbd>declarations</kbd> property of the <kbd>@NgModule</kbd> decorator.</p>
<p>By keeping the data formatting logic as a separate component, Angular keeps the strong separation of concerns that can be seen throughout. We will take a look at how we can define stateful and stateless pipes for our application in <a href="503e1c1c-afb1-4dd4-98e2-657ceb32cc59.xhtml"><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Explaining Pipes and Communicating with RESTful Services</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving change detection</h1>
                </header>
            
            <article>
                
<p>As we saw earlier, the view in MVC updates itself, based on change events it receives from the model. A number of <strong>Model-View-Whatever</strong> (<strong>MVW</strong>) frameworks took this approach and embedded the observer pattern in the core of their change detection mechanism.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Classical change detection</h1>
                </header>
            
            <article>
                
<p>Let's take a look at a simple example, which doesn't use any framework. Suppose, we have a model called <kbd>User</kbd>, which has a property called <kbd>name</kbd>:</p>
<pre>class User extends EventEmitter { 
  private name: string;
 
  setName(name: string) { 
    this.name = name; 
    this.emit('change');
  }
 
  getName(): string { 
    return this.name;
  } 
} </pre>
<p>The preceding snippet again uses TypeScript. Do not worry if the syntax does not look familiar to you, we will make an introduction to the language in the next chapter.</p>
<p>The <kbd>user</kbd> class extends the <kbd>EventEmitter</kbd> class. This provides primitives for emitting and subscribing to events.</p>
<p>Now, let's define a view, which displays <kbd>name</kbd> of an instance of the <kbd>User</kbd> class, passed as an argument to its <kbd>constructor</kbd>:</p>
<pre>class View { 
  constructor(user: User, el: Element /* a DOM element */) { 
    el.innerHTML = user.getName();
  } 
} </pre>
<p>We can initialize the <kbd>view</kbd> element as shown here:</p>
<pre>let user = new User(); 
user.setName('foo'); 
let view = new View(user, document.getElementById('label')); </pre>
<p>As the end result, the user will see a label with the content <kbd>foo</kbd>. However, changes in <kbd>user</kbd> will not be reflected by the view. In order to update the view when the <kbd>name</kbd> of the user changes, we need to subscribe to the <kbd>change</kbd> event and then update the content of the DOM element. We need to update the <kbd>View</kbd> definition in the following way:</p>
<pre>class View { 
  constructor(user:User, el:any /* a DOM element */) { 
    el.innerHTML = user.getName(); 
    user.on('change', () =&gt; { 
      el.innerHTML = user.getName();
    }); 
  } 
} </pre>
<p>This is how most frameworks used to implement their change detection before the era of AngularJS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Change detection in AngularJS</h1>
                </header>
            
            <article>
                
<p>Most beginners are fascinated by the data binding mechanism in AngularJS. The basic <kbd>Hello world!</kbd> example looks similar to this:</p>
<pre>function MainCtrl($scope) { 
  $scope.label = 'Hello world!'; 
}</pre>
<pre>&lt;body ng-app ng-controller="MainCtrl"&gt; 
  {{label}} 
&lt;/body&gt; </pre>
<p>If you run this, <kbd>Hello world!</kbd> magically appears on the screen. However, that is not the only most impressive thing! If we add a text input and we bind it to the <kbd>label</kbd> property of the scope, each change will reflect in the content displayed by the interpolation directive:</p>
<pre>&lt;body ng-controller="MainCtrl"&gt; 
  &lt;input ng-model="label"&gt; 
  {{label}} 
&lt;/body&gt; </pre>
<p>How awesome is that! This is one of the main selling points of AngularJS: the extreme ease of achieving data binding. We add a few attributes in our markup, interpolation directive, the <kbd>label</kbd> property to a mystical object called <kbd>$scope</kbd>, which is magically passed to a custom function we define, and everything simply works!</p>
<p>The more experienced Angular developer has a better understanding of what is actually going on behind the scenes. In the preceding example, inside the <kbd>ng-model</kbd> and <kbd>ng-bind</kbd> directives (in our case, the interpolation directive, <kbd>{{}}</kbd>), Angular adds watchers with a different behavior associated with the same expression: <kbd>label</kbd>. These watchers are quite similar to the observers in the classical MVC pattern. On some specific events (in our case, change of the content of the text input), AngularJS will loop over all such watchers, evaluate the expressions associated with them in the context of a given scope, and store their results. This loop is known as the <strong>digest loop</strong>.</p>
<p>In the preceding examples, the evaluation of the <kbd>label</kbd> expression in the context of the scope will return the text, <span class="packt_screen">Hello world!</span>. On each iteration, AngularJS will compare the current result of the evaluation with the previous result and will invoke the associated callback in case the values differ. For instance, the callback added by the interpolation directive will set the content of the element to be the new result of the expression's evaluation. This is an example of the dependency between the callbacks of the watchers of two directives. The callback of the watcher added by <kbd>ng-model</kbd> modifies the result of the expression associated with the watcher added by the interpolation directive.</p>
<p>This approach has its own drawbacks. We said that the digest loop will be invoked on some specific events, but what if these events happen outside the framework; for example, what if we use <kbd>setTimeout</kbd>, and inside the callback, passed as the first argument, we change properties attached to the scope that we're watching? AngularJS will be unaware of the change and won't invoke the digest loop, so we need to do that explicitly using <kbd>$scope.$apply</kbd>. But, what if the framework knew about all the asynchronous events happening in the browser, such as user events, the <kbd>XMLHttpRequest</kbd> events, and the <kbd>WebSocket</kbd>-related events? In such a case, Angular would be able to intercept the event's handling and could invoke the digest loop without forcing us to do so!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">In zone.js</h1>
                </header>
            
            <article>
                
<p>This is exactly the case in Angular. This functionality is implemented with zones using <kbd>zone.js</kbd>.</p>
<p>At ng-conf, in 2014, Brian Ford gave a talk about zones. Brian presented zones as meta-monkey patching of browser APIs. The <kbd>zone.js</kbd> is a library developed by the Angular team, which implements zones in JavaScript. They represent an execution context, which allows us to intercept asynchronous browser calls. Basically, using zones, we are able to invoke a piece of logic just after the given <kbd>XMLHttpRequest</kbd> object completes or when we receive a new <kbd>WebSocket</kbd> event. Angular took advantage of <kbd>zone.js</kbd> by intercepting asynchronous browser events and invoking the digest loop just at the right time. This totally eliminates the need for explicit calls of the digest loop by the developer using Angular.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simplified data flow</h1>
                </header>
            
            <article>
                
<p>The cross-watcher dependencies may create a tangled data flow in our application, which is hard to follow. This may lead to unpredictable behavior and bugs, which are hard to find. Although Angular kept the dirty checking as a way to achieve change detection, the framework enforced unidirectional data flow. This happened by disallowing dependencies between the different watchers, which allows the digest loop to be run only once. This strategy increases the performance of our applications dramatically and reduces the complexity of the data flow. Angular also made improvements to memory efficiency and the performance of the digest loop. Further details on Angular's change detection and the different strategies used for its implementation can be found in <a href="7bc2aa38-2853-468a-8e03-c25387eb03aa.xhtml"/><a href="1b60c28e-5f34-493d-8371-c69968f09020.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Getting Started with Angular Components and Directives</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhancing AngularJS's change detection</h1>
                </header>
            
            <article>
                
<p>Now, let's take a step back and again think about the change detection mechanism of the framework.</p>
<p>We said that inside the digest loop, Angular evaluates registered expressions and compares the evaluated values with the values associated with the same expressions in the previous iteration of the loop.</p>
<p>The most optimal algorithm used for the comparison may differ depending on the type of the value returned from the evaluation of the expression. For instance, if we get a mutable list of items, we need to loop over the entire collection and compare the items in the collections one by one in order to verify if there is a change or not. However, if we have an immutable list, we can perform a check with a constant complexity, only by comparing references. This is the case because the instances of immutable data structures cannot change: instead of mutating the instance, we'll get a new reference with the modification applied.</p>
<p>In AngularJS, we can add watchers using a few methods. Two of them are <kbd>$watch(exp, fn, deep)</kbd> and <kbd>$watchCollection(exp, fn)</kbd>. These methods give us some level of control over the way the change detection will perform the equality check. For example, adding a watcher using <kbd>$watch</kbd> and passing a <kbd>false</kbd> value as a third argument will make AngularJS perform a reference check (that is, compare the current value with the previous one using <kbd>===</kbd>). However, if we pass a truthy (any <kbd>true</kbd> value), the check will be deep (that is, using <kbd>angular.equals</kbd>). This way, depending on the expected type of the returned by the expression value, we can add listeners in the most appropriate way in order to allow the framework to perform equality checks with the most optimal algorithm available. This API has two limitations:</p>
<ul>
<li>It does not allow you to choose the most appropriate equality check algorithm at runtime</li>
<li>It does not allow you to extend the change detection to third parties for their specific data structures</li>
</ul>
<p>The Angular core team assigned this responsibility to differs, allowing them to extend the change detection mechanism and optimize it, based on the data we use in our applications. Angular defines two base classes, which we can extend in order to define custom algorithms:</p>
<ul>
<li><kbd>KeyValueDiffer</kbd>: This allows us to perform advanced diffing over key value-based data structures</li>
<li><kbd>IterableDiffer</kbd>: This allows us to perform advanced diffing over list-like data structures</li>
</ul>
<p>Angular allows us to take full control over the change detection mechanism by extending it with custom algorithms or configuring it appropriately, which wasn't possible in AngularJS. We'll take a further look into the change detection and how we can configure it in <a href="7bc2aa38-2853-468a-8e03-c25387eb03aa.xhtml"/><a href="1b60c28e-5f34-493d-8371-c69968f09020.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Getting Started with Angular Components and Directives</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Services</h1>
                </header>
            
            <article>
                
<p>Services are the building blocks that Angular provides for the definition of the business logic of our applications. In AngularJS, we had three different ways of defining services:</p>
<pre>// The Factory method 
module.factory('ServiceName', function (dep1, dep2, ...) { 
  return { 
    // public API 
  }; 
}); 
 
// The Service method 
module.service('ServiceName', function (dep1, dep2, ...) { 
  // public API 
  this.publicProp = val; 
}); 
 
// The Provider method 
module.provider('ServiceName', function () { 
  return { 
    $get: function (dep1, dep2, ...) { 
      return { 
        // public API 
      }; 
    } 
  }; 
}); </pre>
<p>Although the first two syntactical variations provide similar functionality, they differ in the way the registered service will be instantiated. The third syntax allows further configuration of the registered provider during configuration time.</p>
<p>Having three different methods for defining services is quite confusing for the AngularJS beginners. Let's think for a second what necessitated the introduction of these methods for registering services. Why can't we simply use JavaScript constructor functions, object literals, or ES2015 classes instead, which Angular will not be aware of? We can encapsulate our business logic inside a custom JavaScript constructor function like this:</p>
<pre>function UserTransactions(id) { 
  this.userId = id; 
}
 
UserTransactions.prototype.makeTransaction = function (amount) { 
  // method logic 
}; 
 
module.controller('MainCtrl', function () { 
  this.submitClick = function () { 
    new UserTransactions(this.userId).makeTransaction(this.amount); 
  }; 
}); </pre>
<p>This code is completely valid. However, it doesn't take advantage of one of the key features that AngularJS provides: the DI mechanism. The <kbd>MainCtrl</kbd> function uses the <kbd>UserTransaction</kbd> constructor function, which is visible in its body. The preceding code has two main pitfalls:</p>
<ul>
<li>We're coupled with the logic used for the service's instantiation.</li>
<li>The code is not testable. In order to mock <kbd>UserTransactions</kbd>, we need to monkey patch it.</li>
</ul>
<p>How does AngularJS deal with these two things? When a given service is required, through the DI mechanism of the framework, AngularJS resolves all of its dependencies and instantiates it by passing it to a <kbd>factory</kbd> function, which encapsulates the logic for its creation. The <kbd>factory</kbd> function is passed as the second argument to the <kbd>factory</kbd> and <kbd>service</kbd> methods. The <kbd>provider</kbd> method allows the definition of a service on a lower level; for the <kbd>factory</kbd> method there is the one under the <kbd>$get</kbd> property.</p>
<p>Just like AngularJS, the new versions of Angular tolerates this separation of concerns as well, so the core team kept the services. In contrast to AngularJS, Angular provides a much simpler interface for their definition by allowing us to use plain ES2015 classes. We cannot escape from the fact that we need to explicitly state the services that should be available for injection and somehow specify instructions for their instantiation. In contrast to AngularJS, now the framework uses the ES2016 decorator's syntax and providers for this purpose, instead of the methods familiar to us from AngularJS. This allows us to define the services in our applications as simple as ES2015 classes, with decorators for configuration of the DI:</p>
<pre>import {Injectable} from '@angular/core'; 
 
@Injectable() 
class HttpService { 
  constructor() { /* ... */ } 
} 
 
@Injectable() 
class User { 
  constructor(private service: HttpService) {}
 
  save() { 
    return this.service.post('/users') 
      .then(res =&gt; { 
        this.id = res.id; 
        return this; 
      }); 
  } 
} </pre>
<p>Services are related to the components and the directives described in the previous sections. For developing highly coherent and reusable UI components, we need to move all the business-related logic to inside our services. Also, in order to develop testable components, we need to take advantage of the DI mechanism to resolve all their dependencies.</p>
<p>Another key difference between the services in AngularJS and Angular is the way the frameworks represent them internally. AngularJS uses strings to identify the different services and the associated factories used for their instantiation. On the other hand, now Angular uses keys instead. Usually, keys are the types of the distinct services. Another core difference in the instantiation is the hierarchical structure of injectors, which encapsulate different dependency providers with different visibility.</p>
<p>One more distinction between the services in AngularJS and Angular is the simplified syntax. The DI in Angular has a completely different syntax and has improved behavior by providing a consistent way of injecting dependencies. You can also find a more detailed explanation of Angular services and DI in <a href=""/><a href="3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Dependency Injection in Angular</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The new router</h1>
                </header>
            
            <article>
                
<p>In traditional web applications, all the page changes are associated with a full-page reload, which fetches all of the referenced resources and data and renders the entire page onto the screen. However, requirements for web applications have evolved over time.</p>
<p><strong>Single-page applications</strong> (<strong>SPAs</strong>) that we build with Angular simulate desktop user experiences. This often involves incremental loading of the resources and data required by the application, and no full-page reloads after the initial page load. Often, the different pages or views in SPAs are represented by different templates, which are loaded asynchronously and rendered on a specific position on the screen. Later, when the template with all the required resources is loaded and the route is changed, the logic attached to the selected page is invoked and populates the template with data. If the user clicks on the refresh button after the given page in our SPA is loaded, the same page needs to be re-rendered after the refresh of the view completes. This involves similar behavior: finding the requested view, fetching the required template with all referenced resources, and invoking the logic associated with that view.</p>
<p>The template that needs to be fetched, and the logic that should be invoked after the page reloads successfully, depends on the view selected before the user clicked on the refresh button. The framework determines this by parsing the page URL, which contains the identifier of the currently selected page, represented in a hierarchical structure.</p>
<p>All the responsibilities related to the navigation, changing the URL, loading the appropriate template, and invoking specific logic when the view is loaded, are assigned to the router component. These are some quite challenging tasks, and support for different navigation APIs required for cross-browser compatibility makes the implementation of routing in modern SPAs a nontrivial problem.</p>
<p>AngularJS introduced the router in its core, which was later externalized into the <kbd>ngRoute</kbd> module. It allows a declarative way for defining the different views in our SPA, by providing a template for each page and a piece of logic that needs to be invoked when a page is selected. However, the functionality of the router is limited. It does not support essential features, such as nested view routing. This is one of the reasons most developers preferred to use <kbd>ui-router</kbd>, developed by the community. Both the AngularJS's router and <kbd>ui-router</kbd> route definitions include a route configuration object, which defines a template and a controller associated with the page.</p>
<p>As described in the previous sections, Angular changed the building blocks it provides for the development of SPAs. Angular removes the floating controllers and instead represents views as a composition of components. This necessitates the development of a brand new router, which empowers these new concepts.</p>
<p>The core differences between the AngularJS router and the new Angular router are as follows:</p>
<ul>
<li>The new router is component based, <kbd>ngRoute</kbd> is not. The new Angular router associates a component with the individual routes or a module in case of lazy-loaded routes.</li>
<li>There is now support for nested views.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular route definition syntax</h1>
                </header>
            
            <article>
                
<p>Let's take a brief look at the new syntax provided by the Angular router to define routes in our applications:</p>
<pre>import {Component, NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';
import {RouterModule, Routes} from '@angular/router';

import {HomeComponent} from './home/home.component';
import {AboutComponent} from './about/about.component';
import {AppComponent} from './app.component';

const routes: Routes = [
  { path: 'home', component: HomeComponent },
  { path: 'about', component: AboutComponent }
];

@NgModule({ 
  imports: [BrowserModule, RouterModule.forRoot(routes)],
  declarations: [AppComponent, HomeComponent, AboutComponent],
  bootstrap: [AppComponent]
})
export class AppModule {} </pre>
<p>We won't go into too much detail here since <a href="0880a64a-a64d-41a9-9ffd-7b2d55270110.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a>, <em>Working with the Angular Router and Forms,</em> and <a href="1b60c28e-5f34-493d-8371-c69968f09020.xhtml"/><a href="503e1c1c-afb1-4dd4-98e2-657ceb32cc59.xhtml"><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Explaining Pipes and Communicating with RESTful Services</em>, are dedicated to the new router, but let's mention the main points of the preceding code snippet.</p>
<p>The router lives in <kbd>@angular/router</kbd>. Since <kbd>AppModule</kbd> is the root module of our application, we use the <kbd>forRoot</kbd> method of <kbd>RouterModule</kbd> in order to import all the required directives and services exported by the router.</p>
<p>The parameter passed to the <kbd>RouterModule.forRoot</kbd> decorator shows how we define the routes in our application. We use an array with objects, which defines the mappings between routes and the components associated with them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we took a quick overview of the main building blocks for developing SPAs provided by Angular. We pointed out the main differences with the core concepts from AngularJS.</p>
<p>In the next chapter, we'll take a look at TypeScript and how we can start using it in our next application. We will also explain how with ambient type definitions we can take advantage of the static typing when using libraries and frameworks written in vanilla JavaScript.</p>


            </article>

            
        </section>
    </body></html>