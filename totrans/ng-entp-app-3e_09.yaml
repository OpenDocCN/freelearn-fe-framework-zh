- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Recipes – Master/Detail, Data Tables, and NgRx
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 食谱 – 主/详细信息，数据表，和 NgRx
- en: 'In this chapter, we complete the router-first architecture implementation on
    LemonMart by implementing the top three most used features in business applications:
    master/detail views, data tables, and state management. I will demonstrate data
    tables with server-side pagination, highlighting the integration between the frontend
    and backend using LemonMart and LemonMart Server.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过实现 LemonMart 中的前三个在业务应用程序中最常用的功能（主/详细信息视图，数据表和状态管理）来完成以路由器为首要的架构实现。我将使用
    LemonMart 和 LemonMart Server 展示具有服务器端分页的数据表，突出前端和后端的集成。
- en: We will leverage the router orchestration concept to orchestrate how our components
    load data or render. We will then use resolve guards to reduce boilerplate code
    when loading data before navigating to a component. We will use auxiliary routes
    to lay out components through the router configuration and reuse the same component
    in multiple contexts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用路由编排概念来编排我们的组件如何加载数据或渲染。然后，我们将使用解析守卫在导航到组件之前减少加载数据时的样板代码。我们将使用辅助路由通过路由配置来布局组件，并在多个上下文中重用相同的组件。
- en: We will then dive into NgRx using the LocalCast Weather app and explore NgRx
    Signal Store with LemonMart, so you can become familiar with more advanced application
    architecture concepts in Angular. By the end of this chapter, we will have touched
    upon the major functionality that Angular and Angular Material offer – only the
    good parts, if you will.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用 LocalCast 天气应用程序深入探讨 NgRx，并使用 LemonMart 探索 NgRx Signal Store，这样你就可以熟悉
    Angular 中更高级的应用程序架构概念。到本章结束时，我们将触及 Angular 和 Angular Material 提供的主要功能 – 如果你愿意，就是好的部分。
- en: This chapter covers a lot of ground. It is organized in a recipe format, so
    you can quickly refer to a particular implementation when working on your projects.
    I cover the architecture, design, and major components of the implementation and
    highlight important pieces of code to explain how the solution comes together.
    Leveraging what you’ve learned, I expect the reader to fill in routine implementation
    and configuration details. However, you can always refer to the GitHub repo if
    you get stuck.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。它以食谱格式组织，因此你可以在项目工作时快速参考特定的实现。我涵盖了实现架构、设计和主要组件，并突出显示重要的代码片段来解释解决方案是如何组合在一起的。利用你所学到的知识，我期望读者能够填补常规实现和配置细节。然而，如果你遇到困难，可以始终参考
    GitHub 仓库。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Loading data with resolve guard
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解析守卫加载数据
- en: Reusing components with binding and route data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用绑定和路由数据重用组件
- en: Master/detail view using auxiliary routes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用辅助路由的主/详细信息视图
- en: Data tables with pagination
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带分页的数据表
- en: NgRx store and effects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgRx 存储 和 影响
- en: NgRx ecosystem
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgRx 生态系统
- en: Implementing a global spinner
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现全局旋转器
- en: Configuring server proxies with the Angular CLI
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular CLI 配置服务器代理
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked in the following list. The repository contains the final
    and completed state of the code. You can verify your progress at the end of this
    chapter by looking for the end-of-chapter snapshot of code under the `projects`
    folder.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的样本代码的最新版本可以在以下列表中链接的 GitHub 仓库中找到。该仓库包含代码的最终和完成状态。你可以在本章结束时通过查找`projects`文件夹下的代码章节末尾快照来验证你的进度。
- en: 'For *Chapter 9*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*第9章*：
- en: Be sure that **lemon-mart-server** is up and running. Refer to *Chapter 7*,
    *Working with REST and GraphQL APIs*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 确保**lemon-mart-server**正在运行。请参阅*第7章*，*与 REST 和 GraphQL API 一起工作*。
- en: Clone the repositories at [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
    and [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆以下仓库：[https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
    和 [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)。
- en: Execute `npm install` on the root folder to install dependencies.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行`npm install`以安装依赖。
- en: 'The beginning state of the project is reflected at:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目的初始状态反映在：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The end state of the project is reflected at:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目的最终状态反映在：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将阶段名称添加到任何`ng`命令中，以仅对该阶段执行操作：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the `dist/stage12` folder at the root of the repository will contain
    the compiled result.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，存储库根目录中的`dist/stage12`文件夹将包含编译结果。
- en: In *Chapter 8,* *Recipes – Reusability, Forms, and Caching*, we created a `ViewUserComponent`
    with an `editUser` function. We need this functionality later in the chapter when
    implementing a master/detail view in the system, where a manager can see all users
    in the system and edit them. Before enabling the `editUser` functionality, we
    need to ensure that the `ViewUserComponent` component alongside the `ProfileComponent`
    can load any user given their ID.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8章*，*食谱 - 可重用性、表单和缓存*中，我们创建了一个带有`editUser`函数的`ViewUserComponent`。在章节后面实现系统中的主/详细视图时，我们需要这个功能，其中经理可以看到系统中的所有用户并编辑他们。在启用`editUser`功能之前，我们需要确保`ViewUserComponent`组件和`ProfileComponent`组件可以加载任何用户，给定他们的ID。
- en: In the next couple of sections, we will learn about resolve guards to simplify
    our code and reduce the amount of boilerplate. Let’s start by implementing a resolve
    guard we can use for both components.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将学习关于解析保护器的内容，以简化我们的代码并减少样板代码的数量。让我们首先实现一个我们可以用于两个组件的解析保护器。
- en: Loading data with resolve guard
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用解析保护器加载数据
- en: A resolve guard is a different kind of router guard, as mentioned in *Chapter
    6*, *Implementing Role-Based Navigation*. A resolve guard can load necessary data
    for a component by reading record IDs from `route` parameters, asynchronously
    loading the data, and having it ready when the component activates and initializes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 解析保护器是一种不同类型的路由保护器，如*第6章*，*基于角色的导航实现*中提到的。解析保护器可以通过从`route`参数中读取记录ID，异步加载数据，并在组件激活和初始化时准备好数据来为组件加载数据。
- en: 'The major advantages of a resolve guard include reusability of the loading
    logic, a reduction of boilerplate code, and the shedding of dependencies because
    the component can receive the data it needs without having to import any service:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 解析保护器的主要优势包括加载逻辑的可重用性、减少了样板代码，以及减少了依赖性，因为组件可以在不导入任何服务的情况下接收所需的数据：
- en: 'Create a new `user.resolve.ts` class under `user/user`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user/user`下创建一个新的`user.resolve.ts`类：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similar to the `updateUser` method in `UserService`, we use `map(User.Build)`
    to hydrate the `user` object, so it is ready to be used when a component loads
    data from the `route` snapshot, as we’ll see next.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`UserService`中的`updateUser`方法类似，我们使用`map(User.Build)`来填充`user`对象，使其在组件从`route`快照加载数据时准备好使用，正如我们接下来将看到的。
- en: 'Modify `user-routing.module.ts` to add a new path, `profile/:userId`, with
    a route resolver and the `canActivate authGuard`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`user-routing.module.ts`以添加一个新的路径`profile/:userId`，带有路由解析器和`canActivate authGuard`：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When combined with an auth guard, the `resolve` function won’t be executed until
    the guard succeeds.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当与身份验证保护器结合使用时，`resolve`函数只有在保护器成功后才会执行。
- en: 'Update the `profile` component to load the data from the `route` if it exists:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`profile`组件，如果存在，则从`route`加载数据：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We first check whether a user is present in the `route` snapshot. If so, we
    call `patchUser` to load this user. Otherwise, we fall back to our conditional
    cache-loading logic.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查用户是否存在于`route`快照中。如果是，我们调用`patchUser`来加载此用户。否则，我们回退到我们的条件缓存加载逻辑。
- en: Note that the `patchUser` method also sets the `currentUserId` and `nameInitialDate$`
    Observables and calls the `patchUpdateData` base to update the form data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`patchUser`方法还设置了`currentUserId`和`nameInitialDate$`可观察对象，并调用`patchUpdateData`基类来更新表单数据。
- en: You can verify that the resolver is working by navigating to the profile with
    your user ID. Using the out-of-the-box settings, this URL will look something
    like `http://localhost:4200/user/profile/5da01751da27cc462d265913`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过导航到带有您用户ID的配置文件来验证解析器是否正常工作。使用出厂设置，此URL将类似于`http://localhost:4200/user/profile/5da01751da27cc462d265913`。
- en: Reusing components with binding and route data
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用绑定和路由数据重用组件
- en: Now, let’s refactor the `viewUser` component so that we can reuse it in multiple
    contexts. User information is displayed in two places in the app per the mock-ups
    created.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重构`viewUser`组件，以便我们可以在多个上下文中重用它。根据创建的模拟图，应用程序中显示用户信息的地方有两个。
- en: 'The first place is the **Review** step of the user profile that we implemented
    in the previous chapter. The second place is on the user management screen on
    the `/manager/users` route, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个地方是我们之前章节中实现的用户资料**审查**步骤。第二个地方是在`/manager/users`路由的用户管理屏幕上，如下所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_09_01.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成](img/B20960_09_01.png)'
- en: 'Figure 9.1: Manager user management mock-up'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：经理用户管理模拟图
- en: To maximize code reuse, we must ensure that our shared `ViewUser` component
    can be used in both contexts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化代码重用，我们必须确保我们的共享 `ViewUser` 组件可以在两种上下文中使用。
- en: 'In the first use case, we bind the current user to the **Review** step of the
    multi-step input form. In the second use case, the component will need to load
    its data using a resolve guard, so we don’t need to implement additional logic
    to achieve our goal:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个用例中，我们将当前用户绑定到多步输入表单的 **Review** 步骤。在第二个用例中，组件需要使用 resolve 守卫加载数据，因此我们不需要实现额外的逻辑来实现我们的目标：
- en: 'Update the `viewUser` component to inject the `Router` and `ActivatedRoute`.
    In `ngOnInit` we need to set `currentUser` from the route in and subscribe to
    future route change events to apply updates to the user using a helper function
    `assignUserFromRoute` and unsubscribe from the event in `ngOnDestroy`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `viewUser` 组件以注入 `Router` 和 `ActivatedRoute`。在 `ngOnInit` 中，我们需要从路由中设置 `currentUser`
    并订阅未来的路由更改事件，以使用辅助函数 `assignUserFromRoute` 更新用户，并在 `ngOnDestroy` 中取消订阅事件：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`ngOnInit` will only fire once when the component is initialized within another
    component or loaded within the router context. If any data for the route has been
    resolved, we update `currentUser`. When the user wants to view another user, a
    new navigation event will occur with a different user ID. Since Angular will reuse
    the component, we must subscribe to router events to react to subsequent user
    changes. In this case, in case of a `NavigationEnd` event, if the route has resolved
    user data, we again update `currentUser`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnInit` 只会在组件在另一个组件内部初始化或在路由器上下文中加载时触发一次。如果已经解析了路由的任何数据，我们将更新 `currentUser`。当用户想要查看另一个用户时，将发生一个新的导航事件，带有不同的用户
    ID。由于 Angular 会重用组件，我们必须订阅路由事件以对后续的用户更改做出反应。在这种情况下，如果发生 `NavigationEnd` 事件，并且已解析了用户数据，我们将再次更新
    `currentUser`。'
- en: We now have three independent events to update and handle data. Within the parent
    component context, `ngOnChanges` handles updates to the `@Input` value and updates
    `currentUser` if `this.user` has been bound to. The code we added above handles
    the remaining two cases with router context on the first navigation and subsequent
    navigation events.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有三个独立的事件来更新和处理数据。在父组件上下文中，`ngOnChanges` 处理 `@Input` 值的更新，如果 `this.user`
    已经绑定，则更新 `currentUser`。我们上面添加的代码处理了第一次导航和后续导航事件中的剩余两个情况。
- en: Since LemonMart is bootstrapped as a standalone application and `viewUser` is
    a standalone component, we can use this component across multiple lazy-loaded
    modules without additional orchestration.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 LemonMart 是作为一个独立的应用程序自举的，并且 `viewUser` 是一个独立的组件，因此我们可以在多个懒加载的模块中使用这个组件，而无需额外的编排。
- en: If you’re not using standalone components, you must wrap this component inside
    a `SharedComponentsModule` and import that module in your lazy-loaded modules.
    You can find an example implementation in the GitHub history of the project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用独立组件，你必须在这个组件内部包装一个 `SharedComponentsModule`，并在你的懒加载模块中导入该模块。你可以在项目的
    GitHub 历史记录中找到一个示例实现。
- en: With the key pieces in place, let’s begin implementing the master/detail view.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键组件就绪后，让我们开始实现 master/detail 视图。
- en: Master/detail view using auxiliary routes
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用辅助路由的 master/detail 视图
- en: The true power of router-first architecture comes to fruition with auxiliary
    routes, where we can influence the layout of components solely through router
    configuration, allowing for rich scenarios where we can remix the existing components
    into different layouts. Auxiliary routes are routes that are independent of each
    other where they can render content in named outlets that have been defined in
    the markup, such as `<router-outlet name="master">` or `<router-outlet name="detail">`.
    Furthermore, auxiliary routes can have their parameters, browser history, children,
    and nested auxiliaries.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器优先架构的真正力量在辅助路由中得以实现，我们可以通过路由配置单独影响组件的布局，从而允许我们混合现有的组件到不同的布局中。辅助路由是相互独立的路由，它们可以在标记中定义的命名出口中渲染内容，例如
    `<router-outlet name="master">` 或 `<router-outlet name="detail">`。此外，辅助路由可以有它们的参数、浏览器历史、子路由和嵌套辅助路由。
- en: 'In the following example, we will implement a basic master/detail view using
    auxiliary routes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将实现一个基本的 master/detail 视图，使用辅助路由：
- en: 'Implement a simple component with two named outlets defined:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个简单的组件，其中定义了两个命名的出口：
- en: '[PRE7]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Add a new `userTable` component under `manager`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `manager` 下添加一个新的 `userTable` 组件。
- en: 'Update `manager-routing.module.ts` to define the auxiliary routes:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `manager-routing.module.ts` 以定义辅助路由：
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that when a user navigates to `/manager/users`, they’ll see the `UserTableComponent`,
    because it is implemented with the default path.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着当用户导航到`/manager/users`时，他们将看到`UserTableComponent`，因为它使用的是默认路径。
- en: Provide `UserResolve` in `manager.module.ts` since `viewUser` depends on it.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`manager.module.ts`中提供`UserResolve`，因为`viewUser`依赖于它。
- en: 'Implement a temporary button in `userTable`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`userTable`中实现一个临时按钮：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `skipLocationChange` directive navigates without pushing a new record into
    history. So, if the user views multiple records and hits the **Back** button,
    they will be taken back to the previous screen instead of having to scroll through
    the records they viewed first.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`skipLocationChange`指令在不将新记录推入历史记录的情况下进行导航。因此，如果用户查看多个记录并点击**后退**按钮，他们将被带回到上一个屏幕，而不是必须滚动查看他们首先查看的记录。'
- en: 'Imagine that a user clicks on a **View detail** button like the one defined
    previously – then, `ViewUserComponent` will be rendered for the user with the
    given `userId`. In the next screenshot, you can see what the **View Details**
    button will look like after we implement the data table in the next section:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想象一下，一个用户点击了一个类似于之前定义的**查看详情**按钮——然后，`ViewUserComponent`将为用户渲染带有给定`userId`的组件。在下一张截图中，你可以看到在下一节实现数据表后，**查看详情**按钮将看起来如何：
- en: '![A screenshot of a phone  Description automatically generated](img/B20960_09_02.png)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![手机截图  自动生成的描述](img/B20960_09_02.png)'
- en: 'Figure 9.2: View Details button'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.2：查看详情按钮
- en: You can have as many combinations as possible and alternative components defined
    for the master and detail, allowing for the infinite possibilities of dynamic
    layouts. However, setting up the `routerLink` can be a frustrating experience.
    Depending on the exact condition, you must either supply or not supply all or
    some outlets in the link.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以尽可能多地组合，并为主视图和详情视图定义替代组件，从而允许动态布局的无限可能性。然而，设置`routerLink`可能是一个令人沮丧的经历。根据具体条件，你必须提供或不需要提供链接中的所有或部分出口。
- en: 'For example, in the preceding scenario, consider this alternative implementation,
    where the master outlet is explicitly defined:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，在先前的场景中，考虑以下替代实现，其中主出口被明确定义：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The router will not correctly parse this route and silently fail to load. If
    it is `master: []` it will work. This comes down to how pattern matching happens
    on empty routes; while this makes logical sense in the framework code, it doesn’t
    make intuitive sense for developers using the APIs.'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '路由器将无法正确解析此路由，并且会静默失败加载。如果它是`master: []`，则可以正常工作。这取决于空路由上的模式匹配方式；虽然这在框架代码中逻辑上是合理的，但对于使用API的开发者来说并不直观。'
- en: Now that we’ve completed the implementation of the resolve guard for `ViewUserComponent`,
    you can use Chrome DevTools to see the data being loaded correctly.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`ViewUserComponent`的resolve guard实现，你可以使用Chrome DevTools来查看正确加载的数据。
- en: Before debugging, ensure that the **lemon-mart-server** we created in *Chapter
    7*, *Working with REST and GraphQL APIs*, is running.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调试之前，确保我们在*第7章*，*使用REST和GraphQL API*中创建的**lemon-mart-server**正在运行。
- en: In **Chrome DevTools**, set a breakpoint right after `this.currentUser` is assigned,
    as shown:![A screenshot of a computer  Description automatically generated](img/B20960_09_03.png)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Chrome DevTools**中，在`this.currentUser`分配后立即设置一个断点，如图所示：![计算机截图  自动生成的描述](img/B20960_09_03.png)
- en: 'Figure 9.3: Dev Tools debugging ViewUserComponent'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.3：Dev Tools调试ViewUserComponent
- en: You will observe that `this.currentUser` is correctly set without any boilerplate
    code for loading data inside the `ngOnInit` function, showing the true benefit
    of a resolve guard. `ViewUserComponent` is the detail view; now, let’s implement
    the master view as a data table with pagination.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你将观察到`this.currentUser`被正确设置，而无需在`ngOnInit`函数内部加载数据的任何样板代码，这显示了resolve guard的真正好处。"ViewUserComponent"是详情视图；现在，让我们实现主视图，作为一个带有分页的数据表。
- en: Data tables with pagination
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有分页的数据表
- en: We have created the scaffolding to lay out our master/detail view. In the master
    outlet, we will have a paginated data table of users, so let’s implement `UserTableComponent`,
    which will contain a `MatTableDataSource` property named `dataSource`. We will
    need to be able to fetch user data in bulk using standard pagination controls
    such as `pageSize` and `pagesToSkip` and narrow down the selection further with
    user-provided search text.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了脚手架来布局我们的主/详细视图。在主出口处，我们将有一个用户分页数据表，所以让我们实现 `UserTableComponent`，它将包含一个名为
    `dataSource` 的 `MatTableDataSource` 属性。我们需要能够使用标准分页控件（如 `pageSize` 和 `pagesToSkip`）批量获取用户数据，并使用用户提供的搜索文本进一步缩小选择范围。
- en: 'Let’s start by adding the necessary functionality to `UserService`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向 `UserService` 添加必要的功能开始：
- en: 'Implement a new `IUsers` interface to describe the data structure of the paginated
    data:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个新的 `IUsers` 接口来描述分页数据的结构：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Update the interface for `UserService` with a `getUsers` function:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `getUsers` 函数更新 `UserService` 的接口：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add `getUsers` to `UserService`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `getUsers` 添加到 `UserService`：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that the `sort` direction is indicated by the keywords `asc` for ascending
    and `desc` for descending. When sorting a column in ascending order, we pass the
    column name as a parameter to the server. We prepend the column name with a minus
    sign to sort a column in descending order.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`sort` 方向由关键字 `asc`（升序）和 `desc`（降序）表示。在升序排序列时，我们将列名作为参数传递给服务器。为了降序排序列，我们在列名前加上负号。
- en: 'Set up `UserTable` with pagination, sorting, and filtering:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分页、排序和过滤设置 `UserTable`：
- en: '[PRE14]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We define and initialize various properties to support loading paginated data.
    `items$` stores the observable stream that defines what data is displayed on the
    data table. `displayedColumns`, a computed signal, defines the columns for the
    table. To dynamically show or hide columns we can defined a toggle using a signal,
    such as `demoViewDetailsColumn`. Since this signal is referenced within the computed
    signal, when it updates the computed signal will also be updated., which will
    then be reflected on the table. `paginator` and `sort` provide pagination and
    sorting preferences `.search` provides the text we need to filter our results
    by.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义并初始化各种属性以支持加载分页数据。`items$` 存储定义在数据表上显示的数据的可观察流。`displayedColumns`，一个计算信号，定义了表格的列。为了动态显示或隐藏列，我们可以使用一个信号定义一个切换器，例如
    `demoViewDetailsColumn`。由于这个信号在计算信号中被引用，当它更新时，计算信号也会更新，这将在表格上得到反映。`paginator`
    和 `sort` 提供分页和排序首选项，`.search` 提供我们用于通过文本过滤结果的文本。
- en: '`resetPage` helps rewind the pagination to the first page and hide the detail
    view. This is useful after a search, pagination, or sort event, otherwise the
    detail view of a random record will be displayed.'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`resetPage` 帮助将分页重置到第一页并隐藏详细视图。这在搜索、分页或排序事件之后很有用，否则将显示随机记录的详细视图。'
- en: '`showDetail` uses the router to display the detail view of a selected record
    in the named outlet `detail`. Later in this section, we will go over a version
    of the same link implemented in the template. I purposefully included both options,
    so you can see how both are implemented.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`showDetail` 使用路由器在名为 `detail` 的出口处显示所选记录的详细视图。在本节稍后，我们将介绍在模板中实现相同链接的版本。我故意包含了这两个选项，这样你可以看到它们是如何实现的。'
- en: 'I purposefully left the following code commented out in the code base:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我故意在代码库中以下代码被注释掉：
- en: '[PRE15]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I found in certain instances the router may not be able to gracefully close
    an outlet. `OutletCloserService`, found in the `common` folder, can close any
    outlet from any context without fuss.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我发现，在某些情况下，路由器可能无法优雅地关闭出口。位于 `common` 文件夹中的 `OutletCloserService` 可以从任何上下文中无麻烦地关闭任何出口。
- en: The reference to the original version by Andrew Scott is at [https://stackblitz.com/edit/close-outlet-from-anywhere](https://stackblitz.com/edit/close-outlet-from-anywhere).
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于安德鲁·斯科特原始版本的引用，请参阅 [https://stackblitz.com/edit/close-outlet-from-anywhere](https://stackblitz.com/edit/close-outlet-from-anywhere)。
- en: The magic happens in `ngAfterViewInit`. We first subscribe to `sort` and `paginator`
    change events, so we can properly reset the table. Next, we use the `merge` method
    within a `setTimeout` call, as highlighted in the preceding snippet, to listen
    for changes in pagination, sorting, and filter properties that impact what data
    needs to be displayed. If one property changes, the whole pipeline is triggered.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 魔法发生在`ngAfterViewInit`中。我们首先订阅`sort`和`paginator`变化事件，以便我们可以正确地重置表格。接下来，我们使用`setTimeout`调用内的`merge`方法，如前一个片段中突出显示的，来监听影响需要显示的数据的分页、排序和筛选属性的变化。如果某个属性发生变化，整个管道就会被触发。
- en: Why is the `setTimeout` necessary? Since we use references to paginator and
    sort extracted from the template, we must use the `ngAfterViewInit` lifecycle
    hook. However, at this point, Angular has already set the `dataSource` property
    for the Material data table component. If we re-assign it with the `merge` operator,
    we’ll get NG0100 `ExpressionChangedAfterItHasBeenCheckedError`. Using `setTimeout`
    pushes the reassignment into the next change detection cycle, avoiding the error.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么`setTimeout`是必要的？因为我们使用从模板中提取的paginator和sort的引用，我们必须使用`ngAfterViewInit`生命周期钩子。然而，在这个时候，Angular已经为Material数据表组件设置了`dataSource`属性。如果我们使用`merge`操作符重新分配它，我们将得到NG0100
    `ExpressionChangedAfterItHasBeenCheckedError`。使用`setTimeout`将重新分配推入下一个变化检测周期，从而避免错误。
- en: This is similar to how we implemented the login routine in `AuthService`. The
    pipeline contains a call to `this.userService.getUsers`, which will retrieve users
    based on the pagination, sorting, and filter preferences passed in. Results are
    then piped into the `this.items$` Observable, which the data table subscribes
    to with an `async` pipe to display the data.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与我们在`AuthService`中实现登录例程的方式类似。该管道包含对`this.userService.getUsers`的调用，该调用将根据传入的分页、排序和筛选偏好检索用户。然后结果被管道传输到`this.items$`
    Observable，数据表通过`async`管道订阅它以显示数据。
- en: There’s no need to subscribe to `this.items$`, because the Material data table
    already subscribes to it internally. If you subscribe, every call to the server
    will be made twice.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有必要订阅`this.items$`，因为Material数据表已经内部订阅了它。如果你订阅，每次对服务器的调用都将执行两次。
- en: However, you must take care to place the `takeUntilDestroyed` call as the last
    element in the pipe. Otherwise, you could leak subscriptions merged after the
    call.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，你必须注意将`takeUntilDestroyed`调用放在管道中的最后一个元素。否则，你可能会在调用之后泄漏合并后的订阅。
- en: Read more about it at [https://cartant.medium.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef](https://cartant.medium.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef).
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在[https://cartant.medium.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef](https://cartant.medium.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef)了解更多相关信息。
- en: 'Import the following modules:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下模块：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Implement the CSS for `userTable`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`userTable`的CSS：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The styles below the comment `/* row selection styles */` assist in the material
    ripple effect when individual rows are clicked.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在注释`/* 行选择样式 */`下面的样式有助于在点击单个行时辅助材料涟漪效果。
- en: 'Finally, implement the `userTable` template:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`userTable`模板：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note the implementation of the `loading-shade` style, which places a spinner
    over the table while loading data. This is an example of a localized spinner.
    Later in the *Implementing a global spinner with NgRx/SignalState section*, I
    cover how we can implement a global version. Most very large applications will
    require a localized spinner to avoid excessive full-screen interruptions caused
    by a global spinner.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`loading-shade`样式的实现，它在加载数据时在表格上放置一个旋转器。这是一个本地化旋转器的示例。在*实现NgRx/SignalState的全局旋转器*部分，我将介绍我们如何实现全局版本。大多数非常大的应用程序将需要一个本地化旋转器，以避免全局旋转器造成的过度全屏中断。
- en: 'We bind `items$` to `dataSource` to activate the Observable. Below, the `mat-icon-button`
    with `[routerLink]="[''../users'', { outlets: { detail: [''user'', { userId: row._id
    }] } }]"` uses the context row variable to assign a URL that will display `ViewUserComponent`
    in the `detail` outlet. `skipLocationChange` ensures that the URL in the browser
    won’t be updated with the outlet information.'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '我们将`items$`绑定到`dataSource`以激活Observable。下面，带有`[routerLink]="[''../users'',
    { outlets: { detail: [''user'', { userId: row._id }] } }]"`的`mat-icon-button`使用上下文行变量来分配一个URL，该URL将在`detail`出口中显示`ViewUserComponent`。`skipLocationChange`确保浏览器中的URL不会更新为出口信息。'
- en: Note that using the relative URL `'../users'` in the `routerLink`, as shown
    above, allows the `UserTableComponent` to be decoupled from the context of the
    manager feature module. This way, the component could be reused under other contexts
    like `/owner/users` or `/ceo/users` instead of being hard coded to `/manager/users`.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在`routerLink`中使用相对URL`'../users'`，如上所示，允许`UserTableComponent`从管理功能模块的上下文中解耦。这样，组件可以在其他上下文中重用，例如`/owner/users`或`/ceo/users`，而不是硬编码为`/manager/users`。
- en: Setting up the router within lazy-loaded modules and named outlets could be
    error-prone.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在延迟加载的模块和命名出口中设置路由器可能会出错。
- en: 'You can enable the router’s debug mode by modifying the root provider in `app.config.ts`
    by adding the `withDebugTracing` function as shown:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过修改`app.config.ts`中的根提供者来启用路由器的调试模式，如下所示添加`withDebugTracing`函数：
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Further on, the `matRipple` directive enables a Material Design ripple when
    a row is clicked. Right after this, we implement the click handlers. By default,
    clicking on a row will display the detail view using the `showDetail` function;
    otherwise, users will click on a view button on the rightmost column.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 进一步来说，`matRipple`指令在行被点击时启用Material Design涟漪效果。紧接着，我们实现点击处理程序。默认情况下，点击行将使用`showDetail`函数显示详细视图；否则，用户将在最右侧列的视图按钮上点击。
- en: Finally, observe the click on the refresh button, which causes an update in
    the `refresh$` Observable. This will be picked up by the merge pipeline we implemented
    in the component.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，观察刷新按钮的点击，这会导致`refresh$`可观察对象更新。这将由我们在组件中实现的合并管道捕获。
- en: 'With just the master view in place, the table is as shown in the following
    screenshot (make sure you’ve updated to the latest version of Angular):'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅放置主视图，表格如下所示（确保您已更新到Angular的最新版本）：
- en: '![](img/B20960_09_04.png)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B20960_09_04.png)'
- en: 'Figure 9.4: User table'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.4：用户表
- en: 'If you click on a row, `ViewUserComponent` will get rendered in the detail
    outlet using the `showDetails` function, as shown:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您点击行，`ViewUserComponent`将使用`showDetails`函数在详细出口中渲染，如下所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_09_05.png)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![计算机截图 自动生成描述](img/B20960_09_05.png)'
- en: 'Figure 9.5: Master/detail view with row click'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.5：行点击的主/详细视图
- en: Note how the row is highlighted to indicate selection. If you flip the **Demo
    ‘View Details’ Column** option on the top right, you will unhide the **View Details**
    column.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意行是如何被突出显示以表示选择的。如果您在右上角翻转**演示“查看详情”列**选项，您将取消隐藏**查看详情**列。
- en: 'If you click on the **View** icon, `ViewUserComponent` will get rendered in
    the detail outlet using `routerLink` in the template, as shown:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您点击**查看**图标，`ViewUserComponent`将使用模板中的`routerLink`在详细出口中渲染，如下所示：
- en: '![](img/B20960_09_06.png)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B20960_09_06.png)'
- en: 'Figure 9.6: Master/detail view icon click'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.6：主/详细视图图标点击
- en: In the previous chapter, we implemented the **Edit** button, represented by
    the pencil icon in the top right, passing the `userId` to the `UserProfile` to
    edit and update the data.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了**编辑**按钮，由右上角的铅笔图标表示，将`userId`传递给`UserProfile`以编辑和更新数据。
- en: Click on the **Edit** button to be taken to the `ProfileComponent`, edit the
    user record, and verify that you can update another user’s record.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**编辑**按钮，将被带到`ProfileComponent`，编辑用户记录，并验证您是否可以更新其他用户的记录。
- en: Confirm that you can view the updated user record in the data table.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您可以在数据表中查看更新的用户记录。
- en: This demonstration of data tables with pagination completes the major functionality
    of LemonMart for this book. Before moving on, make sure all the tests have passed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中LemonMart的数据表分页演示完成了主要功能。在继续之前，请确保所有测试都已通过。
- en: For the unit tests, I import concrete implementations of `NameInputComponent`
    or `ViewUserComponent` instead of using the `createComponentMock` function from
    `angular-unit-test-helper`. This is because `createComponentMock` is not sophisticated
    enough to bind data to child components. In the *Further reading* section, I’ve
    included a blog post by Aiko Klostermann that covers testing Angular components
    with `@Input()` properties.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元测试，我导入`NameInputComponent`或`ViewUserComponent`的具体实现，而不是使用`angular-unit-test-helper`中的`createComponentMock`函数。这是因为`createComponentMock`不足以将数据绑定到子组件。在**进一步阅读**部分，我包括了一篇由Aiko
    Klostermann撰写的博客文章，该文章涵盖了使用`@Input()`属性测试Angular组件。
- en: With the heavy lifting of the implementation completed, we can now explore alternative
    architectures, tools, and libraries to better understand the best ways to architect
    Angular apps for various needs. Next, let’s explore NgRx.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的重任完成后，我们现在可以探索替代的架构、工具和库，以更好地理解针对各种需求构建Angular应用的最好方式。接下来，让我们探索NgRx。
- en: NgRx store and effects
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgRx存储和效果
- en: As covered in *Chapter 1*, *Angular’s Architecture and Concepts*, the NgRx library
    brings reactive state management to Angular based on RxJS. State management with
    NgRx allows developers to write atomic, self-contained, and composable pieces
    of code, creating actions, reducers, and selectors. This kind of reactive programming
    isolates side effects in state changes. NgRx is an abstraction layer over RxJS
    to fit the **Flux pattern**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如*第一章*，*Angular的架构和概念*所述，NgRx库基于RxJS将响应式状态管理引入Angular。使用NgRx进行状态管理允许开发者编写原子化、自包含和可组合的代码片段，创建动作、还原器和选择器。这种响应式编程将副作用隔离在状态变化中。NgRx是RxJS之上的抽象层，以适应**Flux模式**。
- en: 'There are four major elements of NgRx:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx有四个主要元素：
- en: '**Store**: The central location where state information is persisted. You implement
    a reducer to store a state transition in the store and a selector to read data
    out of the store. These are atomic and composable pieces of code.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：状态信息持久化的中心位置。您在存储中实现一个还原器以存储状态转换，并实现一个选择器以从存储中读取数据。这些都是原子化和可组合的代码片段。'
- en: A view (or user interface) displays data from the store by using a selector.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 视图（或用户界面）通过使用选择器显示存储中的数据。
- en: '**Action**: Unique events that happen throughout your app.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**：在整个应用中发生的独特事件。'
- en: Actions are triggered from a view with the purpose of dispatching them to the
    store.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动作从视图触发，目的是将它们派发到存储中。
- en: '**Dispatcher**: This is a method to send actions to the store.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**派发器**：这是一个向存储发送动作的方法。'
- en: Reducers in the store listen for dispatched actions.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储中的还原器监听派发的动作。
- en: '**Effect**: This is a combination of an action and a dispatcher. Effects are
    usually used for actions that are not triggered from a view.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效果**：这是动作和派发器的组合。效果通常用于不是从视图中触发的动作。'
- en: 'Let’s revisit the following Flux pattern diagram, which now highlights an **Effect**:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾以下Flux模式图，现在突出显示了一个**效果**：
- en: '![A diagram of a system  Description automatically generated](img/B20960_09_07.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![系统图，自动生成描述](img/B20960_09_07.png)'
- en: 'Figure 9.7: Flux pattern diagram'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：通量模式图
- en: Let’s demonstrate how NgRx works by going over a concrete example. To keep it
    simple, we will leverage the LocalCast Weather app.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来演示NgRx是如何工作的。为了保持简单，我们将利用LocalCast天气应用。
- en: Implementing NgRx for LocalCast Weather
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现LocalCast天气应用的NgRx
- en: 'We will implement NgRx to execute the search functionality in the LocalCast
    Weather app. Consider the following architecture diagram:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在LocalCast天气应用中实现NgRx以执行搜索功能。考虑以下架构图：
- en: '![A diagram of a weather forecast  Description automatically generated](img/B20960_09_08.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![天气预报图，自动生成描述](img/B20960_09_08.png)'
- en: 'Figure 9.8: LocalCast Weather architecture'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：LocalCast天气架构
- en: We will use the NgRx store and effects libraries to achieve our implementation.
    NgRx store actions are reflected in the diagram in light gray with a `WeatherLoaded`
    reducer and the app state. At the top, actions are represented as a stream of
    various data objects, either dispatching actions or acting on dispatched actions,
    enabling us to implement the **Flux pattern** introduced in *Chapter 1*, *Angular’s
    Architecture and Concepts*. The NgRx effects library extends the Flux pattern
    by isolating side effects in its model without littering the store with temporary
    data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用NgRx存储和效果库来实现我们的实现。NgRx存储动作在图中以浅灰色表示，包括`WeatherLoaded`还原器和应用状态。在顶部，动作表示为各种数据对象流，要么派发动作，要么对派发的动作进行操作，使我们能够实现*第一章*，*Angular的架构和概念*中引入的**Flux模式**。NgRx效果库通过在其模型中隔离副作用来扩展Flux模式，而不会在存储中留下临时数据。
- en: 'The effects workflow, represented in dark gray in *Figure 9.8*, begins with
    *step 1*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.8*中以深灰色表示的效果工作流程从*步骤1*开始：
- en: '`CitySearchComponent` dispatches the `search` action.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CitySearchComponent`派发`search`动作。'
- en: The `search` action appears on the Observable `@ngrx/action` stream (or data
    stream).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`search`动作出现在`@ngrx/action`可观察流（或数据流）中。'
- en: '`CurrentWeatherEffects` acts on the `search` action to perform a search.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CurrentWeatherEffects`对`search`动作进行操作以执行搜索。'
- en: '`WeatherService` performs the search to retrieve current weather information
    from the **OpenWeather API**.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WeatherService` 执行搜索以从 **OpenWeather API** 获取当前天气信息。'
- en: 'Store actions, represented in light gray, begin with *step A* (uppercase A):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 存储动作，以浅灰色表示，以 *step A*（大写 A）开头：
- en: '`CurrentWeatherEffects` dispatches the `weatherLoaded` action.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CurrentWeatherEffects` 分派 `weatherLoaded` 动作。'
- en: The `weatherLoaded` action appears on the Observable data stream, labeled `@ngrx/action`
    stream.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`weatherLoaded` 动作出现在 Observable 数据流上，标记为 `@ngrx/action` 流。'
- en: The `weatherLoaded` reducer acts on the `weatherLoaded` action.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`weatherLoaded` 约束对 `weatherLoaded` 动作进行操作。'
- en: The `weatherLoaded` reducer transforms the weather information to be stored
    as the new state.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`weatherLoaded` 约束将天气信息转换为要存储的新状态。'
- en: The new state is a persisted `search` state, part of the `appStore` state.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新状态是一个持久化的 `search` 状态，是 `appStore` 状态的一部分。
- en: Note that there’s a parent-level `appStore` state containing a child `search`
    state. I intentionally retained this setup to demonstrate how the parent-level
    state scales as you add different kinds of data elements to the store.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有一个包含子 `search` 状态的父级 `appStore` 状态。我故意保留了这种设置，以展示父级状态如何随着你在存储库中添加不同类型的数据元素而扩展。
- en: 'Finally, a view (an Angular component) reads from the store, beginning with
    *step a* (lowercase a):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个视图（一个 Angular 组件）从存储中读取，以 *step a*（小写 a）开始：
- en: The `CurrentWeather` component subscribes to the `selectCurrentWeather` selector
    using the `async` pipe.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CurrentWeather` 组件使用 `async` 管道订阅 `selectCurrentWeather` 选择器。'
- en: The `selectCurrentWeather` selector listens for changes to the `store.search.current`
    property in the `appStore` state.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`selectCurrentWeather` 选择器监听 `appStore` 状态中 `store.search.current` 属性的变化。'
- en: The `appStore` state retrieves the persisted data.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`appStore` 状态检索持久化的数据。'
- en: Using an NgRx selector is like writing a query to read data stored in a database.
    The database, in this case, is the store.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NgRx 选择器就像编写查询来读取存储在数据库中的数据。在这种情况下，数据库是存储库。
- en: Using NgRx, when a user searches for a city, the actions to retrieve, persist,
    and display that information on `CurrentWeatherComponent` happen automatically
    via individual composable and immutable elements.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NgRx，当用户搜索城市时，检索、持久化和在 `CurrentWeatherComponent` 上显示该信息的动作将自动通过单个可组合和不可变元素发生。
- en: Comparing BehaviorSubject and NgRx
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较BehaviorSubject和NgRx
- en: 'We will implement NgRx alongside `BehaviorSubject` so you can see the differences
    in implementing the same feature. To do this, we will need a slide toggle to switch
    between the two strategies:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现 NgRx 与 `BehaviorSubject` 一起，以便你可以看到实现相同功能的差异。为此，我们需要一个滑动开关来在两种策略之间切换：
- en: This section uses the **local-weather-app** repo. You can find the code samples
    for this chapter under the `projects/stage12` folder.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用 **local-weather-app** 仓库。你可以在 `projects/stage12` 文件夹下找到本章的代码示例。
- en: Note that the main app under the `src` folder uses a button toggle to switch
    between `Signals`, `BehaviorSubject`, and `NgRx`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，位于 `src` 文件夹下的主应用程序使用按钮切换在 `Signals`、`BehaviorSubject` 和 `NgRx` 之间切换。
- en: Start by implementing a `<mat-slide-toggle>` element on `CitySearchComponent`,
    as shown in the following screenshot:![A screenshot of a weather forecast  Description
    automatically generated](img/B20960_09_09.png)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `CitySearchComponent` 上实现一个 `<mat-slide-toggle>` 元素，如下面的截图所示：![天气预报截图 自动生成的描述](img/B20960_09_09.png)
- en: 'Figure 9.9: LocalCast Weather slide toggle'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.9：LocalCast 天气滑动切换
- en: Ensure the field is backed by a property on your component named `useNgRx`.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保字段由组件上的名为 `useNgRx` 的属性支持。
- en: Refactor the `doSearch` method to extract the `BehaviorSubject` code into its
    own function named `behaviorSubjectBasedSearch`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构 `doSearch` 方法，将 `BehaviorSubject` 代码提取到名为 `behaviorSubjectBasedSearch` 的单独函数中。
- en: 'Stub out a function called `ngRxBasedSearch`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ngRxBasedSearch` 的函数原型：
- en: '[PRE20]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will be dispatching an action from the `ngRxBasedSearch` function that you
    just created.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从你刚刚创建的 `ngRxBasedSearch` 函数中分派一个动作。
- en: Setting up NgRx
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 NgRx
- en: 'You can add the NgRx Store package with the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令添加 NgRx Store 包：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will create a `reducers` folder with an `index.ts` file in it. Now add
    the NgRx `effects` package:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含 `index.ts` 文件的 `reducers` 文件夹。现在添加 NgRx 的 `effects` 包：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We use the `--minimal` option here to avoid creating unnecessary boilerplate.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `--minimal` 选项以避免创建不必要的样板代码。
- en: 'Next, install the NgRx schematics library so you can take advantage of generators
    to create the boilerplate code for you:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装 NgRx 规范库，这样你就可以利用生成器为你创建样板代码：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Implementing NgRx can be confusing due to its highly decoupled nature, which
    may necessitate some insight into the library’s inner workings.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 NgRx 的高度解耦特性，实现 NgRx 可能会令人困惑，这可能需要了解库的内部工作原理。
- en: The sample project under `projects/stage12` configures `@ngrx/store-devtools`
    for debugging.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`projects/stage12`下的示例项目配置了`@ngrx/store-devtools`进行调试。
- en: If you would like to be able to `console.log` NgRx actions for debugging or
    instrumentation during runtime, you can use a MetaReducer as described in the
    NgRx documentation, [https://ngrx.io/guide/store/metareducers](https://ngrx.io/guide/store/metareducers).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在运行时能够`console.log` NgRx 动作进行调试或监控，可以使用 NgRx 文档中描述的 MetaReducer，[https://ngrx.io/guide/store/metareducers](https://ngrx.io/guide/store/metareducers)。
- en: Defining NgRx actions
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 NgRx 动作
- en: 'Before we can implement effects or reducers, we first need to define the actions
    our app will be able to execute. For LocalCast Weather, there are two types of
    actions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够实现影响或还原器之前，我们首先需要定义我们的应用程序将能够执行的动作。对于 LocalCast Weather，有两种类型的动作：
- en: '`search`: Fetches the current weather for the city or zip code that’s being
    searched'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search`：获取正在搜索的城市或邮编的当前天气'
- en: '`weatherLoaded`: Indicates that new current weather information has been fetched'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weatherLoaded`：表示已获取新的当前天气信息'
- en: 'Create an action named `search` by running the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建名为`search`的动作：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Take the default options when prompted.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时选择默认选项。
- en: The `--group` option groups actions under a folder named `action`. The `--creators`
    option uses creator functions to implement actions and reducers, which is a more
    familiar and straightforward way to implement these components.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`--group`选项将动作分组在名为`action`的文件夹下。`--creators`选项使用创建函数来实现动作和还原器，这是一种更熟悉且直接的方式来实现这些组件。'
- en: 'Now, let’s implement the two actions using the `createAction` function, providing
    a name and an expected list of input parameters:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`createAction`函数实现这两个动作，提供名称和预期的输入参数列表：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The search action has the name `'[Search] Search'` and has `searchText` and
    an optional `country` parameter as inputs. The `weatherLoaded` action follows
    a similar pattern. At the end of the file, we create a union type of actions,
    so we can group them under one parent type to use in the rest of the application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索操作名为`'[Search] Search'`，输入参数包括`searchText`和一个可选的`country`参数。`weatherLoaded`操作遵循类似的模式。在文件末尾，我们创建了一个动作的联合类型，这样我们就可以将它们分组在单个父类型下，以便在应用程序的其余部分中使用。
- en: Notice that action names are prepended by `[Search]`. This convention helps
    developers visually group related actions together during debugging.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，动作名称前缀为`[Search]`。这个约定有助于开发者在调试期间视觉上分组相关的动作。
- en: Now that our actions are deﬁned, we can implement the effect to handle the search
    action and dispatch a `weatherLoaded` action.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了动作，我们可以实现影响来处理搜索动作并分发一个`weatherLoaded`动作。
- en: Implementing NgRx effects
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 NgRx 影响
- en: As mentioned earlier, effects let us change the stored state without necessarily
    storing the event data causing the change. For example, we want our state only
    to have weather data, not the search text itself. Effects allow us to do this
    in one step, rather than forcing us to use an intermediate store for the `searchText`
    and a far more complicated chain of events to turn that into weather data.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，影响允许我们更改存储的状态，而无需存储导致更改的事件数据。例如，我们希望我们的状态只有天气数据，而不是搜索文本本身。影响允许我们一步完成此操作，而不是强迫我们使用中间存储来存储`searchText`，以及一个更复杂的链式事件来将其转换为天气数据。
- en: Otherwise, we would have to implement a reducer in between. We first need to
    store this value in the NgRx store, then retrieve it from a service, and finally
    dispatch a `weatherLoaded` action. The effect will make it simpler to retrieve
    data from the service.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们可能需要在中间实现一个还原器。我们首先需要将此值存储在 NgRx 存储中，然后从服务中检索它，最后分发一个`weatherLoaded`动作。影响将使从服务中检索数据变得更加简单。
- en: 'Now let’s add `CurrentWeatherEffects` to our app:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`CurrentWeatherEffects`添加到我们的应用程序中：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Take the default options when prompted.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时选择默认选项。
- en: You will have a new `current-weather.effects.ts` file under the `effects` folder.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在`effects`文件夹下创建一个新的`current-weather.effects.ts`文件。
- en: Once again, `--group` is used to group effects under a folder of the same name.
    `--root` registers the effect in `app.module.ts` and we use creator functions
    with the `--creators` option.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`--group`用于将影响分组在同名文件夹下。`--root`将影响注册到`app.module.ts`中，我们使用带有`--creators`选项的创建函数。
- en: 'In the `CurrentWeatherEffects` ﬁle, start by implementing a private `doSearch`
    method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CurrentWeatherEffects`文件中，首先实现一个私有的`doSearch`方法：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we’re choosing to ignore errors thrown with the `EMPTY` function.
    You can surface these errors to the user with a `UiService` like the one you’ve
    implemented for LemonMart.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们选择忽略由`EMPTY`函数抛出的错误。您可以使用类似于为LemonMart实现的`UiService`将这些错误暴露给用户。
- en: This function takes an action with search parameters, calls `getCurrentWeather`,
    and upon receiving a response, dispatches the `weatherLoaded` action, passing
    in the current weather property.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个带有搜索参数的操作，调用`getCurrentWeather`，并在收到响应后，派发`weatherLoaded`操作，传递当前天气属性。
- en: 'Now let’s create the effect itself, so we can trigger the `doSearch` function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建效果本身，这样我们就可以触发`doSearch`函数：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is where we tap into the Observable action stream, `this.actions$`, and
    listen to actions of the `SearchAction.search` type. We then use the `exhaustMap`
    operator to register for the emitted event.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们利用Observable操作流`this.actions$`并监听`SearchAction.search`类型操作的地方。然后我们使用`exhaustMap`操作符来注册发射的事件。
- en: Due to its unique nature, `exhaustMap` won’t allow another search action to
    be processed until the `doSearch` function completes dispatching its `weatherLoaded`
    action.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其独特的性质，`exhaustMap`不会允许在`doSearch`函数完成派发`weatherLoaded`操作之前处理另一个搜索操作。
- en: Impact of RxJS operators on actions
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RxJS操作符对操作的影响
- en: In the preceding example, I used the `exhaustMap` operator. This is not necessarily
    the correct RxJS operator for this use case, `switchMap` is. I selected `exhaustMap`
    with the express purpose of limiting the number of API calls generated toward
    a free resource, which can aggressively rate limit requests.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我使用了`exhaustMap`操作符。这并不一定是这个用例的正确RxJS操作符，`switchMap`才是。我选择`exhaustMap`的明确目的是为了限制对免费资源生成的API调用数量，这样可以积极限制请求的速率。
- en: 'Let’s explore four RxJS operators we can choose from:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索我们可以选择的四个RxJS操作符：
- en: '`mergeMap`: Allows for handling multiple actions in parallel, ideal for scenarios
    where each action’s effect is independent and doesn’t need to be synchronized.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mergeMap`：允许并行处理多个操作，适用于每个操作的效果是独立且不需要同步的场景。'
- en: '`concatMap`: Processes actions in sequence, starting the next one only after
    the previous action is complete, ensuring actions are handled in the order they
    were dispatched, which is useful for maintaining consistency in state updates.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`concatMap`：按顺序处理操作，只有在前一个操作完成之后才开始下一个操作，确保操作按它们被派发的顺序处理，这对于在状态更新中保持一致性很有用。'
- en: '`switchMap`: On receiving a new action, it cancels the previous one and switches
    to the new one, which is suitable for use cases like search bar inputs where only
    the latest action (e.g., user input) is relevant.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switchMap`：在接收到新操作时，取消之前的操作并切换到新的操作，这对于搜索栏输入等用例非常合适，在这些用例中，只有最新的操作（例如，用户输入）是相关的。'
- en: '`exhaustMap`: Ignores new actions if one is already being processed, making
    it useful for avoiding duplicate or conflicting requests, such as multiple submissions
    of the same form.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`exhaustMap`：如果已有操作正在处理，则忽略新操作，这使得它对于避免重复或冲突请求很有用，例如，多次提交相同的表单。'
- en: With `exhaustMap`, if actions are created rapidly before the `doSearch` function
    completes, the actions that haven’t been processed will be dropped. So, if actions
    *a*, *b*, *c*, *d*, and *e* are created, but `doSearch` completes between when
    *c* and *d* were created, then actions *b*, *c*, and *e* are never processed,
    but action *d* will be. API calls for *b*, *c*, and *e* are never made. Only a
    `weatherLoaded` action for *d* is dispatched. While we avoid making unnecessary
    API calls for results users will never see, the end state will confuse the user.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`exhaustMap`，如果`doSearch`函数在创建操作之前快速创建，则尚未处理的操作将被丢弃。所以，如果创建了操作*a*、*b*、*c*、*d*和*e*，但`doSearch`在*c*和*d*创建之间完成，那么操作*b*、*c*和*e*将永远不会被处理，但操作*d*将会被处理。对于*b*、*c*和*e*的API调用永远不会发生。只有为*d*发出的`weatherLoaded`操作。虽然我们避免了为用户永远不会看到的成果进行不必要的API调用，但最终状态可能会让用户感到困惑。
- en: Using `mergeMap`, all search actions are processed in parallel, API calls made,
    and `weatherLoaded` actions dispatched. So, if actions *a*, *b*, *c*, *d*, and
    *e* are created rapidly. The user may see flashes of results from all actions,
    but the last one displayed will be *e*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mergeMap`，所有搜索操作都是并行处理的，进行API调用，并派发`weatherLoaded`操作。所以，如果快速创建了操作*a*、*b*、*c*、*d*和*e*，用户可能会看到所有操作的闪烁结果，但最后显示的是*e*。
- en: With `concatMap`, actions are processed sequentially. Considering actions *a*,
    *b*, *c*, *d*, and *e*, the API call for *b* isn’t made until after the `weatherLoaded`
    action is dispatched for *a* and the result is rendered. This will happen for
    each action until the weather for *e* is displayed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`concatMap`，动作按顺序处理。考虑到动作*a*、*b*、*c*、*d*和*e*，对于*b*的API调用不会在为*a*分发了`weatherLoaded`动作并渲染结果之后进行。这将为每个动作发生，直到显示*e*的天气。
- en: With `switchMap`, API calls will be made with each action. However, only the
    last action will be dispatched, so the user will only see the last action displayed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`switchMap`，每个动作都会进行API调用。然而，只有最后一个动作会被分发，所以用户只会看到最后一个动作显示。
- en: So, from a UX perspective, `switchMap` is functionally the correct implementation.
    You could also implement a loading spinner or disable user input while data is
    processed to prevent expensive API calls.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从UX的角度来看，`switchMap`在功能上是正确的实现。您还可以在数据处理时实现加载指示器或禁用用户输入，以防止昂贵的API调用。
- en: Ultimately, depending on your use case and UX needs, consider a different RxJS
    operator. Not all dispatched actions result in a screen that needs to be rendered.
    If you wanted to retain all data input, you could process actions in a service
    worker background thread and update a notification panel or a badge with a counter
    in your app.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，根据您的用例和UX需求，考虑使用不同的RxJS操作符。并非所有分发的动作都会导致需要渲染的屏幕。如果您想保留所有数据输入，您可以在服务工作者后台线程中处理动作，并更新应用中的通知面板或徽章计数器。
- en: Implementing reducers
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现reducers
- en: With the `weatherLoaded` action triggered, we need a way to ingest the current
    weather information and store it in our `appStore` state. Reducers will help us
    handle specific actions, creating an isolated and immutable pipeline to store
    our data predictably.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发`weatherLoaded`动作时，我们需要一种方法来摄取当前天气信息并将其存储在我们的`appStore`状态中。Reducer将帮助我们处理特定动作，创建一个隔离且不可变的管道以可预测地存储我们的数据。
- en: 'Let’s create a `search` reducer:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`search`reducer：
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Take the default options. Here, we use `--group` to keep files organized under
    the `reducers` folder and `--creators` to leverage the creator style of creating
    NgRx code. We also specify the location of our parent `appStore` state at `reducers/index.ts`
    with `--reducers`, so our new reducer can be registered with it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认选项。在这里，我们使用`--group`来保持文件在`reducers`文件夹下组织，并使用`--creators`来利用创建NgRx代码的创建者风格。我们还使用`--reducers`指定我们的父`appStore`状态的位置在`reducers/index.ts`，以便我们的新reducer可以与之注册。
- en: You may observe that `reducers.index.ts` has been updated to register the new
    `search.reducer.ts`. Let’s implement it step by step.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到`reducers.index.ts`已更新以注册新的`search.reducer.ts`。让我们一步一步实现它。
- en: 'In the `search` state, we will be storing the current weather, so implement
    the interface to reﬂect this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在`search`状态中，我们将存储当前天气，因此实现接口以反映这一点：
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now let’s specify the `initialState`. This is similar to how we need to define
    a default value of a `signal` or `BehaviorSubject`. Refactor the `WeatherService`
    to export a `const defaultWeather: ICurrentWeather` object that you can use to
    initialize `BehaviorSubject` and `initialState`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们指定`initialState`。这类似于我们需要定义`signal`或`BehaviorSubject`的默认值。重构`WeatherService`以导出`const
    defaultWeather: ICurrentWeather`对象，您可以使用它来初始化`BehaviorSubject`和`initialState`：'
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, implement `searchReducer` to handle the `weatherLoaded` action using
    the `on` operator:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`on`操作符实现`searchReducer`来处理`weatherLoaded`动作：
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We register for the `weatherLoaded` action, unwrap the stored data, and pass
    it into the `search` state.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册了`weatherLoaded`动作，解包存储的数据，并将其传递到`search`状态。
- en: This is, of course, a very simplistic case. However, it is easy to imagine a
    more complicated scenario where we may need to flatten or process a piece of data
    received and store it in an easy-to-consume manner. Isolating such logic in an
    immutable way is the key value proposition of utilizing a library like NgRx.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个非常简单的例子。然而，很容易想象一个更复杂的场景，我们可能需要扁平化或处理接收到的数据并将其以易于消费的方式存储。以不可变的方式隔离这种逻辑是利用像NgRx这样的库的关键价值主张。
- en: Registering with Store using selector
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选择器在Store中注册
- en: We need `CurrentWeatherComponent` to register with the `appStore` state for
    updated current weather data.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`CurrentWeatherComponent`注册到`appStore`状态以获取更新的当前天气数据。
- en: 'Start by dependency injecting the `appStore` state and registering the selector
    to pluck current weather from the `State` object:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，依赖注入`appStore`状态并注册选择器以从`State`对象中提取当前天气：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We listen to state change events that flow through the store. Using the `select`
    function, we can implement an inline select to get the data we need.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们监听通过存储流动的状态变化事件。使用`select`函数，我们可以实现内联选择以获取所需的数据。
- en: 'We can refactor this a bit and make our selector reusable by using a `createSelector`
    to create a `selectCurrentWeather` property on `reducers/index.ts`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍作重构，通过使用`createSelector`在`reducers/index.ts`上创建`selectCurrentWeather`属性来使我们的选择器可重用：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As the number of TypeScript interfaces and NgRx selectors increases, you should
    break them into separate files and organize your code better.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 随着TypeScript接口和NgRx选择器的数量增加，您应该将它们拆分为单独的文件，并更好地组织您的代码。
- en: 'In addition, since we want to maintain the continued operation of `BehaviorSubject`,
    we can implement a `merge` operator in `CurrentWeatherComponent` to listen to
    both `WeatherService` updates and `appStore` state updates:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们希望保持`BehaviorSubject`的持续操作，我们可以在`CurrentWeatherComponent`中实现一个`merge`运算符来监听`WeatherService`更新和`appStore`状态更新：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we can listen to store updates, let’s implement the final puzzle piece:
    dispatching the search action.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够监听存储更新，让我们实现最终的拼图碎片：分发搜索动作。
- en: Dispatching store actions
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发存储动作
- en: We need to dispatch the search action so that our search effect can fetch the
    current weather data and update the store. Earlier in this chapter, you implemented
    a stubbed function called `ngRxBasedSearch` in the `CitySearchComponent`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要分发搜索动作，以便我们的搜索效果可以获取当前天气数据并更新存储。在本章的早期，您在`CitySearchComponent`中实现了一个名为`ngRxBasedSearch`的存根函数。
- en: 'Let’s implement `ngRxBasedSearch`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现`ngRxBasedSearch`：
- en: '[PRE36]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Don’t forget to inject the `appState` store into the component!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`appState`存储注入到组件中！
- en: And that’s it! Now you should be able to run your code and test to see whether
    it all works.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在您应该能够运行您的代码并测试是否一切正常。
- en: As you can see, NgRx brings a lot of sophisticated techniques to the table to
    create ways to make data transformations immutable, well deﬁned, and predictable.
    However, this comes with considerable implementation overhead.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，NgRx带来了许多复杂的技巧来创建使数据转换不可变、定义良好和可预测的方法。然而，这伴随着相当大的实现开销。
- en: Use your best judgment to determine whether you need the Flux pattern in your
    Angular app. The frontend application code can often be made much simpler by implementing
    RESTful APIs that return ﬂat data objects, with complicated data manipulations
    handled server side, reducing, if not eliminating, the need for tools like NgRx.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的最佳判断来决定您是否需要在您的Angular应用程序中使用Flux模式。前端应用程序代码可以通过实现返回平面数据对象的RESTful API而变得简单得多，复杂的数据操作由服务器端处理，从而减少，如果不是消除，对像NgRx这样的工具的需求。
- en: Unit testing reducers and selectors
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试reducer和选择器
- en: 'You can implement unit tests for the `weatherLoaded` reducer and the `selectCurrentWeather`
    selector in `search.reducer.spec.ts`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`search.reducer.spec.ts`中对`weatherLoaded`reducer和`selectCurrentWeather`选择器实现单元测试：
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These unit tests are straightforward and will ensure that no unintentional changes
    to the data structure can happen within the store.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单元测试很简单，将确保在存储中不会发生对数据结构的意外更改。
- en: Unit testing components with MockStore
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MockStore单元测试组件
- en: You need to update the tests for `CurrentWeatherComponent` so that we can inject
    a mock `Store` into the component to test the value of the `current$` property.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要更新`CurrentWeatherComponent`的测试，以便我们可以将模拟的`Store`注入到组件中以测试`current$`属性的值。
- en: 'Let’s look at the delta of what needs to be added to the `spec` file to configure
    the mock store:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看需要添加到`spec`文件中的delta，以配置模拟存储：
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can now update the `''should get currentWeather from weatherService''` test
    to see whether `CurrentWeatherComponent` works with a mock store:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新`'should get currentWeather from weatherService'`测试，以查看`CurrentWeatherComponent`是否与模拟存储一起工作：
- en: '[PRE39]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The mock store allows us to set the store’s current state, which in turn allows
    the selector to call in the constructor to fire and grab the provided fake weather
    data.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟存储允许我们设置存储的当前状态，这反过来又允许选择器在构造函数中调用以触发并获取提供的虚假天气数据。
- en: '`TestBed` is not a hard requirement for writing unit tests in Angular, a topic
    covered well at [https://angular.dev/guide/testing](https://angular.dev/guide/testing).
    My colleague and reviewer of the 2^(nd) edition, Brendon Caulkins, contributed
    a bedless `spec` file for this chapter, named `current-weather.component.nobed.spec.ts`.
    He cites significant performance increases when running the tests, with fewer
    imports and less maintenance, but a higher level of care and expertise required
    to implement the tests. If you’re on a large project, consider skipping `TestBed`.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestBed` 并非在 Angular 中编写单元测试的硬性要求，关于这个话题在 [https://angular.dev/guide/testing](https://angular.dev/guide/testing)
    有很好的介绍。我的同事和第二版的审稿人布伦登·考林斯为这一章贡献了一个无床的 `spec` 文件，名为 `current-weather.component.nobed.spec.ts`。他提到在运行测试时，由于减少了导入和维护，性能有显著提升，但需要更高水平和专业知识来实现测试。如果你在一个大型项目中，考虑跳过
    `TestBed`。'
- en: The sample code on GitHub is under the `projects/stage12` folder.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 上的示例代码位于 `projects/stage12` 文件夹下。
- en: Go ahead and update the remainder of your tests, and do not move on until they
    all start passing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 继续更新你剩余的测试，直到它们全部通过后再继续。
- en: NgRx ecosystem
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgRx 生态系统
- en: Now that you understand NgRx better beyond just theory, let’s examine the different
    available options within the ecosystem.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 NgRx 的理解已经超越了理论层面，让我们来检查生态系统中的不同可用选项。
- en: 'Here are some popular options from the community, including sibling packages
    from NgRx:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些社区中流行的选项，包括 NgRx 的兄弟包：
- en: '**NgRx/Data**, a gentle introduction to NgRx with simplified entity management'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NgRx/Data**，一个简化实体管理的 NgRx 入门'
- en: '**NgRx/ComponentStore**, a component-scoped version of NgRx/Store with less
    boilerplate'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NgRx/ComponentStore**，NgRx/Store的组件范围版本，减少了样板代码'
- en: '**NgRx/SignalStore**, the next generation of state management in Angular'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NgRx/SignalStore**，Angular 中下一代状态管理'
- en: '**Akita**, a reactive state management offering tailor-made for JS applications'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Akita**，为 JS 应用量身定制的响应式状态管理解决方案'
- en: '**Elf**, a reactive store with magical powers'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Elf**，一个具有神奇力量的响应式存储'
- en: Let’s explore these options.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些选项。
- en: NgRx/Data
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NgRx/Data
- en: If NgRx is a configuration-based framework, NgRx Data is a convention-based
    sibling of NgRx. NgRx Data automates the creation of stores, effects, actions,
    reducers, dispatches, and selectors. If most of your application actions are **CRUD**
    (**Create**, **Retrieve**, **Update**, and **Delete**) operations, then NgRx Data
    can achieve the same result as NgRx with much less code needing to be written.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 NgRx 是基于配置的框架，那么 NgRx Data 就是 NgRx 的基于约定的兄弟。NgRx Data 自动创建存储、效果、动作、还原器、分发和选择器。如果你的应用程序的大部分动作是
    **CRUD**（**创建**、**检索**、**更新**和**删除**）操作，那么 NgRx Data 可以用更少的代码实现与 NgRx 相同的结果。
- en: '`@ngrx/data` works in tandem with the `@ngrx/entity` library. Together they
    offer a rich feature set, including transactional data management.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ngrx/data` 与 `@ngrx/entity` 库协同工作。它们共同提供了一套丰富的功能，包括事务性数据管理。'
- en: NgRx Data may be a much better introduction to the Flux pattern for you and
    your team, allowing an easy ramp-up for the full NgRx framework. Unfortunately,
    NgRx Data is no longer recommended for new projects.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx Data 可能是你和你的团队更好地了解 Flux 模式的一个很好的入门，它允许轻松地过渡到完整的 NgRx 框架。不幸的是，NgRx Data
    已不再推荐用于新项目。
- en: As of version 17, NgRx Data is officially in maintenance mode, and it’s not
    recommended for new projects or adding to existing projects.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 17 版本，NgRx Data 正式进入维护模式，不推荐用于新项目或添加到现有项目中。
- en: You can read more about it at [https://ngrx.io/guide/data](https://ngrx.io/guide/data).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://ngrx.io/guide/data](https://ngrx.io/guide/data) 上了解更多相关信息。
- en: 'You can add NgRx Data to your project by executing the following commands:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下命令将 NgRx Data 添加到你的项目中：
- en: '[PRE40]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So, should you implement NgRx Data in your next app? It depends, but probably
    not, given its maintenance mode status. Since the library is an abstraction layer
    on top of NgRx, you may find yourself lost and restricted if you don’t have a
    good understanding of the internals of NgRx. However, the library holds much promise
    for reducing boilerplate code regarding entity data management and CRUD operations.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你应在你的下一个应用中实现 NgRx Data 吗？这取决于情况，但鉴于其维护模式的状态，可能不太适合。由于这个库是 NgRx 之上的抽象层，如果你没有很好地理解
    NgRx 的内部结构，你可能会感到迷茫和受限。然而，这个库在减少实体数据管理和 CRUD 操作的样板代码方面有很大的潜力。
- en: If you’re doing lots of CRUD operations in your app, you may save time, but
    be careful to limit the scope of your implementation to the areas that need it.
    As the NgRx documentation highlights, NgRx Data lacks many capabilities of a full-featured
    entity management system, like deep entity cloning, server-side querying, relationships,
    key generation, and non-normalized server responses.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在应用程序中执行大量CRUD操作，你可能可以节省时间，但请注意将实现范围限制在需要它的区域。正如NgRx文档所强调的，NgRx Data缺乏许多功能齐全的实体管理系统功能，如深度实体克隆、服务器端查询、关系、键生成和非规范化服务器响应。
- en: For a full-featured entity management library, consider BreezeJS [https://www.getbreezenow.com/breezejs](https://www.getbreezenow.com/breezejs).
    However, beware that Breeze doesn’t adhere to reactive, immutable, and redux principles
    as NgRx does.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个功能齐全的实体管理库，可以考虑BreezeJS [https://www.getbreezenow.com/breezejs](https://www.getbreezenow.com/breezejs)。然而，请注意Breeze并不遵循NgRx所采用的响应式、不可变和Redux原则。
- en: Next, let’s investigate ComponentStore for a less demanding and more focused
    application of the Flux pattern.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们调查ComponentStore在Flux模式更不具挑战性和更专注的应用。
- en: NgRx/ComponentStore
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NgRx/ComponentStore
- en: NgRx ComponentStore offers a lightweight, reactive state management solution
    ideal for local state within components or modules.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx ComponentStore提供了一种轻量级、响应式的状态管理解决方案，非常适合组件或模块内的本地状态。
- en: It’s designed to manage local state without needing a global store, maintaining
    a clean separation of concerns, and making components simple and maintainable.
    This approach is particularly useful for complex components with many local states
    and interactions, as it allows for push-based services that manage this state
    with the component’s lifecycle, supporting reusability and independent instances.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 它旨在在不需要全局存储的情况下管理本地状态，保持关注点的清晰分离，并使组件简单易维护。这种方法对于具有许多本地状态和交互的复杂组件尤其有用，因为它允许基于推的服务管理此状态，支持可重用性和独立实例。
- en: 'You can implement the data source of your paginated data table using `ComponentStore`,
    similar to how this is done with Elf. Check out this excellent two-part blog post
    by Pierre Bouillon: [https://dev.to/this-is-angular/handling-pagination-with-ngrx-component-stores-1j1p](https://dev.to/this-is-angular/handling-pagination-with-ngrx-component-stores-1j1p).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`ComponentStore`实现分页数据表的dataSource，类似于使用Elf的方式。查看Pierre Bouillon这篇出色的两篇博客文章：[https://dev.to/this-is-angular/handling-pagination-with-ngrx-component-stores-1j1p](https://dev.to/this-is-angular/handling-pagination-with-ngrx-component-stores-1j1p)。
- en: In contrast, NgRx Store manages a global shared state and is beneficial for
    larger applications requiring scalability, multiple effects, and DevTools integration.
    ComponentStore, while less scalable and with many updaters and effects, ensures
    type safety, performance, and ease of testing, allowing for a more encapsulated
    and component-specific state management.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，NgRx Store管理全局共享状态，对需要可扩展性、多个效果和DevTools集成的较大应用程序有益。虽然ComponentStore的可扩展性较低，并且有许多更新器和效果，但它确保了类型安全、性能和易于测试，从而允许更封装和组件特定的状态管理。
- en: The choice between `ComponentStore` and `Store` hinges on the application’s
    size, component dependencies, state longevity, and business requirements, among
    other factors.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ComponentStore`和`Store`之间的选择取决于应用程序的大小、组件依赖、状态持久性和业务需求等因素。
- en: Read more about ComponentStore at [https://ngrx.io/guide/component-store](https://ngrx.io/guide/component-store).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://ngrx.io/guide/component-store](https://ngrx.io/guide/component-store)了解更多关于ComponentStore的信息。
- en: 'You can add ComponentStore to your project by executing the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下操作将ComponentStore添加到你的项目中：
- en: '[PRE41]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In short, `ComponentStore` is an alternative to the “Service with a Subject”
    approach we’ve covered in the book. However, with Angular’s architecture shifting
    toward Signals, you may want to skip the `ComponentStore` and implement `SignalStore`
    instead.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`ComponentStore`是本书中提到的“带有Subject的服务”方法的替代方案。然而，随着Angular架构向信号转变，你可能想要跳过`ComponentStore`并实现`SignalStore`。
- en: NgRx/Signals
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NgRx/Signals
- en: I introduced you to signals in the *Using Angular signals* section of *Chapter
    2*, *Forms, Observables, Signals, and Subjects*. NgRx/Signals is a self-contained
    library offering a reactive state management solution alongside a suite of utilities
    for working with Angular Signals. It’s architected for simplicity, presenting
    an intuitive API for developers. Its lightweight nature ensures minimal load on
    applications while maintaining high performance.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章“表单、可观察者、信号和主题”的“使用 Angular 信号”部分，我向您介绍了信号。NgRx/Signals 是一个自包含的库，它提供了一个反应式状态管理解决方案，并附带了一套用于处理
    Angular 信号的实用工具。它旨在简单易用，为开发者提供了一个直观的 API。其轻量级特性确保了应用程序负载最小，同时保持高性能。
- en: The library champions declarative programming, fostering clean and concise code.
    It facilitates the crafting of autonomous components that are easily integrated,
    promoting scalable and flexible applications. Additionally, it enforces type safety,
    mitigating errors early in the development cycle.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 该库推崇声明式编程，培养简洁的代码。它促进了自主组件的构建，这些组件易于集成，促进了可扩展和灵活的应用程序。此外，它强制执行类型安全，在开发周期的早期阶段减少错误。
- en: 'The library includes the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 该库包括以下内容：
- en: SignalStore is a robust state management system bringing the best of both worlds
    from NgRx/Store and NgRx/ComponentStore.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SignalStore 是一个强大的状态管理系统，它从 NgRx/Store 和 NgRx/ComponentStore 中汲取了最佳之处。
- en: SignalState is a streamlined utility for managing state within Angular components
    and services overtaking any need for self-managed signal properties in service.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SignalState 是一个简化的实用工具，用于在 Angular 组件和服务中管理状态，它取代了服务中任何需要自行管理的信号属性。
- en: '`rxMethod` provides opt-in usage to interact with Observables. Useful for interacting
    with existing code.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxMethod` 提供了可选的使用方式来与 Observables 交互。这对于与现有代码交互非常有用。'
- en: '`withEntities` is an entity management plugin offering an efficient approach
    to facilitate CRUD operations for managing entities.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withEntities` 是一个实体管理插件，提供了一种高效的方法来促进 CRUD 操作，以管理实体。'
- en: We will investigate SignalState and SignalStore in depth in the upcoming sections.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中深入探讨 SignalState 和 SignalStore。
- en: Read more about NgRx Signals at [https://ngrx.io/guide/signals](https://ngrx.io/guide/signals).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://ngrx.io/guide/signals](https://ngrx.io/guide/signals) 上了解更多关于
    NgRx Signals 的信息。
- en: 'You can add SignalStore to your project by executing:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下命令将 SignalStore 添加到您的项目中：
- en: '[PRE42]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let’s round up our state management ecosystem tour with some popular non-NgRx
    options, Akita and Elf.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些流行的非 NgRx 选项，如 Akita 和 Elf，来结束我们的状态管理生态系统之旅。
- en: Akita
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Akita
- en: Akita is a state management solution combining Flux, Redux, and RxJS concepts
    into the Observable Data Store model, favoring immutability and streaming data.
    It emphasizes simplicity, reduces boilerplate code, and is accessible to developers
    at all levels due to its moderate learning curve. Akita adopts object-oriented
    principles, making it intuitive for those familiar with OOP, and enforces a consistent
    structure to guide and standardize team development practices.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Akita 是一个将 Flux、Redux 和 RxJS 概念结合到可观察数据存储模型中的状态管理解决方案，它倾向于不可变性和流式数据。它强调简单性，减少了样板代码，由于其适中的学习曲线，使得所有级别的开发者都能轻松上手。Akita
    采用面向对象原则，对于那些熟悉面向对象编程的人来说，它使代码更加直观，并强制执行一致的结构来指导和标准化团队的开发实践。
- en: Akita is built around RxJS/`BehaviorSubject` and provides specialized classes
    for state management, such as `Store`, `Query`, and `EntityStore`. Like NgRx,
    Akita exposes state changes as RxJS Observables and utilizes the update method
    for state mutations, enabling an OOP style for state management.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Akita 围绕 RxJS 的 `BehaviorSubject` 构建，并为状态管理提供了专门的类，如 `Store`、`Query` 和 `EntityStore`。与
    NgRx 类似，Akita 将状态变化暴露为 RxJS Observables，并使用更新方法进行状态突变，从而实现面向对象的状态管理风格。
- en: It’s worthwhile to experiment with Akita if you’re looking for a simpler solution
    with built-in entity management, plugins for state history, server-side pagination,
    more OOP versus functional, and, overall, less boilerplate code.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找一个具有内置实体管理、状态历史记录插件、服务器端分页、更多面向对象而非函数式，以及总体上更少的样板代码的简单解决方案，那么尝试 Akita
    是值得的。
- en: You can learn more about Akita at [https://opensource.salesforce.com/akita/](https://opensource.salesforce.com/akita/).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://opensource.salesforce.com/akita/](https://opensource.salesforce.com/akita/)
    上了解更多关于 Akita 的信息。
- en: Elf
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Elf
- en: Elf is the most magical option of the bunch. It’s a newer state management library
    for Angular that aims to simplify reactivity and state mutations with a minimalistic
    API, focusing on ergonomics and ease of use. It uses modern RxJS patterns for
    state management, enabling fine-grained control over state changes and reactivity.
    Elf is designed to be lightweight and straightforward, offering a simpler alternative
    to the more comprehensive NgRx suite.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Elf is modular, fully tree-shakable, and provides first-class support for the
    following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '**Request cache** to prevent redundant API calls.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entities** such as NgRx/Data or Akita.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State persistence** for offline-first applications.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State history** for easy undo/redo functionality.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced pagination** to optimize fetching and caching of paginated data'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elf integrates features and best practices for building reactive web apps with
    statement management and makes them easy. While features like pagination support
    can be implemented using NgRx/ComponentStore, the built-in pagination caching
    support is impressive. In addition, Elf has a plugin to sync state across browser
    tabs, enabling truly advanced state management.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the number of built-in and high-quality features that ship with Elf, it
    is a standout solution that may be the right option for your next project. You
    can learn more about Elf at [https://ngneat.github.io/elf/](https://ngneat.github.io/elf/).
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve covered the nuances of the NgRx ecosystem. Let’s learn how you can configure
    proxies with Angular to deal with convention-based state management libraries
    that expect a certain way to access server-side data.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Configuring server proxies with the Angular CLI
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some state management libraries, especially convention-based entity stores like
    NgRx Data, make assumptions about accessing server-side data. In the case of NgRx
    Data, the library wants to access the REST API via the `/api` path hosted on the
    same port as your Angular app. We must leverage the Angular CLI’s proxy feature
    to accomplish this during development.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, HTTP requests are sent to our web server, and our API server should
    have the same URL. However, during development, we usually host both applications
    on two different ports of `http://localhost`. Certain libraries, including NgRx
    Data, require that HTTP calls be on the same port. This creates a challenge for
    creating a frictionless development experience. For this reason, the Angular CLI
    ships with a proxy feature with which you can direct the `/api` path to a different
    endpoint on your localhost. This way, you can use one port to serve your web app
    and your API requests:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `proxy.conf.json` file under `src`, as shown:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’re working in the **lemon-mart-server** monorepo, this will be `web-app/src`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Register the proxy with `angular.json`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now the server that is started when you run `npm start` or `ng serve` can rewrite
    the URLs of any call made to the `/api` route with `http://localhost:3000`. This
    is the port that **lemon-mart-server** runs by default.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Use the correct port number and child route if your API is running on a different
    port.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a global spinner with NgRx/SignalState
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Multi-step responsive forms* section of *Chapter 8*, *Recipes – Reusability,
    Forms, and Caching*, and the *Data tables with pagination* section earlier in
    this chapter, I discussed the differences between localized spinners and global
    ones. A global spinner is the ultimate 80-20 solution to paper over UX issues
    stemming from UI elements not being ready for interaction while data loads. However,
    this will cause excessive full-screen interruptions in large applications with
    multiple on-screen components or background service workers loading data. In that
    case, most components will require local spinners instead.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let’s go after the 80-20 solution. We can use an `HttpInterceptor`
    to detect when an API call is made within the application. This allows us to show
    or hide a global spinner. However, if multiple calls are made concurrently, we
    must keep track of this, otherwise the global spinner may behave erratically.
    With NgRx/SignalState, we can keep track of the number of calls without introducing
    the local state in a service.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: NgRx/SignalState
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SignalState is a lightweight utility provided by `@ngrx/signals` for managing
    signal-based state in Angular components and services in a concise and minimalistic
    manner. It is used to create and operate on small slices of state directly in
    your component class, service, or a standalone function. You can provide a deeply
    nested signal of the object properties.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'SignalState should be used within a component or service to manage simple state.
    The library offers the following functions:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '`signalState` is a utility function that takes the initial state of the store
    and defines the shape of the state.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patchState` updates the stored value.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about NgRx SignalState at [https://ngrx.io/guide/signals/signal-state](https://ngrx.io/guide/signals/signal-state).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by adding `signalState`, `computed` `signal`, `showLoader`, and `hideLoader`
    functions to `UiService`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify UiService as shown:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We start by defining a private `signalState` and initializing the `count` and
    `isLoading` properties. The state should always be encapsulated within the boundaries
    it’s being used to avoid uncontrolled side effects. As we cover in the next section,
    SignalStore is a more robust solution to manage side effects. However, we want
    `isLoading` to be publicly available, so a UI component can bind it to hide or
    display the spinner. So, we implement a `computed` signal, which acts as a selector
    to return the current value of `isLoading` in a read-only manner.
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`patchState` is a utility function that provides a type-safe way to perform
    immutable updates on pieces of state. We use it to update the values of `count`
    and `isLoading`, whenever `show` or `hide` functions are called.'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, implement `LoadingHttpInterceptor` under `src/common` to call the `show`
    and `hide` methods:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We inject `UiService` and call `showLoader` to increment the count by one. We
    then set up the finalize operator, so when the API call is finished `hideLoader`
    is called to decrement the count by one. So, whenever a loader function is called
    and the count is equal to zero, we know we either need to show or hide the spinner.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Don’t forget to provide the new interceptor in `app.config.ts`.
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a `LoadingOverlayComponent` under common and use `isLoading` to
    show or hide a spinner:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We inject and use the computed `isLoading` signal from `UiService`. With the
    `@if` flow control, the spinner will be shown or hidden depending on whether `isLoading`
    is set to true or false.
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The use of `ViewEncapsulation.ShadowDom` in Angular allows component styles
    to be encapsulated within a Shadow DOM. By default, Angular uses an emulated mode
    to scope styles to components. However, the Shadow DOM encapsulation provides
    more robust support for dynamic CSS features.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, update `app.component.ts` to import and place the new component at
    the top of the template:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Give it a try. A glorious lemon spinner will take over the screen whenever an
    API call is made.![A screenshot of a lemon login  Description automatically generated](img/B20960_09_10.png)
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.10: LemonMart’s lemon spinner'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This resolves the data pop-in issues in the user profile form mentioned in *Chapter
    8*, *Recipes – Reusability, Forms, and Caching*.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are your API calls happening too quickly to appreciate the spinner?
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In **lemon-mart-server**, you can add a two-second delay:'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Or you can slow things down in your browser’s DevTools **Network** tab by changing
    the **No Throttling** dropdown to **Fast 3G** or **Slow 3G**.
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pre-loading screens with HTML and CSS
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you follow the tip from the previous section and slow down the network speed
    of your browser to **Slow 3G** and **Disable caching**, you’ll notice that it
    takes forever and a half for anything to be shown on screen. In *Chapter 3*, *Architecting
    an Enterprise App*, I covered how to implement **Server-side Rendering** (**SSR**)
    to overcome such issues. However, that may not always be an option or may be overkill.
    Using simple HTML and CSS we can implement an easy solution to present an attractive
    and dynamic loading screen to entertain bored users staring at your app on a slow
    network.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the CSS in LemonMart:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Create `spinner.css` under `src/assets/styles`. Copy the contents from LemonMart’s
    GitHub repo at [https://github.com/duluca/lemon-mart/blob/main/src/assets/styles/spinner.css](https://github.com/duluca/lemon-mart/blob/main/src/assets/styles/spinner.css).
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `index.html` to import the stylesheet and place the necessary HTML inside
    the `<app-root>` element:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When Angular launches, the contents of `<app-root>` will be replaced by your
    application.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that this pre-loading screen is designed to be minimal and should come
    up instantly on screen. However, you will notice it still can take up to 6 seconds
    to display. This is because Angular prioritizes the global `styles.scss` file
    for loading first. If you’re using Angular Material, this adds 165 KB of content,
    which takes almost 6 seconds to load in **Slow 3G**. However, this is still much
    better in the context of a 50-second total loading time.
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Restart your Angular app and you should see the pre-loading screen:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_09_11.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Preloading screen on slow networks'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how to work with a state slice using NgRx/SignalState,
    let’s dive into the excellent NgRx/SignalStore library next. In fact, it’s so
    good that it inspired me to rewrite the LocalCast Weather app to be nearly Observable
    and RxJS operator-free with zero subscribe calls or async pipes.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting Angular apps with NgRx/SignalStore
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Observables, the best subscription is the one you don’t have to make. Throughout
    this book, we used the `async pipe`, `take(1)`, `takeUntilDestroyed`, and `unsubscribe`
    in `ngOnDestroy` to try and manage them. The sample code for this book has been
    through many reviews by various practitioners and experts over a period of six
    years. Every review highlighted some oversight or bug with the RxJS code.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: The 3^(rd) edition of the book provides a 99% bug-free implementation. I could
    never claim 100% due to the insane complexity of the RxJS ecosystem.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: I take pride in not taking the easy way out. I do my best to provide realistic
    and complete examples for you, not just counters and to-do lists. However, these
    are still highly controlled and small-sized projects compared to what happens
    in real life. You rarely have time to go back and reevaluate your entire project.
    Mistakes get compounded over time. This is a sad reality of working with RxJS.
    It’s wonderful for what it does, but 95+ percent of code written doesn’t require
    the flexibility and reactivity the tool brings. Most code is about retrieving
    some data from an API once and displaying it. Signals with async/await-driven
    promises make this kind of code straightforward to write.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: RxJS and signal helpers
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several important functions will help you transition away from Observables
    and RxJS:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript promises** are a construct that allows for asynchronous operations,
    providing a way to handle the eventual success value or failure reason.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript async/await** is syntactic sugar in JavaScript that allows you
    to write asynchronous code in a synchronous fashion, built on top of promises.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RxJS Interop** `toSignal` creates a signal that tracks the value of an Observable,
    like the async pipe in templates but more flexible. Similar to async pipe, `toSignal`
    manages the subscription for us, so there’s no need to use subscribe, `takeUntil`,
    or unsubscribe. There’s also `toObservable`, which is a useful bridge during the
    transition.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChangeDetectionStrategy.OnPush` is a strategy that tells Angular to run change
    detection on a component only when its input properties change, improving performance
    by reducing the number of checks. You will need to set the `changeDetection` property
    of your components to this until Signal-based components arrive.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastValueFrom` is a utility function that converts an Observable to a promise
    that resolves with the last value emitted by the Observable. This operator also
    manages the subscription for us. There’s also `firstValueFrom`, but you probably
    won’t need that one. This conversation will be necessary until Angular implements
    promise-based APIs to modules such as `HttpClient`, `Router`, `FormControl`, etc.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJS Interop is in developer preview.
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can read more about it at [https://angular.dev/guide/signals/rxjs-interop](https://angular.dev/guide/signals/rxjs-interop).
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: State management remains key to managing the complexity of large applications.
    Let’s see how NgRx SignalStore can help with the transition.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: NgRx/SignalStore
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SignalStore is a fully featured state management solution built around declarative
    programming, ensuring clean and concise code. SignalStore is for managing larger
    stores with complex state as opposed to SignalState, which is designed to contain
    simple state within a single component or service.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Read more about NgRx SignalStore at [https://ngrx.io/guide/signals/signal-store](https://ngrx.io/guide/signals/signal-store).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'SignalStore can provided at the root level or component level. The library
    offers the following functions:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '`signalStore` is a utility function for managing larger and more complex pieces
    of state in an application.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withState` takes the initial state of the store and defines the shape of the
    state.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withComputed` derives computed properties from existing pieces of state in
    the store.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withMethods` contains custom functions (store methods) that are exposed publicly
    to operate on the store with a well-defined API. `withMethods` can use `patchState`
    and injected services to update the store.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withHooks` are called when the store is created or destroyed, allowing for
    fetching data to initialize the store or updating state.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withEntities` is an extension to facilitate CRUD operations for managing entities.
    It is like `@ngrx/entity` but not the same.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about NgRx SignalStore entities at [https://ngrx.io/guide/signals/signal-store/entity-management](https://ngrx.io/guide/signals/signal-store/entity-management).
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, see advanced use cases with custom store features at [https://ngrx.io/guide/signals/signal-store/custom-store-features](https://ngrx.io/guide/signals/signal-store/custom-store-features).
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s see how we can apply SignalStore to LocalCast Weather. The diagram below
    is a recreation of the one from the *Implementing NgRx for LocalCast Weather*
    section earlier in this chapter.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a diagram  Description automatically generated](img/B20960_09_12.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: LocalCast Weather architecture'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Upon initial inspection, SignalStore appears simpler than the NgRx store implementation.
    That’s because the inherent reactivity of signals is baked into Angular. You must
    remember this invisible thread that makes the magic work beneath the surface of
    this implementation.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow, represented in dark gray in *Figure 9.12*, begins with *step
    1*:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '`CitySearchComponent` triggers the `doSearch` method, which in turn calls `store.updateWeather`.'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`withMethods` activates the `updateWeather` function, which has an injected
    reference to `WeatherService` and calls `getCurrentWeather` from it.'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`updateWeather` awaits the result from `getCurrentWeather`, which retrieves
    the current weather information from **OpenWeather**, and uses `patchState` to
    update `store.current`.'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CurrentWeatherComponent` is bound to `store.current`, so when the value updates,
    the template is automatically updated.'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we understand how SignalStore operates conceptually, let’s take a tour
    of the new code base.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring RxJS and NgRx code
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will review the refactored LocalCast Weather app to examine how the code
    was rewritten to be simpler and more concise using signals and SignalStore.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this section is under `projects/signal-store` on the `local-weather-app`
    repository at [https://github.com/duluca/local-weather-app/tree/main/projects/signal-store](https://github.com/duluca/local-weather-app/tree/main/projects/signal-store).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the project by executing:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run Cypress tests with:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: NgRx Store to SignalStore
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with the Store implementation under `projects/signal-store/src/app/store`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`withState` defines and initializes the store. `withMethods` implements the
    `updateWeather` function, which encapsulates the behavior for updating the current
    weather. This function used to be in `WeatherService` but has now been moved into
    the store. Arguably, this should have been the case for the NgRx Store implementation;
    however, with an overall simpler architecture, it is easier to see that any potential
    side effect is best implemented in the store.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Services from Observables to Signals
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We must update API calls to return a Promise instead of an Observable. I first
    updated `PostalCodeService`:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`resolvePostalCode` now returns `Promise<IPostalCode>`. We store the Observable
    from `httpClient.get` as a local `httpCall$` variable, which is then wrapped by
    `lastValueFrom`. In the process, we also removed the pipe, which implemented `mergeMap`
    and `defaultIfEmpty` to clean up the received data. We must implement a similar
    functionality in the `then` function. As shown previously, `then` behaves similarly
    to a `tap` function.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at `WeatherService`:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`getCurrentWeather` is now an async function to await the result of `postalCodeService.resolvePostalCode`.
    The logic inside the `switchMap` to handle the response from `resolvePostalCode`
    is now a simple if-else statement with less nesting. `getCurrentWeatherHelper`
    has been refactored similar to how we refactored `resolvePostalCode`.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, there’s no longer a `BehaviorSubject`, a `signal`, or any
    code that remains in the service that updates the value of `currentWeather`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Components from Observables to Signals
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the services updated, we can now complete the refactor and update the components
    to use signals.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with `CitySearchComponent`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We first set the `changeDetection` strategy to be `OnPush`. Next, we wrap `search.valueChanges`
    in a `toSignal` function to convert the Observable to a signal. This is notably
    the only pipe remaining in the app. The main reason is because of the `debounceTime`
    operator. See the tip box for more. We then use the `effect` function to react
    to changes pushed to `searchSignal`, which triggers `doSearch`, which in turn
    calls `store.updateWeather`. As we covered earlier, `store.updateWeather` will
    end up updating the `store.current` signal. Notably, we no longer reference `WeatherService`
    from this component, and no template changes were needed.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Filter and debounce are the only RxJS operators left in LocalCast Weather. Currently,
    there aren’t operators for signals. You can check out how a debounced signal function
    might work in this Stack Overflow answer [https://stackoverflow.com/a/76597576/178620](https://stackoverflow.com/a/76597576/178620).
    However, as the author An Nguyen notes, it’s complicated code, and it’s better
    to use a well-tested library for now.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at `CurrentWeatherComponent`:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The most remarkable change happens within `CurrentWeatherComponent`. We set
    `changeDetection` as before, but now we only have to inject `WeatherStore`. That’s
    it:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the template, we can remove the null guard because the signal is always initialized.
    Then we simply bind to `store.current()` signal. This, of course, requires a rather
    annoying refactoring of the template. We have to update every reference to `current`
    with `store.current()`. This could have been avoided by introducing a local variable
    named `current` and then using an `effect` to listen to updates on `store.current()`.
    However, with that configuration, you wouldn’t get the benefits of the granular
    change detection that `signal` and `OnPush` offer.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'I expect when Signal-based components arrive, we will be able to write code
    similar to how async pipe works:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will be a tremendous help in avoiding annoying template rewrites.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: And with the component updates done, the application refactor is complete. There
    are other subtle changes around the app code. You will notice a lot less imports
    and providers.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, the signal-only code is easier to understand and maintain; far
    superior to the RxJS alternative. I hope you enjoyed this glimpse into Angular’s
    future.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed going over all major Angular app design considerations
    using router-first architecture, along with our recipes, to implement a line-of-business
    app easily. We reviewed how to edit existing users, leverage a resolve guard to
    load user data, and hydrate and reuse a component in different contexts.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: We implemented a master/detail view using auxiliary routes and demonstrated
    how to build data tables with pagination. We then learned how to implement NgRx/Store
    and NgRx/SignalStore using **local-weather-app**. We covered the available options
    within the NgRx ecosystem, including NgRx/Data, NgRx/ComponentStore, Akita, and
    Elf, and the differences between those options, so you can make informed decisions
    about what to include in your project.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: We also implemented a pre-loading animation, so your app looks responsive when
    loading in slow connections. We also implemented a global spinner within the app
    to handle data pop-in-related UX issues. Finally, we took a peek into Angular’s
    signal-based future by touring a full refactor of **local-weather-app** using
    SignalStore and developer preview features.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Using the router-first design, architecture, and implementation approach, we
    tackled our application’s design with a high-level understanding of what we wanted
    to achieve. We saw the power of router orchestration by demonstrating the use
    of router outlets and reusing the same component in two different contexts. By
    identifying code reuse opportunities early on, we optimized our implementation
    strategy to implement reusable components ahead of time without running the risk
    of grossly over-engineering our solution.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we learn about containerization using Docker and deploying
    your apps to the cloud. Docker allows powerful workflows that can greatly improve
    development experiences while allowing you to implement your server configuration
    as code, putting the final nail in the coffin of the developer’s favorite excuse
    when their software breaks: “But it works on my machine!”'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Update `UserTableComponent` and related services in **lemon-mart** to leverage
    Elf entities and pagination to enable optimized handling of requests.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the guide on [https://ngneat.github.io/elf/docs/features/pagination](https://ngneat.github.io/elf/docs/features/pagination).
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rewrite your Angular app with NgRx/SignalStore to be nearly Observable and RxJS
    operator-free with zero subscribe calls or async pipes.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you think this is a hilarious exercise tacked on toward the end of the book,
    give me a shoutout on my GitHub profile at [https://github.com/duluca](https://github.com/duluca).
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Testing Angular Components With @Input()*, Aiko Klostermann, 2017, available
    at [https://medium.com/better-programming/testing-angular-components-with-input-3bd6c07cfaf6](https://medium.com/better-programming/testing-angular-components-with-input-3bd6c07cfaf6
    )'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is NgRx?*, 2020, available at [https://ngrx.io/docs](https://ngrx.io/docs)'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NgRx Testing*, 2020, available at [https://ngrx.io/guide/store/testing](https://ngrx.io/guide/store/testing)'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*@ngrx/data*, 2020, available at [https://ngrx.io/guide/data](https://ngrx.io/guide/data)'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NgRx: Action Creators redesigned*, Alex Okrushko, 2019, available at [https://medium.com/angular-in-depth/ngrx-action-creators-redesigned-d396960e46da](https://medium.com/angular-in-depth/ngrx-action-creators-redesigned-d396960e46da)'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Simplifying Frontend State Management with Observable Store*, Dan Wahlin,
    2019, available at [https://blog.codewithdan.com/simplifying-front-end-state-management-with-observable-store/](https://blog.codewithdan.com/simplifying-front-end-state-management-with-observable-store/)'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Handling pagination with NgRx component stores*, Pierre Bouillon, 2023, [https://dev.to/this-is-angular/handling-pagination-with-ngrx-component-stores-1j1p](https://dev.to/this-is-angular/handling-pagination-with-ngrx-component-stores-1j1p)'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Navigating the Nuances of toSignal in Angular: What to Know*, Netanel Basal,
    2023, [https://netbasal.com/navigating-the-nuances-of-tosignal-in-angular-what-to-know-e4d6a4b5dfaf](https://netbasal.com/navigating-the-nuances-of-tosignal-in-angular-what-to-know-e4d6a4b5dfaf)'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Guide to Angular Signals With Practical Use Cases*, Arman Murzabulatov,
    2023, [https://hackernoon.com/a-guide-to-angular-signals-with-practical-use-cases-part-1](https://hackernoon.com/a-guide-to-angular-signals-with-practical-use-cases-part-1)'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Power of @ngrx/signalstore: A Deep Dive Into Task Management*, Peter Eijgermans,
    2024, [https://dzone.com/articles/the-power-of-ngrxsignalstore-a-deep-dive-into-task](https://dzone.com/articles/the-power-of-ngrxsignalstore-a-deep-dive-into-task)'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to Implement a Global Loader in Angular*, Faizan Shaikh , 2023, [https://blog.bitsrc.io/how-to-implement-a-global-loader-in-angular-df111a2c43d9](https://blog.bitsrc.io/how-to-implement-a-global-loader-in-angular-df111a2c43d9)'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RxJS: Avoiding takeUntil Leaks*, Nicholas Jamieson, 2018, [https://cartant.medium.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef](https://cartant.medium.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef)'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Comprehensive Guide to Higher-Order RxJS Mapping Operators: switchMap, mergeMap,
    concatMap (and exhaustMap)*, Angular University, 2023, [https://blog.angular-university.io/rxjs-higher-order-mapping](https://blog.angular-university.io/rxjs-higher-order-mapping
    )'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: What is a resolve guard?
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of router orchestration?
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an auxiliary route?
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does NgRx differ from using RxJS/Subject?
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the value of NgRx Data?
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `UserTableComponent`, why do we use `readonly` `isLoadingResults$: BehaviorSubject<Boolean>`
    over a simple Boolean to drive the loading spinner?'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularEnterpise3e](Chapter_9.xhtml)'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1116411172100421421.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
