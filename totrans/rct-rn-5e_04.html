<html><head></head><body>
  <div id="_idContainer047" class="Basic-Text-Frame">
    <h1 class="chapterNumber">3</h1>
    <h1 id="_idParaDest-50" class="chapterTitle">Understanding React Components and Hooks</h1>
    <p class="normal">In this chapter, we will delve into the React components and their fundamental aspects and introduce you to the<a id="_idIndexMarker095"/> power of <strong class="keyWord">Hooks</strong>.</p>
    <p class="normal">We will explore the essential concept of component data and how it shapes the structure of your React applications. We will discuss two primary types of component data: <strong class="keyWord">properties</strong> and <strong class="keyWord">state</strong>. Properties allow us to pass data to components, while state enables components to manage and update their internal data dynamically. We will examine how these concepts apply to function components and illustrate the mechanics of setting component state and passing properties.</p>
    <p class="normal">In this chapter, we’ll cover the following topics:</p>
    <ul>
      <li class="bulletList">Introduction to React components</li>
      <li class="bulletList">What are component properties?</li>
      <li class="bulletList">What is component state?</li>
      <li class="bulletList">React Hooks</li>
      <li class="bulletList">Maintaining state using Hooks</li>
      <li class="bulletList">Performing initialization and cleanup actions</li>
      <li class="bulletList">Sharing data using context Hooks</li>
      <li class="bulletList">Memoization with Hooks</li>
    </ul>
    <h1 id="_idParaDest-51" class="heading-1">Technical requirements</h1>
    <p class="normal">The code for this chapter can be found here: <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter03"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter03</span></a></p>
    <h1 id="_idParaDest-52" class="heading-1">Introduction to React components</h1>
    <p class="normal">React components are <a id="_idIndexMarker096"/>the building blocks of modern web and mobile applications. They encapsulate reusable sections of code that define the structure, behavior, and appearance of different parts of a user interface. By breaking down the UI into smaller, self-contained components, React enables developers to create scalable, maintainable, and interactive applications.</p>
    <p class="normal">At its core, a React component is a JavaScript function or class that returns JSX syntax, which resembles HTML markup. In this book, we will focus mostly on function components, as they have become the preferred approach for building components in recent years. Function components are simpler, more concise, and easier to understand compared to class components. They leverage the power of JavaScript functions and utilize React Hooks to manage state and perform side effects.</p>
    <p class="normal">One of the primary advantages of using components in React is their reusability. Components can be reused across multiple parts of an application, reducing code duplication and increasing development efficiency. Moreover, components promote a modular approach to development, allowing developers to break down complex UIs into smaller, manageable pieces.</p>
    <h1 id="_idParaDest-53" class="heading-1">What are component properties?</h1>
    <p class="normal">In React, <strong class="keyWord">component properties</strong>, commonly<a id="_idIndexMarker097"/> known as <strong class="keyWord">props</strong>, allow<a id="_idIndexMarker098"/> us to <a id="_idIndexMarker099"/>pass data from a parent component to its child components. Props provide a way to customize and configure components, making them flexible and reusable. Props are read-only, meaning that the child component should not modify them directly. Instead, the parent component can update the props value and trigger a re-render of the child component with the updated data.</p>
    <p class="normal">When defining a function component, you can access the props passed to it as a parameter:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = (<span class="hljs-params">props</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>{props.title}<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>{props.description}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
};
</code></pre>
    <p class="normal">In the above example, the <code class="inlineCode">MyComponent</code> function component receives the props object as a parameter. We can access the individual props by using dot notation, such as <code class="inlineCode">props.title</code> and <code class="inlineCode">props.description</code>, to render the data within the component’s JSX markup. It is also possible to access props using destructuring:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = (<span class="hljs-params">{ title, description }</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>{title}<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>{description}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
};
</code></pre>
    <p class="normal">As you can see, this <a id="_idIndexMarker100"/>approach is even cleaner and also allows us to use another destructuring feature, default values, which we will discuss in this chapter.</p>
    <h2 id="_idParaDest-54" class="heading-2">Passing property values</h2>
    <p class="normal">React component<a id="_idIndexMarker101"/> properties are set by passing JSX attributes to the component when it is rendered. In <em class="chapterRef">Chapter 7</em>, <em class="italic">Type Checking and Validation with TypeScript</em>, I’ll go into more detail about how to validate the property values that are passed to components. Now let’s create a couple of components in addition to <code class="inlineCode">MyComponent</code> that expect different types of property values:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyButton</span> = (<span class="hljs-params">{ disabled, text }</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">disabled</span><span class="hljs-tag">=</span><span class="hljs-string">{disabled}</span><span class="hljs-tag">&gt;</span>{text}<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>;
};
</code></pre>
    <p class="normal">This simple button component expects a Boolean disabled property and a string text property. While we create components to show how we can pass the following props, you will notice how we already pass these properties to the button HTML element:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">disabled property</strong>: we put into the button attribute with the name <code class="inlineCode">disabled</code></li>
      <li class="bulletList"><strong class="keyWord">text property</strong>: we pass to the button as a child attribute</li>
    </ul>
    <p class="normal">It’s also important to know that any JavaScript expression you want to pass to the component should be wrapped with curly braces.</p>
    <p class="normal">Let’s create one more component that expects an array property value:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyList</span> = (<span class="hljs-params">{ items }</span>) =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
    {items.map((i) =&gt; (
      <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{i}</span><span class="hljs-tag">&gt;</span>{i}<span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">You can pass just about <a id="_idIndexMarker102"/>anything you want as a property value via JSX, just as long as it’s a valid JavaScript expression. The <code class="inlineCode">MyList</code> component accepts an items property, an array that is mapped to <code class="inlineCode">&lt;li&gt;</code> elements.</p>
    <p class="normal">Now, let’s write some code to set these property values:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title">MyButton</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./MyButton"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title">MyList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./MyList"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./MyComponent"</span>;
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"root"</span>));
<span class="hljs-keyword">const</span> appState = {
  <span class="hljs-attr">text</span>: <span class="hljs-string">"My Button"</span>,
  <span class="hljs-attr">disabled</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">items</span>: [<span class="hljs-string">"First"</span>, <span class="hljs-string">"Second"</span>, <span class="hljs-string">"Third"</span>],
};
<span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">props</span>) {
  root.<span class="hljs-title">render</span>(
    <span class="hljs-tag">&lt;</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">MyComponent</span>
<span class="hljs-tag">        </span><span class="hljs-attr">title</span><span class="hljs-tag">=</span><span class="hljs-string">"Welcome to My App"</span>
<span class="hljs-tag">        </span><span class="hljs-attr">description</span><span class="hljs-tag">=</span><span class="hljs-string">"This is a sample component."</span>
<span class="hljs-tag">      /&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">MyButton</span><span class="hljs-tag"> </span><span class="hljs-attr">text</span><span class="hljs-tag">=</span><span class="hljs-string">{props.text}</span><span class="hljs-tag"> </span><span class="hljs-attr">disabled</span><span class="hljs-tag">=</span><span class="hljs-string">{props.disabled}</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">MyButton</span><span class="hljs-tag"> </span><span class="hljs-attr">text</span><span class="hljs-tag">=</span><span class="hljs-string">"Another Button"</span><span class="hljs-tag"> </span><span class="hljs-attr">disabled</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">MyList</span><span class="hljs-tag"> </span><span class="hljs-attr">items</span><span class="hljs-tag">=</span><span class="hljs-string">{props.items}</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
  );
}
<span class="hljs-title">render</span>(appState);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  appState.<span class="hljs-property">disabled</span> = <span class="hljs-literal">false</span>;
  appState.<span class="hljs-property">items</span>.<span class="hljs-title">push</span>(<span class="hljs-string">"Fourth"</span>);
  <span class="hljs-title">render</span>(appState);
}, <span class="hljs-number">1000</span>);
</code></pre>
    <p class="normal">The <code class="inlineCode">render</code> function looks<a id="_idIndexMarker103"/> like it’s creating new React component instances every time it’s called. React is smart enough to figure out that these components already exist, and that it only needs to figure out what the difference in output will be with the new property values. In this example, the call to <code class="inlineCode">setTimeout</code> causes a delay of 1 second. Then, the <code class="inlineCode">appState.disabled</code> value is changed to false and the <code class="inlineCode">appState.items</code> array has a new value added to the end of it. The call to <code class="inlineCode">render</code> will re-render the components with new property values.</p>
    <p class="normal">Another takeaway from this example is that you have an <code class="inlineCode">appState</code> object that holds onto the state of the application. Pieces of this state are then passed into components as properties when the components are rendered. The state has to live somewhere and, in this case, it’s outside of the component. We’ll explore this approach in depth, and why it’s important, in <em class="chapterRef">Chapter 12</em>, <em class="italic">State Management in React</em>.</p>
    <p class="normal">I hope you noticed we’ve rendered another button where we passed props in a different way:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;<span class="hljs-title">MyButton</span> text=<span class="hljs-string">"Another Button"</span> disabled /&gt;
</code></pre>
    <p class="normal">This is a valid JSX expression and in case we want to pass constant values to the components, we can pass strings without curly braces and pass the Boolean value <code class="inlineCode">true</code>, just leaving <a id="_idIndexMarker104"/>the attribute name in the component.</p>
    <h2 id="_idParaDest-55" class="heading-2">Default property values</h2>
    <p class="normal">In addition to passing <a id="_idIndexMarker105"/>data, we can also specify default values for props using the <code class="inlineCode">defaultProps</code> property. This is helpful when a prop is not provided, ensuring that the component still behaves correctly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyButton</span> = (<span class="hljs-params">{ disabled, text }</span>) =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">disabled</span><span class="hljs-tag">=</span><span class="hljs-string">{disabled}</span><span class="hljs-tag">&gt;</span>{text}<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
);
<span class="hljs-title">MyButton</span>.<span class="hljs-property">defaultProps</span> = {
  <span class="hljs-attr">disabled</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">text</span>: <span class="hljs-string">"My Button"</span>,
};
</code></pre>
    <p class="normal">In this case, if the parent component does not provide the <code class="inlineCode">text</code> or <code class="inlineCode">disabled</code> props, the component will fall back to the default values specified in <code class="inlineCode">defaultProps</code>.</p>
    <p class="normal">As I mentioned before, with destructuring, we have a more convenient way to set up default props.</p>
    <p class="normal">Let’s take a look at the updated example of the <code class="inlineCode">MyButton</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyButton</span> = (<span class="hljs-params">{ disabled = </span><span class="hljs-literal">false</span><span class="hljs-params">, text = </span><span class="hljs-string">"</span><span class="hljs-string">My Button"</span><span class="hljs-params"> }</span>) =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">disabled</span><span class="hljs-tag">=</span><span class="hljs-string">{disabled}</span><span class="hljs-tag">&gt;</span>{text}<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">Using destructuring, we can define props and set the default value right inside the function. It’s cleaner and easy to see in cases when we have a big component with a lot of props.</p>
    <p class="normal">In the upcoming <a id="_idIndexMarker106"/>sections, we will further dive into component state with Hooks, and other key concepts.</p>
    <h1 id="_idParaDest-56" class="heading-1">What is component state?</h1>
    <p class="normal">In React, component<a id="_idIndexMarker107"/> state refers to the internal data held by a <a id="_idIndexMarker108"/>component. It represents the mutable values that can be used within the component and can be updated over time. State allows components to keep track of information that can change, such as user input, API responses, or any other data that needs to be dynamic and responsive.</p>
    <p class="normal">State is a feature provided by React that enables components to manage and update their own data. It allows components to re-render when the state changes, ensuring that the user interface reflects the latest data.</p>
    <p class="normal">To define state in a React component, you should use the <code class="inlineCode">useState</code> hook inside of the component. You can then access and modify the state within the component’s methods or JSX code. When the state is updated, React will automatically re-render the component and its child components to reflect the changes.</p>
    <p class="normal">Before jumping <a id="_idIndexMarker109"/>to<a id="_idIndexMarker110"/> examples of using state in components, let’s briefly explore what a React hook is.</p>
    <h1 id="_idParaDest-57" class="heading-1">React Hooks</h1>
    <p class="normal">React Hooks are a <a id="_idIndexMarker111"/>feature introduced in <strong class="keyWord">React 16.8</strong> that allows you to use state and other React features in functional components. Before Hooks, state management and lifecycle methods were primarily used in class components. Hooks provide a way to achieve similar functionality in functional components, making them more powerful and easier to write and understand.</p>
    <p class="normal">Hooks are functions that enable you to “hook into” React’s internal features, such as state management, context, effects, and more. They are prefixed with the <code class="inlineCode">use</code> keyword (such as <code class="inlineCode">useState</code>, <code class="inlineCode">useEffect</code>, <code class="inlineCode">useContext</code>, and so on). React provides several built-in Hooks, and you can also create custom Hooks to encapsulate reusable stateful logic.</p>
    <p class="normal">The most commonly used built-in Hooks are:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">useState</code>: This hook allows<a id="_idIndexMarker112"/> you to add state to a functional component. It returns an array with two elements: the current state value and a function to update the state.</li>
      <li class="bulletList"><code class="inlineCode">useEffect</code>: This hook lets <a id="_idIndexMarker113"/>you perform side effects in your components, such as fetching data, subscribing to events, or manually manipulating the DOM. It runs after every render by default and can be used to handle component lifecycle events like when the component is mounted, updated, or unmounted.</li>
      <li class="bulletList"><code class="inlineCode">useContext</code>: This hook<a id="_idIndexMarker114"/> allows you to consume values from a React context. It provides a way to access context values without nesting multiple components.</li>
      <li class="bulletList"><code class="inlineCode">useCallback</code> and <code class="inlineCode">useMemo</code>: These <a id="_idIndexMarker115"/>Hooks are used for performance <a id="_idIndexMarker116"/>optimization. <code class="inlineCode">useCallback</code> memoizes a function, preventing it from being recreated on every render, while <code class="inlineCode">useMemo</code> memoizes a value, recomputing it only when its dependencies change.</li>
    </ul>
    <p class="normal">We will examine all <a id="_idIndexMarker117"/>these Hooks in this chapter and will use them throughout the book. Let’s continue with state and explore how we can manage it with the <code class="inlineCode">useState</code> Hook.</p>
    <h2 id="_idParaDest-58" class="heading-2">Maintaining state using Hooks</h2>
    <p class="normal">The first React<a id="_idIndexMarker118"/> Hook API that we’ll look at is called <code class="inlineCode">useState</code>, which<a id="_idIndexMarker119"/> enables your functional React components to be stateful. In this section, you’ll learn how to initialize state values and change the state of a component using Hooks.</p>
    <h2 id="_idParaDest-59" class="heading-2">Initial state values</h2>
    <p class="normal">When our <a id="_idIndexMarker120"/>components are first rendered, they probably expect some state values to be set. This is called the initial state of the component, and we can use the <code class="inlineCode">useState</code> hook to set the initial state. </p>
    <p class="normal">Let’s take a look at an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> [name] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-string">"Mike"</span>);
  <span class="hljs-keyword">const</span> [age] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-number">32</span>);
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>My name is {name}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>My age is {age}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}
</code></pre>
    <p class="normal">The <code class="inlineCode">App</code> component is a functional React component that returns JSX markup. But it’s also now a stateful component, thanks to the <code class="inlineCode">useState</code> hook. This example initializes two pieces of state, <code class="inlineCode">name</code> and <code class="inlineCode">age</code>. This is why there are two calls to <code class="inlineCode">useState</code>, one for each state value.</p>
    <p class="normal">You can have as many pieces of state in your component as you need. The best practice is to have one call to <code class="inlineCode">useState</code> per state value. You could always define an object as the state of your component using only one call to <code class="inlineCode">useState</code>, but this complicates things because you have to access state values through an object instead of directly. Updating state values is also more complicated using this approach. When in doubt, use one <code class="inlineCode">useState</code> hook per state value.</p>
    <p class="normal">When we call <code class="inlineCode">useState</code>, we get an array returned to us. The first value of this array is the state value itself. Since we’ve used array-destructuring syntax here, we can call the value whatever we want; in this case, it is <code class="inlineCode">name</code> and <code class="inlineCode">age</code>. Both of these constants have values when the component is first rendered because we passed the initial state values for each of them to <code class="inlineCode">useState</code>. Here’s what the page looks like when it’s rendered:</p>
    <figure class="mediaobject"><img src="../Images/B19636_03_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 3.1: Rendered output using values from state Hooks</p>
    <p class="normal">Now that you’ve<a id="_idIndexMarker121"/> seen how to set the initial state values of your components, let’s learn about updating these values.</p>
    <h3 id="_idParaDest-60" class="heading-3">Updating state values</h3>
    <p class="normal">React components<a id="_idIndexMarker122"/> use state for values that change over time. The state values used by components start off in one state, as we saw in the previous section, and then change in response to some event: for example, the server responds to an API request with new data, or the user has clicked a button or changed a form field.</p>
    <p class="normal">To update the state, the <code class="inlineCode">useState</code> hook provides an individual function for every piece of state, which we can access from the returned array from the <code class="inlineCode">useState</code> hook. The first item is the state value and the second is the function used to update the value. Let’s take a look at an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-string">"Mike"</span>);
  <span class="hljs-keyword">const</span> [age, setAge] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-number">32</span>);
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{name}</span><span class="hljs-tag"> </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{(e)</span><span class="hljs-tag"> =&gt;</span> setName(e.target.value)} /&gt;
        <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>My name is {name}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span>
<span class="hljs-tag">          </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"</span><span class="hljs-string">number"</span>
<span class="hljs-tag">          </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{age}</span>
<span class="hljs-tag">          </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{(e)</span><span class="hljs-tag"> =&gt;</span> setAge(e.target.value)}
        /&gt;
        <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>My age is {age}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}
</code></pre>
    <p class="normal">Just like the example from the initial state values section, the <code class="inlineCode">App</code> component in this example has two <a id="_idIndexMarker123"/>pieces of state: <code class="inlineCode">name</code> and <code class="inlineCode">age</code>. Unlike the previous example, this component uses two functions to update each piece of state. These are returned from the call to <code class="inlineCode">useState</code>. Let’s take a closer look:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-string">"</span><span class="hljs-string">Mike"</span>);
<span class="hljs-keyword">const</span> [age, setAge] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-number">32</span>);
</code></pre>
    <p class="normal">Now, we have two functions: <code class="inlineCode">setName</code> and <code class="inlineCode">setAge</code>: that can be used to update the state of our component. Let’s take a look at the text input field that updates the <code class="inlineCode">name</code> state:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;section&gt;
  <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{name}</span><span class="hljs-tag"> </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{(e)</span><span class="hljs-tag"> =&gt;</span> setName(e.target.value)} /&gt;
  <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>My name is {name}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
&lt;/section&gt;
</code></pre>
    <p class="normal">Whenever the user changes the text in the <code class="inlineCode">&lt;input&gt;</code> field, the <code class="inlineCode">onChange</code> event is triggered. The handler for this event calls <code class="inlineCode">setName</code>, passing it <code class="inlineCode">e.target.value</code> as an argument. The argument passed to <code class="inlineCode">setName</code> is the new state value of name. The succeeding paragraph shows that the text input is also updated with the new name value every time the user changes the text input.</p>
    <p class="normal">Next, let’s look at the <code class="inlineCode">age</code> number input field and how this value is passed to <code class="inlineCode">setAge</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;section&gt;
  <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span>
<span class="hljs-tag">    </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"number"</span>
<span class="hljs-tag">    </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{age}</span>
<span class="hljs-tag">    </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{(e)</span><span class="hljs-tag"> =&gt;</span> setAge(e.target.value)}
  /&gt;
  <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>My age is {age}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
&lt;/section&gt;
</code></pre>
    <p class="normal">The <code class="inlineCode">age</code> field follows the exact same pattern as the <code class="inlineCode">name</code> field. The only difference is that we’ve made the input a number type. Any time the number changes, <code class="inlineCode">setAge</code> is called with the updated value in response to the <code class="inlineCode">onChange</code> event. The following paragraph shows that the<a id="_idIndexMarker124"/> number input is also updated with every change that is made to the <code class="inlineCode">age</code> state.</p>
    <p class="normal">Here is what the two inputs and their two corresponding paragraphs look like when they’re rendered on the screen:</p>
    <figure class="mediaobject"><img src="../Images/B19636_03_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 3.2: Using Hooks to change state values</p>
    <p class="normal">In this section, you learned about the <code class="inlineCode">useState</code> hook, which is used to add state to functional React components. Each piece of state uses its own hook and has its own value variable and its own setter function. This greatly simplifies accessing and updating state in your components. Any given state value should have an initial value so that the component can render correctly the first time. To re-render functional components that use state Hooks, you can use the setter functions that <code class="inlineCode">useState</code> returns to update your state values <a id="_idIndexMarker125"/>as needed.</p>
    <p class="normal">The next hook that you’ll learn about is used to perform initialization and cleanup actions.</p>
    <h1 id="_idParaDest-61" class="heading-1">Performing initialization and cleanup actions</h1>
    <p class="normal">Often, our React<a id="_idIndexMarker126"/> components need to perform actions when the component is created. For example, a common initialization action is to fetch the API data that the component needs. Another common action is to make sure that any pending API requests are canceled when the component is removed. In this section, you’ll learn about the <code class="inlineCode">useEffect</code> hook and how it can help you with these two scenarios. You’ll also learn how to make sure that the initialization code doesn’t run too often.</p>
    <h2 id="_idParaDest-62" class="heading-2">Fetching component data</h2>
    <p class="normal">The <code class="inlineCode">useEffect</code> hook is <a id="_idIndexMarker127"/>used to run “side effects” in your component. Another way to think about side-effect code is that functional components have only one job: returning JSX content to render. If the component needs to do something else, such as fetching API data, this should be done in a <code class="inlineCode">useEffect</code> hook. For example, if you were to just make the API call as part of your component function, you would likely introduce race conditions and other difficult-to-fix buggy behavior.</p>
    <p class="normal">Let’s take a look at an example that fetches API data using Hooks:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> [id, setId] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-string">"loading..."</span>);
  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-string">"loading..."</span>);
  <span class="hljs-keyword">const</span> fetchUser = <span class="hljs-title">React</span>.<span class="hljs-title">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Promise</span>(<span class="hljs-function">(</span><span class="hljs-params">resolve</span><span class="hljs-function">) =&gt;</span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title">resolve</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Mike"</span> });
      }, <span class="hljs-number">1000</span>);
    });
  }, []);
  <span class="hljs-title">React</span>.<span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">fetchUser</span>().<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">user</span><span class="hljs-function">) =&gt;</span> {
      <span class="hljs-title">setId</span>(user.<span class="hljs-property">id</span>);
      <span class="hljs-title">setName</span>(user.<span class="hljs-property">name</span>);
    });
  });
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>ID: {id}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Name: {name}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}
</code></pre>
    <p class="normal">The <code class="inlineCode">useEffect</code> hook expects a function as an argument. This function is called after the component finishes rendering, in a safe way that doesn’t interfere with anything else that React is doing with the component under the covers. Let’s look at the pieces of this example more<a id="_idIndexMarker128"/> closely, starting with the mock API function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> fetchUser = <span class="hljs-title">React</span>.<span class="hljs-title">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Promise</span>(<span class="hljs-function">(</span><span class="hljs-params">resolve</span><span class="hljs-function">) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title">resolve</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Mike"</span> });
    }, <span class="hljs-number">1000</span>);
  });
}, []);
</code></pre>
    <p class="normal">The <code class="inlineCode">fetchUser</code> function is defined using the <code class="inlineCode">useCallback</code> hook. This hook is used to memoize the function, meaning that it will only be created once and will not be recreated on subsequent renders unless the dependencies change. The <code class="inlineCode">useCallback</code> accepts two arguments: the first is the function we want to memorize and the second is the list of dependencies that will be used to identify when React should re-create this function instead of using the memorized version. The <code class="inlineCode">fetchUser</code> function is passed an empty array (<code class="inlineCode">[]</code>) as the dependency list. This means that the function will only be created once during the initial render and won’t be recreated on subsequent renders.</p>
    <p class="normal">The <code class="inlineCode">fetchUser</code> function returns a promise. The promise resolves a simple object with two properties, <code class="inlineCode">id</code> and <code class="inlineCode">name</code>. The <code class="inlineCode">setTimeout</code> function delays the promise resolution for 1 second, so this function is asynchronous, just as a normal <code class="inlineCode">fetch</code> call would be.</p>
    <p class="normal">Next, let’s look at the Hooks used by the <code class="inlineCode">App</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> [id, setId] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-string">"loading..."</span>);
<span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-string">"</span><span class="hljs-string">loading..."</span>);
<span class="hljs-title">React</span>.<span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">fetchUser</span>().<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">user</span><span class="hljs-function">) =&gt;</span> {
    <span class="hljs-title">setId</span>(user.<span class="hljs-property">id</span>);
    <span class="hljs-title">setName</span>(user.<span class="hljs-property">name</span>);
  });
});
</code></pre>
    <p class="normal">As you can see, in addition to <code class="inlineCode">useCallback</code>, we’re using two Hooks in this component: <code class="inlineCode">useState</code> and <code class="inlineCode">useEffect</code>. Combining hook functionality like this is powerful and encouraged. First, we set up the <code class="inlineCode">id</code> and <code class="inlineCode">name</code> states of the component. Then, <code class="inlineCode">useEffect</code> is used to set up<a id="_idIndexMarker129"/> a function that calls <code class="inlineCode">fetchUser</code> and sets the state of our component when the promise resolves.</p>
    <p class="normal">Here is what the <code class="inlineCode">App</code> component looks like when it’s first rendered, using the initial state of <code class="inlineCode">id</code> and <code class="inlineCode">name</code>:</p>
    <figure class="mediaobject"><img src="../Images/B19636_03_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 3.3: Displaying the loading text until the data arrives</p>
    <p class="normal">After 1 second, the promise returned from <code class="inlineCode">fetchUser</code> is resolved with data from the API, which is then used to update the ID and name states. This results in <code class="inlineCode">App</code> being rerendered:</p>
    <figure class="mediaobject"><img src="../Images/B19636_03_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 3.4: The state changes, removing the loading text and displaying returned values</p>
    <p class="normal">There is a good chance that your users will navigate around your application while an API request is <a id="_idIndexMarker130"/>still pending. The <code class="inlineCode">useEffect</code> hook can be used to deal with canceling these requests.</p>
    <h2 id="_idParaDest-63" class="heading-2">Canceling actions and resetting state</h2>
    <p class="normal">There’s a good<a id="_idIndexMarker131"/> chance that, at<a id="_idIndexMarker132"/> some point, your users will navigate your app and cause components to unmount before responses to their API requests arrive. Sometimes your component can listen for some events and you should delete all listeners before unmounting the component to avoid memory leaks. In general, it’s important to stop performing any background actions when a related component is deleted from the screen.</p>
    <p class="normal">Thankfully, the <code class="inlineCode">useEffect</code> hook has a mechanism to clean up effects such as pending <code class="inlineCode">setInterval</code> when the component is removed. Let’s take a look at an example of this in action:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title">Timer</span>() {
  <span class="hljs-keyword">const</span> [timer, setTimer] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-number">100</span>);
  <span class="hljs-title">React</span>.<span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title">setTimer</span>(<span class="hljs-function">(</span><span class="hljs-params">prevTimer</span><span class="hljs-function">) =&gt;</span> (prevTimer === <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : prevTimer - <span class="hljs-number">1</span>));
    }, <span class="hljs-number">1000</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">clearInterval</span>(interval);
    };
  }, []);
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Timer: {timer}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">Timer</span>;
</code></pre>
    <p class="normal">This is a simple <code class="inlineCode">Timer</code> component. It has the state <code class="inlineCode">timer</code>, it sets up interval callback to update <code class="inlineCode">timer</code> inside <code class="inlineCode">useEffect()</code>, and it renders the output with the current <code class="inlineCode">timer</code> value. Let’s take a closer look at the <code class="inlineCode">useEffect()</code> hook:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">React</span>.<span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">setTimer</span>(<span class="hljs-function">(</span><span class="hljs-params">prevTimer</span><span class="hljs-function">) =&gt;</span> (prevTimer === <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : prevTimer - <span class="hljs-number">1</span>));
  }, <span class="hljs-number">1000</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">clearInterval</span>(interval);
  };
}, []);
</code></pre>
    <p class="normal">This effect <a id="_idIndexMarker133"/>creates <a id="_idIndexMarker134"/>an interval timer by calling the <code class="inlineCode">setInterval</code> function with a callback, which updates our <code class="inlineCode">timer</code> state. The interesting thing you will notice here is that to the <code class="inlineCode">setTimer</code> function, we are passing a callback instead of a number. It’s a valid React API: when we need the previous state value to use to calculate a new one, we can pass a callback where the first argument is the current or ‘previous’ state value and we should return the new state value from this callback to update our state.</p>
    <p class="normal">Inside <code class="inlineCode">useEffect</code>, we are also returning a function, which React runs when the component is removed. In this example, the interval that is created by calling <code class="inlineCode">setInterval</code> is cleared by calling the function that we returned from <code class="inlineCode">useEffect</code>, where we call <code class="inlineCode">clearInterval</code>. Functions that you return from <code class="inlineCode">useEffect</code> will be triggered when the component is going to unmount.</p>
    <p class="normal">Now, let’s look at the <code class="inlineCode">App</code> component, which renders and removes the <code class="inlineCode">Timer</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">ShowHideTimer</span> = (<span class="hljs-params">{ show }</span>) =&gt; (show ? <span class="hljs-tag">&lt;</span><span class="hljs-name">Timer</span><span class="hljs-tag"> /&gt;</span> : <span class="hljs-literal">null</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> [show, setShow] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span> setShow(!show)}&gt;
        {show ? "Hide Timer" : "Show Timer"}
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">ShowHideTimer</span><span class="hljs-tag"> </span><span class="hljs-attr">show</span><span class="hljs-tag">=</span><span class="hljs-string">{show}</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}
</code></pre>
    <p class="normal">The <code class="inlineCode">App</code> component renders a button that is used to toggle the <code class="inlineCode">show</code> state. This state value determines whether or not the <code class="inlineCode">Timer</code> component is rendered, but by using the <code class="inlineCode">ShowHideTimer</code> convenience component. If show is true, <code class="inlineCode">&lt;Timer /&gt;</code> is rendered; otherwise, <code class="inlineCode">Timer</code> is removed, triggering our <code class="inlineCode">useEffect</code> cleanup behavior.</p>
    <p class="normal">Here’s what<a id="_idIndexMarker135"/> the <a id="_idIndexMarker136"/>screen looks like when it first loads:</p>
    <figure class="mediaobject"><img src="../Images/B19636_03_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 3.5: A button used to initiate the state change</p>
    <p class="normal">The <code class="inlineCode">Timer</code> component isn’t rendered because the <code class="inlineCode">show</code> state of the <code class="inlineCode">App</code> component is <code class="inlineCode">false</code>. Try clicking on the show timer button. This will change the <code class="inlineCode">show</code> state and render the <code class="inlineCode">Timer</code> component:</p>
    <figure class="mediaobject"><img src="../Images/B19636_03_06.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 3.6: Displays the timer</p>
    <p class="normal">You can click on the <strong class="screenText">Hide Timer</strong> button once more to remove the <code class="inlineCode">Timer</code> component. Without the cleanup interval that we added to <code class="inlineCode">useEffect</code>, this will create new listeners every time the timer is rendered, which will affect the memory leak.</p>
    <p class="normal">React allows us to <a id="_idIndexMarker137"/>control when we<a id="_idIndexMarker138"/> want to run our effects. For example, when we want to all API requests after the first render, or we want to perform effects when a particular state changes. We’ll take a look at how to do this next.</p>
    <h2 id="_idParaDest-64" class="heading-2">Optimizing side-effect actions</h2>
    <p class="normal">By default, React <a id="_idIndexMarker139"/>assumes that every effect that is run needs to be cleaned up and it should be run on every render. This typically isn’t the case. For example, you might have specific property or state values that require cleanup and run one more time when they change. You can pass an array of values to watch as the second argument to <code class="inlineCode">useEffect</code>: for example, if you have a resolved state that requires cleanup when it changes, you would write your effect code like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> [resolved, setResolved] = <span class="hljs-title">useState</span>(<span class="hljs-literal">false</span>);
<span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// ...the effect code...</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// ...the cleanup code</span>
  };
}, [resolved]);
</code></pre>
    <p class="normal">In this code, the effect will be triggered and only ever run if the resolved state value changes. If the effect runs and the resolved state hasn’t changed, then the cleanup code will not run and the original effect code will not run a second time. Another common case is never running the cleanup code, except for when the component is removed. In fact, this is what we want to happen in the example from the section on fetching user data. Right now, the effect runs after every render. This means that we’re repeatedly fetching the user API data when all we really want is to fetch it once when the component is first mounted.</p>
    <p class="normal">Let’s make some modifications to the <code class="inlineCode">App</code> component from the fetching component data requests example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">React</span>.<span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">fetchUser</span>().<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">user</span><span class="hljs-function">) =&gt;</span> {
    <span class="hljs-title">setId</span>(user.<span class="hljs-property">id</span>);
    <span class="hljs-title">setName</span>(user.<span class="hljs-property">name</span>);
  });
}, []);
</code></pre>
    <p class="normal">We’ve added a second argument to <code class="inlineCode">useEffect</code>, an empty array. This tells React that there are no values to watch and that we only want to run the effect once it is rendered and cleanup code when the component is removed. We’ve also added <code class="inlineCode">console.count('fetching user')</code> to the <code class="inlineCode">fetchUser</code> function. This makes it easier to look at the browser dev tools console and make sure that our component data is only fetched once. If you remove the <code class="inlineCode">[]</code> argument that is passed to <code class="inlineCode">useEffect</code>, you’ll notice that <code class="inlineCode">fetchUser</code> is called several times.</p>
    <p class="normal">In this section, you learned about side effects in React components. Effects are an important concept, as they are the bridge between your React components and the outside world. One of <a id="_idIndexMarker140"/>the most common use cases for effects is to fetch data that the component needs, when it is first created, and then clean up after the component when it is removed.</p>
    <p class="normal">Now, we’re going to look at another way to share data with React components: context.</p>
    <h1 id="_idParaDest-65" class="heading-1">Sharing data using context Hooks</h1>
    <p class="normal">React applications <a id="_idIndexMarker141"/>often have a few pieces of data that are<a id="_idIndexMarker142"/> global in nature. This means that several components, possibly every component in an app, share this data: for example, information about the currently logged-in user might be used in several places. This is where <a id="_idIndexMarker143"/>the <strong class="keyWord">Context API</strong> comes in handy. The Context API provides a way to create a shared data store that can be accessed by any component in the tree, regardless of its depth.</p>
    <p class="normal">To utilize the Context API, we need to create a context using the <code class="inlineCode">createContext</code> function from <a id="_idIndexMarker144"/>the <strong class="keyWord">React</strong> library:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { createContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title">MyContext</span> = <span class="hljs-title">createContext</span>();
</code></pre>
    <p class="normal">In the example above, we create a context called <code class="inlineCode">MyContext</code> using <code class="inlineCode">createContext</code>. This creates a context object that contains a <code class="inlineCode">Provider</code> and a <code class="inlineCode">Consumer</code>.</p>
    <p class="normal">The <code class="inlineCode">Provider</code> component is responsible for providing the shared data to its child components. We wrap the relevant portion of the component tree with the <code class="inlineCode">Provider</code> and pass the data using the <code class="inlineCode">value</code> prop:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;<span class="hljs-title">MyContext</span>.<span class="hljs-property">Provider</span> value={<span class="hljs-comment">/* shared data */</span>}&gt;
  {<span class="hljs-comment">/* Child components */</span>}
&lt;/<span class="hljs-title">MyContext</span>.<span class="hljs-property">Provider</span>&gt;
</code></pre>
    <p class="normal">Any component within <a id="_idIndexMarker145"/>the <code class="inlineCode">MyContext.Provider</code> can <a id="_idIndexMarker146"/>access the shared data using the <code class="inlineCode">Consumer</code> component or the <code class="inlineCode">useContext</code> hook. Let’s take a look at how to read context using a hook:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span>, { useContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = () =&gt; {
  <span class="hljs-keyword">const</span> value = <span class="hljs-title">useContext</span>(<span class="hljs-title">MyContext</span>);
  <span class="hljs-comment">// Render using the shared data</span>
};
</code></pre>
    <p class="normal">By utilizing the Context API, we can avoid the prop-drilling problem where data needs to be passed through multiple levels of components. It simplifies the process of sharing data and allows components to access the shared data directly, making the code more readable and maintainable.</p>
    <p class="normal">It’s worth noting that the Context API is not intended for all scenarios and should be used judiciously. It is most useful for sharing data that is truly global or relevant to a large portion of <a id="_idIndexMarker147"/>the <a id="_idIndexMarker148"/>component tree. For smaller-scale data sharing, props are still the recommended approach.</p>
    <h1 id="_idParaDest-66" class="heading-1">Memoization with Hooks</h1>
    <p class="normal">In React, function components are called on every render, which means that expensive computations and function creations can negatively impact performance. To optimize performance and prevent unnecessary recalculations, React provides three Hooks: <code class="inlineCode">useMemo</code>, <code class="inlineCode">useCallback</code>, and <code class="inlineCode">useRef</code>. These Hooks allow us to memoize values, functions, and references, respectively.</p>
    <h2 id="_idParaDest-67" class="heading-2">useMemo Hook</h2>
    <p class="normal">The <code class="inlineCode">useMemo</code> hook is used to <a id="_idIndexMarker149"/>memoize the result of a computation, ensuring that it is only recomputed when the dependencies have changed. It takes a function and an array of dependencies and returns the memoized value.</p>
    <p class="normal">Here’s an example of using the <code class="inlineCode">useMemo</code> hook:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title">Component</span> = () =&gt; {
  <span class="hljs-keyword">const</span> expensiveResult = <span class="hljs-title">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Expensive computation</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title">computeExpensiveValue</span>(dependency);
  }, [dependency]);
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>{expensiveResult}<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>;
};
</code></pre>
    <p class="normal">In this example, the <code class="inlineCode">expensiveResult</code> value is memoized using <code class="inlineCode">useMemo</code>. The computation inside the function is only executed when the <code class="inlineCode">dependency</code> value changes. If the <code class="inlineCode">dependency</code> remains the same, the previously memoized value is returned instead of recomputing the result.</p>
    <h2 id="_idParaDest-68" class="heading-2">useCallback hook</h2>
    <p class="normal">We already<a id="_idIndexMarker150"/> explored <code class="inlineCode">useCallback</code> hook in this chapter, but I want to highlight one important use case. When a function component renders, all of its functions are recreated, including any inline callbacks defined within the component. This can lead to unnecessary re-renders of child components that receive these callbacks as props, as they perceive the callback as a new reference and trigger re-renders. Let’s take a look at the example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = () =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">MyButton</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span> console.log("click")} /&gt;;
};
</code></pre>
    <p class="normal">In this example, the inline function we provide to the <code class="inlineCode">onClick</code> prop will be created every time <code class="inlineCode">MyComponent</code> renders. It means the <code class="inlineCode">MyButton</code> component will receive a new function reference each time, and as we already know, it will result in a new render for the <code class="inlineCode">MyButton</code> component.</p>
    <p class="normal">Here’s an example that demonstrates the use of the <code class="inlineCode">useCallback</code> hook:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = () =&gt; {
  <span class="hljs-keyword">const</span> clickHandler = <span class="hljs-title">React</span>.<span class="hljs-title">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">"click"</span>);
  }, []);
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">MyButton</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{clickHandler}</span><span class="hljs-tag"> /&gt;</span>;
};
</code></pre>
    <p class="normal">In this example, the <code class="inlineCode">clickHandler</code> function is memoized using <code class="inlineCode">useCallback</code>. The empty dependency array <code class="inlineCode">[]</code> indicates that the function has no dependencies and should remain constant throughout the component’s lifecycle. </p>
    <p class="normal">As a result, the same function instance is provided to <code class="inlineCode">MyButton</code> on each render of <code class="inlineCode">MyComponent</code>, preventing unnecessary re-renders of the child.</p>
    <h2 id="_idParaDest-69" class="heading-2">useRef hook</h2>
    <p class="normal">The <code class="inlineCode">useRef</code> hook allows<a id="_idIndexMarker151"/> us to create a mutable reference that persists across component renders. It is commonly used to store values or references that need to be preserved between renders without triggering re-renders. Additionally, <code class="inlineCode">useRef</code> can be used to access the DOM node or a React component instance:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Component</span> = () =&gt; {
  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title">useRef</span>();
  <span class="hljs-keyword">const</span> <span class="hljs-title">handleButtonClick</span> = () =&gt; {
    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title">focus</span>();
  };
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span><span class="hljs-tag"> </span><span class="hljs-attr">ref</span><span class="hljs-tag">=</span><span class="hljs-string">{inputRef}</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleButtonClick}</span><span class="hljs-tag">&gt;</span>Focus Input<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
};
</code></pre>
    <p class="normal">In this example, the <code class="inlineCode">inputRef</code> is created using <code class="inlineCode">useRef</code>, and it is assigned to the <code class="inlineCode">ref</code> attribute of the <code class="inlineCode">input</code> element. This allows us to access the DOM node using the <code class="inlineCode">inputRef.current</code> property. In the <code class="inlineCode">handleButtonClick</code> function, we call the focus method on the <code class="inlineCode">inputRef.current</code> to focus the input element when the button is clicked.</p>
    <p class="normal">By using <code class="inlineCode">useRef</code> to access the DOM node, we can interact with the underlying DOM elements directly without triggering re-renders of the component.</p>
    <p class="normal">By leveraging memoization with the <code class="inlineCode">useMemo</code>, <code class="inlineCode">useCallback</code>, and <code class="inlineCode">useRef</code> Hooks, we can optimize the performance of our React applications by avoiding unnecessary computations, preventing <a id="_idIndexMarker152"/>unnecessary re-renders, and preserving values and references across renders. This results in a smoother user experience and more efficient use of resources.</p>
    <h1 id="_idParaDest-70" class="heading-1">Summary</h1>
    <p class="normal">This chapter introduced you to React components and React Hooks. You learned about component properties or props by implementing code that passed property values from JSX to the component. Next, you found out what state is and how to manipulate it with the <code class="inlineCode">useState</code> hook. Then, you learned about <code class="inlineCode">useEffect</code>, which enables lifecycle management in functional React components, such as fetching API data when a component is mounted and cleaning up any pending async operations when it is removed. Then, you learned how to use the <code class="inlineCode">useContext()</code> hook in order to access global application data. Lastly, you learned about memoization with the <code class="inlineCode">useMemo</code>, <code class="inlineCode">useCallback</code>, and <code class="inlineCode">useMemo</code> Hooks.</p>
    <p class="normal">In the following chapter, you’ll learn about event handling with React components.</p>
  </div>
</body></html>