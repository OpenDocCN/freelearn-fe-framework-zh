- en: Chapter 6. Reacting with Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the previous chapters, we have dug deep into the react world. Let's
    now explore the new dimension of react world, Flux, which is nothing but a unidirectional
    dataflow architecture. Flux is developed by the Facebook internal development
    team and is used in order to build client-side web applications at Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics as we go along:'
  prefs: []
  type: TYPE_NORMAL
- en: The synopsis of Flux versus the MVC architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatchers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller-Views and Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Flux** should not be confused as a framework based on ReactJS. Flux is an
    architecture and is designed in order to reduce the complexity of a huge application
    built with **Model View Controller** (**MVC**) architecture and has been designed
    as an alternative of MVC.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the different Flux components:'
  prefs: []
  type: TYPE_NORMAL
- en: View—This is like for any web app, the views (basically the react component)
    receives the event and passes it to the Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action—They are helper methods (`actionCreators`) that pass the data (payload)
    and `actionType`, received from an external API/view to a dispatcher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatcher—These are Central hub of all registered callbacks. It receives the
    actions and acts as a "traffic controller" before it passes it to the Stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store—It is a data layer that stores all the computations and business logic.
    It is also responsible for storing the application state and the single source
    of truth for the application state. It receives the action from the dispatchers
    based on the registered callbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller-View—This receives the state from the stores based on the `changeEvents`
    and passes it to the React views component via props.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A diagram here illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of Flux](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Typical Flux Data Flow Architecture
  prefs: []
  type: TYPE_NORMAL
- en: Flux versus the MVC architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a typical application built on the MVC architecture, the views get updated
    from the data, which is typically stored in the models. As the application grows,
    the number of models and views also grow, and there grows the interdependency
    among the various models. Therefore the views also get tdependent on multiple
    models, thus increasing the complexity of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The interdependence of views and models can create diffraction in the source
    of truth, leading to increased application complexity and unpredictability. As
    a result, there needs to be a solution to internalize the control by moving all
    the control into the individual pieces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flux versus the MVC architecture](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Issue with a growing app built with MVC
  prefs: []
  type: TYPE_NORMAL
- en: Flux advantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to the Facebook Flux development team, the objects within a Flux
    application are highly decoupled, and adhere very strongly to the first part of
    the Law of Demeter: the principle that each object within a system should know
    as little as possible about the other objects in the system. This results in software
    that is more.'
  prefs: []
  type: TYPE_NORMAL
- en: Maintainable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adaptable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier and more predictable for new engineering team members to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is a Flux application structure of our `library_app` application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flux advantages](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our Library App Structure
  prefs: []
  type: TYPE_NORMAL
- en: Flux components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's dive into an application, built with Flux architecture with React View.
    Here, we will be building an app named `library_app`. This is a basic Flux-based
    ReactJS app, where we can borrow books from the `library_app` store to our reading
    list. Once we finish the book, we can strike it off from our reading list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the command line execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above will install the flux package as a node module and your library_app
    application will have a directory called node_modules with the flux library installed
    within it.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Actions** are typically the data that enters into an application, either
    directly from the View or from an external Web API. Each action is nothing but
    a JavaScript method, which contains two parts: the `actionType` and the actual
    data. The `actionCreators` methods are simply discrete, semantic helper functions
    that facilitate passing data to the *dispatcher* in the form of an *action*. The
    different types of actions are declared as a JavaScript object, in a file named
    `App-Constants.js`. According to the Flux app hierarchy, the `App-Contstants.js`
    file resides under `src/js/constants`. Typical example for such a file looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ADD_BOOK`, `DELETE_BOOK` are the actions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actions, by itself, do not contain any functionality of their own. Actions are
    typically executed by the stores and are available in order to trigger the views.
    In React, we have handful of helper methods named `actionCreators`, which ideally
    creates the action object and passes the action to the Flux dispatcher (`AppDispatcher`).
  prefs: []
  type: TYPE_NORMAL
- en: All the actions defined in the `AppConstants` are declared in the `AppActions`.
  prefs: []
  type: TYPE_NORMAL
- en: The use of constants in the `AppConstants`, which declares the action names,
    helps the developer to understand the app's functionality. As in our case, it
    deals with books.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example while adding books in a `library_app` store, we are
    dealing with four `actionTypes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADD_BOOK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE_BOOK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INC_BOOK_COUNT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEC_BOOK_COUNT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actions (such as `addBook`, `removeBook`, `incBookCount`, and `decBookCount`)
    are unique based on their `actionType` attribute. Thus, when these actions are
    dispatched by the dispatchers to the stores, stores mutates themselves depending
    on the specific callback registered with the dispatchers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical action file resides in `library_app/src/js/actions/app-actions.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Dispatchers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name aptly defines, **Flux dispatchers** dispatches the actions to the
    subsequent stores. Dispatchers can be called as a registry of callbacks. All the
    stores are registered with the dispatchers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key points of dispatcher are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: There is only one dispatcher per app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatchers being used as a center for all the registered callbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It functions as a broadcaster of all the actions to the stores. Dispatchers
    acts as a queue, which sequentially broadcasts the actions. This is different
    from generic pub-sub systems in the following two ways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks are not subscribed to particular events. Every payload is dispatched
    to every registered callback.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Callbacks can be deferred in whole or part until other callbacks have been executed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The dispatcher has the capability to invoke the callbacks in the order specified,
    and it waits for other updates (`waitFor()` method does that).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the flux library (`npm install flux`) `node_module`, the `register()` and
    `dispatch()` methods are defined, in the flux `library_app`, within the dispatcher
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the file located at `library_app/node_modules/Flux/lib/Dispatcher.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Thus, when the dispatchers receive the trigger (actions) from the Actions, it
    dispatches all the actions to the registered stores, one by one. This dispatching-flow
    is initiated with the `dispatch()` method, which passes the payload (data) to
    the registered store and has the callback registered to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an excerpt from the `Flux.js` library within the `node_modules`
    for the dispatcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The file location is at `library_app/src/js/dispatchers/app-dispatchers.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Before implementing the `library_app` store, let's check whether our payload
    (data) is printing out in the console. In order to do so, a handler function is
    created in the React `component app.js`, which is called when any part of the
    heading **My First Flux App** is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file location is `library_app/src/js/components/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Run the httpster from your application''s root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the browser and check the console, after clicking on the heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dispatchers](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot from library_app
  prefs: []
  type: TYPE_NORMAL
- en: 'For a quick recap about the flow of our bookstore app till now:'
  prefs: []
  type: TYPE_NORMAL
- en: The default `index.html` page serves the static content (Sample Application)
    on `localhost:3333`
  prefs: []
  type: TYPE_NORMAL
- en: The `index.html` page internally calls the `main.js`, which internally creates
    the React class and renders the content in the `<App />` React component (from
    the `src/js/components/app.js`). The React component is rendered in the `div`
    tag with ID `main`
  prefs: []
  type: TYPE_NORMAL
- en: Once we click on any portion of the `<App />` component (**My First Flux App**),
    an `onClick` event handler triggers the `handler()` function, which calls, `AppActions.addBook`
    (`This is the book..Sherlock Holmes`), here, `AppActions` in the `AppConstant`.
    `AddBook` is the specific action to be called with the `payload / item/ data`
    (`This is the book..Sherlock Holmes`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `AppActions.addBook` method is called, it is assigned to the callback
    `handleViewAction` of the dispatcher, with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`actionType`: `AppConstants.ADD_BOOK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`item`: `This is the book..Sherlock Holmes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `handleViewAction` method of the dispatcher passes the action (with `action_type`
    and `item`) and logs the output in the console and dispatches it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We see the following output in the `console.log` after clicking on **My First
    Flux App**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action Object { actionType: "ADD_BOOK", item: "This is the book..Sherlock
    Holmes" }`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is just a way to pass the JS objects (`item: "This is the book..Sherlock
    Holmes"`) in a uniform and expected manner for the store to handle. It simplifies
    the data flow of the application and makes tracing and debugging easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux stores can be comparable with the models in MVC, though essentially they
    are not the same. From similar point of view, they are the same as all the business
    logic and computations happen in the Flux store. According to the Facebook team,
    "Stores manage the state of many objects—they do not represent a single record
    of data like ORM models do. Nor they are the same as Backbone's collections. More
    than simply managing a collection of ORM-style objects, stores manages the application
    state for a particular **domain** within the application."
  prefs: []
  type: TYPE_NORMAL
- en: Source [https://en.wikipedia.org/wiki/Object-relational_mapping](https://en.wikipedia.org/wiki/Object-relational_mapping).
  prefs: []
  type: TYPE_NORMAL
- en: '*Object Relational Mapping (ORM) in computer science is a programming technique
    for converting data between incompatible type systems in object-oriented programming
    languages. This creates, in effect, a "virtual object database" that can be used
    from within the programming language. In object-oriented programming, data management
    tasks act on object-oriented (OO) objects that are almost always nonscalar values.
    For example, consider an address book entry that represents a single person along
    with zero or more phone numbers and zero or more addresses. This could be modeled
    in an object-oriented implementation by "Person object" with attributes/fields
    to hold each data item that the entry comprises: the person''s name, a list of
    phone numbers, and a list of addresses. The list of phone numbers would itself
    contain "PhoneNumber objects" and so on. The address book entry is treated as
    a single object by the programming language (it can be referenced by a single
    variable containing a pointer to the object, for instance). Various methods can
    be associated with the object, such as a method to return the preferred phone
    number, the home address, and so on.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The store(s) receives the action(s) from the dispatchers. Depending on the registered
    callback (with the dispatcher), the Store decides whether it should respond to
    the action dispatched by the dispatcher. No objects outside the app are responsible
    for changing the values within the Store or the Views. Thus any change, which
    is brought by the actions, results in the data change based on the registered
    callbacks and never by any setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: As the Flux stores update themselves without any external intervention, hence
    it reduces the complexities typically found in MVC applications. The Flux stores
    controls what happens within them, only the input is via the dispatchers. In a
    MVC app, interdependency of various models with various views may lead to instability
    and complicated test cases.
  prefs: []
  type: TYPE_NORMAL
- en: A single app can have multiple stores, based on its functionality, but each
    store deals with a single domain. A store exhibits characteristics of both collection
    of models and a singleton model of a logical domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is quick recap of Stores Functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Stores register itself with the dispatchers through callbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computations of the business logic reside in the stores as JS functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the action been dispatched from the dispatcher to the Stores, they are
    identified by the registered callbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action is acted upon within stores by the state update.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JS arrays: `_library` and `_readingItems` store the books available and what
    the reader wants to read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventEmitter` is a class of the events module, which is part of the Node.js
    core library. In this example, the event emitter function is done by the `eventEmitter.on()`
    method, where the first argument is the event, and the second argument is the
    function to be added. Thus, the `eventEmitter.on()` method simply registers the
    function. When the the `emit()` method is called, then it executes all the functions
    that are registered with the on method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public methods `getReadingList()` and `getLibrary()` allow us to get the
    computed data from the `_readingItems` and `_readingList` JS arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispatcherIndex` in the `app-stores.js` code is used in order to store the
    return value of the dispatcher''s registration method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The switch statement is the determining factor, in case of a dispatcher's broadcast,
    for what actions has to be performed. If a relevant action is taken, a change
    event is emitted and views that are listening for this event update their states.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the code for `app_stores.js` for our `library_app`. It has
    all the business logic and computations of our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`dispatcherIndex` is used to store the return value of the Dispatchers registration
    method. `dispatcherIndex` is used in case of `waitFor()` method, that is when
    one part of the app has to wait for another part of the app to get updated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code that shows the `dispatcherIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Controller-Views and Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Views are primarily the React Views, which essentially generate the actions.
    Controller-View listens to our stores, for any `changeEvent` been broadcasted.
    The `emitChange` events let our Controller-Views know if any change has to be
    performed into the state of the view or not. They are essentially React components.
    In our code, we have five such react components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app-addbooktoreadinglist.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app-booklist.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app-readinglist.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app-removefromreadinglist.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the code for `app-booklist.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code that is internally called on the `AddBookToReadingList`
    React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, the following component `<Booklist \>` is added in the `app.js`.
    This is essentially for the part where a user can see the books they have in the
    `ReadingList` list section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Revisiting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In each of the React components (`readingList` and `bookList`), `getInitialState()`
    is initialized with the store public method `getReadingList()` and `getLibrary()`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Various methods are executed at precise points in a component's lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: '`componentWillMount()` is a React lifecycle method. It is invoked once, both
    on the client and server, immediately before the initial rendering occurs. If
    you call `setState` within this method, `render()` will see the updated state
    and will be executed only once despite change in the state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Thus, `componentWillMount()` is listening to the `addChangeListener` (defined
    in the `AppStore` store). If the `_onChange` parameter is passed, then the current
    object (`_this`) is updated (`setState`) with the new/updated data/payload (`readingItems`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to remove the items from the reading list, the event listener (`handleClick`)
    is unmounted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the code of app-`removebookfromreadinglist.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The final view of our `library_app` Flux application
  prefs: []
  type: TYPE_NORMAL
- en: On clicking on the button **I want to borrow**, the corresponding book will
    come to my Reading List. Once I am done with the book, click on the button **Book
    Completed**, to remove the book from the reading list.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a screenshot of our `library_app` application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Revisiting the code](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to run this Flux app will be covered in the building and deployment structure
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the details of the components of a Flux-based app:'
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatchers (registry of callbacks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores (callbacks registered with dispatchers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controllers Views![Revisiting the code](img/00038.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: data flow in Flux app
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through our `libary_app` application, we have explored how the unidirectional
    data flow in a simple Flux-based application. The users can see the booklist in
    the views. They can add books in the reading list, thus the actions (adding books
    ) gets passed to the dispatchers. Internally the dispatchers have the registered
    callbacks with the stores. The stores then adds/removes the books based on the
    user's action and computes the business logic and re-renders the changes accordingly
    again to the views.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover React good practices and patterns. This includes
    practices to develop reusable components, how to structure your components hierarchically
    to a better data flow, and how to validate your components behavior. In our app,
    we'll be improving our components developed so far.
  prefs: []
  type: TYPE_NORMAL
