- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Styling, Storage, and Navigation in React Native
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native中的设计、存储和导航
- en: Now that you know the general concepts behind React Native, it’s time to have
    a deeper look at the most common areas of React Native.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了React Native背后的基本概念，是时候深入探讨React Native最常见的一些领域了。
- en: This chapter covers different areas, all of which are important when working
    with React Native. When creating a large app with React Native, you always have
    to have a good understanding of how the styling of your app works to create a
    beautiful product. Besides styling, there is another thing that decides if users
    will like your app from an aesthetic point of view – **animation**. However, this
    will be covered in [*Chapter 6*](B16694_06.xhtml#_idTextAnchor130), *Working with
    Animations*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了不同的领域，所有这些在处理React Native时都很重要。当使用React Native创建大型应用时，您始终需要深入了解您应用的设计风格，以创建一个美观的产品。除了设计风格外，还有另一个决定用户是否从美学角度喜欢您的应用的因素——**动画**。然而，这将在[*第6章*](B16694_06.xhtml#_idTextAnchor130)中介绍，*与动画一起工作*。
- en: Another thing we will focus on in this chapter is how to store data locally
    on users’ devices. Every platform works differently. While Android and iOS are
    quite similar and you can get access to the device’s storage with huge capacity,
    this is completely different when working with the web, where capacity is very
    limited.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将关注的另一件事是如何在用户的设备上本地存储数据。每个平台的工作方式都不同。虽然Android和iOS相当相似，并且您可以访问具有巨大容量的设备存储，但在与网络工作时就完全不同了，那里的容量非常有限。
- en: The last thing we’ll cover is how to navigate between screens in your React
    Native app. Again, this can differ from platform to platform, but you’ll get a
    good overview of the different navigation concepts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一件事是如何在您的React Native应用中在不同屏幕间导航。再次强调，这可能会因平台而异，但您将获得不同导航概念的全面概述。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding how to style a React Native app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何设计React Native应用
- en: Using local storage solutions in React Native
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React Native中使用本地存储解决方案
- en: Understanding navigation in React Native
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解React Native中的导航
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to run the code in this chapter, you must set up the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，您必须设置以下内容：
- en: A working React Native environment ([https://reactnative.dev/docs/environment-setup](https://reactnative.dev/docs/environment-setup)
    – React Native CLI Quickstart)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的React Native开发环境([https://reactnative.dev/docs/environment-setup](https://reactnative.dev/docs/environment-setup)
    – React Native CLI快速入门)
- en: While most of this chapter should also work on Windows, I recommend working
    on a Mac
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然本章的大部分内容也应该在Windows上工作，但我建议在Mac上工作
- en: Understanding how to style a React Native app
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解如何设计React Native应用
- en: You can choose from different solutions to handle styling in your React Native
    app. But before we take a look at the most common ones, you must understand the
    underlying concepts. The first thing we’ll cover in this chapter is what all these
    solutions try to achieve.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从不同的解决方案中选择来处理React Native应用中的设计。但在我们查看最常见的一些之前，您必须理解其背后的概念。在本章中，我们将首先介绍所有这些解决方案试图实现的目标。
- en: Make styling maintainable
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使设计可维护
- en: Styling is often handled very poorly when a project starts because it does not
    interfere with the business logic, so it isn’t likely to introduce bugs. So, most
    of the time, when thinking about the architecture of an application, most developers
    think of state management, data flow, component structure, and more, but not about
    styling. This always takes its toll when a project grows. It starts to take more
    and more time to keep a consistent design and making changes to your UI becomes
    a real pain.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目开始时，设计通常处理得非常糟糕，因为它不会干扰业务逻辑，因此不太可能引入错误。所以，大多数时候，当考虑应用架构时，大多数开发者会想到状态管理、数据流、组件结构等，但不会想到设计。当项目增长时，这总是要付出代价。保持一致的设计需要越来越多的时间，而更改UI变得真正痛苦。
- en: 'Therefore, you should think about how to handle styling in your application
    right at the beginning. No matter what solution or library you use, you should
    always stick to the following concepts:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您应该在应用一开始时就考虑如何处理设计。无论您使用什么解决方案或库，您都应该始终遵循以下概念：
- en: '**Use a central file for colors, fonts, and sizes**: This should either be
    a single file or one file for colors, one for fonts, and one for sizes such as
    margins, paddings, and border radiuses. I prefer to use a single file.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用中央文件存储颜色、字体和大小**：这应该是一个单独的文件，或者一个用于颜色，一个用于字体，一个用于大小，如边距、填充和边框半径。我更喜欢使用一个单独的文件。'
- en: '**Never hardcode values in your components/CSS files**: You should never use
    fixed values inside your component. Always use the values you define in your central
    file. This guarantees that your UI stays consistent and that you can easily change
    the values if you have to adapt.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永远不要在您的组件/CSS文件中硬编码值**：您永远不应该在组件中使用固定值。始终使用您在中央文件中定义的值。这保证了您的UI保持一致，并且如果您需要适应，您可以轻松地更改值。'
- en: '**Never duplicate code**: When you catch yourself copying the styling of parts
    of a component because it’s easier, faster, or more convenient, always keep in
    mind that it isn’t in the long run. Duplicate code always leads to inconsistencies
    in the UI and makes you have to touch multiple files when you want to change something
    later. So, instead of copying and pasting your code, extract it to a component
    or styles file. You will learn more about these options later.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永远不要重复代码**：当您发现自己因为更容易、更快或更方便而复制组件部分样式时，请始终记住这并不是长期之计。重复的代码总是会导致UI不一致，并在您稍后想要更改某些内容时让您不得不触摸多个文件。因此，与其复制粘贴代码，不如将其提取到组件或样式文件中。您稍后将会了解更多关于这些选项的信息。'
- en: When we come back to our example project with these concepts, we will have to
    refactor it because, at the moment, we violate all of these concepts. We have
    no central file; we have hardcoded values everywhere and we have a `backButton`
    style defined in multiple files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们带着这些概念回到我们的示例项目时，我们必须重构它，因为目前我们违反了所有这些概念。我们没有中央文件；我们在每个地方都硬编码了值，并且我们在多个文件中定义了`backButton`样式。
- en: 'First, let’s create a central file to store our values. This could look like
    this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个中央文件来存储我们的值。它可能看起来像这样：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we have all our values in one single place. If you take a deeper
    look, we also introduced dark mode to our app, which was a 3-minute task with
    our central color store. We only have to get the information about the device
    appearance settings and deliver the colors accordingly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们所有的值都集中在一个地方。如果您再深入一点看，我们还为我们应用引入了暗黑模式，这只是一个使用我们的中央颜色存储的3分钟任务。我们只需要获取设备外观设置的信息，并相应地提供颜色。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can test your app in dark mode very easily on the iOS Simulator. Go to **Settings**,
    scroll to the bottom, and choose **Developer**. The **Developer** screen will
    open; the first toggle activates **Dark Appearance**. If you support dark mode
    with our app, you should always test on two simulators – one in the dark mode
    and one in the light mode.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在iOS模拟器上非常容易地测试您的暗黑模式应用。前往**设置**，滚动到最底部，选择**开发者**。**开发者**屏幕将打开；第一个开关激活**暗黑外观**。如果您使用我们的应用支持暗黑模式，您应该始终在两个模拟器上测试——一个在暗黑模式，一个在亮模式。
- en: 'Now that we have our central store, let’s create a `<BackButton />` component
    to get rid of the duplicated style definitions. This can look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了中央存储，让我们创建一个`<BackButton />`组件来消除重复的样式定义。它可能看起来像这样：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In our newly created component, we don’t use fixed values anymore, but we are
    referencing the values in our central store.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们新创建的组件中，我们不再使用固定值，而是引用我们的中央存储中的值。
- en: Lastly, we have to go through our app, replace the `backButton` pressables with
    our new component, and replace the fixed values with references to our central
    store. With that, we have complied with the concepts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须遍历我们的应用，用我们的新组件替换`backButton`可点击部分，并用对中央存储的引用替换固定值。这样，我们就遵守了这些概念。
- en: These concepts are the core of different libraries or solutions. To choose the
    right solution for your project, one of the most important decisions is which
    platform to deploy to. The following subsection will cover the most common solutions,
    including information about which platform the solution works best on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念是不同库或解决方案的核心。为了为您的项目选择正确的解决方案，最重要的决定之一是部署到哪个平台。以下小节将涵盖最常见解决方案，包括有关解决方案在哪个平台上运行最佳的信息。
- en: Choosing the right styling solution
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的样式解决方案
- en: In this subsection, we’ll have a look at inline styling, React Native StyleSheets,
    CSS modules, and styled-components. All four solutions work well and have their
    benefits and drawbacks. We’ll start with inline styles.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将探讨内联样式、React Native样式表、CSS模块和styled-components。所有四种解决方案都运行良好，各有优缺点。我们将从内联样式开始。
- en: Using React Native inline styles
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用React Native内联样式
- en: 'To understand inline styles, let’s have a look at a code example. The following
    code shows the `<Header />` component from our example project from the previous
    chapter but it uses inline styles to style the `Text` component:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解内联样式，让我们看看一个代码示例。以下代码展示了上一章示例项目中的`<Header />`组件，但它使用了内联样式来设置`Text`组件的样式：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we can just create an object with the styling rules. This works
    and has a big advantage. Not only can you use fixed values, but you can also use
    any static or dynamic value you can access in your component. This can be very
    useful, especially when you are working with user-defined themes. But this approach
    also comes with multiple disadvantages.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以创建一个包含样式规则的对象。这可行，并且具有很大的优势。你不仅可以使用固定值，还可以使用你可以在组件中访问的任何静态或动态值。这非常有用，尤其是在你处理用户定义的主题时。但这种方法也有多个缺点。
- en: First, the code gets quite confusing when the project grows – at least, I think
    the code is hard to read when styling, components, and data are mixed in that
    way. So, I would always prefer to separate this as much as possible.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当项目规模扩大时，代码会变得相当混乱——至少，我认为当样式、组件和数据以这种方式混合时，代码难以阅读。因此，我会尽可能地将其分离。
- en: Next, you cannot reuse any styling. You must copy your styles every time you
    need them again. Now, you could argue that you wouldn’t have to copy the styles
    because you can simply extract the component that includes the style into a custom
    component. Although this is correct, there are some cases where you don’t want
    to do this. We’ll have a deeper look at these scenarios in the next subsection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你不能重用任何样式。每次你需要它们时，都必须复制你的样式。现在，你可以争辩说，你不需要复制样式，因为你可以简单地提取包含样式的组件到一个自定义组件中。尽管这是正确的，但有些情况下你不想这样做。我们将在下一小节中更深入地探讨这些场景。
- en: Next, we must think about performance. Inline style objects will be recreated
    at every render, which can negatively impact the performance and memory usage
    of your app.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须考虑性能。内联样式对象将在每次渲染时被重新创建，这可能会对你的应用性能和内存使用产生负面影响。
- en: Last, we’ll have a look at the different platforms. This inline style approach
    has very little room for optimization on build time for the different platforms.
    While this may be no real problem on Android, iOS, Windows, and macOS, it can
    become a real pain for the web because it makes your bundle size a lot larger.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨不同的平台。这种内联样式方法在构建不同平台时几乎没有优化空间。虽然这在Android、iOS、Windows和macOS上可能不是真正的问题，但对于Web来说，它可能会造成真正的痛苦，因为它会使你的包大小大大增加。
- en: On the web, you must think about load times a lot because the user has no installed
    version of your application. Also, search engines such as Google care a lot about
    load times, and it will affect your ranking positively or negatively. So, your
    styling code must be optimized during the build process, which is not possible
    with inline styles.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web上，你必须非常关注加载时间，因为用户没有安装你的应用程序的版本。此外，像Google这样的搜索引擎也非常关注加载时间，这会影响你的排名，产生正面或负面的影响。因此，你的样式代码必须在构建过程中进行优化，而内联样式无法做到这一点。
- en: To take advantage of optimization, you’ll have to use StyleSheets. We’ll have
    a look at them next.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用优化优势，你必须使用样式表。我们将在下一节中探讨它们。
- en: Using React Native StyleSheets
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用React Native样式表
- en: We used StyleSheets in our example app in the previous chapter, but we’ll have
    a look at them again here to truly understand their benefits. Not only do they
    make the code more readable and support a good separation of styling and business
    logic, but they also make it possible to use a lot of performance optimization
    at the build time and runtime of your app.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的示例应用中，我们使用了样式表（StyleSheets），但在这里我们再次探讨它们，以便真正理解它们的优点。样式表不仅使代码更易读，支持样式和业务逻辑的良好分离，而且还能在应用的构建时间和运行时实现许多性能优化。
- en: 'The following code is for the `<Header />` component from our example app.
    It uses React Native StyleSheets for styling:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是我们示例应用中的`<Header />`组件。它使用React Native样式表进行样式设置：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are multiple things you should realize when looking at this code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看此代码时，你应该意识到以下几点：
- en: First, it is much clearer and better separated.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它更加清晰且易于分离。
- en: Second, `StyleSheet` is defined outside of the component, which makes it persist
    between rerenders. This is better in terms of performance and memory usage.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，`StyleSheet` 是在组件外部定义的，这使得它在重新渲染之间保持持久。这在性能和内存使用方面更好。
- en: Third, `StyleSheet.create` will create errors in your simulator when you are
    using styles that can’t be interpreted. This can be very useful for catching bugs
    at a very early stage.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，当你使用无法解释的样式时，`StyleSheet.create` 会在你的模拟器中创建错误。这可以在非常早期的阶段帮助你捕捉到错误。
- en: But the biggest benefit of StyleSheets is the possibility to optimize your styling
    code for the web. The open source web library known as react-native-web does a
    great job of splitting all the StyleSheets of your application into classes and
    adding the needed class names to your components. This makes your code small and
    optimized and improves your load time a lot.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但 StyleSheet 最大的好处是能够优化你的样式代码以适应网页。开源的网页库 react-native-web 能够很好地将你的应用程序中的所有
    StyleSheet 分割成类，并将所需的类名添加到你的组件中。这使得你的代码更小、更优化，并且大大提高了加载时间。
- en: 'Besides all these benefits, there is one problem with StyleSheets. Since they
    are declared outside of your component, you cannot access your component variables,
    such as state and props. This means that if you want to use a user-generated value
    in your styling, you have to combine your StyleSheet values with inline styles,
    like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些优势之外，StyleSheet 还有一个问题。由于它们是在组件外部声明的，因此你无法访问组件变量，如状态和属性。这意味着，如果你想在你的样式中使用用户生成的值，你必须将
    StyleSheet 的值与内联样式结合，如下所示：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code would use the `title` style from the StyleSheet and add a user-defined
    color to the `<Text />` component. This combined approach can also be used when
    working with animations. You can read more about this in [*Chapter 6*](B16694_06.xhtml#_idTextAnchor130),
    *Working with Animations*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会使用 StyleSheet 中的 `title` 风格，并为 `<Text />` 组件添加一个用户定义的颜色。这种结合方法也可以在处理动画时使用。你可以在[*第6章*](B16694_06.xhtml#_idTextAnchor130)
    *处理动画* 中了解更多相关信息。
- en: Last, we’ll have a look at another benefit of StyleSheets. You can use a style
    multiple times in your component. Again, if you stick to my recommendations, you
    will never have to do that because you will be creating a custom component in
    these scenarios. But for daily work, there are circumstances where it is faster
    to not create a component and where it also does not hurt.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨 StyleSheet 的另一个好处。你可以在组件中多次使用一个样式。再次强调，如果你坚持我的建议，你永远不会需要这样做，因为在这种情况下你会创建一个自定义组件。但在日常工作中，有些情况下不创建组件更快，而且也不会造成伤害。
- en: For example, if you have a simple component with two lines of text, you can
    either create a `<TextLine />` component and use it two times, or simply use two
    `<Text />` components with the same style reference in a StyleSheet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个包含两行文本的简单组件，你可以创建一个 `<TextLine />` 组件并使用两次，或者简单地使用两个具有相同样式引用的 `<Text
    />` 组件，并在 StyleSheet 中引用。
- en: This first approach with the `<TextLine />` component is the cleaner one, but
    the second approach will save you some time and does not create problems in the
    long run. So, in this case, StyleSheets have another benefit versus inline styles.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<TextLine />` 组件的第一种方法更为简洁，但第二种方法可以节省你的时间，并且从长远来看不会产生问题。因此，在这种情况下，StyleSheet
    相比内联样式有另一个优势。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Always be careful when you use the same style multiple times. While it can be
    useful, in many cases, you duplicate code that should be extracted into a custom
    component.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你多次使用相同的样式时，一定要小心。虽然这可能有帮助，但在许多情况下，你会重复代码，这些代码应该被提取到自定义组件中。
- en: Now that we understand this built-in solution, let’s look at two solutions that
    need external libraries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这个内置解决方案，让我们看看需要外部库的两个解决方案。
- en: Styling with CSS modules
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 CSS 模块进行样式设置
- en: CSS modules are very popular on the web. You use CSS, Sass, or Less to style
    your components. In most cases, you would end up having one additional style file
    per component. Experts often argue if that’s good or bad.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 模块在网页上非常流行。你使用 CSS、Sass 或 Less 来设置组件样式。在大多数情况下，你将为每个组件创建一个额外的样式文件。专家们经常争论这是好是坏。
- en: You have an additional file, but you have a clear separation between styling
    and components. I do like the separation, but if you manage to split your application
    into small components, adding the style directly to the component is fine from
    my point of view.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个额外的文件，但你将样式和组件之间的分离做得非常清晰。我确实喜欢这种分离，但如果你能将应用程序拆分成小的组件，直接将样式添加到组件中也是可以的，从我的角度来看。
- en: Using CSS modules in React Native needs some additional configuration. Since
    React Native does not have a built-in CSS processor, you must transform your CSS
    code into JavaScript styles before it can be displayed. This can be done with
    the babel transformer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Native 中使用 CSS 模块需要一些额外的配置。由于 React Native 没有内置的 CSS 处理器，你必须将你的 CSS
    代码转换为 JavaScript 样式，然后才能显示。这可以通过 babel 转换器来完成。
- en: CSS modules can be a great choice if you share your styles between React (the
    web) and React Native projects, without using react-native-web to generate the
    web part. This is especially true when you are building an app for an existing
    web application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在 React（网页）和 React Native 项目之间共享样式，而不使用 react-native-web 生成网页部分，CSS 模块可以是一个很好的选择。这尤其适用于你正在为现有的网页应用程序构建应用程序时。
- en: One very important problem with this approach is that you can’t use your JavaScript
    variables in your CSS modules. Even though you can create and use CSS variables,
    this does not enable you to use user-generated values in your styles.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个非常重要的问题是，你无法在 CSS 模块中使用你的 JavaScript 变量。尽管你可以创建和使用 CSS 变量，但这并不允许你在样式中使用用户生成的值。
- en: If you start a green field project for Android, iOS, Windows, or Mac, I wouldn’t
    recommend using CSS modules since, for these platforms, the CSS module approach
    has no benefits over StyleSheets. Again, the only scenario where I would recommend
    using CSS modules is when you build an app for an existing web application that
    is based on CSS modules.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始一个针对 Android、iOS、Windows 或 Mac 的新项目，我不建议使用 CSS 模块，因为这些平台，CSS 模块方法与 StyleSheets
    没有优势。再次强调，我唯一推荐使用 CSS 模块的情况是当你为基于 CSS 模块的老旧网页应用程序构建应用程序时。
- en: There is also another solution that is very popular for React web projects that
    can be used in React Native. It’s called **styled-components** and you’ll learn
    about it in the next subsection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 React 网页项目，还有一个非常流行的解决方案，也可以用于 React Native。它被称为 **styled-components**，你将在下一个子节中了解它。
- en: Understanding styled-components
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 styled-components
- en: '`View` and `Text`, you enhance them with tagged template literals to create
    new components, called styled-components.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`View` 和 `Text`，你可以通过标签模板字面量来增强它们，创建新的组件，称为 styled-components。'
- en: 'The following code shows the `<Header />` component in our example project
    but styled with styled-components:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们示例项目中用 styled-components 样式化的 `<Header />` 组件：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we create the `StyledText` component by using `styled` from
    styled-components and add a template literal to the React Native `Text` component.
    Inside this literal, we can write plain CSS. The cool thing here is that we can
    also use JavaScript variables and we can even pass props to our styled-component.
    This would look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们通过使用 styled-components 中的 `styled` 创建 `StyledText` 组件，并将模板字面量添加到 React
    Native 的 `Text` 组件中。在这个字面量内部，我们可以编写纯 CSS。这里酷的地方在于我们还可以使用 JavaScript 变量，甚至可以将属性传递给我们的
    styled-component。这看起来会是这样：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is how we would pass a property to our `StyledText` component. Now, we
    can use this property inside our template literal:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们向 `StyledText` 组件传递属性的方式。现在，我们可以在模板字面量中使用这个属性：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function is called **interpolation** and makes it possible to use user-generated
    content inside the CSS of our styled-components.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被称为 **插值**，它使得在 styled-components 的 CSS 中使用用户生成的内容成为可能。
- en: This is awesome because it solves a lot of problems, supports a clear separation
    between structure and styling, and allows us to use regular CSS, which is more
    familiar to most developers than the camel-cased CSS in the JavaScript of StyleSheets.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了，因为它解决了许多问题，支持结构和样式之间的清晰分离，并允许我们使用常规 CSS，这对于大多数开发者来说比 StyleSheets 中的驼峰式
    CSS 更熟悉。
- en: While I like this approach for the web, I remain critical of it for app-only
    projects. The styled-components library has a lot of useful optimization features
    for the web, but on pure React Native projects, it also compiles to CSS in JavaScript
    styles. In addition, it doesn’t provide support for animations, which is a very
    important part of modern apps. You can read more about this in [*Chapter 6*](B16694_06.xhtml#_idTextAnchor130),
    *Working with Animations*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我喜欢这种网络方法，但我对仅适用于应用的项目的这种方法持批评态度。styled-components 库为网络提供了许多有用的优化功能，但在纯 React
    Native 项目中，它也会将 CSS 编译成 JavaScript 风格。此外，它不提供对动画的支持，这是现代应用非常重要的一个部分。你可以在[*第6章*](B16694_06.xhtml#_idTextAnchor130)
    *与动画一起工作*中了解更多关于这一点。
- en: Although I wouldn’t recommend using styled-components for pure React Native
    projects, they can be very useful when you try to share your styling code between
    React Native and React projects, without using react-native-web. In this case,
    you can benefit from styled-components a lot.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不会推荐在纯 React Native 项目中使用 styled-components，但当你尝试在 React Native 和 React 项目之间共享样式代码而不使用
    react-native-web 时，它们可以非常有用。在这种情况下，你可以从 styled-components 中获得很多好处。
- en: If you want to have a deeper look at styled-components, I recommend reading
    the official documentation at [https://styled-components.com/docs](https://styled-components.com/docs).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解 styled-components，我建议阅读官方文档[https://styled-components.com/docs](https://styled-components.com/docs)。
- en: In this section, we learned the most important concepts of styling your React
    Native app and looked at the most common solutions to implement the styles. Most
    of the time, you wouldn’t write all your styles on your own but use a UI library.
    This will be handled in [*Chapter 9*](B16694_09.xhtml#_idTextAnchor282), *Essential
    Tools for Improving React Native Development*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了为 React Native 应用进行样式化的最重要的概念，并查看了一些最常用的实现样式的解决方案。大多数时候，你不会自己编写所有的样式，而是使用
    UI 库。这将在[*第9章*](B16694_09.xhtml#_idTextAnchor282) *提高 React Native 开发的必备工具*中处理。
- en: If you want to see all changes to the example project, please have a look at
    the repository for this example project and choose the `chapter-4-styling` tag.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看示例项目的所有更改，请查看此示例项目的存储库，并选择`chapter-4-styling`标签。
- en: Now that we know how to style our app, it’s time to store some data on the user’s
    device.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何为我们的应用进行样式化，是时候在用户的设备上存储一些数据了。
- en: Using local storage solutions in React Native
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React Native 中使用本地存储解决方案
- en: Storing data locally is a very important task in mobile apps. Even nowadays,
    you cannot be sure that a mobile device is always connected to the internet. Because
    of this, it is best practice to create your app in such a way that it has as much
    functionality as possible, even without a connection to the internet. That said,
    you can see why storing data locally is important for React Native apps.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动应用中，存储数据是一个非常重要的任务。即使现在，你也无法保证移动设备始终连接到互联网。正因为如此，最佳实践是创建你的应用，使其尽可能多地具有功能，即使在没有互联网连接的情况下也是如此。话虽如此，你可以看到为什么在
    React Native 应用中本地存储数据很重要。
- en: The most important criterion for differentiation for local storage solutions
    is if it is a secure or an unsecure storage solution. Since most apps store at
    least some information about the user, you should always think about which information
    you want to put in which store.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地存储解决方案来说，最重要的区分标准是它是否是一个安全的或非安全的存储解决方案。由于大多数应用至少存储了一些关于用户的信息，你应该始终考虑你想要将哪些信息放入哪个存储中。
- en: Important
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Always use a secure storage solution to store sensitive information.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用安全的存储解决方案来存储敏感信息。
- en: While it is important to store sensitive data in a secure store, most data,
    such as user progress, app content, and more, can be stored in a *normal* storage
    solution. Secure storage operations always come with some overhead due to encryption/decryption
    and/or accessing special device functionalities, so you should only use them for
    sensitive information to prevent a negative impact on your app’s performance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在安全存储中存储敏感数据很重要，但大多数数据，如用户进度、应用内容等，都可以存储在*普通*存储解决方案中。由于加密/解密和/或访问特殊设备功能，安全存储操作总是伴随着一些开销，因此你应该只为敏感信息使用它们，以防止对应用性能产生负面影响。
- en: In the following subsection, you will learn about the most common storage solutions
    for normal data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的子节中，你将了解最常见的用于常规数据的存储解决方案。
- en: Storing non-sensitive data
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储非敏感数据
- en: For a long time, React Native shipped with its built-in storage solution called
    AsyncStorage. But since the React Native core team at Facebook tried to reduce
    the React Native core to the minimum (lean core), AsyncStorage was handed over
    to the community for further development.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间里，React Native都自带了一个名为AsyncStorage的内置存储解决方案。但自从Facebook的React Native核心团队试图将React
    Native核心降至最低（轻量级核心）以来，AsyncStorage被转交给社区进行进一步开发。
- en: Nevertheless, it is very well maintained and most likely the most used storage
    solution. Besides `AsyncStorage`, other common solutions include `react-native-mmkv`/`react-native-mmkv-storage`,
    `react-native-sqlite-storage`/`react-native-quick-sqlite` and `react-native-fs`.
    All these solutions have their strengths and weaknesses, work completely differently,
    and can be used for slightly different tasks. Let’s start with the most popular
    one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，它得到了非常好的维护，并且很可能是最常用的存储解决方案。除了`AsyncStorage`之外，其他常见解决方案还包括`react-native-mmkv`/`react-native-mmkv-storage`、`react-native-sqlite-storage`/`react-native-quick-sqlite`和`react-native-fs`。所有这些解决方案都有其优缺点，工作方式完全不同，并且可以用于不同的任务。让我们从最受欢迎的一个开始。
- en: Working with AsyncStorage
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与AsyncStorage一起工作
- en: '`AsyncStorage` is a simple key/value store that can be used to store data.
    While it can only store primitive data, you must serialize complex objects to
    JSON before storing them. Nevertheless, it is very simple to use. The API looks
    like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncStorage`是一个简单的键/值存储，可以用来存储数据。虽然它只能存储原始数据，但在存储之前必须将复杂对象序列化为JSON。尽管如此，它非常易于使用。API看起来是这样的：'
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, there are very simple APIs for setting and getting data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，设置和获取数据的API非常简单。
- en: '`AsyncStorage` is not encrypted and cannot be used to run complex queries.
    It is a simple key/value store; there is no database. Also, it does not support
    transactions or locking. This means you have to be extremely careful when you
    write/read to/from different parts of your application.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncStorage`未加密，不能用于运行复杂查询。它是一个简单的键/值存储；没有数据库。它也不支持事务或锁定。这意味着在您向应用程序的不同部分写入/读取时必须非常小心。'
- en: I recommend using it to store user progress, information about app content,
    and any other data that does not have to be searchable. For more information on
    installing and using `AsyncStorage`, please look at the official documentation
    at [https://react-native-async-storage.github.io/async-storage/docs/install/](https://react-native-async-storage.github.io/async-storage/docs/install/).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议用它来存储用户进度、关于应用内容的信息以及任何不需要可搜索的数据。有关安装和使用`AsyncStorage`的更多信息，请参阅官方文档[https://react-native-async-storage.github.io/async-storage/docs/install/](https://react-native-async-storage.github.io/async-storage/docs/install/)。
- en: A relatively new alternative to `AsyncStorage` is MMKV for React Native. It
    is up to 30 times faster and comes with a lot more features.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 相较于`AsyncStorage`，MMKV是React Native的一个较新的替代方案。它的速度可以快到30倍，并且拥有更多功能。
- en: Working with MMKV in React Native
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在React Native中使用MMKV
- en: '**MMKV** is a native storage solution developed by WeChat and used in their
    production app. There are multiple React Native wrappers for this native solution;
    most of them are already based on JSI and therefore support synchronous and super-fast
    access.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**MMKV**是由微信开发并用于其生产应用的本地存储解决方案。有多个React Native包装器用于这个本地解决方案；其中大多数已经基于JSI，因此支持同步和超快访问。'
- en: 'Like `AsyncStorage`, MMKV is a simple key/value store. This means complex objects
    must be serialized to JSON strings before they can be stored. The API is nearly
    as simple as `AsyncStorage`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与`AsyncStorage`一样，MMKV是一个简单的键/值存储。这意味着在存储之前，复杂对象必须序列化为JSON字符串。API几乎与`AsyncStorage`一样简单：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, thanks to JSI, the API is synchronous, so we don’t need to work
    with async/await syntax. In the second line, you can see the initialization of
    the store. This is one advantage over `AsyncStorage` because you can work with
    multiple instances of MMKV stores.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，得益于JSI，API是同步的，因此我们不需要处理async/await语法。在第二行，您可以看到存储的初始化。这是相较于`AsyncStorage`的一个优势，因为您可以使用多个MMKV存储实例。
- en: While it is possible to encrypt data with MMKV, at the time of writing, there
    is no secure solution regarding how to handle the key. Therefore, I would only
    recommend using it to store non-sensitive data. This may change in the future.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MMKV可以加密数据，但在撰写本文时，关于如何处理密钥尚无安全解决方案。因此，我仅建议用于存储非敏感数据。这在未来可能会有所改变。
- en: 'MMKV can be used as a faster drop-in replacement for `AsyncStorage`. The only
    disadvantage MMKV has compared to `AsyncStorage` is that the React Native wrappers
    are not used that much at the time of writing. There are two well-maintained React
    Native MMKV mappers, so you should have a look at them when you consider using
    MMKV for your project. You can find more information about installation, usage,
    and APIs there. The first one is `react-native-mmkv`. It is a leaner project and
    comes with a simpler API. It’s also much simpler to install. You can have a look
    at it here: https://github.com/mrousavy/react-native-mmkv. The second one is `react-native-mmkv-storage`.
    It provides more features, such as indexing and data life cycle methods, which
    can be very useful when it comes to locking and transactions. You can have a look
    at it here: [https://github.com/ammarahm-ed/react-native-mmkv-storage](https://github.com/ammarahm-ed/react-native-mmkv-storage).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: MMKV 可以用作 `AsyncStorage` 的更快替代品。与 `AsyncStorage` 相比，MMKV 的唯一缺点是，在撰写本文时，React
    Native 包装器使用得并不多。有两个维护良好的 React Native MMKV 映射器，所以当你考虑在你的项目中使用 MMKV 时，你应该看看它们。你可以在那里找到有关安装、使用和
    API 的更多信息。第一个是 `react-native-mmkv`。这是一个更精简的项目，并附带一个更简单的 API。它也更容易安装。你可以在这里查看它：[https://github.com/mrousavy/react-native-mmkv](https://github.com/mrousavy/react-native-mmkv)。第二个是
    `react-native-mmkv-storage`。它提供了更多功能，例如索引和数据生命周期方法，这在锁定和事务处理时可能非常有用。你可以在这里查看它：[https://github.com/ammarahm-ed/react-native-mmkv-storage](https://github.com/ammarahm-ed/react-native-mmkv-storage)。
- en: 'Now that we’ve looked at `AsyncStorage` and MMKV, which handle very similar
    use cases, let’s look at a solution that comes with some more features: SQLite.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了处理非常类似用例的 `AsyncStorage` 和 MMKV，让我们看看一个带有更多功能的解决方案：SQLite。
- en: Working with SQLite
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与 SQLite 一起工作
- en: Compared to `AsyncStorage` and MMKV, SQLite is not only a simple key/value store
    – it is a complete database engine that includes functionalities such as locking,
    transactions, and advanced querying.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `AsyncStorage` 和 MMKV 相比，SQLite 不仅仅是一个简单的键值存储 – 它是一个完整的数据库引擎，包括锁定、事务和高级查询等功能。
- en: 'However, this means you can’t simply store your objects as serialized data.
    SQLite uses SQL queries and tables to store your data, which means you have to
    process your objects. To insert data, you must create a table with a column for
    each property and then insert every object with a SQL statement. Let’s have a
    look at the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这意味着你不能简单地以序列化数据的形式存储你的对象。SQLite 使用 SQL 查询和表来存储你的数据，这意味着你必须处理你的对象。要插入数据，你必须创建一个包含每个属性的列的表，然后使用
    SQL 语句插入每个对象。让我们看看下面的代码：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, it takes much more code to insert and query data. You need to
    create and execute SQL and process the data you get to have it in a format you
    can work with. This means that SQLite isn’t as easy and fast to use as `AsyncStorage`
    and MMKV, but it comes with advanced querying features. This means that you can
    filter and search your data and even join different tables.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，插入和查询数据需要更多的代码。你需要创建和执行 SQL，并处理你得到的数据，以便你可以以可以工作的格式使用它。这意味着 SQLite 并不像
    `AsyncStorage` 和 MMKV 那样容易和快速使用，但它提供了高级查询功能。这意味着你可以过滤和搜索你的数据，甚至连接不同的表。
- en: I would recommend using SQLite if you have very complex data structures, where
    you need to join and query different objects or tables a lot. I prefer simpler
    solutions for local data storage, but there are use cases where SQLite is the
    better fit.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有非常复杂的数据结构，需要大量地连接和查询不同的对象或表，我会推荐使用 SQLite。我更喜欢用于本地数据存储的简单解决方案，但也有一些情况，SQLite
    是更好的选择。
- en: Besides the higher complexity of using it, SQLite also adds some MB to your
    app size because it adds its SQLite database engine implementation to your app.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用它的更高复杂性之外，SQLite 还会增加一些 MB 到你的应用大小，因为它将它的 SQLite 数据库引擎实现添加到你的应用中。
- en: The most used React Native wrapper for SQLite is `react-native-sqlite-storage`.
    The API is simple, and it is used in a lot of projects. You can learn more about
    it at [https://github.com/andpor/react-native-sqlite-storage](https://github.com/andpor/react-native-sqlite-storage).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的 React Native SQLite 包装器是 `react-native-sqlite-storage`。API 简单，并被许多项目使用。你可以在
    [https://github.com/andpor/react-native-sqlite-storage](https://github.com/andpor/react-native-sqlite-storage)
    上了解更多信息。
- en: Another solution is `react-native-quick-sqlite`. It is a relatively new library,
    but it is based on JSI and therefore up to five times as fast as other solutions.
    You can learn more about it at [https://github.com/ospfranco/react-native-quick-sqlite](https://github.com/ospfranco/react-native-quick-sqlite).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是 `react-native-quick-sqlite`。这是一个相对较新的库，但它基于 JSI，因此比其他解决方案快五倍。您可以在[https://github.com/ospfranco/react-native-quick-sqlite](https://github.com/ospfranco/react-native-quick-sqlite)了解更多信息。
- en: Now that you’ve learned about the SQLite database engine, let’s look at another
    use case. Sometimes, you have to store large amounts of data, which means you
    need direct access to the filesystem. This is what we’ll explore next.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了SQLite数据库引擎，让我们看看另一个用例。有时，您需要存储大量数据，这意味着您需要直接访问文件系统。这就是我们接下来要探讨的。
- en: Using the filesystem with React Native
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在React Native中使用文件系统
- en: To store large amounts of data, it is always a good idea to create and store
    files. On iOS and Android, every app runs in a sandbox that no other app has access
    to. While that does not mean that all your files are secure – they can be retrieved
    by the user quite easily – it gives you at least some level of privacy regarding
    your data. However, this sandbox mode means that you cannot access the data of
    other apps.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储大量数据，创建并存储文件始终是一个好主意。在iOS和Android上，每个应用程序都在一个沙盒中运行，其他应用程序无法访问。虽然这并不意味着您的所有文件都是安全的——用户可以非常容易地检索它们——但它至少为您提供了关于您数据的一些隐私保护。然而，这种沙盒模式意味着您无法访问其他应用程序的数据。
- en: To read and write data to your app’s sandbox in React Native, you can use libraries
    such as `react-native-fs`. This library provides constants with the paths you
    have access to and lets you read and write files from the filesystem.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native中，要读取和写入应用程序沙盒中的数据，您可以使用如 `react-native-fs` 这样的库。这个库提供了您可访问的路径常量，并允许您从文件系统中读取和写入文件。
- en: I recommend using this approach when you’re synchronizing files from a server
    or writing large amounts of data. Most of the time, you can combine this approach
    with one of the previous approaches to store files locally and then store the
    path of the file in one of the other storage solutions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在您从服务器同步文件或写入大量数据时使用这种方法。大多数情况下，您可以结合之前提到的一种方法来本地存储文件，然后将文件的路径存储在其他存储解决方案之一中。
- en: If you want to find out more about filesystem access on React Native, please
    have a look at the documentation of `react-native-fs` at [https://github.com/itinance/react-native-fs](https://github.com/itinance/react-native-fs).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于React Native中文件系统访问的信息，请查看 `react-native-fs` 的文档，网址为[https://github.com/itinance/react-native-fs](https://github.com/itinance/react-native-fs)。
- en: With that, we’ve covered the most common solutions for storing and accessing
    non-sensitive data. This is where you should store most of your data. However,
    some data contains sensitive information such as passwords or other user information.
    This data needs another level of protection. So, let’s have a look at some storage
    solutions for sensitive information in React Native.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经涵盖了存储和访问非敏感数据的最常见解决方案。这是您应该存储大部分数据的地方。然而，某些数据包含敏感信息，如密码或其他用户信息。这些数据需要另一级别的保护。因此，让我们看看React
    Native中敏感信息的存储解决方案。
- en: Storing sensitive data
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储敏感数据
- en: When you store sensitive information on the device of a user, you should always
    think about how to secure it. Most of the time, this will be irrelevant, but when
    the user loses the device, you should make sure that their sensitive information
    is as secure as possible.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在用户的设备上存储敏感信息时，您应该始终考虑如何保护它。大多数情况下，这将是无关紧要的，但当一个用户丢失设备时，您应该确保他们的敏感信息尽可能安全。
- en: You will never be able to ensure 100% data security when you have no control
    over the device. However, we need to do the best we can to make it as hard as
    possible for that sensitive information to be retrieved.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当您无法控制设备时，您永远无法确保100%的数据安全。然而，我们需要尽我们所能，使敏感信息尽可能难以被检索。
- en: 'The first thing you should consider is if it is necessary to persist the information.
    Information that is not there cannot be stolen. If you need to persist information,
    use secure storage. Android and iOS provide built-in solutions for securely storing
    data. React Native provides wrappers for these native built-in solutions. The
    following ones are well maintained and can be used with ease:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先应该考虑的是是否需要持久化信息。不存在的信息无法被盗取。如果你需要持久化信息，请使用安全存储。Android和iOS提供了内置的安全存储数据解决方案。React
    Native为这些原生内置解决方案提供了包装器。以下是一些维护良好且易于使用的解决方案：
- en: '`expo-secure-store`: Uses iOS Keychain and Android `SharedPreferences` combined
    with Keystore System. It provides an easy API and can store values up to 2,048
    bytes in size. More information can be found at [https://docs.expo.dev/versions/latest/sdk/securestore/](https://docs.expo.dev/versions/latest/sdk/securestore/).'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expo-secure-store`：使用iOS Keychain和Android `SharedPreferences`结合Keystore System。它提供了一个简单的API，可以存储高达2,048字节的值。更多信息可以在[https://docs.expo.dev/versions/latest/sdk/securestore/](https://docs.expo.dev/versions/latest/sdk/securestore/)找到。'
- en: '`react-native-sensitive-info`: This library is very well maintained and provides
    a lot of functionality. It also adds another layer of security, which protects
    your data even on rooted devices. It supports Android, iOS, and Windows. More
    information can be found at [https://mcodex.dev/react-native-sensitive-info/](https://mcodex.dev/react-native-sensitive-info/).'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-sensitive-info`：这个库维护得很好，提供了很多功能。它还增加了一层安全保护，即使在rooted设备上也能保护你的数据。它支持Android、iOS和Windows。更多信息可以在[https://mcodex.dev/react-native-sensitive-info/](https://mcodex.dev/react-native-sensitive-info/)找到。'
- en: '`react-native-keychain`: This is another well-maintained library with an easy
    API. It supports Android and iOS and encrypts data on all devices. More information
    can be found at [https://github.com/oblador/react-native-keychain](https://github.com/oblador/react-native-keychain).'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-keychain`：这是一个维护得很好的库，具有简单的API。它支持Android和iOS，并在所有设备上加密数据。更多信息可以在[https://github.com/oblador/react-native-keychain](https://github.com/oblador/react-native-keychain)找到。'
- en: Again, even if these solutions are very good and secure, based on native implementations,
    there will never be 100% security for data. So, please only persist necessary.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，尽管这些解决方案非常好且安全，基于原生实现，但数据永远无法达到100%的安全。因此，请只保留必要的。
- en: Now that you learned about data storage solutions and the difference between
    sensitive and non-sensitive data, it’s time to look at navigation in React Native
    apps.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了数据存储解决方案以及敏感数据和非敏感数据之间的区别，是时候看看React Native应用中的导航了。
- en: Understanding navigation in React Native
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解React Native中的导航
- en: React Native does not come with a built-in navigation solution. That’s why we
    worked with a global state and simply switched components while navigating in
    our example app. While this works technically, it does not provide a great user
    experience.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: React Native没有内置的导航解决方案。这就是为什么我们在示例应用中与全局状态一起工作，并在导航时简单地切换组件。虽然这在技术上可行，但它并不提供良好的用户体验。
- en: Modern navigation solutions include performance optimization, animations, integration
    in global state management solutions, and much more. Before we dive deep into
    these solutions, let’s see what navigation looks like on different platforms.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现代导航解决方案包括性能优化、动画、集成到全局状态管理解决方案中等等。在我们深入探讨这些解决方案之前，让我们看看不同平台上的导航是什么样的。
- en: Navigating different platforms
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不同平台上的导航
- en: If you open any iOS or Android app, you’ll soon realize that navigation in an
    app is completely different from navigating the web in a browser. A browser navigates
    from page to page by replacing the old page with the new one. In addition to that,
    every page has a URL and can be accessed directly if it’s typed in the browser’s
    address bar.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开任何iOS或Android应用，你很快就会意识到应用中的导航与在浏览器中导航网页完全不同。浏览器通过用新页面替换旧页面来从一个页面导航到另一个页面。除此之外，每个页面都有一个URL，如果它在浏览器的地址栏中输入，可以直接访问。
- en: In an iOS or Android app, navigation takes the form of a combination of different
    navigators. The page you navigate away from doesn’t always get replaced by the
    new one. Multiple pages can be active at the same time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS或Android应用中，导航以不同导航器的组合形式出现。你导航离开的页面不一定会被新的页面替换。可以同时激活多个页面。
- en: 'Let’s have a look at the most common navigation scenarios and navigators to
    handle these scenarios:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看最常见的导航场景和用于处理这些场景的导航器：
- en: '**Stack navigator**: When navigating to a new page in a stack navigator, the
    new page is pushed on top of the old page. Nevertheless, the old page doesn’t
    get unmounted. It continues to exist and if you leave the new page with a back
    button, you’ll automatically navigate back to the old page. The new page gets
    *popped* from the so-called layer stack, and you’ll find your old page in the
    same state you left it in. This also includes the scroll position.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈导航器**：当在堆栈导航器中导航到新页面时，新页面会推送到旧页面上方。然而，旧页面并不会被卸载。它将继续存在，如果你通过返回按钮离开新页面，你将自动导航回旧页面。新页面将从所谓的层堆栈中弹出，你将发现你的旧页面处于你离开时的相同状态。这也包括滚动位置。'
- en: '**Tab navigator**: A very popular navigator is the tab navigator. This navigator
    provides up to five tabs that can be selected via a tab bar. This tab bar contains
    text and/or icons and can be on the top or at the bottom of the screen. Every
    tab has a layer stack. This means you can navigate every tab separately. The state
    of the tabs does not reset when you select another tab. In most cases, you simply
    have multiple stack navigators in your tab navigator.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签导航器**：一个非常受欢迎的导航器是标签导航器。这个导航器提供了最多五个可以通过标签栏选择的标签。这个标签栏包含文本和/或图标，可以位于屏幕顶部或底部。每个标签都有一个层堆栈。这意味着你可以单独导航每个标签。当你选择另一个标签时，标签的状态不会重置。在大多数情况下，你只是在你的标签导航器中有多重堆栈导航器。'
- en: '**Switch navigator**: This navigator provides the same behavior as web navigation.
    When using this navigator, you’ll replace an old page or layer stack with the
    new one. This means the old page or layer stack gets unmounted and removed from
    memory. If you navigate back, the old page or layer stack will have a complete
    clean restart, as if you haven’t been there before.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换导航器**：这个导航器提供了与网络导航相同的行为。当使用这个导航器时，你会用新页面或层堆栈替换旧的一个。这意味着旧页面或层堆栈会被卸载并从内存中移除。如果你返回导航，旧页面或层堆栈将有一个完整的干净重启，就像你之前从未去过那里一样。'
- en: Most apps combine these navigators to provide a great navigation experience
    to the user. Because this common navigation experience in mobile apps is so different
    from the web, you should always keep this in mind when planning a project for
    mobile and the web. You will learn more about this in [*Chapter 10*](B16694_10.xhtml#_idTextAnchor347),
    *Structuring Large-Scale, Multi-Platform Projects*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用都会结合这些导航器来为用户提供出色的导航体验。因为这种在移动应用中的常见导航体验与网络不同，所以在为移动和网页项目规划时，你应该始终牢记这一点。你将在[*第10章*](B16694_10.xhtml#_idTextAnchor347)
    *结构化大规模、多平台项目*中了解更多关于这一点。
- en: Even though multiple community projects provide great support for navigation
    in React Native apps, such as react-native-navigation (supported by Wix; more
    information can be found at [https://wix.github.io/react-native-navigation/docs/before-you-start/](https://wix.github.io/react-native-navigation/docs/before-you-start/))
    and react-router/native (more information can be found at [https://v5.reactrouter.com/native/guides/quick-start](https://v5.reactrouter.com/native/guides/quick-start)),
    we’ll focus on react-navigation in this section. It is by far the most commonly
    used, most actively maintained, and most advanced navigation solution for React
    Native.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多个社区项目为 React Native 应用中的导航提供了很好的支持，例如由 Wix 支持的 react-native-navigation（更多信息可以在[https://wix.github.io/react-native-navigation/docs/before-you-start/](https://wix.github.io/react-native-navigation/docs/before-you-start/)）和
    react-router/native（更多信息可以在[https://v5.reactrouter.com/native/guides/quick-start](https://v5.reactrouter.com/native/guides/quick-start)）中，但本节我们将重点关注
    react-navigation。它是迄今为止最常用的、最活跃维护的、最先进的 React Native 导航解决方案。
- en: Working with React Navigation
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 React 导航
- en: To understand how React Navigation works, it’s best to simply integrate it into
    our example project. We’ll do two things here. First, we’ll replace our global
    state navigation solution with a React Navigation Stack Navigator. Then, we’ll
    add a Tab Navigator to create a second tab, which we’ll use in the next chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 React 导航是如何工作的，最好的方法是将它简单地集成到我们的示例项目中。在这里，我们将做两件事。首先，我们将用 React 导航堆栈导航器替换我们的全局状态导航解决方案。然后，我们将添加一个标签导航器来创建第二个标签，我们将在下一章中使用它。
- en: But before you can begin using React Navigation, you must install it. This process
    is easy – you just have to install the package and the dependencies via npm. This
    can be done with the `npm install @react-navigation/native react-native-screens
    react-native-safe-area-context` command. Since `react-native-screens` and `react-native-safe-area-context`
    have a native part, you’ll have to install the iOS Podfiles with the `npx pod-install`
    command. After this, you’ll have to create fresh builds to be able to use React
    Navigation. This can be done for iOS with `npx react-native run-ios`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但在您开始使用 React Navigation 之前，您必须安装它。这个过程很简单——您只需通过 npm 安装包及其依赖项。这可以通过 `npm install
    @react-navigation/native react-native-screens react-native-safe-area-context`
    命令完成。由于 `react-native-screens` 和 `react-native-safe-area-context` 有原生部分，您将需要使用
    `npx pod-install` 命令安装 iOS Podfiles。之后，您将需要创建新的构建才能使用 React Navigation。对于 iOS，可以使用
    `npx react-native run-ios` 来完成。
- en: At the time of writing, some additional steps are necessary to get React Navigation
    to work on Android. Since this may change in the future, please have a look at
    the installation part of the official documentation at [https://reactnavigation.org/docs/getting-started/#installation](https://reactnavigation.org/docs/getting-started/#installation).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，为了在 Android 上使 React Navigation 工作正常，需要一些额外的步骤。由于这可能会在未来发生变化，请查看官方文档中的安装部分，网址为
    [https://reactnavigation.org/docs/getting-started/#installation](https://reactnavigation.org/docs/getting-started/#installation)。
- en: 'Now that have installed React Navigation, it’s time to use it in our example
    project. First, we’ll replace our global state-based navigation in `App.tsx` with
    a Stack Navigator. To use the Stack Navigator, we’ll have to install it using
    the `npm install @react-navigation/native-stack` command. Then, we can start using
    it in our app:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 React Navigation，是时候在我们的示例项目中使用它了。首先，我们将用 Stack Navigator 替换 `App.tsx`
    中的全局状态导航。要使用 Stack Navigator，我们需要使用 `npm install @react-navigation/native-stack`
    命令来安装它。然后，我们就可以在我们的应用中开始使用了：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, our `App.tsx` got a lot simpler. We can remove all the `useState`
    hooks and all the setter functions because React Navigation will handle all this.
    All we need to do is create a Stack Navigator with React Navigation’s `createNativeStackNavigator`
    command and then return our Layer Stack in our return statement. Please note `<NavigationContainer
    />`, which is wrapping the entire application. This is necessary to be able to
    manage the navigation state and should usually wrap the root component.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的 `App.tsx` 变得简单多了。我们可以移除所有的 `useState` 钩子和所有的设置函数，因为 React Navigation
    会处理所有这些。我们只需要创建一个 Stack Navigator，使用 React Navigation 的 `createNativeStackNavigator`
    命令，然后在返回语句中返回我们的 Layer Stack。请注意 `<NavigationContainer />`，它包裹着整个应用。这是管理导航状态所必需的，通常应该包裹根组件。
- en: Here, every screen has a name, a component, and some options. The name is also
    the key that the screen can be navigated to with. `component` is the component
    that should be mounted when the screen is navigated to. `options` allows us to
    configure things such as the header and the back button.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个屏幕都有一个名称、一个组件和一些选项。名称也是屏幕可以通过它导航到的键。`component` 是当屏幕被导航到时应挂载的组件。`options`
    允许我们配置诸如标题和返回按钮等事项。
- en: 'Now that we have defined the Layer Stack, it’s time to look at the views and
    see what has changed there. Let’s look at `<GenreView />`. This is where we can
    see all the changes best:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了 Layer Stack，是时候查看视图并看看那里有什么变化了。让我们看看 `<GenreView />`。这是我们可以看到所有变化最好的地方：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first thing you can see is that there is another way to access the properties
    that are passed via React Navigation. Every component, which is a React Navigation
    screen, is passed two additional properties – `navigation` and `route`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先可以看到，有另一种方式可以访问通过 React Navigation 传递的属性。每个作为 React Navigation 屏幕的组件都会传递两个额外的属性——`navigation`
    和 `route`。
- en: '`route` contains information about the current route. The most important property
    of `route` is `params`. When navigating to a screen, we can pass `params`, which
    can then be retrieved through `route.params`. In this example, this is how we
    pass the genre to the view (`props.route.params.genre`), which we then use to
    fetch the movie list.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`route` 包含关于当前路由的信息。`route` 中最重要的属性是 `params`。当我们导航到一个屏幕时，我们可以传递 `params`，然后可以通过
    `route.params` 来检索它们。在这个例子中，这就是我们将类型传递给视图（`props.route.params.genre`）的方式，然后我们使用它来获取电影列表。'
- en: When you have a look at the `onPress` function of the `<Pressable />` component
    in the return statement, you can see how to navigate to another page in React
    Navigation. The `navigation` property provides different functions to navigate
    between screens. In our case, we use the `navigate` function with the `Movie`
    key to navigate to the `<Movie />` view. We also pass the current movie as a parameter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看返回语句中`<Pressable />`组件的`onPress`函数时，你可以看到如何在React Navigation中导航到另一个页面。`navigation`属性提供了在不同屏幕之间导航的不同函数。在我们的例子中，我们使用带有`Movie`键的`navigate`函数来导航到`<Movie
    />`视图。我们还传递了当前电影作为参数。
- en: When you compare the code to the example from the previous section, you’ll realize
    that the `<Header />` and `<BackButton />` components are missing. This is because
    React Navigation comes with built-in header and back button support. While you
    can disable this, its default behavior is for every screen to have a header, including
    a back button to the previous screen.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将代码与上一节中的示例进行比较时，你会意识到`<Header />`和`<BackButton />`组件缺失。这是因为React Navigation自带内置的头部和后退按钮支持。虽然你可以禁用它，但它的默认行为是每个屏幕都有一个头部，包括返回到上一个屏幕的后退按钮。
- en: If you want to see all these changes, please have a look at the repository for
    this example project and choose the `chapter-4-navigation` tag.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看所有这些更改，请查看此示例项目的仓库，并选择`chapter-4-navigation`标签。
- en: 'If you run the example project on that tag, you’ll also see that React Native
    added animations to the navigation actions. These animations can be customized
    in any way possible. There is even a community library to support shared animated
    elements between the different pages. You can have a look at it here: [https://github.com/IjzerenHein/react-navigation-shared-element](https://github.com/IjzerenHein/react-navigation-shared-element).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个标签上运行示例项目，你还会看到React Native为导航操作添加了动画。这些动画可以以任何可能的方式自定义。甚至有一个社区库来支持不同页面之间的共享动画元素。你可以在这里查看：[https://github.com/IjzerenHein/react-navigation-shared-element](https://github.com/IjzerenHein/react-navigation-shared-element)。
- en: Now that you’ve learned how to use the Stack Navigator, we’ll add another navigator.
    We want to create a second tab because we want to create an area where the user
    can save his favorite movies. This will be done with a Tab Navigator.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用Stack Navigator，我们将添加另一个导航器。我们想要创建一个第二个标签，因为我们想要创建一个用户可以保存他喜欢的电影的地方。这将通过Tab
    Navigator来完成。
- en: 'As with the Stack Navigator, we have to install the Tab Navigator before using
    it. This can be done with `npm install @react-navigation/bottom-tabs`. After we
    have installed the Tab Navigator, we can add it to our `App.tsx`. Please have
    a look at the following code snippet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与Stack Navigator一样，在使用之前我们必须安装Tab Navigator。这可以通过`npm install @react-navigation/bottom-tabs`来完成。在我们安装了Tab
    Navigator之后，我们可以将其添加到我们的`App.tsx`中。请查看以下代码片段：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a very limited example. To see the working code, please have a look
    at the example repository and choose the `chapter-4-navigation-tabs` tag. As you
    can see, we move the Main Stack to its own function component. Our `App` component
    now contains `<TabNavigator />` with two screens.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有限的示例。要查看工作代码，请查看示例仓库并选择`chapter-4-navigation-tabs`标签。正如你所看到的，我们将主Stack移动到其自己的函数组件中。我们的`App`组件现在包含`<TabNavigator
    />`和两个屏幕。
- en: The first screen gets `<MainStackScreen />` as its component. This means that
    we use our Stack Navigator when we are on the first tab. The second screen gets
    a newly created `<User />` component. You can switch between these tabs with the
    tab bar, which is created automatically by React Navigation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个屏幕使用`<MainStackScreen />`作为其组件。这意味着当我们处于第一个标签时，我们使用我们的Stack Navigator。第二个屏幕使用一个新创建的`<User
    />`组件。你可以通过标签栏在这些标签之间切换，标签栏是由React Navigation自动创建的。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should always install an icon library such as `react-native-vector-icons`
    ([https://github.com/oblador/react-native-vector-icons](https://github.com/oblador/react-native-vector-icons))
    when working with tabs. Such libraries make it easy to find and use expressive
    icons for your tab bar.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与标签一起工作时，你应该始终安装一个图标库，例如`react-native-vector-icons`([https://github.com/oblador/react-native-vector-icons](https://github.com/oblador/react-native-vector-icons))。这样的库使得在标签栏中找到和使用表达性图标变得容易。
- en: 'This example, which contains two different navigators, shows the flexibility
    of React Navigation. We can either use our views in our `<Navigator.Screen />`
    components or use other navigators. This navigator nesting gives us nearly endless
    possibilities. Please note that in this case, we must hide the header for the
    first tab because it has already been created by our Stack Navigator. We can do
    this with the `headerShown: false` option.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '这个例子包含两个不同的导航器，展示了 React Navigation 的灵活性。我们可以在 `<Navigator.Screen />` 组件中使用我们的视图，或者使用其他导航器。这种导航嵌套给我们带来了几乎无限的可能性。请注意，在这种情况下，我们必须隐藏第一个标签页的标题，因为它已经被我们的
    Stack Navigator 创建了。我们可以通过 `headerShown: false` 选项来实现这一点。'
- en: 'As you can see, navigating with React Navigation is easy and powerful. It also
    has excellent TypeScript support, as you can see in the repository. You can create
    types for every layer stack and define exactly what can be passed to the different
    screens. This includes not only type checking, but also autocomplete functionality
    in most modern IDEs. You can read more about TypeScript support for React Navigation
    here: [https://reactnavigation.org/docs/typescript/](https://reactnavigation.org/docs/typescript/).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用 React Navigation 进行导航既简单又强大。它还提供了出色的 TypeScript 支持，正如您在仓库中可以看到的那样。您可以为每一层栈创建类型，并精确地定义可以传递给不同屏幕的内容。这包括不仅限于类型检查，还包括在大多数现代
    IDE 中的自动完成功能。您可以在[https://reactnavigation.org/docs/typescript/](https://reactnavigation.org/docs/typescript/)了解更多关于
    React Navigation 对 TypeScript 的支持。
- en: 'React Navigation supports a lot more features, including deeplinking, testing,
    persisting the navigation state, and integrating different state management solutions.
    If you want to learn more, please visit the official documentation: [https://reactnavigation.org/docs/getting-started/](https://reactnavigation.org/docs/getting-started/).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: React Navigation 支持许多其他功能，包括深度链接、测试、持久化导航状态以及集成不同的状态管理解决方案。如果您想了解更多信息，请访问官方文档：[https://reactnavigation.org/docs/getting-started/](https://reactnavigation.org/docs/getting-started/)。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now that we’ve added a modern navigation library to our example project, it’s
    time to wrap up this chapter. First, you learned what you have to consider when
    you wish to style your application. You also learned about the most common solutions
    for styling React Native applications and learned which of them are suitable for
    sharing code with web projects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将一个现代导航库添加到我们的示例项目中，是时候总结本章内容了。首先，您学习了在您希望美化应用程序时需要考虑的因素。您还了解了美化 React
    Native 应用程序最常见的方法，并学习了哪些方法适合与网络项目共享代码。
- en: Then, you learned how to store data locally in a React Native app. Finally,
    you learned how navigation is different between the web and mobile and how to
    use a modern navigation library to implement state-of-the-art navigation solutions
    in React Native apps.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您学习了如何在 React Native 应用程序中本地存储数据。最后，您学习了在网页和移动端之间导航的不同之处，以及如何使用现代导航库在 React
    Native 应用程序中实现最先进的导航解决方案。
- en: In the next chapter, we’ll look at solutions for creating and maintaining a
    global app state and how to fetch data from external resources. While learning
    about this, we’ll fill the placeholder screen we created in this chapter with
    some cool functionality.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨创建和维护全局应用状态的方法，以及如何从外部资源获取数据。在学习这些内容的同时，我们将用一些酷炫的功能填充本章中创建的占位符屏幕。
