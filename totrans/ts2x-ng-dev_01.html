<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">From Loose Types to Strict Types</h1>
                </header>
            
            <article>
                
<p><em>JavaScript is loosely typed.</em> It's worth repeating, <em>JavaScript is loosely typed</em>. Notice how the sentence is passive--we cannot categorically hold someone responsible for the loose-type nature of JavaScript just as we can't do so for other <span>famous</span> glitches of <span>JavaScript</span>.</p>
<p>A detailed discussion on what loose-types and loosely typed languages are will help aid your understanding of the problem that we plan to solve with this book.</p>
<p>When a programming language is loosely typed, it means that the data passed around using variables, functions, or whatever member applicable to the language does <em>not</em> have a defined type. A variable <em>x</em> could be declared, but the kind of data it holds is never certain. Loosely typed languages are contrary to strongly typed languages, which enforce that every declared member must strictly define what sort of data it can hold.</p>
<p>These types are categorized into:</p>
<ul>
<li>Strings</li>
<li>Numbers (int, float, and so on.)</li>
<li>Data structures (arrays, lists, objects, maps, and so on.)</li>
<li>Boolean (true and false)</li>
</ul>
<p>JavaScript, PHP, Perl, Ruby, and so on, are all examples of loosely typed languages. Java, C, C#, are examples of strongly typed languages.</p>
<p>In loosely typed languages, a member may be initially defined as a string. Down the line, this member could end up storing a number, a boolean, or even a data structure. This instability leads us to the implications of loosely typed languages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Term definitions</h1>
                </header>
            
            <article>
                
<p>Before we keep moving, it would be nice to define the common jargon you may have met or will meet with in the course of understanding loose and strict types:</p>
<ul>
<li><strong>Members</strong>: These are the features of a language that describe how the data is stored and manipulated. Variables, functions, properties, classes, interfaces, and so on, are all examples of the possible members a language can have.</li>
<li><strong>Declared versus defined versus assigned</strong>: When a variable is initialized with no value, it is said to be <em>declared</em>. When it is declared and has a type, it is said to be <em>defined</em>. When the variable has a value, whether typed or not, it is <em>assigned</em>.</li>
<li><strong>Types</strong>: These are used to categorize the data based on how they are parsed and manipulated. For example, numbers, strings, booleans, arrays, and so on.</li>
<li><strong>Values</strong>: The data assigned to a given member is known as the member's value.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implications of loose types</h1>
                </header>
            
            <article>
                
<p>Let's start out with an example to show how loosely typed languages behave:</p>
<pre>// Code 1.1<br/><br/>// Declare a variable and assign a value<br/>var x = "Hello";<br/><br/>// Down the line<br/>// you might have forgotten <br/>// about the original value of x<br/>//<br/>//<br/>// Re-assign the value<br/>x = 1;<br/><br/>// Log value<br/>console.log(x); // 1</pre>
<p>The variable <kbd>x</kbd><em> </em>was initially declared and assigned a string value, <kbd>Hello</kbd>. The same <kbd>x</kbd><em> </em> got re-assigned to a numeric value, <kbd>1</kbd>. Nothing went wrong; the code was interpreted and when we logged the value to the console, it logged the latest value of <kbd>x</kbd>, which is <kbd>1</kbd>.</p>
<p>This is not just a string-number thing; the same thing applies to every other type, including complex data structures:</p>
<pre>// Code 1.2<br/><br/>var isCompleted;<br/><br/>// Assign null<br/>isCompleted = null;<br/>console.log('When null:', isCompleted);<br/><br/>// Re-assign a boolean<br/>isCompleted = false;<br/>console.log('When boolean:', isCompleted);<br/><br/>// Re-assign a string<br/>isCompleted = 'Not Yet!';<br/>console.log('When string:', isCompleted);<br/><br/>// Re-assign a number<br/>isCompleted = 0;<br/>console.log('When number:', isCompleted);<br/><br/>// Re-assign an array<br/>isCompleted = [false, true, 0];<br/>console.log('When array:', isCompleted);<br/><br/>// Re-assign an object<br/>isCompleted = {status: true, done: "no"};<br/>console.log('When object:', isCompleted);<br/><br/>/**<br/>* CONSOLE:<br/>*<br/>* When null: null<br/>* When boolean: false<br/>* When string: Not Yet!<br/>* When number: 0<br/>* When array: [ false, true, 0 ]<br/>* When object: { status: true, done: 'no' }<br/>*/</pre>
<p>The important thing to note here is not that the <em>values</em> are changing. Rather, it's the fact that both values and <em>types</em> are changing. The change in the type does not affect the execution. Everything works fine, and we have our expected result in the console.</p>
<p>The function parameters and return types are not left out either. You can have a function signature that accepts a string parameter, but JavaScript will keep silent when you, or any other developer, pass in a number while calling the function:</p>
<pre>function greetUser( username ) {<br/> return `Hi, ${username}`<br/>}<br/><br/>console.log('Greet a user string: ', greetUser('Codebeast'))<br/>console.log('Greet a boolean: ', greetUser(true))<br/>console.log('Greet a number: ', greetUser(1))<br/><br/>/**<br/> * CONSOLE:<br/> *<br/> * Greet a user string: Hi, Codebeast<br/> * Greet a boolean: Hi, true<br/> * Greet a number: Hi, 1<br/> */</pre>
<p>If you're coming from a strong-type background and have no previous experience with loosely typed languages, the preceding example must feel weird. This is because in strongly typed languages, it's hard to change the type of the particular member (variables, functions, and so on).</p>
<p>So, what is the implication to take note of? The obvious implication is that the members that are loosely typed are inconsistent. Therefore, their value types can change, and this is something that you, the developer, will need to watch out for. There are challenges in doing so; let's talk about them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The problem</h1>
                </header>
            
            <article>
                
<p>Loose types are tricky. At first glance, they appear to be all nice and flexible to work with--flexibility, as in giving you the freedom to change types anytime and anywhere, without the interpreter screaming errors like other strongly typed languages do. Just like any other form of freedom, this one also comes with a price.</p>
<p>The major problem is inconsistency. It is very easy to forget the original type for a member. This could lead you to handling, say, a string as if it were still a string when its value is now Boolean. Let's see an example:</p>
<pre>function greetUser( username ) {<br/> // Reverse the username<br/> var reversed = username.split('').reverse().join('');<br/> return `Hi, ${reversed}`<br/>}<br/><br/>console.log('Greet a correct user: ', greetUser('Codebeast'))<br/><br/><br/> * CONSOLE:<br/> *<br/> * Greet a correct user: Hi, tsaebedoC<br/> */</pre>
<p>In the preceding example, we have a function that greets the users based on their usernames. Before it does the greeting, it first reverses the username. We can call the function by passing in a username string.</p>
<p>What happens when we pass in a Boolean or some other type that does not have a <kbd>split</kbd> method? Let's check it out:</p>
<pre>// Code 1.4<br/><br/>function greetUser( username ) {<br/> var reversed = username.split('').reverse().join('');<br/> return `Hi, ${reversed}`<br/>}<br/><br/>console.log('Greet a correct user: ', greetUser('Codebeast'))<br/><br/>// Pass in a value that doesn't support<br/>// the split method<br/>console.log('Greet a boolean: ',greetUser(true))<br/><br/><br/> * CONSOLE:<br/> *<br/> * Greet a correct user: Hi, tsaebedoC<br/> * /$Path/Examples/chapter1/1.4.js:2<br/> * var reversed = username.split('').reverse().join('');<br/>                          ^<br/> * TypeError: username.split is not a function<br/> */</pre>
<p>The first log output, which prints the greeting with a string, comes out fine. But the second attempt fails because we passed in a Boolean. In as much as <em>everything</em> in JavaScript is an object, a Boolean does not have a <kbd>split</kbd> method. The image ahead shows a clear output of the preceding example:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-280 image-border" height="413" src="assets/a942f086-3e4c-43e5-abca-0f09ed2fec74.jpg" width="557"/></div>
<p>Yes, you might be thinking that you're the author of this code; why would you pass in a Boolean when you designed the function to receive a string? Remember that a majority of the code that we write in our lifetime is not maintained by us, but by our colleagues.</p>
<p>When another developer picks up <kbd>greetUser</kbd> and decides to use the function as an API without digging the code's source or documentation, there is a high possibility that he/she won't pass in the right value type. This is because <em>he/</em><em>she is blind</em>. Nothing tells him/her what is right and what is not. Even the name of the function is not obvious enough to make her pass in a string.</p>
<p>JavaScript evolved. This evolution was not just experienced internally but was also seen in its vast community. The community came up with best practices on tackling the challenges of the loose-type nature of JavaScript.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mitigating loose-type problems</h1>
                </header>
            
            <article>
                
<p>JavaScript does not have any native obvious solution to the problems that loose types bring to the table. Rather, we can use all forms of manual checks using JavaScript's conditions to see whether the value in question is still of the intended type.</p>
<p>We are going to have a look at some examples where manual checks are applied in order to retain the integrity of the value types.</p>
<p>The popular saying that <em>Everything is an Object</em> in JavaScript is not entirely true (<a href="https://blog.simpleblend.net/is-everything-in-javascript-an-object/">https://blog.simpleblend.net/is-everything-in-javascript-an-object/</a>). There are <em>Objects</em> and there are <em>Primitives</em>. Strings, numbers, Boolean, null, undefined, are primitives but are handled as objects only during computation. That's why you can call something like <kbd>.trim()</kbd> on a string. Objects, arrays, dates, and regular expressions are valid objects. It's mind-troubling to say that an object is an object, but that is JavaScript for you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The typeof operator</h1>
                </header>
            
            <article>
                
<p class="p1">The <kbd>typeof</kbd> operator is used to check the type of a given operand. You can use the operator to control the harm of loose types. Let's see some examples:</p>
<pre class="p1">// Code 1.5<br/>function greetUser( username ) {<br/> if(typeof username !== 'string') {<br/>   throw new Error('Invalid type passed');<br/> };<br/> var reversed = username.split('').reverse().join('');<br/> return `Hi, ${reversed}`<br/>}<br/><br/>console.log('Greet a correct user: ', greetUser('Codebeast'))<br/>console.log('Greet a boolean: ',greetUser(true))</pre>
<p class="p1">Rather than waiting for the system to tell us that we're wrong when an invalid type is passed in, we catch the error as early as possible and throw a custom and more friendly error, as shown in the following screenshot:</p>
<div class="p1 CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-281 image-border" height="402" src="assets/2486fb07-13a0-43b5-acdc-5f21028a041b.jpg" width="544"/></div>
<p class="p1">The <kbd>typeof</kbd> operator returns a string, which represents the value's type. The <kbd>typeof</kbd> operator is not entirely perfect and should only be used when you are sure about how it works. See the following issue:</p>
<pre class="p1">function greetUser( user ) {<br/> if ( typeof user !== 'object' ) {<br/>   throw new Error('Type is not an object');<br/> }<br/> return `Hi, ${user.name}`;<br/>}<br/><br/>console.log('Greet a correct user: ', greetUser( {name: 'Codebeast', age: 24 } ))<br/>// Greet a correct user: Hi, Codebeast<br/><br/>console.log('Greet a boolean: ', greetUser( [1, 2, 3] ))<br/>// Greet a boolean: Hi, undefined</pre>
<p class="p1">You may have expected an error to be thrown when the function was called with an array for the second time. Instead, the program got past the check and executed <kbd>user.name</kbd> before realizing that it is undefined. Why did it get past this check? Remember that an array is an object. Therefore, we need something more specific to catch the check. Date and regex could have passed the check as well, even though that may not have been the intent.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The toString method</h1>
                </header>
            
            <article>
                
<p class="p1">The <kbd>toString</kbd> method is prototypically inherited by all the objects and wrapped objects (primitives). When you call this method on them, it returns a string token of the type. See the following examples:</p>
<pre class="p1"><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">([]);</span><span> </span><span class="c1">// [object Array]</span><span> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">({});</span><span> </span><span class="c1">// [object Object]</span><span> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="s1">''</span><span class="p">);</span><span> </span><span class="c1">// [object String]</span><span> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">new</span><span> </span><span class="nb">Date</span><span class="p">());</span><span> </span><span class="c1">// [object Date]<br/>// etc</span></pre>
<p class="p1">Now you can use this to check the types, as shown by Todd Motto (<a href="https://toddmotto.com/understanding-javascript-types-and-reliable-type-checking/#true-object-types">https://toddmotto.com/understanding-javascript-types-and-reliable-type-checking/#true-object-types</a>):</p>
<pre class="p1">var getType = function (elem) {<br/> return Object.prototype.toString.call(elem).slice(8, -1);<br/>};<br/>var isObject = function (elem) {<br/> return getType(elem) === 'Object';<br/>};<br/><br/>// You can use the function<br/>// to check types<br/>if (isObject(person)) {<br/> person.getName();<br/>}</pre>
<p class="p1">What the preceding example does is check the part of the string returned by the <kbd>toString</kbd> method to determine its type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Final Note</h1>
                </header>
            
            <article>
                
<p class="p1">The examples we saw previously are just an overkill for a simple type check. If JavaScript had strict type features, we wouldn't have gone through this stress. In fact, this chapter would never have existed.</p>
<p class="p1">Imagine that JavaScript could do this:</p>
<pre class="p1">function greet( username: string ) {<br/> return `Hi, ${username}`;<br/>}</pre>
<p class="p1">We wouldn't have gone through all that type checking hell because the compiler (as well as the editors) would have thrown errors when it encountered type inconsistency.</p>
<p class="p1">This is where TypeScript comes in. Luckily, with TypeScript, we can write code that looks like the preceding one, and we can have it transpiled to JavaScript.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1">Throughout this book, we will be talking about TypeScript for building not just JavaScript apps but also Angular apps. Angular is a JavaScript framework; therefore, it will be characterized with the discussed limitations unless mitigated with TypeScript.</p>
<p class="p1">Now that you know the problem at hand, buckle up while we dig Angular with the possible solutions that TypeScript provides.</p>
<p>So far, so good! We have been able to discuss the following concerns to help us move forward:</p>
<ul>
<li>Understanding loose types</li>
<li>Differences between loose types and strict types</li>
<li>Challenges of loosely typed programming languages, including JavaScript</li>
<li>Mitigating the effects of loose types</li>
</ul>


            </article>

            
        </section>
    </body></html>