<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Animation"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Animation</h1></div></div></div><p>In the previous chapter, we took a look at react-router and performed routing at different levels. We also looked at nested routing, passing around parameters, and how react-router maintains history when performing the routing tasks. We learned about passing around context and using context to render React components. We explored data models and mixed and matched them with other frameworks to use as data models in React-like Backbone, and were introduced to Flux.</p><p>In this chapter, we are going to explore a fun React add-on, Animation. We will start off by continuing with our Cat Pinterest application and enhancing it to support starring and sharing the data to update the views. We will then explore adding handlers for animation. We will see how components get wrapped for animation and how React adds the handlers for different events. We will also explore different events and how we can easily enhance our application in order to create stunning effects.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Making changes to the data flow and passing data from react-router links</li><li class="listitem" style="list-style-type: disc">Animation in React</li><li class="listitem" style="list-style-type: disc">CSS transitions</li><li class="listitem" style="list-style-type: disc">Transition groups</li><li class="listitem" style="list-style-type: disc">Transition handlers</li><li class="listitem" style="list-style-type: disc">Animating our dynamic component</li></ul></div><p>At the end of chapter, we will be able to start animating our React components for different actions such as adding new content, changing data and position, and so on. We will also be able to add handlers for different types of events and explore different animation options out there, other than core animation add-on.</p><div class="section" title="Fun stuff at Adequate LLC!"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec75"/>Fun stuff at Adequate LLC!</h1></div></div></div><p>"Hi Shawn <a id="id261" class="indexterm"/>and Mike!" Carla joined Mike and Shawn in their conversation.</p><p>The day before, Carla had asked them to build a Pinterest-style application for cats for one of their clients.</p><p>"How are things going today?" she enquired.</p><p>"All good, Carla. Shawn, do you want to show Carla what we built yesterday?"</p><p>"Sure."</p><div class="mediaobject"><img src="graphics/4730_10_01.jpg" alt="Fun stuff at Adequate LLC!"/></div><p>"That looks nice! Are we adding button for faving/starring of cats next?"</p><p>"Yes, we were just getting ready for that."</p><p>"Cool. The client called yesterday. What they want along with displaying the cats is to show a stream of cats being updated on the screen. This is going to happen when someone faves a cat so that we show it to other users."</p><p>"Got it. We will start working on it and simulate addition of cats to appear on the screen to start with."</p><p>"Awesome, I <a id="id262" class="indexterm"/>will leave you both to it."</p></div></div>
<div class="section" title="Model updates"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec76"/>Model updates</h1></div></div></div><p>"So Shawn, instead of using the Backbone collection in an isolated fashion, let's move it to a class to manage <a id="id263" class="indexterm"/>adding of new cats randomly and provide it with some other utilities, as follows:"</p><div class="informalexample"><pre class="programlisting">const PictureModel = Backbone.Model.extend({
  defaults: {
    src: 'http://lorempixel.com/601/600/cats/',
    name: 'Pusheen',
    details: 'Pusheen is a Cat',
    faved: false
  }
});</pre></div><p>"Our <code class="literal">PictureModel</code> stays the same. We are adding a new <code class="literal">faved</code> attribute here to maintain state about whether the cat was faved by the user or not.</p><p>"We will call this new class of ours <code class="literal">CatGenerator</code>, which will provide the component that we use to display the cats, with the data to display, fetch, and add new cats."</p><p>"Got it. Want me to give it a try?"</p><p>"Sure."</p><div class="informalexample"><pre class="programlisting">import Backbone from 'backbone';
import Faker from 'faker';
import _ from 'underscore';
…

class CatGenerator {
  constructor() {
    this.Cats = new Backbone.Collection;
    [600, 601, 602, 603, 604, 605].map( (height)=&gt;{
      this.createCat(height, 600);
    })
  }

  createCat(height = _.random(600, 650), width = 600) {
    console.log('Adding new cat');
    this.Cats.add(new PictureModel({
      src: `http://lorempixel.com/${height}/${width}/cats/`,
      name: Faker.Name.findName(),
      details: Faker.Lorem.paragraph()
    }));
  }
}</pre></div><p>"Nice Shawn."</p><p>"Thanks. I moved <code class="literal">createCat</code> as a method of its own so that we can add cats to the collection on the fly. I am just adding a random one right now, taking a random height of 600-650 and a random width to create a new <code class="literal">PictureModel</code> instance."</p><p>"Also, to start with, I am creating <code class="literal">cats</code> collection as an attribute on the class. Next, I have added six cats to begin with."</p><p>"Cool. We are now <a id="id264" class="indexterm"/>going to start changing its use in our Components."</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Remember that we are going to update the components when new data comes in. Easy way to do this is to start storing the <code class="literal">CatGenerator</code> as a state object on the <code class="literal">Home</code> component.</p></div></div><p>"Let's start defining and changing our <code class="literal">Home</code> component, as follows:"</p><div class="informalexample"><pre class="programlisting">class Home extends React.Component {
  constructor() {
    super();
    this.timer = null;
    this.state = {catGenerator: new CatGenerator()};
  }

  componentDidMount() {
    this.timer = setInterval(::this.generateCats, 1000);
  }

  generateCats() {
    let catGenerator = this.state.catGenerator;
    catGenerator.createCat();
    clearInterval(this.timer);
    this.timer = setInterval(::this.generateCats, catGenerator.randRange());

    this.setState({catGenerator: catGenerator});
  }
…</pre></div><p>"So, what we are doing here is creating a timer to track time intervals. We are going to use a random time interval to simulate the addition of a new stream of cats here."</p><p>"Got it," followed up Shawn.</p><p>"To do this, I have added the <code class="literal">generateCats()</code> method. In our <code class="literal">componentDidMount</code>, we are adding and setting the timer to call this method after the first creation."</p><p>"In the method itself, I have added clearing of the old interval and we are calling the <code class="literal">catGenerator.createCat()</code> method to actually create the cat from our <code class="literal">CatGenerator</code> class."</p><p>"We are then resetting the timer and setting a new one, based on a random time interval. I added the <code class="literal">catGenerator.randRange()</code> method to generate the random time interval. Here's how it looks <a id="id265" class="indexterm"/>in the <code class="literal">CatGenerator</code> class:"</p><div class="informalexample"><pre class="programlisting">randRange() {
    return _.random(5000, 10000);
  }</pre></div><p>"Got it. This should be creating a new stream of cats in the range of 5-10 seconds."</p><p>"Next, let's take a look at how our render method looks. I am going to add a star next to the cats."</p><div class="informalexample"><pre class="programlisting">render() {
    let Cats = this.state.catGenerator.Cats;

    return (
        &lt;div&gt;
          &lt;div&gt;

              {Cats.map(cat =&gt; (
                  &lt;div key={cat.cid} style={{float: 'left'}}&gt;
                    &lt;Link to={`/pictures/${cat.cid}`}
                          state={{ modal: true, returnTo: this.props.location.pathname, cat: cat }}&gt;
                      &lt;img style={{ margin: 10 }} src={cat.get('src')} height="100"/&gt;
                    &lt;/Link&gt;
                    &lt;span key={`${cat.cid}`} className="fa fa-star"&gt;&lt;/span&gt;
                  &lt;/div&gt;
              ))}

          &lt;/div&gt;
        &lt;/div&gt;
    )
  }</pre></div><p>"There are two changes that I am doing here. First of all, I added the star, which is unfaved by default."</p><div class="informalexample"><pre class="programlisting">                    &lt;span key={`${cat.cid}`} className="fa fa-star"&gt;&lt;/span&gt;</pre></div><p>"Secondly, I started passing the cat object on the modal link's state."</p><div class="informalexample"><pre class="programlisting">                    &lt;Link to={`/pictures/${cat.cid}`}
                          state={{ modal: true, 
                                       returnTo: this.props.location.pathname,  
                                       cat: cat }}&gt;</pre></div><p>"In our <code class="literal">PictureModel</code> box, we previously had the access to the global collection of cats. From now on, that won't be the case and we would need the cat object to be passed to the <code class="literal">Picture</code> component."</p><p>"That's neat, we are able to pass the objects too, to the component from a router <code class="literal">&lt;Link/&gt;</code> object."</p><p>"Yup, let's go ahead and <a id="id266" class="indexterm"/>change the picture component in order for it to work properly with this new change in passing the data. Our <code class="literal">Modal</code> stays the same:"</p><div class="informalexample"><pre class="programlisting">const Modal = React.createClass({
  styles: {
…   
  },

  render() {
     return (
      &lt;div style={this.styles}&gt;
        &lt;p&gt;&lt;Link to={this.props.returnTo}&gt;Back&lt;/Link&gt;&lt;/p&gt;
        {this.props.children}
      &lt;/div&gt;
    )
  }
})
…
export {Modal as default}</pre></div><p>"The <code class="literal">Picture</code> component now starts using the cat object."</p><div class="informalexample"><pre class="programlisting">import React from 'react'
import { PictureModel } from './models';

const Picture = React.createClass({
  render() {
    let { location } = this.props;
    let cat = location.state.cat;
    console.log(this.props);
    return (
        &lt;div&gt;
          &lt;div style={{ float: 'left', width: '40%' }}&gt;
            &lt;img src={cat.get('src')} style={{ height: '80%' }}/&gt;
          &lt;/div&gt;
          &lt;div style={{ float: 'left', width: '60%' }}&gt;
            &lt;h3&gt;Name: {cat.get('name')}.&lt;/h3&gt;
            &lt;p&gt;Details: {cat.get('details')} &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
    )
  }
});

export {Picture as default}</pre></div><p>"As you can see, the cat object is received on the <code class="literal">location.state</code> object from props."</p><p>"I have extended the picture to display more details about the cat, such as the name and so on, instead of showing it on a separate page. Previously, it looked pretty blank."</p><p>"Cool, let's take a look at <a id="id267" class="indexterm"/>how it looks, shall we?"</p><div class="mediaobject"><img src="graphics/4730_10_02.jpg" alt="Model updates"/></div><p>"Nice, the stars look good. We will need to check the styles that I added for this soon."</p><p>"The modal seems to be looking good as well, and look at all these cats being generated as a stream!"</p><p>"Nice!" Mike and Shawn rejoiced.</p><div class="mediaobject"><img src="graphics/4730_10_03.jpg" alt="Model updates"/></div></div>
<div class="section" title="Animate"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec77"/>Animate</h1></div></div></div><p>"React allows us <a id="id268" class="indexterm"/>to animate objects easily with its react-addons-css-transition-group add-on."</p><p>"This gives us a handle to the <code class="literal">ReactCSSTransitionGroup</code> object, which is what we will be using to animate changes in data, such as addition of cats, faving/unfaving, and so on."</p><p>"Let's start by animating the addition of new cats to the stream, shall we?"</p><div class="informalexample"><pre class="programlisting">render() {
    let Cats = this.state.catGenerator.Cats;

    return (
        &lt;div&gt;
          &lt;div&gt;
            &lt;ReactCSSTransitionGroup transitionName="cats" 
                                     transitionEnterTimeout={500} 
                                     transitionLeaveTimeout={300}
                                     transitionAppear={true} 
                                     transitionAppearTimeout={500}&gt;
              {Cats.map(cat =&gt; (
                  &lt;div key={cat.cid} style={{float: 'left'}}&gt;
                    &lt;Link to={`/pictures/${cat.cid}`}
                          state={{ modal: true, returnTo: this.props.location.pathname, cat: cat }}&gt;
                      &lt;img style={{ margin: 10 }} src={cat.get('src')} height="100"/&gt;
                    &lt;/Link&gt;
                    &lt;span key={`${cat.cid}`} className="fa fa-star"&gt;&lt;/span&gt;
                  &lt;/div&gt;
              ))}

&lt;/ReactCSSTransitionGroup&gt;
          &lt;/div&gt;
        &lt;/div&gt;
    )
  }</pre></div><p>"Here, I changed our <a id="id269" class="indexterm"/>render method and simply wrapped the display of the collection of cats in a <code class="literal">ReactCSSTransitionGroup</code> element, like so."</p><div class="informalexample"><pre class="programlisting">            &lt;ReactCSSTransitionGroup transitionName="cats" 
                                     transitionEnterTimeout={500}
                                     transitionLeaveTimeout={300}
                                     transitionAppear={true} 
                                     transitionAppearTimeout={500}&gt;</pre></div><p>"Let's go through them one by one in the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">transitionName</code>: This property is used to define the class name prefix used for the CSS classes applied for different events, such as element enter, leave, and so on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">transitionEnterTimeout</code>: This is the timeout for an element to be displayed freshly after rendering.</li><li class="listitem" style="list-style-type: disc"><code class="literal">transitionLeaveTimeout</code>: This is similar to <code class="literal">transitionEnterTimeout</code>, but it is used when the element is removed from the page.</li><li class="listitem" style="list-style-type: disc"><code class="literal">transitionAppear</code>: Sometimes, we want to animate the addition of the collection of elements, in our case cats, when they are first rendered. We can do this by setting this property to true.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Note that the elements, which are added after the first elements are displayed, are applied the <code class="literal">transitionEnter</code> property.</p></div></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">transitionAppearTimeout</code>: This is similar to the other timeout values, but for <code class="literal">transitionAppear</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">transitionEnter</code>: This is, by default, set to <code class="literal">true</code>. It can be set to <code class="literal">false</code> if we don't want to animate the element-enter transition.</li><li class="listitem" style="list-style-type: disc"><code class="literal">transitionLeave</code>: This is, by default, set to <code class="literal">true</code>. It can be set to <code class="literal">false</code> if we don't want to animate the element-leave transition animation.</li></ul></div><p>"Now, based on the transition and transition name, classes are applied to the elements within the <code class="literal">&lt;ReactCSSTransitionGroup/&gt;</code> component. For example, for enter transition, and our <code class="literal">cats</code> prefix, <code class="literal">cats-enter</code> would be applied to the elements."</p><p>"In the next cycle, <code class="literal">cats-enter-active</code> will be applied to the final class that the element should be in."</p><p>"Got it."</p><p>"Let's check all the <a id="id270" class="indexterm"/>different transitions that we can define based on this."</p><div class="informalexample"><pre class="programlisting">.cats-enter {
    opacity: 0.01;
}

.cats-enter.cats-enter-active {
    opacity: 1;
    transition: opacity 1500ms ease-in;
}
.cats-leave {
    opacity: 1;
}

.cats-leave.cats-leave-active {
    opacity: 0.01;
    transition: opacity 300ms ease-in;
}

.cats-appear {
    opacity: 0.01;
}

.cats-appear.cats-appear-active {
    opacity: 1;
    transition: opacity 1.5s ease-in;
}</pre></div><p>"The animation transitions are pretty simple here. When a new element is added in the beginning, to start with the six cats that we initialized with, the .cats-appear class is applied. In the next tick, the .<code class="literal">cats-appear-active</code> class is added to the element."</p><p>"Next, the classes are removed after a successful transition, as shown in the following screenshot:"</p><div class="mediaobject"><img src="graphics/4730_10_04.jpg" alt="Animate"/></div><p>"Shawn, if you can see, you will notice how the cats fade in and then show up in their end state in full opacity."</p><p>"Cool. That looks <a id="id271" class="indexterm"/>nice. A nice effect for when the new elements are added, as well."</p><p>"True. Do you want to try animating the stars?"</p><p>"Sure!"</p><p>"Let me first check the classes that we have for the stars. I can see that you have made use of the font-beautiful star and added style to them."</p><div class="informalexample"><pre class="programlisting">.fa {
  transition: all .1s ease-in-out;
  color: #666;
}
.star{
    display: inline-block;
    width: 20px;
    position: relative;
}

.star span{
    position: absolute;
    left: 0;
    top: 0;
}

.fa-star{
  color: #fa0017;
}

.fa-star-o{
    color: #fa0017;
}

.fa-star-o:active:before {
  content: "\f005"!important;
}</pre></div><p>"Yup, that's it right there."</p><p>"First, let me <a id="id272" class="indexterm"/>handle fave and unfave on the stars."</p><div class="informalexample"><pre class="programlisting">faveUnfave(event){
    let catCid = event.target.dataset;
    let catGenerator = this.state.catGenerator;
    let Cats = catGenerator.Cats;
    let cat = Cats.get(catCid);
    cat.set('faved', !cat.get('faved'));
    catGenerator.Cats = Cats;
    this.setState({catGenerator: catGenerator});
  }</pre></div><p>"Change the element to add <code class="literal">data-cid</code> and <code class="literal">handler</code>, as follows:"</p><div class="informalexample"><pre class="programlisting">&lt;span key={`${cat.cid}`}  className="fa fa-star" onClick={::this.faveUnfave} data-cid={cat.cid}&gt;&lt;/span&gt;  </pre></div><p>"Firstly, I am passing <code class="literal">faveUnfave</code> as the <code class="literal">onClick</code> event, which is bound to the class context here. Next, I am passing <code class="literal">cat.cid</code> value for <code class="literal">data-cid</code>"</p><p>"In the <code class="literal">faveUnfave</code> method, I will then pull the cat ID for the faved element. Based on this, I will pull the cat object from the catGenerator's cat collection. Later, I will toggle the state of the current fave value and reset the state of the collection."</p><p>"This looks good."</p><p>"Next, I will display either the faved or unfaved star, based on the current fave status and wrap this as a CSS transition so that we can start showing animation to display and hide the star, change the color, and so on."</p><div class="informalexample"><pre class="programlisting">&lt;ReactCSSTransitionGroup transitionName="faved"
                                             transitionEnterTimeout={500}
                                             transitionLeaveTimeout={300}
                                             transitionAppear={true}
                                             transitionAppearTimeout={500}
                                             className="star"&gt;
                    {()=&gt;{
                      if(cat.get('faved') === true){
                        return &lt;span key={`${cat.cid}`}  className="fa fa-star" onClick={::this.faveUnfave} data-cid={cat.cid}&gt;&lt;/span&gt;;
                      } else {
                        return &lt;span key={`${cat.cid}`}  className="fa fa-star-o" onClick={::this.faveUnfave} data-cid={cat.cid}&gt;&lt;/span&gt;;
                      }
                    }()}
                    &lt;/ReactCSSTransitionGroup&gt;</pre></div><p>"Perfect," followed Mike.</p><p>"Now let's add <a id="id273" class="indexterm"/>the styling for this fave."</p><div class="informalexample"><pre class="programlisting">.faved-enter {
    transform: scale(1.5);
}

.faved-enter.faved-enter-active {
    transform: scale(3);
    transition: all .5s ease-in-out;
}

.faved-leave {
    transform: translateX(-100%);
    transform: scale(0);
}

.faved-leave.faved-leave-active {
    transform: scale(0);
    transition: all .1s ease-in-out;
}</pre></div><p>"Here, I added animation such that, on clicking the star, it will scale up, similar to Twitter's fave functionality. Then, it will scale back and remain in faved state."</p><p>"Similarly on unfave it will scale up and back to its original size."</p><p>"Looks good, let's <a id="id274" class="indexterm"/>check it out," followed Mike.</p><p>"Umm, I think all elements are here, but it doesn't seem to be working, Mike?"</p><p>"Let me see. Ah, so the culprit is this:"</p><div class="informalexample"><pre class="programlisting">                       {()=&gt;{
                      if(cat.get('faved') === true){
                        return &lt;span key={`${cat.cid}`}  className="fa fa-star" onClick={::this.faveUnfave} data-cid={cat.cid}&gt;&lt;/span&gt;;
                      } else {
                        return &lt;span key={`${cat.cid}`}  className="fa fa-star-o" onClick={::this.faveUnfave} data-cid={cat.cid}&gt;&lt;/span&gt;;
                      }
                    }()}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>Notice the key value that we have used here? It's identical. The <code class="literal">TransitionGroup</code> keeps track of the changes to the elements and performs animation tasks based on key values. The <code class="literal">TransitionGroup</code> needs to know what has changed in the element in order to perform animation tasks and it also needs the key to identify the element.</p></div></div><p>"In the case here, the key will remain <code class="literal">cat.cid</code> in case of fave or unfave, and therefore the element stays the same."</p><p>"Let's add a suffix or prefix to the key, along with the fave status."</p><div class="informalexample"><pre class="programlisting">{()=&gt;{
                      if(cat.get('faved') === true){
                        return &lt;span key={`${cat.cid}_${cat.get('faved')}`} className="fa fa-star" onClick={::this.faveUnfave} data-cid={cat.cid}&gt;&lt;/span&gt;;
                      } else {
                        return &lt;span key={`${cat.cid}_${cat.get('faved')}`} className="fa fa-star-o" onClick={::this.faveUnfave} data-cid={cat.cid}&gt;&lt;/span&gt;;
                      }
}()}</pre></div><p>"Perfect. It works now, Mike."</p><p>"Yup. Nice work on the CSS animation, Shawn. The star looks good. Let's see how it looks now."</p><p>"Here's how it looks when <a id="id275" class="indexterm"/>we fave a cat:"</p><div class="mediaobject"><img src="graphics/4730_10_05.jpg" alt="Animate"/></div><p>"This one is after the fave transition is complete."</p><div class="mediaobject"><img src="graphics/4730_10_06.jpg" alt="Animate"/></div><p>"Finally, the same <a id="id276" class="indexterm"/>animation takes place when we try to unfave the cat."</p><div class="mediaobject"><img src="graphics/4730_10_07.jpg" alt="Animate"/></div><p>"Perfect, Carla will love this!"</p><p>It had been a fun day at Adequate LLC. Shawn and Mike worked on refactoring their app in order to allow data changes to reflect the view changes and animating the cats being added and removed. They <a id="id277" class="indexterm"/>also worked on how stars were faved/unfaved.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec78"/>Summary</h1></div></div></div><p>In this chapter, we worked around changing the data flow and passing data directly from react-router links. We took a look at animating a collection of objects being added/removed or as they appear. We saw different transition events supported by <code class="literal">ReactCSSTransitionGroup</code> and how to use relevant classes to animate our objects.</p><p>In the next chapter, we will learn how to test our app using Jest and React TestUtils.</p></div></body></html>