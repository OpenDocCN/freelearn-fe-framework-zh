- en: Styling and Animating
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式和动画
- en: If actions speak louder than words, then in the JavaScript world, effects make
    actions speak louder still. With jQuery, we can easily add impact to our actions
    through a set of simple visual effects and even craft our own sophisticated animations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果说行动胜于言辞，那么在JavaScript世界中，效果使行动更加响亮。通过jQuery，我们可以轻松地为我们的行动增添影响力，通过一组简单的视觉效果甚至制作我们自己复杂的动画。
- en: The effects offered by jQuery supply simple visual flourishes that grant a sense
    of movement and modernity to any page. However, apart from being mere decoration,
    they can also provide important usability enhancements that help orient the user
    when something happens on a page (especially common in Ajax applications).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供的效果为页面增添了简单的视觉华丽效果，赋予了现代感和动感。然而，除了仅仅是装饰之外，它们还可以提供重要的可用性增强，帮助用户在页面上发生某些事件时进行定位（尤其在Ajax应用程序中常见）。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Changing the styling of elements on the fly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态改变元素的样式
- en: Hiding and showing elements with various built-in effects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种内置效果隐藏和显示元素
- en: Creating custom animations of elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建元素的自定义动画
- en: Sequencing effects to happen one after another
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将效果按顺序连续发生
- en: Modifying CSS with inline properties
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改内联属性的CSS
- en: Before we jump into jQuery effects, a quick look at CSS is in order. In previous
    chapters, we have been modifying a document's appearance by defining styles for
    classes in a separate stylesheet and then adding or removing those classes with
    jQuery. Typically, this is the preferred process for injecting CSS into HTML because
    it respects the stylesheet's role in dealing with the presentation of a page.
    However, there may be times when we need to apply styles that haven't been or
    can't easily be defined in a stylesheet. Fortunately, jQuery offers the `.css()`
    method for such occasions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究jQuery效果之前，先来简要了解一下CSS是如何使用的。在之前的章节中，我们通过在单独的样式表中为类定义样式，然后使用jQuery添加或删除这些类来修改文档的外观。通常，这是将CSS注入HTML的首选过程，因为它尊重样式表在处理页面呈现方面的作用。然而，有时我们可能需要应用还没有或者不能轻松定义在样式表中的样式。幸运的是，jQuery为这种情况提供了`.css()`方法。
- en: 'This method acts as both a **getter** and a **setter**. To get the value of
    a single style property, we simply pass the name of the property as a string and
    get a string in return. To get the value of multiple style properties, we can
    pass the property names as an array of strings to get an object of property-value
    pairs in return. Multiword property names, such as `backgroundColor` can be interpreted
    by jQuery when in hyphenated CSS notation (`background-color`) or camel-cased
    DOM notation (`backgroundColor`):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法既作为**获取器**又作为**设置器**。要获取单个样式属性的值，我们只需将属性名称作为字符串传递，然后返回一个字符串。要获取多个样式属性的值，我们可以将属性名称作为字符串数组传递，然后返回属性值对的对象。多词属性名称，例如`backgroundColor`，可以通过jQuery在连字符化的CSS表示法（`background-color`）或驼峰式的DOM表示法（`backgroundColor`）中解释：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For setting style properties, the `.css()` method comes in two flavors. One
    flavor takes a single style property and its value, and the other takes an object
    of property-value pairs:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设置样式属性，`.css()`方法有两种形式。一种形式接受单个样式属性及其值，另一种形式接受属性值对的对象：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These simple key-value collections, called **object literals**, are real JavaScript
    objects that are created directly in code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的键值集合，称为**对象字面量**，是直接在代码中创建的真正的JavaScript对象。
- en: Object literal notation
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量表示法
- en: In a property value, strings are enclosed in quotes as usual, but other data
    types such as numbers do not require them. Since property names are strings, they
    would typically be contained in quotes. However, quotation marks are not required
    for property names if they are valid JavaScript identifiers, such as when they
    are written in camel-cased DOM notation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性值中，字符串通常像往常一样用引号括起来，但是其他数据类型如数字则不需要。由于属性名称是字符串，因此它们通常会被包含在引号中。然而，如果属性名称是有效的JavaScript标识符，比如在驼峰式的DOM表示法中书写时，属性名称就不需要引号。
- en: 'We use the `.css()` method the same way we''ve been using `.addClass()`; we
    apply it to a jQuery object, which in turn points to a collection of DOM elements.
    To demonstrate this, we''ll play with a style switcher similar to the one from
    [Chapter 3](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml), *Handling Events*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`.css()`方法的方式与使用`.addClass()`方法的方式相同；我们将其应用于一个指向DOM元素集合的jQuery对象。为了演示这一点，我们将玩弄一个类似于[第3章](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml)中的样式切换器，*处理事件*：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Getting the example code
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 获取示例代码
- en: You can access the example code from the GitHub repository: [https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 GitHub 存储库访问示例代码：[https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3)。
- en: 'By linking to a stylesheet with a few basic style rules, the page will initially
    look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过链接到具有几个基本样式规则的样式表，页面将最初呈现如下：
- en: '![](img/5297_04_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_04_01.png)'
- en: Once we're done with our code, clicking on the Bigger and Smaller buttons will
    increase or decrease the text size of `<div class="speech">`, while clicking on
    the Default button will reset `<div class="speech">` to its original text size.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们的代码后，单击“Bigger”和“Smaller”按钮将增加或减小 `<div class="speech">` 的文本大小，而单击“Default”按钮将重置
    `<div class="speech">` 的原始文本大小。
- en: Setting computed style property values
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置计算的样式属性值
- en: If all we wanted was to change the font size a single time to a predetermined
    value, we could still use the `.addClass()` method. But, let's suppose now that
    we want the text to continue increasing or decreasing incrementally each time
    the respective button is clicked. Although it might be possible to define a separate
    class for each click and iterate through them, a more straightforward approach
    would be to compute the new text size each time by getting the current size and
    increasing it by a set factor (for example, 40 percent).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要的仅仅是将字体大小一次性更改为预定值，我们仍然可以使用 `.addClass()` 方法。但是，现在假设我们想要每次单击相应按钮时文本都继续递增或递减。虽然可能可以为每次单击定义一个单独的类并对其进行迭代，但更简单的方法是每次通过获取当前大小并增加固定因子（例如，40%）来计算新的文本大小。
- en: 'Our code will start with the `$(() => {})` and `$(''#switcher-large'').click()`
    event handlers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码将以 `$(() => {})` 和 `$('#switcher-large').click()` 事件处理程序开头：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listing 4.1
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1
- en: 'Next, the font size can be easily discovered using the `.css()` method: `$(''div.speech'').css(''fontSize'')`.
    However, the returned value is a string, containing both the numeric font size
    value and the units of that value (`px`). We''ll need to strip the unit label
    off in order to perform calculations with the numeric value. Also, when we plan
    to use a jQuery object more than once, it''s generally a good idea to cache the
    selector by storing the resulting jQuery object in a constant:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，可以使用 `.css()` 方法轻松发现字体大小：`$('div.speech').css('fontSize')`。然而，返回的值是一个字符串，包含数值字体大小值和该值的单位（`px`）。我们需要去掉单位标签，以便使用数值进行计算。另外，当我们计划多次使用一个
    jQuery 对象时，通常最好通过将生成的 jQuery 对象存储在常量中来缓存选择器：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Listing 4.2
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2
- en: The first line inside `$(() => {})` creates a **constant** containing a jQuery
    object pointing to `<div class="speech">`. Note the use of a dollar (`$`) sign
    in the name, `$speech`. Since the dollar sign is a legal character in JavaScript
    identifiers, we can use it as a reminder that the constant is a jQuery object.
    Unlike in other programming languages such as PHP, the dollar symbol holds no
    special significance in JavaScript.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(() => {})` 内的第一行创建一个包含指向 `<div class="speech">` 的 jQuery 对象的**常量**。注意名称中的美元符号（`$`），`$speech`。由于美元符号是
    JavaScript 标识符中的合法字符，我们可以用它来提醒常量是一个 jQuery 对象。与其他编程语言（如 PHP）不同，美元符号在 JavaScript
    中没有特殊意义。'
- en: There's a good reason to use constants (`const`) instead of variables (`var`).
    Constants were introduced in the ES2015 version of JavaScript, and they can help
    reduce certain types of bugs. Take our `$speech` constant for instance. Is it
    ever going to hold a value other than `<div class="speech">`? No, it isn't. Since
    we've declared this as a constant, trying to assign another value to `$speech`
    results in an error. These errors are easy to fix. If `$speech` were declared
    as a variable and we mistakenly assigned it a new value, the failures would be
    subtle and difficult to diagnose. Of course, sometimes we *need* the ability to
    assign new values, in which case, you would use a variable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常量（`const`）而不是变量（`var`）有充分的理由。常量是在 JavaScript 的 ES2015 版本中引入的，它们可以帮助减少某些类型的错误。以我们的
    `$speech` 常量为例。它除了 `<div class="speech">` 之外，会持有其他值吗？不会。由于我们声明了这是一个常量，试图给 `$speech`
    分配另一个值会导致错误。这些错误很容易修复。如果 `$speech` 被声明为一个变量，并且我们错误地给它分配了一个新值，那么失败将是微妙且难以诊断的。当然，有时我们*需要*能够分配新值，在这种情况下，您将使用一个变量。
- en: Inside the `.click()` handler, we use `parseFloat()` to get the font size property's
    numeric value only. The `parseFloat()` function looks at a string from the left-hand
    side to the right-hand side until it encounters a non-numeric character. The string
    of digits is converted into a floating-point (decimal) number. For example, it
    would convert the string `'12'` to the number `12`. In addition, it strips non-numeric
    trailing characters from the string, so `'12px'` becomes `12`. If the string begins
    with a non-numeric character, `parseFloat()` returns `NaN`, which stands for *Not
    a Number*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.click()` 处理程序内部，我们使用 `parseFloat()` 仅获取字体大小属性的数值部分。`parseFloat()` 函数从左到右查看字符串，直到遇到一个非数字字符为止。数字字符串被转换为浮点数（十进制数）。例如，它会将字符串`'12'`转换为数字`12`。此外，它会从字符串中去除非数字的尾随字符，因此`'12px'`变成了`12`。如果字符串以非数字字符开头，`parseFloat()`
    将返回 `NaN`，表示*不是一个数字*。
- en: 'All that''s left to do is to modify the parsed numeric value and to reset the
    font size based on the new value. For our example, we''ll increase the font size
    by 40 percent each time the button is clicked. To achieve this, we''ll multiply
    `num` by `1.4` and then set the font size by concatenating the result and `''px''`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的就是修改解析出来的数值并根据新值重置字体大小。在我们的示例中，每次点击按钮时，我们将字体大小增加 40%。为此，我们将 `num` 乘以 `1.4`，然后通过连接结果和`'px'`来设置字体大小：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Listing 4.3
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.3
- en: 'Now when a user clicks on the Bigger button, the text becomes larger. Another
    click and the text becomes larger:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户点击“放大”按钮时，文本变大了。再次点击，文本就变得更大了：
- en: '![](img/5297_04_02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4](img/5297_04_02.png)'
- en: 'To get the Smaller button to decrease the font size, we will divide rather
    than multiply: -`num / 1.4`. Better still, we''ll combine the two into a single
    `.click()` handler on all the `<button>` elements within `<div id="switcher">`.
    Then, after finding the numeric value, we can either multiply or divide depending
    on the ID of the button that was clicked. *Listing 4.4* illustrates this.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要让“缩小”按钮减小字体大小，我们将使用除法而不是乘法：`num / 1.4`。更好的是，我们将两者合并成一个单一的`.click()`处理程序，适用于`<div
    id="switcher">`中的所有`<button>`元素。然后，在找到数值之后，我们可以根据被点击的按钮的 ID 来乘以或除以。*清单 4.4* 对此进行了说明。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listing 4.4
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.4
- en: The `e.target.id` value is used to determine the behavior of the click event.
    The `sizeMap` is where these behaviors are stored. This is a simple object that
    maps the element ID to a function. This function is passed the current `fontSize`
    value. The reason we want to use a map like this is that it's a lot easier to
    add or remove behavior than if it were coded as something like an `if` statement.
    For example, let's say the current font size was `"10px"` and the user clicked
    the Bigger button. Then, the template string ``${sizeMap[e.target.id](num)}px``
    would result in `"14px"`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`e.target.id` 值用于确定点击事件的行为。`sizeMap` 是存储这些行为的地方。这是一个简单的对象，将元素 ID 映射到一个函数。此函数接收当前的
    `fontSize` 值。我们之所以想使用这样的映射，是因为它比编码为 `if` 语句之类的东西更容易添加或删除行为。例如，假设当前的字体大小是`"10px"`，用户点击了“放大”按钮。那么，模板字符串``${sizeMap[e.target.id](num)}px``
    将导致`"14px"`。'
- en: 'It would also be nice to have a way to return the font size to its initial
    value. To allow the user to do so, we can simply store the font size in a variable
    as soon as the DOM is ready. We can then restore this value whenever the Default
    button is clicked. All we have to do is add another function to the `sizeMap`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让字体大小恢复到初始值也是很好的。为了让用户能够这样做，我们可以简单地在 DOM 准备就绪时将字体大小存储在一个变量中。然后，每当点击“默认”按钮时，我们就可以恢复这个值。我们只需要向
    `sizeMap` 添加另一个函数：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Listing 4.5
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.5
- en: Notice how we didn't have to touch the click handler at all to accommodate this
    new behavior? We created a new constant called `defaultSize`, which will always
    hold the original font size. Then, we just needed to add a new function for the
    `switcher-default` ID to `sizeMap`, which returns the `defaultSize` value.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们根本不需要更改点击处理程序来适应这种新行为？我们创建了一个名为`defaultSize`的新常量，它将始终保存原始字体大小。然后，我们只需要为`switcher-default`
    ID 添加一个新函数到 `sizeMap` 中，该函数返回 `defaultSize` 的值。
- en: With a map like this one, it's much easier to change our click handler behavior
    than it would be if we had to maintain `if` or `switch` statements in the handler.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的映射，更容易改变我们的点击处理程序行为，而不必维护 `if` 或 `switch` 语句。
- en: Using vendor-specific style properties
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特定于供应商的样式属性
- en: 'When browser vendors introduce experimental style properties, they often prefix
    the property name until the browser''s implementation aligns with the CSS specification.
    When both the implementation and the specification are stable enough, vendors
    will shed that prefix and allow the standard name to be used. In a stylesheet,
    therefore, it is not uncommon to see a set of CSS declarations like the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器供应商引入实验性的样式属性时，通常会在属性名称前加上前缀，直到浏览器的实现与 CSS 规范一致为止。当实现和规范足够稳定时，供应商会去除该前缀，并允许使用标准名称。因此，在样式表中，看到如下一组
    CSS 声明是很常见的：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we wanted to apply the same in JavaScript, we would need to test for the
    existence of the DOM equivalent of these variations: `propertyName`, `WebkitPropertyName`,
    `msPropertyName`, and so on. With jQuery, however, we can simply apply the standard
    property name, such as `.css(''propertyName'', ''value'')`. If that name is not
    found as a property of the style object, jQuery loops through the vendor prefixes
    behind the scenes--`Webkit`, `O`, `Moz`, and `ms`--and uses the first one it does
    find as a property, if any.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在 JavaScript 中应用相同的效果，我们需要测试 DOM 版本的这些变化的存在性：`propertyName`、`WebkitPropertyName`、`msPropertyName`
    等等。然而，使用 jQuery，我们可以简单地应用标准属性名称，例如 `.css('propertyName', 'value')`。如果在样式对象的属性中找不到该名称，则
    jQuery 在幕后循环遍历供应商前缀--`Webkit`、`O`、`Moz` 和 `ms`--并使用找到的第一个作为属性，如果有的话。
- en: Hiding and showing elements
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏和显示元素
- en: The basic `.hide()` and `.show()` methods, without any parameters, can be thought
    of as smart shorthand methods for `.css('display', 'string')`, where `'string'`
    is the appropriate display value. The effect, as might be expected, is that the
    matched set of elements will be immediately hidden or shown with no animation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 `.hide()` 和 `.show()` 方法，没有任何参数，可以被视为 `.css('display', 'string')` 的智能快捷方式方法，其中
    `'string'` 是适当的显示值。效果如预期，匹配的元素集将立即隐藏或显示，没有动画。
- en: 'The `.hide()` method sets the inline style attribute of the matched set of
    elements to `display: none`. The smart part here is that it remembers the value
    of the display property--typically `block`, `inline`, or `inline-block`--before
    it was changed to `none`. Conversely, the `.show()` method restores the display
    properties of the matched set of elements to whatever they initially were before
    `display: none` was applied.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`.hide()` 方法将匹配元素集的内联样式属性设置为 `display: none`。这里的巧妙之处在于它记住了显示属性的值--通常是 `block`、`inline`
    或 `inline-block`--在改为 `none` 之前的值。相反，`.show()` 方法将匹配元素集的显示属性恢复为在应用 `display: none`
    之前的初始值。'
- en: The display property
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 显示属性
- en: For more information about the `display` property and how its values are visually
    represented in a web page, visit the Mozilla Developer Center at [https://developer.mozilla.org/en-US/docs/CSS/display](https://developer.mozilla.org/en-US/docs/CSS/display)
    and view examples at [https://developer.mozilla.org/samples/cssref/display.html](https://developer.mozilla.org/samples/cssref/display.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `display` 属性以及它的值在网页中的视觉呈现方式的信息，请访问 Mozilla Developer Center [https://developer.mozilla.org/zh-CN/docs/Web/CSS/display](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display)，并查看示例
    [https://developer.mozilla.org/samples/cssref/display.html](https://developer.mozilla.org/samples/cssref/display.html)。
- en: 'This feature of `.show()` and `.hide()` is especially helpful when hiding elements
    that have had their default `display` property overridden in a stylesheet. For
    example, the `<li>` element has the property `display: list-item` by default,
    but we might want to change it to `display: inline` for a horizontal menu. Fortunately,
    using the `.show()` method on a hidden element such as one of the `<li>` tags
    would not merely reset it to its default `display: list-item`, because that would
    put the `<li>` tag on its own line. Instead, the element is restored to its previous
    `display: inline` state, thus preserving the horizontal design.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`.show()` 和 `.hide()` 的这个特性在隐藏已在样式表中被覆盖其默认 `display` 属性的元素时尤其有帮助。例如，`<li>`
    元素默认具有 `display: list-item` 属性，但我们可能希望将其更改为 `display: inline` 以用于水平菜单。幸运的是，对一个隐藏的元素（比如其中一个
    `<li>` 标签）使用 `.show()` 方法不会简单地将其重置为其默认的 `display: list-item`，因为这会将 `<li>` 标签放在自己的一行上。相反，该元素被恢复到其先前的
    `display: inline` 状态，从而保持了水平设计。'
- en: 'We can set up a quick demonstration of these two methods by working with a
    second paragraph and adding a read more link after the first paragraph in the
    example HTML:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在示例 HTML 中的第一个段落后添加一个“阅读更多”链接来设置这两种方法的快速演示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the DOM is ready, we select an element and call `.hide()` on it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当 DOM 就绪时，我们选择一个元素并对其调用 `.hide()` 方法：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Listing 4.6
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.6
- en: 'The `.eq()` method is similar to the `:eq()` pseudo-class discussed in [Chapter
    2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml), *Selecting Elements*. It returns
    a jQuery object pointing to a single element at the provided zero-based index.
    In this case, the method selects the second paragraph and hides it so that the
    read more link appears immediately following the first paragraph:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`.eq()`方法类似于[第二章](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml)*选择元素*中讨论的`:eq()`伪类。它返回一个jQuery对象，指向提供的从零开始的索引处的单个元素。在这种情况下，该方法选择第二个段落并隐藏它，以便在第一个段落后立即显示“阅读更多”链接：'
- en: '![](img/5297_04_03.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_04_03.png)'
- en: 'When the user clicks on read more at the end of the first paragraph, we call
    `.show()` to display the second paragraph and `.hide()` to hide the clicked link:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在第一个段落末尾点击“阅读更多”时，我们调用`.show()`来显示第二个段落，并调用`.hide()`来隐藏点击的链接：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 4.7
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.7
- en: 'Note the use of `.preventDefault()` to keep the link from activating its default
    action. Now the speech looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`.preventDefault()`来阻止链接触发其默认操作。现在演讲看起来像这样：
- en: '![](img/5297_04_04.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_04_04.png)'
- en: The `.hide()` and `.show()` methods are quick and useful, but they aren't very
    flashy. To add some flair, we can give them a duration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`.hide()`和`.show()`方法快速实用，但并不十分引人注目。为了增添一些风彩，我们可以给它们指定持续时间。'
- en: Effects and duration
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效果和持续时间
- en: 'When we include a duration (sometimes also referred to as a speed) with `.show()`
    or `.hide()`, it becomes animated--occurring over a specified period of time.
    The `.hide(duration)` method, for example, decreases an element''s height, width,
    and opacity simultaneously until all three reach zero, at which point the CSS
    rule `display: none` is applied. The `.show(duration)` method will increase the
    element''s height from top to bottom, width from the left-hand side to the right-hand
    side, and opacity from 0 to 1 until its contents are completely visible.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们在`.show()`或`.hide()`中包含持续时间（有时也称为速度）时，它就会变成动画效果——在指定的时间段内发生。例如，`.hide(duration)`方法会逐渐减小元素的高度、宽度和不透明度，直到这三者都达到零，此时将应用CSS规则`display:
    none`。`.show(duration)`方法将增加元素的高度从顶部到底部，宽度从左边到右边，不透明度从0到1，直到其内容完全可见。'
- en: Speeding in
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加速中
- en: With any jQuery effect, we can use one of the two preset speeds, `'slow'` or
    `'fast'`. Using `.show('slow')` makes the show effect complete in 600 milliseconds
    (0.6 seconds), `.show('fast')` in 200 milliseconds. If any other string is supplied,
    jQuery's default animation duration of 400 milliseconds will be used. For even
    greater precision, we can specify a number of milliseconds, for example, `.show(850)`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何jQuery效果时，我们可以使用两种预设速度之一，`'slow'`或`'fast'`。使用`.show('slow')`使显示效果在600毫秒（0.6秒）内完成，`.show('fast')`在200毫秒内完成。如果提供了任何其他字符串，jQuery将使用默认的动画持续时间400毫秒。为了更精确地控制，我们可以指定毫秒数，例如`.show(850)`。
- en: 'Let''s include a speed in our example when showing the second paragraph of
    Abraham Lincoln''s Gettysburg Address:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在显示亚伯拉罕·林肯的《葛底斯堡演说》第二段时包含一个速度示例：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Listing 4.8
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.8
- en: 'When we capture the paragraph''s appearance at roughly halfway through the
    effect, we see the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们大致捕捉到段落在效果中的中间时，我们看到以下内容：
- en: '![](img/5297_04_05.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_04_05.png)'
- en: Fading in and fading out
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 淡入和淡出
- en: 'While the animated `.show()` and `.hide()` methods are certainly flashy, in
    practice, they animate more properties than are useful. Fortunately, jQuery offers
    a couple of other prebuilt animations for a more subtle effect. For example, to
    have the whole paragraph appear just by gradually increasing the opacity, we can
    use `fadeIn(''slow'')` instead:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管动画化的`.show()`和`.hide()`方法确实很引人注目，但在实践中，它们会比有用的属性更多地进行动画处理。幸运的是，jQuery提供了另外几种预定义动画，效果更为微妙。例如，要使整个段落逐渐增加不透明度而出现，我们可以使用`fadeIn('slow')`代替：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Listing 4.9
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.9
- en: 'Now when we look at the paragraph during the effect, it looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们在效果进行时观察段落时，它看起来像这样：
- en: '![](img/5297_04_06.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_04_06.png)'
- en: The difference here is that the `.fadeIn()` effect starts by setting the dimensions
    of the paragraph so that the contents can simply fade into it. To gradually decrease
    the opacity we can use `.fadeOut()`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不同之处在于`.fadeIn()`效果首先设置段落的尺寸，使内容可以简单地淡入其中。为了逐渐减少不透明度，我们可以使用`.fadeOut()`。
- en: Sliding up and sliding down
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滑动向上和向下
- en: The fading animations are very useful for items that are outside the flow of
    the document. For example, these are typical effects to apply to *lightbox* elements
    that are overlaid on the page. However, when an element is part of the document
    flow, calling `.fadeIn()` on it causes the document to jump to provide the real
    estate needed for the new element, which is not aesthetically pleasing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 淡入淡出动画对于在文档流之外的项目非常有用。例如，这些是覆盖在页面上的*灯箱*元素上的典型效果。但是，当一个元素是文档流的一部分时，在其上调用`.fadeIn()`会导致文档跳转以提供新元素所需的房地产，这并不美观。
- en: 'In these cases, jQuery''s `.slideDown()` and `.slideUp()` methods are the right
    choice. These effects animate only the height of the selected elements. To have
    our paragraph appear using a vertical slide effect, we can call `.slideDown(''slow'')`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，jQuery的`.slideDown()`和`.slideUp()`方法是正确的选择。这些效果仅对所选元素的高度进行动画处理。要使我们的段落以垂直滑动效果显示，我们可以调用`.slideDown('slow')`：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing 4.10
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10
- en: 'This time when we examine the paragraph at the animation''s midpoint, we see
    the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当我们检查动画中点的段落时，我们看到以下内容：
- en: '![](img/5297_04_07.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_04_07.png)'
- en: To reverse the effect, we would instead call `.slideUp()`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要撤销这种效果，我们将调用`.slideUp()`方法。
- en: Toggling visibility
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换可见性
- en: 'Sometimes we have a need to toggle the visibility of elements, rather than
    displaying them once as we have done in the previous examples. This toggling can
    be achieved by first checking the visibility of the matched elements and then
    calling the appropriate method. Using the fade effects again, we can modify the
    example script to look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要切换元素的可见性，而不是像之前的示例中一样仅显示它们一次。这种切换可以通过首先检查匹配元素的可见性，然后调用适当的方法来实现。再次使用淡入淡出效果，我们可以修改示例脚本如下：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Listing 4.11
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11
- en: As we did earlier in the chapter, we're caching our selector here to avoid repeated
    DOM traversal. Notice too that we're no longer hiding the clicked link; instead,
    we're changing its text.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面所做的那样，我们在这里缓存了我们的选择器，以避免重复的DOM遍历。还要注意，我们不再隐藏点击的链接；相反，我们正在更改其文本。
- en: To examine the text contained by an element and to change that text, we're using
    the `.text()` method. We will delve into this method more fully in [Chapter 5](fa35636a-37d4-49b9-ba72-aa6596bab015.xhtml),
    *Manipulating the DOM*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查元素包含的文本并更改该文本，我们使用`.text()`方法。我们将在[第5章](fa35636a-37d4-49b9-ba72-aa6596bab015.xhtml)，*操作DOM*中更深入地探讨此方法。
- en: 'Using an `if-else` statement is a perfectly reasonable way to toggle an element''s
    visibility. But with jQuery''s compound effect methods, we can remove some conditional
    logic from our code. jQuery provides compound methods `.fadeToggle()` and `.slideToggle()`,
    which show or hide elements using the corresponding effects. Here is what the
    script looks like when we use the `.slideToggle()` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if-else`语句是切换元素可见性的完全合理的方法。但是，通过jQuery的复合效果方法，我们可以从代码中删除一些条件逻辑。jQuery提供了复合方法`.fadeToggle()`和`.slideToggle()`，它们使用相应的效果显示或隐藏元素。当我们使用`.slideToggle()`方法时，脚本看起来是这样的：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 4.12
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12
- en: The **ternary expression** (`$(e.target).text() === 'read more' ?`) checks for
    the text of the link rather than the visibility of the second paragraph, since
    we're only using it to change the text. We can use ternary expressions as a shorter
    alternative to full-blown `if` statements when we need a value based on some condition.
    Think of ternary expressions as calling a function that returns a different value
    based on the arguments supplied.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**三元表达式**（`$(e.target).text() === ''read more'' ?`）检查链接的文本而不是第二段落的可见性，因为我们只是用它来更改文本。当我们需要基于某些条件获取值时，我们可以使用三元表达式作为完整的`if`语句的较短替代方法。把三元表达式想象成调用一个函数，根据提供的参数返回不同的值。'
- en: Creating custom animations
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义动画
- en: 'In addition to the prebuilt effect methods, jQuery provides a powerful `.animate()`
    method that allows us to create our own custom animations with fine-grained control.
    The `.animate()` method comes in two forms. The first takes up to four arguments:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预先构建的效果方法外，jQuery还提供了一个强大的`.animate()`方法，允许我们使用精细的控制创建自己的自定义动画。`.animate()`方法有两种形式。第一种最多接受四个参数：
- en: An object of style properties and values, which is similar to the `.css()` argument
    discussed earlier in this chapter
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含样式属性和值的对象，与本章前面讨论的`.css()`参数类似
- en: An optional duration, which can be one of the preset strings or a number of
    milliseconds
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的持续时间，可以是预设字符串之一，也可以是毫秒数
- en: An optional easing type, which is an option that we will not use now, but which
    we will discuss in [Chapter 11](18ed1c5d-dfac-4361-b647-0cb63f5dd58b.xhtml), *Advanced
    Effects*
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的缓动类型，这是一个我们现在不会使用的选项，但我们将在[第 11 章](18ed1c5d-dfac-4361-b647-0cb63f5dd58b.xhtml)
    *高级效果*中讨论它。
- en: An optional callback function, which will be discussed later in this chapter
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的回调函数，稍后在本章中讨论
- en: 'All together, the four arguments look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这四个参数看起来像这样：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second form takes two arguments: an object of properties and an object
    of options:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式接受两个参数：一个属性对象和一个选项对象：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this form, the second argument wraps up the second through fourth arguments
    of the first form into another object and adds some more advanced options to the
    mix. Here''s what the second form looks like with actual arguments passed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种形式中，第二个参数将第一种形式的第二到第四个参数包装到另一个对象中，并将一些更高级的选项加入其中。以下是传递实际参数时的第二种形式：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For now, we'll use the first form of the `.animate()` method, but we'll return
    to the second form later in the chapter when we discuss queuing effects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`.animate()`方法的第一种形式，但在本章讨论排队效果时，我们将返回到第二种形式。
- en: Building effects by hand
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动构建效果
- en: 'We have already seen several prepackaged effects for showing and hiding elements.
    To begin our discussion of the `.animate()` method, it will be useful to see how
    we could achieve the same results by calling `.slideToggle()` using this lower-level
    interface. Replacing the `.slideToggle()` line of the previous example with our
    custom animation turns out to be quite simple:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几种用于显示和隐藏元素的预包装效果。在讨论`.animate()`方法之前，通过调用`.slideToggle()`使用这个较低级别的接口实现相同的结果将是有用的。用我们的自定义动画替换前面示例中的`.slideToggle()`行非常简单：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Listing 4.13
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13
- en: This is not a perfect replacement for .`slideToggle()`; the actual implementation
    also animates the margin and padding of elements.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是`.slideToggle()`的完美替代品；实际的实现还会动画化元素的边距和填充。
- en: As the example illustrates, the `.animate()` method provides convenient shorthand
    values for CSS properties, such as `'show'`, `'hide'`, and `'toggle'`, to ease
    the process when we want to emulate the behavior of prepackaged effect methods
    such as `.slideToggle()`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，`.animate()`方法提供了用于 CSS 属性的方便的简写值，如`'show'`、`'hide'`和`'toggle'`，以简化当我们想要模拟预包装效果方法如`.slideToggle()`的行为时的过程。
- en: Animating multiple properties at once
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时动画多个属性
- en: 'With the `.animate()` method, we can modify any combination of properties simultaneously.
    For example, to create a simultaneous sliding and fading effect when toggling
    the second paragraph, we simply add `opacity` to the properties that are passed
    to `.animate()`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.animate()`方法，我们可以同时修改任意组合的属性。例如，要在切换第二段落时创建一个同时滑动和淡出的效果，我们只需将`opacity`添加到传递给`.animate()`的属性中即可：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Listing 4.14
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14
- en: 'Additionally, we have not only the style properties used for the shorthand
    effect methods at our disposal, but also numeric CSS properties such as `left`,
    `top`, `fontSize`, `margin`, `padding`, and `borderWidth`. In *Listing 4.5*, we
    changed the text size of the speech paragraphs. We could animate this increase
    or decrease in size by simply substituting the `.animate()` method for the `.css()`
    method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们不仅可以使用简写效果方法中使用的样式属性，还可以使用数值 CSS 属性，例如`left`、`top`、`fontSize`、`margin`、`padding`和`borderWidth`。在*列表
    4.5*中，我们改变了段落的文本大小。我们可以通过简单地将`.animate()`方法替换为`.css()`方法来动画化文本大小的增加或减少：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Listing 4.15
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15
- en: 'The extra animation properties allow us to create much more complex effects,
    too. We can, for example, move an item from the left-hand side of the page to
    the right-hand side while increasing its height by 20 pixels and changing its
    border width to 5 pixels. We will illustrate this complicated set of property
    animations with the `<div id="switcher">` box. Here is what it looks like before
    we animate it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的动画属性允许我们创建更复杂的效果。例如，我们可以将一个项目从页面的左侧移动到右侧，同时将其高度增加 20 像素，并将其边框宽度更改为 5 像素。我们将用`<div
    id="switcher">`框来说明这一复杂的属性动画集。在我们对其进行动画化之前，它是这样的：
- en: '![](img/5297_04_08.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_04_08.png)'
- en: 'With a flexible-width layout, we need to compute the distance that the box
    needs to travel before it lines up at the right-hand side of the page. Assuming
    that the paragraph''s width is 100 percent, we can subtract the Text Size box''s
    width from the paragraph''s width. We have the `jQuery.outerWidth()` method at
    our disposal to calculate these widths, including padding and border. We''ll use
    this method to compute the new `left` property of the switcher. For the sake of
    this example, we''ll trigger the animation by clicking on the Text Size label
    just above the buttons. Here is what the code should look like:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有可伸缩宽度布局，我们需要计算框在与页面右侧对齐之前需要移动的距离。假设段落的宽度是 `100%`，我们可以从段落的宽度中减去“文本大小”框的宽度。我们可以使用
    `jQuery.outerWidth()` 方法来计算这些宽度，包括填充和边框。我们将使用此方法来计算 switcher 的新 `left` 属性。为了本例子的目的，我们将通过点击按钮上方的“文本大小”标签来触发动画。下面是代码应该的样子：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Listing 4.16
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16
- en: It is worth examining these animated properties in detail. The `borderWidth`
    property is straightforward, as we are specifying a constant value with units,
    just as we would in a stylesheet. The `left` property is a computed numeric value.
    The unit suffix is optional on these properties; since we omit it here, `px` is
    assumed. Finally, the `height` property uses a syntax we have not seen before.
    The `+=` prefix on a property value indicates a relative value. So, instead of
    animating the height to 20 pixels, the height is animated to 20 pixels greater
    than the current height. Because of the special characters involved, relative
    values must be specified as a string.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要详细检查这些动画属性。`borderWidth` 属性很直接，因为我们正在指定一个带单位的常量值，就像在样式表中一样。`left` 属性是一个计算出的数字值。在这些属性上，单位后缀是可选的；因为我们在这里省略了它，所以假定为
    `px`。最后，`height` 属性使用了我们之前未见过的语法。在属性值上的 `+=` 前缀表示相对值。所以，不是将高度动画变为 `20` 像素，而是将高度动画变为当前高度的
    `20` 像素更高。由于涉及到特殊字符，相对值必须指定为字符串。
- en: 'Although this code successfully increases the height of the `<div>` tag and
    widens its border, at the moment, the `left` position appears unchanged:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此代码成功增加了 `<div>` 标签的高度并扩大了其边框，但是目前，`left` 位置似乎未更改：
- en: '![](img/5297_04_09.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_04_09.png)'
- en: We still need to enable changing this box's position in the CSS.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要在 CSS 中启用更改此框的位置。
- en: Positioning with CSS
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CSS 进行定位
- en: When working with `.animate()`, it's important to keep in mind the limitations
    that CSS imposes on the elements that we wish to change. For example, adjusting
    the `left` property will have no effect on the matching elements unless those
    elements have their CSS position set to `relative` or `absolute`. The default
    CSS position for all block-level elements is `static`, which accurately describes
    how those elements will remain if we try to move them without first changing their
    `position` value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `.animate()` 时，重要的是要记住 CSS 对我们希望更改的元素施加的限制。例如，调整 `left` 属性对匹配元素没有影响，除非这些元素的
    CSS 位置设置为 `relative` 或 `absolute`。所有块级元素的默认 CSS 位置都是 `static`，这准确描述了如果我们在先更改它们的
    `position` 值之前尝试移动它们，这些元素将保持不变的方式。
- en: For more information on absolute and relative positioning, see CSS Tricks: [https://css-tricks.com/almanac/properties/p/position/](https://css-tricks.com/almanac/properties/p/position/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有关绝对和相对定位的更多信息，请参阅 CSS 技巧：[https://css-tricks.com/almanac/properties/p/position/](https://css-tricks.com/almanac/properties/p/position/)。
- en: 'In our stylesheet, we could set `<div id="switcher">` to be relatively positioned:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的样式表中，我们可以将 `<div id="switcher">` 设置为相对定位：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Instead, though, let''s practice our jQuery skills by altering this property
    through JavaScript when needed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，让我们通过在需要时通过 JavaScript 更改此属性来练习我们的 jQuery 技能：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Listing 4.17
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17
- en: 'With the CSS taken into account, the result of clicking on Text Size after
    the animation has completed will look like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑了 CSS 后，在动画完成后点击“文本大小”后的结果如下：
- en: '![](img/5297_04_10.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_04_10.png)'
- en: Simultaneous versus queued effects
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时执行与顺序执行的效果
- en: The `.animate()` method, as we've just discovered, is very useful for creating
    **simultaneous** effects affecting a particular set of elements. There may be
    times, however, when we want to **queue** our effects to have them occur one after
    the other.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚发现的那样，`.animate()` 方法对影响特定一组元素的**同时**效果非常有用。然而，有时候我们想要**排队**我们的效果，以便它们一个接一个地发生。
- en: Working with a single set of elements
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单组元素
- en: 'When applying multiple effects to the same set of elements, queuing is easily
    achieved by chaining those effects. To demonstrate this queuing, we''ll revisit
    *Listing 4.17* by moving the Text Size box to the right-hand side, increasing
    its height and border width. This time, however, we perform the three effects
    sequentially simply by placing each in its own `.animate()` method and chaining
    the three together:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当对同一组元素应用多个效果时，通过链接这些效果可以轻松实现排队。为了演示这种排队，我们将通过将文本大小框移动到右侧，增加其高度和边框宽度来重新访问*列表
    4.17*。但是，这次，我们只需将每个效果放在自己的`.animate()`方法中，并将三者链接在一起，便可以依次执行三个效果：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Listing 4.18
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.18
- en: Recall that chaining permits us to keep all three `.animate()` methods on the
    same line, but here we have indented them and put each on its own line for greater
    readability.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，链式调用允许我们将所有三个`.animate()`方法保持在同一行上，但是在这里，我们将它们缩进并将每个方法放在自己的一行上以提高可读性。
- en: 'We can queue any of the jQuery effect methods by chaining them, not just `.animate()`.
    We could, for example, queue effects on `<div id="switcher">` in the following
    order:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过链接它们来对jQuery效果方法中的任何一个进行排队，而不仅仅是`.animate()`。例如，我们可以按照以下顺序对`<div id="switcher">`上的效果进行排队：
- en: Fade its opacity to 0.5 with `.fadeTo()`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.fadeTo()`将其不透明度淡化为0.5。
- en: Move it to the right-hand side with `.animate()`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.animate()`将其移到右侧。
- en: Fade it back in to full opacity with `.fadeTo()`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.fadeTo()`将其淡回完全不透明。
- en: Hide it with `.slideUp()`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.slideUp()`将其隐藏。
- en: Show it once more with `.slideDown()`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.slideDown()`再次显示它。
- en: 'All we need to do is chain the effects in the same order in our code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是按照代码中相同的顺序链接效果：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Listing 4.19
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.19
- en: Bypassing the queue
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过队列
- en: 'But what if we want to move the `<div>` tag to the right-hand side at the same
    time as it fades to half opacity? If the two animations were occurring at the
    same speed, we could simply combine them into a single `.animate()` method. But,
    in this example, the fade is using the `''fast''` speed while the move to the
    right-hand side is using the `''slow''` speed. Here is where the second form of
    the `.animate()` method comes in handy:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要在淡入到半透明度的同时将`<div>`标签移到右侧怎么办？如果两个动画的速度相同，我们可以简单地将它们合并为一个`.animate()`方法。但是，在这个例子中，淡出使用了'快'速度，而移到右侧则使用了'慢'速度。这就是第二种形式的`.animate()`方法派上用场的地方：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Listing 4.20
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.20
- en: The second argument, an options object, provides the `queue` option, which when
    set to `false` makes the animation start simultaneously with the previous one.
    Which makes sense if you think about it, because anything that sits in a queue,
    has to wait for anything that's already in the queue.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数，一个选项对象，提供了`queue`选项，当设置为`false`时，使动画与前一个动画同时开始。如果你考虑一下，这是有道理的，因为任何在队列中的东西都必须等待已经在队列中的东西。
- en: Queuing effects manually
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动排队效果
- en: One final observation about queuing effects on a single set of elements is that
    queuing does not automatically apply to other non-effect methods such as .`css()`.
    So, let's suppose we wanted to change the background color of `<div id="switcher">`
    to red after the `.slideUp()` method, but before the `slideDown()` method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关于单一元素队列效应的最后观察是，排队不会自动应用于其他非效果方法，例如`.css()`。所以，假设我们想在`.slideUp()`方法之后但在`slideDown()`方法之前将`<div
    id="switcher">`的背景颜色更改为红色。
- en: 'We could try doing it like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试这样做：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Listing 4.21
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.21
- en: However, even though the code that changes the background color is placed at
    the correct position in the chain, it occurs immediately upon the click.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管改变背景颜色的代码被放置在链中的正确位置，但它会立即在点击时发生。
- en: 'One way we can add non-effect methods to the queue is to use the appropriately
    named `.queue()` method. Here is what it would look like in our example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用名为`.queue()`的方法将非效果方法添加到队列中。以下是在我们的示例中的样子：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Listing 4.22
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.22
- en: When given a callback function, as it is here, the `.queue()` method adds the
    function to the queue of effects to perform on the matched elements. Within the
    function, we set the background color to red and then call `next()`, a function
    that is passed as a parameter to our callback. Including this `next()` function
    call allows the animation queue to pick up where it left off and complete the
    chain with the following `.slideDown('slow')` line. If we hadn't called `next()`,
    the animation would have stopped.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当即将执行一个回调函数时，`.queue()`方法将该函数添加到要对匹配元素执行的效果队列中。在函数内部，我们将背景颜色设置为红色，然后调用`next()`，这是一个作为参数传递给我们的回调函数的函数。包含这个`next()`函数调用允许动画队列从断点恢复，并用后续的`.slideDown('slow')`行完成链条。如果我们没有调用`next()`，动画将停止。
- en: For more information and examples of `.queue()`, visit [http://api.jquery.com/category/effects/](http://api.jquery.com/category/effects/).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`.queue()`的更多信息和示例，请访问[http://api.jquery.com/category/effects/](http://api.jquery.com/category/effects/)。
- en: We'll discover another way to queue non-effect methods as we examine effects
    with multiple sets of elements.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们研究对多组元素进行效果处理时，我们将发现另一种在非效果方法中排队的方法。
- en: Working with multiple sets of elements
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多组元素
- en: 'Unlike with a single set of elements, when we apply effects to different sets,
    they occur at virtually the same time. To see these simultaneous effects in action,
    we''ll slide one paragraph down while sliding another paragraph up. We''ll be
    working with paragraphs three and four of our sample document:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与单一元素不同，当我们对不同的元素集应用效果时，它们几乎同时发生。为了看到这些同时发生的效果，我们将把一个段落向下滑动，同时将另一个段落向上滑动。我们将处理我们示例文档中的第三段和第四段：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To help us see what''s happening during the effect, we''ll give the third paragraph
    a 1-pixel border and the fourth paragraph a gray background. We''ll also hide
    the fourth paragraph when the DOM is ready:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们看到效果的发生过程，我们将给第三段添加1像素的边框，将第四段添加灰色背景。此外，在DOM准备就绪时，我们将隐藏第四段：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Listing 4.23
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.23
- en: 'Our sample document now displays the opening paragraph followed by the read
    more link and the bordered paragraph:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例文档现在显示了开头段落，然后是阅读更多链接和有边框的段落：
- en: '![](img/5297_04_11.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_04_11.png)'
- en: 'Finally, we''ll apply a `click` handler to the third paragraph so that when
    it is clicked, the third paragraph will slide up (and eventually out of view)
    while the fourth paragraph slides down (and into view):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在第三段应用一个`click`处理程序，这样当单击它时，第三段将向上滑动（最终滑出视野），而第四段将向下滑动（并进入视野）：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Listing 4.24
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.24
- en: 'A screenshot of these two effects in mid-slide confirms that they do, indeed,
    occur simultaneously:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在滑动中截取这两个效果的屏幕截图证实它们的确是同时发生的：
- en: '![](img/5297_04_12.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_04_12.png)'
- en: The third paragraph, which started visible, is halfway through sliding up at
    the same time as the fourth paragraph, which started hidden, is halfway through
    sliding down.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第三段开始是可见的，正在向上滑动，与此同时第四段，开始是隐藏的，正在向下滑动。
- en: Queuing with callbacks
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用回调函数排队
- en: In order to allow queuing effects on different elements, jQuery provides a callback
    function for each effect method. As we have seen with event handlers and with
    the `.queue()` method, callbacks are simply functions passed as method arguments.
    In the case of effects, they appear as the last argument of the method.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许在不同元素上排队效果，jQuery为每个效果方法提供了一个回调函数。正如我们在事件处理程序和`.queue()`方法中所看到的，回调函数只是作为方法参数传递的函数。至于效果，它们出现在方法的最后一个参数中。
- en: 'If we use a callback to queue the two slide effects, we can have the fourth
    paragraph slide down before the third paragraph slides up. Let''s first try moving
    the `.slideUp()` call into the .`slideDown()` method''s completion callback:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一个回调将这两个滑动效果排队，我们可以让第四段在第三段之前滑下来。让我们先尝试将`.slideUp()`调用移到`.slideDown()`方法的完成回调中：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Listing 4.25
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.25
- en: Had we decided to use `$(this)` in both the `click()` callback function and in
    the `slideDown()` callback function, things wouldn't have worked as expected.
    That's because `this` is contextual. Instead, we can avoid it all together and
    reference `$(e.target)` to get the `<p>` element that we need.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定在`click()`回调函数和`slideDown()`回调函数中都使用`$(this)`，事情将不会按预期进行。因为`this`是有上下文的。相反，我们可以完全避免它，并引用`$(e.target)`来获取我们需要的`<p>`元素。
- en: 'This time, a snapshot halfway through the effects reveals that both the third
    and the fourth paragraphs are visible; the fourth has finished sliding down and
    the third is about to begin sliding up:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，在效果进行一半的快照中，第三段和第四段都是可见的；第四段已经滑动下来，第三段即将开始滑动上去：
- en: '![](img/5297_04_13.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_04_13.png)'
- en: 'Now that we''ve discussed callbacks, we can return to the code from *Listing
    4.22*, in which we queued a background-color change near the end of a series of
    effects. Instead of using the `.queue()` method, as we did then, we can simply
    use a callback function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了回调函数，我们可以返回到*清单 4.22*中的代码，其中我们在一系列效果的最后排队更改了背景颜色。与当时所做的一样，我们可以简单地使用回调函数，而不是使用`.queue()`方法：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Listing 4.26
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.26
- en: Here again, the background color of `<div id="switcher">` changes to red after
    it slides up and before it slides back down. Note that when using an effect's
    completion callback rather than `.queue()`, we don't need to worry about calling
    `next()` from within the callback.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，在`<div id="switcher">`滑动上升之后和滑动回落之前，背景色会变为红色。请注意，当使用效果的完成回调而不是`.queue()`时，我们不需要担心在回调中调用`next()`。
- en: In a nutshell
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: With all the variations to consider when applying effects, it can become difficult
    to remember whether the effects will occur simultaneously or sequentially. A brief
    outline might help.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到应用效果时的各种变化，记住效果是同时还是顺序发生可能变得困难。简要的大纲可能会有所帮助。
- en: 'Effects on a single set of elements are:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 单一元素集上的效果是：
- en: Simultaneous when applied as multiple properties in a single .`animate()` method
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个属性同时应用于单个`.animate()`方法时
- en: Queued when applied in a chain of methods, unless the `queue` option is set
    to `false`
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法链中应用时排队，除非将 `queue` 选项设置为 `false`
- en: 'Effects on multiple sets of elements are:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 多个元素集上的效果是：
- en: Simultaneous by default
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下同时进行
- en: Queued when applied within the callback of another effect or within the callback
    of the `.queue()` method
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个效果的回调中应用时或者在`.queue()`方法的回调中应用时排队
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Using the effect methods that we have explored in this chapter, we should now
    be able to modify inline style attributes from JavaScript, apply prepackaged jQuery
    effects to elements, and create our own custom animations. In particular, you
    learned how to incrementally increase and decrease text size using either the
    `.css()` or `.animate()` methods, gradually hide and show page elements by modifying
    several attributes, and how to animate elements (simultaneously or sequentially)
    in a number of ways.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章中探讨的效果方法，我们现在应该能够从 JavaScript 修改内联样式属性，将预包装的 jQuery 效果应用于元素，并创建我们自己的自定义动画。特别是，您学会了如何逐步增加和减小文本大小，使用`.css()`
    或 `.animate()` 方法，通过修改多个属性逐渐隐藏和显示页面元素，以及如何以多种方式动画元素（同时或顺序）。
- en: In the first four chapters of this book, all of our examples have involved manipulating
    elements that have been hardcoded into the page's HTML. In [Chapter 5](fa35636a-37d4-49b9-ba72-aa6596bab015.xhtml),
    *Manipulating the DOM*, we will explore ways to manipulate the DOM directly, including
    using jQuery to create new elements and insert them into the DOM wherever we choose.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前四章中，我们的所有示例都涉及到操纵硬编码到页面 HTML 中的元素。在[第 5 章](fa35636a-37d4-49b9-ba72-aa6596bab015.xhtml)，*操作
    DOM* 中，我们将探讨直接操作 DOM 的方法，包括使用 jQuery 创建新元素并将其插入到我们选择的 DOM 中。
- en: Further reading
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The topic of animation will be explored in more detail in [Chapter 11](18ed1c5d-dfac-4361-b647-0cb63f5dd58b.xhtml),
    *Advanced Effects*. A complete list of effect and styling methods is available
    in Appendix B of this book, or in the official jQuery documentation at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 动画主题将在[第 11 章](18ed1c5d-dfac-4361-b647-0cb63f5dd58b.xhtml)，*高级效果* 中详细探讨。本书附录
    B 中提供了完整的效果和样式方法列表，或者在官方 jQuery 文档[http://api.jquery.com/](http://api.jquery.com/)
    中提供。
- en: Exercises
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The challenge exercise may require the use of the official jQuery documentation
    at [http://api.jquery.com/](http://api.jquery.com/):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战练习可能需要使用官方 jQuery 文档[http://api.jquery.com/](http://api.jquery.com/)：
- en: Alter the stylesheet to hide the contents of the page initially. When the page
    is loaded, fade in the contents slowly.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改样式表以最初隐藏页面内容。当页面加载时，逐渐淡入内容。
- en: Give each paragraph a yellow background only when the mouse is over it.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当鼠标悬停在段落上时，才给每个段落添加黄色背景。
- en: Make a click on the title `(<h2>)` and simultaneously fade it to 25 percent
    opacity and grow its left-hand margin to `20px`. Then, when this animation is
    complete, fade the speech text to 50 percent opacity.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击标题`(<h2>)`，同时将其淡出至25%的不透明度，并将其左边距增加到`20px`。然后，当此动画完成时，将演讲文本淡出至50%的不透明度。
- en: 'Here''s a challenge for you. React to presses of the arrow keys by smoothly
    moving the switcher box 20 pixels in the corresponding direction. The key codes
    for the arrow keys are: `37` (left), `38` (up), `39` (right), and `40` (down).'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一个挑战给你。通过平滑地移动开关框，对箭头键的按键作出反应，向相应方向移动20像素。箭头键的键码分别为：`37`（左）、`38`（上）、`39`（右）和`40`（下）。
