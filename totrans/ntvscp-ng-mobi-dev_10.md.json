["```js\nnpm i @ngrx/store --save\n```", "```js\nexport interface IUserState {\n  recentUsername?: string;\n  current?: any;\n  loginCanceled?: boolean;\n}\n\nexport const userInitialState: IUserState = {};\n```", "```js\nexport * from './user.state';\n```", "```js\nimport { Action } from '@ngrx/store';\nimport { IUserState } from '../states';\n\nexport namespace \n\nUserActions {\n  const CATEGORY: string = 'User';\n\n  export interface IUserActions {\n    INIT: \n\nstring;\n    LOGIN: string;\n    LOGIN_SUCCESS: string;\n    LOGIN_CANCELED: string;\n    LOGOUT: \n\nstring;\n    UPDATED: string;\n  }\n\n  export const ActionTypes: IUserActions = {\n    INIT:           \n\n`${CATEGORY} Init`,\n    LOGIN:          `${CATEGORY} Login`,\n    LOGIN_SUCCESS:  `${CATEGORY} Login Success`,\n    LOGIN_CANCELED: `${CATEGORY} Login Canceled`,\n    LOGOUT:         `${CATEGORY} Logout`,\n    UPDATED:        \n\n`${CATEGORY} Updated`\n  };\n\n  export class InitAction implements Action {\n    type = \n\nActionTypes.INIT;\n    payload = null;\n  }\n\n  export class LoginAction implements Action {\n    type \n\n= ActionTypes.LOGIN;\n    constructor(public payload: { msg: string; usernameAttempt?: string}) { }\n  }\n\n  export class LoginSuccessAction implements Action {\n    type = ActionTypes.LOGIN_SUCCESS;\n    constructor\n\n(public payload: any /*user object*/) { }\n  }\n\n  export class LoginCanceledAction implements Action {\n\n  type = ActionTypes.LOGIN_CANCELED;\n    constructor(public payload?: string /*last attempted username*/) { }\n\n}\n\n  export class LogoutAction implements Action {\n    type = ActionTypes.LOGOUT;\n    payload = \n\nnull;\n  }\n\n  export class UpdatedAction implements Action {\n    type = ActionTypes.UPDATED;\n\nconstructor(public payload: IUserState) { }\n  }\n\n  export type Actions =\n    InitAction\n    | \n\nLoginAction\n    | LoginSuccessAction\n    | LoginCanceledAction\n    | LogoutAction\n    | \n\nUpdatedAction;\n}\n```", "```js\nexport * from './user.action';\n```", "```js\nimport { IUserState, userInitialState } from '../states/user.state';\nimport { UserActions } from \n\n'../actions/user.action';\n\nexport function userReducer(\n  state: IUserState = userInitialState,\n\naction: UserActions.Actions\n): IUserState {\n  switch (action.type) {\n    case \n\nUserActions.ActionTypes.UPDATED:\n      return Object.assign({}, state, action.payload);\n    default:\n\nreturn state;\n  }\n}\n```", "```js\nnpm i @ngrx/effects --save\n```", "```js\n// angular\nimport { Injectable } from '@angular/core';\n\n// libs\nimport { Store, Action } from \n\n'@ngrx/store';\nimport { Effect, Actions } from '@ngrx/effects';\nimport { Observable } from \n\n'rxjs/Observable';\n\n// module\nimport { LogService } from '../../core/services/log.service';\nimport { \n\nDatabaseService } from '../services/database.service';\nimport { UserService } from '../services/user.service';\nimport { UserActions } from '../actions/user.action';\n\n@Injectable()\nexport class UserEffects {\n\n  @Effect() init$: Observable<Action> = this.actions$\n    .ofType(UserActions.ActionTypes.INIT)\n    .startWith(new UserActions.InitAction())\n    .map(action => {\n      const current = \n\nthis.databaseService\n        .getItem(DatabaseService.KEYS.currentUser);\n      const recentUsername = \n\nthis.databaseService\n        .getItem(DatabaseService.KEYS.recentUsername);\n      this.log.debug(`Current user: \n\n`, current || 'Unauthenticated');\n        return new UserActions.UpdatedAction({ current, recentUsername });\n\n});\n\n  @Effect() login$: Observable<Action> = this.actions$\n    .ofType\n\n(UserActions.ActionTypes.LOGIN)\n    .withLatestFrom(this.store)\n    .switchMap(([action, state]) => {\n\n  const current = state.user.current;\n      if (current) {\n        // user already logged in, just fire \n\nupdated\n        return Observable.of(\n          new UserActions.UpdatedAction({ current })\n        );\n\n    } else {\n        this._loginPromptMsg = action.payload.msg;\n        const usernameAttempt =\n\naction.payload.usernameAttempt\n          || state.user.recentUsername;\n\n        return \n\nObservable.fromPromise(\n          this.userService.promptLogin(this._loginPromptMsg, \n          usernameAttempt)\n\n        )\n        .map(user => (new UserActions.LoginSuccessAction(user)))\n        .catch\n\n(usernameAttempt => Observable.of(\n          new UserActions.LoginCanceledAction(usernameAttempt)\n\n));\n      }\n    });\n\n  @Effect() loginSuccess$: Observable<Action> = this.actions$\n\n.ofType(UserActions.ActionTypes.LOGIN_SUCCESS)\n    .map((action) => {\n      const user = action.payload;\n\n     const recentUsername = user.username;\n      this.databaseService\n        .setItem\n\n(DatabaseService.KEYS.currentUser, user);\n      this.databaseService\n        .setItem\n\n(DatabaseService.KEYS.recentUsername, recentUsername);\n      this._loginPromptMsg = null; // clear, no longer \n\nneeded\n      return (new UserActions.UpdatedAction({\n        current: user,\n        recentUsername,\n\n    loginCanceled: false\n      }));\n    });\n\n  @Effect() loginCancel$ = this.actions$\n\n.ofType(UserActions.ActionTypes.LOGIN_CANCELED)\n    .map(action => {\n      const usernameAttempt = \n\naction.payload;\n      if (usernameAttempt) {\n        // reinitiate sequence, login failed, retry\n\nreturn new UserActions.LoginAction({\n          msg: this._loginPromptMsg,\n          usernameAttempt\n\n});\n      } else {\n        return new UserActions.UpdatedAction({\n          loginCanceled: true\n\n});\n      }\n    });\n\n  @Effect() logout$: Observable<Action> = this.actions$\n\n.ofType(UserActions.ActionTypes.LOGOUT)\n    .map(action => {\n      this.databaseService\n\n.removeItem(DatabaseService.KEYS.currentUser);\n      return new UserActions.UpdatedAction({\n        current: \n\nnull\n      });\n    });\n\n  private _loginPromptMsg: string;\n\n  constructor(\n    private \n\nstore: Store<any>,\n    private actions$: Actions,\n    private log: LogService,\n    private \n\ndatabaseService: DatabaseService,\n    private userService: UserService\n  ) { }\n}\n```", "```js\n.startWith(new UserActions.InitAction())\n```", "```js\nnew UserActions.UpdatedAction({ current, recentUsername })\n```", "```js\nexport function userReducer(\n  state: IUserState = userInitialState,\n  action: UserActions.Actions\n): \n\nIUserState {\n  switch (action.type) {\n    case UserActions.ActionTypes.UPDATED:\n\nreturn Object.assign({}, state, action.payload);\n    default:\n      return state;\n  }\n}\n```", "```js\n// angular\nimport { Injectable } from '@angular/core';\n\n// app\nimport { DialogService } from \n\n'./dialog.service';\n\n@Injectable()\nexport class UserService {\n\n  constructor(\n\nprivate dialogService: DialogService\n  ) { } \n\n  public promptLogin(msg: string, username: string = ''): \n\nPromise<any> {\n    return new Promise((resolve, reject) => {\n      this.dialogService.login(msg, \n\nusername, '').then((input) => {\n        if (input.result) { // result will be false when canceled\n          if \n\n(input.userName && input.userName.indexOf('@') > -1) {\n            if (input.password) {\n\n    resolve({\n                username: input.userName,\n                password: input.password\n\n  });\n            } else {\n              this.dialogService.alert('You must provide a password.')\n\n     .then(reject.bind(this, input.userName));\n            }\n          } else {\n            // reject, \n\npassing userName back to try again\n            this.dialogService.alert('You must provide a valid email \n\n   address.')\n              .then(reject.bind(this, input.userName));\n          }\n        } else {\n\n     // user chose cancel\n          reject(false);\n        }\n      });\n    });\n  }\n}\n```", "```js\nexport * from './actions';\nexport * from './effects';\nexport * from './reducers';\nexport * from \n\n'./services';\nexport * from './states';\nexport * from './core.module';\n```", "```js\n// nativescript\nimport { NativeScriptModule } from 'nativescript-angular/nativescript.module'; \nimport { \n\nNativeScriptFormsModule } from 'nativescript-angular/forms'; \nimport { NativeScriptHttpModule } from 'nativescript-\n\nangular/http'; \n\n// angular\nimport { NgModule, Optional, SkipSelf } from '@angular/core';\n\n// libs\nimport { StoreModule } from '@ngrx/store';\nimport { \n\nEffectsModule } from '@ngrx/effects';\n\n// app\nimport { UserEffects } from \n\n'./effects';\nimport { userReducer } from './reducers';\nimport { PROVIDERS } from \n\n'./services';\nimport { PROVIDERS as MIXER_PROVIDERS } from '../mixer/services';\nimport { PROVIDERS as \n\nPLAYER_PROVIDERS } from '../player/services';\n\nconst MODULES: any[] = [\n  NativeScriptModule,\n\nNativeScriptFormsModule,\n  NativeScriptHttpModule\n];\n\n@NgModule({\n  imports: [\n\n...MODULES,\n    // define core app state\n    StoreModule.forRoot({\n user: \n\nuserReducer\n }),\n    // register core effects\n\nEffectsModule.forRoot([\n      UserEffects\n    ]), \n  ],\n  providers: [\n\n...PROVIDERS,\n    ...MIXER_PROVIDERS,\n    ...PLAYER_PROVIDERS\n  ],\n  exports: [\n    ...MODULES\n  ]\n})\nexport class CoreModule {\n  constructor (@Optional() @SkipSelf() parentModule: CoreModule) \n\n{\n    if (parentModule) {\n      throw new Error(\n        'CoreModule is already loaded. Import it in the \n\nAppModule only');\n    }\n  }\n}\n```", "```js\n@Component({\n  moduleId: module.id,\n  selector: 'my-app',\n  templateUrl: 'app.component.html',\n})\nexport class AppComponent {\n\n  constructor() { // we removed AuthService (UserService) here  \n```", "```js\nimport { Injectable } from '@angular/core';\nimport { Route, CanActivate, CanLoad } from \n\n'@angular/router';\n\n// libs\nimport { Store } from '@ngrx/store';\nimport { Subscription } from 'rxjs/Subscription';\n\n// app\nimport { IUserState, \n\nUserActions } from '../modules/core';\n\n@Injectable()\nexport class AuthGuard implements \n\nCanActivate, CanLoad {\n\n  private _sub: Subscription;\n\n  constructor(private \n\nstore: Store<any>) { }\n\n  canActivate(): Promise<boolean> {\n    return new Promise\n\n((resolve, reject) => {\n      this.store.dispatch(\n new \n\nUserActions.LoginAction({ msg: 'Authenticate to record.' })\n );\n this._sub = this.store.select(s => s.user).subscribe((state: \n      IUserState) => {\n if (state.current) {\n this._reset();\n resolve\n\n(true);\n } else if (state.loginCanceled) {\n this._reset\n\n();\n resolve(false);\n }\n });\n    });\n  }\n\n  canLoad(route: Route): Promise<boolean> {\n    // reuse same \n\nlogic to activate\n    return this.canActivate();\n  }\n\n  private _reset() {\n if (this._sub) this._sub.unsubscribe();\n }\n}\n```", "```js\n...\n// libs\nimport { StoreModule } from '@ngrx/store';\n...\n\n@NgModule({\n  imports: [\n    PlayerModule,\n    SharedModule,\n\nNativeScriptRouterModule.forChild(routes),\n    StoreModule.forFeature('mixerModule', {\n mixer: {}     // TODO: add reducer when ready\n })\n  ],\n  ...\n})\nexport class MixerModule { }\n```", "```js\nimport { IComposition } from '../../shared/models';\n\nexport interface IMixerState {\n  compositions?: \n\nArray<IComposition>;\n  activeComposition?: any;\n}\n\nexport const mixerInitialState: IMixerState = \n\n{\n  compositions: []\n};\n```", "```js\nexport * from './mixer.state';\n```", "```js\nimport { ViewContainerRef } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { \n\nIMixerState } from '../states';\nimport { IComposition, CompositionModel, TrackModel } from '../../shared/models';\n\nexport namespace MixerActions {\n  const CATEGORY: string = 'Mixer';\n\n  export interface \n\nIMixerActions {\n    INIT: string;\n    ADD: string;\n    EDIT: string;\n    SAVE: string;\n    CANCEL: \n\nstring;\n    SELECT: string;\n    OPEN_RECORD: string;\n    UPDATE: string;\n    UPDATED: string;\n  }\n\n  export const ActionTypes: IMixerActions = {\n    INIT: `${CATEGORY} Init`,\n    ADD: `${CATEGORY} \n\nAdd`,\n    EDIT: `${CATEGORY} Edit`,\n    SAVE: `${CATEGORY} Save`,\n    CANCEL: `${CATEGORY} Cancel`,\n\nSELECT: `${CATEGORY} Select`,\n    OPEN_RECORD: `${CATEGORY} Open Record`,\n    UPDATE: `${CATEGORY} Update`,\n\n   UPDATED: `${CATEGORY} Updated`,\n  };\n\n  export class InitAction implements Action {\n    type = \n\nActionTypes.INIT;\n    payload = null;\n  }\n\n  export class AddAction implements Action {\n    type = \n\nActionTypes.ADD;\n    payload = null;\n  }\n\n  export class EditAction implements Action {\n    type = \n\nActionTypes.EDIT;\n    constructor(public payload: CompositionModel) { }\n  }\n\n  export class SaveAction \n\nimplements Action {\n    type = ActionTypes.SAVE;\n    constructor(public payload?: Array<CompositionModel>) \n\n{ }\n  }\n\n  export class CancelAction implements Action {\n    type = ActionTypes.CANCEL;\n\npayload = null;\n  }\n\n  export class SelectAction implements Action {\n    type = ActionTypes.SELECT;\n    constructor(public payload: CompositionModel) { }\n  }\n\n  export class OpenRecordAction implements \n\nAction {\n    type = ActionTypes.OPEN_RECORD;\n    constructor(public payload?: { \n      vcRef: \n\nViewContainerRef, track?: TrackModel \n    }) { }\n  }\n\n  export class UpdateAction implements Action \n\n{\n    type = ActionTypes.UPDATE;\n    constructor(public payload: CompositionModel) { }\n  }\n\nexport class UpdatedAction implements Action {\n    type = ActionTypes.UPDATED;\n    constructor(public payload: \n\nIMixerState) { }\n  }\n\n  export type Actions =\n    InitAction\n    | AddAction\n    | \n\nEditAction\n    | SaveAction\n    | CancelAction\n    | SelectAction\n    | OpenRecordAction\n    | \n\nUpdateAction\n    | UpdatedAction;\n}\n```", "```js\nimport { IMixerState, mixerInitialState } from '../states';\nimport { MixerActions } from '../actions';\n\nexport function mixerReducer(\n  state: IMixerState = mixerInitialState,\n  action: MixerActions.Actions\n): \n\nIMixerState {\n  switch (action.type) {\n    case MixerActions.ActionTypes.UPDATED:\n      return \n\nObject.assign({}, state, action.payload);\n    default:\n      return state;\n  }\n}\n```", "```js\n// angular\nimport { Injectable, ViewContainerRef } from '@angular/core';\n\n// nativescript\nimport { RouterExtensions } from 'nativescript-angular/router';\n\n// libs\nimport { Store, Action } from \n\n'@ngrx/store';\nimport { Effect, Actions } from '@ngrx/effects';\nimport { Observable } from \n\n'rxjs/Observable';\n\n// module\nimport { CompositionModel } from '../../shared/models';\nimport { \n\nPlayerActions } from '../../player/actions';\nimport { RecordComponent } from \n\n'../../recorder/components/record.component';\nimport { MixerService } from '../services/mixer.service';\nimport { \n\nMixerActions } from '../actions';\n\n@Injectable()\nexport class MixerEffects {\n\n  @Effect() \n\ninit$: Observable<Action> = this.actions$\n    .ofType(MixerActions.ActionTypes.INIT)\n    .startWith(new \n\nMixerActions.InitAction())\n    .map(action =>\n      new MixerActions.UpdatedAction({\n\ncompositions: this.mixerService.hydrate(\n          this.mixerService.savedCompositions()\n          || \n\nthis.mixerService.demoComposition())\n      })\n    );\n\n  @Effect() add$: Observable<Action> = \n\nthis.actions$\n    .ofType(MixerActions.ActionTypes.ADD)\n    .withLatestFrom(this.store)\n    .switchMap\n\n(([action, state]) =>\n      Observable.fromPromise(this.mixerService.add())\n        .map(value => {\n\n       if (value.result) {\n            let compositions = [...state.mixerModule.mixer.compositions];\n\nlet composition = new CompositionModel({\n              id: compositions.length + 1,\n              name: \n\nvalue.text,\n              order: compositions.length // next one in line\n            });\n\ncompositions.push(composition);\n            // persist changes\n            return new MixerActions.SaveAction\n\n(compositions);\n          } else {\n            return new MixerActions.CancelAction();\n          }\n\n   })\n    );\n\n  @Effect() edit$: Observable<Action> = this.actions$\n    .ofType\n\n(MixerActions.ActionTypes.EDIT)\n    .withLatestFrom(this.store)\n    .switchMap(([action, state]) => {\n\n  const composition = action.payload;\n      return Observable.fromPromise(this.mixerService.edit(composition.name))\n        .map(value => {\n          if (value.result) {\n            let compositions = \n\n[...state.mixerModule.mixer.compositions];\n            for (let i = 0; i < compositions.length; i++) {\n\n      if (compositions[i].id === composition.id) {\n                compositions[i].name = value.text;\n\n    break;\n              }\n            }\n            // persist changes\n            return new \n\nMixerActions.SaveAction(compositions);\n          } else {\n            return new MixerActions.CancelAction();\n          }\n        })\n      });\n\n  @Effect() update$: Observable<Action> = this.actions\n\n$\n    .ofType(MixerActions.ActionTypes.UPDATE)\n    .withLatestFrom(this.store)\n    .map(([action, state]) \n\n=> {\n      let compositions = [...state.mixerModule.mixer.compositions];\n      const composition = \n\naction.payload;\n      for (let i = 0; i < compositions.length; i++) {\n        if (compositions[i].id === \n\ncomposition.id) {\n          compositions[i] = composition;\n          break;\n        }\n      }\n\n // persist changes\n      return new MixerActions.SaveAction(compositions);\n    });\n\n  @Effect() \n\nselect$: Observable<Action> = this.actions$\n    .ofType(MixerActions.ActionTypes.SELECT)\n    .map(action \n\n=> {\n      this.router.navigate(['/mixer', action.payload.id]);\n      return new MixerActions.UpdatedAction\n\n({\n        activeComposition: action.payload\n      });\n    });\n\n  @Effect({ dispatch: false }) \n\nopenRecord$: Observable<Action> = this.actions$\n    .ofType(MixerActions.ActionTypes.OPEN_RECORD)\n\n.withLatestFrom(this.store)\n    // always pause/reset playback before handling\n    .do(action => new \n\nPlayerActions.PauseAction(0))\n    .map(([action, state]) => {\n      if \n\n(state.mixerModule.mixer.activeComposition &&\n        state.mixerModule.mixer.activeComposition.tracks.length) \n\n{\n        // show record modal but check authentication\n        if (state.user.current) {\n          if \n\n(action.payload.track) {\n            // rerecording\n            this.dialogService\n              .confirm\n\n(\n                'Are you sure you want to re-record this track?'\n              ).then((ok) => {\n\n        if (ok) \n                  this._showRecordModal(\n                    action.payload.vcRef, \n\n            action.payload.track\n                  );\n              });\n          } else {\n\nthis._showRecordModal(action.payload.vcRef);\n          }\n        } else {\n          this.store.dispatch(\n            new UserActions.LoginToRecordAction(action.payload));\n        }\n      } else {\n        // \n\nnavigate to it\n        this.router.navigate(['/record']);\n      }\n      return action;\n    });\n\n  @Effect() save$: Observable<Action> = this.actions$\n    .ofType(MixerActions.ActionTypes.SAVE)\n\n.withLatestFrom(this.store)\n    .map(([action, state]) => {\n      const compositions = action.payload || \n                           state.mixerModule.mixer.compositions;\n      // persist\n      this.mixerService.save\n\n(compositions);\n      return new MixerActions.UpdatedAction({ compositions });\n    });\n\n  constructor\n\n(\n    private store: Store<any>,\n    private actions$: Actions,\n    private router: \n\nRouterExtensions,\n    private dialogService: DialogService,\n    private mixerService: MixerService\n  ) { }\n\n  private _showRecordModal(vcRef: ViewContainerRef, track?: TrackModel) {\n    let context: any = { \n\nisModal: true };\n    if (track) {\n      // re-recording track\n      context.track = track;\n    }\n\n  this.dialogService.openModal(\n      RecordComponent,\n      vcRef,\n      context,\n\n'./modules/recorder/recorder.module#RecorderModule'\n    );\n  }\n}\n```", "```js\n.do(action => new PlayerActions.PauseAction(0))\n```", "```js\n...\n@Injectable()\nexport class MixerService {\n  ...\n  public add() {\n    return \n\nthis.dialogService.prompt('Composition name:');\n  }\n\n  public edit(name: string) {\n\nreturn this.dialogService.prompt('Edit name:', name);\n  }\n  ...\n```", "```js\n...\n// libs\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from \n\n'@ngrx/effects';\n...\nimport { MixerEffects } from './effects';\nimport \n\n{ mixerReducer } from './reducers';\n\n@NgModule({\n  imports: [\n    PlayerModule,\n\nSharedModule,\n    NativeScriptRouterModule.forChild(routes),\n    // mixer state\n    StoreModule.forFeature\n\n('mixerModule', {\n      mixer: mixerReducer\n    }),\n    // mixer effects\n\nEffectsModule.forFeature([\n      MixerEffects\n    ])\n  ],\n  ...\n})\nexport \n\nclass MixerModule { }\n```", "```js\n...\nexport class MixerComponent implements OnInit, OnDestroy {\n  ...\n  constructor( private store: Store<any>,\n    private vcRef: ViewContainerRef  ) { }\n\n  ngOnInit() \n\n{\n    this._sub = this.store.select(s => s.mixerModule.mixer)\n .subscribe\n\n((state: IMixerState) => {\n this.composition = state.activeComposition;\n });\n  }\n\n  public record(track?: TrackModel) {\n\nthis.store.dispatch(new MixerActions.OpenRecordAction({\n vcRef: this.vcRef,\n track\n }));\n  }\n\n  ngOnDestroy() {\n this._sub.unsubscribe();\n }\n}\n```", "```js\n// angular\nimport { Component } from '@angular/core';\n\n// libs\nimport { Store } from \n\n'@ngrx/store';\nimport { Observable } from 'rxjs/Observable';\n\n// app\nimport { MixerActions } from '../actions';\nimport { IMixerState } from '../states';\n\n@Component({\n  moduleId: module.id,\n  selector: 'mix-list',\n  templateUrl: 'mix-list.component.html'\n})\nexport class MixListComponent {\n  public mixer$: Observable<IMixerState>;\n\n  constructor(private store: Store<any>) {\n    this.mixer$ = store.select(s => s.mixerModule.mixer);\n  } \n\n  public add() {\n    this.store.dispatch(new MixerActions.AddAction());\n  }\n\n  public edit(composition) {\n    this.store.dispatch(new MixerActions.EditAction(composition));\n  }\n\n  public select(composition) {\n    this.store.dispatch(new MixerActions.SelectAction(composition));\n  }\n}\n```", "```js\n<ActionBar title=\"Compositions\" class=\"action-bar\">\n  <ActionItem (tap)=\"add()\" \n\nios.position=\"right\">\n    <Button text=\"New\" class=\"action-item\"></Button>\n\n</ActionItem>\n</ActionBar>\n<ListView [items]=\"(mixer$ | async)?.compositions | \n\norderBy: 'order'\" class=\"list-group\">\n  <ng-template let-composition=\"item\">\n    <GridLayout \n\nrows=\"auto\" columns=\"100,*,auto\" class=\"list-group-item\">\n      <Button text=\"Edit\" (tap)=\"edit(composition)\" \n\nrow=\"0\" col=\"0\"></Button>\n      <Label [text]=\"composition.name\" (tap)=\"select(composition)\" row=\"0\" \n\ncol=\"1\" class=\"h2\"></Label>\n      <Label [text]=\"composition.tracks.length\" row=\"0\" col=\"2\" class=\"text-\n\nright\"></Label>\n    </GridLayout>\n  </ng-template>\n</ListView>\n```"]