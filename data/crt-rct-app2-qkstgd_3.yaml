- en: Create React App and Babel
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 React App 和 Babel
- en: If you come from a background where maybe you haven't worked with JavaScript
    for a long time, or maybe you're new to JavaScript and Create React App is your
    conduit for using it, you may see a lot of syntax throughout this book and while
    exploring other people's projects and find that the code is hard to read without
    a thorough understanding of what's going on. This chapter aims to bridge that
    gap for people who are new to Babel and describe what it brings to the table with
    our Create React App project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自一个可能已经很久没有使用JavaScript的背景，或者你可能对JavaScript和Create React App是使用它的途径，你可能会在本书的各个部分以及探索他人的项目时看到很多语法，并发现没有对正在发生的事情有彻底的了解，代码很难阅读。本章旨在为那些新接触Babel的人架起桥梁，并描述它为我们的
    Create React App 项目带来了什么。
- en: The other goal of this chapter is for people who are already comfortable with
    JavaScript, but are curious about what features Babel introduces and has turned
    on by default in a Create React App project, so that you can take advantage of
    all of the quality-of-life improvements and cleaner syntax rules in your project
    and really put that finishing touch on your project. The goal is to teach you
    production-ready code so that you're able to contribute at the highest level on
    your React projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的另一个目标是针对已经熟悉JavaScript但对其引入的功能和默认在 Create React App 项目中启用的 Babel 感兴趣的人，这样你就可以在你的项目中充分利用所有的生活质量改进和更简洁的语法规则，真正为你的项目增添最后一笔。目标是教授你生产就绪的代码，以便你能够在你的
    React 项目中达到最高水平的贡献。
- en: 'As we work through this chapter, you can expect to get caught up on the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们学习本章，你可以期待掌握以下主题：
- en: Const variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量变量
- en: New arrow function syntax
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的箭头函数语法
- en: Array and object destructuring
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和对象解构
- en: Array and object spread operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和对象扩展操作符
- en: React Fragments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 片段
- en: Babel and the latest JavaScript syntax
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Babel 和最新的 JavaScript 语法
- en: 'We''ve been building up this application to act as our base and in the process
    we''ve introduced a lot of syntax that may not be the same JavaScript that you''re
    used to writing! For example, we''ve written a few functions with this sort of
    syntax:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在构建这个应用程序作为我们的基础，在这个过程中，我们引入了许多可能与你习惯编写的JavaScript不同的语法。例如，我们使用这种语法编写了一些函数：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The syntax here is not particularly tricky and you can probably figure out
    what''s going on, but maybe you don''t fully understand how all of that ends up
    as a function when all is said and done. You may be more used to writing functions
    in a similar pattern to the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的语法并不特别复杂，你可能能够弄清楚发生了什么，但也许你并不完全理解所有这些最终是如何变成一个函数的。你可能更习惯于按照以下类似模式编写函数：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or maybe something more like a function declaration without the variable, such
    as the following function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可能更类似于没有变量的函数声明，如下面的函数：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The reality is that as JavaScript progresses, there are new and more efficient
    methods of writing a large variety of different language constructs. Some offer
    helpful shortcuts, or maybe they provide a nice quality-of-life improvement for
    developers. Since Create React App runs on Node.js, we get some syntax improvements
    here and there, but generally speaking, Node integrates those new features and
    syntax into its standard library at a much slower pace.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，随着JavaScript的发展，有新的、更高效的方法来编写各种不同的语言结构。一些提供了有用的快捷方式，或者可能为开发者提供了更好的生活质量改进。由于
    Create React App 在 Node.js 上运行，我们在这里得到了一些语法改进，但一般来说，Node 以更慢的速度将新功能和语法整合到其标准库中。
- en: Over the course of this chapter, we'll dive deeper into how to write, incorporate,
    and, most importantly, *understand* modern JavaScript code in our Create React
    App projects. We'll take a look at what features are currently supported in Create
    React App and learn how to take full advantage of each and every one of them!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的进程中，我们将更深入地探讨如何在 Create React App 项目中编写、整合以及最重要的，*理解* 现代JavaScript代码。我们将查看当前在
    Create React App 中支持哪些功能，并学习如何充分利用每一个功能！
- en: What is Babel?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Babel？
- en: Babel is designed to bridge the gap between *the features JavaScript will have*
    and *the features Node.js supports right now*, and turn that resulting code into
    something that Node.js can understand. That means that even if Node chooses not
    to support something (or maybe can't support due to incompatibilities with an
    existing system) you're still covered!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Babel旨在弥合*JavaScript将拥有的功能*与*Node.js目前支持的功能*之间的差距，并将生成的代码转换为Node.js可以理解的形式。这意味着即使Node选择不支持某些功能（或者可能由于与现有系统的不兼容性而无法支持），你仍然有解决方案！
- en: Understanding the history
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解历史
- en: To understand why Babel is incorporated by default into Create React App projects,
    you need to understand a little bit of its history (similar to why it's helpful
    to understand the history of why Create React App was turned into a tool). Back
    before this handy little CLI tool, a lot of the configuration was manual, and,
    typically, these projects would be either built against vanilla Node.js or on
    browsers directly. Whatever JavaScript you wanted to do was limited to the minimum
    number of features that would be supported against either every version of Node
    that could run your code or every browser you chose to support with your application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么Babel默认集成到Create React App项目中，你需要了解一点它的历史（类似于为什么了解Create React App被转化为工具的历史是有帮助的）。在方便的CLI工具出现之前，很多配置都是手动完成的，而且，通常这些项目要么是针对vanilla
    Node.js构建的，要么是直接在浏览器上构建的。你想要做的任何JavaScript都局限于在Node.js的每个版本中支持的最小功能集，或者是在你的应用程序中选择的每个浏览器上支持的功能集。
- en: 'As a result, you ended up with basically no support for anything fun or quality
    of life either. Think of it like the following table:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你最终基本上对任何有趣或生活质量的提升都没有支持。想象一下以下表格：
- en: '| **Browser** | **Feature A** | **Feature B** | **Feature C** | **Feature D**
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **浏览器** | **功能A** | **功能B** | **功能C** | **功能D** |'
- en: '| Internet Explorer | No | Yes | No | No |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| Internet Explorer | 否 | 是 | 否 | 否 |'
- en: '| Firefox | Yes | Yes | No | Yes |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Firefox | 是 | 是 | 否 | 是 |'
- en: '| Chrome | Yes | Yes | Yes | No |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| Chrome | 是 | 是 | 是 | 否 |'
- en: '| Safari | No | Yes | Yes | Yes |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| Safari | 否 | 是 | 是 | 是 |'
- en: '| What my code can support | No | Yes | No | No |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 我的代码可以支持的功能 | 否 | 是 | 否 | 否 |'
- en: Using the previous table as an example, we get to support *Feature B* in our
    project and absolutely nothing else! There's nothing more demoralizing than knowing
    you could potentially support some insanely great feature in your programming
    language but not being able to use it because some users would have negative or
    completely broken experiences.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以之前的表格为例，我们可以在项目中支持*功能B*，而绝对不支持其他任何功能！知道你可能会支持你编程语言中一些非常棒的功能，但由于一些用户会有负面或完全糟糕的体验，却无法使用它们，这是最令人沮丧的事情。
- en: Maybe you and your company decide that you want to pare down the number of browsers
    you officially support so that you can get some of these new features. Now you
    need to make a decision about sacrificing your user base and alienating old and
    new users so that you can use newer language features. Maybe it makes for a better
    experience for your other users and that ends up being worth the cost, but then
    those decisions need to be made carefully and against what percentage of your
    users is using what. For example, if you decided you'd only support Safari, you'd
    alienate every single Windows user, not just every single Internet Explorer user.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你和你的公司决定想要减少官方支持的浏览器数量，以便可以使用这些新功能。现在你需要做出决定，牺牲你的用户群，疏远新旧用户，以便使用更新的语言功能。也许这会给其他用户带来更好的体验，最终证明这是值得的，但那些决定需要谨慎做出，并考虑有多少用户在使用什么。例如，如果你决定只支持Safari，你将疏远每一个Windows用户，而不仅仅是每一个Internet
    Explorer用户。
- en: These decisions are heavy and have longstanding impacts to the health of your
    application. Alienating a user base at the start of your project's life could
    mean that it never recovers from that in the first place!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些决定很重大，对应用程序的健康状况有长期影响。在项目生命周期的开始就疏远用户群可能意味着它根本无法恢复！
- en: Where does Babel fit into the puzzle?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Babel在这个谜题中扮演什么角色？
- en: Babel comes to the rescue here by saying, *Hey, we'll give you those language
    f**eatures you want to use, but that not enough browsers support*. This becomes
    a massive relief as you start to use a larger and larger code base and run around
    some of the worst ways you used to have to architect larger JavaScript applications!
    Now if you want to use imports and new syntax and anything else, you can just
    do so!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Babel在这里伸出援手，说：“嘿，我们会给你那些你想要使用的语言特性，但不是所有浏览器都支持。”当你开始使用越来越大的代码库，并绕过一些你过去必须用来构建大型JavaScript应用程序的糟糕方式时，这会带来巨大的安慰！现在，如果你想使用导入、新语法以及其他任何东西，你都可以这样做！
- en: Babel acts as a **transpiler**, which is a very fancy way of saying that it
    takes your JavaScript code that everything may not be able to be understood and
    turns it into JavaScript code that will be able to be understood! Babel will,
    based on different configurations, settings, and something called **stages**,
    allow you to opt in to all kinds of new syntax and language features and ensure
    that your code will run on most modern browsers! Granted, nothing is ever bulletproof
    and you will, of course, find different scenarios that aren't supported by some
    particular browser. You can't win them all, unfortunately!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Babel作为一个**转换器**，这是一个非常华丽的说法，意思是它将你的JavaScript代码（可能不是所有内容都能被理解）转换成可以被理解的JavaScript代码！根据不同的配置、设置和所谓的**阶段**，Babel将允许你选择使用各种新的语法和语言特性，并确保你的代码能在大多数现代浏览器上运行！当然，没有任何东西是万无一失的，你当然会发现一些特定浏览器不支持的场景。不幸的是，你不可能赢得所有比赛！
- en: Exploring modern JavaScript with Babel
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Babel探索现代JavaScript
- en: Over the course of this section, we're going to explore the different modern
    JavaScript tricks and techniques that Babel allows us to use as a major part of
    our code. We'll take a look at the different ways that we can implement all kinds
    of different code and patterns, exploring the differences between the JavaScript
    standard ways to do certain tricks and the shorthand syntax that Babel will allow
    us to use. The first, especially if you haven't written any modern JavaScript
    in a long time, is the addition of different variable declarations, such as `const`
    and `let`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Babel允许我们作为代码主要部分的现代JavaScript技巧和技术。我们将查看我们可以实现各种不同代码和模式的不同方式，探讨JavaScript标准方式执行某些技巧与Babel允许我们使用的简写语法之间的差异。首先是变量声明的添加，特别是如果你很久没有编写现代JavaScript的话，比如`const`和`let`。
- en: The `let` variable allows us to declare a variable with very specific scoping
    rules. While `var` is scoped to the nearest function block and gets used as a
    result of that, `let` is instead scoped to the nearest block in general, and can't
    be used before it's declared. You also can't redeclare variables with the same
    name with `let`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`变量允许我们声明一个具有非常具体作用域规则的变量。虽然`var`的作用域是最近的函数块，并因此被使用，但`let`的作用域是最近的块，并且在其声明之前不能使用。你也不能用`let`重新声明具有相同名称的变量。'
- en: The `const` variable allows us to declare a constant with the same scoping rules
    as `let`, overall. The best practice is to use both of these far more than using
    `var`. In fact, I personally never use `var` if I'm working with code that I know
    supports const and let instead.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`变量允许我们声明一个具有与`let`相同作用域规则的常量。总的来说，最佳实践是尽可能多地使用这两个变量，而不是使用`var`。事实上，如果我知道我正在处理的代码支持`const`和`let`，我个人从来不会使用`var`。'
- en: 'Now, let''s move on to the first more complex thing we''ve run into as part
    of our application code: JSX!'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到我们作为应用程序代码遇到的第一件更复杂的事情：JSX！
- en: JSX
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX
- en: Let's look at a very simple example of JSX code; something very similar to the
    code we've already written. It's easier for us to start off simple and build it
    up a little bit so you can see how JSX actually helps us write our code a little
    faster and smarter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常简单的JSX代码示例；与我们已经编写过的代码非常相似。我们最好从简单开始，逐步构建，这样你就可以看到JSX实际上是如何帮助我们更快、更智能地编写代码的。
- en: 'First off, this is just a simple `HelloWorld div` in React:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是一个简单的React中的`HelloWorld div`：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Like I said, nothing particularly fancy or difficult yet. Let''s take a look
    at the plain JavaScript version of this instead:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，目前还没有什么特别复杂或困难的东西。让我们来看看这个的纯JavaScript版本：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It does the same thing at the end of the day: it creates an `HelloWorld` React
    component, and then that component itself contains a single `div` with an `HelloWorld`
    body as the text. Where this starts to get more complicated is when you have to
    start including child components as well. Using our previous an `HelloWorld` component,
    let''s expand it and make the person we''re greeting configurable:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最终它做的都是同样的事情：它创建了一个 `HelloWorld` React 组件，然后该组件本身包含一个带有 `HelloWorld` 主体文本的单个
    `div`。当您必须开始包括子组件时，事情开始变得复杂。使用我们之前的 `HelloWorld` 组件，让我们扩展它，并使我们要问候的人可配置：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The analog in regular JavaScript would be the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规 JavaScript 中的类似操作如下：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s open up our project and experiment with changing some of the syntax
    in our existing project to use the non-JSX method of creating React components
    and elements. Our goal is that we should get to a point where we''ve added a little
    divider in between each of the `Todo` items in our `TodoList` component. We shouldn''t
    have to modify too much to make this work, but we''re going to use the non-JSX
    method to build out the `Divider` component. We''ll start off by creating `src/Divider.js`
    and `src/Divider.css`, and then we''ll start off by writing `src/Divider.js` first:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们的项目，并尝试改变现有项目中的一些语法，以使用创建 React 组件和元素的非 JSX 方法。我们的目标是，我们应该达到在 `TodoList`
    组件中的每个 `Todo` 项目之间添加一个小分隔符的程度。我们不需要做太多修改就能使它工作，但我们将使用非 JSX 方法来构建 `Divider` 组件。我们将从创建
    `src/Divider.js` 和 `src/Divider.css` 开始，然后首先编写 `src/Divider.js`：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There''s not a whole lot extra that we''re doing here; we''re creating a `div` container
    with a class of `Divider` (you can see here why `class` isn''t available for you
    to use in React JSX; it would not make sense, since `class` is what we use to
    declare classes, such as for our class-based stateful components). In our function,
    which doesn''t take in any additional properties, we return the results of the
    `React.createElement()` function. `React.createElement()` takes three arguments
    to its call: the main element we''re creating (either an HTML tag, such as `div`
    or `hr`, or the fully-qualified name of the function or variable, such as `Todo`),
    followed by an object with the properties that you''re passing on to this element,
    and finally the array of children that should live inside that component.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们并没有做太多额外的事情；我们创建了一个具有 `Divider` 类的 `div` 容器（你从这里可以看到为什么 `class` 在 React
    JSX 中不可用；这没有意义，因为 `class` 是我们用来声明类（如我们的基于类的有状态组件）的）。在我们的函数中，它不接受任何额外的属性，我们返回 `React.createElement()`
    函数的结果。`React.createElement()` 调用有三个参数：我们正在创建的主要元素（可以是 HTML 标签，如 `div` 或 `hr`，或者函数或变量的完全限定名称，如
    `Todo`），然后是一个对象，包含传递给该元素的属性，最后是应该存在于该组件内部的子元素数组。
- en: 'Next, we''ll populate our `src/Divider.css` with some fancy CSS to make our
    `hr` into nice gradient-based dividing lines:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将用一些花哨的 CSS 来填充我们的 `src/Divider.css`，使我们的 `hr` 变成基于渐变的分隔线：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, go into `src/TodoList.js`, where we''ll `import` our new `Divider` and
    modify a little bit of code to include the new divider. First, we''ll start off
    with `import` at the top:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入 `src/TodoList.js`，我们将 `import` 我们的新 `Divider` 并修改一些代码以包含新的分隔符。首先，我们从顶部开始
    `import`：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we''ll actually place the `Divider` inside of the code. We''ll need to
    go down to the `renderItems()` function and change the body to wrap `Todo` inside
    of a `div` container (we can get around this by using React Fragments, but we''ll
    talk about this more a little bit later), and then include the `Divider` component
    at the bottom of that. Also, note that for each of the key properties in the following
    JSX code, we''re prefixing the "description" with a little description of the
    component we''re building to avoid collisions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将实际上将 `Divider` 放置在代码中。我们需要进入 `renderItems()` 函数，并将主体改为将 `Todo` 包裹在一个 `div`
    容器中（我们可以通过使用 React Fragments 来解决这个问题，但我们会稍后再详细讨论），然后在底部包含 `Divider` 组件。此外，请注意，在下面的
    JSX 代码中的每个关键属性中，我们都在 "description" 前缀加上我们正在构建的组件的简要描述，以避免冲突：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save and reload, and we should have some new dividers breaking up our `Todo`
    items:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并重新加载，我们应该有一些新的分隔线来分隔我们的 `Todo` 项目：
- en: '![](img/55cd75f0-c009-40d2-b326-cabdd15d0f89.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55cd75f0-c009-40d2-b326-cabdd15d0f89.png)'
- en: And there we are, a new `Divider` written entirely in vanilla JavaScript!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就有了，一个完全用纯 JavaScript 编写的 `Divider`！
- en: The next code snippet is just provided as an example of what a full, more complicated
    function would look like written without any JSX. You don't actually need to do
    any of this work!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段只是作为一个示例，展示一个完整的、更复杂的函数在没有 JSX 的情况下会是什么样子。你实际上不需要做任何这项工作！
- en: 'Just for fun, let''s take a look at what our two `render()` function calls
    in `TodoList` would look like without JSX:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，让我们看看在 `TodoList` 中的两个 `render()` 函数调用在没有 JSX 的情况下会是什么样子：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Everything will still function exactly the same, so if this was something you
    wanted to pursue and you preferred this syntax to JSX, that remains an option
    for you.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的功能都将保持完全相同，所以如果你想要追求这个，并且你更喜欢这种语法而不是 JSX，这仍然是你的一种选择。
- en: Function syntax
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数语法
- en: Let's also spend a little bit of time talking about the different ways to write
    functions that we can take advantage of when using Babel paired with Create React
    App. In the code we wrote previously, we already talked a bit about this and showed
    a few examples of alternate function syntax, but we're going to dive more deeply
    into everything now.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也花一点时间来谈谈在使用 Babel 和 Create React App 配对时可以利用的不同方式来编写函数。在我们之前写的代码中，我们已经对此进行了一些讨论，并展示了几个替代函数语法的示例，但现在我们将更深入地探讨所有这些内容。
- en: 'Ultimately, there are a few standard ways in JavaScript, without any frills,
    to declare a function. We can either choose the method of declaring a function
    with the `function` keyword, or we could declare it as a variable. Let''s look
    at a few examples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在 JavaScript 中，有一些标准的方式来声明函数，没有任何花哨的东西。我们可以选择使用 `function` 关键字声明函数的方法，或者将其声明为一个变量。让我们看看一些例子：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We could also write this, without using any frills from Babel, via the following
    code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样写，不使用 Babel 的任何花哨功能，通过以下代码：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And the way that we''d invoke that function after having built it is just simply
    via the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建函数之后，我们调用该函数的方式只是简单地通过以下方式：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So now, think back to some of the other functions that we''ve written over
    the previous two chapters. We''ve frequently defined functions using a `const`
    statement, which would turn the `function` we''ve written previously into the
    following instead:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回想一下我们在前两章中编写的一些其他函数。我们经常使用 `const` 语句来定义函数，这会把我们之前写的 `function` 转换成以下形式：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While this is practically identical to the variable method of declaring functions
    in old JavaScript, there's a minor difference in terms of the syntax that's worth
    pointing out, and that's in the way that the function signature is declared in
    the code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这实际上与旧 JavaScript 中声明函数的变量方法非常相似，但在语法上有细微的差别，这是值得指出的，那就是在代码中声明函数签名的方式。
- en: Previously, after our variable declaration, we'd write the function and then
    parentheses with the arguments in it. In modern JavaScript, we can use something
    called **arrow functions**. Arrow functions are a shorthand syntax shortcut with
    an extra benefit in terms of how `this` gets bound. Specifically, the context
    of `this` when the function is declared is the context of `this` when the function
    is declared. Instead of the function taking and defining its own context for `this`,
    it instead uses `this` in the current scope.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前，在我们的变量声明之后，我们会写一个函数，然后是带有参数的括号。在现代 JavaScript 中，我们可以使用一种叫做 **箭头函数** 的东西。箭头函数是一种简写语法快捷方式，在
    `this` 绑定方面有一个额外的优势。具体来说，函数声明时的 `this` 上下文是函数声明时的 `this` 上下文。而不是函数自己获取并定义自己的 `this`
    上下文，它使用当前作用域中的 `this`。
- en: 'The rules for declaring arrow functions are pretty simple:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 声明箭头函数的规则相当简单：
- en: 'If you have no arguments, you must declare the function with parentheses and
    then the fat arrow (`=>`):'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有参数，你必须使用圆括号声明函数，然后是粗箭头 (`=>`)：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you have one argument, you can optionally include the parentheses:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个参数，你可以选择性地包含圆括号：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you have two or more arguments, you must include the parentheses:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有两个或更多参数，你必须包含圆括号：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you''re returning something as a single-line function, you don''t need to
    use curly brackets or a `return` statement:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你作为单行函数返回某个东西，你不需要使用花括号或 `return` 语句：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you''re returning something as a multi-line function, you must use curly
    brackets and a `return` statement:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你作为多行函数返回某个东西，你必须使用花括号和 `return` 语句：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Destructuring
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构赋值
- en: 'Modern JavaScript also gives us better access to destructuring. Destructuring
    is a way of matching the patterns in data structures (for example, in arrays or
    objects) and being able to turn those into individual variables in function arguments
    or in variable declarations. Let''s mess around with a few different examples
    to get a good feel for how destructuring works and how we can better take advantage
    of it. Open up `src/App.js`, where we''ll use destructuring a few times. Before
    we make our change, the `App` function should look like the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现代JavaScript也给了我们更好的解构访问。解构是一种匹配数据结构（例如，在数组或对象中）的模式，并且能够将这些模式转换为函数参数或变量声明中的单个变量。让我们通过几个不同的例子来玩一玩，以更好地了解解构是如何工作的，以及我们如何更好地利用它。打开`src/App.js`，我们将多次使用解构。在我们做出更改之前，`App`函数应该看起来像以下代码：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Nothing exciting yet, so let''s make this code exciting! We''ll start off by
    allowing you to rename your app, since maybe you don''t feel that `Todoifier`
    is a great name for an app! We''ll start off by adding a simple data structure
    above our code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有什么激动人心的东西，所以让我们让这段代码变得有趣！我们首先允许你重命名你的应用，因为也许你并不觉得`Todoifier`是一个很好的应用名称！我们将在代码上方添加一个简单的数据结构：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we''ll destructure this data structure into a single variable name. We''ll
    add the following line right after we declare our `details` data structure:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将这个数据结构解构到一个单独的变量名中。我们将在声明我们的`details`数据结构之后添加以下行：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What we''re doing here is rewriting the structure of the data structure we
    created in the `details` variable and then saying that we want it to take the
    value in the `header` key of the `details` variable and ignore everything else,
    and then throw it into the `header` variable. The end result is that we should
    expect to see `Todoifier` in the `header` variable. Just to make sure, let''s
    throw a `console.log` statement and verify the results:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是重新编写我们在`details`变量中创建的数据结构的结构，然后说我们想要它取`details`变量中`header`键的值，忽略其他所有内容，然后将它抛入`header`变量中。最终结果是，我们应该在`header`变量中看到`Todoifier`。为了确保这一点，让我们抛出一个`console.log`语句来验证结果：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We should see it show up in our JavaScript console in the browser if all went
    well:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在我们的浏览器JavaScript控制台中看到它：
- en: '![](img/f2c19437-7a71-4369-983e-8c41f5fd9ba7.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2c19437-7a71-4369-983e-8c41f5fd9ba7.png)'
- en: 'There we are! Now that we know this works, let''s hop back over to the `App`
    component and add in a reference to the `header` variable:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在我们知道这可以工作，让我们回到`App`组件，并添加对`header`变量的引用：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When our page refreshes, we should see whatever value you threw in the `header`
    value in the `details` variable! Let''s make it a little cleaner and a little
    bit closer to what you''d normally expect to see in production code, because right
    now the code we''ve written is a bit redundant. Delete the reference to `appName`
    and the `console.log` statement and we''ll write a new function to use in our
    component:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的页面刷新时，我们应该看到你在`details`变量中的`header`值所抛出的任何值！让我们让它更简洁一些，更接近你通常在生产代码中期望看到的样子，因为现在我们写的代码有点冗余。删除对`appName`的引用和`console.log`语句，我们将编写一个新的函数用于我们的组件：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We're actually using a few separate tricks here! We're using the new function
    declaration syntax and simple function `return` syntax, and we're using destructuring
    to make our code super simple and clean! We destructure a passed-in argument to
    pull the `title` and `headerColor` out and store those in the title and `color`
    variables, respectively!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上在这里使用了一些单独的技巧！我们使用了新的函数声明语法和简单的函数`return`语法，我们还使用了解构来使我们的代码超级简单和整洁！我们解构传入的参数以提取`title`和`headerColor`，并将它们分别存储在`title`和`color`变量中！
- en: 'We then pass those into the `h2` tag to set the CSS `color` style and the displayed
    `title` of the application! The final step is that we need to hook up this component
    to use the new `header` function we just defined:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将这些传递给`h2`标签，以设置CSS的`color`样式和应用的显示`title`！最后一步是我们需要将这个组件连接到使用我们刚刚定义的新`header`函数：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And there we are! With this code in place, we should see a red header with
    the name Todoifier! Let''s take a look:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！有了这段代码，我们应该看到一个红色的标题，上面写着Todoifier！让我们看看：
- en: '![](img/1d9b2a48-88cd-4dc7-8500-82dcaef778fe.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d9b2a48-88cd-4dc7-8500-82dcaef778fe.png)'
- en: 'We can actually destructure arrays as well! For example, let''s say we have
    a few unique options we want to start off our list with. We can capture those
    as named variables through array-destructuring, and we can also take advantage
    of some other syntax tricks we''ll learn later, such as array spreads! Let''s
    take a look at `src/TodoList.js` and change our constructor to use array-destructuring:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们也可以解构数组！例如，假设我们有一些独特的选项想要作为列表的起始项。我们可以通过数组解构捕获这些选项，我们还可以利用我们稍后将要学习的其他一些语法技巧，比如数组展开！让我们看看`src/TodoList.js`，并更改我们的构造函数以使用数组解构：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Array-destructuring is just based on position; the only new trick here is that
    after matching `item1` and `item2`, we''re just going to throw the remainder of
    the array onto a variable called `rest`, which we''ll join with some spaces and
    the word `"and"`. Let''s see the result:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 数组解构仅基于位置；这里唯一的技巧是在匹配`item1`和`item2`之后，我们将把数组的其余部分扔到一个叫做`rest`的变量中，我们将用一些空格和单词`"and"`将其连接起来。让我们看看结果：
- en: '![](img/995f2163-34f3-4bbf-959f-5577a3b0cbeb.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/995f2163-34f3-4bbf-959f-5577a3b0cbeb.png)'
- en: Optional arguments
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选参数
- en: 'Setting optional arguments for functions is thankfully a pretty simple endeavor!
    If you want to make a `function` argument optional, all you need to do is add
    an equals sign after the name of the parameter and give it a default value. For
    example, let''s revisit the `sayHello` function we wrote a little bit earlier
    in this chapter:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为函数设置可选参数是一个相对简单的任务！如果你想使一个`function`参数可选，你只需要在参数名称后添加一个等号，并给它一个默认值。例如，让我们回顾一下本章稍早前我们编写的`sayHello`函数：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s modify that so that if someone doesn''t specify a `name`, the function
    call will not just fail out or throw an error for the developer:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改一下，如果有人没有指定`name`，函数调用将不会失败或抛出错误：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that since we''re using an optional variable for the argument list, we
    need to enclose it in parentheses again! Now, if someone were to call that function
    without specifying any parameters, we''d expect to see in our console Hello Unknown!,
    something similar to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们正在使用可选变量作为参数列表，我们需要再次将其括在括号中！现在，如果有人调用该函数而不指定任何参数，我们预计在控制台看到的是Hello Unknown!，类似于以下内容：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With that, let''s write this into our previous `headerDisplay` function. It
    will be a little messy, sure, but it''s great to know how to use this effectively,
    since it''s a great way to implement defensive programming in your projects:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 既然如此，让我们将其写入我们之前的`headerDisplay`函数中。这确实会有些杂乱，但了解如何有效地使用它是非常好的，因为这是一种在项目中实现防御性编程的绝佳方式：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, if we were to go back and change our App component''s call to the `header()`
    function to just pass in a blank object, we would expect the header to instead
    say `TodoList` with a blue header:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们回到并更改我们的`App`组件对`header()`函数的调用，只传递一个空对象，我们预计标题将改为显示`TodoList`，带有蓝色的标题：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s see the results before we revert the change to our `header` function
    and change it back into passing in the `details` variable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将更改回`header`函数并改回传递`details`变量之前，让我们看看结果：
- en: '![](img/5e050b12-bb6d-4ef8-bc80-7edeb79ac47d.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e050b12-bb6d-4ef8-bc80-7edeb79ac47d.png)'
- en: The spread operator
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开运算符
- en: 'Remember a little bit earlier in the chapter, when we wrote an ellipse and
    then a variable name? Any time you do that, you''re telling JavaScript to stuff
    the rest of the unmatched stuff into here and join it to the current data structure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在章节开头一点，当我们写了一个省略号然后一个变量名的时候吗？每次你这样做，你都是在告诉 JavaScript 将未匹配的其余部分放入这里，并将其与当前的数据结构连接起来：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This line of code tells JavaScript that the item in the first spot goes into
    the `item1` variable, the item in the second spot goes into the `item2` variable,
    and then everything else after that goes into the `rest` variable. We can take
    advantage of this as well when we want to add items onto an array in a non-destructive
    way. Remember the `addTodo()` function that lives in `src/TodoList.js`? Let''s
    take a look at that in greater detail to see how we can use array spreads elsewhere:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码告诉 JavaScript，第一个位置的项目进入`item1`变量，第二个位置的项目进入`item2`变量，然后所有其他的项目都进入`rest`变量。当我们想要以非破坏性的方式向数组中添加项目时，我们也可以利用这一点。还记得位于`src/TodoList.js`中的`addTodo()`函数吗？让我们更详细地看看，看看我们如何在其他地方使用数组展开：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This line of code is telling JavaScript to set the `items` key in the component''s
    `state` to be equal to the current value of `this.state.items`, and then concatenate
    `item` onto the end of that list. The code is identical to this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码告诉 JavaScript 将组件的 `state` 中的 `items` 键设置为当前 `this.state.items` 的值，然后将 `item`
    添加到该列表的末尾。代码与以下内容相同：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can also do this with objects in JavaScript code with Babel''s most recent
    update in Create React App, which is great for `state` modification, since `state`
    modification is just changing objects around! Let''s head back to `src/App.js`
    and write a sample bit of code that also sets a background color for our `header`.
    We''ll start off with our object spread and set a new variable called `moreDetails`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 Babel 在 Create React App 中的最新更新在 JavaScript 代码中这样做，这对于 `state` 修改来说非常好，因为
    `state` 修改只是改变对象！让我们回到 `src/App.js` 并编写一段示例代码，这段代码也会为我们的 `header` 设置背景颜色。我们将从对象展开开始，并设置一个新的变量
    `moreDetails`：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We''re just taking the `details` data structure, and then on top of that, we''re
    either adding new keys or replacing values for existing keys. Next, we''ll need
    to modify the `headerDisplay` function to be able to work with a background color
    being passed in:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是获取 `details` 数据结构，然后在上面添加新的键或替换现有键的值。接下来，我们需要修改 `headerDisplay` 函数，使其能够处理传入的背景颜色：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The final step of this is to change the call in the `App` component to pass
    in `moreDetails` to the `header` instead of `details` or a blank object:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的最后一步是将 `App` 组件中的调用改为传递 `moreDetails` 到 `header` 而不是 `details` 或一个空对象：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After you save and reload, you should see the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并重新加载后，你应该会看到以下内容：
- en: '![](img/bb93503b-6a75-414b-8867-e91cb332aab0.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb93503b-6a75-414b-8867-e91cb332aab0.png)'
- en: 'The line of code for the `Object` spread is the equivalent of us writing the
    following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object` 展开的代码行相当于我们编写以下内容：'
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It's just a little more concise and easier to read, so it's great that the Create
    React App team and the Babel team made this supported in the most recent version!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是稍微简洁一些，更容易阅读，所以非常感谢 Create React App 团队和 Babel 团队在最新版本中支持这一点！
- en: React Fragments
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Fragments
- en: The final thing we're going to talk about in this chapter is the new support
    for React Fragments! React Fragments are a brand-new, but important, feature.
    Previously, if you wanted to include multiple components at the same level, you
    *always* had to have a root component, even for things such as multiple table
    rows, which never really made sense; you'd have to nest `<td>` tags inside of
    `<div>`, which is just weird.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的最后一件事是 React Fragments 的新支持！React Fragments 是一个全新的但重要的特性。之前，如果你想在同一级别包含多个组件，你
    *总是* 必须有一个根组件，即使对于像多行表这样的东西，这实际上也没有太多意义；你必须在 `<div>` 内部嵌套 `<td>` 标签，这看起来很奇怪。
- en: 'It ends up with you having to choose between writing what''s technically invalid
    HTML or writing compliant React code, which tends to just end up as awkward or
    bad code to get around the limitation. Now, instead, we can write code encased
    in special Fragment tags (`<Fragment>` and `</Fragment>`) to denote the start
    and end of a fragment, respectively. We can reference these as `<React.Fragment>`,
    `<Fragment>` (if we choose to `import Fragment` where we `import Component`, such
    as in the following line of code), or as `<>` for a shortcut:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是你不得不在技术上无效的 HTML 和符合 React 代码之间做出选择，这往往只是为了绕过限制而编写尴尬或糟糕的代码。现在，相反，我们可以编写包含特殊
    Fragment 标签（`<Fragment>` 和 `</Fragment>》）的代码，分别表示片段的开始和结束。我们可以将这些引用为 `<React.Fragment>`、`<Fragment>`（如果我们选择在
    `import Component` 的地方 `import Fragment`，例如在以下代码行中），或者作为 `<>` 的快捷方式：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A quick warning about using the shortcut syntax of `<>` and `</>`: if you''re
    using Fragments inside of code that''s building a list of Fragments, you can''t
    use the shortcut syntax and still specify a `key` property; you will have to use
    either `React.Fragment` or `Fragment`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 `<>` 和 `</>` 简写语法的快速警告：如果你在构建片段列表的代码中使用片段，你不能使用简写语法并指定 `key` 属性；你将不得不使用
    `React.Fragment` 或 `Fragment`。
- en: 'If we go back to `src/TodoList.js`, in our `renderItems()` function, we can
    see the perfect place to replace an extraneous `<div>` with a `Fragment` instead:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到 `src/TodoList.js`，在我们的 `renderItems()` 函数中，我们可以看到将多余的 `<div>` 替换为 `Fragment`
    的完美位置：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At the top of the function, where we `import Component` as a named `import`
    from `React`, we'll also need to include `Fragment`, similar to the line of code
    a little bit higher up in this section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数顶部，我们通过`import Component`作为从`React`的命名`import`导入组件，我们还需要包含`Fragment`，类似于本节稍高一点的代码行。
- en: The end result is otherwise identical; the major difference is that instead
    of placing each of the Todos and Dividers inside of extra `div` for no reason,
    they can all sit next to each other in the DOM tree and keep your code significantly
    cleaner, especially in the case of working with HTML tables, where introducing
    an extra `div` will actually just break your code!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果在其他方面是相同的；主要区别在于，我们不再无理由地将每个Todos和Dividers放在额外的`div`中，它们都可以并排坐在DOM树中，让你的代码更加整洁，尤其是在处理HTML表格时，引入额外的`div`实际上只会破坏你的代码！
- en: A quick recap
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速回顾
- en: 'Before we end this chapter, let''s look at the final state of all of the code
    that we''ve written. Our `src/TodoList.js` has expanded and includes a lot of
    new tricks:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，让我们看看我们所编写代码的最终状态。我们的`src/TodoList.js`已经扩展，并包含了很多新技巧：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Our `src/App.js` component has expanded significantly as well:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`src/App.js`组件也显著扩展了：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot, but were pretty productive! We talked a lot about how to take
    full advantage of the better and cleaner syntax that Babel offers us in a Create
    React App 2 project!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们覆盖了很多内容，但非常高效！我们讨论了很多如何在Create React App 2项目中充分利用Babel提供的更好、更干净的语法！
- en: Even this is really just scratching the surface of what you can do in modern
    JavaScript, but it covers a lot of the common patterns and tricks that you'll
    see throughout this book. We hope this guide will give you everything you need
    to be able to execute projects and to understand and contribute at the highest
    levels!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这样，这也只是触及了现代JavaScript所能做到的一小部分，但它涵盖了你在整本书中都会看到的许多常见模式和技巧。我们希望这本指南能给你提供一切所需，以便能够执行项目，并在最高水平上理解和贡献！
- en: We'll be exploring a lot of these code techniques in future chapters, so make
    sure you have a firm grasp of everything we discussed in this chapter before you
    forge ahead!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在未来的章节中探索很多这些代码技巧，所以请确保在你继续前进之前，你已经牢固掌握了本章中我们讨论的所有内容！
