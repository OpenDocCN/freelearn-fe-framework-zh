<html><head></head><body>
  <div id="_idContainer023" class="Basic-Text-Frame">
    <h1 class="chapterNumber">1</h1>
    <h1 id="_idParaDest-16" class="chapterTitle">Why React?</h1>
    <p class="normal">If you’re reading this book, you probably are already familiar<a id="_idIndexMarker000"/> with <strong class="keyWord">React</strong>. But if you’re not, don’t worry. I’ll do my best to keep philosophical definitions to a minimum. However, this is a long book with a lot of content, so I feel that setting the tone is an appropriate first step. Our goal is to learn <a id="_idIndexMarker001"/>React and <strong class="keyWord">React Native</strong>, but it’s also to build a scalable and adaptive architecture that can handle everything we want to build with React today and in the future. In other words, we want to create a foundation around React, with a set of additional tools and approaches that can withstand the test of time. This book will guide you through the process of using tools like routing, TypeScript typing, testing, and many more.</p>
    <p class="normal">This chapter starts with a brief explanation of why React exists. Then, we’ll think about the simplicity of React and how it is able to handle many of the typical performance issues faced by web developers. Next, we’ll go over the declarative philosophy of React and the level of abstraction that React programmers can expect to work with. Then, we’ll touch on some of the major features of React. And finally, we will explore how we can set up a project to start to work with React.</p>
    <p class="normal">Once you have a conceptual understanding of React and how it solves problems with UI development, you’ll be better equipped to tackle the remainder of the book. This chapter will cover the following topics:</p>
    <ul>
      <li class="bulletList">What is React?</li>
      <li class="bulletList">What’s new in React?</li>
      <li class="bulletList">Setting up a new React project </li>
    </ul>
    <h1 id="_idParaDest-17" class="heading-1">What is React?</h1>
    <p class="normal">I think the one-line <a id="_idIndexMarker002"/>description of React on its home page (<a href="https://react.dev/"><span class="url">https://react.dev/</span></a>) is concise and accurate:</p>
    <blockquote class="packt_quote">
      <p class="quote">”A JavaScript library for building user interfaces.”</p>
    </blockquote>
    <p class="normal">This is perfect because, as it turns out, this is all we want most of the time. I think the best part about this description is everything that it leaves out. It’s not a mega-framework. It’s not a full-stack solution that’s going to handle everything, from the database to real-time updates <a id="_idIndexMarker003"/>over <strong class="keyWord">WebSocket</strong> connections. We might not actually want most of these prepackaged solutions. If React isn’t a framework, then what is it exactly?</p>
    <h2 id="_idParaDest-18" class="heading-2">React is just the view layer</h2>
    <p class="normal">React is generally<a id="_idIndexMarker004"/> thought of as the <em class="italic">view layer</em> in an application. Applications are typically divided into different layers, such as the view layer, the logic layer, and the data layer. React, in this context, primarily handles the view layer, which involves rendering and updating the UI based on changes in data and application state. React components change what the user sees. The following diagram illustrates where React fits in our frontend code:</p>
    <figure class="mediaobject"><img src="../Images/B19636_01_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 1.1: The layers of a React application</p>
    <p class="normal">This is all there is to React – the core concept. Of course, there will be subtle variations to this theme as we make our way through the book, but the flow is more or less the same:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><strong class="keyWord">Application logic</strong>: Start with some application logic that generates data.</li>
      <li class="numberedList"><strong class="keyWord">Rendering data to the UI</strong>: The next step is to render this data to the UI.</li>
      <li class="numberedList"><strong class="keyWord">React component</strong>: To accomplish this, you pass the data to a React component.</li>
      <li class="numberedList"><strong class="keyWord">Component’s role</strong>: The React component takes on the responsibility of getting the HTML onto the page.</li>
    </ol>
    <p class="normal">You may wonder <a id="_idIndexMarker005"/>what the big deal is; React appears to be yet another rendering technology. We’ll touch on some of the key areas where React can simplify application development in the remaining sections of the chapter.</p>
    <h2 id="_idParaDest-19" class="heading-2">Simplicity is good</h2>
    <p class="normal">React doesn’t have<a id="_idIndexMarker006"/> many moving parts to learn about and understand. While React boasts a relatively simple API, it’s important to note that beneath the surface, React operates with a degree of complexity. Throughout this book, we will delve into these internal workings, exploring various aspects of React’s architecture and mechanisms to provide you with a comprehensive understanding. The advantage of having a small API to work with is that you can spend more time familiarizing yourself with it, experimenting with it, and so on. The opposite is true of large frameworks, where all of your time is devoted to figuring out how everything works. The following diagram gives you a rough idea of the APIs that we have to think about when programming with React:</p>
    <figure class="mediaobject"><img src="../Images/B19636_01_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 1.2: The simplicity of the React API</p>
    <p class="normal">React is divided into two major APIs:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">The React Component API</strong>: These<a id="_idIndexMarker007"/> are the parts of the page that are rendered by the <strong class="keyWord">React DOM</strong>.</li>
      <li class="bulletList"><strong class="keyWord">React DOM</strong>: This is the API that’s used to perform the rendering on a web page.</li>
    </ul>
    <p class="normal">Within a React<a id="_idIndexMarker008"/> component, we have the following areas to think about: </p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Data</strong>: This is data that <a id="_idIndexMarker009"/>comes from somewhere (the component doesn’t care where) and is rendered by the component.</li>
      <li class="bulletList"><strong class="keyWord">Lifecycle</strong>: For example, one phase of the lifecycle is when the component is about to be rendered. Within a React component, methods or hooks respond to the component’s entering and exiting phases of the React rendering process as they happen over time.</li>
      <li class="bulletList"><strong class="keyWord">Events</strong>: These are the code that we write to respond to user interactions.</li>
      <li class="bulletList"><strong class="keyWord">JSX</strong>: This is the syntax commonly used for describing UI structures in React components. Even though JSX is closely associated with React, it can also be used alongside<a id="_idIndexMarker010"/> other <strong class="keyWord">JavaScript</strong> frameworks and libraries.</li>
    </ul>
    <p class="normal">Don’t fixate on what these different areas of the React API represent just yet. The takeaway here is that React, by nature, is simple. Just look at how little there is to figure out! This means that we don’t have to spend a ton of time going through API details here. Instead, once you pick up on the basics, we can spend more time on nuanced React usage <a id="_idIndexMarker011"/>patterns that fit in nicely with declarative UI structures.</p>
    <h2 id="_idParaDest-20" class="heading-2">Declarative UI structures</h2>
    <p class="normal">React newcomers<a id="_idIndexMarker012"/> have a hard time getting to grips with the<a id="_idIndexMarker013"/> idea that components mix in markup with their JavaScript in order to declare UI structures. If you’ve looked at React examples and had the same adverse reaction, don’t worry. Initially, we can be skeptical of this approach, and I think the reason is that we’ve been conditioned for decades by the <em class="italic">separation of concerns</em> principle. This principle states that different concerns, such as logic and presentation, should be separate from one another. Now, whenever we see things combined, we automatically assume that this is bad and shouldn’t happen.</p>
    <p class="normal">The syntax used by React components is <a id="_idIndexMarker014"/>called <strong class="keyWord">JSX</strong> (short for <strong class="keyWord">JavaScript XML</strong>, also known<a id="_idIndexMarker015"/> as <strong class="keyWord">JavaScript Syntax Extension</strong>). A component renders content by returning some JSX. The JSX itself is usually HTML markup, mixed with custom tags for React components. The specifics don’t matter at this point; we’ll go into detail in the coming chapters. </p>
    <p class="normal">What’s groundbreaking about the declarative JSX approach is that we don’t have to manually perform intricate operations to change the content of a component. Instead, we describe how the UI should look in different states, and React efficiently updates the actual DOM to match. As a result, React UIs become easier and more efficient to work with, resulting in better performance.</p>
    <p class="normal">For example, think about using something such as jQuery to build your application. You have a page with some content on it, and you want to add a class to a paragraph when a button is clicked: </p>
    <pre class="programlisting code"><code class="hljs-code">$(<span class="hljs-variable">document</span>).<span class="hljs-title">ready</span>(<span class="hljs-keyword">function</span>() {
  $(<span class="hljs-string">'#my-button'</span>).<span class="hljs-title">click</span>(<span class="hljs-keyword">function</span>() {
    $(<span class="hljs-string">'#my-paragraph'</span>).<span class="hljs-title">addClass</span>(<span class="hljs-string">'highlight'</span>);
  });
});
</code></pre>
    <p class="normal">Performing these steps is easy enough. This is called imperative programming, and it’s problematic for UI development. The problem with imperative programming in UI development is that it can lead to code that is difficult to maintain and modify. This is because imperative code is often tightly coupled, meaning that changes to one part of the code can have unintended consequences elsewhere. Additionally, imperative code can be difficult to reason about, as it can be hard to understand the flow of control and the state of an application at any given time. While this example of changing the class of an element is simple, real applications tend to involve more than three or four steps to make something happen.</p>
    <p class="normal">React components don’t require you to execute steps in an imperative way. This is why JSX is central to React components. The XML-style syntax makes it easy to describe what the UI should look like – that is, what are the HTML elements that component is going to render? </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title">App</span> = () =&gt; {
  <span class="hljs-keyword">const</span> [isHighlighted, setIsHighlighted] = <span class="hljs-title">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span> setIsHighlighted(true)}&gt;Add Class<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag"> </span><span class="hljs-attr">className</span><span class="hljs-tag">=</span><span class="hljs-string">{isHighlighted</span><span class="hljs-tag"> &amp;&amp; "</span><span class="hljs-attr">highlight</span><span class="hljs-tag">"}&gt;</span>This is paragraph<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
};
</code></pre>
    <p class="normal">In this example, we’re not just writing the imperative procedure that the browser should execute. This is more like an instruction, where we say how the UI should look and what user interaction <a id="_idIndexMarker016"/>should happen on it. This is called declarative<a id="_idIndexMarker017"/> programming and is very well suited for UI development. Once you’ve declared your UI structure, you need to specify how it changes over time.</p>
    <h2 id="_idParaDest-21" class="heading-2">Data changes over time</h2>
    <p class="normal">Another area that’s<a id="_idIndexMarker018"/> difficult for React newcomers to grasp is the idea that JSX is like a static string, representing a chunk of rendered output. This is where data and the passage of time come into play. React components rely on data being passed into them. This data represents the dynamic parts of the UI – for example, a UI element that’s rendered based on a Boolean value could change the next time the component is rendered. Here’s a diagram illustrating the idea:</p>
    <figure class="mediaobject"><img src="../Images/B19636_01_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 1.3: React components changing over time</p>
    <p class="normal">Each time the React component is rendered, it’s like taking a snapshot of the JSX at that exact moment in time. As your application moves forward through time, you have an ordered collection of rendered UI components. In addition to declaratively describing what a UI should<a id="_idIndexMarker019"/> be, re-rendering the same JSX content makes things much easier for developers. The challenge is making sure that React can handle the performance demands of this approach.</p>
    <h2 id="_idParaDest-22" class="heading-2">Performance matters</h2>
    <p class="normal">Using React to build UIs <a id="_idIndexMarker020"/>means that we can declare the structure of the UI with JSX. This is less error-prone than the imperative approach of assembling the UI piece by piece. However, the declarative approach does present a challenge with performance.</p>
    <p class="normal">For example, having a declarative UI structure is fine for the initial rendering because there’s nothing on the page yet. So the React renderer can look at the structure declared in JSX and render it in the DOM browser.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">The Document Object Model</strong> (<strong class="keyWord">DOM</strong>) represents HTML in the browser after it has been<a id="_idIndexMarker021"/> rendered. The DOM API is how JavaScript is able to change content on a page.</p>
    </div>
    <p class="normal">This concept is illustrated in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19636_01_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 1.4: How JSX syntax translates to HTML in the browser DOM</p>
    <p class="normal">On the initial render, React<a id="_idIndexMarker022"/> components and their JSX are no different from other template libraries. For instance, there is a templating library called <strong class="keyWord">Handlebars</strong> used<a id="_idIndexMarker023"/> for server-side rendering, which will render a template to HTML markup as a string that is then inserted into the browser DOM. Where React is different from libraries such as Handlebars is that React can accommodate when data changes and we need to re-render the component, whereas Handlebars will just rebuild the entire HTML string, the same way it did on the initial render. Since this is problematic for performance, we often end up implementing imperative workarounds that manually update tiny bits of the DOM. We end up with a tangled mess of declarative templates and imperative code to handle the dynamic aspects of the UI.</p>
    <p class="normal">We don’t do this in React. This is what sets React apart from other view libraries. Components are declarative for the initial render, and they stay this way even as they’re re-rendered. It’s what React does under the hood that makes re-rendering declarative UI structures possible.</p>
    <p class="normal">In React, however, when we create a component, we describe what it should look like clearly and straightforwardly. Even as we update our components, React handles the changes smoothly behind the scenes. In other words, components are declarative for the initial render, and they stay this way even as they’re re-rendered. This is possible because React employs the virtual DOM, which is used to keep a representation of the real DOM elements in memory. It does this so that each time we re-render a component, it can compare the new content to the content that’s already displayed on the page. Based on the difference, the virtual DOM can execute the imperative steps necessary to make the changes. So not only do we get to keep our declarative code when we need to update the UI but React will also make sure that it’s done in a performant way. Here’s what this process looks like:</p>
    <figure class="mediaobject"><img src="../Images/B19636_01_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 1.5: React transpiles JSX syntax into imperative DOM API calls</p>
    <div class="note">
      <p class="normal">When you read about React, you’ll often see words such <a id="_idIndexMarker024"/>as <strong class="keyWord">diffing</strong> and <strong class="keyWord">patching</strong>. Diffing <a id="_idIndexMarker025"/>means comparing <em class="italic">old content</em> (the previous state of the UI) with <em class="italic">new content</em> (the updated state) to identify the differences, much like comparing two versions of a document to see what’s changed. Patching means executing the necessary DOM operations to render the new content, ensuring that only the specific changes are made, which is crucial for performance.</p>
    </div>
    <p class="normal">As with any other<a id="_idIndexMarker026"/> JavaScript library, React is constrained by the <em class="italic">run-to-completion</em> nature of the main thread. For example, if the React virtual DOM logic is busy diffing content and patching the real DOM, the browser can’t respond to user input such as clicks or interactions. </p>
    <p class="normal">As you’ll see in the next section of this chapter, changes were made to the internal rendering algorithms in React to mitigate these performance pitfalls. With performance concerns addressed, we need to make sure that we’re confident that React is flexible enough to adapt to the different platforms that we <a id="_idIndexMarker027"/>might want to deploy our apps to in the future.</p>
    <h2 id="_idParaDest-23" class="heading-2">The right level of abstraction</h2>
    <p class="normal">Another topic I want <a id="_idIndexMarker028"/>to cover at a high level before we dive into React <a id="_idIndexMarker029"/>code is <strong class="keyWord">abstraction</strong>.</p>
    <p class="normal">In the preceding section, you saw how JSX syntax translates to low-level operations that update our UI. A better way to look at how React translates our declarative UI components is via the fact that we don’t necessarily care what the render target is. The render target happens to be the browser DOM with React, but, as we will see, it isn’t restricted to the browser DOM.</p>
    <p class="normal">React has the potential to be used for any UI we want to create, on any conceivable device. We’re only just starting to see this with React Native, but the possibilities are endless. I would not be surprised if <em class="italic">React Toast</em>, which is totally not a thing, suddenly becomes relevant, where React targets toasters that can singe the rendered output of JSX onto bread. React’s abstraction level strikes a balance that allows for versatility and adaptability while maintaining a practical and efficient approach to UI development.</p>
    <p class="normal">The following diagram gives you an idea of how React can target more than just the browser:</p>
    <figure class="mediaobject"><img src="../Images/B19636_01_06.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 1.6: React abstracts the target rendering environment from the components that we implement</p>
    <p class="normal">From left to <a id="_idIndexMarker030"/>right, we have <strong class="keyWord">React DOM</strong>, <strong class="keyWord">React Native</strong>, <strong class="keyWord">React PDF</strong>, and <strong class="keyWord">React Unity</strong>. All<a id="_idIndexMarker031"/> of these<a id="_idIndexMarker032"/> React <a id="_idIndexMarker033"/>Renderer libraries accept the React component and return a platform-specific result. As you can see, to target something new, the same pattern applies:</p>
    <ul>
      <li class="bulletList">Implement components specific to the target.</li>
      <li class="bulletList">Implement a React renderer that can perform the platform-specific operations under the hood.</li>
    </ul>
    <p class="normal">This is, obviously, an oversimplification of what’s actually implemented for any given React environment. But the details aren’t so important to us. What’s important is that we can use our React <a id="_idIndexMarker034"/>knowledge to focus on describing the structure of our UI on any platform.</p>
    <p class="normal">Now that you understand the role of abstractions in React, let’s see what’s new in React.</p>
    <h1 id="_idParaDest-24" class="heading-1">What’s new in React?</h1>
    <p class="normal">React is a continuously <a id="_idIndexMarker035"/>evolving library in the ever-changing web development landscape. As you embark on your journey to learn and master React, it’s important to understand the evolution of the library and its updates over time.</p>
    <p class="normal">One of the advantages of React is that its core API has remained relatively stable in recent years. This provides a sense of continuity and allows developers to leverage their knowledge from previous versions. The conceptual foundation of React has remained intact, meaning that the skills acquired three or five years ago can still be applied today. Let’s take a step back and trace the history of React from its early versions to the recent ones. From <strong class="keyWord">React 0.x</strong> to <strong class="keyWord">React 18</strong>, numerous pivotal changes and enhancements have been made as follows: </p>
    <ul>
      <li class="bulletList"><strong class="keyWord">React 0.14</strong>: In this version, the introduction of functional components allowed developers to utilize functions as components, simplifying the creation of basic UI elements. At that time, no one knew that now we would write only functional components and almost completely abandon class-based components.</li>
      <li class="bulletList"><strong class="keyWord">React 15</strong>: With a new versioning scheme, the next update of React 15 brought a complete overhaul of the internal architecture, resulting in improved performance and stability.</li>
      <li class="bulletList"><strong class="keyWord">React 16</strong>: This version, however, stands as one of the most notable releases in React’s history. It introduced hooks, a revolutionary concept that enables developers to use state and other React features without the need for class components. Hooks make code simpler and more readable, transforming the way developers write components. We will explore a lot of hooks in this book. Additionally, React 16 introduced <strong class="keyWord">Fiber</strong>, a new reconciliation mechanism that significantly<a id="_idIndexMarker036"/> improved performance, especially when dealing with animations and complex UI structures.</li>
      <li class="bulletList"><strong class="keyWord">React 17</strong>: This version focused on updating and maintaining compatibility with previous versions. It introduced a new JSX transform system.</li>
      <li class="bulletList"><strong class="keyWord">React 18</strong>: This release continues the trajectory of improvement and emphasizes performance enhancements and additional features, such as the automatic batching of renders, state transitions, server components, and streaming server-side rendering. Most of the important updates related to <a id="_idIndexMarker037"/>performance will be explored in <em class="chapterRef">Chapter 12</em>, <em class="italic">High-Performance State Updates</em>. More details about server rendering will be covered in <em class="chapterRef">Chapter 14</em>, <em class="italic">Server Rendering and Static Site Generation with React Frameworks</em>.</li>
      <li class="bulletList"><strong class="keyWord">React 19</strong>: Introduces several major features and improvements. The <strong class="keyWord">React Compiler</strong> is a new compiler that enables automatic memoization and optimizes re-rendering, eliminating the need for manual <code class="inlineCode">useMemo</code>, <code class="inlineCode">useCallback</code>, and memo optimizations. Enhanced <strong class="keyWord">Hooks</strong> like <code class="inlineCode">use</code>(promise) for data fetching, <code class="inlineCode">useFormStatus()</code> and <code class="inlineCode">useFormState()</code> for form handling, and <code class="inlineCode">useOptimistic()</code> for optimistic UI simplify common tasks. React 19 also brings simplified APIs, such as ref becoming a regular prop, React.lazy being replaced, and Context.Provider becoming just Context. Asynchronous rendering allows fetching data asynchronously during rendering without blocking the UI, while error handling improvements provide better mechanisms to diagnose and fix issues in applications.</li>
    </ul>
    <p class="normal">React’s stability and compatibility make it a reliable library for long-term use, while the continuous updates ensure that it remains at the forefront of web and mobile development. Throughout this book, all examples will utilize the latest React API, ensuring that they remain functional and relevant in future versions.</p>
    <p class="normal">Now that we have <a id="_idIndexMarker038"/>explored the evolution and updates in React, we can delve deeper into React and examine how to get set up with the new React project.</p>
    <h1 id="_idParaDest-25" class="heading-1">Setting up a new React project</h1>
    <p class="normal">There are several ways <a id="_idIndexMarker039"/>to create a React project when you are getting started. In this section, we will explore three common approaches:</p>
    <ul>
      <li class="bulletList">Using web bundlers</li>
      <li class="bulletList">Using frameworks</li>
      <li class="bulletList">Using online code editors<div class="note">
          <p class="normal">To start developing and previewing your React applications, you will first need to have <strong class="keyWord">Node.js</strong> installed on<a id="_idIndexMarker040"/> your computer. Node.js is a runtime environment for executing JavaScript code.</p>
        </div>
      </li>
    </ul>
    <p class="normal">Let’s dive into<a id="_idIndexMarker041"/> each approach in the following subsections.</p>
    <h1 id="_idParaDest-26" class="heading-1">Using web bundlers</h1>
    <p class="normal">Using a web bundler is <a id="_idIndexMarker042"/>an efficient way to create React projects, especially if you are building a <strong class="keyWord">single-page application</strong> (<strong class="keyWord">SPA</strong>). For all<a id="_idIndexMarker043"/> of the examples in this book, we will use <strong class="keyWord">Vite</strong> as our web bundler. Vite is known for its remarkable speed and ease of setup and use.</p>
    <p class="normal">To set up your project using Vite, you will need to take the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Ensure that you have Node.js installed on your computer by visiting the official <em class="italic">Node.js</em> website (<a href="https://nodejs.org/"><span class="url">https://nodejs.org/</span></a>) and <a id="_idIndexMarker044"/>downloading the appropriate version for your operating system.</li>
      <li class="numberedList">Open your terminal or command prompt and navigate to the directory where you want to create your project:
        <pre class="programlisting con"><code class="hljs-con">mkdir react-projects
cd react-projects
</code></pre>
      </li>
      <li class="numberedList">Run the following command to create a new React project with Vite:
        <pre class="programlisting con"><code class="hljs-con">npm create vite@latest my-react-app -- --template react
</code></pre>
      
    <p class="normal">This command creates a new directory called <code class="inlineCode">my-react-app</code> and sets up a React project using the Vite template.</p>
</li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Once the project is created, your terminal should look like this:
        <pre class="programlisting con"><code class="hljs-con">Scaffolding project in react-projects/my-react-app...
Done. Now run:
  cd my-react-app
  npm install
     npm run dev
</code></pre>
      </li>
      <li class="numberedList">Navigate into the project directory and install dependencies. The result in the terminal should look like:
        <pre class="programlisting con"><code class="hljs-con">added 279 packages, and audited 280 packages in 21s
103 packages are looking for funding
  run 'npm fund' for details
found 0 vulnerabilities
</code></pre>
      </li>
    </ol>
    <p class="normal">Finally, start the development server by running the following command: <code class="inlineCode">npm run dev</code></p>
    <p class="normal">This command launches the development server, and you can view your React application by opening your browser and visiting <code class="inlineCode">http://localhost:3000</code>.</p>
    <p class="normal">By now, you will have successfully set up your React project using Vite as the web bundler. For more<a id="_idIndexMarker045"/> information about Vite and its possible configurations, visit the official website at <a href="https://vitejs.dev/"><span class="url">https://vitejs.dev/</span></a>.</p>
    <h2 id="_idParaDest-27" class="heading-2">Using frameworks</h2>
    <p class="normal">For real-world and <a id="_idIndexMarker046"/>commercial projects, it is recommended<a id="_idIndexMarker047"/> to use frameworks built on top of React. These frameworks provide additional features out of the box, such as routing and asset management (images, SVG files, fonts, etc.). They also guide you in organizing your project structure effectively, as frameworks often enforce <a id="_idIndexMarker048"/>specific file organization rules. Some <a id="_idIndexMarker049"/>popular React framework<a id="_idIndexMarker050"/>s include <strong class="keyWord">Next.js</strong>, <strong class="keyWord">Gatsby</strong>, and <strong class="keyWord">Remix</strong>.</p>
    <p class="normal">In <em class="chapterRef">Chapter 13</em>, <em class="italic">Server-Side Rendering</em>, we will explore setting up Next.js and some differences between that and using a plain web bundler.</p>
    <h2 id="_idParaDest-28" class="heading-2">Online code editors</h2>
    <p class="normal">Online code editors <a id="_idIndexMarker051"/>combine the advantages of web bundlers <a id="_idIndexMarker052"/>and frameworks but allow you to set up your React development environment in the cloud or right inside of the browser. This eliminates the need to install anything on your machine and lets you write and explore React code directly in your browser.</p>
    <p class="normal">While there are various online code editors available, some of the most popular options include <strong class="keyWord">CodeSandbox</strong>, <strong class="keyWord">StackBlitz</strong>, and <strong class="keyWord">Replit</strong>. These platforms provide a user-friendly interface and <a id="_idIndexMarker053"/>allow <a id="_idIndexMarker054"/>you to<a id="_idIndexMarker055"/> create, share, and collaborate on React projects without any local setup.</p>
    <p class="normal">To get started with an online code editor, you don’t even need an account. Simply follow this link on your browser: <a href="https://react.new"><span class="url">https://react.new</span></a>. In a few seconds, you will see that CodeSandbox is ready to work with a template project, and a live preview of the editor is available directly in the browser tab. If you want to save your changes, then you need to create an account.</p>
    <p class="normal">Using online code editors is a convenient way to learn and experiment with React, especially if you prefer a browser-based development environment.</p>
    <p class="normal">In this section, we explored different methods to set up your React project. Whether you choose web bundlers, frameworks, or online code editors, each approach offers its unique advantages. Select<a id="_idIndexMarker056"/> the method that you prefer and suits<a id="_idIndexMarker057"/> your project requirements. Now, we are ready to dive into the world of React development!</p>
    <h1 id="_idParaDest-29" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, you were introduced to React comprehensively so that you have an idea of what it is and the necessary aspects of it, setting the tone for the rest of the book. React is a library with a small API used to build UIs. Then, you were introduced to some of the key concepts of React. We discussed the fact that React is simple because it doesn’t have a lot of moving parts. </p>
    <p class="normal">Afterward, we explored the declarative nature of React components and JSX. Following that, you learned that React enables effective performance by writing declarative code that can be re-rendered repeatedly.</p>
    <p class="normal">You also gained insight into the idea of render targets and how React can easily become the UI tool of choice for various platforms. We then provided you with a brief overview of React’s history and introduced the latest developments. Finally, we delved into how to set up a new React project and initiate the learning process.</p>
    <p class="normal">That’s sufficient introductory and conceptual content for now. As we progress through the book’s journey, we’ll revisit these concepts. Next, let’s take a step back and nail down the basics, starting with rendering with JSX in the next chapter.</p>
    <h1 id="_idParaDest-30" class="heading-1">Join us on Discord!</h1>
    <p class="normal">Read this book alongside other users and the authors themselves. Ask questions, provide solutions to other readers, chat with the authors, and more. Scan the QR code or visit the link to join the community.</p>
    <p class="normal"><a href="https://packt.link/ReactAndReactNative5e"><span class="url">https://packt.link/ReactAndReactNative5e</span></a></p>
    <p class="normal"><img src="../Images/QR_Code196803360665486921.png" alt="" role="presentation"/></p>
  </div>
</body></html>