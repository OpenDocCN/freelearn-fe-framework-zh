<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer049">
			<h1 id="_idParaDest-47"><em class="italic"><a id="_idTextAnchor046"/>Chapter 3</em>: Testing Complex Components with React Testing Library</h1>
			<p>In <a href="B16887_02_Final_PG_ePub.xhtml#_idTextAnchor029"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with React Testing Library</em>, we learned how to test presentational components. However, most features are designed to allow user actions that result in changes to the state and resulting output. Testing as many user action scenarios as possible is essential for reducing risk before sending code to production for end users. By the end of this chapter, you will learn how to simulate user actions with the <strong class="source-inline">fireEvent</strong> and <strong class="source-inline">user-event</strong> modules. You will learn how to test components that interact with web service APIs. Finally, you will learn how to use test-driven development as a workflow for building your features.</p>
			<p>In this chapter, we're going to cover the following topics:</p>
			<ul>
				<li>Performing actions on components with the <strong class="source-inline">fireEvent</strong> module</li>
				<li>Simulating <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) events with the <strong class="source-inline">user-event</strong> module</li>
				<li>Testing components that interact with APIs</li>
				<li>Implementing test-driven development with React Testing Library</li>
			</ul>
			<p>The skills you gain in this chapter will provide you with a solid understanding of testing the outcomes of user behaviors. You will also gain a different approach to building components from start to finish.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Technical requirements</h1>
			<p>For the examples in this chapter, you will need to have Node.js installed on your machine. We will be using the <strong class="source-inline">create-react-app</strong> CLI tool for all code examples. Please familiarize yourself with the tool before starting the chapter if needed. Although not a requirement, it may help if you review the material from the previous two chapters before beginning this chapter.</p>
			<p>You can find code examples for this chapter here: <a href="https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter03">https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter03</a>.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Testing user events</h1>
			<p>In this section, we will learn how<a id="_idIndexMarker067"/> to simulate user events and test the resulting output. To test component interactions, similar to the case with users, we need methods to simulate DOM events in our tests. Numerous events caused by users can occur on the DOM. For example, a user can perform a keypress event by entering text into an input box, a click event by clicking a button, or they can view drop-down menu items with a mouseover event. The DOM Testing Library provides two libraries to simulate user actions, <strong class="source-inline">fireEvent</strong> and <strong class="source-inline">user-event</strong>, which we are going to see in the following sections.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Simulating user actions with fireEvent</h2>
			<p>We can use the <strong class="source-inline">fireEvent</strong> module to<a id="_idIndexMarker068"/> simulate user actions on the resulting DOM output of components. For example, we can build a reusable <strong class="source-inline">Vote</strong> component that renders <a id="_idIndexMarker069"/>the following DOM output:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="Images/Figure_3.1_B16887.jpg" alt="Figure 3.1 – Vote component&#13;&#10;" width="941" height="336"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Vote component</p>
			<p>In the preceding screenshot, the number <strong class="bold">10</strong> represents the likes rating. We have two buttons that a user can click to place a vote and change the likes rating: a thumbs-up button and a thumbs-down button. There is also a disclaimer letting the user know that they are only allowed to vote <a id="_idIndexMarker070"/>once. When a user clicks the<a id="_idIndexMarker071"/> thumbs-up button, they will see the following output:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="Images/Figure_3.2_B16887.jpg" alt="Figure 3.2 – Thumbs-up vote&#13;&#10;" width="903" height="322"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Thumbs-up vote</p>
			<p>In the previous screenshot, the likes rating increased from <strong class="bold">10</strong> to <strong class="bold">11</strong>. When a user clicks the thumbs-down button, they will see the following output:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="Images/Figure_3.3_B16887.jpg" alt="Figure 3.3 – Thumbs-down vote" width="949" height="336"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Thumbs-down vote</p>
			<p>In the previous screenshot, the likes rating has decreased from <strong class="bold">10</strong> to <strong class="bold">9</strong>. The act of clicking the button is an event we can simulate with <strong class="source-inline">fireEvent</strong>. In the code implementation for the <strong class="source-inline">Vote</strong> component, an event handler is called inside the component <a id="_idIndexMarker072"/>with logic to update the likes we see on the<a id="_idIndexMarker073"/> screen:</p>
			<p class="source-code">  <strong class="bold">const handleLikeVote = () =&gt; dispatch({ type: 'LIKE' })</strong></p>
			<p class="source-code">  const handleDislikeVote = () =&gt; dispatch({ type: </p>
			<p class="source-code">    'DISLIKE' })</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div className="h1"&gt;</p>
			<p class="source-code">      &lt;h5&gt;Note: You are not allowed to change your vote </p>
			<p class="source-code">         once selected!&lt;/h5&gt;</p>
			<p class="source-code">      &lt;button</p>
			<p class="source-code">        <strong class="bold">onClick={handleLikeVote}</strong></p>
			<p class="source-code">        disabled={hasVoted}</p>
			<p class="source-code">        style={clickedLike ? { background: 'green' } : </p>
			<p class="source-code">          null}</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">        &lt;img src={thumbsUp} alt="thumbs up" /&gt;</p>
			<p class="source-code">      &lt;/button&gt;</p>
			<p>In the preceding code block, the button has an <strong class="source-inline">onClick</strong> event handler attached. When the like button is clicked, the event handler calls the <strong class="source-inline">handleLikeVote</strong> method, which calls another method, <strong class="source-inline">dispatch</strong>, which updates the likes rating.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Please refer to the <a href="B16887_03_Final_PG_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a>, <em class="italic">Testing Complex Components with React Testing Library</em>, code samples, found in the <em class="italic">Technical requirements</em> section, to see the component in its entirety.</p>
			<p>We can write a test to assert the output of making a vote:</p>
			<p class="source-code">import { fireEvent, render, screen } from '@testing-library/react'</p>
			<p class="source-code">import Vote from './Vote'</p>
			<p class="source-code">test('increases total likes by one', () =&gt; {</p>
			<p class="source-code">  render(&lt;Vote totalGlobalLikes={10} /&gt;)</p>
			<p>In the preceding <a id="_idIndexMarker074"/>code block, we import the <strong class="source-inline">fireEvent</strong>, <strong class="source-inline">render</strong>, and <strong class="source-inline">screen</strong> methods from React Testing Library. Next, we import the <strong class="source-inline">Vote</strong> component to test. Then, we<a id="_idIndexMarker075"/> arrange our test code in the <strong class="source-inline">test</strong> method and use the <strong class="source-inline">render</strong> method to render the <strong class="source-inline">Vote</strong> component with the value <strong class="source-inline">10</strong> for the <strong class="source-inline">totalGlobalLikes</strong> property passed in to the component.</p>
			<p>The <strong class="source-inline">totalGlobalLikes</strong> property is the number we initially see on the screen when the component is rendered and represents the application-wide state for the likes. In a fully completed application, we would pass the <strong class="source-inline">totalGlobalLikes</strong> value down to the <strong class="source-inline">Vote</strong> component via a parent component. Next, we will interact with and assert the output of the rendered component:</p>
			<p class="source-code">expect(screen.getByText(/10/i)).toBeInTheDocument()</p>
			<p class="source-code">  fireEvent.click(screen.getByRole('button', { name: </p>
			<p class="source-code">    /thumbs up/i }))</p>
			<p class="source-code">  expect(screen.getByText(11).toBeInTheDocument()</p>
			<p class="source-code">  expect(screen.getByRole('button', { name: /thumbs up/i </p>
			<p class="source-code">    })).toHaveStyle(</p>
			<p class="source-code">    'background: green'</p>
			<p class="source-code">  )</p>
			<p class="source-code">})</p>
			<p>In the preceding code block, first, we assert that the <strong class="source-inline">Vote</strong> component's local version of <strong class="source-inline">totalGlobalLikes</strong> is in the document with a value equal to <strong class="source-inline">10</strong>. Next, we use the <strong class="source-inline">click</strong> method of <strong class="source-inline">fireEvent</strong> to click the button with the name <strong class="source-inline">thumbs up</strong>. Next, we assert that the value of <strong class="source-inline">totalGlobalLikes</strong> updates in the document to <strong class="source-inline">11</strong>. Finally, we assert that the <strong class="source-inline">thumbs up</strong> button's background color has changed to <strong class="source-inline">green</strong>.</p>
			<p>In many cases, using <strong class="source-inline">fireEvent</strong> is completely fine. However, it does have some limitations. For example, when a user performs an action such as entering text into an input box, many events occur, such as <strong class="source-inline">keydown</strong> and <strong class="source-inline">keyup</strong>. Now, <strong class="source-inline">fireEvent</strong> has methods to achieve these individual actions, but it doesn't have one way to handle them all together in <a id="_idIndexMarker076"/>sequence.</p>
			<p>Next, we will learn<a id="_idIndexMarker077"/> about using the <strong class="source-inline">user-event</strong> library to address the <strong class="source-inline">fireEvent</strong> module's limitations.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Simulating user actions with user-event</h2>
			<p>The <strong class="source-inline">user-event</strong> library is an <a id="_idIndexMarker078"/>enhanced version of <strong class="source-inline">fireEvent</strong>. In the previous section, we learned that <strong class="source-inline">fireEvent</strong> has methods to simulate various events<a id="_idIndexMarker079"/> that occur when a user enters text into an input box. The <strong class="source-inline">user-event</strong> library has many methods, such as <strong class="source-inline">click</strong> or <strong class="source-inline">type</strong>, that automatically simulate all the events that occur when a user performs actions on the DOM. The advantage is that <strong class="source-inline">user-event</strong> methods provide more value compared to <strong class="source-inline">fireEvent</strong> methods.</p>
			<p><strong class="source-inline">create-react-app</strong> comes with <strong class="source-inline">user-event</strong> already installed. For projects not using <strong class="source-inline">create-react-app</strong>, use the following command to install:</p>
			<p class="source-code">npm install --save-dev @testing-library/user-event</p>
			<p>We can update the previous section's <strong class="source-inline">Vote</strong> component test with <strong class="source-inline">user-event</strong>:</p>
			<p class="source-code">import { render, screen } from '@testing-library/react'</p>
			<p class="source-code"><strong class="bold">import user from '@testing-library/user-event'</strong></p>
			<p class="source-code">import Vote from './Vote'</p>
			<p class="source-code">test('increases total likes by one', () =&gt; {</p>
			<p class="source-code">  render(&lt;Vote totalGlobalLikes={10} /&gt;)</p>
			<p class="source-code">  expect(screen.getByText(/10/i)).toBeInTheDocument()</p>
			<p class="source-code">  <strong class="bold">user.click(screen.getByRole('button', { name: /thumbs </strong></p>
			<p class="source-code"><strong class="bold">     up/i }))</strong></p>
			<p class="source-code">  expect(screen.getByText(/11/i)).toBeInTheDocument()</p>
			<p class="source-code">  expect(screen.getByRole('button', { name: /thumbs up/i </p>
			<p class="source-code">    })).toHaveStyle(</p>
			<p class="source-code">    'background: green'</p>
			<p class="source-code">  )</p>
			<p class="source-code">})</p>
			<p>In the previous code, we imported the <strong class="source-inline">user-event</strong> library as <strong class="source-inline">user</strong>. Finally, we used the <strong class="source-inline">click</strong> method of <strong class="source-inline">user-event</strong> to click the <strong class="source-inline">thumbs up</strong> button. Our test provides more value because<a id="_idIndexMarker080"/> we are more closely simulating user DOM actions. The React Testing Library team recommends using <strong class="source-inline">user-event</strong> as much as <a id="_idIndexMarker081"/>possible, so we will not use <strong class="source-inline">fireEvent</strong> in any more examples throughout the remainder of this book.</p>
			<p>When we introduced the <strong class="source-inline">Vote</strong> component in the previous section, we mentioned that a user could only vote once. We can write a test to handle that scenario:</p>
			<p class="source-code">test('A user can only vote once', () =&gt; {</p>
			<p class="source-code">  render(&lt;Vote totalGlobalLikes={10} /&gt;)</p>
			<p class="source-code">  const thumbsUpBtn = screen.getByRole('button', { name: </p>
			<p class="source-code">    /thumbs up/i })</p>
			<p class="source-code">  const thumbsDownBtn = screen.getByRole('button', { name: </p>
			<p class="source-code">    /thumbs down/i })</p>
			<p class="source-code">  expect(screen.getByText(/10/i)).toBeInTheDocument()</p>
			<p class="source-code">  user.click(thumbsUpBtn)</p>
			<p class="source-code">  user.click(thumbsUpBtn)</p>
			<p class="source-code">  expect(screen.getByText(/11/i)).toBeInTheDocument()</p>
			<p class="source-code">  user.click(thumbsDownBtn)</p>
			<p class="source-code">  expect(screen.getByText(/11/i)).toBeInTheDocument()</p>
			<p class="source-code">})</p>
			<p>In the preceding code, first, we<a id="_idIndexMarker082"/> grab the <strong class="source-inline">thumbs up</strong> and <strong class="source-inline">thumbs down</strong> buttons. Then, we verify the current total likes is <strong class="source-inline">10</strong> and click the <strong class="source-inline">thumbs up</strong> button twice. Next, we verify the total likes is <strong class="source-inline">11</strong>. Finally, we click the <strong class="source-inline">thumbs down</strong> button <a id="_idIndexMarker083"/>and assert that the total likes count is still <strong class="source-inline">11</strong>. As another test case, we can also verify that the local version of <strong class="source-inline">totalGlobalLikes</strong> decreases by one when a user clicks the <strong class="source-inline">thumbs down</strong> button:</p>
			<p class="source-code">test('decreases total likes by one', () =&gt; {</p>
			<p class="source-code">  render(&lt;Vote totalGlobalLikes={10} /&gt;)</p>
			<p class="source-code">  expect(screen.getByText(/10/i)).toBeInTheDocument()</p>
			<p class="source-code">  user.click(screen.getByRole('button', { name: /thumbs </p>
			<p class="source-code">    down/i }))</p>
			<p class="source-code">  expect(screen.getByText(/9/i)).toBeInTheDocument()</p>
			<p class="source-code">  expect(screen.getByRole('button', { name: /thumbs down/i </p>
			<p class="source-code">    })).toHaveStyle(</p>
			<p class="source-code">    'background: red'</p>
			<p class="source-code">  )</p>
			<p class="source-code">})</p>
			<p>We click the <strong class="source-inline">thumbs down</strong> button and verify the total likes decreased from <strong class="source-inline">10</strong> to <strong class="source-inline">9</strong>, and the background color changed to <strong class="source-inline">red</strong> in the preceding code.</p>
			<p>When we run all the tests for the <strong class="source-inline">Vote</strong> component, we get the following results indicating all tests passed:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="Images/Figure_3.4_B16887.jpg" alt="Figure 3.4 – Vote component test results&#13;&#10;" width="951" height="354"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Vote component test results</p>
			<p>The preceding screenshot<a id="_idIndexMarker084"/> shows that the <strong class="bold">increases total likes by one</strong>, <strong class="bold">decreases total likes by one</strong>, and <strong class="bold">A user can only vote once</strong> tests have passed in the <strong class="source-inline">Vote.test.js</strong> file.</p>
			<p>In another example, we might<a id="_idIndexMarker085"/> create an input component for employees that accepts their name:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="Images/Figure_3.5_B16887.jpg" alt="Figure 3.5 – Employee email input&#13;&#10;" width="572" height="65"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Employee email input</p>
			<p>When the employee enters their name, the component appends it to the company's website name and displays the result to the screen:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="Images/Figure_3.6_B16887.jpg" alt="Figure 3.6 – Completed employee email input&#13;&#10;" width="685" height="122"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Completed employee email input</p>
			<p>If the employee enters a first and last name separated by a space, the name is concatenated with a <strong class="source-inline">.</strong>:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="Images/Figure_3.7_B16887.jpg" alt="Figure 3.7 – Concatenated employee email input&#13;&#10;" width="646" height="117"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Concatenated employee email input</p>
			<p>We can use the <strong class="source-inline">type</strong> method of <strong class="source-inline">user-event</strong> to simulate typing into the employee email component and make an assertion on the result as follows:</p>
			<p class="source-code">import { render, screen } from '@testing-library/react'</p>
			<p class="source-code">import user from '@testing-library/user-event'</p>
			<p class="source-code">import EmployeeEmail from './EmployeeEmail'</p>
			<p class="source-code">test('it accepts a username and displays to the screen', ()</p>
			<p class="source-code">  =&gt; {</p>
			<p class="source-code">  render(&lt;EmployeeEmail /&gt;)</p>
			<p class="source-code">  const input = screen.getByRole('textbox', { name: /enter </p>
			<p class="source-code">    your name/i })</p>
			<p class="source-code">  user.type(input, 'jane doe')</p>
			<p class="source-code">  expect(screen.getByText(/jane.doe@software-</p>
			<p class="source-code">    plus.com/i)).toBeInTheDocument()</p>
			<p class="source-code">})</p>
			<p>We import the <strong class="source-inline">render</strong>, <strong class="source-inline">screen</strong>, and <strong class="source-inline">user-event</strong> modules in the previous code. Then, we import <a id="_idIndexMarker086"/>the <strong class="source-inline">EmployeeEmail</strong> component. We render the <a id="_idIndexMarker087"/>component on the screen. Then, we grab the input element and store it in the variable input. Next, we use the <strong class="source-inline">type</strong> method from <strong class="source-inline">user-event</strong> to enter <strong class="source-inline">jane doe</strong> into the input. Finally, we assert that the text <strong class="source-inline">jane.doe@software-plus.com</strong> is in the DOM.</p>
			<p>When we run our test, we get the following output indicating the scenario passes as expected:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="Images/Figure_3.8_B16887.jpg" alt="Figure 3.8 – Employee component test results&#13;&#10;" width="1018" height="291"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Employee component test results</p>
			<p>The previous <a id="_idIndexMarker088"/>screenshot shows that the <strong class="bold">it accepts a username and displays to the screen</strong> test passed in the <strong class="source-inline">EmployeeEmail.test.js</strong> file. Now you know how to simulate user actions using the <strong class="source-inline">user-event</strong> module. The<a id="_idIndexMarker089"/> skills learned in this section are essential because most of our tests typically will need to involve some type of user action.</p>
			<p>Next, we will learn how to test components that call event handlers in isolation.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Testing components that call event handlers in isolation </h2>
			<p>It is very common to create<a id="_idIndexMarker090"/> child components that invoke methods passed down to them from parent components. In the previous section, we had a <strong class="source-inline">Vote</strong> component that included two buttons in the same component, which can be seen in the following code block:</p>
			<p class="source-code">      &lt;button</p>
			<p class="source-code">        onClick={voteLike}</p>
			<p class="source-code">        disabled={hasVoted}</p>
			<p class="source-code">        style={clickedLike ? { background: 'green' } : </p>
			<p class="source-code">          null}</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">        &lt;img src={thumbsUp} alt="thumbs up" /&gt;</p>
			<p class="source-code">      &lt;/button&gt;</p>
			<p class="source-code">      &lt;div&gt;{totalLikes}&lt;/div&gt;</p>
			<p class="source-code">      &lt;button</p>
			<p class="source-code">        onClick={voteDislike}</p>
			<p class="source-code">        disabled={hasVoted}</p>
			<p class="source-code">        style={clickedDislike ? { background: 'red' } : </p>
			<p class="source-code">          null}</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">        &lt;img src={thumbsDown} alt="thumbs down" /&gt;</p>
			<p class="source-code">      &lt;/button&gt;</p>
			<p>We could decide to <a id="_idIndexMarker091"/>extract the button code into its own file to become a reusable component:</p>
			<p class="source-code">const VoteBtn = props =&gt; {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;button onClick={props.handleVote} </p>
			<p class="source-code">      disabled={props.hasVoted}&gt;</p>
			<p class="source-code">      &lt;img src={props.imgSrc} alt={props.altText} /&gt;</p>
			<p class="source-code">    &lt;/button&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>In the preceding code block, we have a <strong class="source-inline">VoteBtn</strong> component that accepts <strong class="source-inline">handleVote</strong>, <strong class="source-inline">hasVoted</strong>, <strong class="source-inline">imgSrc</strong>, and <strong class="source-inline">altText</strong> properties passed to the <strong class="source-inline">props</strong> object. The parent component would pass down the props. For this section's purposes, our primary focus is the <strong class="source-inline">handleVote</strong> property. The <strong class="source-inline">handleVote</strong> method is called when a <strong class="source-inline">click</strong> event fires due to clicking the button. When this method runs inside the <strong class="source-inline">Vote</strong> component, the <a id="_idIndexMarker092"/>result is updating the local version of <strong class="source-inline">totalGlobalLikes</strong>. The resulting screen output of the button is as follows:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="Images/Figure_3.9_B16887.jpg" alt="Figure 3.9 – Vote button&#13;&#10;" width="170" height="166"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Vote button</p>
			<p>In the preceding screenshot, we see a <strong class="source-inline">Vote</strong> component with a <strong class="source-inline">thumbs up</strong> image. To test the <strong class="source-inline">VoteBtn</strong> component in isolation, we need to provide properties to the component since it's no longer wrapped in a component that provides them automatically. Jest provides functions that serve as test doubles to replace the real versions of methods inside our tests.</p>
			<p>A test double is a generic term used to represent an object that replaces a real object for testing purposes. Test doubles used as <a id="_idIndexMarker093"/>placeholders for dependencies such as an API or <a id="_idIndexMarker094"/>database are known as <strong class="bold">stubs</strong>. However, when a test double is used to make assertions against, it is known as a <strong class="bold">mock</strong>. For example, we can use the <strong class="source-inline">jest.fn</strong> function to replace <strong class="source-inline">handleVote</strong> inside our test:</p>
			<p class="source-code">import { render, screen } from '@testing-library/react'</p>
			<p class="source-code">import user from '@testing-library/user-event'</p>
			<p class="source-code">import thumbsUp from './images/thumbs-up.svg'</p>
			<p class="source-code">import VoteBtn from './VoteBtn'</p>
			<p class="source-code">test('invokes handleVote', () =&gt; {</p>
			<p class="source-code">  <strong class="bold">const mockHandleVote = jest.fn()</strong></p>
			<p class="source-code">  render(</p>
			<p class="source-code">    &lt;VoteBtn</p>
			<p class="source-code">      handleVote={<strong class="bold">mockHandleVote</strong>}</p>
			<p class="source-code">      hasVoted={false}</p>
			<p class="source-code">      imgSrc={thumbsUp}</p>
			<p class="source-code">      altText="vote like"</p>
			<p class="source-code">    /&gt;</p>
			<p class="source-code">  )</p>
			<p>In the preceding code block, first, we import the <strong class="source-inline">render</strong> and <strong class="source-inline">screen</strong> methods from React Testing Library. Next, we import the <strong class="source-inline">user-event</strong> module. Then, we import the <strong class="source-inline">thumbsUp</strong> image and the <strong class="source-inline">VoteBtn</strong> component we want to test. Then, inside the <strong class="source-inline">test</strong> method, we create a <strong class="source-inline">jest</strong> function to use as a mock and assign it to the <strong class="source-inline">mockHandleVote</strong> variable.</p>
			<p>Next, we render the <strong class="source-inline">VoteBtn</strong> component into the DOM and pass <strong class="source-inline">mockHandleVote</strong> and other properties to the component. Now that our test code is arranged, we can perform actions and make<a id="_idIndexMarker095"/> assertions:</p>
			<p class="source-code">  user.click(screen.getByRole('button', { name: /vote </p>
			<p class="source-code">    like/i }))</p>
			<p class="source-code">  expect(mockHandleVote).toHaveBeenCalled()</p>
			<p class="source-code">  expect(mockHandleVote).toHaveBeenCalledTimes(1)</p>
			<p class="source-code">})</p>
			<p>In the previous code, we click the button with the name <strong class="bold">vote like</strong>. Finally, we make two assertions. The first assertion verifies the <strong class="source-inline">mockHandleVote</strong> method is called when a user clicked the button. The second assertion confirms the <strong class="source-inline">mockHandleVote</strong> method was called exactly one time. The <strong class="source-inline">mockHandleVote</strong> assertions can be important when you need to be sure the function is used correctly. When we run our test, we get the following output indicating the scenario passes as expected:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="Images/Figure_3.10_B16887.jpg" alt="Figure 3.10 – Vote button component test results&#13;&#10;" width="1014" height="312"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Vote button component test results</p>
			<p>The previous screenshot shows that the <strong class="bold">invokes handleVote</strong> test passed in the <strong class="source-inline">VoteBtn.test.js</strong> file. It should be noted that although we were able to verify that the event handler is called, we are not able to confirm whether the button state changes to disabled after being clicked. We would need to include the parent component and write an integration test to verify that behavior. We will learn how to approach these scenarios in <a href="B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>, <em class="italic">Integration Testing and Third-Party Libraries in Your Application</em>.</p>
			<p>Now you know how to test <a id="_idIndexMarker096"/>event handlers in isolated components with test doubles. In this section, we learned how to simulate and test user interactions. We learned how to mimic actions with <strong class="source-inline">fireEvent</strong> and <strong class="source-inline">user-event</strong>. We also learned how to use test doubles to test event handlers. The skills learned in this section will help you in the next section when we learn how to test components that interact with APIs.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Testing components that interact with APIs</h1>
			<p>This section will build on<a id="_idIndexMarker097"/> our knowledge of testing event handlers from the previous section by looking at how to test components that send and receive data from APIs. In our component unit tests, we can reduce application risk with our testing efforts by using tools that act as test doubles in place of real APIs. Using test doubles in place of the actual API, we can avoid slow internet connections or receive dynamic data resulting in unpredictable test results.</p>
			<p>We will learn how<a id="_idIndexMarker098"/> to install and use <strong class="bold">Mock Service Worker</strong> (<strong class="bold">MSW</strong>) as a test double in tests to capture API requests initiated by our components and return mock data. We will test a component <a id="_idIndexMarker099"/>designed for users to search for drinks data from an API. We will also learn how to use MSW as a development server. The concepts in this section will help us understand how to verify communication between the frontend and API servers.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Requesting API data with fetch</h2>
			<p>We can create a <a id="_idIndexMarker100"/>component that allows a user to<a id="_idIndexMarker101"/> search for drinks from TheCockTailDB (<a href="https://www.thecocktaildb.com">https://www.thecocktaildb.com</a>), a free open source service that will play the backend API's role. Our component will access the<a id="_idIndexMarker102"/> service and request data. When the component first renders, the user sees an input field and a <strong class="bold">Search</strong> button:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="Images/Figure_3.11_B16887.jpg" alt="Figure 3.11 – Drink search component" width="527" height="156"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – Drink search component</p>
			<p>When a user searches for drinks, the API returns drink data similar to the following:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="Images/Figure_3.12_B16887.jpg" alt="Figure 3.12 – Drink search results&#13;&#10;" width="990" height="731"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Drink search results</p>
			<p>In the preceding <a id="_idIndexMarker103"/>screenshot, a user searched for <strong class="source-inline">gin</strong> and received<a id="_idIndexMarker104"/> an array of results from the API. If a user searches for drinks that don't return results, a <strong class="bold">No drinks found</strong> message is displayed on the screen:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="Images/Figure_3.13_B16887.jpg" alt="Figure 3.13 – No drink search results&#13;&#10;" width="986" height="234"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – No drink search results</p>
			<p>If a user attempts a search and the API server is inaccessible, a <strong class="bold">Service unavailable</strong> message is displayed:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="Images/Figure_3.14_B16887.jpg" alt="Figure 3.14 – Drink search request error&#13;&#10;" width="1004" height="231"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Drink search request error</p>
			<p>Our component <a id="_idIndexMarker105"/>will use an HTTP <strong class="source-inline">request</strong> module designed to<a id="_idIndexMarker106"/> request drink data from the API using the <strong class="source-inline">fetch</strong> method, a tool included in browsers to make HTTP requests:</p>
			<p class="source-code">const fetchDrinks = async drinkQuery =&gt; {</p>
			<p class="source-code">  const response = await fetch(</p>
			<p class="source-code">    `https://www.thecocktaildb.com/api/json/v1/1/search.php?s=$</p>
			<p class="source-code">  {drinkQuery}`</p>
			<p class="source-code">  )</p>
			<p class="source-code">  const data = await response.json()</p>
			<p class="source-code">  return data.drinks</p>
			<p class="source-code">}</p>
			<p class="source-code">export default fetchDrinks</p>
			<p>In the preceding code block, <strong class="source-inline">fetchDrinks</strong> accepts a <strong class="source-inline">drinkQuery</strong> parameter representing the search data<a id="_idIndexMarker107"/> and makes an API request to return drinks data.</p>
			<p>The <strong class="source-inline">Drink Search</strong> component <a id="_idIndexMarker108"/>has a form that, when submitted, will call the <strong class="source-inline">handleDrinkQuery</strong> method, which ultimately invokes the <strong class="source-inline">request</strong> module with the drinks to search:</p>
			<p class="source-code">&lt;form onSubmit={handleDrinkQuery}&gt;</p>
			<p class="source-code">  &lt;input</p>
			<p class="source-code">    placeholder='search for a drink...'</p>
			<p class="source-code">    type='search'</p>
			<p class="source-code">    value={drinkQuery}</p>
			<p class="source-code">    onChange={(event) =&gt; setDrinkQuery(event.target.value)}</p>
			<p class="source-code">  /&gt;</p>
			<p class="source-code">  &lt;button type='submit'&gt;Search&lt;/button&gt;</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p>When the <strong class="source-inline">request</strong> module sends a response that includes an array of drinks, the <strong class="source-inline">Drink Search</strong> component will call <strong class="source-inline">drinkResults</strong>, a method that renders <strong class="source-inline">drinks</strong> on the screen:</p>
			<p class="source-code">{drinks &amp;&amp; &lt;div&gt;{drinkResults()}&lt;/div&gt;}</p>
			<p>If the response does not return any drinks, then the <strong class="source-inline">No drinks found</strong> code is rendered:</p>
			<p class="source-code">{!drinks &amp;&amp; &lt;h5&gt; No drinks found &lt;/h5&gt;}</p>
			<p>If there is an error communicating with the server, then the <strong class="source-inline">Service unavailable</strong> code is rendered:</p>
			<p class="source-code">{error &amp;&amp; &lt;h5&gt;<img src="Images/Shape_01.png" alt="" width="26" height="24"/> Service unavailable <img src="Images/Shape_01.png" alt="" width="26" height="24"/>&lt;/h5&gt;</p>
			<p>Now we understand how the <strong class="source-inline">Drink Search</strong> component behaves based on user interactions. Next, we will <a id="_idIndexMarker109"/>learn how to create mock API data to test the<a id="_idIndexMarker110"/> component.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Creating mock API data with MSW</h2>
			<p><strong class="bold">MSW</strong> is a tool we can use to <a id="_idIndexMarker111"/>capture API requests initiated by our components and return mocked responses. When our frontend React application <a id="_idIndexMarker112"/>makes an HTTP request to an API server, MSW will intercept the request before it reaches the network and respond with mock data. Use the following command to install MSW into your project:</p>
			<p class="source-code">npm install msw --save-dev</p>
			<p>To get started using MSW, first, we will create a mock response route handler to override matching calls to specific URLs by our component:</p>
			<p class="source-code">import { rest } from 'msw'</p>
			<p class="source-code">export const handlers = [</p>
			<p class="source-code">  rest.get(</p>
			<p class="source-code">    'https://www.thecocktaildb.com/api/json/v1/1/search.php',</p>
			<p class="source-code">    (req, res, ctx) =&gt; {</p>
			<p class="source-code">      return res(</p>
			<p class="source-code">        ctx.status(200),</p>
			<p class="source-code">        ctx.json({</p>
			<p class="source-code">          drinks: [</p>
			<p class="source-code">            {</p>
			<p class="source-code">              idDrink: 1,</p>
			<p class="source-code">              strDrinkThumb: './images/thumbs-down.svg',</p>
			<p class="source-code">              strDrink: 'test drink',</p>
			<p class="source-code">              strInstructions: 'test instructions',</p>
			<p class="source-code">              strIngredient1: 'test ingredient'</p>
			<p class="source-code">            }</p>
			<p class="source-code">          ]</p>
			<p>In the preceding code block, we imported <strong class="source-inline">rest</strong> from <strong class="source-inline">msw</strong>. The <strong class="source-inline">rest</strong> object allows us to specify the <strong class="source-inline">request</strong> type to <strong class="source-inline">mock</strong>. Inside the <strong class="source-inline">get</strong> method, we specify the route we will override when a <em class="italic">GET</em> request is<a id="_idIndexMarker113"/> made. In the <strong class="source-inline">callback</strong> parameter of the <strong class="source-inline">get</strong> method, three parameters are accepted –the <strong class="source-inline">req</strong> parameter provides information about the request, such as the data sent in the request. The <strong class="source-inline">res</strong> parameter is a function used to make the mocked<a id="_idIndexMarker114"/> response. The <strong class="source-inline">ctx</strong> parameter provides a context for the response functions to send.</p>
			<p>Inside <strong class="source-inline">ctx</strong>, we create a <strong class="source-inline">200</strong> response status code indicating a successful request, and lastly, we create JSON data to return, which will be an array of drinks. You may notice that the <em class="italic">GET</em> request route does not match the entire URL used in the HTTP request module from the previous section. MSW will pattern match URLs, making the need to use the exact URL string unnecessary.</p>
			<p>Next, we will create our mock server and pass in the mock response route handler:</p>
			<p class="source-code">import { setupServer } from 'msw/node'</p>
			<p class="source-code">import { handlers } from './handlers'</p>
			<p class="source-code">export const mockServer = setupServer(...handlers)</p>
			<p>In the previous code, first, we import <strong class="source-inline">setupServer</strong> from <strong class="source-inline">msw/node</strong>, which will be used to intercept requests made to the route handler created in the previous code snippet. We use <strong class="source-inline">msw/node</strong> because <a id="_idIndexMarker115"/>our test code will run in a Node.js environment. Next, we import the route handlers. Finally, we pass the handlers to <strong class="source-inline">setupServer</strong> and export the code via the <strong class="source-inline">mockServer</strong> variable. Now that we have our server set up, we can write a <a id="_idIndexMarker116"/>test for the <strong class="source-inline">DrinkSearch</strong> component.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Testing the DrinkSearch component</h2>
			<p>To get started testing the<a id="_idIndexMarker117"/> component, first, we will import the required code and start our mock server:</p>
			<p class="source-code">import { render, screen} from '@testing-library/react'</p>
			<p class="source-code">import user from '@testing-library/user-event'</p>
			<p class="source-code">import DrinkSearch from './DrinkSearch'</p>
			<p class="source-code">import { mockServer } from './mocks/server.js'</p>
			<p>In the preceding code block, first, we import <strong class="source-inline">render</strong> and <strong class="source-inline">screen</strong> from React Testing Library. Next, we import the <strong class="source-inline">user-event</strong> module. Then we import the <strong class="source-inline">DrinkSearch</strong> component we want to test. Finally, we import <strong class="source-inline">mockServer</strong>, our mock server. Next, we need to start our mock server and set it up to perform specific actions at different points in the test life cycle:</p>
			<p class="source-code">beforeAll(() =&gt; mockServer.listen())</p>
			<p class="source-code">afterEach(() =&gt; mockServer.resetHandlers())</p>
			<p class="source-code">afterAll(() =&gt; mockServer.close())</p>
			<p>In the preceding code block, first, we set up our mock server to listen to HTTP requests before running any of our tests. Next, we make our mock server reset after each test, so no tests are affected by previous tests. Finally, we shut down our mock server after all tests are finished running. Next, we will create the main test code:</p>
			<p class="source-code">test('renders mock drink data, async () =&gt; {</p>
			<p class="source-code">  render(&lt;DrinkSearch /&gt;)</p>
			<p class="source-code">  const searchInput = screen.getByRole('searchbox')</p>
			<p class="source-code">  user.type(searchInput, 'vodka, {enter}')</p>
			<p>In the preceding code block, we<a id="_idIndexMarker118"/> render the <strong class="source-inline">DrinkSearch</strong> component. Next, we grab the search input and enter <strong class="source-inline">vodka</strong> as the drink to search. That <strong class="source-inline">{enter}</strong> after <strong class="source-inline">vodka</strong> simulates pressing the <em class="italic">Enter</em> key on a keyboard. Next, we will make assertions on the outcomes of user actions:</p>
			<p class="source-code">  expect(</p>
			<p class="source-code">    await screen.findByRole('img', { name: /test drink/i })</p>
			<p class="source-code">  ).toBeInTheDocument()</p>
			<p class="source-code">  expect(</p>
			<p class="source-code">    screen.getByRole('heading', { name: /test drink/i })</p>
			<p class="source-code">  ).toBeInTheDocument()</p>
			<p class="source-code">  expect(screen.getByText(/test </p>
			<p class="source-code">    ingredient/i)).toBeInTheDocument()</p>
			<p class="source-code">  expect(screen.getByText(/test </p>
			<p class="source-code">    instructions/i)).toBeInTheDocument()</p>
			<p class="source-code">})</p>
			<p>In the preceding code, we use the <strong class="source-inline">findByRole</strong> query method to grab the image element. In previous examples, we solely used <strong class="source-inline">getBy*</strong> queries. The <strong class="source-inline">getBy*</strong> queries can be used in most situations when you expect elements to be available in the current state of the DOM. However, in the previous code, we use a <strong class="source-inline">findBy*</strong> query because the process of communicating with the API is asynchronous, so we need to give our application time to receive a response and update the DOM before attempting to grab an element.</p>
			<p>When a <strong class="source-inline">getBy*</strong> query is used to select elements, an error is thrown, and our test fails if the element is not found in the current DOM:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="Images/Figure_3.15_B16887.jpg" alt="Figure 3.15 – No drink search failing test results&#13;&#10;" width="1143" height="170"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – No drink search failing test results</p>
			<p>The preceding screenshot shows that the <strong class="bold">renders mock drink data</strong> test failed in the <strong class="source-inline">DrinkSearch.test.js</strong> file. The test result output also provides more context for the failure by letting us know it couldn't find an image element with the name <strong class="source-inline">test drink</strong>. The <strong class="source-inline">findBy*</strong> queries will<a id="_idIndexMarker119"/> also throw an error when elements are not found, but only after a few seconds, allowing time for the element to appear on the screen.</p>
			<p>We can also write a test to verify the output when no results are returned from the API server for our drink search. We can modify the response of our MSW server to set up the scenario:</p>
			<p class="source-code">test('renders no drink results', async () =&gt; {</p>
			<p class="source-code">  mockServer.use(</p>
			<p class="source-code">    rest.get(</p>
			<p class="source-code">      'https://www.thecocktaildb.com/api/json/v1/1/search.php',</p>
			<p class="source-code">      (req, res, ctx) =&gt; {</p>
			<p class="source-code">        return res(</p>
			<p class="source-code">          ctx.status(200),</p>
			<p class="source-code">          ctx.json({</p>
			<p class="source-code">            drinks: null</p>
			<p class="source-code">          })</p>
			<p class="source-code">        )</p>
			<p class="source-code">      }</p>
			<p class="source-code">    )</p>
			<p class="source-code">  )</p>
			<p>In the preceding code block, we use the <strong class="source-inline">use</strong> method to override our default mock values to return <strong class="source-inline">null</strong>. As mentioned in the <em class="italic">Requesting API data with fetch</em> section, our component will return the <strong class="source-inline">No drinks found</strong> message when the server does not return an array of drinks. Now<a id="_idIndexMarker120"/> that we have our test set up to send the right data, we can write the main test code:</p>
			<p class="source-code">      render(&lt;DrinkSearch /&gt;)</p>
			<p class="source-code">  const searchInput = screen.getByRole('searchbox')</p>
			<p class="source-code">  user.type(searchInput, 'vodka, {enter}')</p>
			<p class="source-code">  expect(</p>
			<p class="source-code">    await screen.findByRole('heading', { name: / no </p>
			<p class="source-code">      drinks found /i })</p>
			<p class="source-code">  ).toBeInTheDocument()</p>
			<p class="source-code">})</p>
			<p>We render the <strong class="source-inline">DrinkSearch</strong> component and search for <strong class="source-inline">vodka</strong> as in the last test in the preceding code. However, instead of expecting an array of drinks, we expect to see the <strong class="source-inline">No drinks found</strong> message.</p>
			<p>For our next test, we will verify the output when the API server is unavailable. Like we did in the previous test, we will modify the response of our MSW server to set up the test scenario:</p>
			<p class="source-code">test('renders service unavailable', async () =&gt; {</p>
			<p class="source-code">  mockServer.use(</p>
			<p class="source-code">    rest.get(</p>
			<p class="source-code">      'https://www.thecocktaildb.com/api/json/v1/1/search.php',</p>
			<p class="source-code">      (req, res, ctx) =&gt; {</p>
			<p class="source-code">        return res(ctx.status(503))</p>
			<p class="source-code">      }</p>
			<p class="source-code">    )</p>
			<p class="source-code">  )</p>
			<p>We override our default mock values in the previous code to respond with a <strong class="source-inline">503</strong> status code indicating the API is not available. As mentioned in the <em class="italic">Requesting API data with fetch</em> section, our component will return the <strong class="source-inline">Service unavailable</strong> message when the server is offline. Now that we have our test set up to send the right response, we can write the main test code:</p>
			<p class="source-code">render(&lt;DrinkSearch /&gt;)</p>
			<p class="source-code">const searchInput = screen.getByRole('searchbox');</p>
			<p class="source-code">user.type(searchInput, 'vodka, {enter}');</p>
			<p class="source-code">expect(</p>
			<p class="source-code">  await screen.findByRole('heading', { name: /Service     unavailable/i })</p>
			<p class="source-code">).toBeInTheDocument()</p>
			<p>Like code in the previous test, we render the <strong class="source-inline">DrinkSearch</strong> component and search for <strong class="source-inline">vodka</strong> as in the last test. However, now <a id="_idIndexMarker121"/>we expect <strong class="source-inline">Service unavailable</strong> to be in the document due to the server sending the <strong class="source-inline">503</strong> error code.</p>
			<p>The last test we write will verify that no request is made when a user attempts to submit a blank search query:</p>
			<p class="source-code">test('prevents GET request when search input empty', async </p>
			<p class="source-code">  () =&gt; {</p>
			<p class="source-code">  render(&lt;DrinkSearch /&gt;)</p>
			<p class="source-code">  const searchInput = screen.getByRole('searchbox')</p>
			<p class="source-code">  user.type(searchInput, '{enter}')</p>
			<p class="source-code">  expect(screen.queryByRole('heading')).not.toBeInTheDocument()</p>
			<p class="source-code">})</p>
			<p>In the previous code, we press the <em class="italic">Enter</em> key without typing in a search string. When the application first loads, we only see the input field and the button used to search. The application is designed to display additional content that includes heading elements when a search query is submitted to the API. We expect no element with the role of <strong class="source-inline">heading</strong> on the screen <a id="_idIndexMarker122"/>using a <strong class="source-inline">queryBy*</strong> query. The <strong class="source-inline">queryBy*</strong> query is preferred when you want to verify that specific elements are not on the screen.</p>
			<p>Unlike the <strong class="source-inline">getBy*</strong> and <strong class="source-inline">findBy*</strong> queries, <strong class="source-inline">queryBy*</strong> queries do not throw an error and fail the test when an element is not found. <strong class="source-inline">queryBy*</strong> queries return <strong class="source-inline">null</strong> when an element is not found, allowing you to assert the expected absence of elements in the DOM without test failure. When we run our tests, we should receive the following output indicating our test suite passed:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="Images/Figure_3.16_B16887.jpg" alt="Figure 3.16 – No drink search passing test results&#13;&#10;" width="1095" height="432"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – No drink search passing test results</p>
			<p>The preceding screenshot shows that the <strong class="bold">renders mock drink data</strong>, <strong class="bold">renders no drink results</strong>, <strong class="bold">renders service unavailable</strong>, and <strong class="bold">prevents GET request when search input empty</strong> tests all passed in the <strong class="source-inline">DrinkSearch.test.js</strong> file. Now you know how to create a mock<a id="_idIndexMarker123"/> server with MSW to test components that request API data.</p>
			<p>Next, we will learn how to use MSW in development.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Using MSW in development</h2>
			<p>In addition to using MSW to mock HTTP responses<a id="_idIndexMarker124"/> in our tests, we can also create mock responses in development. The benefit of having a mock development server is building and testing the frontend even if the backend API is not complete. We need to know what the communication and data exchange will look like between the frontend and backend API to create the right mock responses.</p>
			<p>First, we need to add the service worker file to intercept HTTP requests made by our frontend and respond with mock data. The MSW documentation states we should install the file in the public directory of your project. Run the following command from the root of your project to install:</p>
			<p class="source-code">npx msw init public/</p>
			<p>The previous command automatically downloads the service worker file to the public folder. If you are using <strong class="source-inline">create-react-app</strong> to build your project, the <strong class="source-inline">public</strong> directory is located at the project's root. We do not need to do anything extra in the file once it's downloaded. Next, we need to create a file in the <strong class="source-inline">src/mocks/</strong> directory to set up and start the service<a id="_idIndexMarker125"/> worker, similar to what we did in the <em class="italic">Creating mock API data with MSW</em> section in this chapter.</p>
			<p>However, for the mock development server, we will make slight changes to how we set up the server:</p>
			<p class="source-code">import { rest, setupWorker } from 'msw'</p>
			<p class="source-code">const drinks = [</p>
			<p class="source-code">  {</p>
			<p class="source-code">    idDrink: '11457',</p>
			<p class="source-code">    strDrink: 'Gin Fizz',</p>
			<p class="source-code">    strInstructions:</p>
			<p class="source-code">      'Shake all ingredients with ice cubes, except soda </p>
			<p class="source-code">       water. Pour into glass. Top with soda water.',</p>
			<p class="source-code">    strDrinkThumb:</p>
			<p class="source-code">         'https://www.thecocktaildb.com/images/media/drink/</p>
			<p class="source-code">           drtihp1606768397.jpg',</p>
			<p class="source-code">    strIngredient1: 'Gin',</p>
			<p class="source-code">    strIngredient2: 'Lemon',</p>
			<p class="source-code">    strIngredient3: 'Powdered sugar',</p>
			<p class="source-code">    strIngredient4: 'Carbonated water'</p>
			<p class="source-code">  },</p>
			<p class="source-code">  </p>
			<p class="source-code">]</p>
			<p>In the preceding code, we import <strong class="source-inline">rest</strong> and <strong class="source-inline">setupWorker</strong> from <strong class="source-inline">msw</strong>. In the <em class="italic">Creating mock API data with MSW</em> section in this chapter, we imported modules from <strong class="source-inline">msw/node</strong> because our tests run in a Node.js environment. The mock development server will run in the browser, so we do not need to import the Node.js version. Next, we create a <strong class="source-inline">drinks</strong> array of drink data. Then, we set up the routes and responses for the server:</p>
			<p class="source-code">export const worker = setupWorker(</p>
			<p class="source-code">  rest.get(</p>
			<p class="source-code">    'https://www.thecocktaildb.com/api/json/v1/1/search.php',</p>
			<p class="source-code">    (req, res, ctx) =&gt; {</p>
			<p class="source-code">      return res(</p>
			<p class="source-code">        ctx.status(200),</p>
			<p class="source-code">        ctx.json({</p>
			<p class="source-code">          drinks</p>
			<p class="source-code">        })</p>
			<p class="source-code">      )</p>
			<p class="source-code">    }</p>
			<p class="source-code">  )</p>
			<p class="source-code">)</p>
			<p>We create a route handler in the <a id="_idIndexMarker126"/>preceding code to handle <em class="italic">GET</em> requests made to the URL attempting to access the cocktail API. We pass in the array of drinks as the response data. In the <em class="italic">Creating mock API data with MSW</em> section in this chapter, we split the server setup code and route handlers into separate files. We will keep all the server setup code in the same file for the mock development server to achieve the same result. The last thing we need to do is set up our application to run the mock server in the development environment:</p>
			<p class="source-code">if (process.env.NODE_ENV === 'development') {</p>
			<p class="source-code">  const { worker } = require('./mocks/browser')</p>
			<p class="source-code">  worker.start()</p>
			<p class="source-code">}</p>
			<p class="source-code">ReactDOM.render(</p>
			<p class="source-code">  &lt;React.StrictMode&gt;</p>
			<p class="source-code">    &lt;App /&gt;</p>
			<p class="source-code">  &lt;/React.StrictMode&gt;,</p>
			<p class="source-code">  document.getElementById('root')</p>
			<p class="source-code">)</p>
			<p>In the preceding code, we set up the server to start when the <strong class="source-inline">NODE_ENV</strong> environment variable is set to <strong class="source-inline">development</strong> before rendering the <strong class="source-inline">App</strong> component into the DOM. Applications built with <strong class="source-inline">create-react-app</strong> already set <strong class="source-inline">NODE_ENV</strong> to <strong class="source-inline">development</strong>, so all we need to do is start the application with the <strong class="source-inline">npm</strong> <strong class="source-inline">start</strong> script, typical when building <strong class="source-inline">create-react-app</strong> applications.</p>
			<p>Now you know how to<a id="_idIndexMarker127"/> create a mock server with MSW to test components that request API data. You also made an MSW server to respond with fake responses in development. Furthermore, you now know when to use the <strong class="source-inline">findBy*</strong> and <strong class="source-inline">queryBy*</strong> queries in addition to <strong class="source-inline">getBy*</strong> queries.</p>
			<p>In this section, we learned how to install and use MSW. We tested a component used for searching drinks data from an API. Finally, we learned how to use MSW as a development server. Next, we will learn how to use the test-driven development approach to writing tests.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Implementing test-driven development </h1>
			<p><strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) entails<a id="_idIndexMarker128"/> writing unit tests first and then building the code to pass. The TDD approach allows you to think about whether the code is correct for the tests you want to write. The process provides a perspective that focuses on the least amount of code needed to make tests pass. TDD is also known as <strong class="bold">Red, Green, Refactor</strong>. <em class="italic">Red</em> represents failing tests, <em class="italic">Green</em> represents passing tests, and as the name says, <em class="italic">Refactor</em> means refactoring the<a id="_idIndexMarker129"/> code while maintaining passing tests. A typical TDD workflow would be the following:</p>
			<ol>
				<li>Write a test.</li>
				<li>Run the test, expecting it to fail.</li>
				<li>Write the minimum amount of code to make the test pass.</li>
				<li>Rerun the test to verify it passes.</li>
				<li>Refactor the code as needed.</li>
				<li>Repeat steps <em class="italic">2</em> through <em class="italic">5</em> as needed.</li>
			</ol>
			<p>We can use React Testing Library to drive the development of React components using the TDD approach. First, we will use TDD to build the <strong class="source-inline">Vote</strong> component we introduced in a previous section in this chapter. Then, we will use TDD to create a <strong class="source-inline">Registration</strong> component.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Building the Vote component using TDD</h2>
			<p>In the <em class="italic">Testing components that call event handlers</em><span lang="en-US" xml:lang="en-US"> </span><em class="italic">in isolation</em> section, we built a <strong class="source-inline">Vote Button</strong> component by first building the component and then writing tests. In this section, we will use TDD to<a id="_idIndexMarker130"/> build the component. First, we plan out how the component should look when rendered into the DOM and the actions a user should take. We decide the component will be an image button. The parent component should pass the image source and image alt text into the component as <strong class="source-inline">props</strong>.</p>
			<p>The component will also accept a Boolean value passed for the <strong class="source-inline">hasVoted</strong> prop to set the button's state to <strong class="source-inline">enabled</strong> or <strong class="source-inline">disabled</strong>. If <strong class="source-inline">hasVoted</strong> is set to <strong class="source-inline">true</strong>, a user can click the button to invoke a method that will handle updating the vote count. Next, we write tests based on our design. The first test will verify the component renders to the screen with the <strong class="source-inline">props</strong> passed in:</p>
			<p class="source-code">  test('given image and vote status, renders button to </p>
			<p class="source-code">    screen', () =&gt; {</p>
			<p class="source-code">    const stubHandleVote = jest.fn()</p>
			<p class="source-code">    const stubAltText = 'vote like'</p>
			<p class="source-code">    render(</p>
			<p class="source-code">      &lt;VoteBtn</p>
			<p class="source-code">        handleVote={stubHandleVote}</p>
			<p class="source-code">        hasVoted={false}</p>
			<p class="source-code">        imgSrc={stubThumbsUp}</p>
			<p class="source-code">        altText={stubAltText}</p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">    )</p>
			<p class="source-code">    const image = screen.getByRole('img', { name: </p>
			<p class="source-code">      stubAltText })</p>
			<p class="source-code">    const button = screen.getByRole('button', { name: </p>
			<p class="source-code">      stubAltText })</p>
			<p>In the preceding code, first, we create <strong class="source-inline">jest</strong> functions and assign them to the <strong class="source-inline">stubHandleVote</strong> and <strong class="source-inline">stubAltText</strong> variables. We prepend the variable names with <em class="italic">stub</em> because we are only using them as dependency placeholders in the test. The variable names also provide<a id="_idIndexMarker131"/> more context for their purpose in the test.</p>
			<p>Next, we render the component with <strong class="source-inline">props</strong> values passed in. Then, we grab the <strong class="source-inline">image</strong> and <strong class="source-inline">button</strong> elements and assign them to associated variables. Next, we will make assertions:</p>
			<p class="source-code">    expect(image).toBeInTheDocument()</p>
			<p class="source-code">    expect(button).toBeInTheDocument()</p>
			<p class="source-code">    expect(button).toBeEnabled()</p>
			<p class="source-code">  })</p>
			<p>In the preceding code, we assert that the <strong class="source-inline">image</strong> and <strong class="source-inline">button</strong> elements are on the DOM. We also assert that the button state is <strong class="source-inline">enabled</strong>, meaning a user can click it. We create a file for the <strong class="source-inline">Vote Button</strong> component like so:</p>
			<p class="source-code">const VoteBtn = props =&gt; {</p>
			<p class="source-code">  return null</p>
			<p class="source-code">}</p>
			<p class="source-code">export default VoteBtn</p>
			<p>We create a <strong class="source-inline">VoteBtn</strong> component that doesn't currently return any code to render in the DOM in the preceding code. We also export the component to be used in other files. When we run the test, we get the following output from the test results:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="Images/Figure_3.17_B16887.jpg" alt="Figure 3.17 – TDD Vote Button test step 1&#13;&#10;" width="1147" height="156"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.17 – TDD Vote Button test step 1</p>
			<p>In the preceding<a id="_idIndexMarker132"/> screenshot, the <strong class="bold">given image and vote status, renders button to screen</strong> test failed. The failure output provides context for the failure that occurred when the test did not find an <strong class="source-inline">image</strong> element with the name <strong class="source-inline">vote like</strong> in the DOM. Since we know the image should be a child of a <strong class="source-inline">button</strong> element, next we will resolve the error by creating the <strong class="source-inline">button</strong> element with a child <strong class="source-inline">image</strong> element and pass in the required properties in the <strong class="source-inline">VoteBtn</strong> component file:</p>
			<p class="source-code">const VoteBtn = props =&gt; {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    <strong class="bold">&lt;button disabled={props.hasVoted}&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;img src={props.imgSrc} alt={props.altText} /&gt;</strong></p>
			<p class="source-code"><strong class="bold">    &lt;/button&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p class="source-code">export default VoteBtn</p>
			<p>In the previous code, we create a <strong class="source-inline">button</strong> element with the child <strong class="source-inline">image</strong> element and required <strong class="source-inline">props</strong> for the image source, alt text, and disabled attributes. Now when we run our test, we receive the following output:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="Images/Figure_3.18_B16887.jpg" alt="Figure 3.18 – TDD Vote Button test step 2&#13;&#10;" width="1140" height="323"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.18 – TDD Vote Button test step 2</p>
			<p>In the preceding <a id="_idIndexMarker133"/>screenshot, the <strong class="bold">given image and vote status, renders button to screen</strong> test now passes. For the next piece of <strong class="source-inline">Vote Button</strong>, we will write the code allowing a user to click the button to invoke a method that will handle updating the vote count when <strong class="source-inline">hasVoted</strong> is set to <strong class="source-inline">true</strong>. First, we will create another test to target the functionality:</p>
			<p class="source-code">  test('given clicked button, invokes handleVote', () =&gt; {</p>
			<p class="source-code">    const mockHandleVote = jest.fn()</p>
			<p class="source-code">    render(</p>
			<p class="source-code">      &lt;VoteBtn</p>
			<p class="source-code">        handleVote={mockHandleVote}</p>
			<p class="source-code">        hasVoted={false}</p>
			<p class="source-code">        imgSrc={stubThumbsUp}</p>
			<p class="source-code">        altText="vote like"</p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">    )</p>
			<p>In the preceding code, first, we create a <strong class="source-inline">jest</strong> function and assign it to the variable named <strong class="source-inline">mockHandleVote</strong>. We prepend the variable name with <em class="italic">mock</em> because we will assert against the variable later in the test. Next, we render the <strong class="source-inline">VoteBtn</strong> component into the DOM and pass in the required properties. Notice that we pass in <strong class="source-inline">mockHandleVote</strong> for the <strong class="source-inline">handleVote</strong> property. Next, we will click the button and make assertions:</p>
			<p class="source-code">    user.click(screen.getByRole('button', { name: /vote</p>
			<p class="source-code">      like/i }))</p>
			<p class="source-code">    expect(mockHandleVote).toHaveBeenCalled()</p>
			<p class="source-code">    expect(mockHandleVote).toHaveBeenCalledTimes(1)</p>
			<p class="source-code">  })</p>
			<p>In the preceding code, first, we<a id="_idIndexMarker134"/> click the button inside the component. Then, we assert that <strong class="source-inline">mockHandleVote</strong> was called and called precisely one time. Verifying if and how <strong class="source-inline">mockHandleVote</strong> was called is essential. If <strong class="source-inline">mockHandleVote</strong> is not called or is called more than once per click, we know the component will not correctly communicate when integrated with the parent component. We receive the following output when we run the test:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="Images/Figure_3.19_B16887.jpg" alt="Figure 3.19 – TDD Vote Button test step 3&#13;&#10;" width="1133" height="376"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.19 – TDD Vote Button test step 3</p>
			<p>In the preceding code, the <strong class="bold">given clicked button, invokes handleVote</strong> test fails. The test expected the <strong class="source-inline">jest</strong> function passed in the component to be called at least once, but it was never called. Next, we will resolve the error by adding the implementation to the component:</p>
			<p class="source-code">    &lt;button <strong class="bold">onClick={props.handleVote}</strong> disabled={props.        hasVoted}&gt;</p>
			<p>In the preceding code, we added an <strong class="source-inline">onClick</strong> event handler that will invoke the <strong class="source-inline">handleVote</strong> method passed into the component as a property when the button is clicked. Now when we run the test, we get the following output:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="Images/Figure_3.20_B16887.jpg" alt="Figure 3.20 – TDD Vote Button test step 4&#13;&#10;" width="1134" height="356"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.20 – TDD Vote Button test step 4</p>
			<p>In the preceding<a id="_idIndexMarker135"/> screenshot, the <strong class="bold">given clicked button, invokes handleVote</strong> test passes. Now that all our design plans for <strong class="source-inline">Vote Button</strong> have been implemented and tested, we have finished building the feature using the TDD approach.</p>
			<p>In the next section, we will use TDD to create a registration component.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Building a registration form using TDD</h2>
			<p>In the previous section, we<a id="_idIndexMarker136"/> used TDD to build a <strong class="source-inline">Vote</strong> component. In this section, we will use TDD to build a component used to create user accounts for a website. Then, once we build the minimal functionality to make the test pass, we will also refactor the component's implementation and verify the test continues to pass. The component will have a <strong class="bold">Register here</strong> <strong class="source-inline">heading</strong> element, <strong class="source-inline">email</strong> and <strong class="source-inline">password</strong> fields, and a <strong class="bold">Submit</strong> button. When the form is submitted, a <strong class="source-inline">handleSubmit</strong> method should be invoked. The final version of the component should look like the following:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="Images/Figure_3.21_B16887.jpg" alt="Figure 3.21 – Registration form" width="638" height="474"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.21 – Registration form</p>
			<p>In the preceding screenshot, we have a form allowing users to submit an email and password to register an account for a website. Now that we understand how the final version should <a id="_idIndexMarker137"/>look on the screen, we will write a test based on our design. For purposes of this section, we will verify that a <strong class="source-inline">handleRegister</strong> method is called when the form is submitted:</p>
			<p class="source-code">  test('given submitted form, invokes handleRegister', () </p>
			<p class="source-code">    =&gt; {</p>
			<p class="source-code">    const mockHandleRegister = jest.fn()</p>
			<p class="source-code">    const mockValues = {</p>
			<p class="source-code">      email: 'john@mail.com',</p>
			<p class="source-code">      password: '123'</p>
			<p class="source-code">    }</p>
			<p class="source-code">    render(&lt;Register handleRegister={mockHandleRegister} /&gt;)</p>
			<p>In the preceding code, we create <strong class="source-inline">mockHandleRegister</strong> and <strong class="source-inline">mockValues</strong> variables. The variables will be asserted against later in the test. Then, we render the component under test into the DOM and pass in <strong class="source-inline">mockHandleRegister</strong>. Now, <strong class="source-inline">mockHandleRegister</strong> will allow us to test the <strong class="source-inline">Register</strong> component in isolation from the <strong class="source-inline">handleRegister</strong> dependency. Next, we will enter values in the form fields:</p>
			<p class="source-code">user.type(screen.getByLabelText('Email Address'), </p>
			<p class="source-code">  mockValues.email)</p>
			<p class="source-code">user.type(screen.getByLabelText('Create Password'), </p>
			<p class="source-code">  mockValues.password)</p>
			<p class="source-code">user.click(screen.getByRole('button', { name: /submit/i }))</p>
			<p>In the preceding code, we <a id="_idIndexMarker138"/>enter values from the <strong class="source-inline">mockValues</strong> object into the <strong class="source-inline">email</strong> and <strong class="source-inline">password</strong> fields. Notice the use of string values passed into the <strong class="source-inline">getByLabelText</strong> queries. String values are another option for queries when you do not want to use a regular expression. Next, we will make assertions:</p>
			<p class="source-code">    expect(mockHandleRegister).toHaveBeenCalledTimes(1)</p>
			<p class="source-code">    expect(mockHandleRegister).toHaveBeenCalledWith({</p>
			<p class="source-code">      email: mockValues.email,</p>
			<p class="source-code">      password: mockValues.password</p>
			<p class="source-code">    })</p>
			<p class="source-code">  })</p>
			<p>In the preceding code, we expect <strong class="source-inline">mockHandleRegister</strong> to be called once. Finally, we expect values from the <strong class="source-inline">mockValues</strong> object to have been included as arguments when <strong class="source-inline">mockHandleRegister</strong> was called. Verifying the arguments passed to <strong class="source-inline">mockHandleRegister</strong> is important because it helps reduce the risk that form values will not be passed to <strong class="source-inline">handleRegister</strong>.</p>
			<p>Next, we will create a file for the <strong class="source-inline">Register</strong> component like so:</p>
			<p class="source-code">export default class Register extends React.Component {</p>
			<p class="source-code">  render() {</p>
			<p class="source-code">    return null</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>We create and export a <strong class="source-inline">Register</strong> component that doesn't currently return any code to render in the DOM in the preceding code. When we run the test, we get the following output from the test results:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="Images/Figure_3.22_B16887.jpg" alt="Figure 3.22 – TDD registration test step 1" width="1126" height="196"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.22 – TDD registration test step 1</p>
			<p>In the preceding<a id="_idIndexMarker139"/> screenshot, the <strong class="bold">given submitted form, invokes handleRegister</strong> test failed. The failure output provides context for the failure that occurred when the test did not find an <strong class="source-inline">email</strong> field element in the DOM. Next, we will resolve the error by creating the <strong class="source-inline">email</strong> field. We will also create the <strong class="source-inline">password</strong> field and the <strong class="bold">Submit</strong> button:</p>
			<p class="source-code">  state = {</p>
			<p class="source-code">    email: '',</p>
			<p class="source-code">    password: ''</p>
			<p class="source-code">  }</p>
			<p class="source-code">  handleChange = event =&gt; {</p>
			<p class="source-code">    const { id, value } = event.target</p>
			<p class="source-code">    this.setState(prevState =&gt; {</p>
			<p class="source-code">      return {</p>
			<p class="source-code">        ...prevState,</p>
			<p class="source-code">        [id]: value</p>
			<p class="source-code">      }</p>
			<p class="source-code">    })</p>
			<p class="source-code">  }</p>
			<p>In the preceding code, first, we create a <strong class="source-inline">state</strong> object to store values entered for the <strong class="source-inline">email</strong> and <strong class="source-inline">password</strong> fields. Next, we create a <strong class="source-inline">handleChange</strong> method that will be called anytime a user <a id="_idIndexMarker140"/>enters a value into a form field. The <strong class="source-inline">handleChange</strong> method will update <strong class="source-inline">state</strong> values based on the <strong class="source-inline">form</strong> field that is changed. Next, we create the <strong class="source-inline">heading</strong> element and an <strong class="source-inline">email</strong> field:</p>
			<p class="source-code">      &lt;main&gt;</p>
			<p class="source-code">        &lt;h1&gt;Register here&lt;/h1&gt;</p>
			<p class="source-code">        &lt;form&gt;</p>
			<p class="source-code">          &lt;div&gt;</p>
			<p class="source-code">            &lt;label htmlFor='email'&gt;Email Address&lt;/label&gt;</p>
			<p class="source-code">            &lt;input</p>
			<p class="source-code">              value={this.state.email}</p>
			<p class="source-code">              onChange={this.handleChange}</p>
			<p class="source-code">              type='email'</p>
			<p class="source-code">              id='email'</p>
			<p class="source-code">            /&gt;</p>
			<p class="source-code">          &lt;/div&gt;</p>
			<p>In the preceding code, first, we create a <strong class="source-inline">main</strong> element to wrap the <strong class="source-inline">heading</strong> and <strong class="source-inline">form</strong> elements. Inside <strong class="source-inline">main</strong>, we create the <strong class="bold">Register here</strong> heading. Then, we create a <strong class="source-inline">form</strong> element and add a field for users to enter an email address. When a user enters a value into the field, an <strong class="source-inline">onChange</strong> event handler is invoked to call <strong class="source-inline">handleChange</strong> to update the state object's associated value. The field's <strong class="source-inline">value</strong> attribute always displays the current value stored in the state object's associated key. Next, we will create a field for users to enter a password and a <strong class="source-inline">button</strong> element to submit the form:</p>
			<p class="source-code">          &lt;div&gt;</p>
			<p class="source-code">            &lt;label htmlFor='password'&gt;Create Password</p>
			<p class="source-code">              &lt;/label&gt;</p>
			<p class="source-code">            &lt;input</p>
			<p class="source-code">              value={this.state.password}</p>
			<p class="source-code">              onChange={this.handleChange}</p>
			<p class="source-code">              type='password'</p>
			<p class="source-code">              id='password'</p>
			<p class="source-code">            /&gt;</p>
			<p class="source-code">          &lt;/div&gt;</p>
			<p class="source-code">          &lt;button type='submit'&gt;Submit&lt;/button&gt;</p>
			<p class="source-code">        &lt;/form&gt;</p>
			<p class="source-code">      &lt;/main&gt;</p>
			<p>In the preceding code, first, we create a <strong class="source-inline">password</strong> field. The field has the same event handler methods as the <strong class="source-inline">email</strong> field. Finally, we make a <strong class="bold">Submit</strong> button to allow a user to submit values<a id="_idIndexMarker141"/> entered in the form. Now when we run the test, we get the following output:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="Images/Figure_3.23_B16887.jpg" alt="Figure 3.23 – TDD registration test step 2" width="1130" height="419"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.23 – TDD registration test step 2</p>
			<p>In the preceding code, our test is still failing, but for a different reason. Now the test can enter values and submit the form, but <strong class="source-inline">mockHandleRegister</strong> was not called with the submitted values. The failure happened because we have not yet implemented an <strong class="source-inline">onSubmit</strong> event handler to call our <strong class="source-inline">mockHandleRegister</strong> method and any other desired behavior when the form is submitted.</p>
			<p>Next, we will resolve the <a id="_idIndexMarker142"/>error by adding an <strong class="source-inline">onSubmit</strong> handler to the form and have it call a <strong class="source-inline">handleSubmit</strong> method that we will create:</p>
			<p class="source-code">  handleSubmit = event =&gt; {</p>
			<p class="source-code">    event.preventDefault()</p>
			<p class="source-code">    this.props.handleRegister(this.state)</p>
			<p class="source-code">  }</p>
			<p>In the preceding code, we create the <strong class="source-inline">handleSubmit</strong> method. When <strong class="source-inline">handleSubmit</strong> is invoked, the browser <strong class="source-inline">event</strong> that triggered the method is passed into it. Next, we prevent the browser's normal behavior of refreshing the page after submitting a form using the <strong class="source-inline">preventDefault</strong> method. Finally, we call <strong class="source-inline">handleRegister</strong>, provided to the component as <strong class="source-inline">props</strong>, and pass in the form values stored in the <strong class="source-inline">state</strong> object. Next, we will attach <strong class="source-inline">handleSubmit</strong> to the form:</p>
			<p class="source-code">        &lt;form onSubmit={this.handleSubmit}&gt;</p>
			<p>In the preceding code, we add an <strong class="source-inline">onSubmit</strong> event handler and pass in <strong class="source-inline">handleSubmit</strong>. When the form is submitted, <strong class="source-inline">handleSubmit</strong> will be called, resulting in <strong class="source-inline">handleRegister</strong> being called, with the form values as arguments. Now when we run the test, we get the following output:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="Images/Figure_3.24_B16887.jpg" alt="Figure 3.24 – TDD registration test step 3" width="1139" height="329"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.24 – TDD registration test step 3</p>
			<p>The preceding<a id="_idIndexMarker143"/> screenshot shows that our test is finally passing. Technically, we could stop here since our code makes our test pass. However, we can make our component code cleaner by converting it from a class component into a function component. As long as the behavior remains the same, our test should continue to pass. We can refactor the component like so:</p>
			<p class="source-code">const Register = props =&gt; {</p>
			<p class="source-code">  const [values, setValues] = React.useState({</p>
			<p class="source-code">    email: '',</p>
			<p class="source-code">    password: ''</p>
			<p class="source-code">  })</p>
			<p>In the preceding code, first, we convert the class into a function. Then, we use the <strong class="source-inline">useState</strong> hook to manage the form value state. Next, we will refactor our <strong class="source-inline">handleChange</strong> and <strong class="source-inline">handleSubmit</strong> methods:</p>
			<p class="source-code"> const handleChange = event =&gt; {</p>
			<p class="source-code">   const { id, value } = event.target</p>
			<p class="source-code">   setValues({ ...values, [id]: value })</p>
			<p class="source-code"> }</p>
			<p class="source-code"> const handleSubmit = event =&gt; {</p>
			<p class="source-code">   event.preventDefault()</p>
			<p class="source-code">   props.handleRegister(values)</p>
			<p class="source-code"> }</p>
			<p>In the previous code, the <strong class="source-inline">handleChange</strong> class and <strong class="source-inline">handleSubmit</strong> methods are converted to function expressions. The <strong class="source-inline">handleChange</strong> method calls <strong class="source-inline">setValues</strong> to update the state for each entered form value. The implementation of <strong class="source-inline">handleSubmit</strong> is virtually the<a id="_idIndexMarker144"/> same as the class version. Next, we will refactor the returned code that renders as HTML in the browser:</p>
			<p class="source-code">&lt;main className="m-3 d-flex flex-column"&gt;</p>
			<p class="source-code">      &lt;h1&gt;Register here&lt;/h1&gt;</p>
			<p class="source-code">      &lt;form onSubmit={handleSubmit}&gt;</p>
			<p class="source-code">        &lt;div&gt;</p>
			<p class="source-code">          &lt;label htmlFor="email"&gt;Email Address&lt;/label&gt;</p>
			<p class="source-code">          &lt;input</p>
			<p class="source-code">            value={values.email}</p>
			<p class="source-code">            onChange={handleChange}</p>
			<p class="source-code">// the rest of the component code ...   </p>
			<p>In the preceding code, first, we remove the <strong class="source-inline">render</strong> method required in <strong class="source-inline">class</strong> components. The remainder of the code is very similar to the class version. However, the <strong class="source-inline">value</strong> attribute uses the <strong class="source-inline">values</strong> object, and the <strong class="source-inline">handleChange</strong> method passed in to the <strong class="source-inline">onChange</strong> event handler does not need to include the <strong class="source-inline">this</strong> keyword. When we rerun our test, we get the following result:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="Images/Figure_3.25_B16887.jpg" alt="Figure 3.25 – TDD registration test step 4" width="1137" height="328"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.25 – TDD registration test step 4</p>
			<p>In the preceding <a id="_idIndexMarker145"/>screenshot, our test still passes after the refactor. The <strong class="source-inline">refactor</strong> component made our code a lot cleaner. Now you understand how to build a component using TDD with React Testing Library. In this section, we used TDD to drive the creation of vote and registration features. The test result feedback that React Testing Library provides makes for a pleasant experience to guide development.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Summary</h1>
			<p>In this chapter, you learned how to install and use a module to simulate user actions on the resulting DOM output for components. You can now install and test features that interact with APIs with a user-friendly tool. You understand how to test components in isolation from event handler dependencies with mock functions. Finally, you learned how to implement the TDD approach to building features combined with React Testing Library.</p>
			<p>In the next chapter, we will dive deeper by learning the benefits of integration testing. We will also learn how to test React components that utilize popular third-party libraries.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Questions</h1>
			<ol>
				<li value="1">Why should you favor <strong class="source-inline">user-event</strong> over <strong class="source-inline">fireEvent</strong> to simulate user actions in your tests?</li>
				<li>Explain how MSW allows you to test components that make requests to APIs.</li>
				<li>What is a mock function?</li>
				<li>Explain the application risk associated with testing components in isolation with mock functions.</li>
				<li>In your own words, describe the TDD workflow.</li>
				<li>Explain when to use a <strong class="source-inline">getBy*</strong>, <strong class="source-inline">findBy*</strong>, or <strong class="source-inline">queryBy*</strong> query to select an element.</li>
			</ol>
		</div>
	</div></body></html>