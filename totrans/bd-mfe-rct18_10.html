<html><head></head><body>
		<div id="_idContainer056" class="calibre2">
			<h1 id="_idParaDest-105" class="chapter-number"><a id="_idTextAnchor104" class="pcalibre1 calibre6 pcalibre"/>7</h1>
			<h1 id="_idParaDest-106" class="calibre7"><a id="_idTextAnchor105" class="pcalibre1 calibre6 pcalibre"/>Deploying Microfrontends to Static Storage</h1>
			<p class="calibre3">Things start to get interesting from this chapter on, because we are now stepping out of the frontend/React world and moving into the areas of cloud and full life <span>cycle engineering.</span></p>
			<p class="calibre3">As you may recollect from earlier chapters of this book, one of the primary goals of a microfrontend architecture is to ensure that we don’t need to deploy the entire application each time a small change is made but instead only deploy the micro apps that have changed. Hence, a book on microfrontends wouldn’t be deemed complete unless we covered the critical topic of deploying our microfrontend to production in the <span>right way.</span></p>
			<p class="calibre3">When it comes to deploying SPAs, usually we run the webpack <strong class="source-inline">build</strong> command to generate our JavaScript bundles and assets in the <strong class="source-inline">/build</strong> or <strong class="source-inline">/dist</strong> folder, which we then simply copy to a static website hosting provider to make our app available to our users. However, deploying microfrontends is a bit <span>more complex.</span></p>
			<p class="calibre3">In this chapter, we will see how to deploy the client-side-rendered microfrontend we built in <a href="B18987_05.xhtml#_idTextAnchor073" class="pcalibre1 calibre6 pcalibre"><span><em class="italic">Chapter 5</em></span></a> to a static storage cloud provider such as Firebase. We will cover the <span>following topics:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Understanding what static <span>storage is</span></li>
				<li class="calibre14">Setting up <span>Firebase Hosting</span></li>
				<li class="calibre14">Learning how to build production bundles <span>with Nx</span></li>
				<li class="calibre14">Learning how to only build and deploy <span>modified apps</span></li>
			</ul>
			<p class="calibre3">By the end of this chapter, we will have our microfrontend apps running on Firebase, and we will have also created scripts that only build and deploy the apps that have <span>been modified.</span></p>
			<h1 id="_idParaDest-107" class="calibre7"><a id="_idTextAnchor106" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
			<p class="calibre3">As we go through the code examples in this chapter, we will need <span>the following:</span></p>
			<ul class="calibre15">
				<li class="calibre14">A PC, Mac, or Linux desktop/laptop with at least 8 GB of RAM (16 <span>GB preferred)</span></li>
				<li class="calibre14">An Intel chipset i5+ or Mac <span>M1+ chipset</span></li>
				<li class="calibre14">At least 256 GB of free hard <span>disk storage</span></li>
			</ul>
			<p class="calibre3">You will also need the following software installed on <span>your computer:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Node.js version 18+ (use <strong class="source-inline1">nvm</strong> to manage different versions of Node.js if you <span>have to)</span></li>
				<li class="calibre14">Terminal: iTerm2 with OhMyZsh (you will thank <span>me later)</span></li>
				<li class="calibre14">IDE: We strongly recommend VS Code as we will be making use of some of the plugins that come with VS Code for an improved <span>developer experience</span></li>
				<li class="calibre14">npm, Yarn, or pnpm: We recommend pnpm because it’s fast and <span>storage efficient</span></li>
				<li class="calibre14">Browser: Chrome/Microsoft <span>Edge, Firefox</span></li>
				<li class="calibre14">A basic understanding of <span>Nx.dev monorepos</span></li>
				<li class="calibre14">A basic understanding of Firebase and static site hosting would <span>be helpful</span></li>
			</ul>
			<p class="calibre3">The code files for this chapter can be <span>found here:</span></p>
			<p class="calibre3"><a href="https://github.com/PacktPublishing/Building-Micro-Frontends-with-React" class="pcalibre1 calibre6 pcalibre"><span>https://github.com/PacktPublishing/Building-Micro-Frontends-with-React</span></a></p>
			<p class="calibre3">We also assume you have a basic working knowledge of Git, such as branching, committing code, and raising a <span>pull request.</span></p>
			<h1 id="_idParaDest-108" class="calibre7"><a id="_idTextAnchor107" class="pcalibre1 calibre6 pcalibre"/>What is Static Storage?</h1>
			<p class="calibre3">Cloud hosting providers<a id="_idIndexMarker297" class="pcalibre1 calibre6 pcalibre"/> such as AWS, Google, and Azure offer a variety of hosting<a id="_idIndexMarker298" class="pcalibre1 calibre6 pcalibre"/> solutions. Static storage, also known as blob storage, refers to a type of storage service that is optimized<a id="_idIndexMarker299" class="pcalibre1 calibre6 pcalibre"/> for storing large amounts of unstructured data, such as <strong class="bold">Binary Large Objects</strong> (<strong class="bold">Blob</strong>). This data can be of any type, including images, videos, audio files, and text file formats such as HTML, CSS, <span>and JavaScript.</span></p>
			<p class="calibre3">Static storage is designed<a id="_idIndexMarker300" class="pcalibre1 calibre6 pcalibre"/> to be highly scalable and is usually served via a <strong class="bold">Content Delivery Network</strong> (<strong class="bold">CDN</strong>). This allows it to handle large volumes of data without performance degradation, and also makes it highly durable, with data replication across different nodes to ensure that data is not lost due to hardware failures or <span>other disruptions.</span></p>
			<p class="calibre3">A key point to keep in mind about static storage is that it doesn’t have any compute power; that is, it doesn’t have any CPU or RAM resources. It can only serve static files. Think of it like a very large external hard disk connected to <span>the cloud.</span></p>
			<p class="calibre3">Historically, static storage has been used to store and serve images, JavaScript, or CSS files, or as backup storage. It was never an option to host web apps. However, with the advent of SPAs that execute on the browser, frontend engineers realized they could use storage to host JavaScript and CSS bundles and have the apps execute and run on the browser. Most hosting providers now officially offer static site hosting. Some popular static site hosting providers are <span>the following:</span></p>
			<ul class="calibre15">
				<li class="calibre14"><span>Firebase</span></li>
				<li class="calibre14"><span>Netlify</span></li>
				<li class="calibre14"><span>Cloudflare</span></li>
				<li class="calibre14">Azure Static <span>Web Apps</span></li>
				<li class="calibre14">Google <span>Cloud Storage</span></li>
				<li class="calibre14"><span>Amazon S3</span></li>
			</ul>
			<p class="calibre3">Due to its simplicity and very low costs, static storage is ideal for serving client-side-rendered (CSR) React apps. Due to the lack of compute<a id="_idIndexMarker301" class="pcalibre1 calibre6 pcalibre"/> power, they cannot<a id="_idIndexMarker302" class="pcalibre1 calibre6 pcalibre"/> be used to serve backend or node-based APIs, or to execute <strong class="bold">server-side </strong><span><strong class="bold">rendering</strong></span><span> (</span><span><strong class="bold">SSR</strong></span><span>).</span></p>
			<p class="calibre3">In our case, since our microfrontend is client-side-rendered, we will use it to deploy <span>our apps.</span></p>
			<p class="calibre3">Of the various hosting options available, we will choose Firebase for our hosting solution, and in the next section, we will go about setting up our <span>Firebase application.</span></p>
			<p class="calibre3">Just a note that deploying<a id="_idIndexMarker303" class="pcalibre1 calibre6 pcalibre"/> the microfrontend to any other hosting provider will follow a similar process to what we will go through in the rest of the sections of <span>this chapter.</span></p>
			<h1 id="_idParaDest-109" class="calibre7"><a id="_idTextAnchor108" class="pcalibre1 calibre6 pcalibre"/>Setting up Firebase</h1>
			<p class="calibre3">Firebase, which is part of Google Cloud<a id="_idIndexMarker304" class="pcalibre1 calibre6 pcalibre"/> Platform, is an extremely easy-to-use and developer-friendly hosting provider. Firebase has a lot of offerings and services for building and managing web and <span>mobile applications.</span></p>
			<p class="calibre3">Many of these services have free tiers, which make it ideal for building and testing things out. You can access<a id="_idIndexMarker305" class="pcalibre1 calibre6 pcalibre"/> all the products and services by heading over to <a href="https://www.firebase.com" class="pcalibre1 calibre6 pcalibre">www.firebase.com</a> and logging in with your <span>Google account.</span></p>
			<p class="calibre3">Once you’ve logged in to Firebase, head over to <strong class="bold">Manage </strong><span><strong class="bold">Console</strong></span><span> (</span><a href="https://console.firebase.google.com/" class="pcalibre1 calibre6 pcalibre"><span>https://console.firebase.google.com/</span></a><span>).</span></p>
			<p class="calibre3">Create a new project. Let's call it <strong class="source-inline">ebuy</strong>. In the next section, we will set up our sites within <span>this project.</span></p>
			<h2 id="_idParaDest-110" class="calibre5"><a id="_idTextAnchor109" class="pcalibre1 calibre6 pcalibre"/>Setting up a project with multiple sites</h2>
			<p class="calibre3">We will be using Firebase’s hosting service<a id="_idIndexMarker306" class="pcalibre1 calibre6 pcalibre"/> to deploy our apps. If you are not familiar<a id="_idIndexMarker307" class="pcalibre1 calibre6 pcalibre"/> with Firebase Hosting, we strongly encourage you to head over to <a href="https://firebase.google.com/docs/hosting" class="pcalibre1 calibre6 pcalibre">https://firebase.google.com/docs/hosting</a> and read <span>about it:</span></p>
			<ol class="calibre13">
				<li class="calibre14">Once in the console, select the <span><strong class="bold">ebuy</strong></span><span> project.</span></li>
				<li class="calibre14">Head over to the <strong class="bold">Build</strong> | <strong class="bold">Hosting</strong> link on the left navigation pane. Click on the <strong class="bold">Get Started</strong> button to start the wizard and follow the steps to create a new site within the <span><strong class="bold">ebuy</strong></span><span> project.</span></li>
				<li class="calibre14">We are going to need a new site for every micro app that we build, so on the Dashboard page use the <strong class="bold">Add another site</strong> and go ahead and create five sites. For the sake of consistency in this chapter, let’s name them <span>as follows:</span><ul class="calibre16"><li class="calibre14"><span><strong class="source-inline1">ebuy-app-shell.web.app</strong></span></li><li class="calibre14"><span><strong class="source-inline1">ebuy-catalog.web.app</strong></span></li><li class="calibre14"><span><strong class="source-inline1">ebuy-checkout.web.app</strong></span></li><li class="calibre14"><span><strong class="source-inline1">ebuy-recommendations.web.app</strong></span></li><li class="calibre14"><span><strong class="source-inline1">ebuy-datastore.web.app</strong></span></li></ul></li>
			</ol>
			<p class="calibre3">Note that these names need to be unique to the entirety of Firebase. If the name is taken (and most likely it would have been taken), you can choose suitable names or go with the recommendation<a id="_idIndexMarker308" class="pcalibre1 calibre6 pcalibre"/> <span>Firebase provides.</span></p>
			<p class="calibre3">Once you’ve created these five sites, note down the URLs at which these sites will be available, as we will need <span>them later.</span></p>
			<h2 id="_idParaDest-111" class="calibre5"><a id="_idTextAnchor110" class="pcalibre1 calibre6 pcalibre"/>Installing and configuring the Firebase CLI</h2>
			<p class="calibre3">Next, we need to install<a id="_idIndexMarker309" class="pcalibre1 calibre6 pcalibre"/> Firebase tools and connect them to our project<a id="_idIndexMarker310" class="pcalibre1 calibre6 pcalibre"/> <span>and site:</span></p>
			<ol class="calibre13">
				<li class="calibre14">In the terminal, run <strong class="source-inline1">npm install -</strong><span><strong class="source-inline1">g firebase-tools</strong></span><span>.</span></li>
				<li class="calibre14">Then, run <strong class="source-inline1">firebase login</strong>. This will open up a browser window and request you to log in to your <span>Firebase account.</span></li>
				<li class="calibre14">Run <strong class="source-inline1">firebase init hosting</strong>. This will take you through a series of steps. If all goes well, then you will see new <strong class="source-inline1">.firebaserc</strong> and <strong class="source-inline1">firebase.json</strong> <span>files created.</span></li>
				<li class="calibre14">Next, we need to let Firebase know which micro app should be deployed to which target site. We do this by running the following commands. The syntax looks <span>as follows:</span><pre class="source-code">
<strong class="bold1">firebase target:apply hosting &lt;micro-app-name&gt; &lt;firebase-site-name</strong></pre></li>				<li class="calibre14">So, in our case, given the names we have for our micro apps and the websites created within Firebase, our commands would look <span>as follows:</span><ol class="calibre17"><li class="calibre14"><strong class="source-inline1">firebase target:apply hosting </strong><span><strong class="source-inline1">app-shell ebuy-app-shell</strong></span></li><li class="calibre14"><strong class="source-inline1">firebase target:apply hosting </strong><span><strong class="source-inline1">catalog ebuy-catalog</strong></span></li><li class="calibre14"><strong class="source-inline1">firebase target:apply hosting </strong><span><strong class="source-inline1">checkout ebuy-checkout</strong></span></li><li class="calibre14"><strong class="source-inline1">firebase target:apply hosting recommendations </strong><span><strong class="source-inline1">ebuy-recommendations</strong></span></li><li class="calibre14"><strong class="source-inline1">firebase target:apply hosting </strong><span><strong class="source-inline1">store ebuy-datastore</strong></span></li></ol></li>
			</ol>
			<p class="calibre3">Once these commands have been executed successfully, you’ll notice these entries being made in the <strong class="source-inline">.</strong><span><strong class="source-inline">firebaserc</strong></span><span> file.</span></p>
			<p class="calibre3">This completes<a id="_idIndexMarker311" class="pcalibre1 calibre6 pcalibre"/> our setup on the Firebase<a id="_idIndexMarker312" class="pcalibre1 calibre6 pcalibre"/> side of things. In the next section, we will prepare our microfrontend for <span>production builds.</span></p>
			<h1 id="_idParaDest-112" class="calibre7"><a id="_idTextAnchor111" class="pcalibre1 calibre6 pcalibre"/>Creating the Microfrontend Production build</h1>
			<p class="calibre3">As you may recollect, so far, we’ve only run<a id="_idIndexMarker313" class="pcalibre1 calibre6 pcalibre"/> and tested our microfrontends in development mode, using the <strong class="source-inline">nx serve</strong> command. For us to deploy applications to a hosting server, they need to be built in <span>production mode.</span></p>
			<p class="calibre3">This is usually quite straightforward in regular React apps, but with our microfrontends, it needs a bit <span>more work.</span></p>
			<p class="calibre3">Open up the ebuy app we built in <a href="B18987_05.xhtml#_idTextAnchor073" class="pcalibre1 calibre6 pcalibre"><span><em class="italic">Chapter 5</em></span></a> and follow these steps. Let's first create a script command<a id="_idIndexMarker314" class="pcalibre1 calibre6 pcalibre"/> to build all <span>our apps:</span></p>
			<ol class="calibre13">
				<li class="calibre14">Open up the <strong class="source-inline1">package.json</strong> file on the root and just like the <strong class="source-inline1">serve:all</strong> command, let's create a new command for <strong class="source-inline1">build:all</strong> <span>as follows:</span><pre class="source-code">
"build:all": "nx run-many --target=build"</pre></li>				<li class="calibre14">Run the <strong class="source-inline1">pnpm build:all</strong> command and let us see whether all the apps build. Oops! You’ll notice while all the other apps built fine, <strong class="source-inline1">app-shell</strong> threw out some error about not being able to find <strong class="source-inline1">catalog/Module</strong> or <strong class="source-inline1">checkout/Module</strong>, and <span>so on.</span><p class="calibre3">Let's dig a bit <span>into it.</span></p></li>
				<li class="calibre14">Open up the <strong class="source-inline1">/apps/app-shell/project.json</strong> file and have a look at the build scripts object. You will notice that it uses a different <strong class="source-inline1">webpackConfig</strong> file for production builds, namely the one located <span>here: </span><span><strong class="source-inline1">apps/app-shell/webpack.config.prod.js</strong></span><span>.</span><p class="calibre3">Let's open up this file and have a look. In there, you will notice that the <strong class="source-inline">remotes</strong> array is blank. This is the reason why our app-shell build command is failing, because webpack doesn’t know the path from where it needs to fetch the <span><strong class="source-inline">remoteEntry.js</strong></span><span> file.</span></p></li>
				<li class="calibre14">Let's add our list of remotes to this array. This should mirror the list of apps in the remotes array of our <span><strong class="source-inline1">module-federation.config</strong></span><span> file.</span><p class="calibre3">When entering these remote paths, since module-federation is now going to pick them from a publicly hosted URL, we will need to use the full path for where these <strong class="source-inline">remoteEntry</strong> files <span>will exist.</span></p></li>
				<li class="calibre14">We update the remotes array in <strong class="source-inline1">apps/app-shell/webpack.config.prod.js</strong> <span>as follows:</span><pre class="source-code">
  remotes: [
    ['catalog', 'https://ebuy-catalog.web.app/'],
    ['checkout', 'https://ebuy-checkout.web.app/'],
    ['store', 'https://ebuy-datastore.web.app/'],
  ]</pre></li>				<li class="calibre14">Now, rerun the <strong class="source-inline1">pnpm build:all</strong> command and verify that all the apps <span>build successfully.</span><p class="calibre3">Our work isn’t fully done yet. As you will recollect, our <strong class="source-inline">catalog</strong> and <strong class="source-inline">recommendations</strong> apps also need the array of remotes in their <span><strong class="source-inline">webpack.config.prod.js</strong></span><span> files.</span></p><p class="calibre3">We also notice that because our catalog and checkout apps were not originally built as microfrontend remote apps, they have a slightly different configuration and are missing <strong class="source-inline">webpack.config.prod.js</strong> files. Let's fix <span>that first.</span></p></li>
				<li class="calibre14">First and foremost, let’s copy<a id="_idIndexMarker315" class="pcalibre1 calibre6 pcalibre"/> and paste the <strong class="source-inline1">webpack.config.prod.js</strong> files from the <strong class="source-inline1">app-shell</strong> app into our catalog, checkout and <span>recommendations apps.</span><p class="calibre3">Then, we need to let the builder know that we want webpack to pick up the configurations from this <strong class="source-inline">.prod.js</strong> file when building the <span>production builds.</span></p></li>
				<li class="calibre14">So, in their respective <strong class="source-inline1">project.json</strong> files, we add the following line within the <strong class="source-inline1">build &gt; configuration &gt; production</strong> object, <span>as follows:</span><pre class="source-code">
//apps/catalog/project.json
 . . .
"vendorChunk": false,
<strong class="bold1">  "webpackConfig": "apps/catalog/webpack.config.prod.js"</strong>
        },
//apps/checkout/project.json
 . . .
"vendorChunk": false,
  <strong class="bold1">"webpackConfig": "apps/checkout/webpack.config.prod.js"</strong>
        },</pre><p class="calibre3">This will now ensure that all apps use their corresponding <strong class="source-inline">webpack.config.prod.js</strong> file to run their <span>production builds.</span></p></li>				<li class="calibre14">Now, let's go and update<a id="_idIndexMarker316" class="pcalibre1 calibre6 pcalibre"/> the array for the remote paths in our <strong class="source-inline1">apps/catalog/webpack.config.prod.js</strong> file. Since the catalog app has only one remote, which is the recommendations micro app, our remotes array would look <span>like this:</span><pre class="source-code">
  remotes: [
    ['recommendations', 'https://ebuy-recommendations.web.app/'],
  ],</pre><p class="calibre3">Next, let's do the same for our recommendations apps, which use the <strong class="source-inline">store</strong> micro app as a remote. So, in the <strong class="source-inline">apps/recommendations/webpack.config.prod.js</strong> file, we update the remotes array <span>as follows:</span></p><pre class="source-code">  remotes: [
    [‘store’, 'https://ebuy-datastore.web.app/'],
  ],</pre></li>				<li class="calibre14">10. Since the checkout app also needs to use the store as a remote we update the <strong class="source-inline1">apps/checkout/webpack.config.prod.js</strong> <span>as follows:</span><pre class="source-code">
  remotes: [
    [‘store’, 'https://ebuy-datastore.web.app/'],
  ],</pre></li>				<li class="calibre14">Run our <strong class="source-inline1">pnpm build:all</strong> command again to generate the production builds based on the latest webpack configurations <span>we made.</span></li>
			</ol>
			<p class="calibre3">When the build is successful, have a look in the <strong class="source-inline">/dist</strong> folder on the root of the project and verify that all our micro-app folders are present within <strong class="source-inline">/dist/apps</strong>. Note their paths as we will need<a id="_idIndexMarker317" class="pcalibre1 calibre6 pcalibre"/> them in the <span>next section.</span></p>
			<p class="calibre3">In this section, we were able to generate production builds for our microfrontends by ensuring all the apps used the right webpack configuration, including the correct public URLs for the <span><strong class="source-inline">remoteEntry.js</strong></span><span> files.</span></p>
			<p class="calibre3">In the next section, we will see how to deploy these apps <span>to Firebase.</span></p>
			<h1 id="_idParaDest-113" class="calibre7"><a id="_idTextAnchor112" class="pcalibre1 calibre6 pcalibre"/>Deploying our Apps to Firebase</h1>
			<p class="calibre3">Deploying our apps to Firebase<a id="_idIndexMarker318" class="pcalibre1 calibre6 pcalibre"/> is quite easy using the Firebase CLI’s <strong class="source-inline">deploy</strong> command. However, before<a id="_idIndexMarker319" class="pcalibre1 calibre6 pcalibre"/> we run our Firebase <strong class="source-inline">deploy</strong> command, we need to let Firebase know which micro-apps go into the corresponding Firebase website. We do this in the <strong class="source-inline">/</strong><span><strong class="source-inline">firebase.json</strong></span><span> file.</span></p>
			<p class="calibre3">Replace the default configuration with <span>the following:</span></p>
			<pre class="source-code">
 {
  "hosting": [
    {
      "target": "app-shell",
      "public": "dist/apps/app-shell",
      "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
      "rewrites": [
        {
          "source": "**",
          "destination": "/index.html"
        }
      ]
    }
    {
      "target": "catalog",
      "public": "dist/apps/catalog",
      "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
      "rewrites": [
        {
          "source": "**",
          "destination": "/index.html"
        }
      ]
    },
    {
      "target": "checkout",
      "public": "dist/apps/checkout",
      "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
      "rewrites": [
        {
          "source": "**",
          "destination": "/index.html"
        }
      ]
    },
    {
      "target": "recommendations",
      "public": "dist/apps/recommendations",
      "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
      "rewrites": [
        {
          "source": "**",
          "destination": "/index.html"
        }
      ],
    },
    {
      "target": "store",
      "public": "dist/apps/store",
      "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
      "rewrites": [
        {
          "source": "**",
          "destination": "/index.html"
        }
      ]
    }
  ]
}</pre>			<p class="calibre3">As you can see, the preceding code is a configuration, where we have an array of our target apps, and we define the folder path where Firebase should look for the bundles for each of the micro apps. We also have a few settings regarding ignoring and not deploying <strong class="source-inline">node_modules</strong> and a rewrite rule, which is essential if you want each micro app to also be available as its own SPA within its <span>respective site.</span></p>
			<p class="calibre3">With this, we are now ready to deploy our apps to Firebase. Let's first run it manually to ensure things <span>work fine.</span></p>
			<p class="calibre3">In the terminal of the project, run the <span>following command:</span></p>
			<pre class="source-code">
firebase deploy --only hosting</pre>			<p class="calibre3">This would generate a <strong class="source-inline">.firebase</strong> folder with a lot of files. Don’t forget to add <strong class="source-inline">.firebase</strong> to <span>your </span><span><strong class="source-inline">.gitignore</strong></span><span>.</span></p>
			<p class="calibre3">Let Firebase do its thing, and if all goes well, it should display a success message and print out the list of URLs where the sites have been deployed, <span>like so:</span></p>
			<div class="calibre2">
				<div id="_idContainer052" class="img---figure">
					<img src="image/Figure_7.01_B18987.jpg" alt="Figure 7.1 – List of website URLs published after a successful deployment on Firebase" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.1 – List of website URLs published after a successful deployment on Firebase</p>
			<p class="calibre3">Great! Let’s click on the <strong class="source-inline">app-shell</strong> link and check whether we can see <span>our microfrontend.</span></p>
			<p class="calibre3">Err, we see a blank page... Have a peek into the browser’s developer<a id="_idIndexMarker320" class="pcalibre1 calibre6 pcalibre"/> tools console and you’ll notice<a id="_idIndexMarker321" class="pcalibre1 calibre6 pcalibre"/> what the problem is. Our browser<a id="_idIndexMarker322" class="pcalibre1 calibre6 pcalibre"/> has blocked calls to the <strong class="source-inline">remoteEntry.js</strong> files because of <strong class="bold">Cross-Origin Resource </strong><span><strong class="bold">Sharing</strong></span><span> (</span><span><strong class="bold">CORS</strong></span><span>).</span></p>
			<div class="calibre2">
				<div id="_idContainer053" class="img---figure">
					<img src="image/Figure_7.02_B18987.jpg" alt="Figure 7.2 – CORS policy headers due to missing Access-Control-Allow-Origin header" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.2 – CORS policy headers due to missing Access-Control-Allow-Origin header</p>
			<p class="calibre3">We will see how to fix this in the <span>next section.</span></p>
			<h2 id="_idParaDest-114" class="calibre5"><a id="_idTextAnchor113" class="pcalibre1 calibre6 pcalibre"/>Fixing CORS issues</h2>
			<p class="calibre3">If you’ve been building React<a id="_idIndexMarker323" class="pcalibre1 calibre6 pcalibre"/> or any other web apps, you’ll be familiar with the dreaded CORS problem. This is where the browser, for security reasons, prevents calls to external domains unless it sees an explicit <strong class="source-inline">'Access-Control-Allow-Origin'</strong> header. The access control is set on the apps that decide whether they want assets from their domain to be consumed and executed on <span>other domains.</span></p>
			<p class="calibre3">So, for our microfrontend apps to work properly, the host app needs to be able to load the <strong class="source-inline">remoteEntry.js</strong> file from the public URL where each of the micro apps is hosted. This is what we are going to set in the <span>next steps.</span></p>
			<p class="calibre3">With Firebase Hosting, it is quite easy, and we can define a headers array in the <span><strong class="source-inline">firebase.json</strong></span><span> file.</span></p>
			<p class="calibre3">Open up <strong class="source-inline">/firebase.json</strong> for all the apps except <strong class="source-inline">app-shell</strong>, and within each of the target objects, define the headers we’d like <span>to set:</span></p>
			<pre class="source-code">
      "headers": [
        {
          "source": "**/*.@(eot|otf|ttf|ttc|woff||woff2|js|font.css|remoteEntry.js)",
          <strong class="bold1">"headers": [</strong>
<strong class="bold1">            {</strong>
<strong class="bold1">              "key": "Access-Control-Allow-Origin",</strong>
<strong class="bold1">              "value": "https://ebuy-app-shell.web.app"</strong>
<strong class="bold1">            }</strong>
<strong class="bold1">          ]</strong>
<strong class="bold1">        }</strong>
<strong class="bold1">      ]</strong></pre>			<p class="calibre3">What we are basically saying here is each of the micro apps allows the list of defined file types to be called and executed <span>from </span><span><strong class="source-inline">https://ebuy-app-shell.web.app</strong></span><span>.</span></p>
			<p class="calibre3">Note that we need to add the headers array for every target app defined within the <span><strong class="source-inline">firebase.json</strong></span><span> file.</span></p>
			<p class="calibre3">Rerun <strong class="source-inline">firebase deploy --only hosting</strong> and now, you should<a id="_idIndexMarker324" class="pcalibre1 calibre6 pcalibre"/> be able to view all the sites working <span>on </span><span><strong class="source-inline">https://ebuy-app-shell.web-app/</strong></span><span>.</span></p>
			<h2 id="_idParaDest-115" class="calibre5"><a id="_idTextAnchor114" class="pcalibre1 calibre6 pcalibre"/>Deploying only the selected target</h2>
			<p class="calibre3">Currently, the <strong class="source-inline">firebase</strong> command deploys<a id="_idIndexMarker325" class="pcalibre1 calibre6 pcalibre"/> all the micro-apps. If we wanted to deploy only one of the micro apps, we’d simply need to pass the target name as <span>an argument:</span></p>
			<pre class="console">
firebase deploy --only hosting:&lt;app-name&gt;</pre>			<p class="calibre3">So, if we wanted to deploy only <strong class="source-inline">app-shell</strong>, our command would look <span>as follows:</span></p>
			<pre class="console">
firebase deploy --only hosting:app-shell</pre>			<p class="calibre3">This will be critical in the <span>next section.</span></p>
			<p class="calibre3">Looking back at this section, we were able to deploy our apps to Firebase, and we also managed to fix the CORSs issue by setting <strong class="source-inline">Access-Control-Allow-Origin</strong> headers. We also saw the CLI syntaxes<a id="_idIndexMarker326" class="pcalibre1 calibre6 pcalibre"/> that allow us to deploy only the apps that <span>we need.</span></p>
			<p class="calibre3">In the next section, we will use these CLI commands in combination with another nifty command from Nx to control and deploy only the apps <span>that changed.</span></p>
			<h1 id="_idParaDest-116" class="calibre7"><a id="_idTextAnchor115" class="pcalibre1 calibre6 pcalibre"/>Deploying only Micro Apps that changed</h1>
			<p class="calibre3">To be able to deploy only the micro apps<a id="_idIndexMarker327" class="pcalibre1 calibre6 pcalibre"/> that have been impacted by modifications to a file, we basically need to be able to do <span>two things:</span></p>
			<ol class="calibre13">
				<li class="calibre14">Identify which apps have been impacted due to changes to a given set <span>of files</span></li>
				<li class="calibre14">Only build and deploy the micro-apps that have <span>been impacted</span></li>
			</ol>
			<p class="calibre3">For the second point, from the previous section, we now know how to let the Firebase CLI know which micro-app we would like to be deployed. We will look at how to achieve the first point in the <span>next subsection.</span></p>
			<h2 id="_idParaDest-117" class="calibre5"><a id="_idTextAnchor116" class="pcalibre1 calibre6 pcalibre"/>NX Affected</h2>
			<p class="calibre3">The NX dev tools come <a id="_idIndexMarker328" class="pcalibre1 calibre6 pcalibre"/>with a handy command called <strong class="source-inline">nx affected</strong>, which is able to keep track of what files changed from the previous commit and highlight the apps that have been impacted due to the changes to <span>these files.</span></p>
			<p class="calibre3">This is a nifty feature that can be used for various purposes, such as speeding up the execution of tests by running unit tests or build commands only against projects that have been impacted by changes to certain files – or, in our case, deploying only the micro-apps that <span>have changed.</span></p>
			<p class="calibre3">To give it a quick try, run <strong class="source-inline">git add.</strong>  and <strong class="source-inline">git commit</strong> to commit all the changes we have made so far. Try and make a small visual change to <strong class="source-inline">apps/app-shell/src/app/app.tsx</strong>. Save the file and run the <span>following command:</span></p>
			<pre class="console">
pnpm nx print-affected --type=app --select=projects</pre>			<p class="calibre3">It should print out <strong class="source-inline">app-shell</strong> as the app that was modified. Now, try and make changes to <strong class="source-inline">libs/mocks/src/lib/product-list-mocks.tsx</strong> and run the same command. You will see the catalog and checkout apps also added to the list of apps that <span>are affected.</span></p>
			<p class="calibre3">The way the <strong class="source-inline">nx affected</strong> command works is by comparing the difference between the SHAs of the main branch and the current <strong class="source-inline">HEAD</strong>. You can pass in additional parameters to the affected command to compare the difference between any base and head and run a command passed to the <span>target flag:</span></p>
			<pre class="console">
pnpm nx affected --target=deploy --base=main --head=HEAD</pre>			<p class="calibre3"><strong class="source-inline">--target</strong> is the custom command to run, <strong class="source-inline">--base</strong> is the base you want to compare against, and <strong class="source-inline">--head</strong> is the tip of your <span>Git branch.</span></p>
			<p class="calibre3">This will probably return a message saying <strong class="bold">Nx successfully ran target deploy on 0 projects</strong>. This is because we haven’t created our custom deploy <span>command yet.</span></p>
			<p class="calibre3">To get a deeper understanding<a id="_idIndexMarker329" class="pcalibre1 calibre6 pcalibre"/> of the various options for <strong class="source-inline">nx affected</strong>, have a read <span>here: </span><a href="https://nx.dev/nx/affected#affected" class="pcalibre1 calibre6 pcalibre"><span>https://nx.dev/nx/affected#affected</span></a><span>.</span></p>
			<p class="calibre3">In addition to affected, you may also find the <strong class="source-inline">nx graph</strong> command useful for getting a nice, visual representation of the various micro-apps consuming the different shared components and utilities form the <span><strong class="source-inline">libs</strong></span><span> folder.</span></p>
			<p class="calibre3">Try running <strong class="source-inline">pnpm nx affected:dep-graph</strong> to get a visual graph of how the modified files impact <span>the micro-apps.</span></p>
			<p class="calibre3">Here is an example<a id="_idIndexMarker330" class="pcalibre1 calibre6 pcalibre"/> of how changes to the <strong class="source-inline">libs/mocks/src/lib/product-list-mocks.tsx</strong> file impact both the catalog and checkout apps, because both these apps import the product list from the <span><strong class="source-inline">product-list-mocks</strong></span><span> file:</span></p>
			<div class="calibre2">
				<div id="_idContainer054" class="img---figure">
					<img src="image/Figure_7.03_B18987.jpg" alt="Figure 7.3 – nx affected:dep-graph highlighting the projects impacted due to a change in mocks" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.3 – nx affected:dep-graph highlighting the projects impacted due to a change in mocks</p>
			<p class="callout-heading">Note</p>
			<p class="callout">nx graph or nx affected doesn’t take into account the host and remote features of <span>module federation.</span></p>
			<h2 id="_idParaDest-118" class="calibre5"><a id="_idTextAnchor117" class="pcalibre1 calibre6 pcalibre"/>Creating an Nx custom command executor to deploy</h2>
			<p class="calibre3">Executors in Nx allow you to create custom script<a id="_idIndexMarker331" class="pcalibre1 calibre6 pcalibre"/> commands for a project, which you can run via the Nx <span>command system.</span></p>
			<p class="calibre3">Please do take the time to read more<a id="_idIndexMarker332" class="pcalibre1 calibre6 pcalibre"/> about Nx custom command executors <span>here: </span><a href="https://nx.dev/recipes/executors/run-commands-executor#3.-run-the-command" class="pcalibre1 calibre6 pcalibre"><span>https://nx.dev/recipes/executors/run-commands-executor#3.-run-the-command</span></a><span>.</span></p>
			<p class="calibre3">Let's create a custom command to deploy an individual <span>micro app.</span></p>
			<p class="calibre3">In <strong class="source-inline">apps/app-shell/project.json</strong>, add the following code within the <span>target attribute:</span></p>
			<pre class="source-code">
    "deploy": {
      "executor": "@nrwl/workspace:run-commands",
      "options": {
        "commands": ["firebase deploy --only hosting:app-shell"],
        "parallel": true
      }
}</pre>			<p class="calibre3">Add the deploy custom command to each of the micro-app’s <strong class="source-inline">project.json</strong> files. Pass the correct micro-app name in <span>the argument.</span></p>
			<p class="calibre3">Once that is done, try making a small change in the mocks file and run the following <span>two commands:</span></p>
			<pre class="console">
pnpm nx affected -–target=build
pnpm nx affected -–target=deploy</pre>			<p class="calibre3">Assuming Nx has detected the difference correctly, it will only build the catalog and checkout apps and you will also notice that these are the only two apps that deployed <span>to Firebase.</span></p>
			<p class="calibre3">You can verify that by going<a id="_idIndexMarker333" class="pcalibre1 calibre6 pcalibre"/> into Firebase Console’s hosting dashboard and checking the timestamp of when the apps were <span>last deployed:</span></p>
			<div class="calibre2">
				<div id="_idContainer055" class="img---figure">
					<img src="image/Figure_7.04_B18987.jpg" alt="Figure 7.4 – Firebase Console displaying the deployed timestamp of modified apps" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Firebase Console displaying the deployed timestamp of modified apps</p>
			<p class="calibre3">Navigate to <a href="https://ebuy-app-shell.web-app/" class="pcalibre1 calibre6 pcalibre">https://ebuy-app-shell.web-app/</a> (use the correct URL as displayed in your Firebase Console) and verify that everything continues to work fine and that the changes you’ve made reflect on the app. You may need to do a hard reload on your browser to view <span>the updates.</span></p>
			<p class="calibre3">And with this, we’ve successfully<a id="_idIndexMarker334" class="pcalibre1 calibre6 pcalibre"/> managed to deploy only the apps that have changed while ensuring that the rest of the app works <span>as expected.</span></p>
			<h1 id="_idParaDest-119" class="calibre7"><a id="_idTextAnchor118" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
			<p class="calibre3">With that, we come to the end of this chapter, where we learned about static storage hosting and why it is ideal for deploying and serving client-side-rendered React apps. We saw how to build production bundles for our module-federated micro app. We then saw how to set up a multi-site project in Firebase and used Firebase CLI commands to deploy our apps. We also saw how to address CORS issues by setting the right header values for the <strong class="source-inline">Access-Control-Allow-Origin</strong> header, and then finally, we saw how to combine the <strong class="source-inline">nx affected</strong> command and Firebase’s <strong class="source-inline">hosting:&lt;app-name&gt;</strong> command to detect the micro-apps that have been impacted by a change and only build and deploy them to Firebase. We also used this as an opportunity to create a custom command executor to deploy these <span>affected apps.</span></p>
			<p class="calibre3">In the next chapter, we will go deeper into DevOps and cloud territory by seeing how to deploy our microfrontends to a managed <span>Kubernetes cluster.</span></p>
		</div>
	</body></html>