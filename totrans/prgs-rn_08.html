<html><head></head><body>
		<div id="_idContainer040">
			<h1 id="_idParaDest-127" class="chapter-number"><a id="_idTextAnchor268"/>8</h1>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor269"/>JavaScript Engines and Hermes</h1>
			<p><a id="_idTextAnchor270"/><a id="_idTextAnchor271"/>React Native runs on JavaScript and, as mentioned in <a href="B16694_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Essentials of JavaScript and TypeScript</em>, JavaScript needs a JavaScript engine to interpret and/or transform the code into executable machine code. There is no exception to this for React Native.</p>
			<p>While there are quite a lot of different JS engines out there, only a few are used in React Native projects. This is due to the quite complex process to change the JS engine as well as the new Hermes engine, which is an engine developed for React Native and is going to be the default soon. Nevertheless, it is important and helpful to understand the different possible engines with their strengths and weaknesses.</p>
			<p>In this theoretical chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding JavaScript engines</li>
				<li>Getting to know the Hermes engine</li>
				<li>Comparing key metrics</li>
			</ul>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor272"/>Technical requirements</h1>
			<p>Since this is a theoretical chapter, you don’t need to have anything set up.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor273"/>Understanding JavaScript engines</h1>
			<p>As mentioned in<a id="_idIndexMarker487"/> the introduction to this chapter, a JavaScript engine is responsible for interpreting JavaScript and/or transforming it into machine code, so that the device can execute it. </p>
			<p>The first JavaScript engines were simple interpreters that simply processed the statements and ensured the execution. The code was just executed like it was written. This has changed a lot.</p>
			<p>Modern JS engines provide a lot of optimization features. The most discussed is <strong class="bold">just-in-time</strong> (<strong class="bold">JIT</strong>) compilation, which<a id="_idIndexMarker488"/> is implemented by all modern JS engines.</p>
			<p>Compiled languages such as C are compiled before the execution of the code. In this compile step, the transformation to machine language is done as well as a lot of optimization steps. This creates an output that is extremely performant.</p>
			<p><em class="italic">Just-in-time</em> compilation means that the code is compiled while it runs. This means the just-in-time compiler does not know all the code while it compiles. This makes code optimization a lot more difficult. The just-in-time compiler contains two components – the <strong class="bold">profiler</strong> and<a id="_idIndexMarker489"/> the <strong class="bold">compiler</strong>. While<a id="_idIndexMarker490"/> the JS code is executed by the interpreter, the profiler keeps an eye on how often the different statements are executed.</p>
			<p>The more often a statement is executed, the higher priority it gets from the profiler. When a certain threshold is hit, the profiler sends these statements of code to the compiler, which then compiles the statements to bytecode. When the statement shall be executed the next time, it is done via a highly optimized bytecode interpreter. This makes these sections run much faster.</p>
			<p>There are some more optimizations that can be done during the compilation. This depends a lot on the implementation and every modern JS engine has its own just-in-time compiler implementation.</p>
			<p>In general, just-in-time compilation works better for longer running code, because then the compiler has more time to learn how to optimize. Since a lot of JS code is executed while running a React Native app, just-in-time compilation works great.</p>
			<p>The most<a id="_idIndexMarker491"/> widely known JS engines today are JavaScriptCore and V8. Since both can be used in React Native, we’ll have a deeper look at them. </p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor274"/>Using JavaScriptCore</h2>
			<p><strong class="bold">JavaScriptCore</strong> is the JS engine <a id="_idIndexMarker492"/>that powers the Safari browser. It is the default engine shipping with React Native. If you create a new blank project, JavaScriptCore will interpret and execute your JS code. </p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor275"/>Using V8</h2>
			<p><strong class="bold">V8</strong> is an open source <a id="_idIndexMarker493"/>JS engine, heavily backed by Google. It is used by default when you are using the remote debugging feature of React Native. In this case, your JS code is executed in your Chrome browser, which is powered by V8.</p>
			<p class="callout-heading">Important tip</p>
			<p class="callout">Please always keep in mind that you are using different JS engines when having remote debugging on/off. Without remote debugging, your JS code runs on your device or simulator; with remote debugging activated, your JS code runs on your computer in Chrome and communicates with native via WebSockets. Even if the two engines should behave quite similarly, there are some inconsistencies. So always test without remote debugging before shipping your app.</p>
			<p>There is also a project that provides support for V8 as the main JS engine for React Native. This is no big deal for Android since it just replaces the JavaScriptCore for Android JS engine with the V8 engine. It gets more complex on iOS since JavaScriptCore is available on iOS without having to include it in the app bundle. So instead of just using the available JS engine, you would have to bundle the V8 engine in your app. This increases your app bundle size by up to 7 MB depending on the version you use. You can find more information on <a id="_idIndexMarker494"/>this on the <strong class="source-inline">react-native-v8</strong> project: <a href="https://bit.ly/prn-rn-v8">https://bit.ly/prn-rn-v8</a>.</p>
			<p>While both engines work fine, Facebook started a project <a id="_idIndexMarker495"/>called <strong class="bold">Hermes</strong> to develop their own JS engine for React Native. The use case of React Native differs a lot from that of the browser engines as the code is available at build time and cannot change after shipping; hence, there is a lot more room for optimization.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor276"/>Getting to know the Hermes engine</h1>
			<p>Hermes was <a id="_idIndexMarker496"/>brought to the React Native community at the React Native EU conference in 2019. Back then, it was already in production in Facebook’s apps for more than a year. It is completely built with mobile in mind, which changes the architectural approach completely. The following figure shows how a modern JS engine works.</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B16694_08_01.jpg" alt="Figure 8.1 – Modern JS engine pipeline (inspired by Tsvetan Mikov)&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Modern JS engine pipeline (inspired by Tsvetan Mikov)</p>
			<p>When creating and building JavaScript code, usually there is some transcompiling done to backward-compatible JS code and some JS code minification. This minified JS bundle is then sent to a device and gets executed. JS engines such as JavaScriptCore or V8 try to optimize the execution using just-in-time compilation, which, as described before, is a quite complex process and may store and optimize the wrong code statements. Hermes changes the way this is done completely.</p>
			<p>The following<a id="_idIndexMarker497"/> figure shows how optimization and compilation are done in Hermes:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B16694_08_02.jpg" alt="Figure 8.2 – Hermes pipeline (inspired by Tzvetan Mikov)&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Hermes pipeline (inspired by Tzvetan Mikov)</p>
			<p>Because we know all the code, we want to ship in our React Native app, it is possible to do the compilation and optimization during the build process. This means all optimization is done on your computer (or in your CI environment) and not on the users’ devices. Hermes uses a so-called internal code representation, which is highly optimized for the optimization of code.</p>
			<p>After optimizing the code, it is compiled to optimized bytecode. So, when working with Hermes, you don’t ship JavaScript any longer, you ship optimized bytecode. This bytecode only has to be loaded and executed by the Hermes engine on the users’ devices.</p>
			<p>This approach brings a lot of benefits. The <a id="_idIndexMarker498"/>most important are as follows: </p>
			<ul>
				<li><strong class="bold">No warmup</strong>: We don’t need to spend time on just-in-time compiler warmup.</li>
				<li><strong class="bold">No memory usage for just-in-time compiler output</strong>: We don’t need any memory for the output of the just-in-time compiler. This reduces the memory footprint a lot. </li>
				<li><strong class="bold">Startup optimizations</strong>: Some operations that are done by JS engines at startup can be precomputed. This makes the start of the application a lot faster.</li>
				<li><strong class="bold">Smaller bundle size</strong>: The optimized bundle is smaller than minified JavaScript code.</li>
			</ul>
			<p>Due to the benefits of this approach, Hermes is pushed to become the default JS engine for React Native as soon as possible. At the point of writing, you still have to activate it, but it is quite simple: </p>
			<ul>
				<li><strong class="bold">Android</strong>: Go to your <strong class="source-inline">android/app/build.gradle</strong> file and change <strong class="source-inline">enableHermes</strong> from <strong class="source-inline">false</strong> to <strong class="source-inline">true</strong>. You have to clean and rebuild your application after that. </li>
				<li><strong class="bold">iOS</strong>: Go to your <strong class="source-inline">ios/Podfile</strong> file and change <strong class="source-inline">:hermes_enabled =&gt; false</strong> to <strong class="source-inline">:hermes_enabled =&gt; true</strong>. Reinstall your pods with <strong class="source-inline">cd ios &amp;&amp; pod install</strong>.</li>
			</ul>
			<p>Please note that the remote debugging feature does work differently when using Hermes. Since the approach is completely different, there is no bundle that can be run directly in your Chrome browser. Nevertheless, Hermes does support debugging with the Chrome inspector protocol and the Chrome developer tools.</p>
			<p>To use remote debugging, you have to connect your Chrome browser to your running device via Metro. This is done as follows:</p>
			<ol>
				<li value="1">Go to <strong class="source-inline">chrome://inspect/#devices</strong> in your Chrome browser.</li>
				<li>Click on the <strong class="source-inline">Configure…</strong> button and add the Metro server address (usually <strong class="source-inline">localhost:8081</strong>).</li>
				<li>Now, there is a <strong class="source-inline">Hermes React Native</strong> target, which you can inspect.</li>
			</ol>
			<p>For more information, please visit the Hermes documentation of React Native (<a href="https://bit.ly/prn-hermes">https://bit.ly/prn-hermes</a>) or the documentation of the Hermes engine itself (<a href="https://bit.ly/prn-hermes-engine">https://bit.ly/prn-hermes-engine</a>).</p>
			<p>As mentioned, the <a id="_idIndexMarker499"/>Hermes approach brings a lot of benefits to React Native. This is also reflected in key metrics, which we are going to have a look at in the following section.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor277"/>Comparing key metrics</h1>
			<p>When it comes to mobile apps, there are a few metrics you should have a look at when optimizing your application.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor278"/>Understanding important metrics</h2>
			<p>The most important<a id="_idIndexMarker500"/> key metrics on mobile are the following:</p>
			<ul>
				<li><strong class="bold">Time to interaction</strong> (<strong class="bold">TTI</strong>): This<a id="_idIndexMarker501"/> is the time between the user clicking on your app icon and when the user can use your app. It is important to reduce the TTI as much as possible because mobile app users are very impatient. The longer the TTI is, the more users will leave your app without even using it. </li>
				<li><strong class="bold">Application size</strong>: This is the <a id="_idIndexMarker502"/>size the user has to download from the store to install your application. The larger the application size is, the more users won’t download your app. This can have many reasons such as high transfer costs in some countries or disk space left on the user’s device. The fact is, the smaller your app is, the more users will download it.</li>
				<li><strong class="bold">Memory utilization</strong>: This metric<a id="_idIndexMarker503"/> describes how much memory your application consumes during execution. If your app is very memory-hungry, it can lead to problems, especially on older devices or during multitasking. Also, it can lead to the operating system closing your app. The less memory your app consumes, the better it is.</li>
			</ul>
			<p>There are some benchmark results publicly available when looking at these metrics. As JavaScriptCore and V8 deliver mostly similar results (V8 is a bit better in most tests), we’ll focus on the<a id="_idIndexMarker504"/> comparison of JavaScriptCore and Hermes used in a React Native application.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor279"/>Comparing JavaScriptCore and Hermes on Android</h2>
			<p>The following<a id="_idIndexMarker505"/> test compares the key metrics of<a id="_idIndexMarker506"/> JSC and Hermes on Android. The test was run by the Hermes team at Facebook with a very early version of Hermes:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>JSC</p>
						</td>
						<td class="No-Table-Style">
							<p>Hermes</p>
						</td>
						<td class="No-Table-Style"/>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Time to interaction</p>
						</td>
						<td class="No-Table-Style">
							<p>4.30s</p>
						</td>
						<td class="No-Table-Style">
							<p>2.01s</p>
						</td>
						<td class="No-Table-Style">
							<p>-2.29s</p>
						</td>
						<td class="No-Table-Style">
							<p>-53%</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Application size</p>
						</td>
						<td class="No-Table-Style">
							<p>41MB</p>
						</td>
						<td class="No-Table-Style">
							<p>22MB</p>
						</td>
						<td class="No-Table-Style">
							<p>-19MB</p>
						</td>
						<td class="No-Table-Style">
							<p>-46%</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Memory Utilization</p>
						</td>
						<td class="No-Table-Style">
							<p>185MB</p>
						</td>
						<td class="No-Table-Style">
							<p>136MB</p>
						</td>
						<td class="No-Table-Style">
							<p>-49MB</p>
						</td>
						<td class="No-Table-Style">
							<p>-26%</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Facebook JSC/Hermes test on Android (https://bit.ly/prn-hermes-test-fb)</p>
			<p>There was another test run by Kudo Chien, a well-respected member of the React Native community, that also included TTI. This test also worked with different bundle sizes:</p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>JSC</p>
						</td>
						<td class="No-Table-Style">
							<p>Hermes</p>
						</td>
						<td class="No-Table-Style">
							<p>*in ms</p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>TTI 3MB bundle</p>
						</td>
						<td class="No-Table-Style">
							<p>400</p>
						</td>
						<td class="No-Table-Style">
							<p>240</p>
						</td>
						<td class="No-Table-Style">
							<p>160</p>
						</td>
						<td class="No-Table-Style">
							<p>-40%</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>TTI 10MB bundle</p>
						</td>
						<td class="No-Table-Style">
							<p>584</p>
						</td>
						<td class="No-Table-Style">
							<p>305</p>
						</td>
						<td class="No-Table-Style">
							<p>279</p>
						</td>
						<td class="No-Table-Style">
							<p>-48%</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>TTI 15MB bundle</p>
						</td>
						<td class="No-Table-Style">
							<p>694</p>
						</td>
						<td class="No-Table-Style">
							<p>342</p>
						</td>
						<td class="No-Table-Style">
							<p>352</p>
						</td>
						<td class="No-Table-Style">
							<p>-51%</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – TTI test by Kudo Chien on Android (https://bit.ly/prn-hermes-test-kudo)</p>
			<p>If you have a look at the test results, they are just remarkable on Android. The time to interaction was reduced by around 50% in all tests. This is a real game-changer. React Native apps used to open quite slowly compared to real native or Flutter apps. This is due to the need of initializing the JS engine before rendering their first screen. Hermes is a huge step in the right direction for React Native in this area.</p>
			<p>When having a look at the Facebook test, the application size was also reduced by nearly 50%. This is partly because we don’t have to bundle the JavaScriptCore engine into our application anymore, so this effect will reduce on larger applications. But you can expect a saving in bundle size by around 30% even on larger apps. </p>
			<p>Now let’s have a look at memory utilization. In Facebook’s test, Hermes achieved memory savings of around 25%. This is mostly because of the not needed just-in-time compilation and is also a huge achievement. </p>
			<p>Again, these <a id="_idIndexMarker507"/>tests <a id="_idIndexMarker508"/>were run with very early versions of Hermes, so you can expect larger gains in the future.</p>
			<p>While the results are very clear on Android, let’s proceed with tests on iOS.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor280"/>Comparing JSC and Hermes on iOS</h2>
			<p>On iOS, we<a id="_idIndexMarker509"/> have to keep in mind that JavaScriptCore is<a id="_idIndexMarker510"/> provided by the operating system. This means when using JSC, we don’t have to bundle any JavaScript engine into our application. Also, JavaScriptCore is optimized for iOS and Apple products. The implementation of Hermes on iOS was <a id="_idIndexMarker511"/>done by <strong class="bold">Callstack</strong>, a company that contributes a lot to React Native in general. After completing the implementation, the Callstack team also ran some tests to compare JSC and Hermes. These are the results:</p>
			<table id="table003" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>JSC</p>
						</td>
						<td class="No-Table-Style">
							<p>Hermes</p>
						</td>
						<td class="No-Table-Style">
							<p>*in ms</p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Time to interaction</p>
						</td>
						<td class="No-Table-Style">
							<p>920ms</p>
						</td>
						<td class="No-Table-Style">
							<p>570ms</p>
						</td>
						<td class="No-Table-Style">
							<p>-350ms</p>
						</td>
						<td class="No-Table-Style">
							<p>-38%</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Application size</p>
						</td>
						<td class="No-Table-Style">
							<p>10.6MB</p>
						</td>
						<td class="No-Table-Style">
							<p>13MB</p>
						</td>
						<td class="No-Table-Style">
							<p>2,4MB</p>
						</td>
						<td class="No-Table-Style">
							<p>18%</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Memory utilization</p>
						</td>
						<td class="No-Table-Style">
							<p>216MB</p>
						</td>
						<td class="No-Table-Style">
							<p>178MB</p>
						</td>
						<td class="No-Table-Style">
							<p>-38MB</p>
						</td>
						<td class="No-Table-Style">
							<p>-18%</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Callstack JSC/Hermes test on iOS (https://bit.ly/prn-hermes-test-ios)</p>
			<p>As on Android, time to interaction and memory utilization improved a lot. The values are a little lower than on Android, but this can be explained due to the better optimization of JSC on iOS. The application size increased on iOS, which seems only logical, so we now have to add Hermes to our bundle, while JSC is provided by the operating system.</p>
			<p>But when the JavaScript bundle of your app grows, this effect will decrease due to the smaller bytecode of Hermes compared to the minified JS code shipped with the JSC-based bundle.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor281"/>Summary</h1>
			<p>In this chapter, we had a look at JavaScript engines in general, learned about the special requirements React Native has for a JavaScript engine, the different engines we can use in React Native, and how to change the JS engine of our React Native project. We then had a look at Hermes, a JavaScript engine developed with mobile in general and React Native especially in mind.</p>
			<p>After understanding the approach of Hermes and its benefits, we compared mobile app key metrics on apps running on JavaScriptCore, V8, and Hermes. While there is no big difference in using JSC or V8, Hermes brings a huge boost in terms of TTI and memory utilization to React Native. </p>
			<p>After mastering JavaScript engines, we’ll have a look at useful tools when working with React Native in the next chapter.</p>
		</div>
	</body></html>