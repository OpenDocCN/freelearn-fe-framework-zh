- en: Chapter 8. Time Will Tell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our task-management system is coming into shape. However, we were not concerned
    about one crucial aspect of managing our projects so far. Time plays a major role
    in all projects, and this is the thing that is often the most complicated to manage.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will add a few features to our task management system that
    will help our users to manage time more efficiently. Reusing some components that
    we created earlier, we will be able to provide a consistent user experience to
    manage time.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a higher level, we will develop the following features to enable time management
    in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task details**: So far, we did not include a details page of tasks because
    all the necessary information about tasks could be displayed on the task list
    of our project page. While our time management will increase the complexity of
    our tasks quite a bit, we will create a new detail view of project tasks that
    will also be accessible through routing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efforts management**: We will include some new data on our tasks to manage
    efforts on tasks. Efforts are always represented by an estimated duration of time
    and an effective duration of spent time. We will make both properties of efforts
    optional so that they can exist independently. We will create new components to
    enable users to provide time duration input easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Milestone management**: We will include a way to manage project milestones
    and then map them to project tasks. This will help us later gain an overview over
    the project status, and it enables the user to group tasks into smaller chunks
    of work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project task detail component to edit task details and enable a new
    route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying our tag management system to include task tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new pipes to deal with formatting time durations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating task information components to display task overview information on
    the existing task components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a time duration use input component that enables users to easily input
    time durations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SVG component to display progress on tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an autocomplete component to manage milestones on tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our task list was sufficient enough to display all details of tasks
    directly in the listing. However, as we will add more details to tasks in this
    chapter, it's time to provide a detail view where users can edit the task.
  prefs: []
  type: TYPE_NORMAL
- en: We already laid the groundwork on project navigation using the router in [Chapter
    5](part0039.xhtml#aid-1565U1 "Chapter 5. Component-Based Routing"), *Component-Based
    Routing*, of this book. Adding a new routable component that we'll use in the
    context of our projects will be a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new component class for our project task detail view in the
    `project/project-task-details/project-task-details.js` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As this component will never exist without a parent `Project` component, we
    can safely rely on that to obtain the data we use. This component isn't used in
    pure UI composition cases, so it's not required to create a routable wrapper component
    like we did for other components in [Chapter 5](part0039.xhtml#aid-1565U1 "Chapter 5. Component-Based
    Routing"), *Component-Based Routing*. We can directly rely on route parameters
    and obtain the relevant data from the parent `Project` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we use dependency injection in order to get a reference to the parent
    project component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Similarly to our routing wrapper components, we make use of parent component
    injection to obtain a reference to the parent `Project` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll use the `OnActivate` lifecycle hook of the router again to obtain
    the task number from the active route segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we'll create a reactive subscription to the `LiveDocument` projects
    that will extract the task that we are concerned about and store it into the components
    `task` member. In this way, we ensure that our component will always receive the
    latest task data when the project is updated outside of the current task details
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our component gets destroyed, we need to make sure that we unsubscribe from
    the RxJS `Observable` that is provided by the `LiveDocument` project. Let''s implement
    the `ngOnDestroy` lifecycle hook for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, let''s now take a look at the template of our component, and see how
    we''ll deal with the task data to provide an interface to edit the details. We''ll
    create a `project-task-details.html` file in our new `component` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Reusing the `Editor` component that we created in [Chapter 4](part0036.xhtml#aid-12AK82
    "Chapter 4. No Comments, Please!"), *No Comments, Please!*, of this book, we can
    rely on simple UI composition to make the title and description of our tasks editable.
  prefs: []
  type: TYPE_NORMAL
- en: As we stored the task data into the `task` member variable on our component,
    we can reference the `title` and `description` fields to create a binding to the
    `content` input property of our editor components.
  prefs: []
  type: TYPE_NORMAL
- en: While the `title` should only consist of plaintext, we can support the tagging
    functionality that we created in [Chapter 7](part0049.xhtml#aid-1ENBI2 "Chapter 7. Components
    for User Experience"), *Components for User Experience*, on the `description`
    field of the task. For this, we simply set the `enableTags` input property of
    the description `Editor` component to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Editor` component has an `editSaved` output property that will emit the
    updated content once a user saves his edits. Now, all we need to make sure of
    is that we create a binding to our component that will persist these changes.
    Let''s create the `onTitleSaved` and `onDescriptionSaved` methods on our `Component`
    class to handle these events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The task member is just a reference to the given task in the `LiveDocument`
    project of the `Project` component. This simplifies the way we persist the data
    that was changed on the task. After updating the given property on the task, we
    simply call the `persist` method on the `LiveDocument` projects to store our changes
    in the data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good. We created a task details component that makes it easy to
    edit the title and description of tasks using our `Editor` UI component. The only
    thing left to enable our component is to create a child route on the `Project`
    component. Let''s open our `Project` component class in `lib/project/project.js`
    to make the necessary modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We added a new child route on our `Project` component, which is responsible
    for the instantiation of our `ProjectTaskDetails` component. By including a `:nr`
    parameter in the route configuration, we can pass the concerned task number into
    the `ProjectTaskDetails` component.
  prefs: []
  type: TYPE_NORMAL
- en: Our newly-created child route is now accessible in the router and we can access
    the task detail view using the `/projects/project-1/task/1` example URL.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make our `TaskDetails` route navigable, we need to add a navigation
    link to our `Task` component so that users can navigate to it in the projects
    task list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this rather simple task, the only thing that we need to do is use the `RouterLink`
    directive and create a new link in the `Task` template, `lib/task-list/task/task.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a relative router URL here because we''re already on the `/project/tasks`
    route. As our `task/:nr` route is part of the project router, we need to navigate
    one level back to access the `task` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Task details](img/image00333.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Newly created task detail view with editable title and description
  prefs: []
  type: TYPE_NORMAL
- en: Enabling tags for tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, the tag-management system that we created in [Chapter 7](part0049.xhtml#aid-1ENBI2
    "Chapter 7. Components for User Experience"), *Components for User Experience*,
    only supports project tags. As we now created a detail view to tasks, it would
    be nice to also support task tags directly in our tagging system. Our tagging
    system is quite flexible, and we can implement new tags with very little effort.
    On a higher level, we need to make the following changes to enable task tags in
    our system:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit the `generate-tag.js` module in order to support the generation of task
    tags from task and project data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit the `TagsService` in order to initialize task tags using the `generate-tag.js`
    module and cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s first modify the `lib/tags/generate-tag.js` file to enable task tag
    generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we need to have a reference to project data as well as to the individual
    task of this project, we expect the `subject` parameter to look like the following
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From this `subject` object, we can then create a new `Tag` object. For the `textTag`
    field, we use a construct that includes the project ID as well as the task number.
    Like this, we can uniquely identify the task using a simple text representation.
  prefs: []
  type: TYPE_NORMAL
- en: For the `link` field, we construct a URL from the project as well as the task
    number. This string will resolve to a URL required to activate the `TaskDetails`
    route, which we configured in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `generateTag` function is now ready to create task tags. Now, the only
    thing left to enable task tags in our system is the modification required in the
    `TagsService` class. Let''s open the `lib/tags/tags-service.js` file and apply
    our changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the `initializeTags` method of our `TagsService` class, we now add task `Tag`
    objects for all available tasks in projects. First, we map each project task to
    the required `subject` object by the `generateTag` function. Then, we can simply
    map the resulting array using the `generateTag` function directly. The result
    is an array of generated task `Tag` objects that we then concatenate into the
    `tags` list of the `TagsService` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This wasn''t too complicated, right? This relatively simple change results
    in a huge improvement for our users. They can now reference individual tasks everywhere
    in our system where we enabled tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling tags for tasks](img/image00334.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Editor component displaying newly-added task tags
  prefs: []
  type: TYPE_NORMAL
- en: Managing efforts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create some components that help us keep track of efforts.
    Primarily, we will use this to manage efforts on tasks, but this could be applied
    to any part of our application where we need to keep track of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Efforts in our context always consist of two components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Estimated duration**: This is the duration that is initially estimated for
    the task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Effective duration**: This is the duration of time that is spent on a given
    task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For time durations, we assume some time units and rules that will simplify
    the processing of time and align to some working standards. The goal here is not
    to provide a razor sharp time management but something that is accurate enough
    to bring value. For this purpose, we define the following working time units:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minute**: One minute is a regular 60 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hour**: One hour always represents 60 minutes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Day**: One day represents a regular workday of eight hours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Week**: One week is equivalent to five working days (5 * 8 hours)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time duration input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now start to write a complex user interface component, where users can
    enter individual time units in different input element. However, I believe it's
    much more convenient to treat time duration input with a no-UI approach. Therefore,
    instead of building a complex user interface, we can simply agree on a textual
    short form to write durations, and let the user write something, such as `1.5d`
    or `5h 30m`, in order to provide input. Sticking to the convention that we previously
    established, we can build a simple parser that can handle this sort of input.
  prefs: []
  type: TYPE_NORMAL
- en: This approach has several advantages. Besides that, this is one of the most
    effective ways to enter time durations, and it's also easy for us to implement.
    We can simply reuse our `Editor` component to gather text input from the user.
    Then, we use a conversion process to parse the entered time duration.
  prefs: []
  type: TYPE_NORMAL
- en: Let's spin up a new module that helps us deal with these conversions. We create
    a new module in the `lib/utilities/time-utilities.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to have a constant that defines all the units we need for the
    conversion process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is all the units that we need to deal with for now. You can see the milliseconds
    being calculated at interpretation time. We can also write the milliseconds as
    constants, but this provides us with some transparency on how we get to these
    values and we can spear on some comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our parsing function, which we can use to parse text input into
    time durations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the preceding code briefly to explain what we do here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define a regular expression that helps us dissect the text representation
    of a duration. This pattern will extract chunks from the text input that are important
    to calculate the duration behind the text representation. These chunks always
    consist of a number, followed by either `w`, `d`, `h`, or `m`. Therefore, the
    text `10w 3d 2h 30m` will be split into the chunks `10w`, `3d`, `2h`, and `30m`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We initialize a `timeSpan` variable with `0`, so we can add all the milliseconds
    from discovered chunks together and later return this sum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each of the previously-extracted chunks, we now extract the number component
    into a variable called `amount`, and the unit (`w`, `d`, `h`, or `m`) into a variable
    called `unitShortName`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can look up the data in the `UNITS` constant for the unit of the chunk
    that we will process, multiply the amount of milliseconds of the unit by the amount
    we extract from the chunk, and then add that result to our `timeSpan` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Well this is quite a neat function we built here. It accepts a formatted time
    duration string and converts it into milliseconds. This is already half of what
    we need to deal with textual representation of time durations. The second piece
    is the opposite of what we have with the `parseDuration` function to convert a
    duration in milliseconds into a formatted duration string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also explain briefly what the `formatDuration` function does:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `Array.prototype.reduce` function to format a string that contains
    all time units and their amount. We iterate over all available time units in the
    `UNITS` constant starting with the largest unit for weeks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then divide the `timeSpan` variable, which is in milliseconds, by the milliseconds
    of the unit which gives us the amount of the given unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the amount is greater than or equal to 1, we can add the unit with the given
    amount and unit short name to our formatted string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we could be left with some fractions after the comma in the amount, which
    we will need to encode in smaller units, we subtract the floored version of our
    amount from the `timeSpan` before we return to the `reduce` function again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process is repeated for every unit, where each unit will only provide formatted
    output if the amount is greater than or equal to 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is all we need to convert back and forth between formatted time duration
    and time duration represented in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll do one more thing before we create the actual component to enter time
    durations. We will create a simple pipe that basically just wraps our `formatTime`
    function. For this, we will create a new `lib/pipes/format-duration.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using the `formatTime` function of our `time-utilities` module, we now have
    the ability to format durations in millisecond directly from in our templates.
  prefs: []
  type: TYPE_NORMAL
- en: Components to manage efforts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, this is enough time math for the moment. Let's now use the elements that
    we created to shape some components that will help us gather user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create two components to manage efforts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Duration`: The `Duration` component is a simple UI component, enabling user
    input of time durations using the formatted time strings we dealt with in the
    previous topics. It uses an `Editor` component to enable user input and makes
    use of the `FormatTimePipe` pipe as well as the `parseDuration` utility function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Efforts`: The `Efforts` component is just a composition of two `Duration`
    components that represent the estimated effort and the effective effort spent
    on a given task. Following a strict rule of composition, this component is important
    for us so that we don''t repeat ourselves and instead compose a larger component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the `Duration` component class, and create a new `lib/ui/duration/duration.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing fancy about this component really because we created the bulk
    of the logic already and we simply compose a higher component together.
  prefs: []
  type: TYPE_NORMAL
- en: As the `duration` input, we expect a time duration in milliseconds, while the
    `durationChange` output property will emit events when the user provides some
    input.
  prefs: []
  type: TYPE_NORMAL
- en: The `onEditSaved` method serves in the binding to the `Editor` component in
    our component. Whenever the user saves his edits on the `Editor` component, we'll
    take this input, convert the formatted time duration into milliseconds using the
    `parseDuration` function, and re-emit the converted value using the `durationChange`
    output property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the template of our component in the `lib/ui/duration/duration.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Surprised with how simple our template is? Well, this is exactly what we should
    achieve with higher components once we establish a good foundation of base components.
    Well-organized composition radically simplifies our code. The only thing that
    we deal with here is our good old `Editor` component.
  prefs: []
  type: TYPE_NORMAL
- en: We bind the `duration` input property of our `Duration` component to the content
    input property of the `Editor` component. As we'd like to pass the formatted time
    duration and not the duration in milliseconds, we use the `FormatDurationPipe`
    pipe to convert in the binding expression.
  prefs: []
  type: TYPE_NORMAL
- en: If the `Editor` component notifies us about a saved edit, we call the `onEditSaved`
    method on our `Duration` component, which will parse the entered duration and
    re-emit the resulting value.
  prefs: []
  type: TYPE_NORMAL
- en: As we initially defined all efforts to consist of an estimated and an effective
    duration, we would now like to create another component that combines these two
    durations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new `Efforts` component by starting with a new template on
    the `lib/efforts/efforts.html` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we add two `Duration` components labelled, where the first one is used
    to gather input for the estimated time and the later one for effective time.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, we provide three small buttons to increase the effective
    duration by a simple click. In this way, the user can quickly add one or four
    hours (half a working day) or a complete working day (which we defined as eight
    hours).
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the `Component` class, there should be no surprises. Let''s open
    the `lib/efforts/efforts.js` component class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The component provides two separate inputs for estimated and effective time
    duration in milliseconds. If you take a look at the component template again,
    these input properties are directly bound to the input properties of the `Duration`
    components.
  prefs: []
  type: TYPE_NORMAL
- en: The `onEstimatedChange` and `onEffectiveChange` methods are used to create bindings
    to the `durationChange` output properties of the `Duration` components. All we
    do here is emit an aggregated data object that contains the effective and estimated
    time in milliseconds using the `effortsChange` output property.
  prefs: []
  type: TYPE_NORMAL
- en: In the `addEffectiveHours` method, we simply emit an `effortsChange` event and
    update the effective property by the calculated amount of milliseconds. We use
    our `UNITS` constant from the `time-utilities` module in order to get the amount
    of milliseconds for an hour.
  prefs: []
  type: TYPE_NORMAL
- en: This is all that we need in order to provide a user input to manage efforts
    on our tasks. To complete this topic, we will add our newly-created `Efforts`
    component to the `ProjectTaskDetail` component in order to manage efforts on tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at the code changes in the `Component` class located in `lib/project/project-task-detail/project-task-detail.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Besides providing the `Efforts` component to the `directives` list of our `ProjectTaskDetail`
    component, we added a new `onEffortsChange` method that deals with the output
    provided by the `Efforts` component.
  prefs: []
  type: TYPE_NORMAL
- en: If both estimated and effective effort isn't set, or set to `0`, we'll set the
    task efforts to `null`. Otherwise, we use the output data of the `Efforts` component
    and assign it as our new task efforts.
  prefs: []
  type: TYPE_NORMAL
- en: After changing the task efforts, we persist the `LiveDocument` of the project
    in the same way that we do for the title and the description updates already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the changes in the template of our component located in `lib/project/project-task-detail/project-task-detail.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are binding the estimated and effective input properties of the `Efforts`
    component to the task data in the `ProjectTaskDetail` component. For the `effortsChange`
    output property we''re using an expression that is invoking our `onEffortsChange`
    method that we''ve just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Components to manage efforts](img/image00335.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our new Efforts component that consists of two duration input components
  prefs: []
  type: TYPE_NORMAL
- en: The visual efforts timeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the components that we created so far to manage efforts provide a good
    way to edit and display effort and time durations, we can still improve this with
    some visual indication.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create a visual efforts timeline using SVG. This timeline
    should display the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The total estimated duration as a gray background bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total effective duration as a green bar that overlays on the total estimated
    duration bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A yellow bar that shows any overtime (if the effective duration is greater than
    the estimated duration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two figures illustrate the different visual states of our efforts
    timeline component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The visual efforts timeline](img/image00336.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The visual state if the estimated duration is greater than the effective duration
  prefs: []
  type: TYPE_NORMAL
- en: '![The visual efforts timeline](img/image00337.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The visual state if the effective duration exceeds the estimated duration (the
    overtime is displayed as a black bar)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start fleshing out our component by creating a new `EffortsTimeline`
    Component class on the `lib/efforts/efforts-timeline/efforts-timeline.js` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our component has three input properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`estimated`: This is the estimated time duration in milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`effective`: This is the effective time duration in milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: This is the desired height of the efforts timeline in pixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `OnChanges` lifecycle hook, we set two component member fields, which
    are based on the estimated and effective time:'
  prefs: []
  type: TYPE_NORMAL
- en: '`done`: This contains the width of the green bar in percentage that displays
    the effective duration without overtime that exceeds the estimated duration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`overtime`: This contains the width of the yellow bar in percentage that displays
    any overtime, which is any time duration that exceeds the estimated duration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the template of the `EffortsTimeline` component and see how we
    can now use the `done` and `overtime` member fields to draw our timeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new `lib/efforts/efforts-timeline/efforts-timeline.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our template is SVG-based, and it contains three rectangles for each of the
    bars that we want to display. The background bar that will be visible if there
    is remaining effort will always be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Above the remaining bar, we conditionally display the done and the overtime
    bar using the calculated widths from our component class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can go ahead and include the `EffortsTimeline` class in our `Efforts`
    component. This way our users will have visual feedback when they edit the estimated
    or effective duration, and it provides them a sense of overview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look into the template of the `Efforts` component to see how we integrate
    the timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have the estimated and effective duration times readily available in
    our `Efforts` component, we can simply create a binding to the `EffortsTimeline`
    component input properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The visual efforts timeline](img/image00338.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Efforts component displaying our newly-created efforts timeline component
    (the overtime of six hours is visualized with the yellow bar)
  prefs: []
  type: TYPE_NORMAL
- en: Recapitulating on efforts management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we''ll create components that allow users to manage efforts
    easily and add a simple but powerful time tracking to our tasks. We''ve done the
    following to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: We implemented some utility functions to deal with the time math in order to
    convert time durations in milliseconds into formatted time durations and vice
    versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a pipe to format time durations in milliseconds using our utility
    functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a `Duration` UI component, which wraps an `Editor` component and
    uses our time utilities to provide a no-UI kind of input element to enter durations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created an `Efforts` component that acts as a composition of two `Duration`
    components for estimated and effective time and provides additional buttons to
    add effective spent time quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We integrated the `Efforts` component into the `ProjectTaskDetail` component
    in order to manage efforts on tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a visual `EffortsTimeline` component using SVG, which displays the
    overall progress on a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting milestones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracking time is important. I don't know how you feel about time, but I really
    suck at organizing my time. Although a lot of people ask me how I manage to do
    so many things, I believe I'm actually very bad at managing how I get these things
    done. If I were a better organizer, I could get things done with much less energy
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that always helps me organize myself is to break things down into
    smaller work packages. Users that organize themselves with our task management
    application can already do this by creating tasks in projects. While a project
    is the overall goal, we can create smaller tasks to achieve this goal. However,
    sometimes we tend to lose sight of the overall goal when we're only focused on
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Milestones are a perfect glue between projects and tasks. They make sure that
    we bundle tasks together into larger packages. This will help us a lot in organizing
    our tasks, and we can look at milestones of the project to see the overall project
    health. However, we can still focus on tasks when we work in the context of a
    milestone.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create the necessary components in order to add basic
    milestone functionality to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement milestone functionality in our application, we will stick to the
    following design decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: Milestones should be stored on the project level, and tasks can contain an optional
    reference to a project milestone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep things simple, the only interaction point with milestones should be
    on task level. Therefore, creation of milestones will be done on task level, although
    the created milestones will be stored on project level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Milestones currently only consist of a name. There are a lot more to milestones
    that we can potentially build into our system, such as deadlines, dependencies,
    and other nice things. However, we will stick to the bare minimum, which is a
    milestone name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an autocomplete component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to keep the management of milestones simple, we will create a new user
    interface component to deal with the design concerns that we listed. Our new autocomplete
    component will not only display possible values to select from, but it will also
    allow us to create new items. We can then simply use this component on our `ProjectTaskDetail`
    component in order to manage milestones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `Component` class of our new autocomplete component that
    we will create in the `lib/ui/auto-complete/auto-complete.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once again, our `Editor` component can be reused to create this higher component.
    We're lucky that we created such a nice component, as this saved us a lot of time
    throughout this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the input and output properties of the `AutoComplete` component
    in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`items`: This is where we expect an array of strings. This will be the list
    of items a user can choose from when typing into the editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectedItem`: This is when we make the selected item an input property to
    actually make this component pure, and we can rely on the parent component to
    set this property right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectedItemChange`: This output property will emit an event if the selected
    item was changed. As we create a pure component here, we somehow need to propagate
    the event of an item that was selected in the autocomplete list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`itemCreated`: This output property will emit an event if a new item was added
    to the autocomplete list. Updating the list of items and changing the component
    `items` input property will still be the responsibility of the parent component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add more code to our component. We use an `Editor` component as main
    input source. While our users will type into the editor, we filter the available
    items using the text input of the editor. Let''s create a `filterItems` for this
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `filterItems` method has a single parameter, which is the text that we want
    to use in order to search for relevant items in our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the content of the method in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: For later use in our template, we will set aside the filter query that was used
    the last time this method was called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `filteredItems` member variable, we will store a filtered version of
    the item list by searching for text occurrences of the filter string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a last step, we also store the information if the search query resulted in
    an exact match of an item in our list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we need to make sure that if the `items` or `selectedItem` input properties
    change, we also execute our filter method again. For this, we simply implement
    the `ngOnChanges` lifecycle hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now see how we deal with the events provided by the `Editor` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If the editor changes to edit mode, we want to save the previously selected
    item. We'll need this if the user decides to cancel his edits and switch back
    to the previous item. Of course, this is also the point where we need to display
    the autocomplete list to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if the edit mode is switched back to read mode, we want
    to hide the autocomplete list again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `editableInput` event is triggered by our editor on every editor input
    change. The event provides us with the text content that was entered by the user.
    If such an event occurs, we need to execute our filter function again with the
    updated filter query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `editSaved` event is triggered by our editor, we need to decide whether
    we should do either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Emit an event using the `selectedItemChange` output property if the saved content
    is an empty string to signal the removal of a selected item to the parent component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Emit an event using the `itemCreated` output property if valid content is given
    and our list does not include an item with that name to signal an item creation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On the `editCanceled` event of the `Editor` component, we want to switch back
    to the previous selected item. For this, we can simply emit an event using the
    `selectedItemChange` output property and the `previousSelectedItem` member that
    we put aside after the editor was switched into edit mode.
  prefs: []
  type: TYPE_NORMAL
- en: These are all the binding functions that we will use to wire up our editor and
    in order to attach the autocomplete functionality to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more rather simple methods that we will create before we take
    a look at the template of our autocomplete component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use these two for the click actions in the autocomplete callout from
    our template. Let''s take a look at the template so that you can see all the code
    that we just created in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: First, the `Editor` component is placed and all necessary bindings to the handler
    methods that we created in our `Component` class are attached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create the autocomplete list that will be displayed as a callout
    to the user right next to the editor input area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We rely on the `showCallout` member set by the `onEditModeChange` method of
    our `Component` class to signal if we should display the autocomplete list or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: We then iterate over all filtered items using the `NgFor` directive and render
    the text content of each item. If one of the items gets clicked on, we will call
    our `selectItem` method with the concerned item as the parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last list element, after the repeated list items, we conditionally display
    an additional list element in order to create a nonexisting milestone. We only
    display this button if there''s a valid filter already and if there''s no exact
    match of the filter to an existing milestone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an autocomplete component](img/image00339.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our milestone component plays nicely together with the editor component using
    a clean composition
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are all done with our autocomplete component, the only thing left
    to do in order to manage project milestones is to make use of it in the `ProjectTaskDetails`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the `Component` class located in `lib/project/project-task-details/project-task-details.js`
    and apply the necessary modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the subscription to project changes, we now also extract any preexisting
    project milestones and store them in a `projectMilestones` member variable. This
    makes it easier to reference in the template.
  prefs: []
  type: TYPE_NORMAL
- en: The `onMilestoneSelected` method will be bound to the `selectItemChange` output
    property of the `AutoComplete` component. We use the emitted value of the `AutoComplete`
    component to set our tasks milestone and persist the `LiveDocument` project using
    its `persist` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `onMilestoneCreated` method will be bound to the `itemCreated` output property
    of the `AutoComplete` component. On such an event, we add the created milestone
    to the projects milestone list as well as assign the current task to the created
    milestone. After updating the `LiveDocument` data, we use the `persist` method
    to save all changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look into `lib/project/project-task-details/project-task-details.html`
    to see the necessary changes in our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Besides the output property bindings that you're already aware of, we also create
    two input bindings for the `items` and `selectedItem` input properties of the
    `AutoComplete` component.
  prefs: []
  type: TYPE_NORMAL
- en: This is already it. We created a new UI component that provides autocompletion
    and used that component to implement milestone management on our tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Isn't it nice how easy it suddenly seems to implement new functionality when
    using components with proper encapsulation? The great thing about component-oriented
    development is that your development time for new functionality decreased with
    the amount of reusable components that you already created.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented some components that help our users keep track
    of time. They can now log efforts on tasks and manage milestones on projects.
    We created a new task detail view that can be accessed using a navigation link
    on our task list.
  prefs: []
  type: TYPE_NORMAL
- en: Once more, we experienced the power of composition using components, and reusing
    existing components, we were able to easily implement higher components that provide
    more complex functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to use the charting library Chartist
    and create some wrapper components that allow us to build reusable charts. We
    will build a dashboard for our task management system, where we will see our chart
    components in action.
  prefs: []
  type: TYPE_NORMAL
