- en: Chapter 3. Loading and Manipulating Dynamic Content with AJAX and JSON
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。 使用 AJAX 和 JSON 加载和操作动态内容
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Loading HTML from a web server into a page
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 HTML 从 Web 服务器加载到页面中
- en: Using AJAX and handling server errors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AJAX 并处理服务器错误
- en: Processing JSON data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 JSON 数据
- en: Searching JavaScript objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索 JavaScript 对象
- en: Sorting JavaScript objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序 JavaScript 对象
- en: Caching JSON and AJAX requests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存 JSON 和 AJAX 请求
- en: Creating a search feature
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建搜索功能
- en: Creating an autosuggest feature
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自动建议功能
- en: Waiting for an AJAX response
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待 AJAX 响应
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: jQuery allows the developer to make AJAX calls that will update website content
    without the need for refreshing a complete web page. jQuery's AJAX functionality
    adds an additional dimension to a website that allows it to become more of a web
    application. This chapter looks at how a developer can make these AJAX requests,
    receive data, and process it. In addition to processing and utilizing data received
    from an AJAX request, this chapter also looks at some of the other major features
    of AJAX including search and suggestion.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 允许开发人员进行 AJAX 调用，这将更新网站内容，而无需刷新完整的网页。 jQuery 的 AJAX 功能为网站增加了一个额外的维度，使其更像一个
    Web 应用程序。 本章讨论了开发人员如何进行这些 AJAX 请求，接收数据并对其进行处理。 除了处理和利用从 AJAX 请求接收到的数据之外，本章还介绍了
    AJAX 的一些其他主要功能，包括搜索和建议。
- en: 'For most of the recipes in this chapter, you will either need to run a web
    server on your local machine or have access to an online web server. Some basic
    knowledge of PHP and MySQL will be useful as the required web server will make
    use of these technologies. To learn more about these technologies, you can refer
    to the following resources:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的大多数示例，您要么需要在本地计算机上运行一个 Web 服务器，要么需要访问在线 Web 服务器。 一些关于 PHP 和 MySQL 的基本知识将会很有用，因为所需的
    Web 服务器将使用这些技术。 要了解有关这些技术的更多信息，您可以参考以下资源：
- en: To learn more on PHP, refer to [http://www.php.net](http://www.php.net)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关 PHP 的更多信息，请参阅[http://www.php.net](http://www.php.net)
- en: To learn more on MySQL, refer to [http://www.mysql.com](http://www.mysql.com)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关 MySQL 的更多信息，请参阅[http://www.mysql.com](http://www.mysql.com)
- en: Loading HTML from a web server into a page
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 HTML 从 Web 服务器加载到页面中
- en: At the most basic level, AJAX allows us to update a single page element with
    new content from a web server. This recipe looks at how we can set up some data
    to be received from a web server with PHP and how we can then receive this data
    and apply it to our web page.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的级别上，AJAX 允许我们使用来自 Web 服务器的新内容更新单个页面元素。 这个示例展示了如何设置一些数据以从一个使用 PHP 的 Web
    服务器接收，以及如何接收此数据并将其应用到我们的网页中。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you have a web server running and have access to its web root.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的 Web 服务器正在运行并且可以访问其 Web 根目录。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Perform the following steps to create the required PHP, MySQL, and HTML in
    order to understand how to use jQuery with AJAX:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建所需的 PHP、MySQL 和 HTML，以便了解如何使用 jQuery 进行 AJAX：
- en: 'Before we can request for any data from the web server to be displayed within
    our web page, we need to be able to serve this data from a web server. Create
    a PHP file named `request-1.php`. Add the following PHP code and save it within
    the web root of your web server:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够从 Web 服务器请求任何数据以在我们的网页中显示之前，我们需要能够从 Web 服务器提供此数据。 创建一个名为 `request-1.php`
    的 PHP 文件。 添加以下 PHP 代码，并将其保存在 Web 服务器的 Web 根目录中：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second step is to create a jQuery-powered HTML page that can request data
    from our PHP script. Within the web root of your web server, create an HTML file
    named `recipe-1.html` and add the following HTML code to it:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是创建一个使用 jQuery 的 HTML 页面，该页面可以从我们的 PHP 脚本请求数据。 在 Web 服务器的 Web 根目录中，创建一个名为
    `recipe-1.html` 的 HTML 文件，并添加以下 HTML 代码：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are now going to use CSS in order to add styles to our HTML page. Add the
    following CSS code within the `<style type="text/css"></style>` tags in the `recipe-1.html`
    file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用 CSS 来为我们的 HTML 页面添加样式。 在 `recipe-1.html` 文件的 `<style type="text/css"></style>`
    标签中添加以下 CSS 代码：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The final step is to add some jQuery code in order to request data from the
    PHP script and load it into our web page. Within the script tags in the header
    of the `recipe-1.html` file, add the following jQuery code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是添加一些 jQuery 代码，以便从 PHP 脚本请求数据并将其加载到我们的网页中。 在 `recipe-1.html` 文件的头部的脚本标签中，添加以下
    jQuery 代码：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Now, let us understand the steps performed previously in detail.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细了解之前执行的步骤。
- en: PHP
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: 'The aim of using the PHP script is to provide a random quote by Albert Einstein
    as a string. To be able to do this at random, we first need to generate a random
    number. This is done using the PHP `rand()` function as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PHP 脚本的目的是将**阿尔伯特·爱因斯坦**的随机引用提供为字符串。要能够随机执行此操作，我们首先需要生成一个随机数。这通过以下方式使用 PHP
    `rand()` 函数完成：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will create a variable with a random integer value between `1` to `5`.
    We can then use this random number to determine which quote to output. We use
    a switch statement based on the `$num` variable to create a `$quote` variable
    with a random Einstein quote:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个随机整数值的变量，范围在 `1` 到 `5` 之间。然后，我们可以使用此随机数来确定要输出哪个引用。我们使用基于 `$num` 变量的 switch
    语句创建一个具有随机爱因斯坦引用的 `$quote` 变量：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we echo the value of `$quote`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们输出`$quote`的值：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you were to visit this file served from a web server (that is, `http://localhost/request.php`)
    in your browser, you will be presented with a random quote every time you refresh
    the page, as shown in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中访问此文件（即`http://localhost/request.php`）从 Web 服务器提供的文件，您将每次刷新页面都会看到一个随机引用，如下面的截图所示：
- en: '![PHP](img/08960S_03_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![PHP](img/08960S_03_01.jpg)'
- en: HTML
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML
- en: We need an HTML page to load our PHP-generated quote. Within the HTML, we define
    a simple HTML layout. We create a division element with the class `left`. This
    box simply holds the title **Famous Einstein Quotes**. We define a second div
    element with the class `right` and two child elements, a paragraph and a button.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 HTML 页面来加载我们的 PHP 生成的引用。在 HTML 中，我们定义一个简单的 HTML 布局。我们创建一个具有 `left` 类的分区元素。此框仅包含标题**著名的爱因斯坦语录**。我们定义一个具有
    `right` 类的第二个 div 元素和两个子元素，一个段落和一个按钮。
- en: '![HTML](img/08960S_03_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![HTML](img/08960S_03_02.jpg)'
- en: In the preceding screenshot, the box on the right-hand side made up of the paragraph
    element with a `quote` class is where we will load our dynamic content using jQuery.
    We will use the button to allow the user to trigger the dynamic load of the quote.
    Note that you could also load the quote on page load without the need of user
    interaction.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，右侧的由带有 `quote` 类的段落元素组成的框是我们将使用 jQuery 加载动态内容的地方。我们将使用按钮允许用户触发引用的动态加载。请注意，您还可以在页面加载时加载引用，而无需用户交互。
- en: CSS
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS
- en: 'To make the web page containing our dynamic quotes, we use some very basic
    CSS to style and align the various elements we have created in our HTML as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建包含我们动态引用的网页，我们使用一些非常基本的 CSS 来样式化和对齐我们在 HTML 中创建的各种元素，如下所示：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We make the div element with the `left` class have a static width and height
    and then force it to float on the left-hand side of the browser window. A static
    height is set to ensure that both the left and right div elements are of equal
    height. We also add some basic text formatting including `line-height`, `text-align`,
    and `font-size`, which are self-explanatory. We also change the background color
    of the div element and add some padding for further text alignment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使具有 `left` 类的 div 元素具有固定的宽度和高度，然后强制其浮动到浏览器窗口的左侧。设置固定高度以确保左侧和右侧 div 元素具有相等的高度。我们还添加了一些基本的文本格式设置，包括
    `line-height`、`text-align` 和 `font-size`，这些都是不言自明的。我们还更改了 div 元素的背景颜色，并添加了一些填充以进一步对齐文本。
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We add very similar styles to the right-hand side division element with the
    addition of `position: relative;`, which allows us to prevent sibling elements
    with an absolute position from floating outside this div element.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '我们向右侧的分区元素添加了非常相似的样式，还添加了 `position: relative;`，这样可以防止具有绝对位置的兄弟元素漂浮到此 div 元素之外。'
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As the parent `.right` division element has a relative position, we can make
    the position of the `.refresh` button absolute and set the top and right position
    values as static, forcing the button to float to the top-right corner of our `.right`
    division box.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于父级 `.right` 分区元素具有相对位置，我们可以使 `.refresh` 按钮的位置为绝对，并将顶部和右侧位置值设置为静态，从而强制按钮浮动到我们的
    `.right` 分区框的右上角。
- en: jQuery
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery
- en: Using jQuery, we can make a request to the `request.php` page we created earlier,
    which is on our web server. First, we create an event handler and attach it to
    the refresh button, so we can make a request when the user clicks on this button.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 jQuery，我们可以向我们的 Web 服务器上早些时候创建的 `request.php` 页面发出请求。首先，我们创建一个事件处理程序并将其附加到刷新按钮上，以便在用户单击此按钮时进行请求。
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Any code within `function(){}` will be executed when the user clicks on the
    `.refresh` button. Within this callback function, we can make the AJAX request
    using `$ajax`, which is provided by jQuery:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击`.refresh`按钮时，`function(){}`内的任何代码都将被执行。在这个回调函数中，我们可以使用 jQuery 提供的`$ajax`进行
    AJAX 请求：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We provide `$.ajax()` with an object, which allows us to specify a set of parameters
    required to make the AJAX call. In this example, we provide the `url` and `type`
    parameters that tell jQuery where to make the request and what kind of request
    it should be.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`$.ajax()`提供一个对象，该对象允许我们指定进行 AJAX 调用所需的一组参数。在本例中，我们提供了`url`和`type`参数，告诉 jQuery
    在哪里进行请求以及请求的类型。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Read the documentation on `$.ajax()` to learn more about other parameters that
    can be provided. The API documentation can be found at [http://api.jquery.com/jQuery.ajax/](http://api.jquery.com/jQuery.ajax/).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读`$.ajax()`的文档，了解可以提供的其他参数。API 文档可以在[http://api.jquery.com/jQuery.ajax/](http://api.jquery.com/jQuery.ajax/)找到。
- en: 'Additionally, we append a `.done()` function after the AJAX request method
    and provide it with a callback function that accepts the argument `data`. This
    `data` argument will hold the response from the server. Within the callback function,
    we use `$(''.quote'').html(data);` to replace the HTML in the `.quote` paragraph
    with the response from our PHP script. If a user visits this HTML page and clicks
    on the **Get Quote** button, they will be presented with a result as shown in
    the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们在 AJAX 请求方法后添加`.done()`函数，并提供一个接受`data`参数的回调函数。这个`data`参数将保存来自服务器的响应。在回调函数中，我们使用`$('.quote').html(data);`来用我们的
    PHP 脚本的响应替换`.quote`段落中的 HTML。如果用户访问这个 HTML 页面并点击**获取报价**按钮，他们将看到如下截图中的结果：
- en: '![jQuery](img/08960S_03_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![jQuery](img/08960S_03_03.jpg)'
- en: See also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请参见
- en: '*Creating a search feature*'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建搜索功能*'
- en: '*Creating an autosuggest feature*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建自动建议功能*'
- en: '*Waiting for an AJAX response*'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待 AJAX 响应*'
- en: Using AJAX and handling server errors
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AJAX 处理服务器错误
- en: In an ideal world, your web application would never go wrong. Unfortunately,
    this is not the case, and web developers need to gracefully handle errors and
    provide the user with useful feedback.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界里，你的 Web 应用程序永远不会出错。不幸的是，事实并非如此，Web 开发人员需要优雅地处理错误，并为用户提供有用的反馈。
- en: For example, system errors occur when a server cannot be reached or a file/web
    page is missing. System errors are typically unavoidable and out of the user's
    control. They differ from application errors such as invalid data input, which
    a user can correct.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当服务器无法访问或文件/网页丢失时，会发生系统错误。系统错误通常是不可避免的，超出用户的控制范围。它们与应用程序错误（如无效的数据输入）不同，用户可以进行更正。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since this recipe deals with AJAX errors and we will be calling a PHP script
    that does not exist, we only require HTML and JavaScript for this recipe. Create
    a blank HTML document named `recipe-2.html` and ensure that you have the latest
    version of jQuery downloaded and ready for use.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个示例涉及到 AJAX 错误，并且我们将调用一个不存在的 PHP 脚本，所以我们只需要 HTML 和 JavaScript。创建一个名为`recipe-2.html`的空白
    HTML 文档，并确保你已经下载并准备好了最新版本的 jQuery。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怎样去做…
- en: 'Learn how to handle AJAX errors by carefully performing the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何通过仔细执行以下步骤来处理 AJAX 错误：
- en: 'Add the following HTML code to create a simple web page with a single button
    that will trigger an AJAX request:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 HTML 代码以创建一个简单的网页，其中只有一个按钮，将触发一个 AJAX 请求：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Within the script tags, add the following jQuery code that will make an AJAX
    request to a nonexistent file when the `#makeRequest` button has been clicked:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签中，添加以下的 jQuery 代码，当`#makeRequest`按钮被点击时，将向不存在的文件发出 AJAX 请求：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Under the AJAX request (but still within `$(function(){});`), add the following
    code, which will create a global AJAX error event handler that is fired every
    time an AJAX request fails:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AJAX 请求之后（但仍在`$(function(){});`中），添加以下代码，它将创建一个全局的 AJAX 错误事件处理程序，每当 AJAX 请求失败时都会触发：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运作原理…
- en: The HTML page we created is self-explanatory. We create a button that can trigger
    the AJAX request. This is obviously the simplest example to illustrate the error
    handling concept, which can then be applied to any AJAX request situation using
    jQuery.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 HTML 页面是不言自明的。我们创建了一个按钮，可以触发 AJAX 请求。这显然是用来说明错误处理概念的最简单的例子，然后可以应用到使用 jQuery
    的任何 AJAX 请求情况。
- en: 'We create an event handler for the `#makeRequest` button and provide a callback
    function to be executed on-click as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`#makeRequest`按钮创建了一个事件处理程序，并提供了一个回调函数来在单击时执行：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We add the AJAX request within the callback function using the `$.ajax()` function
    provided by jQuery. We then pass a JavaScript object to this method, where we
    specify the URL of a nonexistent file and the type of the request; in this case,
    `GET`. Note that the `.done()` function chained onto the `$.ajax()` function will
    never be executed if the AJAX request fails.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过jQuery提供的`$.ajax()`函数在回调函数中添加了AJAX请求。然后，我们将一个JavaScript对象传递给这个方法，在这个方法中，我们指定了一个不存在文件的URL和请求的类型；在这种情况下，`GET`。请注意，如果AJAX请求失败，则`$.ajax()`函数链接到`.done()`函数的功能将永远不会被执行。
- en: 'We create a global AJAX error handler and attach it to the document so that
    it will catch all AJAX errors within our page:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个全局AJAX错误处理程序，并将其附加到文档上，以便它能够捕获我们页面中的所有AJAX错误：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are three arguments provided to the callback function of the `.ajaxError`
    method that we can use to learn more about the error. In this example, we extract
    the target URL from the `settings` variable and the status information from the
    `request` object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.ajaxError`方法的回调函数中提供了三个参数，我们可以使用这些参数了解有关错误的更多信息。在这个例子中，我们从`settings`变量和`request`对象中提取目标URL的信息和状态信息。
- en: 'If you open this HTML file in a web browser and click on the `#makeRequest`
    button, you will be presented with a JavaScript alert box that provides you information
    about the error, as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Web浏览器中打开此HTML文件并单击`#makeRequest`按钮，将显示一个JavaScript警报框，其中提供有关错误的信息，如下面的屏幕截图所示：
- en: '![How it works…](img/08960S_03_04.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/08960S_03_04.jpg)'
- en: There's more…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this example, we created a global AJAX error handler to catch all the AJAX
    request errors within our page. A global AJAX error handler is ideal for request
    errors such as file missing or host unreachable. In these cases, errors can be
    handled in the same way for all AJAX requests, and more specific information about
    an individual request is not required.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个全局AJAX错误处理程序来捕获页面中的所有AJAX请求错误。全局AJAX错误处理程序非常适合请求错误，例如文件丢失或主机不可达。在这些情况下，可以以相同的方式处理所有AJAX请求的错误，并且不需要有关个别请求的更具体的信息。
- en: 'There might be instances in your application where you may need to handle one
    or more AJAX request errors differently. For this, you can use the `.fail()` function,
    which is used in the same way as `.done()`. The following jQuery code provides
    an example usage of `.fail()` to achieve the same result for a simple AJAX request
    as our global error handler:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中可能会出现这样的情况，您可能需要以不同的方式处理一个或多个AJAX请求错误。为此，您可以使用`.fail()`函数，该函数与`.done()`的使用方式相同。以下jQuery代码提供了一个使用`.fail()`的示例用法，以实现一个简单的AJAX请求的全局错误处理相同的结果：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that there is less information directly available about the error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关于错误的直接可用信息较少。
- en: Processing JSON data
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理JSON数据
- en: '**JavaScript Object Notation** (**JSON**) provides web developers with a clean
    and efficient way to encode data. JSON is a widely adopted format. It simplifies
    data processing and manipulation. To read more about why you should use JSON,
    visit [http://www.revillweb.com/why-use-json/](http://www.revillweb.com/why-use-json/).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）为Web开发人员提供了一种干净高效的数据编码方式。JSON是一种被广泛采用的格式。它简化了数据处理和操作。要了解更多关于为什么应该使用JSON的信息，请访问[http://www.revillweb.com/why-use-json/](http://www.revillweb.com/why-use-json/)。'
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that your web server is running and you have access to the web root where
    you can save/upload the files that you will create as part of this recipe.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的Web服务器正在运行，并且您可以访问您可以保存/上传作为此配方的一部分创建的文件的网络根目录。
- en: How to do it…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Learn how to use JSON-formatted data with JavaScript by performing the following
    steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下步骤来学习如何使用JavaScript处理JSON格式的数据：
- en: 'Create a PHP file named `request-3.php` and save it to the web root of your
    web server. Use the following PHP code to create and output a list of names as
    JSON data:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`request-3.php`的PHP文件，并将其保存到您的网络服务器的网络根目录中。使用以下PHP代码创建并输出一个名字列表作为JSON数据：
- en: '[PRE18]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create an HTML page named `recipe-3.html` within the web root of your web server.
    Add the following HTML to this page, which creates an unordered list element that
    can be populated with our JSON data once processed:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网络服务器的网络根目录中创建一个名为`recipe-3.html`的HTML页面。将以下HTML添加到此页面中，它创建了一个无序列表元素，一旦处理完成我们的JSON数据，就可以填充该元素：
- en: '[PRE19]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Within the script tags in the head tag of the HTML page, add the following
    jQuery code to perform an AJAX request to the `request-3.php` page created earlier:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 HTML 页面的 head 标签内的 script 标签中，添加以下 jQuery 代码以执行对之前创建的`request-3.php`页面的 AJAX
    请求：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Within the `.done()` callback function, use the jQuery `$.each()` function
    to process the JSON data returned from our PHP page and add a new list item for
    each person to the list within our HTML page:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.done()`回调函数中，使用 jQuery 的`$.each()`函数处理来自我们的 PHP 页面返回的 JSON 数据，并为列表中的每个人添加一个新的列表项到我们的
    HTML 页面中：
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行原理...
- en: Now, let us understand the steps performed previously in detail.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细了解之前执行的步骤。
- en: PHP
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: In a real-world application, you would typically be retrieving data from a database.
    In this recipe, we are creating a simple, two-dimensional array of names that
    will act as our database, allowing us to concentrate on the jQuery code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，你通常会从数据库中检索数据。在这个示例中，我们创建了一个简单的二维姓名数组作为我们的“数据库”，允许我们集中精力编写 jQuery 代码。
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we manually specify the response content type and character set. The
    content type and character set of the response should be specified so that the
    web browser and jQuery code know the format in which to expect the data. Most
    web browsers will work this out without an issue. However, Internet Explorer 9
    and lower versions are particularly problematic in this area, and it is always
    good practice to manually specify the content type and charset using the PHP''s
    `header()` function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们手动指定响应内容类型和字符集。要指定响应的内容类型和字符集，以便 web 浏览器和 jQuery 代码知道期望数据的格式。大多数web 浏览器都可以很好地解决这个问题。然而，Internet
    Explorer 9及更低版本在这个领域特别棘手，手动使用 PHP 的 `header()` 函数指定内容类型和字符集始终是一个好的做法：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that we have set the charset as `UTF-8`, not `utf8` or `utf-8`. Once again,
    most browsers will be fine with either, but some earlier Internet Explorer versions
    will produce undesirable effects if the character set is not formatted correctly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的字符集设置为`UTF-8`，而不是 `utf8` 或 `utf-8`。再次提醒，大多数浏览器都可以接受任一种设置，但一些较早的 Internet
    Explorer 版本在字符集格式不正确时会产生不良影响。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The browser-related issues mentioned in this recipe are not likely to occur
    within this example with such simple data. This is a best practice and will provide
    a greater benefit to larger and more complex web applications that use AJAX and
    JSON.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，与这样简单的数据不太可能出现本文中提到的与浏览器相关的问题。这是一种最佳实践，将为更大型、更复杂的使用 AJAX 和 JSON 的 Web
    应用程序提供更大的益处。
- en: 'Finally, we encode our PHP array in the JSON format using the PHP provided
    `json_encode()` function and output the results using `echo` as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 PHP 提供的 `json_encode()` 函数将我们的 PHP 数组编码为 JSON 格式，并使用`echo`输出结果如下：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you visit the `request-3.php` page directly, you will see the output of
    the `people` array within the browser window in the following format:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果直接访问`request-3.php`页面，你会在浏览器窗口中看到以下格式的`people`数组的输出：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Alternatively, using the browser developer tools and selecting the network tab,
    you can view the response in a more readable manner.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用浏览器开发工具并选择网络选项卡，以更可读的方式查看响应。
- en: HTML
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML
- en: Our HTML page does nothing more than include the jQuery library and creates
    an HTML unordered list element, which we can populate with the JSON data once
    processed by jQuery.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 HTML 页面除了包含 jQuery 库外，还创建了一个 HTML 无序列表元素，我们可以在 jQuery 处理后将其填充为 JSON 数据。
- en: jQuery
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery
- en: 'Putting our code within `$(function(){});`will lead to its execution on page
    load. We use jQuery''s `$.ajax()` functionality to make the AJAX request to our
    previously created PHP file as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的代码放在`$(function(){});`中将导致页面加载时执行它。我们使用 jQuery 的`$.ajax()`功能来对先前创建的 PHP
    文件执行 AJAX 请求，方法如下：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By providing the `url` and `type` parameters within an object to this method,
    we tell a method to make a `GET` request to the `request-3.php` file present in
    the web root of our web server. We then append a `.done()` function onto the `$.ajax();`
    method, which will be executed when the request has been made successfully. The
    `.done()` method takes a callback function as an argument with the `data` variable
    that contains all the response data from the request—the JSON data from the PHP
    file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在对象中提供`url`和`type`参数给这个方法，我们告诉方法对我们的 web 服务器的 web root 中存在的`request-3.php`文件发出`GET`请求。然后我们在`$.ajax();`方法上附加了一个`.done()`函数，当请求成功发送时，将执行该函数。`.done()`方法采用回调函数作为参数，该回调函数包含来自请求的响应数据的`data`变量——来自
    PHP 文件的 JSON 数据。
- en: 'Now that we have the response data available within the `data` variable, we
    can process the JSON data and populate our HTML list element using the following
    code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`data`变量中获得了响应数据，我们可以处理 JSON 数据并使用以下代码填充我们的 HTML 列表元素：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`$.each();` is another function provided by jQuery which allows us to loop
    through a set of data that is specified as the first argument in this example
    (that is, `data`). The second argument is the callback function to execute for
    each of the items found within the `data` variable. This callback function also
    takes two arguments, `key` and `value`. Using these variables, we can get all
    the information from the JSON data including the array key (for example, 1, 2,
    3, and so on) and the values; the first and last names for each object.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`$.each();`是 jQuery 提供的另一个函数，它允许我们循环遍历作为第一个参数指定的一组数据（在本例中是`data`）。第二个参数是要对`data`变量中找到的每个项目执行的回调函数。这个回调函数还接受两个参数，`key`和`value`。使用这些变量，我们可以从
    JSON 数据中获取所有信息，包括数组键（例如，1、2、3 等）和值；每个对象的名字和姓氏。'
- en: Finally, we select the `#peopleList` element, and we use the `append()` function
    to append an HTML list item to the unordered list with the data from each of the
    `people` JSON objects.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们选择`#peopleList`元素，并使用`append()`函数将 HTML 列表项附加到每个`people`JSON 对象的无序列表中。
- en: See also
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Searching JavaScript objects*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*搜索 JavaScript 对象*'
- en: '*Sorting JavaScript objects*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对 JavaScript 对象进行排序*'
- en: Searching JavaScript objects
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索 JavaScript 对象
- en: With objects being the main method of holding data within your application,
    it can be very useful to be able to find objects matching a certain criteria.
    jQuery does not provide a direct method for us to search through objects and arrays
    of objects; however, we can easily create this functionality.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象是在应用程序中保存数据的主要方法，因此能够找到符合特定条件的对象非常有用。jQuery 并未为我们提供直接搜索对象和对象数组的方法；但是，我们可以很容易地创建此功能。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Using your favorite text editor, create a blank HTML document named `recipe-4.html`,
    and ensure that you have the latest version of jQuery installed. Add the following
    HTML code to this HTML file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的文本编辑器，创建一个名为`recipe-4.html`的空白 HTML 文档，并确保你已安装了最新版本的 jQuery。将以下 HTML 代码添加到此
    HTML 文件中：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Ensure that you update the reference to the jQuery library to point out the
    location where it is saved on your computer. This HTML page provides us with a
    web page where we can execute JavaScript for this recipe.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你更新了对 jQuery 库的引用，以指出它在计算机上保存的位置。这个 HTML 页面为我们提供了一个网页，我们可以在此处执行这个配方的 JavaScript。
- en: How to do it…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a JavaScript function that will make searching through an object easy
    by performing the following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 JavaScript 函数，通过执行以下步骤可以轻松地搜索对象：
- en: 'Within the script tags of the newly created `recipe-4.html` page, create an
    array of objects on which we can perform searches:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的`recipe-4.html`页面的脚本标签中，创建一个对象数组，我们可以对其执行搜索：
- en: '[PRE29]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Below this array of objects, add the following recursive function that we can
    use to iterate through the preceding objects and find matches based on the provided
    arguments:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个对象数组下面，添加以下递归函数，我们可以用它来遍历前面的对象，并根据提供的参数找到匹配项：
- en: '[PRE30]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Call the function by specifying the parameter you would like to look for, the
    value you would like to match, and then the object/objects you would like to search
    through:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过指定要查找的参数、要匹配的值，然后是要搜索的对象/对象来调用该函数：
- en: '[PRE31]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Open `recipe-4.html` in a browser and then the JavaScript console (*Ctrl* +
    *Shift* + *J* in Chrome); you will be presented with the results of the search.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`recipe-4.html`，然后打开 JavaScript 控制台（在 Chrome 中按 *Ctrl* + *Shift* + *J*）；你将看到搜索结果。
- en: How it works…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: First of all, an array of objects representing people is created. This does
    not need to be a static set of data and could have been loaded from an AJAX request
    as seen in the previous recipes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个表示人员的对象数组。这不需要是静态数据集，可以像前面的示例中那样从 AJAX 请求中加载。
- en: Our `findObjects()` function will allow us to search through an object or an
    array of objects. This function takes three arguments. The first argument is `parameter`,
    which is the object we want to search within; in this example, `title`. The second
    argument is the actual value we want to find matches against; the above example
    uses `Sir`. The final argument is the array of objects we created.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `findObjects()` 函数将允许我们搜索一个对象或对象数组。这个函数接受三个参数。第一个参数是 `parameter`，即我们想要在其中搜索的对象；在这个例子中是
    `title`。第二个参数是我们想要查找匹配项的实际值；上面的例子使用了 `Sir`。最后一个参数是我们创建的对象数组。
- en: 'We first create an empty array within the function, which will hold each of
    the objects that match our specified criteria:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在函数内部创建一个空数组，这个数组将保存符合我们指定条件的每个对象：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using the native JavaScript `for` loop, we can iterate through the object/objects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生的 JavaScript `for` 循环，我们可以遍历对象/对象数组。
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we provide an array of objects, `object[i]` will represent a different object
    within the array on each iteration. If we provided a single object, then `i` will
    be a different property within the provided object on each iteration.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供了一个对象数组，`object[i]` 在每次迭代中将代表数组内的不同对象。如果我们提供了单个对象，那么 `i` 将在每次迭代中代表所提供对象内的不同属性。
- en: 'Since JavaScript objects can also hold other objects or arrays, we need to
    allow for recursion so that we can search through an infinite depth of objects.
    To do this, we first check to see if `object[i]` (the currently iterated object
    or property value) is an object. If it is, we call our `findObjects()` function
    from within itself and provide the current object as the last argument:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 对象也可以包含其他对象或数组，我们需要允许递归，以便能够搜索无限深度的对象。为此，我们首先检查 `object[i]`（当前迭代的对象或属性值）是否为对象。如果是，我们从函数内部调用我们自己的
    `findObjects()` 函数，并将当前对象作为最后一个参数提供：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As the `findObjects()` function will return an array of matches, we use `matches
    = matches.concat()` to add the array of returned results to the current array
    of matches. We add an `else if` statement to filter instances where the value
    is not an object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `findObjects()` 函数将返回一组匹配项，我们使用 `matches = matches.concat()` 将返回结果的数组添加到当前匹配项数组中。我们添加了一个
    `else if` 语句来过滤值不是对象的情况。
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Within the `else if` statement, we check to see if the current property (represented
    by `i`) matches the parameter we provided as an argument. If this is true, we
    check whether the value for this property matches the value we provided as an
    argument. If this is also true, we use `matches.push(object)` to add the current
    object to the `matches` array. Finally, once we have iterated through all the
    objects and properties, we return the `matches` array.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `else if` 语句中，我们检查当前属性（由 `i` 表示）是否与我们提供的参数匹配。如果是，则检查该属性的值是否与我们提供的参数值匹配。如果也是，则使用
    `matches.push(object)` 将当前对象添加到 `matches` 数组中。最后，一旦我们遍历了所有对象和属性，我们就返回 `matches`
    数组。
- en: In the preceding example, we then simply use `console.log();` to output the
    array of matching objects to the browser's JavaScript console. This array can
    be used in any manner, such as to populate an HTML list element.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们简单地使用 `console.log();` 将匹配的对象数组输出到浏览器的 JavaScript 控制台。这个数组可以以任何方式使用，比如填充
    HTML 列表元素。
- en: There's more…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Searching through JavaScript objects will often become a common part of your
    application. Be sure to make functions such as this as universal as possible,
    and do not code them for a single operation. You will then be able to make this
    function globally available within your application and re-use it throughout.
    Also, be careful when writing recursive functions, as it is easy to create infinite
    loops and complex, unreadable code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 对象中搜索通常会成为你应用程序的常见部分。确保将此类函数尽可能地制作成通用的，并且不要将其编码为单一操作。然后，你将能够在应用程序中全局使用此函数，并在整个应用程序中重复使用它。此外，在编写递归函数时要小心，因为很容易创建无限循环和复杂难读的代码。
- en: See also
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Processing JSON data*'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理 JSON 数据*'
- en: '*Sorting JavaScript objects*'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对 JavaScript 对象进行排序*'
- en: Sorting JavaScript objects
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 JavaScript 对象进行排序
- en: Along with the ability to efficiently find objects that match a criteria, you
    will often require your objects to be in a certain order for outputting.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够高效地找到符合条件的对象外，你通常还需要将对象按照某种顺序输出。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As with the previous recipe, create an HTML page named `recipe-5.html` where
    we can add and execute JavaScript code for this recipe using the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例一样，创建一个名为 `recipe-5.html` 的 HTML 页面，我们可以使用以下代码为此示例添加和执行 JavaScript 代码：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Update the reference to the jQuery library in order to ensure that it includes
    the correct file on your computer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 jQuery 库的引用，以确保在您的计算机上包含正确的文件。
- en: How to do it…
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a reusable function to sort a JavaScript object by performing the following
    step-by-step instructions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可重复使用的函数来对 JavaScript 对象进行排序，执行以下逐步说明：
- en: 'Within the script tags in the `recipe-5.html` file you have just created, add
    the following JavaScript code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您刚刚创建的 `recipe-5.html` 文件中的脚本标签中，添加以下 JavaScript 代码：
- en: '[PRE37]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Below this array, add the following function that can be used to sort JavaScript
    objects within an array:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此数组下方，添加以下可用于对数组中的 JavaScript 对象进行排序的函数：
- en: '[PRE38]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Use this function with the native JavaScript `.sort()` function as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此函数与原生 JavaScript 的 `.sort()` 函数如下所示：
- en: '[PRE39]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Opening this web page in a browser and looking at the JavaScript console will
    provide you with a list of the objects we created in the JavaScript array in step
    1\. The difference is that they will be ordered by the last name as opposed to
    their original order.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开此网页并查看 JavaScript 控制台，将为您提供我们在步骤 1 中创建的 JavaScript 数组中的对象列表。不同之处在于它们将按姓氏排序，而不是它们的原始顺序。
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We must have an array of objects to successfully use our `.sort()` function
    to reorder them. This array of objects can be static, as in the example, or can
    be loaded from a server via an AJAX request.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须有一个对象数组，才能成功使用我们的 `.sort()` 函数对其进行重新排序。这个对象数组可以是静态的，就像示例中一样，也可以通过 AJAX 请求从服务器加载。
- en: 'JavaScript provides a `.sort()` function, which takes a function as an argument
    and provides two arguments to this callback function. The typical usage of `.sort()`
    would be as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 提供了一个 `.sort()` 函数，它将一个函数作为参数，并将两个参数提供给此回调函数。`.sort()` 的典型用法如下：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `a` and `b` arguments are two objects from the array. We can compare these
    two objects and determine which object needs to be placed before the other.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 和 `b` 参数是数组中的两个对象。我们可以比较这两个对象，并确定哪个对象需要放在另一个对象之前。'
- en: 'In our example, we require some additional functionality; we need to be able
    to specify which parameter on which we want to sort the objects. As we cannot
    provide the `.sort()` callback function with an additional argument, we wrap the
    callback in another function as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们需要一些额外的功能；我们需要能够指定要对其进行排序的参数。由于无法向 `.sort()` 回调函数提供额外的参数，因此我们将回调包装在另一个函数中，如下所示：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can then specify a property on which to sort the objects, which can then
    be used within the callback function. The callback function must return either
    `0` or a positive or negative number. In our example, `0` means that no sorting
    is required and that both objects are equal. `1` means that `a` should be placed
    before `b` and `-1` means that `b` should be placed before `a`. We can do this
    evaluation within the callback function as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以指定一个属性来对对象进行排序，然后在回调函数中使用。回调函数必须返回 `0` 或正数或负数。在我们的示例中，`0` 表示不需要排序，两个对象相等。`1`
    表示应将 `a` 放在 `b` 之前，`-1` 表示应将 `b` 放在 `a` 之前。我们可以在回调函数中进行此评估，如下所示：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We use `a[param]` and `b[param]` to check only the specified parameter of the
    objects. We can now use this function in conjunction with the native JavaScript
    `.sort()` function to reorder our objects based on the specified parameter as
    follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `a[param]` 和 `b[param]` 仅检查对象的指定参数。现在，我们可以将此函数与原生 JavaScript 的 `.sort()`
    函数结合使用，根据指定的参数重新排序我们的对象，如下所示：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This would alphabetically reorder the array of objects we created earlier by
    their last name. So, the object `Mr John Andrews` would be the first in the array
    and so on.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按字母顺序重新排列我们稍早创建的对象数组，按其姓氏排序。因此，对象 `Mr John Andrews` 将是数组中的第一个对象，依此类推。
- en: There's more…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Similar to the function used for searching objects, this function should not
    be coded for a single operation so that it can be used throughout your application.
    Reusable code will make your application more manageable and easier to debug.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与用于搜索对象的函数类似，此函数不应编码为单个操作，以便在整个应用程序中重复使用。可重复使用的代码将使您的应用程序更易于管理和调试。
- en: See also
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Processing JSON data*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理 JSON 数据*'
- en: '*Searching JavaScript objects*'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*搜索 JavaScript 对象*'
- en: Caching JSON and AJAX requests
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存 JSON 和 AJAX 请求
- en: One way by which a web developer can increase the speed of his/her web application
    is by limiting the number of requests made to the web server. It is very important
    to ensure that you are making data calls only when you need to. We can use caching
    to ensure that requests are made only when a new set of data is required.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Web 开发人员可以增加其 Web 应用程序的速度的一种方法是限制向 Web 服务器发出的请求数量。确保仅在需要时进行数据调用非常重要。我们可以使用缓存来确保只有在需要新的数据集时才发出请求。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that your web server is up and running and you have permission to add
    files to the server's web root directory.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的 Web 服务器正在运行，并且你有权限将文件添加到服务器的 Web 根目录中。
- en: How to do it…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Learn how to speed up your JavaScript applications using simple caching methods
    by performing the following instructions:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何通过简单的缓存方法加速你的 JavaScript 应用程序，按照以下说明执行：
- en: 'Create a PHP file named `request-6.php` in the web root of your web server.
    Use the following PHP code to create and output a list of names as JSON data:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Web 服务器的 Web 根目录中创建一个名为 `request-6.php` 的 PHP 文件。使用以下 PHP 代码创建并输出名称列表作为
    JSON 数据：
- en: '[PRE44]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Use the following HTML code to create a page named `recipe-6.html` within the
    web root of your web server so that you can make AJAX requests to your PHP file:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下 HTML 代码在 Web 服务器的 Web 根目录中创建一个名为 `recipe-6.html` 的页面，以便你可以向你的 PHP 文件发出
    AJAX 请求：
- en: '[PRE45]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Within the script tags in the head tag of the HTML page, add the following
    jQuery code to make an AJAX request to retrieve the `people` array created in
    the PHP file and then cache the results:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 HTML 页面的 head 标签中的 script 标签中，添加以下 jQuery 代码以发出 AJAX 请求，以检索在 PHP 文件中创建的 `people`
    数组，然后缓存结果：
- en: '[PRE46]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works…
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Now, let us understand the steps performed previously in detail.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细了解之前执行的步骤。
- en: PHP
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: Please refer to the previous recipe, *Processing JSON data*, of this chapter
    for a detailed look at how this PHP code works.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章的上一个示例，*处理 JSON 数据*，以详细了解这段 PHP 代码的工作原理。
- en: HTML
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML
- en: The HTML page we created is very basic and does not require a great deal of
    explanation. We simply create an unordered list element, which we can populate
    with jQuery, and a button, which the user can click on to trigger the AJAX request
    to load the JSON data from the PHP file.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 HTML 页面非常基础，不需要太多解释。我们只是创建了一个无序列表元素，我们可以用 jQuery 填充它，并且一个按钮，用户可以点击它来触发从
    PHP 文件加载 JSON 数据的 AJAX 请求。
- en: jQuery
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery
- en: 'First, we create an empty JavaScript array that we can use to cache the data
    received from AJAX requests as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个空的 JavaScript 数组，我们可以用来缓存从 AJAX 请求接收到的数据，如下所示：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Then, within `$(function(){});`, which will be executed on page load, we attach
    a click event handler to the `.getPeople` button.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `$(function(){});` 中，这将在页面加载时执行，我们将点击事件处理程序附加到 `.getPeople` 按钮上。
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Within the callback function for this event handler, we check to see if there
    is currently anything within the `cache` array by evaluating its length:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在此事件处理程序的回调函数中，我们通过评估 `cache` 数组的长度来检查当前是否有任何内容：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If there is nothing in the `cache` array, we do not have any cached data. We
    need to make an AJAX request to our PHP file in order to get the JSON data as
    shown in the following code snippet. This will ensure that an AJAX request is
    made only when data is required, and a request will not be made every time the
    button is clicked.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `cache` 数组中没有任何内容，那么我们没有任何缓存的数据。我们需要向我们的 PHP 文件发出 AJAX 请求，以获取 JSON 数据，如下所示的代码片段所示。这将确保仅在需要数据时才进行
    AJAX 请求，并且每次点击按钮时不会进行请求。
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: On the success of the AJAX request, we store the results within our `cache`
    array. Note that we have set the `async` property to `false`, meaning that any
    JavaScript code below the AJAX request will not be executed until there has been
    a response. This is to prevent the HTML list being populated before the `cache`
    array has been populated with data. This would not be the ideal solution for large
    applications because this can cause the browser to hang or crash if the AJAX request
    takes a long time to respond. Read the *Waiting for an AJAX response* recipe of
    this chapter to learn the preferred method of waiting for AJAX request completion.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AJAX 请求成功时，我们将结果存储在我们的 `cache` 数组中。请注意，我们将 `async` 属性设置为 `false`，这意味着在 AJAX
    请求之后任何 JavaScript 代码都不会被执行，直到有响应为止。这是为了在 `cache` 数组填充数据之前防止 HTML 列表被填充的理想解决方案。对于大型应用程序来说，这不是理想的解决方案，因为如果
    AJAX 请求花费很长时间响应，这可能会导致浏览器挂起或崩溃。阅读本章的 *等待 AJAX 响应* 示例，以了解等待 AJAX 请求完成的首选方法。
- en: With the `cache` array populated, we can use it to add items to our HTML unordered
    list. We use the jQuery `$.each()` function, which allows us to iterate through
    each of the objects within the `cache` array. For each of these objects, we use
    `.append()` to add a list item along with the data from the object to the `#peopleList`
    list.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `cache` 数组被填充后，我们可以使用它来向我们的HTML无序列表中添加项目。我们使用了jQuery的 `$.each()` 函数，它允许我们遍历
    `cache` 数组中的每个对象。对于这些对象中的每一个，我们使用 `.append()` 来添加一个列表项以及对象中的数据到 `#peopleList`
    列表中。
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Before we populate the list, we first use `$('#peopleList').empty();` to empty
    the list in the DOM. This is to prevent additional button clicks from adding duplicate
    items.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们填充列表之前，我们首先使用 `$('#peopleList').empty();` 来清空DOM中的列表。这是为了防止额外的按钮点击添加重复的项目。
- en: There's more…
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: This method of caching data can speed up your web application. This method,
    however, will not be suitable for situations where the requested data is changing
    frequently, as the user will only get updated data when they refresh or revisit
    the page.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据缓存方法可以加快你的Web应用程序。然而，这种方法对于请求的数据经常变化的情况不太适用，因为用户只有在刷新或重新访问页面时才会得到更新的数据。
- en: AJAX requests in jQuery have their own form of caching, which is essentially
    the same as the browser cache. Through the settings provided to the `$.ajax()`
    function, you can control how this type of cache works. Although this cache can
    be useful, it does not offer the same level of control as the manual caching method
    we implemented in this recipe.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery中的AJAX请求有它们自己的一种缓存方式，本质上与浏览器缓存是一样的。通过提供给 `$.ajax()` 函数的设置，你可以控制这种缓存的工作方式。虽然这种缓存很有用，但它并没有手动缓存方法所提供的同样级别的控制。
- en: Creating a search feature
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个搜索特性
- en: Allowing your users to search through data within your web application is a
    basic principle. This recipe will show you how to create a fast and efficient
    search feature that uses jQuery and AJAX with a PHP and MySQL backend.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户在你的Web应用程序中搜索数据是一个基本原则。这个示例将向你展示如何使用jQuery和AJAX来创建一个快速高效的搜索功能，后端使用PHP和MySQL。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe not only requires that you have a running web server that has PHP5,
    but you will also need a MySQL server that is ready to accept connections from
    PHP scripts.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法不仅要求你有一个运行着PHP5的Web服务器，还需要一个准备好接受PHP脚本连接的MySQL服务器。
- en: How to do it…
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Learn how to create a search feature from scratch, which will show you valuable
    jQuery principles in action, by performing the following steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何从零开始创建一个搜索特性，这将向你展示有价值的jQuery原则在实际操作中的运行，执行以下步骤：
- en: 'We need to create a database and a table to store the data that the users will
    be able to search. Create a database named `jquerycookbook` on your database server,
    and use the following SQL code to create and populate a table with some data:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个数据库和一张表来存储用户可以搜索的数据。在你的数据库服务器上创建一个名为 `jquerycookbook` 的数据库，并使用下面的SQL代码来创建并填充一张包含一些数据的表：
- en: '[PRE52]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In order to allow the users to search the data present in our database from
    their browser (the client), we need to be able to extract the information from
    the database based on their search. We can do this using PHP to query the MySQL
    database for data based on the search term, which will be provided by the user
    via the client. Before we can do this, we need to be able to connect to the database
    we just created. Create a PHP file named `db.inc.php` within the web root of your
    web server and add the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让用户能够从他们的浏览器（客户端）搜索到我们的数据库中的数据，我们需要能够根据他们的搜索提取出数据库中的信息。我们可以使用PHP来查询MySQL数据库，以根据用户通过客户端提供的搜索词来获取数据。在我们能够做到这一点之前，我们需要能够连接到刚刚创建的数据库。在Web服务器的根目录下创建一个名为
    `db.inc.php` 的PHP文件，并添加以下代码：
- en: '[PRE53]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Be sure to change the `$dbhost`, `$dbuser`, and `$dbpass` values to match your
    configuration.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请确保将`$dbhost`，`$dbuser`和`$dbpass`的值改为与你的配置匹配。
- en: 'Create a PHP file named `search.php` in the web root of your web server and
    add the following code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web服务器的根目录下创建一个名为 `search.php` 的PHP文件，并添加以下代码：
- en: '[PRE54]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create an HTML file named `recipe-7.html` in the web root of your web server
    using the following HTML code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web服务器的根目录下创建一个名为 `recipe-7.html` 的HTML文件，使用以下HTML代码：
- en: '[PRE55]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To make our search feature more attractive, we can use CSS to style the HTML
    page we have just created. You may have noticed that within the HTML page header,
    we included a CSS file named `style-7.css`. Create the `style-7.css` file, save
    it to the web root of your web server, and add the following CSS code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的搜索功能更加吸引人，我们可以使用 CSS 来为我们刚刚创建的 HTML 页面添加样式。您可能已经注意到，在 HTML 页面头部，我们包含了一个名为
    `style-7.css` 的 CSS 文件。创建 `style-7.css` 文件，将其保存到您的 Web 服务器的 Web 根目录中，并添加以下 CSS
    代码：
- en: '[PRE56]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Using jQuery, we will be able to accept the user''s search query and send the
    request to our PHP script. Create a JavaScript file named `script-7.js` within
    the web root of your web server. Note that this was also included within the header
    of the HTML file. Add the following jQuery code to this file:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 jQuery，我们将能够接受用户的搜索查询，并将请求发送到我们的 PHP 脚本。在您的 Web 服务器的 Web 根目录中创建一个名为 `script-7.js`
    的 JavaScript 文件。请注意，这也包含在 HTML 文件的头部中。将以下 jQuery 代码添加到此文件中：
- en: '[PRE57]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Visiting the `recipe-7.html` file on your web server will present you with a
    simply-styled search input, allowing you to perform a search on the stationary
    items we added to our MySQL database. The following screenshot is similar to the
    one you will see after a search is completed:![How to do it…](img/08960S_03_05.jpg)
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问您的 Web 服务器上的 `recipe-7.html` 文件将呈现给您一个简单样式的搜索输入，允许您在我们添加到 MySQL 数据库的静态项上执行搜索。下面的截图与完成搜索后您将看到的类似：![操作步骤…](img/08960S_03_05.jpg)
- en: How it works…
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Now, let us understand the steps performed previously in detail.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细了解之前执行的步骤。
- en: SQL
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL
- en: With the SQL code, we simply tell the SQL script to use the `jquerycookbook`
    database that we created; we create a table named `stationary` and then insert
    five stationary items into the table.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 SQL 代码，我们简单地告诉 SQL 脚本使用我们创建的 `jquerycookbook` 数据库；我们创建一个名为 `stationary` 的表，然后向表中插入五个静态项。
- en: PHP
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: The first PHP script we created, `db.inc.php`, was simply to connect to the
    database we created, which will then allow us to query the data within it. We
    created four variables to hold the hostname of the database server (typically
    localhost), the username, the password, and finally the name of the database to
    which we wish to connect.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第一个 PHP 脚本，`db.inc.php`，只是用来连接到我们创建的数据库，然后允许我们查询其中的数据。我们创建了四个变量来保存数据库服务器的主机名（通常是
    localhost）、用户名、密码，以及我们希望连接的数据库的名称。
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: After we have this information available within our PHP script, we create a
    new `mysqli` connection and select the `jquerycookbook` database for use.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 PHP 脚本中有了这些信息后，我们创建一个新的 `mysqli` 连接，并选择 `jquerycookbook` 数据库供使用。
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Finally, we add some basic error handling code that would stop any further execution
    if the connection to the database server failed. We also provide some information
    about the error for debugging.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一些基本的错误处理代码，如果连接到数据库服务器失败，将停止任何进一步的执行。我们还提供了一些关于错误的信息以供调试。
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now that we have a script that we can call in order to connect to our database,
    it is possible for us to write the PHP script that will take information from
    the client and perform queries on the database.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可以调用以连接到数据库的脚本，我们可以编写 PHP 脚本，从客户端获取信息并对数据库执行查询。
- en: 'First, we create an object named `$data` to hold the results and any errors
    from the script. We create this object using PHP''s `stdClass` as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 `$data` 的对象，用于保存脚本的结果和任何错误。我们使用 PHP 的 `stdClass` 来创建此对象，如下所示：
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Next, we check to see if the request from the client included some `POST` information
    with `text` as the key. This prevents the script from running needlessly if we
    have no query text.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查客户端请求是否包含一些以 `text` 为键的 `POST` 信息。如果没有查询文本，这会防止脚本无谓地运行。
- en: '[PRE62]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: PHP's `isset()` function simply checks to see if the provided argument is set
    and available for use. If there has been some data posted to the script with the
    key `text`, we can continue to connect to the database by including our database
    connection script using `require_once();`. There are various ways by which you
    can include additional PHP files. We use `require_once()` because we cannot continue
    with the execution without the database connection. If the specified file is not
    found when using `require_once()`, the script provides a fatal error and ceases
    the execution.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的`isset()`函数简单地检查提供的参数是否已设置并可供使用。如果已经有一些数据通过键`text`发布到脚本中，我们可以通过使用`require_once();`包含我们的数据库连接脚本来继续连接到数据库。有多种方法可以包含额外的PHP文件。我们使用`require_once()`是因为在没有数据库连接的情况下无法继续执行。如果在使用`require_once()`时找不到指定的文件，则脚本会提供致命错误并停止执行。
- en: '[PRE63]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: After including the database connection file and connecting to the database,
    we can refer to the `$db` connection variable that is instantiated within that
    file. We then use the `real_escape_string()` function that will remove any harmful
    characters from the provided `text` string with the aim to prevent a security
    breach, such as MySQL injection (read more on this at [http://dev.mysql.com/tech-resources/articles/guide-to-php-security-ch3.pdf](http://dev.mysql.com/tech-resources/articles/guide-to-php-security-ch3.pdf)).
    We put `$_POST['text']` through this function and store the result in a `$text`
    variable, which we can now safely use within MySQL queries.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含数据库连接文件并连接到数据库之后，我们可以引用在该文件中实例化的`$db`连接变量。然后我们使用`real_escape_string()`函数，该函数将从提供的`text`字符串中删除任何有害字符，以防止安全漏洞，如MySQL注入（在[http://dev.mysql.com/tech-resources/articles/guide-to-php-security-ch3.pdf](http://dev.mysql.com/tech-resources/articles/guide-to-php-security-ch3.pdf)上阅读更多内容）。我们将`$_POST['text']`传递给此函数，并将结果存储在一个`$text`变量中，现在我们可以安全地在MySQL查询中使用它。
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We construct a MySQL `LIKE` query using the `$text` string and then use `$result
    = $db->query($q);` to execute the query on the database. We first evaluate the
    `$result` variable for a `false` value to determine if the query was executed
    successfully. If the query isn't executed successfully, we store an error within
    the `$data` object.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`$text`字符串构造一个MySQL`LIKE`查询，然后使用`$result = $db->query($q);`在数据库上执行查询。我们首先评估`$result`变量是否为`false`值，以确定查询是否成功执行。如果查询未成功执行，则在`$data`对象中存储错误。
- en: 'If the query is executed successfully, we can prepare the results to send back
    to the client as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询成功执行，我们可以准备将结果发送回客户端，如下所示：
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: By using a `while` loop with `$result->fetch_assoc()`, we are able to iterate
    through each of the results returned from the database query. We can then extract
    the information we require and store each item within the results array in the
    `$data` object. Once this is complete, we set the `success` variable of the `$data`
    object to `true`, which will tell the jQuery within the client that everything
    went according to plan.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用带有`$result->fetch_assoc()`的`while`循环，我们能够迭代返回的每个结果从数据库查询。然后，我们可以提取所需的信息，并将结果数组中的每个项目存储在`$data`对象中。完成此操作后，我们将`$data`对象的`success`变量设置为`true`，这将告诉客户端内部的jQuery一切都按计划进行。
- en: 'Finally, we set the headers in order to force the jQuery to expect JSON data,
    encode our `$data` object into JSON, and output the encoded data as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置标题以强制jQuery期望JSON数据，将我们的`$data`对象编码为JSON，并将编码数据输出如下：
- en: '[PRE66]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: HTML
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML
- en: The HTML page we created provides the user with an input where they can type
    in their search query and a button to submit the search. It provides us with an
    unordered list element to display the results to the user. We also create a div
    element showing a **Loading…** message with the help of jQuery, which will be
    displayed when the AJAX request is made.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的HTML页面为用户提供了一个输入框，他们可以在其中输入他们的搜索查询，并提供了一个按钮来提交搜索。它为我们提供了一个无序列表元素来向用户显示结果。我们还使用jQuery创建一个显示**加载中...**消息的div元素，这将在进行AJAX请求时显示。
- en: CSS
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS
- en: The CSS we created positions our HTML elements on the page and styles each item
    to provide a greater user experience. Note that we are using Google Fonts to add
    additional aesthetics to our search feature; you can read more about this at [http://www.google.com/fonts/](http://www.google.com/fonts/).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的CSS将我们的HTML元素定位在页面上并为每个项目设置样式，以提供更好的用户体验。请注意，我们正在使用Google字体为我们的搜索功能添加额外的美学效果；您可以在[http://www.google.com/fonts/](http://www.google.com/fonts/)上阅读更多相关信息。
- en: jQuery
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery
- en: 'Within the `script-7.js` file, we perform three actions on page load as shown
    in the following code snippet:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `script-7.js` 文件中，我们在页面加载时执行三个操作，如下所示：
- en: '[PRE67]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Firstly, we hide the results list using `$('#results-list').hide();` so that
    it will be hidden by default. We then attach a click event handler to the search
    button which will perform the search when this button is clicked. Within the callback
    function for this event handler, we call the `doSearch();` function, which is
    declared later in our JavaScript file. The final action that we perform on page
    load is adding a `keydown` event handler to the search input which allows us to
    detect if the *Enter* key has been pressed. If it has, we can call the `doSearch();`
    function to trigger the search.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `$('#results-list').hide();` 隐藏结果列表，这样默认情况下它将被隐藏。然后，我们将点击事件处理程序附加到搜索按钮，当单击此按钮时将执行搜索。在此事件处理程序的回调函数中，我们调用
    `doSearch();` 函数，该函数在我们的 JavaScript 文件中稍后声明。我们在页面加载时执行的最后一个操作是向搜索输入添加 `keydown`
    事件处理程序，以便我们可以检测是否按下了 *Enter* 键。如果是，我们可以调用 `doSearch();` 函数来触发搜索。
- en: The `doSearch()` function performs the AJAX request, sending the search query
    text to the PHP script. It also processes the response and updates the HTML page
    appropriately. The function gets the inputted text from the search input using
    `$('#text').val();` and stores it in the `searchText` variable for use. It also
    hides `#results-list` to ensure that it is always hidden before the AJAX request
    is made, providing room to display the loading text.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`doSearch()` 函数执行 AJAX 请求，将搜索查询文本发送到 PHP 脚本。它还处理响应并相应地更新 HTML 页面。该函数使用 `$(''#text'').val();`
    从搜索输入中获取输入的文本，并将其存储在 `searchText` 变量中以供使用。它还隐藏 `#results-list`，以确保在进行 AJAX 请求之前始终隐藏它，为显示加载文本提供空间。'
- en: '[PRE68]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This function uses the jQuery-provided `$.ajax()` method to set up and make
    an AJAX request to our `search.php` script:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用 jQuery 提供的 `$.ajax()` 方法来设置并发出到我们的 `search.php` 脚本的 AJAX 请求：
- en: '[PRE69]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The initial parameters we provide to the AJAX function are the URLs in which
    we wish to make the request, the type of request we would like to make, and the
    data we would like to send with the request. We specify the request target as
    the `search.php` file and the request type as `POST`, so we can send data to the
    PHP file without needing it to be within the URL. Within the data object, we put
    the `searchText` variable with a key of `text`, which will be picked up by our
    PHP script that we created earlier, allowing it to use the user-inputted text.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供给 AJAX 函数的初始参数是我们希望进行请求的 URL、我们希望进行的请求类型以及我们希望随请求发送的数据。我们将请求目标指定为 `search.php`
    文件，将请求类型指定为 `POST`，这样我们就可以发送数据到 PHP 文件而无需将其放在 URL 中。在数据对象中，我们将 `searchText` 变量放置在
    `text` 键下，这将被我们之前创建的 PHP 脚本拾取，使其能够使用用户输入的文本。
- en: We include `beforeSend` after these initial parameters, which allows us to specify
    a callback function to be executed just before the AJAX request is made. We are
    able to add some animation and show the `.loading` div element within this function
    using `$('.loading').fadeIn();`. This will display the **Loading…** text, informing
    the user that the request is in progress. Within the `success` callback function,
    which is executed once the request is successful and a response has been received,
    we are able to hide the **Loading…** div element with some additional animation
    using `$('.loading').fadeOut();`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些初始参数之后，我们包含 `beforeSend`，这允许我们指定在 AJAX 请求发出之前执行的回调函数。我们能够通过此函数使用 `$('.loading').fadeIn();`
    添加一些动画并显示 `.loading` div 元素。这将显示 **Loading…** 文本，告知用户请求正在进行中。在 `success` 回调函数中，该函数在请求成功且已收到响应时执行，我们能够使用
    `$('.loading').fadeOut();` 使用一些额外的动画隐藏 **Loading…** div 元素。
- en: The `success` callback function has the data argument which will hold all of
    the response data from the PHP file. Looking back at the PHP script, you will
    remember the `$data` object we created to store information about the response.
    We check to see if the `success` property of this object is set to `true`, meaning
    that the query was successful.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`success` 回调函数具有数据参数，该参数将保存来自 PHP 文件的所有响应数据。回顾一下 PHP 脚本，您将记得我们创建的 `$data` 对象用于存储有关响应的信息。我们检查此对象的
    `success` 属性是否设置为 `true`，这意味着查询成功。'
- en: '[PRE70]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If the `success` property is not set to `true` and something does go wrong,
    we then use `alert(data.error);` to alert the user with the error message created
    by the `search.php` script.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `success` 属性未设置为 `true` 并且出现了问题，我们将使用 `alert(data.error);` 通过 `search.php`
    脚本创建的错误消息警告用户。
- en: 'If `data.success` is set to `true`, we can process the search results and update
    the HTML page as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`data.success`被设置为`true`，我们可以按照以下方式处理搜索结果并更新 HTML 页面：
- en: '[PRE71]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Within the `if` statement, we empty the results list of any data to prevent
    multiple searches from duplicating results. We do this using `$(''#results-list'').empty();`.
    Then, we check the length of `results`. If there are results, we need to process
    them; otherwise, we display a message to the users informing them that their search
    did not return any results. This is done with the following code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`语句内，我们清空结果列表中的任何数据，以防止多次搜索重复结果。我们使用`$('#results-list').empty();`来执行此操作。然后，我们检查`results`的长度。如果有结果，我们需要处理它们；否则，我们向用户显示消息，告知他们的搜索没有返回任何结果。以下是代码：
- en: '[PRE72]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If the `data.results.length > 0` condition is evaluated as `true`, it means
    that there are results to display, and hence, we use the jQuery `$.each()` function
    to iterate through each of the results in the response and append them to the
    results list as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`data.results.length > 0`条件被评估为`true`，这意味着有结果要显示，因此，我们使用 jQuery 的`$.each()`函数来迭代响应中的每个结果，并将它们附加到结果列表中，如下所示：
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, the users' search results will be visible within the list.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户的搜索结果将显示在列表中。
- en: See also
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Creating an autosuggest feature*'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建自动建议功能*'
- en: Creating an autosuggest feature
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自动建议功能
- en: Autosuggest features are in abundance on the Internet. There are many plugins
    available for jQuery and jQuery UI which will allow you to add the autosuggest
    feature to your site quickly and easily. This recipe will show you how to create
    one from scratch which you can customize and add your own unique features to.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有大量的自动建议功能。有许多可用于 jQuery 和 jQuery UI 的插件，可以让您快速轻松地将自动建议功能添加到您的网站中。本配方将向您展示如何从头开始创建一个自动建议功能，您可以自定义并添加自己的独特功能。
- en: Getting ready
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The server-side code for this recipe mirrors that of the previous one. Ensure
    that you have a web server and a MySQL database server running and ready to use.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的服务器端代码与上一个配方相似。确保您的 Web 服务器和 MySQL 数据库服务器正在运行并且可以使用。
- en: How to do it…
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following are the steps to create an autosuggest feature:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建自动建议功能的步骤：
- en: Please refer to the previous recipe of this chapter, *Creating a search feature*,
    to create and set up a stationary database and the `search.php` script. We will
    be using the exact same code for the autosuggest feature.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参考本章的前一配方*创建搜索功能*，以创建和设置一个静态数据库和`search.php`脚本。我们将使用完全相同的代码来实现自动建议功能。
- en: 'Within the web root of your web server, create an HTML file named `recipe-8.html`.
    Add the following HTML code to create the basics of the autosuggest user interface:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 Web 服务器的 Web 根目录中，创建一个名为`recipe-8.html`的 HTML 文件。添加以下 HTML 代码以创建自动建议用户界面的基础：
- en: '[PRE74]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You may have noticed that within the header of our `recipe-8.html` file, we
    have included a cascading stylesheet named `style-8.css`. Create this file and
    save it within the web root of your web server. Add the following CSS code, which
    will style and position the HTML elements within `recipe-8.html`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在我们的`recipe-8.html`文件的头部，我们已经包含了一个名为`style-8.css`的级联样式表。创建此文件并将其保存在您的
    Web 服务器的 Web 根目录中。添加以下 CSS 代码，将样式和定位应用到`recipe-8.html`中的 HTML 元素：
- en: '[PRE75]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Along with the CSS file, we are also including `script-8.js` into our HTML
    page. Create this JavaScript file and add the following code:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了 CSS 文件之外，我们还将`script-8.js`包含在我们的 HTML 页面中。创建此 JavaScript 文件并添加以下代码：
- en: '[PRE76]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Visiting `recipe-8.html` served by a web server will present you with the autosuggest
    feature. It will suggest items based on the text inputted into the textbox as
    you type. There will be no suggestions until the user inputs more than two characters.
    This is shown in the following screenshot:![How to do it…](img/08960S_03_06.jpg)
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问由 Web 服务器提供的`recipe-8.html`将向您呈现自动建议功能。它将根据输入到文本框中的文本提供建议，而您键入。在用户输入超过两个字符之前，不会提供任何建议。这在以下截图中显示：![如何做…](img/08960S_03_06.jpg)
- en: How it works…
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Now, let us understand the steps performed previously in detail.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细了解以前执行的步骤。
- en: SQL and PHP
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL 和 PHP
- en: Please refer to the previous recipe of this chapter, *Creating a search feature*,
    which will explain in detail how the SQL and PHP code is created.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章的前一配方*创建搜索功能*，其中详细说明了 SQL 和 PHP 代码的创建过程。
- en: HTML
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML
- en: The HTML file we created is very simple. We create an input box which allows
    the user to input text, and we create an unordered list element which we can populate
    with suggestions using jQuery.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的HTML文件非常简单。我们创建一个输入框，允许用户输入文本，然后我们创建一个无序列表元素，我们可以使用jQuery填充建议。
- en: CSS
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS
- en: The CSS code we created adds basic styling to our feature, which includes the
    positioning of the main text input area.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的CSS代码为我们的功能添加了基本样式，包括定位主文本输入区域。
- en: The main task of this CSS code is to position the suggestion list such that
    suggestions are displayed directly below the input box. For this to be possible,
    we first need to set the position of the `.suggest-input` div element to `relative`.
    This will allow us to have sibling elements which are absolutely positioned, without
    them floating off to other areas of the page.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这段CSS代码的主要任务是定位建议列表，使建议直接显示在输入框下方。为了实现这一点，我们首先需要将`.suggest-input` div元素的位置设置为`relative`。这将允许我们有绝对定位的兄弟元素，而不会让它们漂移到页面的其他区域。
- en: '[PRE77]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: With this positioning set, we can go ahead and add the required styles to our
    `.suggest-list` element, which will hold the suggestions. We need to position
    the element directly below the input box. This means that we will need to make
    the `.suggest-list` element the same width as the input box. We also need to ensure
    that the left and top positions of the `.suggest-list` element are specified,
    taking into account the size and padding of the input textbox.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个定位设置，我们可以继续为我们的`.suggest-list`元素添加所需的样式，该元素将保存建议。我们需要将该元素定位在输入框的正下方。这意味着我们需要使`.suggest-list`元素的宽度与输入框相同。我们还需要确保`.suggest-list`元素的左和顶部位置被指定，考虑到输入文本框的大小和填充。
- en: '[PRE78]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In this section of CSS, we remove any default padding and margins from the
    list element and set its position to absolute. Any element with absolute positioning
    will not be affected by other elements on the page, apart from their parents if
    they have a relative position. This leaves us to be able to set its left and top
    positional values to control exactly where it will sit in relation to the text
    input. We also set the `z-index` value of this element to `100` to ensure that
    it will always float above the other elements on the page. Finally, we use `display:
    none;`, which will make this element hidden by default as we want to display this
    dynamically with jQuery.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '在这段CSS中，我们从列表元素中移除任何默认填充和边距，并将其位置设置为绝对。具有绝对定位的任何元素都不会受到页面上其他元素的影响，除了它们的父元素，如果它们具有相对位置的话。这使我们能够设置其左和顶部位置值，精确控制其相对于文本输入框的位置。我们还将此元素的`z-index`值设置为`100`，以确保它始终浮在页面上的其他元素之上。最后，我们使用`display:
    none;`，这将使此元素默认隐藏，因为我们希望使用jQuery动态显示它。'
- en: jQuery
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery
- en: 'Within our `script-8.js` file, we perform two actions when the page is loaded
    as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`script-8.js`文件中，当页面加载时，我们执行两个动作如下：
- en: '[PRE79]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The former action is to attach a `keyup` event handler to the text input. This
    event handler will execute when the user enters a character into the input box
    and releases a key. Within the callback function, we check the current length
    of the text input using `$('#text').val();`. If this value is greater than `2`,
    we need to look for some suggestions; so, we call the `makeSuggestion()` function,
    which is declared further down in the JavaScript file. We also show the `.suggest-list`
    element using `$('.suggest-list').show();` so that it is visible to the user.
    If the inputted text is less than two characters in length, all we do is ensure
    that the `.suggest-list` is hidden with `$('.suggest-list').hide();`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个动作是将一个`keyup`事件处理程序附加到文本输入上。当用户在输入框中输入字符并释放键时，此事件处理程序将执行。在回调函数中，我们使用`$('#text').val();`检查文本输入的当前长度。如果此值大于`2`，我们需要寻找一些建议；所以，我们调用`makeSuggestion()`函数，该函数在JavaScript文件中进一步声明。我们还使用`$('.suggest-list').show();`显示`.suggest-list`元素，以便用户能够看到它。如果输入的文本长度小于两个字符，我们只需确保`.suggest-list`被隐藏，使用`$('.suggest-list').hide();`。
- en: The latter action we perform on page load is to attach another event handler.
    This event handler will listen for clicks on any element with the `.suggestion`
    class. We use the `.on()` function provided by jQuery so that we can listen for
    click events on elements that have been dynamically added to the DOM, which is
    not possible using the `.click()` function. Please refer to the *Detecting button
    clicks* recipe in [Chapter 2](ch02.html "Chapter 2. Interacting with the User
    by Making Use of jQuery Events"), *Interacting with the User by Making Use of
    jQuery Events*, to learn more about these event handler functions. Within the
    callback function of this event handler, we get the HTML code of the clicked element
    using `$(this).html()`. Provide this to the `$('#text').val();` function, which
    will update the value of the text input. This will be used to allow the user to
    click on a suggestion and update the text input with its value.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在页面加载时执行的另一个动作是附加另一个事件处理程序。此事件处理程序将监听具有`.suggestion`类的任何元素上的点击。我们使用 jQuery
    提供的`.on()`函数，以便我们可以监听动态添加到 DOM 中的元素的点击事件，这是使用`.click()`函数不可能的。请参阅[第 2 章](ch02.html
    "Chapter 2. Interacting with the User by Making Use of jQuery Events")中的*通过使用
    jQuery 事件与用户进行交互*，以了解更多关于这些事件处理程序函数的信息。在此事件处理程序的回调函数中，我们使用`$(this).html()`获取点击元素的
    HTML 代码。将其提供给`$('#text').val();`函数，该函数将更新文本输入的值。这将用于允许用户点击建议并使用其值更新文本输入。
- en: Our `makeSuggestion()` function takes the text from the input element and sends
    an AJAX request to our `search.php` file to query the database and look for anything
    similar to what the user has inputted. This function then takes the results and
    populates the `.suggest-list` list for the user to select.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`makeSuggestion()`函数获取输入元素的文本，并向我们的`search.php`文件发送 AJAX 请求以查询数据库并查找与用户输入的任何内容相似的内容。然后，此函数获取结果并为用户选择填充`.suggest-list`列表。
- en: The first part of the function gets the current value of the text input and
    empties the `.suggest-list` unordered list element.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一部分获取文本输入的当前值并清空`.suggest-list`无序列表元素。
- en: '[PRE80]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Next, we use the `$.ajax()` function to set up the AJAX request. We specify
    the `search.php` file as the target, using the `url` parameter, the request type
    as `POST`, and provide the inputted text as data to be sent to the PHP file. Please
    refer to the *Creating a search feature* recipe for greater detail on this.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`$.ajax()`函数设置 AJAX 请求。我们使用`url`参数将`search.php`文件指定为目标，请求类型为`POST`，并将输入的文本作为数据提供给要发送到
    PHP 文件的数据。请参阅*创建搜索功能*配方以获取更多关于此的详细信息。
- en: '[PRE81]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We use the `beforeSend` parameter and provide a callback function that appends
    a list item with the `.suggest-list` element with the text **Loading…**. This
    callback function will be executed just before the AJAX request is made, allowing
    us to inform the user that the request is loading, as shown in the following screenshot:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`beforeSend`参数并提供一个回调函数，该函数将一个带有`.suggest-list`元素的列表项附加上文本**正在加载……**。此回调函数将在进行
    AJAX 请求之前执行，允许我们通知用户请求正在加载，如下面的屏幕截图所示：
- en: '![jQuery](img/08960S_03_07.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![jQuery](img/08960S_03_07.jpg)'
- en: The `success` callback function, which is executed when the request has been
    successful, is the function where we check to see if the database query has returned
    the desired results; if there are any suggestions to populate the list with.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`success`回调函数在请求成功时执行，这是我们检查数据库查询是否返回所需结果的函数；是否有任何建议可以填充列表。'
- en: '[PRE82]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `data` argument within the `success` callback function holds all the data
    sent from the PHP file. The object we created to send back to the client in the
    PHP has a `success` parameter, which we can use to check if everything went according
    to plan.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在`success`回调函数内的`data`参数保存了从 PHP 文件发送的所有数据。我们在 PHP 中创建的发送回客户端的对象具有`success`参数，我们可以使用它来检查一切是否按计划进行。
- en: '[PRE83]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: If something went wrong, we display the error message as an alert, which is
    provided by the PHP within the `error` parameter.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，我们将错误消息显示为警报，该消息由 PHP 中的`error`参数提供。
- en: If the query is executed successfully, we first empty the suggestion list once
    more to remove the loading item that was added in the `beforeSend()` callback
    function. We then check the length of the results using `data.results.length`
    to see if there are any suggestions with which we can populate our list element.
    If there are, we use the jQuery `$.each()` function to iterate through each item
    and append it to our `.suggest-list` element. We also wrap the suggestion in the
    `<a></a>` tags with the `.suggestion` class. Clicking on these suggestions will
    fire the event handler we created earlier and then update the text input with
    the suggested text.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询成功执行，则首先再次清空建议列表，以删除在`beforeSend()`回调函数中添加的加载项。然后，我们使用`data.results.length`检查结果的长度，以查看是否有任何建议可以填充我们的列表元素。如果有的话，我们使用jQuery的`$.each()`函数来遍历每个项并将其附加到我们的`.suggest-list`元素。我们还使用`.suggestion`类将建议包装在`<a></a>`标签中。单击这些建议将触发我们之前创建的事件处理程序，然后使用建议的文本更新文本输入。
- en: There's more…
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这还不止……
- en: Since the autosuggest feature is such a common implementation on modern websites
    and web applications, there are many jQuery plugins available to help you add
    this feature to your application. jQuery UI, which is jQuery's own user interface
    framework, has an autosuggest module readily available. You should investigate
    this further to see if your application can benefit from this ready-built solution.
    [Chapter 9](ch09.html "Chapter 9. jQuery UI"), *jQuery UI*, is dedicated to jQuery
    UI, as the name suggests, and you will also find an entire recipe on implementing
    the autocomplete feature.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自动建议功能在现代网站和Web应用程序中是如此常见的实现，因此有许多jQuery插件可帮助您将此功能添加到您的应用程序中。jQuery UI，即jQuery自己的用户界面框架，具有现成的自动建议模块。您应进一步调查此功能，以查看您的应用程序是否可以从此现成的解决方案中受益。[第9章](ch09.html
    "第9章。jQuery UI")，*jQuery UI*，专门介绍了jQuery UI，正如其名称所示，您还将找到一个关于实现自动完成功能的整个食谱。
- en: See also
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Creating a search feature*'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建搜索功能*'
- en: Waiting for an AJAX response
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待AJAX响应
- en: The default behavior of jQuery AJAX requests is that they run asynchronously,
    which means that you can run many AJAX requests or other JavaScript processes
    at the same time. If you call the `$.ajax()` function with the default settings,
    any JavaScript code after this AJAX request will be executed without waiting for
    a response. In most cases, this is the desired behavior, but there are some situations
    where you will want to prevent further execution until there has been a response
    to the AJAX call. This may be because you require some information from the first
    AJAX call to make a second, or just that your application requires data from the
    first call before it can run the second. There are a few ways to achieve this;
    refer to the *Caching JSON and AJAX requests* recipe of this chapter to see a
    very basic implementation where you simply turn off the asynchronous behavior.
    The preferred implementation though uses jQuery's `.when()` and `.done()` functions.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery AJAX请求的默认行为是异步运行，这意味着您可以同时运行许多AJAX请求或其他JavaScript进程。如果使用默认设置调用`$.ajax()`函数，则此AJAX请求之后的任何JavaScript代码都将在等待响应的情况下执行。在大多数情况下，这是期望的行为，但有一些情况下，您希望在等待AJAX调用的响应之前阻止进一步执行。这可能是因为您需要从第一个AJAX调用获取一些信息来进行第二个调用，或者只是您的应用程序在运行第二个调用之前需要第一个调用的数据。有几种方法可以实现这一点；请参考本章的*缓存JSON和AJAX请求*部分，看看一个非常基本的实现，其中您只需关闭异步行为。但首选的实现是使用jQuery的`.when()`和`.done()`函数。
- en: Getting ready
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that your web server is up and running and you have access to add files
    to the web root.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的Web服务器正在运行，并且您有权限向Web根目录添加文件。
- en: How to do it…
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Understand the correct way to wait for an AJAX response with jQuery by performing
    the following steps:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下步骤来了解使用jQuery等待AJAX响应的正确方法：
- en: 'Create an HTML file named `recipe-9.html` in the web root of your web server.
    Add the following code, which has a button that can trigger a series of AJAX requests
    and an element that can be updated with information about the responses:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Web服务器的Web根目录中创建一个名为`recipe-9.html`的HTML文件。添加以下代码，其中有一个按钮可以触发一系列AJAX请求，并且有一个可以使用响应信息更新的元素：
- en: '[PRE84]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: To be able to wait for a set of AJAX requests, we need to be able to make successful
    calls to the web server. Create a PHP file named `loading1.php` in the web root
    of your web server and add the following code to simulate a working PHP script.
    In your application, this could be any PHP script.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够等待一组AJAX请求，我们需要能够成功地调用Web服务器。在Web服务器的网站根目录中创建一个名为`loading1.php`的PHP文件，并添加以下代码来模拟一个有效的PHP脚本。在你的应用程序中，这可以是任何PHP脚本。
- en: '[PRE85]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Create another PHP file named `loading2.php` within the web root of your web
    server and add the following code:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web服务器的网站根目录中创建另一个名为`loading2.php`的PHP文件，并添加以下代码：
- en: '[PRE86]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You may have noticed that within the header of the HTML page, we included `script-9.js`.
    Create this file and save it in the web root of your web server, adding the following
    code:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经注意到在HTML页面的头部，我们包含了`script-9.js`。创建这个文件并将其保存在Web服务器的网站根目录中，添加以下代码：
- en: '[PRE87]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Opening `recipe-9.html` within a web browser and clicking on the **Load** button
    will give you the output from each of the AJAX calls. Finally, you will see the
    output from the `.done()` function, which is only executed once both the AJAX
    requests have been completed.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中打开`recipe-9.html`，点击**Load**按钮将给你每个AJAX调用的输出。最后，你将看到`.done()`函数的输出，它只有在两个AJAX请求都完成后才会执行。
- en: How it works…
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Now, let us understand the steps performed previously in detail.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地了解之前执行的步骤。
- en: HTML
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML
- en: Our very basic HTML page simply creates a button that will trigger the AJAX
    requests and provides an HTML element for us to update with data from the responses.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常基本的HTML页面只是创建一个按钮，来触发AJAX请求，并为我们提供一个HTML元素，用于从响应中更新数据。
- en: PHP
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: The two PHP scripts we created are just to simulate the end points for the AJAX
    calls. Both scripts are nearly identical, with two subtle differences. The `loading1.php`
    script loops twice, calls the PHP `sleep()` method, and provides `1` as an argument.
    This will pause the script for 1 second on each iteration of the `for` loop.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的两个PHP脚本只是模拟AJAX调用的终点。两个脚本几乎是相同的，只有两处细微的差异。`loading1.php`脚本循环两次，调用PHP的`sleep()`方法，并提供`1`作为参数。这将在`for`循环的每次迭代中暂停脚本1秒钟。
- en: '[PRE88]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: After the execution of the `for` loop, the script outputs the `Call 1 complete`
    message, which can then be displayed in the web browser using jQuery. The second
    script, `loading2.php`, is the same, except that its `for` loop iterates five
    times and we provide a different output to differentiate between the two scripts.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环执行后，脚本输出`Call 1 complete`消息，然后可以使用jQuery在Web浏览器中显示。第二个脚本`loading2.php`也是一样的，只是它的`for`循环迭代五次，我们提供了一个不同的输出来区分这两个脚本。
- en: The two scripts loop a different number of times to make sure that the former
    script will complete first, allowing us to demonstrate that we can wait for both
    scripts to complete within our jQuery code.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个脚本循环的次数不同，以确保前一个脚本会先完成，这样我们可以展示我们可以在我们的jQuery代码中等待两个脚本都完成。
- en: jQuery
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery
- en: In our JavaScript file, we attach a click event handler to the `.load` button
    that will be created on page load. Within the callback function for this event,
    we use the jQuery `$.when()` function and provide the results of the `call1()`
    and `call2()` functions as arguments. We then chain `.done()` at the end of the
    `$.when()` function, which will be executed once the `when()` function is complete.
    Within the `.done()` function, we provide a callback, which allows us to provide
    an argument for each of the functions we provided to `$.when()`. As the functions
    we provided to `$.when()` are AJAX requests, the arguments provided within the
    callback of the `.done()` function will all contain the response, status, and
    the `jqXHR` object from each of the AJAX requests.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JavaScript文件中，我们为`.load`按钮附加一个点击事件处理程序，在页面加载时将创建这个按钮。在这个事件的回调函数中，我们使用jQuery
    `$.when()`函数，并将`call1()`和`call2()`函数的结果作为参数提供。然后我们在`$.when()`函数的末尾链接`.done()`，这将在`when()`函数完成后执行。在`.done()`函数中，我们提供一个回调函数，它允许我们为`$.when()`提供的每个函数提供一个参数。由于我们在`$.when()`中提供的函数是AJAX请求，所以`.done()`函数的回调中提供的参数将包含每个AJAX请求的响应、状态和`jqXHR`对象。
- en: The `jqXHR` object is the return value of the jQuery `$.ajax()` function, which
    holds a lot of information regarding the AJAX request. The `.done()` function
    will not be executed until `call1()` and `call2()` have received a complete response
    from their respective AJAX requests and have finished executing.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`jqXHR`对象是 jQuery `$.ajax()` 函数的返回值，其中包含有关 AJAX 请求的大量信息。直到`call1()`和`call2()`从各自的
    AJAX 请求接收到完整响应并完成执行之前，`.done()`函数将不会被执行。'
- en: '[PRE89]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Within the callback for the `.done()` function, we append some text to the `.info`
    HTML element showing that both the AJAX calls within `$.when()` are complete.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.done()`函数的回调中，我们向`.info`HTML 元素附加一些文本，显示`$.when()`中的两个 AJAX 调用都已完成。
- en: The two call functions we created simply return `$.ajax()`, which both make
    a `GET` request to the PHP files we created. For each of these AJAX requests,
    we append the `.success()` function that will be executed once the respective
    AJAX call has been successful. Within the callback function for `.success()`,
    we append the response of the call to the `.info` HTML element using `$('.info').append();`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的两个调用函数简单地返回`$.ajax()`，它们都会向我们创建的 PHP 文件发出`GET`请求。对于这两个 AJAX 请求，我们都附加了`.success()`函数，一旦相应的
    AJAX 调用成功，该函数就会被执行。在`.success()`的回调函数中，我们使用`$('.info').append();`将调用的响应附加到`.info`HTML
    元素上。
- en: If you visit the root of your web server with a browser and select the load
    button, you will first see the response from the `loading1.php` script added to
    the `.info` div element. Shortly after, you will see the response from the `loading2.php`
    script and the text from the `.done()` callback added.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用浏览器访问您的 Web 服务器的根目录并选择加载按钮，您将首先看到从`loading1.php`脚本添加到`.info` div 元素的响应。不久后，您将看到从`loading2.php`脚本和`.done()`回调添加的文本的响应。
- en: See also
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: '*Caching JSON and AJAX requests*'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缓存 JSON 和 AJAX 请求*'
