- en: Typescript Native Types and Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have seen different kinds of examples of using TypeScript. Hopefully, you
    now know what TypeScript can offer you as a developer. There are still some TypeScript
    core concepts to learn before hopping right into using it to build Angular 2 apps.
    This chapter will cover the following TypeScript concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic types, such as strings, numbers, Boolean, arrays, void, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's revisit the basic types. Most of the types that we will be discussing
    are familiar to you from JavaScript, but it's nice to have a refresher session
    to better appreciate what TypeScript offers. Some of the types, on the other hand,
    are not available in JavaScript but are TypeScript-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strings are available in both JavaScript and TypeScript. They are used to represent
    textual data. This data appears in programs as string literals. These literals
    are easily identified in most programming languages because of the wrapping double
    quotes (`""`).  In JavaScript (and TypeScript), the literals are represented with
    both double quotes (`""`) and single quotes (`''''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the `text` variable stores this string: `"Hi, I am
    a string. Now you know!"`. Because TypeScript supports the latest features of
    JavaScript, you can use the new ES6 template literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Numbers are available in JavaScript and TypeScript.Numbers represent floating
    numbers in JavaScript. You feed them right in with the keyboard, without any decoration
    like we had to do for strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Boolean type is available in JavaScript and TypeScript**. **Booleans are
    the simplest types you will ever meet in a programming language. They answer the
    question with yes or no, which is represented in JavaScript as `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are available in both JavaScript and TypeScript**. **Data structures
    in JavaScript are basically represented with objects and arrays. Objects are key-value
    pairs while arrays have an indexable structure. There is no `array` type,  rather
    you provide types for the items that are contained in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have two options for doing this. You can use the `[]` symbol pair, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the built-in generic type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Void
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Void is available *only *in TypeScript**. **The `void` type is applicable to
    functions'' return types (we will discuss this soon). Void indicates that a function
    is not expected to return anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Any
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any is available *only *in TypeScript**.** The`any` type is the most flexible
    type. It allows you to get closer to the loose nature of JavaScript when there
    is a need for it. Such needs could arise from third-party libraries that are not
    typed and if you don't know which value type may be returned from a property or
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type can store all the known JavaScript types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tuple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tuples are available *only *in TypeScript**. **They allow you to have varying
    types in an array. Tuples come with the implication that the fixed number of elements
    in an array must be defined while creating the type. For example, if we need an
    array of `string`, `number`, and `boolean`, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When you try to access an index that was not initially created, the new index
    is added with the appropriate inferred type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enums are available *only *in TypeScript**.** On a few occasions, you may simply
    want to store a set of numbers, serially or not. Enums hand you a numeric data
    structure control without having to drag in the complexities of arrays or objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows an `enum` type with numbers from `0` to `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Enums are `0`-based; therefore, `Started` holds `0`, `InProgress` holds `1`,
    and `Completed` holds `2`. In addition, enums are flexible; hence, you can provide
    a number for the starting point instead of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can write more expressive code with Enums. Let''s see how, by using percentage
    values for the status in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s easy to find out the name of the value if you know the actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Functions and function types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript functions are loosely typed and are some of the most common sources
    of errors in the language. This is what a basic function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How sure are we that `char` is not a number? Well, we might not have any control
    over what the developer consuming `stringToArray` will pass in. This is why we
    need to be strict about the value types using TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions use types in two different parts of their declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: Function parameters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function return value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can tell TypeScript what type of values a function should expect, and it
    will strictly adhere to it. The following example shows a function that receives
    a typed string and a number as its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `char` and `index` parameters have the `string` and `number` types, respectively.
    Even before things get to the browser, TypeScript will alert you when you try
    something silly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, function expressions are not left out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, arrow functions are welcome too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Function return value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The value expected from a function when it is executed can also be strictly
    typed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code snippet, the return type comes after
    the brackets containing the parameters and before the opening curly bracket of
    the function's body. The preceding function is expected to, and must, return a
    string. Anything other than a string will scream at you with errors.
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a function's parameter is strictly typed, it feels rigid when the function
    needs to be flexible. Why should we pass in `index` to our previous example in
    a situation where we intend to return the whole string if the index is missing?
  prefs: []
  type: TYPE_NORMAL
- en: 'When the index parameter is omitted while calling the function, TypeScript
    will throw an error. To overcome this issue, we can declare the `index` parameter
    as optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The question mark succeeding the parameter name tells TypeScript that it's okay
    if the parameter is missing when called. Be careful to handle such cases of parameters
    not being supplied in the function body, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are contracts that our code adheres too. It's an agreement that data
    structures must follow. This helps every data/logic implementing an interface
    stay safe from improper or non-matching types. It also validates the types and
    availability of values passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript, interfaces are used for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating types for JavaScript objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up contracts for classes to adhere to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will discuss how interfaces are applied in the scenarios we just listed.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces for JavaScript object types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We agree that the following is a valid JavaScript object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It is a valid JavaScript code but loosely typed. All this while, we have been
    discussing strings, numbers, Boolean, and even arrays. We are yet to consider
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have imagined, the following code snippet demonstrates a typed version
    of the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is correct in fact, but TypeScript could use interfaces to make it more
    maintainable and easy to comprehend. The following is how we write interfaces
    in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What you can then do is make the `options` variable of the `OptionBag` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Optional properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing about interfaces, though, is that the defined properties/methods of
    an interface must be supplied when creating the values that are typed with that
    interface. Basically, I am saying that we must adhere strictly to the contract
    established with an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the following is incorrect and will throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make `container` optional; we use the question mark literal, as seen
    in a previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful, though, to account for when the optional parameter is not supplied.
    The following is an example that does so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Read-only properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another typical situation is when you have properties to which you intend to
    assign values only once, just like we do with the ES6 `const` declaration keyword.
    You can mark the values as `readonly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces as contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can ensure that a class adheres to a particular contract using interfaces.
    I use the term contract in the sense that all the properties and methods defined
    in the interface must be implemented in the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have the following `Note` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the interface using a class, we add the `implements` keyword after
    the class name followed by the interface we are implementing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Interfaces do not only define the signatures for properties but they also accept
    function types as methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This could be implemented by a class in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript will throw an error if neither the `wordCount` property nor the `updateCount` method
    exists in the `NoteTaker` class.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common feature introduced in Angular 2+ is **decorators**. Decorators,
    at first glance, are confusing because of the unusual `@` sign preceding their
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2d6b017-9e35-49d8-9d9e-85f6a967d310.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is a code snippet from an Angular application. It shows
    a component decorator decorating a class called `AppComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: At first, this might look overwhelming because, in the history of JavaScript,
    I have never seen the `@` literal used this way. If only we knew it was just a
    function that had access to the members of what it is decorating! Classes, properties,
    methods, and accessors are all allowed to be decorated. Let's discuss how to decorate
    methods and classes
  prefs: []
  type: TYPE_NORMAL
- en: Decorating methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to make a method on a class read-only. Therefore,
    after creating the method, it cannot be overridden for any reason. For example,
    this is what the method looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do not want to override `error` in the application''s lifecycle, we could
    write a decorator to set the descriptor''s `writable` property to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The common signature is that a method decorator takes the same parameters as
    `Object.defineProperty`. In such a case, the target will be the class, the key
    will be the method name, which is a property of the class, and the descriptor
    will be the `config` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now decorate the `error` method with the just created `readonly` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Any attempt to mutate the error property will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Decorating classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another commonly decorated member is the class. In fact, in Angular, almost
    all classes (components, services, modules, filters, and directives) are decorated.
    This is why it is important to understand the importance of the existence of decorators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorators can be used to extend the features of a class, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Decorator factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example is rigid because the `options` object will always have
    the same value. What if we needed to receive dynamic values? Of course, that's
    a valid question to ask because the `id` property may not always be `#main`. Therefore,
    we need to be more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorator factories are functions that return a decorator, giving you the power
    to pass in arguments for the decorator via its factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We spent time in the first three chapters discussing TypeScript fundamentals
    with the intention that while walking through the rest of the chapters (which
    are filled with a lot of Angular stuff), TypeScript will be something you don't
    have to worry about.
  prefs: []
  type: TYPE_NORMAL
- en: It is fine to assume that the basic types, function types, decorators, and interfaces
    have been added to your existing knowledge of TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapters of this book, we will soak ourselves in Angular. If you
    have come this far, then you made it through the boring parts of this book because,
    henceforth, we will be building a lot of fun examples with Angular 2+.
  prefs: []
  type: TYPE_NORMAL
