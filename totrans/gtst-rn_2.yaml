- en: Chapter 2. Understanding React Native Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：理解React Native基础知识
- en: You might not be familiar with how React for Web works, so we are going to cover
    the fundamentals in this chapter. We will also explain the core principles of
    how React for Web works under the hood. Once you have a solid understanding of
    the basics, we will dive into how React for Web works and the subtle differences
    between mobile and web. By the end of this chapter, you will have the necessary
    skills to start building the example application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对React Web的工作原理不太熟悉，所以我们将在本章中介绍其基础知识。我们还将解释React Web在底层是如何工作的核心原则。一旦你对基础知识有了扎实的理解，我们将深入探讨React
    Web的工作原理以及移动端和Web端之间的细微差别。到本章结束时，你将具备开始构建示例应用程序所需的技能。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Virtual DOM
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟DOM
- en: Introducing components and JSX
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍组件和JSX
- en: Writing our first component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们的第一个组件
- en: Props and state of components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的属性和状态
- en: The Virtual DOM
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟DOM
- en: 'Do you know how to write a JavaScript function? If you do, that''s great! You''re
    well on your way to understand how React and React Native work under the hood.
    What do we mean exactly? Well, when you research how React works, you''ll eventually
    encounter someone explaining it in the following manner:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道如何编写JavaScript函数吗？如果你知道，那太好了！你正走在理解React和React Native底层工作原理的道路上。我们具体指的是什么？当你研究React的工作原理时，你最终会遇到有人用以下方式解释它：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You may say, *Nerd alert! How is this helpful?* Well, it''s saying that your
    UI is a function of your data. To put it in more familiar terms, let''s say that:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说，*警告：这有什么用？* 好吧，这是说你的UI是你的数据的函数。用更熟悉的话来说，让我们说：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can call the `function` with an array of data, such as:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用数据数组调用该函数，例如：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is not a particularly earth-shattering code; however, you're now rendering
    some content, in this case to the console.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是特别震撼人心的代码；然而，你现在正在渲染一些内容，在这种情况下是到控制台。
- en: 'What if, all your UI rendering code could be this predictable? It can be! Let''s
    start getting a little more advanced. What if, in addition to our `todos()` function,
    we had a function called `todoItem()`, such as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有的UI渲染代码都能如此可预测呢？它可以！让我们开始变得稍微高级一些。除了我们的`todos()`函数外，如果我们还有一个名为`todoItem()`的函数，例如：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That looks a lot like our original `UI` function, doesn''t it?:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很像我们的原始`UI`函数，不是吗？：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What if we start composing our `todos()` and `todoItems()`, such as:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们开始组合我们的`todos()`和`todoItems()`，例如：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can start to get the picture that we can start to render more and more complex
    outputs by composing simple functions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以开始想象，我们可以通过组合简单的函数来渲染越来越复杂的输出。
- en: What if we want to start rendering our content to the browser? I'm sure you
    can imagine changing our `todoItem()` to add elements to the DOM using jQuery;
    however, in this case we will start repeating ourselves a lot with many instances
    of `appendChild()` calls and jQuery selectors. If we are really smart, we might
    write a framework to abstract away the DOM manipulations so that we can write
    the code that matters to our application, not just the code that matters to the
    browser.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想开始将内容渲染到浏览器中呢？我敢肯定你能想象将我们的`todoItem()`改为使用jQuery添加元素到DOM；然而，在这种情况下，我们将开始重复很多次，有很多`appendChild()`调用和jQuery选择器的实例。如果我们真的很聪明，我们可能会编写一个框架来抽象DOM操作，这样我们就可以编写对我们应用程序重要的代码，而不仅仅是针对浏览器的代码。
- en: OK, so now let's say that we've magically got a framework that lets us represent
    our UI as a `data` function and we don't have to think about how our content will
    get rendered to the DOM. We can start changing our data over and over and watch
    the DOM update! That sounds great in theory, but when we have dozens of `div`
    elements in a deeply nested hierarchy, the underlying DOM manipulations become
    complex and inefficient.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在假设我们神奇地获得了一个框架，它允许我们将UI表示为一个`data`函数，我们不必考虑内容是如何渲染到DOM中的。我们可以不断地更改我们的数据，并观察DOM的更新！从理论上讲，这听起来很棒，但当我们有数十个深度嵌套的`div`元素时，底层的DOM操作变得复杂且效率低下。
- en: What if our magic framework had an intermediate representation of the DOM? Let's
    call it Virtual DOM and let's say that instead of making every little change to
    the DOM, we batch the changes together. We can even compare the before and after
    states of the Virtual DOM. Figure out the differences and reduce the number of
    real DOM manipulations that we need to perform. Now we're really on to something!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的魔法框架有一个DOM的中间表示形式怎么办？让我们称它为虚拟DOM，并且让我们说，我们不是对DOM进行每一个小更改，而是将更改批量处理在一起。我们甚至可以比较虚拟DOM的当前和之前状态。找出差异，减少我们需要执行的真正DOM操作次数。现在我们真的开始有所作为了！
- en: So we can now express our UI as a function of our data. We don't have to think
    about the underlying DOM manipulation code and our UI is nice and snappy because
    the underlying framework is really smart and reduces the number of DOM manipulations
    it needs to perform. It will be pretty great to have a framework that could do
    that for us, but you know what will be really cool? What if the DOM didn't have
    to be a browser DOM? What if that same abstraction that allows us to write the
    code that matters to our app could be used to, say, update native mobile components?
    Enter React Native.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以将我们的UI表达为数据的一个函数。我们不必考虑底层的DOM操作代码，而且我们的UI既美观又迅速，因为底层框架非常智能，减少了它需要执行的DOM操作次数。有一个能够为我们做这件事的框架将会非常棒，但你知道吗，什么会真正酷？如果DOM不需要是浏览器DOM怎么办？如果那个允许我们编写对应用有意义的代码的相同抽象能够用来，比如说，更新原生移动组件怎么办？这就是React
    Native。
- en: Components
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: Now here is an interesting problem; we have come across this great framework
    for making fast differences between the Virtual DOM and its native components.
    How do we tell React Native what UI to represent or when to change it? A React
    Native component is a simple, reusable, function-like object that enables us to
    describe the native mobile components we want to render. They will always contain
    properties, state, and a render method. Let's start really simple by creating
    our own component.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个有趣的问题；我们遇到了这个伟大的框架，用于快速在虚拟DOM和其原生组件之间进行差异比较。我们如何告诉React Native要表示什么UI或何时更改它？一个React
    Native组件是一个简单、可重用的、类似函数的对象，使我们能够描述我们想要渲染的原生移动组件。它们将始终包含属性、状态和一个渲染方法。让我们从创建我们自己的组件开始，从非常简单的地方开始。
- en: Creating your first component
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您的第一个组件
- en: 'Creating a new component in React Native will look similar to the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native中创建一个新的组件将类似于以下内容：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember to import the React Native module. Here, we are using the ES6 import
    statement; it is similar to how the node require module works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 记得导入React Native模块。在这里，我们使用ES6导入语句；它类似于node require模块的工作方式。
- en: '*Wait a second…* What are these weird XML elements doing in my JavaScript code?
    Facebook has created its own syntactic extension over JavaScript to describe React
    components. Here is the exact same code, but written in ordinary JavaScript:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*等等…* 这些奇怪的XML元素在我的JavaScript代码中做什么？Facebook为描述React组件在JavaScript上创建了自己的语法扩展。以下是完全相同的代码，但用普通的JavaScript编写：'
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While it is possible to write React Native applications only in JavaScript,
    the previous syntax includes many added benefits for the developer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然只使用JavaScript编写React Native应用程序是可能的，但之前的语法为开发者提供了许多额外的优势。
- en: JSX
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX
- en: '**JavaScript XML** (**JSX**) is an XML-like extension to the ECMAScript specification.
    It combines the component logic (JavaScript) and markup (DOM or Native UI) into
    a single file.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript XML（JSX**）是ECMAScript规范的一个类似XML的扩展。它将组件逻辑（JavaScript）和标记（DOM或原生UI）合并到一个文件中。'
- en: 'A JSX Element will take the following form:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JSX元素将具有以下形式：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The JSX specification also defines the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JSX规范还定义了以下内容：
- en: The JSX Elements can be either self-opening `<JSXElement></JSXElement>` or self-closing
    `<JSXElement />`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX元素可以是自闭合的`<JSXElement></JSXElement>`或自闭合的`<JSXElement />`。
- en: Accept attributes as an expression `{}` or string `""` `<Component attr="attribute">`.
    Expressions are JavaScript snippets.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以表达式`{}`或字符串`""`的形式接受属性`<Component attr="attribute">`。表达式是JavaScript片段。
- en: The children elements can be text, expressions, or elements.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子元素可以是文本、表达式或元素。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**What if you have more than one component or a list of components?**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你有多个组件或组件列表怎么办？**'
- en: There can only be a single root element; it means that if you have multiple
    components, you must wrap them in a parent component.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 只能有一个根元素；这意味着如果你有多个组件，你必须将它们包裹在一个父组件中。
- en: This is cool! We have gone from a deeply nested and imperative JavaScript code
    to a declarative format that describes the exact elements that we want to see
    in our components. There is no separation of concerns since our logic is coupled
    with our markup, making the components easier to debug and test. Since you can
    always include the same component in multiple other components, there is no need
    to duplicate the code anyway.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷！我们已经从深层嵌套和命令式的JavaScript代码转变为描述我们希望在组件中看到的精确元素的声明性格式。由于我们的逻辑与我们的标记耦合，因此没有关注点的分离，这使得组件更容易调试和测试。由于你总是可以将相同的组件包含在多个其他组件中，因此根本不需要重复代码。
- en: Note that JSX is only meant to be used as a preprocessor and it is not recommended
    to transpile in your production build. More information on JSX can be found in
    the official React documentation [https://facebook.github.io/react/docs/jsx-in-depth.html](https://facebook.github.io/react/docs/jsx-in-depth.html)
    or in the official JSX Specification [https://facebook.github.io/jsx/](https://facebook.github.io/jsx/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，JSX仅应作为预处理器使用，不建议在生产构建中进行转译。有关JSX的更多信息，请参阅官方React文档[https://facebook.github.io/react/docs/jsx-in-depth.html](https://facebook.github.io/react/docs/jsx-in-depth.html)或官方JSX规范[https://facebook.github.io/jsx/](https://facebook.github.io/jsx/)。
- en: Back to our first component
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到我们的第一个组件
- en: There are a few things that we have overlooked in our component. **View** and
    **Text** are two of the many components provided by React Native to build a UI.
    These are not regular components that render in the JavaScript layer, they can
    map directly to their native container parts! The View component maps to `UIView`
    in IOS and `android.view` in Android, while Text is the generic component to display
    text on each platform respectively. **View** and **Text** support various functions,
    such as layouts, styling, and touch handling.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的组件中，我们忽略了一些事情。**View**和**Text**是React Native提供的许多组件中的一部分，用于构建UI。这些不是在JavaScript层渲染的常规组件，它们可以直接映射到其原生容器部分！View组件映射到iOS中的`UIView`和Android中的`android.view`，而Text是分别在每个平台上显示文本的通用组件。**View**和**Text**支持各种功能，如布局、样式和触摸处理。
- en: Displaying the same static text over and over is not very exciting. Let's extend
    this simple component and add some more functionalities.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 反复显示相同的静态文本并不令人兴奋。让我们扩展这个简单的组件并添加一些更多功能。
- en: Props and states
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性和状态
- en: At this point, you may be wondering how React Native deals with component manipulation
    and communication as the number of components grows into a component hierarchy.
    A component hierarchy, similar to a tree, starts with a root component and can
    contain many children. React Native provides two methods of data passing; one
    for data-flow down the component hierarchy and another for maintaining internal
    state.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能想知道随着组件数量的增长形成组件层次结构时，React Native是如何处理组件操作和通信的。组件层次结构类似于树，从根组件开始，可以包含许多子组件。React
    Native提供了两种数据传递方法；一种用于组件层次结构中的数据流向下传递，另一种用于维护内部状态。
- en: Props
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'How do the components in the same component hierarchy communicate with each
    other? Data is passed down through properties commonly known as **props**. Props
    are considered to be immutable by convention and should never be modified directly.
    To pass a prop into a component, just add a camel-cased attribute to the component:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同一组件层次结构中的组件之间是如何进行通信的呢？数据通过通常称为**属性**的属性向下传递。按照惯例，属性被认为是不可变的，不应直接修改。要将属性传递给组件，只需在组件中添加一个驼峰式命名的属性即可：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Props can be accessed internally in the component through `this.props`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`this.props`在组件内部访问属性：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**What if I want to pass down a lot of props?**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果我想要传递很多属性怎么办？**'
- en: It is possible to pass an array of props to a component using the ES7 spread
    operator `<HelloComponent {...props} />`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ES7扩展运算符`<HelloComponent {...props} />`可以将属性数组传递给组件。
- en: It is not always necessary to include props with a component, but if you require
    a default value for your props, you can assign the `defaultProps` object to the
    component's class constructor.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是需要将属性包含在组件中，但如果你需要为属性指定默认值，可以将`defaultProps`对象分配给组件类的构造函数。
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Validating props
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验证属性
- en: 'If you are planning to expose your component to the public, it makes sense
    to constrain the ways developers can use it. To enforce that your components are
    being used correctly, the **PropTypes** module can be used to validate any props
    passed in. In the event that a prop does not pass the `propType` validation, a
    warning is shown to the developer in the console. The `PropTypes` cover a wide
    range of JavaScript types and primitives, including nested objects. You can define
    `propTypes` on a component''s class constructor:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算将你的组件公开给公众，限制开发者使用它的方式是有意义的。为了确保你的组件被正确使用，可以使用 **PropTypes** 模块来验证传入的任何
    props。如果某个 prop 未通过 `propType` 验证，则会在控制台中向开发者显示警告。`PropTypes` 覆盖了广泛的 JavaScript
    类型和中型，包括嵌套对象。你可以在组件的类构造函数上定义 `propTypes`：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For more information on `propTypes`, visit the Prop Validation section of React
    Docs [https://facebook.github.io/react/docs/reusable-components.html](https://facebook.github.io/react/docs/reusable-components.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `propTypes` 的信息，请访问 React 文档的 Prop 验证部分 [https://facebook.github.io/react/docs/reusable-components.html](https://facebook.github.io/react/docs/reusable-components.html)。
- en: State
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态
- en: 'So now we can pass in the data, but what if the data changes, then how can
    we display these changes to the user? Components can optionally contain state,
    a mutable and private set of data. State is a great way to keep track of user
    input, asynchronous requests, and events. Let''s update our component with additional
    text when the user interacts with it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们可以传递数据，但如果数据发生变化，我们如何向用户显示这些变化呢？组件可以包含可选的状态，这是一个可变且私有的数据集。状态是跟踪用户输入、异步请求和事件的绝佳方式。当用户与组件交互时，让我们更新我们的组件以添加额外的文本：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Touching the `Text` component will trigger the function in its `onPress` prop.
    We are taking advantage of the ES6 arrow syntax to include our functionality in
    line with the text component.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸 `Text` 组件将触发其 `onPress` prop 中的函数。我们正在利用 ES6 箭头语法将我们的功能与文本组件一起放在一行中。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the ES6 arrow syntax will automatically bind this to a function. For any
    non-arrow function, if you need access to this then you need to bind the value
    to the function in the props expression `<Text onPress={this.myFunction.bind(this)}>`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ES6 箭头语法将自动将 `this` 绑定到函数上。对于任何非箭头函数，如果你需要访问 `this`，那么你需要在 `<Text onPress={this.myFunction.bind(this)}>`
    的 props 表达式中将值绑定到函数上。
- en: The `setState` function will merge the object you pass into the first argument
    with the current state of the component. Calling `setState` will trigger a new
    render where, instead of being empty, `this.state.appendText` will append **Native!**
    to the value of text, which we originally passed in from props. The final result
    is `"Hello React" + " Native!"` to produce `"Hello React Native!"`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`setState` 函数将你传递给第一个参数的对象与组件的当前状态合并。调用 `setState` 将触发一个新的渲染，其中 `this.state.appendText`
    将在原始从 props 传递的文本值上追加 **Native!**，最终结果是 `"Hello React" + " Native!"`，生成 `"Hello
    React Native!"`。'
- en: Never try and modify the value of this state on your own. Directly changing
    the state could result in data loss during the next `setState` call and it will
    not trigger another re-render.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要尝试直接修改这个状态值。直接更改状态可能导致下一次 `setState` 调用期间数据丢失，并且不会触发另一个重新渲染。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now hopefully, you understand the radical new direction React has taken in achieving
    performance. The Virtual DOM handles all of the DOM manipulations for us behind
    the scenes. At the same time, it uses efficient diffing algorithms to minimize
    the number of calls to the DOM. We have also seen how JSX allows us to express
    our components declaratively and combine our application logic into a single file.
    By using props and state, we can pass the data through components and update them
    dynamically.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，希望你能理解 React 在实现性能方面所采取的激进新方向。虚拟 DOM 在幕后处理所有的 DOM 操作。同时，它使用高效的差异算法来最小化对 DOM
    的调用次数。我们也看到了 JSX 如何允许我们声明式地表达我们的组件，并将应用程序逻辑合并到一个文件中。通过使用 props 和 state，我们可以通过组件传递数据并动态更新它们。
- en: I hope you can now take the information you learned in this chapter and convince
    your boss to start using React Native right away!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在能够利用本章学到的信息，说服你的老板立即开始使用 React Native！
