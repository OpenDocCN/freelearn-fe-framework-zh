- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Understanding React Components and Hooks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解React组件和Hooks
- en: In this chapter, we will delve into the React components and their fundamental
    aspects and introduce you to the power of **Hooks**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨React组件及其基本方面，并介绍**Hooks**的强大功能。
- en: 'We will explore the essential concept of component data and how it shapes the
    structure of your React applications. We will discuss two primary types of component
    data: **properties** and **state**. Properties allow us to pass data to components,
    while state enables components to manage and update their internal data dynamically.
    We will examine how these concepts apply to function components and illustrate
    the mechanics of setting component state and passing properties.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨组件数据的基本概念以及它是如何塑造你的React应用结构的。我们将讨论两种主要的组件数据类型：**属性**和**状态**。属性允许我们向组件传递数据，而状态使组件能够动态地管理和更新其内部数据。我们将探讨这些概念如何应用于函数组件，并说明设置组件状态和传递属性的工作原理。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to React components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React组件简介
- en: What are component properties?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件属性是什么？
- en: What is component state?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件状态是什么？
- en: React Hooks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks
- en: Maintaining state using Hooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks维护状态
- en: Performing initialization and cleanup actions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行初始化和清理操作
- en: Sharing data using context Hooks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用context Hooks共享数据
- en: Memoization with Hooks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks进行记忆化
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter03](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter03)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下链接找到：[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter03](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter03)
- en: Introduction to React components
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React组件简介
- en: React components are the building blocks of modern web and mobile applications.
    They encapsulate reusable sections of code that define the structure, behavior,
    and appearance of different parts of a user interface. By breaking down the UI
    into smaller, self-contained components, React enables developers to create scalable,
    maintainable, and interactive applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: React组件是现代Web和移动应用的基础构建块。它们封装了可重用的代码部分，用于定义用户界面不同部分的架构、行为和外观。通过将UI分解成更小、更独立的组件，React使开发者能够创建可扩展、可维护和交互式的应用。
- en: At its core, a React component is a JavaScript function or class that returns
    JSX syntax, which resembles HTML markup. In this book, we will focus mostly on
    function components, as they have become the preferred approach for building components
    in recent years. Function components are simpler, more concise, and easier to
    understand compared to class components. They leverage the power of JavaScript
    functions and utilize React Hooks to manage state and perform side effects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，React组件是一个返回类似HTML标记的JSX语法的JavaScript函数或类。在本书中，我们将主要关注函数组件，因为它们在近年来已成为构建组件的首选方法。与类组件相比，函数组件更简单、更简洁、更容易理解。它们利用JavaScript函数的力量，并利用React
    Hooks来管理状态和执行副作用。
- en: One of the primary advantages of using components in React is their reusability.
    Components can be reused across multiple parts of an application, reducing code
    duplication and increasing development efficiency. Moreover, components promote
    a modular approach to development, allowing developers to break down complex UIs
    into smaller, manageable pieces.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中使用组件的主要优势之一是它们的可重用性。组件可以在应用的多个部分中重用，减少代码重复并提高开发效率。此外，组件促进了模块化开发方法，使开发者能够将复杂的UI分解成更小、更易于管理的部分。
- en: What are component properties?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件属性是什么？
- en: In React, **component properties**, commonly known as **props**, allow us to
    pass data from a parent component to its child components. Props provide a way
    to customize and configure components, making them flexible and reusable. Props
    are read-only, meaning that the child component should not modify them directly.
    Instead, the parent component can update the props value and trigger a re-render
    of the child component with the updated data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，**组件属性**，通常称为**props**，允许我们将数据从父组件传递到其子组件。Props提供了一种定制和配置组件的方式，使它们灵活且可重用。Props是只读的，这意味着子组件不应直接修改它们。相反，父组件可以更新props值并触发子组件的重新渲染，以使用更新的数据。
- en: 'When defining a function component, you can access the props passed to it as
    a parameter:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义一个函数组件时，你可以将其作为参数访问传递给它的props：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the above example, the `MyComponent` function component receives the props
    object as a parameter. We can access the individual props by using dot notation,
    such as `props.title` and `props.description`, to render the data within the component’s
    JSX markup. It is also possible to access props using destructuring:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`MyComponent`函数组件将props对象作为参数接收。我们可以通过点符号访问单个属性，例如`props.title`和`props.description`，以在组件的JSX标记中渲染数据。也可以通过解构来访问属性：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, this approach is even cleaner and also allows us to use another
    destructuring feature, default values, which we will discuss in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种方法甚至更简洁，还允许我们使用另一个解构特性，默认值，我们将在本章中讨论。
- en: Passing property values
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递属性值
- en: 'React component properties are set by passing JSX attributes to the component
    when it is rendered. In *Chapter 7*, *Type Checking and Validation with TypeScript*,
    I’ll go into more detail about how to validate the property values that are passed
    to components. Now let’s create a couple of components in addition to `MyComponent`
    that expect different types of property values:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: React组件属性是通过在渲染组件时传递JSX属性来设置的。在第7章*Type Checking and Validation with TypeScript*中，我将更详细地介绍如何验证传递给组件的属性值。现在，让我们创建一些额外的组件，除了`MyComponent`之外，它们期望不同类型的属性值：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This simple button component expects a Boolean disabled property and a string
    text property. While we create components to show how we can pass the following
    props, you will notice how we already pass these properties to the button HTML
    element:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的按钮组件期望一个布尔值禁用属性和一个字符串文本属性。当我们创建组件来展示如何传递以下属性时，你会注意到我们已经在按钮HTML元素中传递了这些属性：
- en: '**disabled property**: we put into the button attribute with the name `disabled`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用属性**：我们将其放入按钮属性中，属性名为`disabled`'
- en: '**text property**: we pass to the button as a child attribute'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本属性**：我们将其作为子属性传递给按钮'
- en: It’s also important to know that any JavaScript expression you want to pass
    to the component should be wrapped with curly braces.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 还重要的是要知道，你想要传递给组件的任何JavaScript表达式都应该用大括号括起来。
- en: 'Let’s create one more component that expects an array property value:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一个期望数组属性值的组件：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can pass just about anything you want as a property value via JSX, just
    as long as it’s a valid JavaScript expression. The `MyList` component accepts
    an items property, an array that is mapped to `<li>` elements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过JSX传递几乎任何你想要的属性值，只要它是一个有效的JavaScript表达式。`MyList`组件接受一个items属性，一个映射到`<li>`元素的数组。
- en: 'Now, let’s write some code to set these property values:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些代码来设置这些属性值：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `render` function looks like it’s creating new React component instances
    every time it’s called. React is smart enough to figure out that these components
    already exist, and that it only needs to figure out what the difference in output
    will be with the new property values. In this example, the call to `setTimeout`
    causes a delay of 1 second. Then, the `appState.disabled` value is changed to
    false and the `appState.items` array has a new value added to the end of it. The
    call to `render` will re-render the components with new property values.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`函数看起来每次被调用时都会创建新的React组件实例。React足够智能，能够判断这些组件已经存在，并且它只需要确定新属性值将导致输出差异。在这个例子中，`setTimeout`的调用导致1秒的延迟。然后，`appState.disabled`的值被更改为false，`appState.items`数组末尾添加了一个新值。对`render`的调用将使用新的属性值重新渲染组件。'
- en: Another takeaway from this example is that you have an `appState` object that
    holds onto the state of the application. Pieces of this state are then passed
    into components as properties when the components are rendered. The state has
    to live somewhere and, in this case, it’s outside of the component. We’ll explore
    this approach in depth, and why it’s important, in *Chapter 12*, *State Management
    in React*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们还可以得到一个启示，即你有一个`appState`对象，它保留着应用程序的状态。当组件渲染时，这个状态的一部分会被作为属性传递给组件。状态必须存在于某个地方，在这个例子中，它位于组件之外。我们将在*第12章*，*React中的状态管理*中深入探讨这种方法，以及为什么它很重要。
- en: 'I hope you noticed we’ve rendered another button where we passed props in a
    different way:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经注意到我们渲染了另一个按钮，我们以不同的方式传递了props：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a valid JSX expression and in case we want to pass constant values to
    the components, we can pass strings without curly braces and pass the Boolean
    value `true`, just leaving the attribute name in the component.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的 JSX 表达式，如果我们想向组件传递常量值，我们可以传递不带花括号的字符串，并传递布尔值 `true`，只需在组件中留下属性名即可。
- en: Default property values
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认属性值
- en: 'In addition to passing data, we can also specify default values for props using
    the `defaultProps` property. This is helpful when a prop is not provided, ensuring
    that the component still behaves correctly:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传递数据之外，我们还可以使用 `defaultProps` 属性指定属性的默认值。当属性未提供时，这很有用，确保组件仍然表现正确：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, if the parent component does not provide the `text` or `disabled`
    props, the component will fall back to the default values specified in `defaultProps`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，如果父组件没有提供 `text` 或 `disabled` 属性，组件将回退到在 `defaultProps` 中指定的默认值。
- en: As I mentioned before, with destructuring, we have a more convenient way to
    set up default props.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，使用解构，我们有更方便的方式来设置默认属性。
- en: 'Let’s take a look at the updated example of the `MyButton` component:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `MyButton` 组件的更新示例：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using destructuring, we can define props and set the default value right inside
    the function. It’s cleaner and easy to see in cases when we have a big component
    with a lot of props.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解构，我们可以在函数内部定义属性并设置默认值。当组件有很多属性时，这更简洁且易于查看。
- en: In the upcoming sections, we will further dive into component state with Hooks,
    and other key concepts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将进一步探讨使用 Hooks 和其他关键概念的组件状态。
- en: What is component state?
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是组件状态？
- en: In React, component state refers to the internal data held by a component. It
    represents the mutable values that can be used within the component and can be
    updated over time. State allows components to keep track of information that can
    change, such as user input, API responses, or any other data that needs to be
    dynamic and responsive.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，组件状态指的是组件持有的内部数据。它代表可以在组件内部使用并可随时间更新的可变值。状态允许组件跟踪可能发生变化的信息，例如用户输入、API
    响应或任何需要动态和响应式的其他数据。
- en: State is a feature provided by React that enables components to manage and update
    their own data. It allows components to re-render when the state changes, ensuring
    that the user interface reflects the latest data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是 React 提供的一个特性，它使组件能够管理和更新它们自己的数据。它允许组件在状态变化时重新渲染，确保用户界面反映了最新的数据。
- en: To define state in a React component, you should use the `useState` hook inside
    of the component. You can then access and modify the state within the component’s
    methods or JSX code. When the state is updated, React will automatically re-render
    the component and its child components to reflect the changes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 React 组件中定义状态，你应该在组件内部使用 `useState` hook。然后你可以在组件的方法或 JSX 代码中访问和修改状态。当状态更新时，React
    会自动重新渲染组件及其子组件以反映这些更改。
- en: Before jumping to examples of using state in components, let’s briefly explore
    what a React hook is.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳转到组件中使用状态的示例之前，让我们简要地探索一下 React hook 是什么。
- en: React Hooks
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Hooks
- en: React Hooks are a feature introduced in **React 16.8** that allows you to use
    state and other React features in functional components. Before Hooks, state management
    and lifecycle methods were primarily used in class components. Hooks provide a
    way to achieve similar functionality in functional components, making them more
    powerful and easier to write and understand.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks 是在 **React 16.8** 中引入的一个特性，它允许你在函数组件中使用状态和其他 React 特性。在 Hooks 之前，状态管理和生命周期方法主要在类组件中使用。Hooks
    提供了一种在函数组件中实现类似功能的方法，使它们更强大、更容易编写和理解。
- en: Hooks are functions that enable you to “hook into” React’s internal features,
    such as state management, context, effects, and more. They are prefixed with the
    `use` keyword (such as `useState`, `useEffect`, `useContext`, and so on). React
    provides several built-in Hooks, and you can also create custom Hooks to encapsulate
    reusable stateful logic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks 是一些函数，它们使你能够“挂钩”到 React 的内部特性，例如状态管理、上下文、效果等。它们以 `use` 关键字为前缀（例如 `useState`、`useEffect`、`useContext`
    等）。React 提供了几个内置的 Hooks，你也可以创建自定义 Hooks 来封装可重用的状态逻辑。
- en: 'The most commonly used built-in Hooks are:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的内置 Hooks 包括：
- en: '`useState`: This hook allows you to add state to a functional component. It
    returns an array with two elements: the current state value and a function to
    update the state.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState`：这个钩子允许你在函数式组件中添加状态。它返回一个包含两个元素的数组：当前状态值和一个用于更新状态的函数。'
- en: '`useEffect`: This hook lets you perform side effects in your components, such
    as fetching data, subscribing to events, or manually manipulating the DOM. It
    runs after every render by default and can be used to handle component lifecycle
    events like when the component is mounted, updated, or unmounted.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect`：这个钩子允许你在组件中执行副作用，例如获取数据、订阅事件或手动操作 DOM。它默认在每次渲染后运行，可以用来处理组件的生命周期事件，比如组件挂载、更新或卸载。'
- en: '`useContext`: This hook allows you to consume values from a React context.
    It provides a way to access context values without nesting multiple components.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useContext`：这个钩子允许你从 React 上下文中消费值。它提供了一种方法来访问上下文值，而无需嵌套多个组件。'
- en: '`useCallback` and `useMemo`: These Hooks are used for performance optimization.
    `useCallback` memoizes a function, preventing it from being recreated on every
    render, while `useMemo` memoizes a value, recomputing it only when its dependencies
    change.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useCallback` 和 `useMemo`：这些钩子用于性能优化。`useCallback` 缓存了一个函数，防止它在每次渲染时被重新创建，而
    `useMemo` 缓存了一个值，只有当它的依赖项改变时才会重新计算。'
- en: We will examine all these Hooks in this chapter and will use them throughout
    the book. Let’s continue with state and explore how we can manage it with the
    `useState` Hook.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中检查所有这些钩子，并在整本书中使用它们。让我们继续讨论状态，并探索如何使用 `useState` 钩子来管理它。
- en: Maintaining state using Hooks
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Hooks 维护状态
- en: The first React Hook API that we’ll look at is called `useState`, which enables
    your functional React components to be stateful. In this section, you’ll learn
    how to initialize state values and change the state of a component using Hooks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个 React 钩子 API 被称为 `useState`，它使你的函数式 React 组件能够拥有状态。在本节中，你将学习如何使用
    Hooks 初始化状态值并改变组件的状态。
- en: Initial state values
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始状态值
- en: When our components are first rendered, they probably expect some state values
    to be set. This is called the initial state of the component, and we can use the
    `useState` hook to set the initial state.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的组件首次渲染时，它们可能期望设置一些状态值。这被称为组件的初始状态，我们可以使用 `useState` 钩子来设置初始状态。
- en: 'Let’s take a look at an example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `App` component is a functional React component that returns JSX markup.
    But it’s also now a stateful component, thanks to the `useState` hook. This example
    initializes two pieces of state, `name` and `age`. This is why there are two calls
    to `useState`, one for each state value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 组件是一个功能性的 React 组件，它返回 JSX 标记。但现在它也是一个有状态的组件，多亏了 `useState` 钩子。这个例子初始化了两个状态值，`name`
    和 `age`。这就是为什么有两个 `useState` 调用，每个状态值一个。'
- en: You can have as many pieces of state in your component as you need. The best
    practice is to have one call to `useState` per state value. You could always define
    an object as the state of your component using only one call to `useState`, but
    this complicates things because you have to access state values through an object
    instead of directly. Updating state values is also more complicated using this
    approach. When in doubt, use one `useState` hook per state value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在组件中拥有你需要的任意数量的状态。最佳实践是每个状态值使用一个 `useState` 调用。你当然可以使用一个 `useState` 调用来定义一个对象作为组件的状态，但这会使事情变得复杂，因为你必须通过对象来访问状态值，而不是直接访问。使用这种方法更新状态值也会更复杂。如果有疑问，请为每个状态值使用一个
    `useState` 钩子。
- en: 'When we call `useState`, we get an array returned to us. The first value of
    this array is the state value itself. Since we’ve used array-destructuring syntax
    here, we can call the value whatever we want; in this case, it is `name` and `age`.
    Both of these constants have values when the component is first rendered because
    we passed the initial state values for each of them to `useState`. Here’s what
    the page looks like when it’s rendered:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `useState` 时，我们得到一个返回给我们的数组。这个数组的第一个值是状态值本身。由于我们在这里使用了数组解构语法，我们可以将值命名为我们想要的任何名称；在这种情况下，它是
    `name` 和 `age`。这两个常量在组件首次渲染时都有值，因为我们已经将每个的初始状态值传递给了 `useState`。以下是渲染后的页面外观：
- en: '![](img/B19636_03_01.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_03_01.png)'
- en: 'Figure 3.1: Rendered output using values from state Hooks'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：使用状态钩子值渲染的输出
- en: Now that you’ve seen how to set the initial state values of your components,
    let’s learn about updating these values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经看到了如何设置组件的初始状态值，让我们来了解一下如何更新这些值。
- en: Updating state values
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新状态值
- en: 'React components use state for values that change over time. The state values
    used by components start off in one state, as we saw in the previous section,
    and then change in response to some event: for example, the server responds to
    an API request with new data, or the user has clicked a button or changed a form
    field.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件使用状态来表示随时间变化的价值。组件使用的状态值最初处于一种状态，就像我们在上一节中看到的那样，然后响应某些事件而改变：例如，服务器响应
    API 请求并返回新数据，或者用户点击了按钮或更改了表单字段。
- en: 'To update the state, the `useState` hook provides an individual function for
    every piece of state, which we can access from the returned array from the `useState`
    hook. The first item is the state value and the second is the function used to
    update the value. Let’s take a look at an example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新状态，`useState` 钩子为每一块状态提供了一个单独的函数，我们可以从 `useState` 钩子返回的数组中访问它。第一个元素是状态值，第二个是用于更新值的函数。让我们看看一个例子：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Just like the example from the initial state values section, the `App` component
    in this example has two pieces of state: `name` and `age`. Unlike the previous
    example, this component uses two functions to update each piece of state. These
    are returned from the call to `useState`. Let’s take a closer look:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就像初始状态值部分中的示例一样，本例中的 `App` 组件有两个状态：`name` 和 `age`。与前面的示例不同，此组件使用两个函数来更新每一块状态。这些函数是从
    `useState` 调用中返回的。让我们更仔细地看看：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we have two functions: `setName` and `setAge`: that can be used to update
    the state of our component. Let’s take a look at the text input field that updates
    the `name` state:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个函数：`setName` 和 `setAge`，它们可以用来更新我们组件的状态。让我们看看更新 `name` 状态的文本输入字段：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Whenever the user changes the text in the `<input>` field, the `onChange` event
    is triggered. The handler for this event calls `setName`, passing it `e.target.value`
    as an argument. The argument passed to `setName` is the new state value of name.
    The succeeding paragraph shows that the text input is also updated with the new
    name value every time the user changes the text input.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户更改 `<input>` 字段中的文本时，会触发 `onChange` 事件。此事件的处理器调用 `setName`，并将 `e.target.value`
    作为参数传递给它。传递给 `setName` 的参数是名称的新状态值。接下来的段落显示了每次用户更改文本输入时，文本输入也会更新名称的新值。
- en: 'Next, let’s look at the `age` number input field and how this value is passed
    to `setAge`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `age` 数字输入字段以及这个值是如何传递给 `setAge` 的：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `age` field follows the exact same pattern as the `name` field. The only
    difference is that we’ve made the input a number type. Any time the number changes,
    `setAge` is called with the updated value in response to the `onChange` event.
    The following paragraph shows that the number input is also updated with every
    change that is made to the `age` state.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`age` 字段遵循与 `name` 字段完全相同的模式。唯一的区别是我们将输入类型设置为数字。每当数字发生变化时，`setAge` 就会被调用，并带有
    `onChange` 事件响应的更新值。接下来的段落显示了随着 `age` 状态的每次更改，数字输入也会更新。'
- en: 'Here is what the two inputs and their two corresponding paragraphs look like
    when they’re rendered on the screen:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两个输入及其对应的段落在屏幕上渲染时，它们看起来是这样的：
- en: '![](img/B19636_03_02.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_03_02.png)'
- en: 'Figure 3.2: Using Hooks to change state values'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：使用 Hooks 更改状态值
- en: In this section, you learned about the `useState` hook, which is used to add
    state to functional React components. Each piece of state uses its own hook and
    has its own value variable and its own setter function. This greatly simplifies
    accessing and updating state in your components. Any given state value should
    have an initial value so that the component can render correctly the first time.
    To re-render functional components that use state Hooks, you can use the setter
    functions that `useState` returns to update your state values as needed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了 `useState` 钩子，它用于向功能 React 组件添加状态。每一块状态都使用它自己的钩子，并有自己的值变量和自己的设置函数。这大大简化了在组件中访问和更新状态。任何给定的状态值都应该有一个初始值，这样组件才能在第一次渲染时正确显示。要重新渲染使用状态钩子的功能组件，你可以使用
    `useState` 返回的设置函数来按需更新你的状态值。
- en: The next hook that you’ll learn about is used to perform initialization and
    cleanup actions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来要学习的下一个钩子用于执行初始化和清理操作。
- en: Performing initialization and cleanup actions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行初始化和清理操作
- en: Often, our React components need to perform actions when the component is created.
    For example, a common initialization action is to fetch the API data that the
    component needs. Another common action is to make sure that any pending API requests
    are canceled when the component is removed. In this section, you’ll learn about
    the `useEffect` hook and how it can help you with these two scenarios. You’ll
    also learn how to make sure that the initialization code doesn’t run too often.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们的 React 组件需要在组件创建时执行某些操作。例如，一个常见的初始化操作是获取组件需要的 API 数据。另一个常见操作是在组件移除时确保任何挂起的
    API 请求被取消。在本节中，你将了解 `useEffect` 钩子以及它如何帮助你在这些两种场景下。你还将了解如何确保初始化代码不会运行得太频繁。
- en: Fetching component data
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取组件数据
- en: 'The `useEffect` hook is used to run “side effects” in your component. Another
    way to think about side-effect code is that functional components have only one
    job: returning JSX content to render. If the component needs to do something else,
    such as fetching API data, this should be done in a `useEffect` hook. For example,
    if you were to just make the API call as part of your component function, you
    would likely introduce race conditions and other difficult-to-fix buggy behavior.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子用于在组件中运行“副作用”。另一种思考副作用代码的方式是，函数组件只有一个任务：返回用于渲染的 JSX 内容。如果组件需要做其他事情，例如获取
    API 数据，这应该在 `useEffect` 钩子中完成。例如，如果你只是将 API 调用作为组件函数的一部分，你可能会引入竞态条件和其他难以修复的故障行为。'
- en: 'Let’s take a look at an example that fetches API data using Hooks:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用 Hooks 获取 API 数据的示例：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `useEffect` hook expects a function as an argument. This function is called
    after the component finishes rendering, in a safe way that doesn’t interfere with
    anything else that React is doing with the component under the covers. Let’s look
    at the pieces of this example more closely, starting with the mock API function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子期望一个函数作为参数。这个函数在组件完成渲染后以安全的方式被调用，不会干扰 React 在组件背后进行的任何其他操作。让我们更仔细地看看这个示例的各个部分，从模拟
    API 函数开始：'
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `fetchUser` function is defined using the `useCallback` hook. This hook
    is used to memoize the function, meaning that it will only be created once and
    will not be recreated on subsequent renders unless the dependencies change. The
    `useCallback` accepts two arguments: the first is the function we want to memorize
    and the second is the list of dependencies that will be used to identify when
    React should re-create this function instead of using the memorized version. The
    `fetchUser` function is passed an empty array (`[]`) as the dependency list. This
    means that the function will only be created once during the initial render and
    won’t be recreated on subsequent renders.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchUser` 函数使用 `useCallback` 钩子定义。这个钩子用于记忆函数，意味着它只会创建一次，并且除非依赖项发生变化，否则不会在后续渲染中重新创建。`useCallback`
    接受两个参数：第一个是我们想要记忆的函数，第二个是用于识别 React 应该重新创建此函数而不是使用记忆版本的依赖项列表。`fetchUser` 函数将空数组
    (`[]`) 作为依赖项列表传递。这意味着函数在初始渲染期间只会创建一次，并且在后续渲染中不会重新创建。'
- en: The `fetchUser` function returns a promise. The promise resolves a simple object
    with two properties, `id` and `name`. The `setTimeout` function delays the promise
    resolution for 1 second, so this function is asynchronous, just as a normal `fetch`
    call would be.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchUser` 函数返回一个承诺。承诺解析一个包含两个属性 `id` 和 `name` 的简单对象。`setTimeout` 函数将承诺解决延迟
    1 秒，因此这个函数是异步的，就像正常的 `fetch` 调用一样。'
- en: 'Next, let’s look at the Hooks used by the `App` component:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `App` 组件使用的 Hooks：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, in addition to `useCallback`, we’re using two Hooks in this
    component: `useState` and `useEffect`. Combining hook functionality like this
    is powerful and encouraged. First, we set up the `id` and `name` states of the
    component. Then, `useEffect` is used to set up a function that calls `fetchUser`
    and sets the state of our component when the promise resolves.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除了 `useCallback`，我们还在这个组件中使用了两个 Hooks：`useState` 和 `useEffect`。以这种方式组合
    hook 功能非常强大且被鼓励。首先，我们设置组件的 `id` 和 `name` 状态。然后，使用 `useEffect` 设置一个函数，当承诺解决时调用
    `fetchUser` 并设置组件的状态。
- en: 'Here is what the `App` component looks like when it’s first rendered, using
    the initial state of `id` and `name`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `App` 组件首次渲染时的样子，使用初始状态 `id` 和 `name`：
- en: '![](img/B19636_03_03.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3：显示加载文本，直到数据到达](img/B19636_03_03.png)'
- en: 'Figure 3.3: Displaying the loading text until the data arrives'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：在数据到达之前显示加载文本
- en: 'After 1 second, the promise returned from `fetchUser` is resolved with data
    from the API, which is then used to update the ID and name states. This results
    in `App` being rerendered:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 1秒后，`fetchUser` 返回的promise使用API数据解析，然后用于更新ID和名称状态。这导致 `App` 重新渲染：
- en: '![](img/B19636_03_04.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_03_04.png)'
- en: 'Figure 3.4: The state changes, removing the loading text and displaying returned
    values'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：状态变化，移除加载文本并显示返回值
- en: There is a good chance that your users will navigate around your application
    while an API request is still pending. The `useEffect` hook can be used to deal
    with canceling these requests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有很大可能性，你的用户会在API请求挂起时在应用中导航。`useEffect` 钩子可以用来处理取消这些请求。
- en: Canceling actions and resetting state
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消操作和重置状态
- en: There’s a good chance that, at some point, your users will navigate your app
    and cause components to unmount before responses to their API requests arrive.
    Sometimes your component can listen for some events and you should delete all
    listeners before unmounting the component to avoid memory leaks. In general, it’s
    important to stop performing any background actions when a related component is
    deleted from the screen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有很大可能性，在某个时刻，你的用户会在API请求的响应到达之前导航你的应用，导致组件卸载。有时你的组件可以监听某些事件，你应该在卸载组件之前删除所有监听器以避免内存泄漏。一般来说，当相关组件从屏幕中删除时，停止执行任何后台操作是很重要的。
- en: 'Thankfully, the `useEffect` hook has a mechanism to clean up effects such as
    pending `setInterval` when the component is removed. Let’s take a look at an example
    of this in action:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`useEffect` 钩子有一个机制来清理组件移除时挂起的 `setInterval` 等效果。让我们看看一个实际应用的例子：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a simple `Timer` component. It has the state `timer`, it sets up interval
    callback to update `timer` inside `useEffect()`, and it renders the output with
    the current `timer` value. Let’s take a closer look at the `useEffect()` hook:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 `Timer` 组件。它具有 `timer` 状态，它在 `useEffect()` 中设置间隔回调以更新 `timer`，并使用当前
    `timer` 值渲染输出。让我们更仔细地看看 `useEffect()` 钩子：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This effect creates an interval timer by calling the `setInterval` function
    with a callback, which updates our `timer` state. The interesting thing you will
    notice here is that to the `setTimer` function, we are passing a callback instead
    of a number. It’s a valid React API: when we need the previous state value to
    use to calculate a new one, we can pass a callback where the first argument is
    the current or ‘previous’ state value and we should return the new state value
    from this callback to update our state.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此效果通过调用带有回调的 `setInterval` 函数创建一个间隔计时器，该回调更新我们的 `timer` 状态。你在这里会发现有趣的是，对于 `setTimer`
    函数，我们传递的是一个回调而不是一个数字。这是一个有效的React API：当我们需要使用前一个状态值来计算新值时，我们可以传递一个回调，其中第一个参数是当前或“前一个”状态值，我们应该从这个回调中返回新状态值以更新我们的状态。
- en: Inside `useEffect`, we are also returning a function, which React runs when
    the component is removed. In this example, the interval that is created by calling
    `setInterval` is cleared by calling the function that we returned from `useEffect`,
    where we call `clearInterval`. Functions that you return from `useEffect` will
    be triggered when the component is going to unmount.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `useEffect` 中，我们还在返回一个函数，React 在组件移除时运行此函数。在这个例子中，通过调用 `setInterval` 创建的间隔被调用
    `useEffect` 中返回的函数的 `clearInterval` 清除。从 `useEffect` 返回的函数将在组件将要卸载时触发。
- en: 'Now, let’s look at the `App` component, which renders and removes the `Timer`
    component:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看渲染和移除 `Timer` 组件的 `App` 组件：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `App` component renders a button that is used to toggle the `show` state.
    This state value determines whether or not the `Timer` component is rendered,
    but by using the `ShowHideTimer` convenience component. If show is true, `<Timer
    />` is rendered; otherwise, `Timer` is removed, triggering our `useEffect` cleanup
    behavior.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 组件渲染一个按钮，用于切换 `show` 状态。此状态值决定是否渲染 `Timer` 组件，但通过使用 `ShowHideTimer` 便利组件。如果
    `show` 为真，则渲染 `<Timer />`；否则，移除 `Timer`，触发我们的 `useEffect` 清理行为。'
- en: 'Here’s what the screen looks like when it first loads:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是屏幕首次加载时的样子：
- en: '![](img/B19636_03_05.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_03_05.png)'
- en: 'Figure 3.5: A button used to initiate the state change'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：用于启动状态变化的按钮
- en: 'The `Timer` component isn’t rendered because the `show` state of the `App`
    component is `false`. Try clicking on the show timer button. This will change
    the `show` state and render the `Timer` component:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`App`组件的`show`状态为`false`，`Timer`组件没有被渲染。尝试点击显示计时器按钮。这将改变`show`状态并渲染`Timer`组件：
- en: '![](img/B19636_03_06.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_03_06.png)'
- en: 'Figure 3.6: Displays the timer'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：显示计时器
- en: You can click on the **Hide Timer** button once more to remove the `Timer` component.
    Without the cleanup interval that we added to `useEffect`, this will create new
    listeners every time the timer is rendered, which will affect the memory leak.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以再次点击**隐藏计时器**按钮来移除`Timer`组件。如果没有添加到`useEffect`中的清理间隔，这将每次计时器渲染时创建新的监听器，这将影响内存泄漏。
- en: React allows us to control when we want to run our effects. For example, when
    we want to all API requests after the first render, or we want to perform effects
    when a particular state changes. We’ll take a look at how to do this next.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: React允许我们控制何时运行我们的效果。例如，当我们想在第一次渲染后进行所有API请求，或者当特定状态改变时执行效果。我们将看看如何做到这一点。
- en: Optimizing side-effect actions
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化副作用操作
- en: 'By default, React assumes that every effect that is run needs to be cleaned
    up and it should be run on every render. This typically isn’t the case. For example,
    you might have specific property or state values that require cleanup and run
    one more time when they change. You can pass an array of values to watch as the
    second argument to `useEffect`: for example, if you have a resolved state that
    requires cleanup when it changes, you would write your effect code like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，React假设每个运行的效果都需要清理，并且应该在每次渲染时运行。这通常不是情况。例如，你可能有一些特定的属性或状态值需要清理，并在它们改变时再运行一次。你可以将一个要观察的值的数组作为`useEffect`的第二个参数传递：例如，如果你有一个在改变时需要清理的解析状态，你会这样编写你的效果代码：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this code, the effect will be triggered and only ever run if the resolved
    state value changes. If the effect runs and the resolved state hasn’t changed,
    then the cleanup code will not run and the original effect code will not run a
    second time. Another common case is never running the cleanup code, except for
    when the component is removed. In fact, this is what we want to happen in the
    example from the section on fetching user data. Right now, the effect runs after
    every render. This means that we’re repeatedly fetching the user API data when
    all we really want is to fetch it once when the component is first mounted.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，效果将在状态值解析改变时触发，并且只有在解析状态值改变时才会运行。如果效果运行但解析状态没有改变，则清理代码将不会运行，原始效果代码也不会再次运行。另一个常见的情况是，除了组件被移除时，从不运行清理代码。实际上，这正是我们在“获取用户数据”部分示例中想要发生的。目前，效果在每次渲染后都会运行。这意味着我们反复获取用户API数据，而我们真正想要的只是当组件首次挂载时获取一次。
- en: 'Let’s make some modifications to the `App` component from the fetching component
    data requests example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对从获取组件数据请求示例中的`App`组件进行一些修改：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’ve added a second argument to `useEffect`, an empty array. This tells React
    that there are no values to watch and that we only want to run the effect once
    it is rendered and cleanup code when the component is removed. We’ve also added
    `console.count('fetching user')` to the `fetchUser` function. This makes it easier
    to look at the browser dev tools console and make sure that our component data
    is only fetched once. If you remove the `[]` argument that is passed to `useEffect`,
    you’ll notice that `fetchUser` is called several times.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`useEffect`添加了一个第二个参数，一个空数组。这告诉React没有要观察的值，并且我们只想在渲染后运行效果，并在组件移除时运行清理代码。我们还向`fetchUser`函数中添加了`console.count('fetching
    user')`。这使得查看浏览器开发者工具控制台并确保我们的组件数据只获取一次变得更容易。如果你从传递给`useEffect`的`[]`参数中移除，你会注意到`fetchUser`被多次调用。
- en: In this section, you learned about side effects in React components. Effects
    are an important concept, as they are the bridge between your React components
    and the outside world. One of the most common use cases for effects is to fetch
    data that the component needs, when it is first created, and then clean up after
    the component when it is removed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了React组件中的副作用。效果是一个重要的概念，因为它们是React组件和外部世界之间的桥梁。效果最常见的使用场景之一是在组件首次创建时获取组件所需的数据，然后在组件移除后进行清理。
- en: 'Now, we’re going to look at another way to share data with React components:
    context.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨另一种与React组件共享数据的方法：上下文。
- en: Sharing data using context Hooks
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文Hooks共享数据
- en: 'React applications often have a few pieces of data that are global in nature.
    This means that several components, possibly every component in an app, share
    this data: for example, information about the currently logged-in user might be
    used in several places. This is where the **Context API** comes in handy. The
    Context API provides a way to create a shared data store that can be accessed
    by any component in the tree, regardless of its depth.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: React应用程序通常有一些全局性质的数据。这意味着几个组件，可能是一个应用程序中的所有组件，共享这些数据：例如，当前登录用户的信息可能在多个地方使用。这就是**Context
    API**派上用场的地方。Context API提供了一种创建共享数据存储的方法，任何树中的组件都可以访问，无论其深度如何。
- en: 'To utilize the Context API, we need to create a context using the `createContext`
    function from the **React** library:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用Context API，我们需要使用**React**库中的`createContext`函数创建一个上下文：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the example above, we create a context called `MyContext` using `createContext`.
    This creates a context object that contains a `Provider` and a `Consumer`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们使用`createContext`创建了一个名为`MyContext`的上下文。这创建了一个包含`Provider`和`Consumer`的上下文对象。
- en: 'The `Provider` component is responsible for providing the shared data to its
    child components. We wrap the relevant portion of the component tree with the
    `Provider` and pass the data using the `value` prop:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Provider`组件负责将共享数据提供给其子组件。我们用`Provider`包装组件树的相关部分，并通过`value`属性传递数据：'
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Any component within the `MyContext.Provider` can access the shared data using
    the `Consumer` component or the `useContext` hook. Let’s take a look at how to
    read context using a hook:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MyContext.Provider`内的任何组件都可以使用`Consumer`组件或`useContext`钩子访问共享数据。让我们看看如何使用钩子读取上下文：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By utilizing the Context API, we can avoid the prop-drilling problem where data
    needs to be passed through multiple levels of components. It simplifies the process
    of sharing data and allows components to access the shared data directly, making
    the code more readable and maintainable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用Context API，我们可以避免需要通过多个组件层级传递数据的prop-drilling问题。它简化了数据共享的过程，并允许组件直接访问共享数据，使代码更易于阅读和维护。
- en: It’s worth noting that the Context API is not intended for all scenarios and
    should be used judiciously. It is most useful for sharing data that is truly global
    or relevant to a large portion of the component tree. For smaller-scale data sharing,
    props are still the recommended approach.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Context API并不适用于所有场景，应谨慎使用。它对于共享真正全局或与组件树大部分相关联的数据最有用。对于较小规模的数据共享，属性仍然是推荐的方法。
- en: Memoization with Hooks
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hooks 进行缓存
- en: 'In React, function components are called on every render, which means that
    expensive computations and function creations can negatively impact performance.
    To optimize performance and prevent unnecessary recalculations, React provides
    three Hooks: `useMemo`, `useCallback`, and `useRef`. These Hooks allow us to memoize
    values, functions, and references, respectively.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，函数组件在每次渲染时都会被调用，这意味着昂贵的计算和函数创建可能会对性能产生负面影响。为了优化性能并防止不必要的重新计算，React提供了三个Hooks：`useMemo`、`useCallback`和`useRef`。这些Hooks允许我们分别缓存值、函数和引用。
- en: useMemo Hook
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useMemo 钩子
- en: The `useMemo` hook is used to memoize the result of a computation, ensuring
    that it is only recomputed when the dependencies have changed. It takes a function
    and an array of dependencies and returns the memoized value.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo`钩子用于缓存计算结果，确保只有当依赖项发生变化时才重新计算。它接受一个函数和一个依赖项数组，并返回缓存的值。'
- en: 'Here’s an example of using the `useMemo` hook:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`useMemo`钩子的一个例子：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, the `expensiveResult` value is memoized using `useMemo`. The
    computation inside the function is only executed when the `dependency` value changes.
    If the `dependency` remains the same, the previously memoized value is returned
    instead of recomputing the result.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`expensiveResult`值使用`useMemo`进行了缓存。函数内的计算只有在`dependency`值改变时才会执行。如果`dependency`保持不变，则返回之前缓存的值，而不是重新计算结果。
- en: useCallback hook
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useCallback 钩子
- en: 'We already explored `useCallback` hook in this chapter, but I want to highlight
    one important use case. When a function component renders, all of its functions
    are recreated, including any inline callbacks defined within the component. This
    can lead to unnecessary re-renders of child components that receive these callbacks
    as props, as they perceive the callback as a new reference and trigger re-renders.
    Let’s take a look at the example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章中探讨了 `useCallback` 钩子，但我想要强调一个重要的用例。当一个函数组件渲染时，它所有的函数都会被重新创建，包括在组件内部定义的任何内联回调。这可能导致接收这些回调作为属性的孩子组件的不必要重新渲染，因为这些组件将回调视为新的引用并触发重新渲染。让我们看看下面的例子：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, the inline function we provide to the `onClick` prop will be
    created every time `MyComponent` renders. It means the `MyButton` component will
    receive a new function reference each time, and as we already know, it will result
    in a new render for the `MyButton` component.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们提供给 `onClick` 属性的匿名函数将在 `MyComponent` 每次渲染时创建。这意味着 `MyButton` 组件每次都会接收到一个新的函数引用，正如我们已知的，这将导致
    `MyButton` 组件的新渲染。
- en: 'Here’s an example that demonstrates the use of the `useCallback` hook:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个演示 `useCallback` 钩子使用的例子：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, the `clickHandler` function is memoized using `useCallback`.
    The empty dependency array `[]` indicates that the function has no dependencies
    and should remain constant throughout the component’s lifecycle.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`clickHandler` 函数是通过 `useCallback` 进行缓存的。空依赖数组 `[]` 表示该函数没有依赖项，并且应该在组件的生命周期内保持不变。
- en: As a result, the same function instance is provided to `MyButton` on each render
    of `MyComponent`, preventing unnecessary re-renders of the child.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `MyComponent` 的每次渲染中，都会向 `MyButton` 提供相同的函数实例，从而防止孩子组件的不必要重新渲染。
- en: useRef hook
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useRef 钩子
- en: 'The `useRef` hook allows us to create a mutable reference that persists across
    component renders. It is commonly used to store values or references that need
    to be preserved between renders without triggering re-renders. Additionally, `useRef`
    can be used to access the DOM node or a React component instance:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef` 钩子允许我们创建一个在组件渲染之间持续存在的可变引用。它通常用于存储需要在渲染之间保留的值或引用，而不会触发重新渲染。此外，`useRef`
    可以用来访问 DOM 节点或 React 组件实例：'
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, the `inputRef` is created using `useRef`, and it is assigned
    to the `ref` attribute of the `input` element. This allows us to access the DOM
    node using the `inputRef.current` property. In the `handleButtonClick` function,
    we call the focus method on the `inputRef.current` to focus the input element
    when the button is clicked.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`inputRef` 是通过 `useRef` 创建的，并且被分配给了 `input` 元素的 `ref` 属性。这使我们能够通过 `inputRef.current`
    属性访问 DOM 节点。在 `handleButtonClick` 函数中，我们调用 `inputRef.current` 上的 focus 方法，以便在按钮被点击时聚焦输入元素。
- en: By using `useRef` to access the DOM node, we can interact with the underlying
    DOM elements directly without triggering re-renders of the component.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `useRef` 访问 DOM 节点，我们可以直接与底层的 DOM 元素交互，而不会触发组件的重新渲染。
- en: By leveraging memoization with the `useMemo`, `useCallback`, and `useRef` Hooks,
    we can optimize the performance of our React applications by avoiding unnecessary
    computations, preventing unnecessary re-renders, and preserving values and references
    across renders. This results in a smoother user experience and more efficient
    use of resources.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 `useMemo`、`useCallback` 和 `useRef` 钩子的缓存功能，我们可以通过避免不必要的计算、防止不必要的重新渲染以及跨渲染保留值和引用来优化我们的
    React 应用程序的性能。这导致更平滑的用户体验和更高效地使用资源。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to React components and React Hooks. You learned
    about component properties or props by implementing code that passed property
    values from JSX to the component. Next, you found out what state is and how to
    manipulate it with the `useState` hook. Then, you learned about `useEffect`, which
    enables lifecycle management in functional React components, such as fetching
    API data when a component is mounted and cleaning up any pending async operations
    when it is removed. Then, you learned how to use the `useContext()` hook in order
    to access global application data. Lastly, you learned about memoization with
    the `useMemo`, `useCallback`, and `useMemo` Hooks.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了 React 组件和 React Hooks。您通过实现将属性值从 JSX 传递到组件的代码来学习了组件属性或 props。接下来，您了解了状态是什么以及如何使用
    `useState` 钩子来操作它。然后，您学习了 `useEffect`，它使功能 React 组件能够进行生命周期管理，例如在组件挂载时获取 API 数据，以及在组件移除时清理任何挂起的异步操作。然后，您学习了如何使用
    `useContext()` 钩子来访问全局应用程序数据。最后，您学习了使用 `useMemo`、`useCallback` 和 `useMemo` 钩子进行记忆化。
- en: In the following chapter, you’ll learn about event handling with React components.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用 React 组件处理事件。
