- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding the Architecture of React Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 React 应用程序的架构
- en: React is an open source JavaScript library for building user interfaces created
    and maintained by Meta (Facebook).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: React 是由 Meta（Facebook）创建和维护的开源 JavaScript 库，用于构建用户界面。
- en: It is probably the most popular library for building user interfaces nowadays.
    The reason for its popularity is that it is quite performant and has a small API,
    which makes it a simple yet very powerful tool for creating user interfaces.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能最流行的用于构建用户界面的库就是它。它之所以受欢迎，是因为它性能出色，API 简小，这使得它成为创建用户界面的简单而又非常强大的工具。
- en: It is component-based, which allows us to split large applications into smaller
    parts and work on them in isolation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 它是组件化的，这允许我们将大型应用程序拆分成更小的部分，并独立地工作在这些部分上。
- en: React is also great because its core API is decoupled from the platform, allowing
    projects such as React Native to exist outside the web platform.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: React 也非常出色，因为它的核心 API 与平台解耦，这使得像 React Native 这样的项目可以在网络平台之外存在。
- en: One of React’s biggest strengths but also weaknesses is that it is very flexible.
    This has allowed its community to build great solutions. However, defining a good
    application architecture out of the box can be challenging.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: React 最大的优点也是缺点之一在于它的非常灵活。这允许其社区构建出优秀的解决方案。然而，默认定义一个良好的应用程序架构可能具有挑战性。
- en: Making the right architectural decisions is crucial for any application to succeed,
    especially once it needs changes or it grows in terms of size, the number of users,
    and the number of people working on it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何应用程序的成功来说，做出正确的架构决策至关重要，尤其是在它需要变化或规模、用户数量和参与人数增长时。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Benefits of having a good application architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好应用程序架构的好处
- en: Exploring the architectural challenges of React applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 React 应用程序的架构挑战
- en: Understanding architectural decisions when building React applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建 React 应用程序时理解架构决策
- en: Planning our application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划我们的应用程序
- en: By the end of this chapter, we will learn to think a bit more from the architectural
    point of view when starting React application development.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将学会在开始 React 应用程序开发时从架构的角度思考更多。
- en: Benefits of having a good application architecture
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好应用程序架构的好处
- en: Every application uses some architecture, even without thinking about it. It
    might have been chosen randomly and might not be the right one for its needs and
    requirements, but still, every application does have an architecture.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都使用某种架构，即使没有考虑过。它可能被随机选择，可能并不适合其需求和需求，但无论如何，每个应用程序确实都有架构。
- en: 'That’s why being mindful of the proper architecture at the beginning is essential
    for every project. Let’s define a couple of reasons why:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在项目开始时就关注适当的架构对于每个项目都是至关重要的。让我们定义几个原因：
- en: A good foundation for the project
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目打下良好的基础
- en: Easier project management
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易的项目管理
- en: Increased development speed and productivity
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高开发速度和生产力
- en: Cost-effectiveness
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本效益
- en: Better product quality
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的产品质量
- en: It is worth noting that all applications are prone to requirement changes, so
    it is not always possible to predict everything upfront. However, we should be
    mindful of the architecture from the start. We will discuss these reasons in detail
    in the following sections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，所有应用程序都容易受到需求变化的影响，因此并不总是能够提前预测一切。然而，我们应该从一开始就关注架构。我们将在接下来的章节中详细讨论这些原因。
- en: A good foundation for the project
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为项目打下良好的基础
- en: Every building should be built on solid foundations to remain resilient to different
    conditions such as age, weather conditions, earthquakes, and other causes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每座建筑都应该建立在稳固的基础上，以保持对不同条件如年龄、天气条件、地震和其他原因的抵抗力。
- en: The same thing can apply to applications. Multiple factors cause various changes
    during a project’s lifetime, such as changes in requirements, organization, technologies,
    market, finance, and more. Being built on solid foundations will make it resilient
    to all those changes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这种情况也适用于应用程序。在项目生命周期中，多种因素会导致各种变化，例如需求、组织、技术、市场、财务等。建立在稳固的基础上将使它能够抵御所有这些变化。
- en: Easier project management
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更容易的项目管理
- en: Having different components organized properly will make organizing and delegating
    tasks much easier, especially if a larger team is involved.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 合理组织不同的组件将使组织和委派任务变得更加容易，尤其是在涉及更大团队的情况下。
- en: Good component decoupling will allow better splitting of work between teams
    and team members and faster iterations without team members being blocked by each
    other.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的组件解耦将允许团队和团队成员之间更好地分配工作，并实现更快的迭代，而不会因为彼此而受阻。
- en: It also allows better estimates to be made regarding how much time is required
    for a feature to be completed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许更好地估计完成一个功能所需的时间。
- en: Increased development speed and productivity
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高开发速度和生产力
- en: Having a good architecture defined allows developers to focus on the product
    they are building without overthinking the technical implementations since most
    of the technical decisions should have already been made.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 定义良好的架构可以让开发者专注于他们正在构建的产品，而无需过度思考技术实现，因为大多数技术决策应该已经做出。
- en: Besides that, it will provide a smoother onboarding process for new developers,
    who can be productive quickly after familiarizing themselves with the overall
    architecture.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它将为新开发者提供一个更平滑的入职流程，他们可以在熟悉整体架构后迅速变得高效。
- en: Cost-effectiveness
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经济效益
- en: All the reasons mentioned in the previous sections indicate that the improvements
    a good architecture brings will reduce costs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前各节中提到的所有原因都表明，良好的架构带来的改进将降低成本。
- en: In most cases, the most expensive cost of every project is people and their
    work and time. Therefore, by allowing them to be more efficient, we can reduce
    some redundant costs a bad architecture could bring.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，每个项目的最大成本是人力和他们的工作以及时间。因此，通过让他们更有效率，我们可以减少一些不良架构可能带来的冗余成本。
- en: It will also allow better financial analysis and planning of pricing models
    for software products. It will make it easier to predict all the costs the platform
    requires to be functional.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将允许更好地进行软件产品的财务分析和定价模型规划。这将使预测平台需要的功能所需的所有成本变得更加容易。
- en: Better product quality
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的产品质量
- en: Making all team members productive gives them time to focus and spend more time
    on important things, such as the business requirements and the needs of users,
    rather than spending most of the time fixing bugs and reducing technical debt.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让所有团队成员都变得高效，这样他们就有时间专注于重要的事情，比如业务需求和用户需求，而不是花大部分时间修复错误和减少技术债务。
- en: Better product quality will also make our users more satisfied, which should
    be the end goal.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的产品质量也会让我们的用户更加满意，这应该是最终目标。
- en: To exist, every piece of software needs to meet its requirements. We’ll see
    what these software requirements are in the following section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存在，每款软件都需要满足其需求。在下一节中，我们将看到这些软件需求是什么。
- en: Exploring the architectural challenges of React applications
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索React应用程序的架构挑战
- en: In this section, we will focus on React and see what things are necessary to
    consider when building React applications and the main challenges most React developers
    face when building their applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注React，并探讨在构建React应用程序时需要考虑哪些因素，以及大多数React开发者构建应用程序时面临的主要挑战。
- en: What are the challenges when building a React application?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建React应用程序时有哪些挑战？
- en: React is a great tool for building user interfaces. However, there are some
    challenging things we should think about when building an application. It is very
    flexible, which is both a good and a bad thing. It is good in the sense that we
    can define the architecture of different parts of the application without the
    library getting in our way.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: React是构建用户界面的优秀工具。然而，在构建应用程序时，我们应该考虑一些具有挑战性的事情。它非常灵活，这既是好事也是坏事。好事在于我们可以定义应用程序不同部分的结构，而不会受到库的干扰。
- en: By being so flexible, React has gathered a large community of developers worldwide,
    building different open-source solutions. There is a complete solution for literally
    any problem we might encounter during development. This makes the React ecosystem
    very rich.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React非常灵活，它已经聚集了一个全球范围内的开发者社区，构建了不同的开源解决方案。在开发过程中，我们可能会遇到任何问题的完整解决方案。这使得React生态系统非常丰富。
- en: However, that flexibility and ecosystem richness come with a cost.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种灵活性和生态系统丰富性是有代价的。
- en: 'Let’s take a look at the following React ecosystem overview diagram made by
    `roadmap.sh`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看由`roadmap.sh`制作的以下React生态系统概述图：
- en: '![Figure 1.1 – React developer roadmap by roadmap.sh ](img/B17297_01_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 由roadmap.sh提供的React开发者路线图](img/B17297_01_01.jpg)'
- en: Figure 1.1 – React developer roadmap by roadmap.sh
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 由roadmap.sh提供的React开发者路线图
- en: As shown in *Figure 1**.1*, there is a lot to consider when building an application
    with React. Let’s also keep in mind that this diagram might show just the tip
    of the iceberg. Many different packages and solutions could be used to build the
    same application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如**图1.1**所示，在用React构建应用程序时有很多要考虑的因素。我们也要记住，这个图表可能只显示了冰山一角。许多不同的包和解决方案都可以用来构建相同的应用程序。
- en: 'Some of the most frequent questions when starting with a new React application
    are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用新的React应用程序时，最常见的一些问题如下：
- en: What project structure are we using?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用什么项目结构？
- en: What rendering strategy are we using?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用什么渲染策略？
- en: What state management solution are we using?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用什么状态管理解决方案？
- en: What styling solution are we using?
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用什么样式解决方案？
- en: What data fetching approach are we using?
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用什么数据获取方法？
- en: How are we going to handle user authentication?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将如何处理用户身份验证？
- en: What testing strategies are we going to use?
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将要使用哪些测试策略？
- en: These challenges are not limited to React – they are relevant to building frontend
    applications in general, regardless of which tools are being used. But since this
    book focuses on React, we will be approaching them from that perspective.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些挑战不仅限于React——它们与构建前端应用总体相关，无论使用哪些工具。但鉴于本书专注于React，我们将从那个角度来处理它们。
- en: What project structure are we using?
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们正在使用什么项目结构？
- en: 'Because React is very flexible and has a very small API, it is unopinionated
    about how we should structure our projects. Here is what *Dan Abramov*, one of
    the maintainers of React, says on this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React非常灵活并且API非常小，它对我们的项目结构没有特定的看法。以下是React的维护者之一Dan Abramov关于这一点所说的话：
- en: “*Move files around until it feels right*”
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: “*移动文件直到感觉正确*”
- en: And that is a very good point. It will mostly depend on the nature of the application.
    For example, we wouldn’t organize a social network application and a text editor
    application in the same way because they have different needs and different problems
    to solve.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常正确的观点。它将主要取决于应用程序的本质。例如，我们不会以相同的方式组织社交网络应用程序和文本编辑应用程序，因为它们有不同的需求和要解决的问题。
- en: What rendering strategy are we using?
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们正在使用什么渲染策略？
- en: It depends on the nature of our application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于我们应用程序的本质。
- en: If we are building an internal dashboard application, a single-page application
    is more than enough.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在构建一个内部仪表板应用程序，单页应用程序就足够了。
- en: On the other hand, if we build a customer-facing application that should also
    be public and SEO-friendly, we should think about server-side rendering or static
    generation, depending on how often the data on the pages are being updated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们构建的是一个面向客户的、应该公开且SEO友好的应用程序，那么我们应该考虑服务器端渲染或静态生成，具体取决于页面上的数据更新频率。
- en: What state management solution are we using?
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们正在使用什么状态管理解决方案？
- en: React comes with built-in state management mechanisms with its hooks and Context
    API, but for more complex applications, we often reach for external solutions
    such as **Redux**, **MobX**, **Zustand**, **Recoil**, and others.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: React通过其hooks和Context API内置了状态管理机制，但对于更复杂的应用程序，我们通常求助于外部解决方案，如**Redux**、**MobX**、**Zustand**、**Recoil**等。
- en: Choosing the right state management solution is something that depends a lot
    on the application’s needs and requirements. We will not reach for the same tools
    if we are building a to-do app or an e-commerce application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的状态管理解决方案很大程度上取决于应用程序的需求和需求。如果我们正在构建待办事项应用程序或电子商务应用程序，我们不会使用相同的工具。
- en: It mostly depends on the amount of state that needs to be shared across the
    entire application and the frequency of updating those pieces of state.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要取决于整个应用程序中需要共享的状态量以及这些状态更新的频率。
- en: Will our application have a lot of frequent updates? If that is the case, we
    might consider atom-based solutions such as **Recoil** or **Jotai**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序会有很多频繁的更新吗？如果是这样，我们可能会考虑基于原子的解决方案，如**Recoil**或**Jotai**。
- en: If our application requires a lot of different components to share the same
    state, then **Redux** with **Redux Toolkit** is a good option.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序需要许多不同的组件共享相同的状态，那么**Redux**结合**Redux Toolkit**是一个好选择。
- en: On the other hand, if we do not have a lot of global states and don’t update
    it very often, then **Zustand** or **React Context API**, in combination with
    hooks, are good choices.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们没有很多全局状态并且不经常更新它，那么**Zustand**或**React Context API**，结合hooks，是不错的选择。
- en: At the end of the day, it all depends on the application’s needs and the nature
    of the problem we are trying to solve.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一切都取决于应用的需求和我们试图解决的问题的本质。
- en: What styling solution are we using?
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们将使用什么样式解决方案？
- en: This one mostly depends on preference. Some people prefer vanilla CSS, some
    people love utility-first CSS libraries such as **Tailwind**, and some developers
    can’t live without **CSS** **in JS**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要取决于个人喜好。有些人喜欢纯CSS，有些人喜欢像**Tailwind**这样的实用优先CSS库，而有些开发者则无法离开**CSS in JS**。
- en: Making this decision should also depend on whether our application will be re-rendered
    very often. If that is the case, we might consider build-time solutions such as
    vanilla CSS, SCSS, Tailwind, and others. Otherwise, we can use runtime styling
    solutions such as **Styled Components**, **Emotion**, and more.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 做出这个决定也应该取决于我们的应用是否会被频繁地重新渲染。如果是这样，我们可能会考虑构建时解决方案，如纯CSS、SCSS、Tailwind等。否则，我们可以使用运行时样式解决方案，如**Styled
    Components**、**Emotion**等。
- en: We should also keep in mind whether we want to use a pre-built component library
    or if we want to build everything from scratch.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该记住，我们是否想使用预构建的组件库，或者如果我们想从头开始构建一切。
- en: How are we going to handle user authentication?
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们将如何处理用户认证？
- en: This depends on the API implementation. Are we using token-based authentication?
    Does our API server support cookie-based authentication? It is considered to be
    safer to use cookie-based authentication with `httpOnly` cookies to prevent **cross-site
    scripting** (**XSS**) attacks.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于API实现。我们是否使用基于令牌的认证？我们的API服务器是否支持基于cookie的认证？使用带有`httpOnly` cookie的基于cookie的认证被认为更安全，可以防止**跨站脚本攻击**（XSS）。
- en: Most of these things should be defined together with the backend teams.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些大多数事情都应该与后端团队一起定义。
- en: What testing strategies are we going to use?
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们将使用什么测试策略？
- en: This depends on the team structure, so if we have QA engineers available, we
    will be able to let them do end-to-end tests.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于团队结构，所以如果我们有QA工程师可用，我们将能够让他们进行端到端测试。
- en: It also depends on how much time we can devote to testing and other aspects.
    Keep in mind that we should always consider having some level of testing, at least
    integration, and end-to-end testing for the most critical parts of our application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这也取决于我们可以投入多少时间进行测试和其他方面。记住，我们应该始终考虑至少进行一些级别的测试，对于应用最关键的部分，进行端到端测试。
- en: Understanding architectural decisions when building React applications
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建React应用时理解架构决策
- en: Regardless of the specific needs of the application, there are some generally
    bad and good decisions we can make when building it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不论应用的具体需求如何，在构建过程中，我们都可以做出一些普遍的优劣决策。
- en: Bad architectural decisions
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恶劣的架构决策
- en: Let’s look at some of the bad architectural decisions that might slow us down.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些可能拖慢我们进度的恶劣架构决策。
- en: Flat project structure
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平坦的项目结构
- en: Imagine having a lot of components, all living in the same folder. The simplest
    thing to do is to place all the React components within the components folder,
    which is fine if our components count does not exceed 20 components. After that,
    it becomes difficult to find where a component should belong because they are
    all mixed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下有很多组件，它们都生活在同一个文件夹中。最简单的事情就是将所有React组件放在components文件夹中，如果我们的组件数量不超过20个，这是可以的。之后，由于它们都混合在一起，就很难找到组件应该属于的位置。
- en: Large, tightly coupled components
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大型、紧密耦合的组件
- en: Having large and coupled components have a couple of downsides. They are difficult
    to test in isolation, they are difficult to reuse, and they may also have performance
    issues in some cases because the component would need to be re-rendered entirely
    instead of us re-rendering just a small part of it that needs to be re-rendered.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有大型和耦合的组件有几个缺点。它们在隔离测试中很难，很难重用，并且在某些情况下可能存在性能问题，因为组件需要完全重新渲染，而不是我们只重新渲染需要重新渲染的小部分。
- en: Unnecessary global state
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不必要的全局状态
- en: Having a global state is fine, and often required. But keeping too many things
    in a global state can be a bad idea. It might affect performance, but also maintainability
    because it makes it difficult to understand the scope of the state.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有全局状态是可以的，并且通常是必需的。但是，将太多东西放在全局状态中可能是个坏主意。它可能会影响性能，也可能影响可维护性，因为它使得理解状态的范围变得困难。
- en: Using the wrong tools to solve problems
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用错误的工具解决问题
- en: The number of choices in the React ecosystem makes it easier to choose the wrong
    tools to solve a problem – for example, caching server responses in the global
    store. It may be possible, and we have been doing this in the past, but that doesn’t
    mean we should keep doing that because there are tools to solve this problem,
    such as React Query, SWR, Apollo Client, and so on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: React生态系统中的选择数量使得选择错误的工具来解决问题变得更容易——例如，在全局存储中缓存服务器响应。这可能是有可能的，我们过去一直在这样做，但这并不意味着我们应该继续这样做，因为存在解决这个问题的工具，如React
    Query、SWR、Apollo Client等。
- en: Putting the entire application in a single component in a single file
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将整个应用程序放在单个文件中的单个组件里
- en: This is something that shouldn’t ever happen, but it is still worth mentioning.
    Nothing is preventing us from creating a complete application in a single file.
    It could be thousands of lines long – that is, a single component that would do
    everything. But for the same reason as having large components, it should be avoided.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不应该发生的事情，但仍然值得提及。没有任何东西阻止我们在单个文件中创建一个完整的应用程序。它可能长达数千行——即一个能够完成所有工作的单个组件。但正如拥有大型组件一样，应该避免这样做。
- en: Not sanitizing user inputs
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未清理用户输入
- en: Many hackers on the web are trying to steal our user’s data. Therefore, we should
    do everything possible to prevent such things from happening. By sanitizing user
    inputs, we can prevent hackers from executing some malicious piece of code in
    our application and stealing user data. For example, we should prevent our users
    from inputting anything that could be executed in our application by removing
    any parts of the input that might be risky.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上有许多黑客试图窃取我们的用户数据。因此，我们应该尽一切可能防止这类事情发生。通过清理用户输入，我们可以防止黑客在我们的应用程序中执行恶意代码并窃取用户数据。例如，我们应该通过移除可能存在风险的任何输入部分，防止我们的用户输入任何可能在我们的应用程序中执行的内容。
- en: Using unoptimized infrastructure to serve our application
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用未优化的基础设施来托管我们的应用程序
- en: Using unoptimized infrastructure to serve our application will make our application
    slow when accessed from different parts of the world.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未优化的基础设施来托管我们的应用程序，当从世界各地的不同部分访问时，会使我们的应用程序变慢。
- en: Now that we have covered some bad architectural decisions, let’s see how to
    improve them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一些不良的架构决策，让我们看看如何改进它们。
- en: Good architectural decisions
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 良好的架构决策
- en: Let’s look at some of the good decisions we can make to make our application
    better.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以做出的一些良好决策，以使我们的应用程序变得更好。
- en: Better structured project structure based on domain and features
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于领域和功能的更好结构化的项目结构
- en: Splitting the application structure into different features or domain-specific
    modules, each responsible for its own role, will allow better separation of concerns
    of different application pieces, better modularity of different parts of the application,
    better flexibility, and scalability.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序结构拆分为不同的功能或领域特定模块，每个模块负责其自身的角色，将允许更好地分离应用程序不同部分的关注点，更好地模块化应用程序的不同部分，更好的灵活性和可扩展性。
- en: Better state management
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好的状态管理
- en: Instead of putting everything in a global state, we should start by defining
    a piece of a state as close as possible to where it is being used in the component
    and lift it only if necessary.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从定义尽可能接近组件中使用状态的部分的状态开始，只有在必要时才提升它，而不是将所有内容放入全局状态。
- en: Smaller components
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更小的组件
- en: Having smaller components will make them more testable, easier to track changes,
    and easier to work in larger teams.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有更小的组件将使它们更容易测试、更容易跟踪更改，并且更容易在大团队中协作。
- en: Separation of concerns
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关注点分离
- en: Have each component do as little as possible. This makes components easy to
    understand, test, modify, and even reuse.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让每个组件尽可能少做。这使得组件易于理解、测试、修改，甚至重用。
- en: Static code analysis
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: Relying on static code analysis tools such as **ESLint**, **Prettier**, and
    **TypeScript** will improve our code quality without us having to think too much
    about it. We just need to configure these tools, and they will let us know when
    something is wrong with our code. These tools also introduce consistency in the
    code base regarding formatting, code practices, and documentation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于静态代码分析工具，如**ESLint**、**Prettier**和**TypeScript**，将提高我们的代码质量，而无需我们过多思考。我们只需要配置这些工具，它们就会告诉我们代码中有什么问题。这些工具还在代码库的格式、代码实践和文档方面引入了一致性。
- en: Deploying the application over a CDN
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在CDN上部署应用程序
- en: Having users worldwide means our application should be functional and accessible
    from all over the world. By deploying the application on a CDN, users all over
    the world can access the application in the most optimal way.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户遍布全球，我们的应用程序应该在全球范围内功能齐全且易于访问。通过在CDN上部署应用程序，全球用户都可以以最优化方式访问应用程序。
- en: Planning our application
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划我们的应用程序
- en: Now, let’s apply the principles we just learned about to a real-world scenario
    where we will be planning the application that we will be building.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将刚刚学到的原则应用到实际场景中，我们将规划我们将要构建的应用程序。
- en: What are we building?
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们在构建什么？
- en: We will be building an application that allows organizations to manage their
    job boards. The organization admins can create job postings for their organizations,
    and the candidates can apply for the jobs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个应用程序，允许组织管理他们的工作板。组织管理员可以为他们的组织创建职位发布，候选人可以申请这些职位。
- en: We will be building an MVP version of the application with the minimum set of
    features, but it should be extendable for more features in the future. At the
    end of this book, we will cover the features that the final application could
    have, but to keep things simple, we will be focusing on the MVP version.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个具有最少功能集的最小可行产品（MVP）版本，但它应该可以扩展以添加更多功能。在本书的最后，我们将介绍最终应用程序可能具有的功能，但为了保持简单，我们将专注于MVP版本。
- en: Proper application planning starts with gathering the requirements of the application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的应用规划始于收集应用程序的需求。
- en: Application requirements
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用需求
- en: 'The application has two types of application requirements:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有两种类型的应用需求：
- en: Functional requirements
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性需求
- en: Non-functional requirements
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非功能性需求
- en: Functional requirements
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能性需求
- en: Functional requirements should define what the application should do. They are
    descriptions of all the features and functionalities of an application that our
    users would use.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性需求应定义应用程序应该做什么。它们是我们用户将使用的所有功能和功能描述。
- en: 'Our application can be split into two parts:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序可以分为两部分：
- en: Publicly facing part
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开部分
- en: Organization admin dashboard
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织管理员仪表板
- en: Publicly facing part
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 公开部分
- en: Landing page with some basic information about our application.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含我们应用程序一些基本信息的着陆页。
- en: Public organization view where the visitors can find information about the given
    organization. Besides the basic organization information, it should also include
    the list of jobs of the organization.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共组织视图，访客可以找到有关给定组织的详细信息。除了基本组织信息外，还应包括组织的职位列表。
- en: A public job view where the visitors can view some basic information about the
    given job. Besides this information, it should also include the action for applying
    for the job.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共职位视图，访客可以查看有关给定职位的一些基本信息。除了这些信息外，还应包括申请职位的操作。
- en: Organization admin dashboard
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组织管理员仪表板
- en: Authentication system for the dashboard that should allow organization admins
    to authenticate into the dashboard. For our MVP, we will just implement the login
    functionality with an existing test user.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于仪表板的身份验证系统，应允许组织管理员登录仪表板。对于我们的最小可行产品（MVP），我们只需实现使用现有测试用户的登录功能。
- en: Jobs list view where the admin can view all the jobs of the organization.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 职位列表视图，管理员可以查看组织的所有职位。
- en: Create a job view that contains the form for creating new jobs.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含创建新工作表单的工作视图。
- en: Job details view, which contains all the information about the job.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含有关职位所有信息的职位详情视图。
- en: Non-functional requirements
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非功能性需求
- en: 'Non-functional requirements should define how the application should work from
    the technical side:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 非功能性需求应定义应用程序从技术角度应该如何工作：
- en: '**Performance**: The application must be interactive within 5 seconds. By that,
    we mean that the user should be able to interact with the page within 5 seconds
    from when the request to load the application was made until the user can interact
    with the page.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：应用程序必须在5秒内交互。这意味着用户应该在请求加载应用程序后5秒内与页面交互。'
- en: '**Usability**: The application must be user-friendly and intuitive. This includes
    implementing responsive design for smaller screens. We want the user experience
    to be smooth and straightforward.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：应用程序必须用户友好且直观。这包括为小屏幕实现响应式设计。我们希望用户体验流畅且直接。'
- en: '**SEO**: The public-facing pages of the application should be SEO-friendly.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SEO**：应用程序的公开页面应该是SEO友好的。'
- en: Data model overview
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据模型概述
- en: To better understand how our application will work under the hood, it is helpful
    to understand its data model, so we will dive into that in this section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解我们的应用程序在底层的工作方式，了解其数据模型是有帮助的，因此我们将在本节中深入探讨。
- en: 'In the following diagram, we can see what our data model looks like from the
    database perspective:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到从数据库的角度看我们的数据模型是什么样的：
- en: '![Figure 1.2 – Data model overview ](img/B17297_01_02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 数据模型概述](img/B17297_01_02.jpg)'
- en: Figure 1.2 – Data model overview
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 数据模型概述
- en: 'As seen in *Figure 1**.2*, there are three main models in the application:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如**图1.2**所示，应用程序中有三种主要模型：
- en: User
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户
- en: Organization
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织
- en: Job
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作
- en: Defining the application requirements and data model should give us a good understanding
    of what we are building. Now, let’s explore the technical decisions for our application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 定义应用程序需求和数据模型应该能让我们很好地理解我们正在构建的内容。现在，让我们来探讨我们应用程序的技术决策。
- en: Exploring the technical decisions
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索技术决策
- en: Let’s see what technical decisions we need to make for our application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要为我们的应用程序做出哪些技术决策。
- en: Project structure
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目结构
- en: We will be using a feature-based project structure that allows good feature
    isolation and good communication between the features.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用基于功能的工程项目结构，这有助于良好的功能隔离和功能之间的良好沟通。
- en: This means we will create a feature folder for every larger functionality, which
    will make the application structure more scalable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将为每个较大的功能创建一个功能文件夹，这将使应用程序结构更具可扩展性。
- en: It will scale very well when the number of features increases because we only
    need to worry about a specific feature and not the entire application at once,
    where the code is scattered all over the place.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当功能数量增加时，它将扩展得非常好，因为我们只需要担心一个特定的功能，而不是整个应用程序，代码散布在各个地方。
- en: We will see the project structure definition in action in the upcoming chapters.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中看到项目结构定义的实际应用。
- en: Rendering strategy
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染策略
- en: When it comes to the rendering strategy, we are referring to the way the pages
    of our application are being created.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当提到渲染策略时，我们指的是我们应用程序页面创建的方式。
- en: 'Let’s look at the different types of rendering strategies:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不同的渲染策略类型：
- en: '**Server-side rendering**: In the early days of the web, this was the most
    common way to generate pages with dynamic content. The page content is created
    on the fly, inserted into the page on the server, and then returned to the client.
    The benefits of this approach are that the pages are easier to crawl by search
    engines, which is important for SEO, and users might get faster initial loads
    of the page compared to single-page apps. The downside of this approach is that
    it might require more server resources. In our scenario, we will be using this
    approach for the pages that can be updated frequently and should be SEO optimized
    at the same time, such as the public organization page and public job page.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端渲染**：在互联网的早期，这是生成具有动态内容的页面的最常见方式。页面内容是即时创建的，在服务器上插入页面，然后返回给客户端。这种方法的好处是页面更容易被搜索引擎爬取，这对SEO很重要，并且与单页应用程序相比，用户可能会获得更快的页面初始加载速度。这种方法的不利之处在于可能需要更多的服务器资源。在我们的场景中，我们将使用这种方法来更新频繁且需要同时进行SEO优化的页面，例如公共组织页面和公共工作页面。'
- en: '**Client-side rendering**: The existence of client-side JavaScript libraries
    and frameworks, such as React, Angular, Vue, and others, allows us to create complex
    client-side applications completely on the client. The benefit of this is that
    once the application is loaded in the browser, the transition between pages seems
    very fast. On the other hand, for the application to load, we need to download
    a lot of JavaScript to use the application. This can be improved by code splitting
    and lazy loading. It is also more difficult to crawl the page’s content using
    search engines, which can impact SEO scores. We can use this approach for protected
    pages, which is every page in the dashboard of our application.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端渲染**：客户端JavaScript库和框架（如React、Angular、Vue等）的存在，使我们能够在客户端完全创建复杂的客户端应用程序。这种方法的优点是，一旦应用程序在浏览器中加载，页面之间的转换看起来非常快。另一方面，为了加载应用程序，我们需要下载大量的JavaScript来使用应用程序。这可以通过代码拆分和懒加载来改进。使用搜索引擎爬取页面内容也更加困难，这可能会影响SEO评分。我们可以使用这种方法来保护页面，也就是我们应用程序仪表板中的每一个页面。'
- en: '**Static generation**: This is the most straightforward approach. Here, we
    can generate our pages while building the application and serve them statically.
    It is very fast, and we can use this approach for pages that never update but
    need to be SEO optimized, such as the landing page of our application.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态生成**：这是最直接的方法。在这里，我们可以在构建应用程序的同时生成我们的页面，并以静态方式提供服务。这非常快，我们可以使用这种方法为那些永不更新但需要SEO优化的页面，例如我们应用程序的着陆页。'
- en: Since our application requires multiple rendering strategies, we will use Next.js,
    which supports each of them very well.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序需要多种渲染策略，我们将使用Next.js，它非常出色地支持每种策略。
- en: State management
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态管理
- en: State management is probably one of the most discussed topics in the React ecosystem.
    It is very fragmented, meaning there are so many libraries that handle state that
    it makes it difficult for the developers to make a choice.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理可能是React生态系统中最常讨论的话题之一。它非常碎片化，这意味着有如此多的库处理状态，以至于让开发者难以做出选择。
- en: 'To make state management easier for us, we need to understand that there are
    multiple types of states:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使状态管理对我们来说更容易，我们需要理解存在多种状态类型：
- en: '**Local state**: This is the simplest type of state. It is the state that is
    being used in a single component only and is not required anywhere else. We will
    use the built-in React hooks to handle that.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地状态**：这是最简单的状态类型。它是在单个组件中使用的状态，且不需要在其他任何地方使用。我们将使用内置的React hooks来处理这一点。'
- en: '**Global state**: This is the state that is shared across multiple components
    in the application. It is used to avoid prop drilling. We will be using a lightweight
    library called **Zustand** for this.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局状态**：这是在应用程序的多个组件间共享的状态。它用于避免属性钻取。我们将使用一个名为**Zustand**的轻量级库来处理这一点。'
- en: '**Server state**: This state is used to store data responses from the API.
    Things such as loading states, request de-duplications, polling, and others are
    very challenging to implement from scratch. Therefore, we will be using **React
    Query** to handle this elegantly so that we have less code to write.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器状态**：这种状态用于存储来自API的数据响应。像加载状态、请求去重、轮询等其他功能从头开始实现非常具有挑战性。因此，我们将使用**React
    Query**来优雅地处理这些功能，这样我们就有更少的代码要写。'
- en: '**Form state**: This should handle form inputs, validation, and other aspects.
    We will be using the **React Hook Form** library to handle forms in our application.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单状态**：这应该处理表单输入、验证和其他方面。我们将使用**React Hook Form**库来处理我们应用程序中的表单。'
- en: '**URL state**: This type of state is often overlooked yet very powerful. URL
    and query params can also be considered as pieces of state. This is especially
    useful when we want to deep-link some part of the view. Capturing the state in
    the URL makes it very easy to share it.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL状态**：这种类型的状态经常被忽视，但非常强大。URL和查询参数也可以被视为状态的一部分。当我们想要深度链接视图的某个部分时，这特别有用。在URL中捕获状态使其非常容易分享。'
- en: Styling
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式
- en: Styling is also a big topic in the React ecosystem. There are many great libraries
    for styling React components.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 样式也是React生态系统中的一个重要话题。有许多优秀的库用于样式化React组件。
- en: To style our application, we will use the **Chakra UI** component library, which
    uses Emotion under the hood, and it comes with a variety of nice-looking and accessible
    components that are very flexible and easy to modify.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了样式化我们的应用程序，我们将使用**Chakra UI**组件库，它底层使用Emotion，并附带各种看起来很好且无障碍友好的组件，这些组件非常灵活且易于修改。
- en: The reason for choosing Chakra UI is that it has a great developer experience.
    It is very customizable, and its components are accessibility-friendly out of
    the box.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Chakra UI的原因是它拥有极佳的开发者体验。它非常可定制，并且其组件默认就是无障碍友好的。
- en: Authentication
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证
- en: The authentication of our application will be cookie-based, meaning that on
    a successful auth request, a cookie will be attached to the headers, which will
    handle user authentication on the server. We are choosing cookie-based authentication
    because it is more secure.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的认证将基于cookie，这意味着在成功的认证请求中，一个cookie将被附加到头部，这将处理服务器上的用户认证。我们选择基于cookie的认证是因为它更安全。
- en: Testing
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试
- en: Testing is a very important method of asserting that our application is working
    as it’s supposed to.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是我们确保应用程序按预期工作的重要方法。
- en: We don’t want to ship our product with bugs in it. Also, manual testing takes
    more time and effort to discover new bugs, so we want to have automated tests
    for our application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望我们的产品带有错误。此外，手动测试需要更多的时间和精力来发现新错误，因此我们希望为我们的应用程序拥有自动化测试。
- en: 'There are multiple types of tests:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种类型的测试：
- en: '**Unit tests**: Unit tests only test the smallest units of an application in
    isolation. We will be using **Jest** to unit-test the shared components of our
    application.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：单元测试仅在隔离状态下测试应用程序的最小单元。我们将使用 **Jest** 对应用程序的共享组件进行单元测试。'
- en: '**Integration tests**: Integration tests test multiple units at once. They
    are very useful for testing the communication between multiple different parts
    of the application. We will be using **React Testing Library** to test our pages.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：集成测试同时测试多个单元。它们对于测试应用程序不同部分之间的通信非常有用。我们将使用 **React Testing Library**
    测试我们的页面。'
- en: '**End-to-end tests**: End-to-end tests allow us to test our application’s most
    important parts end to end, meaning we can test the entire flow. Usually, the
    most important end-to-end tests should test the most critical features. For this
    kind of testing, we will be using **Cypress**.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：端到端测试允许我们从头到尾测试应用程序最重要的部分，这意味着我们可以测试整个流程。通常，最重要的端到端测试应该测试最关键的功能。对于这种测试，我们将使用
    **Cypress**。'
- en: This was an overview of how our application should work. Now, we should be able
    to start implementing it in code in the upcoming chapters.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对我们的应用程序应该如何工作的概述。现在，我们应该能够开始在接下来的章节中用代码实现它。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: React is a very popular library for building user interfaces, and it leaves
    most of the architectural choices to developers, which can be challenging.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个用于构建用户界面的非常流行的库，它将大多数架构选择留给了开发者，这可能具有挑战性。
- en: In this chapter, we learned that some of the benefits of setting up a good architecture
    are a good project foundation, easier project management, increased productivity,
    cost-effectiveness, and better product quality.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到设置良好架构的一些好处包括良好的项目基础、更易于项目管理、提高生产力、成本效益和更好的产品质量。
- en: We also learned about the challenges to consider, such as project structure,
    rendering strategies, state management, styling, authentication, testing, and
    others.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到了需要考虑的挑战，例如项目结构、渲染策略、状态管理、样式、身份验证、测试以及其他。
- en: Then, we covered the planning phase of the application that we will be building,
    which is an application for managing job boards and job applications by gathering
    requirements. We did that by defining the data model of the application and choosing
    the right tools to overcome the architectural challenges.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了我们将要构建的应用程序的规划阶段，这是一个通过收集需求来管理职位板和职位申请的应用程序。我们通过定义应用程序的数据模型和选择合适的工具来克服架构挑战来实现这一点。
- en: This has given us a good foundation to implement our architecture in a real-world
    scenario, as we will see in the following chapters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个良好的基础，可以在现实场景中实施我们的架构，正如我们将在以下章节中看到的那样。
- en: In the next chapter, we will cover the entire setup that we will be using for
    building the application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍我们将用于构建应用程序的整个设置。
