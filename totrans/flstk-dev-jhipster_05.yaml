- en: Customization and Further Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制和进一步开发
- en: 'In the previous chapter, we saw how to use the JHipster Domain Language to
    model and generate our domain model. We also learned about entity relationships
    and the `import-jdl` sub-generator. In this chapter, we will see how we can further
    customize and add business logic to the generated application to suit our needs.
    We will learn about:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用 JHipster 领域语言来建模和生成我们的领域模型。我们还学习了实体关系和 `import-jdl` 子生成器。在本章中，我们将看到如何进一步定制和添加业务逻辑到生成的应用程序以满足我们的需求。我们将学习以下内容：
- en: Live reload with Spring DevTools and BrowserSync
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring DevTools 和 BrowserSync 进行实时重新加载
- en: Customizing the angular frontend for an entity
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为实体定制 angular 前端
- en: Editing an entity created using the JHipster entity generator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑使用 JHipster 实体生成器创建的实体
- en: Changing the look and feel of the application using a Bootstrap theme
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bootstrap 主题更改应用程序的外观和感觉
- en: Adding a new i18n language using the JHipster language generator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JHipster 语言生成器添加新的 i18n 语言
- en: Customizing the generated REST API to add additional role-based authorization
    with Spring Security
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Security 添加基于角色的额外授权来定制生成的 REST API
- en: Creating new Spring Data JPA queries and methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的 Spring Data JPA 查询和方法
- en: Live reload for development
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发时的实时重新加载
- en: 'When developing an application, one of the most annoying and time-consuming
    parts is recompiling the code and restarting the servers to see the code changes
    we have made. Traditionally, JavaScript code used to be easier, as it didn''t
    need any compilation and you could just refresh the browser and see the changes.
    However, even though current MVVM stacks make the client side more important than
    before, they also introduce side effects, such as transpiling of client-side code,
    and more. So, if you are refactoring a field for an entity, you would traditionally
    need to do the following tasks to see the changes in your browser:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，最令人烦恼和耗时的一部分是重新编译代码和重新启动服务器以查看我们所做的代码更改。传统上，JavaScript 代码更容易，因为它不需要编译，你只需刷新浏览器就能看到更改。然而，尽管当前的
    MVVM 堆栈使客户端比以前更重要，但它们也引入了副作用，如客户端代码的转译等。所以，如果你正在重构实体的一个字段，你传统上需要执行以下任务才能在浏览器中看到更改：
- en: Compile the server-side Java code.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译服务器端 Java 代码。
- en: Apply the table changes to the database.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表更改应用到数据库中。
- en: Recompile the client-side code.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编译客户端代码。
- en: Restart the application server.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动应用程序服务器。
- en: Refresh the browser.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新浏览器。
- en: This takes a lot of time, is frustrating to do for every small change, and results
    in you making more changes before checking them, hence affecting productivity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要花费很多时间，每次进行小改动时都令人沮丧，导致你在检查之前做出更多更改，从而影响生产力。
- en: What if I told you that you don't have to do any of these, and all of this could
    happen automatically as you save your changes using your IDE? That would be awesome,
    wouldn't it?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你，你不必做任何这些事情，而且所有这些都可以在你使用 IDE 保存更改时自动发生，那会怎么样？那会非常棒，不是吗？
- en: With JHipster you get exactly that. JHipster uses Spring Boot DevTools, webpack
    dev server, and BrowserSync to enable a nice live reload feature for the end-to-end
    code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JHipster，你将得到完全相同的功能。JHipster 使用 Spring Boot DevTools、webpack 开发服务器和 BrowserSync
    来为端到端代码提供良好的实时重新加载功能。
- en: Let's take a quick look at the technologies used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下所使用的这些技术。
- en: Spring Boot DevTools
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot DevTools
- en: Spring Boot DevTools ([https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html))
    enables Spring Boot applications to reload the embedded server when there is a
    change in the classpath. It states the following—*The aim of this module is to
    try and improve the development-time experience when working on Spring Boot applications*, and
    it does exactly that. It uses a custom classloader to restart the application
    when a class is updated and recompiled, and since the server is hot reloaded it
    is much faster than a cold restart.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot DevTools ([https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html))
    允许 Spring Boot 应用程序在类路径发生变化时重新加载嵌入的服务器。它声明如下——*本模块的目的是尝试改善在开发 Spring Boot 应用程序时的开发体验*，并且它确实做到了这一点。它使用自定义类加载器在类更新和重新编译时重启应用程序，并且由于服务器是热重载的，所以比冷启动快得多。
- en: It isn't as cool as JRebel or similar technologies, which do instant reload,
    but it beats doing it manually and doesn't require any extra configuration to
    enable it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它不如 JRebel 或类似技术那样酷，这些技术可以即时重新加载，但它比手动操作要好，并且不需要任何额外配置即可启用。
- en: JHipster DevTools is automatically enabled in the `dev` profile, using an IDE
    that can automatically recompile classes on saving. The DevTools will ensure the
    application is reloaded and up to date. Since Liquibase is used, any schema updates
    using proper changelogs will also get updated. Make sure not to change existing
    changelogs as it will cause a checksum error. Application reloads can also be
    triggered by simply using the commands `mvnw compile` or `gradlew compileJava`
    depending on the build tool used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster DevTools 在 `dev` 配置文件中自动启用，使用可以自动在保存时重新编译类的 IDE。DevTools 将确保应用程序重新加载并保持最新。由于使用了
    Liquibase，任何使用正确变更日志的架构更新也将得到更新。请确保不要更改现有的变更日志，因为这会导致校验和错误。应用程序的重新加载也可以通过简单地使用命令
    `mvnw compile` 或 `gradlew compileJava` 来触发，具体取决于所使用的构建工具。
- en: If you choose a NoSQL DB, such as MongoDB, Cassandra, or Couchbase, JHipster
    provides database migration tools for those as well.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择 NoSQL 数据库，例如 MongoDB、Cassandra 或 Couchbase，JHipster 也为这些数据库提供了数据库迁移工具。
- en: Webpack dev server and BrowserSync
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack 开发服务器和 BrowserSync
- en: Webpack dev server ([https://github.com/webpack/webpack-dev-server](https://github.com/webpack/webpack-dev-server))
    provides a simple Express server using webpack dev middleware, and supports live
    reloads when assets change. Webpack dev middleware supports features such as hot
    module replacement and in memory file access.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 开发服务器 ([https://github.com/webpack/webpack-dev-server](https://github.com/webpack/webpack-dev-server))
    使用 webpack 开发中间件提供了一个简单的 Express 服务器，并在资源更改时支持实时重新加载。Webpack 开发中间件支持热模块替换和内存文件访问等功能。
- en: In Webpack Version 4 and above a new alternative called webpack-serve ([https://github.com/webpack-contrib/webpack-serve](https://github.com/webpack-contrib/webpack-serve))
    is used instead of Webpack dev server. It uses native WebSocket support in newer
    browsers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Webpack 版本 4 及以上版本中，使用了一个名为 webpack-serve ([https://github.com/webpack-contrib/webpack-serve](https://github.com/webpack-contrib/webpack-serve))
    的新替代方案，而不是 Webpack 开发服务器。它利用了较新浏览器中的原生 WebSocket 支持。
- en: BrowserSync ([https://browsersync.io/](https://browsersync.io/)) is a Node.js
    tool that helps in browser testing by synchronizing file changes and interactions
    of the web page across multiple browsers and devices. It provides features such
    as auto-reload on file changes, synchronized UI interactions, scrolling, and so
    on. JHipster integrates BrowserSync with Webpack dev server to provide a productive
    development setup. It makes testing a web page on different browsers and devices
    super easy. Changes to CSS are loaded without a browser refresh.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: BrowserSync ([https://browsersync.io/](https://browsersync.io/)) 是一个 Node.js
    工具，它通过同步多个浏览器和设备上网页的文件更改和交互来帮助进行浏览器测试。它提供了诸如文件更改时的自动重新加载、同步 UI 交互、滚动等功能。JHipster
    将 BrowserSync 与 Webpack 开发服务器集成，以提供高效的开发环境。这使得在不同的浏览器和设备上测试网页变得非常简单。CSS 的更改无需刷新浏览器即可加载。
- en: To use live reload on the client side you need to run `yarn start`, which will
    start the development server and open up a browser pointing to `http://localhost:9000`.
    Notice the port `9000`. BrowserSync will be using this port, while the application
    backend will be served at `8080`, which all requests will be proxied through via
    webpack dev middleware.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要在客户端使用实时重新加载，你需要运行 `yarn start`，这将启动开发服务器并打开指向 `http://localhost:9000` 的浏览器。注意端口号
    `9000`。BrowserSync 将使用此端口，而应用程序的后端将在 `8080` 上提供服务，所有请求将通过 webpack 开发中间件代理。
- en: Open another browser, for example, Firefox if BrowserSync has opened Chrome
    already or vice versa. Now place them side by side and play around with the application.
    You will see your actions are replicated, thanks to BrowserSync. Try changing
    some code and save the file to see live reload in action.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个浏览器，例如，如果 BrowserSync 已经打开了 Chrome，则打开 Firefox，反之亦然。现在将它们并排放置，并与应用程序交互。你会看到你的操作被复制，多亏了
    BrowserSync。尝试更改一些代码并保存文件，以查看实时重新加载的效果。
- en: Setting up live reload for an application
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序设置实时重新加载
- en: Let's start the perfect development setup for the application we created. In
    a terminal, start the server in dev mode by running `./gradlew` and in another
    terminal, start the client side development server by running `yarn start`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为创建的应用程序设置完美的开发环境。在终端中，通过运行 `./gradlew` 以开发模式启动服务器，在另一个终端中，通过运行 `yarn start`
    启动客户端开发服务器。
- en: Now when you make any changes on the server side simply run `./gradlew compileJava`
    or if you are using an IDE click on the compile button.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你在服务器端进行任何更改时，只需运行`./gradlew compileJava`，或者如果你使用的是 IDE，点击编译按钮。
- en: With IntelliJ IDEA, files are automatically saved and so you can set up *Ctrl*
    + *S* to compile the classes giving you a nice workflow. In Eclipse, saving a
    class automatically compiles it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IntelliJ IDEA，文件会自动保存，因此你可以设置 *Ctrl* + *S* 来编译类，从而提供一个良好的工作流程。在 Eclipse 中，保存类会自动编译。
- en: When you make changes on the client side, simply save the file and webpack dev
    server and BrowserSync will do the rest.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在客户端进行更改时，只需保存文件并启动 webpack 开发服务器和 BrowserSync，它将完成剩余的工作。
- en: Customizing the Angular frontend for an entity
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为实体自定义 Angular 前端
- en: Now that we have our entity domain model created and working, let's make it
    more usable. The Product listing screen has a table view generated by JHipster;
    it is sufficient for simple CRUD operations but isn't the best-suited user experience
    for end users who want to browse our product listing. Let's see how we can easily
    change to something more appealing. We will also add a nice client-side filter
    option to filter the listing. We will be using both Angular and Bootstrap features
    for this.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了工作着的实体领域模型，让我们让它更易于使用。产品列表屏幕由 JHipster 生成的表格视图；它对于简单的 CRUD 操作来说是足够的，但并不是最适合想要浏览我们的产品列表的最终用户的用户体验。让我们看看我们如何轻松地将其更改为更吸引人的东西。我们还将添加一个不错的客户端筛选选项来筛选列表。我们将使用
    Angular 和 Bootstrap 的功能来完成这项工作。
- en: 'First, let''s find the source code that we would need to edit. In your favorite
    editor/IDE navigate to `src/main/webapp/app/entities/product`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们找到我们需要编辑的源代码。在你的首选编辑器/IDE 中导航到`src/main/webapp/app/entities/product`：
- en: '![](img/bca08683-2256-4fd8-8465-f61b3530b443.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bca08683-2256-4fd8-8465-f61b3530b443.png)'
- en: 'Let''s start by customizing the `product.component.html` file to update the
    UI view of the product listing. The HTML code currently renders a table view and
    uses some Angular directives to enhance the view with sorting and pagination.
    Let''s first change the view from a table into a list, but first open the development
    web server from BrowserSync, if it''s not already open, by navigating to `http://localhost:9000`.
    Log in and navigate to Entities | Product Category and create a category, then
    navigate to Entities | Product and create few new products so that we have something
    to list:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从自定义`product.component.html`文件开始，以更新产品列表的 UI 视图。当前的 HTML 代码渲染一个表格视图，并使用一些
    Angular 指令来增强视图，包括排序和分页。让我们首先将视图从表格更改为列表，但首先通过导航到`http://localhost:9000`打开 BrowserSync
    的开发 web 服务器（如果尚未打开）。登录并导航到实体 | 产品类别，创建一个类别，然后导航到实体 | 产品，创建一些新产品，以便我们有东西可以列出：
- en: '![](img/5cf97e13-399a-4bb3-8b1e-2a78d11690e2.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5cf97e13-399a-4bb3-8b1e-2a78d11690e2.png)'
- en: 'We can use the Bootstrap List group ([https://getbootstrap.com/docs/4.0/components/list-group/](https://getbootstrap.com/docs/4.0/components/list-group/))
    component for this purpose. Let''s use the following snippet and change the view.
    Replace the `div` with `class="table-responsive"` with the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Bootstrap 列表组([https://getbootstrap.com/docs/4.0/components/list-group/](https://getbootstrap.com/docs/4.0/components/list-group/))组件来实现这个目的。让我们使用以下代码片段并更改视图。将`div`替换为`class="table-responsive"`的以下代码：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, we are iterating the products using the Angular directive `*ngFor="let
    product of products; trackBy: trackId"` on the anchor element so that the element
    is created for each product in the list. We wrap this in a `*ngIf="products"`
    directive so that the view is rendered only when the product''s object is defined.
    The `[routerLink]="[''../product'', product.id ]"` directive will create a href
    for the anchor using the Angular router so that we can navigate to the particular
    product route.  We then use properties from the product in template strings to
    be rendered using `{{product.name}}` syntax. As you save the code, you might notice
    that the view refreshes automatically, thanks to BrowserSync.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，我们正在使用 Angular 指令`*ngFor="let product of products; trackBy: trackId"`在锚点元素上迭代产品，以便为列表中的每个产品创建元素。我们用`*ngIf="products"`指令包裹这个，这样只有在产品对象定义时才会渲染视图。`[routerLink]="[''../product'',
    product.id ]"`指令将使用 Angular 路由为锚点创建一个 href，这样我们就可以导航到特定的产品路由。然后我们使用产品的属性在模板字符串中使用`{{product.name}}`语法进行渲染。当你保存代码时，你可能会注意到视图会自动刷新，这要归功于
    BrowserSync。'
- en: The `trackBy` function used in `ngFor` lets Angular decide which items are added
    or removed from a collection. This improves rendering performance as Angular can
    now figure out which items need to be added or removed from DOM exactly, without
    having to recreate the entire collection. Here, we provide `trackId` as the function
    to uniquely identify an item in the collection.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ngFor`中使用的`trackBy`函数让Angular决定哪些项目被添加或从集合中删除。这提高了渲染性能，因为现在Angular可以精确地找出需要添加或从DOM中删除哪些项目，而不必重新创建整个集合。在这里，我们提供`trackId`作为函数来唯一标识集合中的项目。
- en: 'This will produce the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '![](img/a312031d-0b47-4d3d-8350-488708564282.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a312031d-0b47-4d3d-8350-488708564282.png)'
- en: 'While it''s a good start, it''s not enough. So, let''s go in and make it better.
    Let''s add the image to the listing first. Modify the code to add Bootstrap rows
    and columns, as shown in the following code, the original code rendering the content
    is moved into the second column and remains unchanged:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个好的开始，但还不够。所以，让我们进去并让它变得更好。首先，让我们将图片添加到列表中。修改代码以添加Bootstrap行和列，如下所示，原始的渲染内容代码被移动到第二列，并且保持不变：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Take a look at the code highlighted in bold. We added a Bootstrap row ([https://getbootstrap.com/docs/4.0/layout/grid/](https://getbootstrap.com/docs/4.0/layout/grid/))
    with two column divs, the first div takes up two columns in a 12 column grid specified
    by `col-2`, while we also say that when the display is **xs** (**extra small**)
    the `div` tag should take 12-columns using `col-xs-12`. The second `div` is kept
    responsive by specifying just `col` so it takes the remaining available columns
    after the first `div`, and when the display is extra small it takes up 12 columns
    as well. The image inside the first column `div` uses a data URL as `src` to render
    the image. Now we have an even better view:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下加粗的代码。我们添加了一个Bootstrap行，其中包含两个列div，第一个div在12列网格中占用两个列，指定为`col-2`，同时我们还说当显示为**xs**（**额外小**）时，`div`标签应该使用`col-xs-12`占用12列。第二个`div`通过仅指定`col`来保持响应式，它占用第一个`div`之后的剩余可用列，当显示为额外小尺寸时，它也占用12列。第一个列`div`中的图片使用数据URL作为`src`来渲染图片。现在我们有一个更好的视图：
- en: '![](img/e0a5d8d9-4d36-460c-8eb5-b73798c4cdd7.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0a5d8d9-4d36-460c-8eb5-b73798c4cdd7.png)'
- en: We can polish it further. We can use the Angular currency pipe ([https://angular.io/api/common/CurrencyPipe](https://angular.io/api/common/CurrencyPipe))
    for the price and remove the redundant label for it by changing to `{{product.price
    | currency:'USD'}}`.  We can add a label for the category shown on the right-hand
    side of the list as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步润色它。我们可以使用Angular货币管道([https://angular.io/api/common/CurrencyPipe](https://angular.io/api/common/CurrencyPipe))来显示价格，并通过将其更改为`{{product.price
    | currency:'USD'}}`来移除其冗余标签。我们还可以为列表右侧显示的分类添加一个标签。
- en: 'Finally, we can add the Edit and Delete buttons back, but we need to show them
    only for users who have the role `ADMIN` so that normal users will only be able
    to view the product listing. We can copy the HTML code for `edit` and `delete`
    buttons from the original table. The final code will be as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将编辑和删除按钮重新添加回来，但我们只需要为具有`ADMIN`角色的用户显示它们，这样普通用户就只能查看产品列表。我们可以从原始表格中复制`edit`和`delete`按钮的HTML代码。最终的代码如下：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `*jhiHasAnyAuthority="''ROLE_ADMIN''"` directive is provided by JHipster
    and can be used to control presentation based on user roles. By default, JHipster
    provides `ROLE_ADMIN` and `ROLE_USER`, but controlling this only on the client
    side is not secure as it can be easily bypassed, so we should secure this on the
    server side as well. We will look at this later in the chapter. Log out and log
    in again using the user account to see the directive in action:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`*jhiHasAnyAuthority="''ROLE_ADMIN''"`指令由JHipster提供，可以用于根据用户角色控制展示。默认情况下，JHipster提供`ROLE_ADMIN`和`ROLE_USER`，但仅在客户端控制这并不安全，因为它很容易被绕过，所以我们应该在服务器端也进行安全控制。我们将在本章后面讨论这个问题。使用用户账户注销并重新登录以查看指令的作用：'
- en: '![](img/917bd423-64fd-47df-85d5-6f899bb36ae3.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/917bd423-64fd-47df-85d5-6f899bb36ae3.png)'
- en: Now, let's also add the `*jhiHasAnyAuthority="'ROLE_ADMIN'"` directive to the
    create button element.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们也将`*jhiHasAnyAuthority="'ROLE_ADMIN'"`指令添加到创建按钮元素中。
- en: Now that our view is much better, let's bring back the sorting functionality
    we originally had. Since we do not have table headers anymore we can use some
    buttons to sort based on certain fields that are important.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然我们的视图已经变得更好，让我们恢复我们最初拥有的排序功能。由于我们没有表头了，我们可以使用一些按钮根据某些重要的字段进行排序。
- en: 'Let''s use Bootstrap button group ([https://getbootstrap.com/docs/4.0/components/button-group/](https://getbootstrap.com/docs/4.0/components/button-group/))
    for this. Place the following snippet above the `<div class="list-group">` element
    we created earlier:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Bootstrap 按钮组（[https://getbootstrap.com/docs/4.0/components/button-group/](https://getbootstrap.com/docs/4.0/components/button-group/))
    来实现这个功能。将以下代码片段放置在我们之前创建的 `<div class="list-group">` 元素上方：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can use Bootstrap margin and flexbox utility classes such as `mb-2 d-flex
    justify-content-end align-items-center` to position and align the item properly.
    We use the `btn-group` class on a div element to group our button elements together
    on which we have placed the `jhiSort` directive and its bound properties such
    as `predicate`, `ascending`, and `callback`. On the buttons themselves, we use
    the `jhiSortBy` directive to specify which field it would use to sort. Now our
    page looks as follows, where products are sorted by price:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Bootstrap 外边距和 flexbox 工具类，如 `mb-2 d-flex justify-content-end align-items-center`
    来正确定位和排列项目。我们在一个 div 元素上使用 `btn-group` 类来将按钮元素组合在一起，并在这些按钮上放置了 `jhiSort` 指令及其绑定的属性，如
    `predicate`、`ascending` 和 `callback`。在按钮本身上，我们使用 `jhiSortBy` 指令来指定它将使用哪个字段进行排序。现在我们的页面看起来如下，产品按价格排序：
- en: '![](img/113a2cb2-3da0-485d-a5ac-21d3b37fc3f9.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/113a2cb2-3da0-485d-a5ac-21d3b37fc3f9.png)'
- en: Finally, let's add some good old client-side filtering for the page.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为页面添加一些传统的客户端过滤功能。
- en: JHipster provides an option to enable server-side filtering using JPA metamodel.
    Another option is to enable Elasticsearch, for which JHipster will automatically create
    full-text search fields for every entity. So for any serious filtering requirements,
    you should use these.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 提供了一个选项，可以使用 JPA 元模型启用服务器端过滤。另一个选项是启用 Elasticsearch，对于每个实体，JHipster
    将自动创建全文搜索字段。因此，对于任何严肃的过滤需求，你应该使用这些。
- en: 'First, let''s add a new instance variable called `filter` of type string to
    the `ProductComponent` class in the `product.component.ts` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 `product.component.ts` 文件中的 `ProductComponent` 类中添加一个新的字符串类型实例变量 `filter`：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s use this variable in the `product.component.html` file. Add the
    highlighted snippet from the following code to the `div` we created for the sort-by
    buttons:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `product.component.html` 文件中使用这个变量。将以下代码中的高亮部分添加到我们为排序按钮创建的 `div` 中：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We bound the filter variable to an input element using the `ngModel` directive,
    and using `[()]` ensures two-way binding on the variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ngModel` 指令将过滤变量绑定到一个输入元素上，使用 `[()]` 确保变量的双向绑定。
- en: '`[(ngModel)]="filter"` creates a two-way binding, `[ngModel]="filter"` creates
    a one-way binding from model to view, and `(ngModel)="filter"` creates a one-way
    binding from view to model.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(ngModel)]="filter"` 创建双向绑定，`[ngModel]="filter"` 从模型到视图创建单向绑定，`(ngModel)="filter"`
    从视图到模型创建单向绑定。'
- en: 'Finally, update the `ngFor` directive on our list-group-item element as follows.
    We use a pipe provided by JHipster to filter the list using the name field of
    the product:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将我们的列表项元素上的 `ngFor` 指令更新如下。我们使用 JHipster 提供的管道通过产品的名称字段过滤列表：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That''s it, and we get a shiny filter option on our screen:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们在屏幕上得到了一个闪亮的过滤选项：
- en: '![](img/8753e58a-9256-42b6-a546-6a45f1a157b1.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8753e58a-9256-42b6-a546-6a45f1a157b1.png)'
- en: 'The UX is much better than before but for a real-world use case you could build
    a much better UI for the client-facing website, with features to add items to
    a cart, pay for items online, and so on, and leave this part for the back office
    use. Let''s commit this to `git`: this is very important for managing changes
    to the project later. Run the following commands:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前相比，用户体验有了很大的提升，但在实际应用中，你可以为面向客户的网站构建一个更好的用户界面，包括添加商品到购物车、在线支付等功能，并将这部分留给后台办公使用。让我们将这个更改提交到
    `git`：这对于以后管理项目更改非常重要。运行以下命令：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Editing an entity using the JHipster entity sub-generator
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JHipster 实体子生成器编辑实体
- en: While looking through the generated entity screens, we might realize that there
    are some minor issues that affect the user experience. For example, on the product
    screens we have a relationship to a product category but when choosing the product
    category from the drop-down menu during creation, or when showing the category
    in the list, we show the category by its ID, which is not user-friendly. It would
    be nice if we could show the product category name instead. This is the default
    JHipster behavior but it can be customized while defining the relationships. Let's
    see how we can make our generated screens more user-friendly by editing the JDL
    model. This will overwrite existing files, but since we are using `git` we can
    easily cherry-pick the changes we made, we will see how this is done in a moment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看生成的实体屏幕时，我们可能会意识到一些影响用户体验的小问题。例如，在产品屏幕上，我们有一个与产品类别的关联，但在创建时从下拉菜单中选择产品类别，或者在列表中显示类别时，我们通过其ID显示类别，这对用户来说并不友好。如果我们可以显示产品类别名称，那就更好了。这是JHipster的默认行为，但在定义关系时可以进行自定义。让我们看看如何通过编辑JDL模型来使我们的生成屏幕更加用户友好。这将覆盖现有文件，但由于我们使用`git`，我们可以轻松地选择我们所做的更改，我们将在稍后看到这是如何完成的。
- en: 'In our JDL, we defined relationships between entities using the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JDL中，我们使用以下代码定义了实体之间的关系：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By specifying the field to use for displaying the relationship in JDL using
    the `(<field name>)` syntax as follows, we can change how the client-side code
    displays relationships:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在JDL中使用`(<字段名>)`语法指定用于显示关系的字段，我们可以更改客户端代码显示关系的方式：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s run this using the `import-jdl` command. The command only generates
    entities that underwent changes from the last run. But before we run let''s also
    switch to a new branch, because it''s a good practice to do major changes on a
    separate branch and merge them back so you have more control:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`import-jdl`命令来运行这个操作。该命令仅生成自上次运行以来发生变化的实体。但在运行之前，我们也要切换到一个新的分支，因为将主要更改放在单独的分支上并合并回来是一种良好的实践，这样你可以有更多的控制权：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Read more about Git flow here: [https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多关于Git flow的信息：[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)。
- en: Accept the changes to the files and wait for the build to finish. Now, let's
    look at the entity pages to verify that the display names are used properly and
    create some entities to try it out. Now we realize that the `Invoice` entity has
    empty drop-down menus, and that is because the `Invoice` entity does not have
    a field called **code**. Since we use `{{invoice.order?.code}}` in the template
    the symbol `?` makes Angular skip undefined values preventing errors in rendering.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接受文件更改，等待构建完成。现在，让我们查看实体页面，以验证显示名称是否被正确使用，并创建一些实体来尝试一下。现在我们意识到`Invoice`实体有空的下拉菜单，这是因为`Invoice`实体没有名为**code**的字段。由于我们在模板中使用`{{invoice.order?.code}}`，符号`?`使Angular跳过未定义的值，从而防止渲染错误。
- en: 'This is easy to fix. Sometimes we might want to make a small change to an entity
    after we have created it using JDL and the `import-jdl` command. The best way
    would be to make the change in JDL and regenerate it using the import JDL command
    as we saw in the previous code. Now there is also another option, the entity sub
    generator, which can yield the same result. For the sake of familiarizing yourself
    with this option, let''s use that to add the field to our `Invoice` entity:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易修复。有时我们可能想在创建实体后使用JDL和`import-jdl`命令进行一些小的更改。最好的方法是在JDL中进行更改，并使用导入JDL命令重新生成，就像我们在前面的代码中看到的那样。现在还有一个选项，即实体子生成器，它可以产生相同的结果。为了熟悉这个选项，让我们使用它来向我们的`Invoice`实体添加字段：
- en: 'Run the following command:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From the options select Yes, add more fields and relationships:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从选项中选择“是”，添加更多字段和关系：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Select Yes for the next question and provide the field name, type, and validation
    in the questions that follow:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个问题选择“是”，并提供后续问题中的字段名、类型和验证：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Select n for the prompts that follow to add more fields and relationships. Accept
    the proposed file changes and that's it, we are done.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于后续的提示选择“n”以添加更多字段和关系。接受提议的文件更改，这样就完成了。
- en: Now just make sure to update the JDL so that the entity `Invoice` has `code
    String required` as a field.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请确保更新JDL，使实体`Invoice`具有`code String required`字段。
- en: You could also run `jhipster export-jdl online-store.jh` to export the current
    model back to the JDL.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以运行`jhipster export-jdl online-store.jh`来将当前模型导回到JDL。
- en: 'Now that we have displayed entity relationships properly, we also need to make
    sure certain entities have relationship values mandatory. For example, for customers
    it should be mandatory to have a user, `ProductOrder` should have a customer,
    order item should have an order, Invoice should have an order, and finally, the
    shipment should have an invoice. Since JHipster supports making relationships
    required, we can make these changes using JDL. Update the relationships to the
    following snippet in `online-store.jh`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确显示了实体关系，我们还需要确保某些实体具有必填的关系值。例如，对于客户来说，必须有一个用户，`ProductOrder` 必须有一个客户，订单项必须有一个订单，发票必须有一个订单，最后，运输必须有一个发票。由于
    JHipster 支持使关系成为必填项，我们可以使用 JDL 进行这些更改。在 `online-store.jh` 中更新关系到以下片段：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, run `jhipster import-jdl online-store.jh` and accept the proposed updates.
    Make sure to check what has changed using the `git diff` command or your Git UI
    tool.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行 `jhipster import-jdl online-store.jh` 并接受提出的更新。请确保使用 `git diff` 命令或你的
    Git UI 工具检查更改。
- en: 'Let''s commit this step so that it can be rolled back if required:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提交这一步，以便在需要时可以回滚：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we have a problem, regenerating the entities overwrote all the files and
    that means we lost all the changes we made for the product listing page, but since
    we use `git` it's easy to get it back. So far, our project has only a few commits,
    so it will be easy to cherry-pick the commit we made for the product listing UI
    change and apply it back on top of the current codebase. However, in real-world
    scenarios, there could be a lot of changes before you can regenerate the JDL,
    and so it will require some effort to verify and merge the required changes back.
    Always rely on pull requests so that you can see what has changed and others can
    review and find any issues.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们遇到了问题，重新生成实体覆盖了所有文件，这意味着我们丢失了我们为产品列表页面所做的所有更改，但因为我们使用了 `git`，所以很容易恢复。到目前为止，我们的项目只有几个提交，所以将我们为产品列表
    UI 更改所做的提交 cherry-pick 并应用到当前代码库上将会很容易。然而，在现实世界的场景中，在可以重新生成 JDL 之前可能会有很多更改，因此需要一些努力来验证和合并所需更改。始终依赖拉取请求，这样你就可以看到更改了什么，其他人可以审查并发现任何问题。
- en: Let's cherry-pick the changes that we need.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们 cherry-pick 我们需要的更改。
- en: Refer to the documentation for cherry-picking advanced options at: [https://git-scm.com/docs/git-cherry-pick](https://git-scm.com/docs/git-cherry-pick).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考文档了解如何在[https://git-scm.com/docs/git-cherry-pick](https://git-scm.com/docs/git-cherry-pick)中
    cherry-pick 高级选项。
- en: Since the commit we need is the last one on the master we can simply use `git
    cherry-pick master`. We could also switch to the master and use the `git log`
    command to list the commits, then copy the commit hash of the required commit
    and use that with `git cherry-pick <commit-sha>`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要的是 master 分支上的最后一个提交，我们可以简单地使用 `git cherry-pick master`。我们也可以切换到 master
    分支并使用 `git log` 命令列出提交，然后复制所需提交的提交哈希值，并使用 `git cherry-pick <commit-sha>`。
- en: Now, this results in merge conflicts, as the `product.component.html` file was
    updated in the commit we picked on our current branch tip. We need the incoming
    change from the commit but also need to update the product category display name
    from ID to code, so let's accept the incoming change and make a manual update
    from `{{product.productCategory?.id}}` to `{{product.productCategory?.name}}`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这会导致合并冲突，因为我们当前分支的顶端提交中更新了 `product.component.html` 文件。我们需要从提交中获取传入的更改，但还需要更新产品类别显示名称从
    ID 到代码，所以让我们接受传入的更改，并从 `{{product.productCategory?.id}}` 手动更新到 `{{product.productCategory?.name}}`。
- en: 'Resolve the conflict by staging the file and commit. Now we can merge the branch
    into the master:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过暂存文件并提交来解决冲突。现在我们可以将分支合并到 master：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you are new to Git, it is advisable to use a UI tool such as SourceTree or
    GitKraken to cherry-pick and resolve merge conflicts. IDEs such as IntelliJ and
    editors such as VSCode, also provide good options for these.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始使用 Git，建议使用 SourceTree 或 GitKraken 等界面工具进行 cherry-pick 和解决合并冲突。IntelliJ
    和 VSCode 等 IDE 以及编辑器也提供了良好的选项。
- en: 'Now our page view should be good:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的页面视图应该很好：
- en: '![](img/d0c78f86-2f00-4628-8a7a-2ac64f32fb98.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0c78f86-2f00-4628-8a7a-2ac64f32fb98.png)'
- en: Of course, we could also make it more user-friendly by making the product listing
    our home page. But for now, let's skip that.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以通过将产品列表作为主页来使其更加用户友好。但就目前而言，让我们跳过这个步骤。
- en: Since we were working on the client-side code we didn't pay attention to the
    server-side code that was changed during this. We need to compile the Java code
    to reload our server. Let's run `./gradlew compileJava`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们一直在处理客户端代码，我们没有注意到在此期间服务器端代码的更改。我们需要编译 Java 代码来重新加载我们的服务器。让我们运行 `./gradlew
    compileJava`。
- en: 'Unfortunately, we receive an error during the reload regarding a failure to
    update the database changelogs by Liquibase due to a checksum error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在重新加载过程中，我们遇到了一个错误，由于校验和错误，Liquibase 无法更新数据库变更日志：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is due to the changes made to the original changelog by JHipster. In an
    ideal world, new schema changes should be done in new changelogs so that Liquibase
    can apply them, but JHipster doesn't generate this by default yet. For local development
    using an H2 DB we can run `./gradlew clean` to clear the DB and start the application
    again, but in real use cases you might be using an actual DB, and you would want
    to retain the data, so we would have to handle this manually here using the diff
    features provided by Liquibase.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 JHipster 对原始变更日志所做的更改。在一个理想的世界里，新的架构更改应该在新的变更日志中完成，以便 Liquibase 可以应用它们，但
    JHipster 目前还没有默认生成。对于使用 H2 数据库的本地开发，我们可以运行 `./gradlew clean` 来清除数据库并重新启动应用程序，但在实际使用案例中，你可能会使用实际的数据库，并且希望保留数据，因此我们在这里必须手动使用
    Liquibase 提供的 diff 功能来处理这个问题。
- en: JHipster provides an integration for Liquibase in both Gradle and Maven builds.
    You can make use of it to create new changelogs and to create diff changelogs.
    In cases like these, when we would like to resolve conflicts while retaining data,
    the Liquibase diff feature is our friend. With Gradle, you could run the `./gradlew liquibaseDiffChangeLog`
    command to create a diff changelog of your changesets and the database. You can
    add this changeset to the `src/main/resources/config/liquibase/master.xml` file
    and it will get applied the next time you restart your server. By default, the
    command is configured to run against your development database, if you would like
    to do this against your production database just update the liquibaseCommand command
    definition in the `gradle/liquibase.gradle` file with the details of the production
    DB. Refer to [http://www.jhipster.tech/development/#using-a-database](http://www.jhipster.tech/development/#using-a-database)
    for more.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 在 Gradle 和 Maven 构建中提供了 Liquibase 的集成。你可以利用它来创建新的变更日志和创建 diff 变更日志。在这些情况下，当我们希望保留数据并解决冲突时，Liquibase
    的 diff 功能是我们的好朋友。使用 Gradle，你可以运行 `./gradlew liquibaseDiffChangeLog` 命令来创建更改集和数据库的
    diff 变更日志。你可以将这个更改集添加到 `src/main/resources/config/liquibase/master.xml` 文件中，它将在你下次重新启动服务器时应用。默认情况下，该命令配置为针对开发数据库运行，如果你想针对生产数据库运行，只需更新
    `gradle/liquibase.gradle` 文件中的 liquibaseCommand 命令定义，并包含生产数据库的详细信息。有关更多信息，请参阅
    [http://www.jhipster.tech/development/#using-a-database](http://www.jhipster.tech/development/#using-a-database)。
- en: If you want to clear checksums in your DB, use the `./gradlew liquibaseClearChecksums`
    task.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要清除数据库中的校验和，请使用 `./gradlew liquibaseClearChecksums` 任务。
- en: Changing the look and feel of the application
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变应用程序的外观和感觉
- en: The good thing about using Bootstrap is that it lets us easily change the look
    and feel of the application using any available Bootstrap themes. Let's see how
    we can install a cool theme for our application, then we will also fine tune the
    styles to fit our needs using Sass variables provided by Bootstrap.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Bootstrap 的好处是它让我们能够轻松地使用任何可用的 Bootstrap 主题来改变应用程序的外观和感觉。让我们看看我们如何为我们的应用程序安装一个酷炫的主题，然后我们将使用
    Bootstrap 提供的 Sass 变量来调整样式以适应我们的需求。
- en: There are hundreds of Bootstrap themes out there. Since we are using Bootstrap
    4 it is important to pick a theme that is made for Bootstrap 4.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在市面上有数百种 Bootstrap 主题。由于我们正在使用 Bootstrap 4，因此选择一个为 Bootstrap 4 定制的主题非常重要。
- en: Bootswatch is a nice collection of themes for Bootstrap; check it out to see
    all the available themes at: [https://bootswatch.com/](https://bootswatch.com/).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Bootswatch 是 Bootstrap 主题的精美集合；查看所有可用的主题，请访问：[https://bootswatch.com/](https://bootswatch.com/)。
- en: Let's use a Bootswatch theme called **materia**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个名为 **materia** 的 Bootswatch 主题。
- en: In your terminal, run `yarn add bootswatch` to install all the themes. Don't
    worry; we will only import the theme that we want to use so you do not have to
    worry about installing all themes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中，运行 `yarn add bootswatch` 来安装所有主题。不用担心；我们只会导入我们想要使用的主题，所以你不需要担心安装所有主题。
- en: 'Now let''s import this using Sass. Open `src/main/webapp/content/scss/vendor.scss`
    and find the line `@import ''node_modules/bootstrap/scss/bootstrap'';` and add
    the following code highlighted in bold:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Sass导入这个文件。打开`src/main/webapp/content/scss/vendor.scss`并找到行`@import
    'node_modules/bootstrap/scss/bootstrap';`，然后添加以下加粗的代码：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The name of the theme here is materia, you can use any theme available in Bootswatch
    here. Make sure that name is in all lowercase. Also, notice the order of imports.
    It is important that we import the theme variables after importing Bootstrap variables
    and themes after importing the Bootstrap theme so that SASS variables and styles
    are overridden properly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里主题的名称是materia，你可以在Bootswatch中在这里使用任何可用的主题。确保名称全部是小写。同时，注意导入的顺序。在导入Bootstrap变量和主题之后导入主题变量和样式非常重要，以确保SASS变量和样式被正确覆盖。
- en: We can customize the theme further by overriding Bootstrap variables defined
    in `src/main/webapp/content/scss/_bootstrap-variables.scss`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过覆盖在`src/main/webapp/content/scss/_bootstrap-variables.scss`中定义的Bootstrap变量来进一步自定义主题。
- en: You can override any variable supported by Bootstrap. The full list of supported
    variables can be found in `node_modules/bootstrap/scss/_variables.scss`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以覆盖Bootstrap支持的任何变量。支持的变量完整列表可以在`node_modules/bootstrap/scss/_variables.scss`中找到。
- en: 'For example, let''s change some colors as follows, in `_bootstrap-variables.scss`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们按照以下方式更改一些颜色，在`_bootstrap-variables.scss`中：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There might be some UI glitches when you apply a new theme, you could solve
    them by updating the generated SASS files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用一个新的主题时，可能会有一些UI错误，你可以通过更新生成的SASS文件来解决它们。
- en: 'For example, add the following CSS to `src/main/webapp/content/scss/global.scss`
    to fix the glitch in checkboxes that we got after the theme change:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将以下CSS添加到`src/main/webapp/content/scss/global.scss`中，以修复主题更改后出现的复选框错误：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We now have a cool new theme:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个酷炫的新主题：
- en: '![](img/0982f799-068a-476d-aced-59efc6d5dd2f.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0982f799-068a-476d-aced-59efc6d5dd2f.png)'
- en: Further reference can be found at: [https://getbootstrap.com/docs/4.0/getting-started/theming/.](https://getbootstrap.com/docs/4.0/getting-started/theming/)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 更多参考信息可以在以下链接找到：[https://getbootstrap.com/docs/4.0/getting-started/theming/](https://getbootstrap.com/docs/4.0/getting-started/theming/)
- en: 'Let''s commit this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提交这个更改：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Adding a new i18n language
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的i18n语言
- en: Since we enabled i18n support for our application we can add new i18n languages
    easily, at any time, using the JHipster language generator. Let's add a new language
    to our application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为我们的应用程序启用了i18n支持，我们可以轻松地随时添加新的i18n语言，使用JHipster语言生成器添加一个新的语言到我们的应用程序。
- en: 'In the terminal, switch to a new branch and run the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，切换到一个新的分支并运行以下命令：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will now see a prompt like this, where you can choose any available language
    listed:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在会看到一个类似这样的提示，你可以选择任何可用的语言：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's select French here for now. Accept the file changes proposed and we are
    good to go. Once the application automatically refreshes you can see the new language
    in the language drop-down menu in the application menu. Now, wasn't that easy!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们先选择法语。接受文件更改建议，然后我们就可以继续了。一旦应用程序自动刷新，你可以在应用程序菜单的语言下拉菜单中看到新的语言。现在，这不是很容易吗！
- en: 'Now there is a problem, since we have some entities and we added a new language.
    We will need to get i18n French files for entities as well. We can do this easily
    by running the `jhipster --with-entities` command, which will regenerate the application
    along with entities. Now make sure to carefully stage only changes that you need
    (i18n related JSON files) from the diff and discard the remaining changes. The
    following are the files and folders that need to be staged:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个问题，因为我们有一些实体并且添加了新的语言。我们需要为实体获取i18n法语文件。我们可以通过运行`jhipster --with-entities`命令轻松完成此操作，该命令将重新生成应用程序以及实体。现在请确保仔细地仅从差异中暂存你需要的更改（与i18n相关的JSON文件），并丢弃其余的更改。以下是需要暂存的文件和文件夹：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s commit this and merge it back to the master. If we have picked
    only i18n related changes we shouldn''t have any merge conflicts:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们提交这个更改并将其合并回master分支。如果我们只选择了与i18n相关的更改，那么我们不应该有任何合并冲突：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Authorization with Spring Security
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Security进行授权
- en: As you may have noticed, when it comes to generated code, JHipster doesn't provide
    much in terms of role-based security, authorization management, and so on. This
    is intentional, as these heavily depend on the use case and most often associated
    with the business logic of the application. So, it would be better if this was
    hand-coded by the developers as part of the business code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal users have `ROLE_USER` and admin users have `ROLE_ADMIN` assigned in
    user management. For our use case there are few security holes that we need to
    take care of:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Normal users should only have access to view the product listing, product order,
    order item, invoice, and shipment
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal users should not have access to create/edit/delete entities via the CRUD
    API
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal users should not be able to access the product order, order item, invoice,
    and shipment of other users
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could overcome these issues using features provided by Spring Security.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Limiting access to entities
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's limit the access for normal users. This can be done easily at the
    API level using Spring Security. Add the following snippet to the configure method
    of `src/main/java/com/mycompany/store/config/SecurityConfiguration.java`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Add it right before the line `.antMatchers("/api/**").authenticated()`. The
    position is very important:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We specify that when the request path matches `api/customers` or `api/product-categories`
    the user should have `ROLE_ADMIN` to access them. Now sign out and log in as `user` and
    try to access the customer entity page. Look at the console in your browser's
    development tools and you should see a `403 Forbidden` error for calls made to
    `GET http://localhost:9000/api/customers`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Now that our backend handles this properly let's hide these entries in the menu
    for normal users. Let's add a `*jhiHasAnyAuthority="'ROLE_ADMIN'"` directive to
    the elements for customer and product category in `src/main/webapp/app/layouts/navbar/navbar.component.html`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Now only admin users will see these items on the menu.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Limiting access to create/edit/delete entities
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need to ensure that only admin users can edit entities, normal users
    should only be able to view entities authorized to them. For this, it would be
    better to handle it at the API level using the Spring Security `PreAuthorize` annotation.
    Let''s start with the order item. Go to `src/main/java/com/mycompany/store/web/rest/OrderItemResource.java`
    and add `@PreAuthorize("hasAuthority(''ROLE_ADMIN'')")` to methods `createOrderItem`, `updateOrderItem`,
    and `deleteOrderItem`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are asking Spring Security interceptors to provide access to these methods
    only when the user has `ROLE_ADMIN`.The `PreAuthorize` annotation stops access
    before executing the method. Spring Security also provides `PostAuthorize` and
    more general `Secured` annotations. More about these can be found in the Spring
    Security documentation at: [https://projects.spring.io/spring-security/](https://projects.spring.io/spring-security/).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Compile the backend using `./gradlew compileJava` or using the IDE. Now go to
    the order items page and try to create an order item. You will get an `POST http://localhost:9000/api/order-items
    403 (Forbidden)` error from the API call on the web console. Now let's add the
    annotation to all the entity Resource class create, update, and delete methods.
    You could skip customer and product category entities as they are entirely forbidden
    to the `ROLE_USER` already.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `./gradlew compileJava` 或 IDE 编译后端。现在转到订单项页面，尝试创建一个订单项。你将在网页控制台上的 API 调用中收到一个
    `POST http://localhost:9000/api/order-items 403 (Forbidden)` 错误。现在让我们将注解添加到所有实体
    Resource 类的创建、更新和删除方法中。你可以跳过客户和产品类别实体，因为它们对 `ROLE_USER` 已经完全禁止访问。
- en: Let's also hide the create, edit, and delete buttons from the Angular views
    using the `*jhiHasAnyAuthority="'ROLE_ADMIN'"` directive.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `*jhiHasAnyAuthority="'ROLE_ADMIN'"` 指令从 Angular 视图中隐藏创建、编辑和删除按钮。
- en: Limiting access to data of other users
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制对其他用户数据的访问
- en: Now, this is a little more tricky, as this requires us to change code at the
    service layer on the backend, but it is not hard. Let's get right to it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这一点稍微有点棘手，因为它要求我们在后端的服务层更改代码，但这并不难。让我们直接开始。
- en: 'Let''s start with the product order entity. Let''s modify the `findAll` method
    in `src/main/java/com/mycompany/store/service/ProductOrderService.java` as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从产品订单实体开始。让我们修改 `src/main/java/com/mycompany/store/service/ProductOrderService.java`
    中的 `findAll` 方法，如下所示：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, we modified the original call to `productOrderRepository.findAll(pageable)`
    so that we call it only when the current user has the `Admin` role, else we call `findAllByCustomerUserLogin`,
    but our generated `ProductOrderRepository` interface does not have this method
    yet so let''s add that. In `src/main/java/com/mycompany/store/repository/ProductOrderRepository.java`
    let''s add a new method as follows. Currently, the interface doesn''t have any
    methods and only uses methods inherited from `JpaRepository`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们修改了原始的 `productOrderRepository.findAll(pageable)` 调用，使其仅在当前用户具有 `Admin`
    角色时调用，否则调用 `findAllByCustomerUserLogin`，但我们的生成的 `ProductOrderRepository` 接口还没有这个方法，所以让我们添加它。在
    `src/main/java/com/mycompany/store/repository/ProductOrderRepository.java` 中，让我们添加以下新方法。目前，该接口没有任何方法，只使用从
    `JpaRepository` 继承的方法：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There is a lot of magic going on here. This is a Spring Data interface and
    hence, we can simply write a new method and expect Spring Data to create an implementation
    for this automatically; we just need to follow the naming conventions. In our
    use case, we need to find all product orders where the user relationship for the
    customer has the same login as our current logged in user. In SQL, this would
    be as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里正在进行很多魔法操作。这是一个 Spring Data 接口，因此我们可以简单地编写一个新方法，并期望 Spring Data 自动创建实现；我们只需要遵循命名约定。在我们的用例中，我们需要找到所有用户关系为客户的订单，其登录信息与当前登录用户相同。在
    SQL 中，这将是以下这样：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In simple terms, we could say *find all product orders where* `customer.user.login`
    *equals* `login` and that is exactly what we have written as the `findAllByCustomerUserLogin` method.
    The entity under operation is implicit, hence the product order is omitted. By
    providing the Pageable parameter we tell Spring Data to provide us a page from
    the paginated list of entities. You can refer to the Spring Data docs ([https://docs.spring.io/spring-data/jpa/docs/current/reference/html/](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/))
    for more information.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们可以说 *查找所有产品订单，其中* `customer.user.login` *等于* `login`，这正是我们作为 `findAllByCustomerUserLogin`
    方法所写的。正在操作的实体是隐含的，因此省略了产品订单。通过提供 Pageable 参数，我们告诉 Spring Data 从分页实体列表中提供给我们一个页面。您可以参考
    Spring Data 文档 ([https://docs.spring.io/spring-data/jpa/docs/current/reference/html/](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/))
    获取更多信息。
- en: While calling the `productOrderRepository.findAllByCustomerUserLogin` method
    we can pass the current user login using the `SecurityUtils.getCurrentUserLogin()`
    method. The SecurityUtils class is generated by JHipster as well, as it has useful
    methods such as `getCurrentUserLogin`, `getCurrentUserJWT`, `isAuthenticated`,
    and `isCurrentUserInRole`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `productOrderRepository.findAllByCustomerUserLogin` 方法时，我们可以使用 `SecurityUtils.getCurrentUserLogin()`
    方法传递当前用户登录信息。SecurityUtils 类也是由 JHipster 生成的，它包含一些有用的方法，例如 `getCurrentUserLogin`、`getCurrentUserJWT`、`isAuthenticated`
    和 `isCurrentUserInRole`。
- en: That is it. Now log in as admin and create two new users, create two customers,
    and create product orders for each of them. Then log out and log in again as the
    default user and see if you can see the product order for the newly created user.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。现在以管理员身份登录，创建两个新用户，创建两个客户，并为每个客户创建产品订单。然后注销并再次以默认用户身份登录，看看您是否可以看到新创建用户的产品订单。
- en: 'Now let''s make similar updates for other services. The repository methods
    for those would be as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为其他服务进行类似的更新。这些服务的存储库方法如下：
- en: 'For `src/main/java/com/mycompany/store/repository/InvoiceRepository`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `src/main/java/com/mycompany/store/repository/InvoiceRepository`：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For `src/main/java/com/mycompany/store/repository/OrderItemRepository`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `src/main/java/com/mycompany/store/repository/OrderItemRepository`：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For `src/main/java/com/mycompany/store/repository/ShipmentRepository`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `src/main/java/com/mycompany/store/repository/ShipmentRepository`：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we need to make similar changes for `findOne` methods on the services.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对服务上的 `findOne` 方法进行类似的更改。
- en: 'For the `ProductOrderService` it would be as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ProductOrderService`，如下所示：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, we changed the methods to find one by ID and customer user
    login. The repository method for the same would be as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将查找一个通过ID和客户用户登录的方法进行了更改。相同的存储库方法如下：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For `src/main/java/com/mycompany/store/repository/InvoiceRepository`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `src/main/java/com/mycompany/store/repository/InvoiceRepository`：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For `src/main/java/com/mycompany/store/repository/OrderItemRepository`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `src/main/java/com/mycompany/store/repository/OrderItemRepository`：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For `src/main/java/com/mycompany/store/repository/ShipmentRepository`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `src/main/java/com/mycompany/store/repository/ShipmentRepository`：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The same queries can be written using the `@Query` annotation provided by Spring
    Data as well.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的查询可以使用Spring Data提供的 `@Query` 注解来编写。
- en: That's it. We have implemented a good role-based authorization logic for the
    application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。我们已经为应用程序实现了良好的基于角色的授权逻辑。
- en: 'Let''s commit this checkpoint:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提交这个检查点：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In a real-world scenario, the changes we have made so far are not enough for
    an e-commerce website. But since our aim is to learn JHipster and its supported
    tools rather than to create a feature perfect application, consider this a minimum
    viable product. To make this e-commerce application usable, we would need to build
    more features, such as a shopping cart, invoice generation, customer registration,
    and so on. Why don't you take it up as an assignment and see if you can build
    more features for this application? This would be part of the next steps to take
    once you finish the book. The use case and instructions will be detailed in [Chapter
    14](7a7b29a3-0ff7-4d86-be16-2c4b88d3a16a.xhtml), *Best Practices with JHipster*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，我们迄今为止所做的更改对于电子商务网站来说还不够。但鉴于我们的目标是学习JHipster及其支持的工具，而不是创建一个功能完美的应用程序，请将此视为一个最小可行产品。为了使这个电子商务应用程序可用，我们需要构建更多功能，例如购物车、发票生成、客户注册等。为什么不把它作为一个作业来尝试，看看您是否可以为这个应用程序构建更多功能？这将是您完成本书后的下一步行动的一部分。用例和说明将在第14章中详细说明，*JHipster的最佳实践*。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how we can easily customize a web application created
    using JHipster. We also learned about Angular and Bootstrap when we customized
    our Product listing page. In addition to this, we saw how to secure our application
    with role-based authorization using Spring Security. We also learned about Spring
    Data and used Git to manage our source code properly. We saw our application evolving
    with business logic and becoming more user-friendly. In the next chapter, we will
    see how we can integrate continuous integration with our application using Jenkins.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何轻松定制使用JHipster创建的Web应用程序。我们还学习了在定制我们的产品列表页面时关于Angular和Bootstrap的知识。除此之外，我们还看到了如何使用Spring
    Security通过基于角色的授权来保护我们的应用程序。我们还学习了Spring Data，并使用Git来正确管理我们的源代码。我们看到了我们的应用程序随着业务逻辑的发展而变得更加用户友好。在下一章中，我们将看到如何使用Jenkins将持续集成集成到我们的应用程序中。
