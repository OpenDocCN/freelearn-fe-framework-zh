["```js\n    npm install msw --save-dev\n    ```", "```js\n    yarn add msw --dev\n    ```", "```js\n    pnpm add msw --save-dev\n    ```", "```js\nimport { rest } from \"msw\";\nexport const handlers = [\n  rest.get(\"*/api/*\", (req, res, ctx) => {\n    return res(\n      ctx.status(200),\n      ctx.json({\n        data: \"value\"\n      })\n    );\n  }),\n];\n```", "```js\nimport { setupServer } from \"msw/node\";\nimport { handlers } from \"./handlers\";\nexport const server = setupServer(...handlers);\n```", "```js\nimport { server } from \"./mocks/server.js\";\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n```", "```js\nimport axios from \"axios\";\nexport const axiosInstance = axios.create({\n  baseURL: \"https://danieljcafonso.builtwithdark.com\",\n});\nexport const getUser = async (username, signal) => {\n  const { data } = await axiosInstance.get\n    (`/react-query-api/${username}`, {\n    signal,\n  });\n  return data;\n};\nexport const createUser = async (user) => {\n  return axiosInstance.post(`/name-api`, user);\n};\n```", "```js\nexport const userKeys = {\n    all: () => [\"allUsers\"],\n    api: () => [{queryIdentifier: \"api\"}],\n    withUsername: (username = \"username\") =>\n      [{ ...userKeys.api[0], username }],\n    paginated: (page) => [{ ...userKeys.api, page }]\n}\n```", "```js\nimport { useMutation, useQueryClient } from\n  \"@tanstack/react-query\";\nimport { userKeys } from \"../utils/queryKeyFactories\";\nimport { createUser } from \"../api/userAPI\";\nconst useOptimisticUpdateUserCreation = () => {\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: createUser,\n    retry: 0,\n    onSettled: () => queryClient.invalidateQueries\n      (userKeys.all()),\n    onMutate: async (user) => {\n      await queryClient.cancelQueries(userKeys.all());\n      const previousUsers = queryClient.getQueryData\n        (userKeys.all());\n      queryClient.setQueryData(userKeys.all(), (prevData)\n        => [\n        user,\n        ...prevData,\n      ]);\n      return { previousUsers };\n    },\n    onError: (error, user, context) => {\n      queryClient.setQueryData(userKeys.all(),\n        context.previousUsers);\n    },\n  });\n};\nexport default useOptimisticUpdateUserCreation;\n```", "```js\nconst mutation = useOptimisticUpdateUserCreation();\n```", "```js\nimport { render } from \"@testing-library/react\";\nimport { QueryClient, QueryClientProvider } from\n  \"@tanstack/react-query\";\nconst customRender = (ui, { ...options } = {}) => {\n  const queryClient = new QueryClient({\n    logger: {\n      log: console.log,\n      warn: console.warn,\n      error: () => {},\n    },\n    defaultOptions: {\n      queries: {\n        retry: 0,\n        cacheTime: Infinity,\n      },\n    },\n  });\n  const CombinedProviders = ({ children }) => {\n    return (\n      <QueryClientProvider client={queryClient}>\n        {children}</QueryClientProvider>\n    );\n  };\n  return render(ui, { wrapper: CombinedProviders,\n     ...options });\n};\nexport * from \"@testing-library/react\";\nexport { customRender as render };\n```", "```js\nexport const ParallelQueries = () => {\n  const { multipleQueries } = useMultipleQueriesV2();\n  return (\n    <div>\n      {multipleQueries.map(({ data, isFetching }, index) => (\n        <p key={index}>{isFetching ? \"Fetching data...\" :\n          data.hello}</p>\n      ))}\n    </div>\n  );\n};\n```", "```js\nimport { useQueries } from \"@tanstack/react-query\";\nimport { userKeys } from \"../utils/queryKeyFactories\";\nimport { getUser } from \"../api/userAPI\";\nconst fetchData = async ({ queryKey }) => {\n  const { username } = queryKey[0];\n  return await getUser(username);\n};\nconst usernameList = [\"userOne\", \"userTwo\", \"userThree\"];\nconst useMultipleQueriesV2 = () => {\n  const multipleQueries = useQueries({\n    queries: usernameList.map((username) => {\n      return {\n        queryKey: userKeys.withUsername(username),\n        queryFn: fetchData,\n      };\n    }),\n  });\n  return { multipleQueries }\n};\nexport default useMultipleQueriesV2\n```", "```js\nexport const getUser = async (username, signal) => {\n  const { data } = await axiosInstance.get\n    (`/react-query-api/${username}`, {\n    signal,\n  });\n  return data;\n};\n```", "```js\n  rest.get(\"*/react-query-api/*\", (req, res, ctx) => {\n    return res(\n      ctx.delay(500),\n      ctx.status(200),\n      ctx.json({\n        hello: req.params[1],\n      })\n    );\n  })\n```", "```js\n{\n  hello: \"Hello userOne\"\n}\n```", "```js\nimport { ParallelQueries } from \"../MultipleQueries\";\nimport { render, screen } from \"../utils/test-utils\";\ndescribe(\"Parallel Queries Tests\", () => {\n  test(\"component should fetch and render multiple data\",\n    async () => {\n    render(<ParallelQueries />);\n    const text = await screen.findByText(\"userOne\");\n    expect(text).toBeInTheDocument();\n    expect(screen.getByText(\"userTwo\")).toBeInTheDocument();\n    expect(screen.getByText(\"userThree\")).toBeInTheDocument();\n  });\n  test(\"component should show loading indicator for each\n    query\", () => {\n    render(<ParallelQueries />);\n    const isFetching = screen.getAllByText(\"Fetching data...\");\n    expect(isFetching).toHaveLength(3);\n  });\n});\n```", "```js\nconst fetchData = async ({ queryKey}) => {\n  const { username } = queryKey[0];\n  return await getUser(username);\n};\nconst QueryInvalidation = () => {\n  const { data, isFetching } = useQuery({\n    queryKey: userKeys.withUsername(\"userOne\"),\n    queryFn: fetchData,\n  });\n  const queryClient = useQueryClient();\n  return (\n    <div>\n      <p>{isFetching ? \"Loading...\" : data?.hello}</p>\n      <button onClick={() => queryClient.invalidateQueries\n        (userKeys.api())}>\n        Invalidate Query\n      </button>\n    </div>\n  );\n};\n```", "```js\nimport { QueryInvalidation } from \"../QueryClientExamples\";\nimport { fireEvent, render, screen, waitFor } from \"../utils/test-utils\";\ndescribe(\"QueryInvalidation Tests\", () => {\n  test(\"component should display fetched data\", async () => {\n    render(<QueryInvalidation />);\n    const text = await screen.findByText(\"userOne\");\n    expect(text).toBeInTheDocument();\n  });\n  test(\"component should show a loading indicator\", () => {\n    render(<QueryInvalidation />);\n    expect(screen.getByText(\"Loading...\")).toBeInTheDocument();\n  });\n  test(\"component should invalidate query\", async () => {\n    render(<QueryInvalidation />);\n    const text = await screen.findByText(\"userOne\");\n    expect(text).toBeInTheDocument();\n    const invalidateButton = screen.getByRole(\"button\", {\n      text: \"Invalidate Query\",\n    });\n    fireEvent.click(invalidateButton);\n    await waitFor(() =>\n      expect(screen.queryByText(\"userOne\")).not.\n        toBeInTheDocument()\n    );\n    await waitFor(() =>\n      expect(screen.queryByText(\"Loading\"…\")).not.\n        toBeInTheDocument()\n    );\n    expect(screen.getByText(\"userOne\")).\n      toBeInTheDocument();\n  });\n});\n```", "```js\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useState } from \"react\";\nimport { getPaginatedData } from \"./api/userAPI\";\nimport { userKeys } from \"./utils/queryKeyFactories\";\nconst fetchData = async ({ queryKey }) => {\n  const { page } = queryKey[0];\n  return await getPaginatedData(page);\n};\nconst PaginatedQuery = () => {\n  const [page, setPage] = useState(0);\n  const { isLoading, isError, error, data, isFetching,\n    isPreviousData } =\n    useQuery({\n      queryKey: userKeys.paginated(page),\n      queryFn: fetchData,\n      keepPreviousData: true,\n    });\n  if (isLoading) {\n    return <h2>Loading initial data...</h2>;\n  }\n  if (isError) {\n    return <h2>{error.message}</h2>;\n  }\n  return (\n    <>\n      <div>\n        {data.results.map((user) => (\n          <div key={user.email}>\n            {user.name.first}\n            {user.name.last}\n          </div>\n        ))}\n      </div>\n      <div>\n        <button\n          onClick={() => setPage((oldValue) =>\n            Math.max(oldValue - 1, 0))}\n          disabled={page === 0}\n        >\n          Previous Page\n        </button>\n        <button\n          disabled={isPreviousData}\n          onClick={() => setPage((old) => old + 1)}\n        >\n          Next Page\n        </button>\n      </div>\n      {isFetching ? <span> Loading...</span> : null}\n    </>\n  );\n};\nexport default PaginatedQuery;\n```", "```js\nexport const getPaginatedData = async (page) => {\n  const { data } = await axiosInstance.get(\n    `/react-query-paginated?page=${page}&results=10`\n  );\n  return data;\n};\n```", "```js\nrest.get(\"*/react-query-paginated\", (req, res, ctx) => {\n    const page = req.url.searchParams.get(\"page\");\n    const pageOneData = {\n      email: \"email1\",\n      name: {\n        first: \"first1\",\n        last: \"last1\",\n      },\n    };\n    const pageTwoData = {\n      email: \"email2\",\n      name: {\n        first: \"first2\",\n        last: \"last2\",\n      },\n    };\n    const data = {\n      results: [page > 0 ? pageTwoData : pageOneData],\n    };\n    return res(ctx.status(200), ctx.json(data));\n  })\n```", "```js\nimport PaginatedQuery from \"../PaginatedQuery\";\nimport { render, screen } from \"../utils/test-utils\";\nimport userEvent from \"@testing-library/user-event\";\nimport { server } from \"../mocks/server\";\nimport { rest } from \"msw\";\ndescribe(\"PaginatedQuery tests\", () => {\n  test(\"should render loading indicator on start\", () => {\n    render(<PaginatedQuery />);\n    expect(screen.getByText(\"Loading initial data...\")).\n      toBeInTheDocument();\n  });\n  test(\"should render error on failed fetching\", async () => {\n    server.use(rest.get(\"*\", (req, res, ctx) =>\n      res(ctx.status(403))));\n    render(<PaginatedQuery />);\n    expect(\n      await screen.findByText(\"Request failed with status\n        code 403\")\n    ).toBeInTheDocument();\n  });\n  test(\"should render first page data\", async () => {\n    render(<PaginatedQuery />);\n    const firstName = await screen.findByText(/first1/i);\n    expect(firstName).toBeInTheDocument();\n    expect(screen.getByText(/last1/i)).toBeInTheDocument();\n  });\n  test(\"should render second page data\", async () => {\n    render(<PaginatedQuery />);\n    const firstName = await screen.findByText(/first1/i);\n    expect(firstName).toBeInTheDocument();\n    const nextPageButton = screen.getByRole(\"button\", {\n      name: \"Next Page\" });\n    userEvent.click(nextPageButton);\n    const secondPageFirstName = await screen.findByText\n      (/first2/i);\n    expect(secondPageFirstName).toBeInTheDocument();\n    expect(screen.getByText(/last2/i)).toBeInTheDocument();\n  });\n  test(\"should show fetching indicator while fetching\n    data\", async () => {\n    render(<PaginatedQuery />);\n    const firstName = await screen.findByText(/first1/i);\n    expect(firstName).toBeInTheDocument();\n    const nextPageButton = screen.getByRole(\"button\", {\n      name: \"Next Page\" });\n    userEvent.click(nextPageButton);\n    expect(screen.getByText(\"Loading...\")).\n      toBeInTheDocument();\n  });\n  test(\"should change pages back and forth and render\n    expected data\", async () => {\n    render(<PaginatedQuery />);\n    expect(await screen.findByText(/first1/i)).\n      toBeInTheDocument();\n    expect(screen.getByText(/last1/i)).toBeInTheDocument();\n    const nextPageButton = screen.getByRole(\"button\", {\n      name: \"Next Page\" });\n    userEvent.click(nextPageButton);\n    expect(await screen.findByText(/first2/i)).\n      toBeInTheDocument();\n    expect(screen.getByText(/last2/i)).toBeInTheDocument();\n    const previousPageButton = screen.getByRole(\"button\", {\n      name: \"Previous Page\",\n    });\n    userEvent.click(previousPageButton);\n    expect(await screen.findByText(/first1/i)).\n      toBeInTheDocument();\n    expect(screen.getByText(/last1/i)).toBeInTheDocument();\n  });\n  test(\"should have previous page button disabled on first\n    page\", async () => {\n    render(<PaginatedQuery />);\n    const previousPageButton = await screen.findByRole\n      (\"button\", {\n      name: \"Previous Page\",\n    });\n    expect(previousPageButton).toBeDisabled();\n  });\n  test(\"should have next page button disabled while\n    changing pages\", async () => {\n    render(<PaginatedQuery />);\n    const nextPageButton = await screen.findByRole\n      (\"button\", {\n      name: \"Next Page\",\n    });\n    userEvent.click(nextPageButton);\n    expect(nextPageButton).toBeDisabled();\n  });\n});\n```", "```js\n            export const SimpleMutation = () => {\n              const [name, setName] = useState(\"\");\n              const { mutate, isPaused } = useMutation({\n                mutationFn: createUser,\n              });\n              const submitForm = (e) => {\n                e.preventDefault();\n                mutate({ name, age: 0 });\n              };\n              return (\n                <div>\n                  {isPaused && <p> Waiting for network to come back </p>}\n                  <form>\n                    <input\n                      name=\"name\"\n                      type={\"text\"}\n                      onChange={(e) => setName(e.target.value)}\n                      value={name}\n                    />\n                    <button disabled={isPaused} onClick={submitForm}>\n                      Add\n                    </button>\n                  </form>\n                </div>\n              );\n            };\n            ```", "```js\n            rest.post(\"*/name-api/*\", (req, res, ctx) => {\n                return res(\n                  ctx.status(201),\n                  ctx.json({\n                    hello: \"user\",\n                  })\n                );\n              })\n            ```", "```js\n            import { axiosInstance } from \"../api/userAPI\";\n            import { SimpleMutation } from \"../Mutation\";\n            import { render, screen, waitFor } from\n              \"../utils/test-utils\";\n            import userEvent from \"@testing-library/user-event\";\n            const postSpy = jest.spyOn(axiosInstance, \"post\");\n            describe(\"SimpleMutation Tests\", () => {\n              test(\"data should be sent to the server\", async () => {\n                const name = \"Daniel\";\n                render(<SimpleMutation />);\n                const input = screen.getByRole(\"textbox\");\n                userEvent.type(input, name);\n                userEvent.click(\n                  screen.getByRole(\"button\", {\n                    name: /add/i,\n                  })\n                );\n                await waitFor(() =>\n                  expect(postSpy.mock.calls[0][1]).toEqual\n                    ({ name, age: 0 })\n                );\n              });\n              test(\"on no network should display paused information\", async () => {\n                jest.spyOn(navigator, \"onLine\", \"get\").mockReturnValue\n                  (false);\n                render(<SimpleMutation />);\n                userEvent.click(\n                  screen.getByRole(\"button\", {\n                    name: /add/i,\n                  })\n                );\n                const text = await screen.findByText(\"Waiting for\n                  network to come back\");\n                expect(text).toBeInTheDocument();\n              });\n            });\n            ```", "```js\n                npm install @testing-library/react-hooks react-test-renderer --save-dev\n                ```", "```js\n                yarn add @testing-library/react-hooks react-test-renderer --dev\n                ```", "```js\n                pnpm add @testing-library/react-hooks react-test-renderer --save-dev\n                ```", "```js\n            import { useMutation, useQueryClient } from\n              \"@tanstack/react-query\";\n            import { userKeys } from \"../../utils/queryKeyFactories\";\n            import { createUser } from \"../../api/userAPI\";\n            const useOptimisticUpdateUserCreation = () => {\n              const queryClient = useQueryClient();\n              return useMutation({\n                mutationFn: createUser,\n                retry: 0,\n                onSettled: () => queryClient.invalidateQueries\n                  (userKeys.all()),\n                onMutate: async (user) => {\n                  await queryClient.cancelQueries(userKeys.all());\n                  const previousUsers = queryClient.getQueryData\n                    (userKeys.all());\n                  queryClient.setQueryData(userKeys.all(), (prevData) => [\n                    user,\n                    ...prevData,\n                  ]);\n                  return { previousUsers };\n                },\n                onError: (error, user, context) => {\n                  queryClient.setQueryData(userKeys.all(),\n                    context.previousUsers);\n                },\n              });\n            };\n            export default useOptimisticUpdateUserCreation;\n            ```", "```js\n            import useOptimisticUpdateUserCreation from\n              \"../useOptimisticUpdateUserCreation\";\n            import { QueryClient, QueryClientProvider } from\n              \"@tanstack/react-query\";\n            import { renderHook } from \"@testing-library/react-hooks\";\n            import { userKeys } from \"../../../utils/\n              queryKeyFactories\";\n            import { server } from \"../../../mocks/server\";\n            import { rest } from \"msw\";\n            const queryClient = new QueryClient({\n              logger: {\n                log: console.log,\n                warn: console.warn,\n                error: jest.fn(),\n              },\n            });\n            const wrapper = ({ children }) => (\n              <QueryClientProvider client={queryClient}>{children}\n                </QueryClientProvider>\n            );\n            describe(\"useOptimisticUpdateUserCreation\", () => {\n              test(\"should perform optimistic update\", async () => {\n                queryClient.setQueryData(userKeys.all(), []);\n                const name = \"user\";\n                const age = 20;\n                const { result, waitFor } = renderHook(\n                  () => useOptimisticUpdateUserCreation(),\n                  {\n                    wrapper,\n                  }\n                );\n                result.current.mutate({ name, age });\n                await waitFor(() =>\n                  expect(queryClient.getQueryData(userKeys.all())).\n                    toEqual([{ name, age }])\n                );\n              });\n              test(\"should revert optimistic update\", async () => {\n                queryClient.setQueryData(userKeys.all(), []);\n                server.use(rest.post(\"*\", (req, res, ctx) =>\n                  res(ctx.status(403))));\n                const name = \"user\";\n                const age = 20;\n                const { result, waitFor } = renderHook(() =>\n                  useOptimisticUpdateUserCreation(), {\n                  wrapper,\n                });\n                result.current.mutate({ name, age });\n                await waitFor(() => expect(result.current.isError).\n                  toBe(true));\n                await waitFor(() =>\n                  expect(queryClient.getQueryData(userKeys.all())).\n                    toEqual([])\n                );\n              });\n              test(\"should invalidate query on settled\", async () => {\n                queryClient.setQueryData(userKeys.all(), []);\n                const invalidateQueriesSpy = jest.spyOn(queryClient,\n                  \"invalidateQueries\");\n                const name = \"user\";\n                const age = 20;\n                const { result, waitFor } = renderHook(\n                  () => useOptimisticUpdateUserCreation(),\n                  {\n                    wrapper,\n                  }\n                );\n                result.current.mutate({ name, age });\n                await waitFor(() => expect(result.current.isSuccess).\n                  toBe(true));\n                expect(invalidateQueriesSpy).toHaveBeenCalledWith\n                  (userKeys.all());\n              });\n            });\n            ```", "```js\n            import useMultipleQueriesV2 from \"../useMultipleQueriesV2\";\n            import { QueryClient, QueryClientProvider } from\n              \"@tanstack/react-query\";\n            import { renderHook } from \"@testing-library/react-hooks\";\n            const queryClient = new QueryClient();\n            const wrapper = ({ children }) => (\n              <QueryClientProvider client={queryClient}>{children}\n                </QueryClientProvider>\n            );\n            describe(\"useMultipleQueriesV2\", () => {\n              test(\"should fetch all data\", async () => {\n                const { result, waitFor } = renderHook(() =>\n                  useMultipleQueriesV2(), {\n                  wrapper,\n                });\n                await waitFor(() =>\n                  expect(result.current.multipleQueries[0].data.hello).\n                    toBeDefined()\n                );\n                expect(result.current.multipleQueries[0].data.hello).\n                  toBe(\"userOne\");\n                expect(result.current.multipleQueries[1].data.hello).\n                  toBe(\"userTwo\");\n                expect(result.current.multipleQueries[2].data.hello).\n                  toBe(\"userThree\");\n              });\n            });\n            ```"]