- en: Chapter 3. Working with Properties
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 使用属性
- en: 'In this chapter, we will be exploring how to work with ReactJS properties.
    We''re also going to learn how to integrate ReactJS with an external API (Facebook
    Open-Graph API) and render incoming data in a set of components. This chapter
    will cover the following items:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用 ReactJS 属性。我们还将学习如何将 ReactJS 与外部 API（Facebook Open-Graph API）集成，并在一组组件中渲染传入的数据。本章将涵盖以下内容：
- en: Component properties
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件属性
- en: Component's data flow
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的数据流
- en: Configuring and consuming Facebook Open-Graph API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和消费 Facebook Open-Graph API
- en: Creating a ReactJS component and list data from API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 ReactJS 组件并从 API 列出数据
- en: Component properties
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件属性
- en: In the [Chapter 2](part0020_split_000.html#page "Chapter 2. Exploring JSX and
    the ReactJS Anatomy"), *Exploring JSX and ReactJS Anatomy*, we talked a lot about
    ReactJS properties and used them throughout our examples, but so far, we've just
    used them like HTML properties. They play a role that is far beyond that. It's
    common to use them to pass data through your components tree that defines your
    view; to pass configuration properties that come from parent components; to pass
    callbacks for user input, UI/custom events that need to be triggered outside,
    and so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0020_split_000.html#page "第2章. 探索 JSX 和 ReactJS 结构")中，*探索 JSX 和 ReactJS
    结构*，我们讨论了很多关于 ReactJS 属性的内容，并在我们的示例中使用了它们，但到目前为止，我们只是像使用 HTML 属性一样使用它们。它们的作用远不止于此。通常，我们会使用它们在组件树中传递数据，以定义视图；传递来自父组件的配置属性；传递用户输入的回调，以及需要在外部触发的
    UI/自定义事件等。
- en: Properties of a ReactJS component can't be changed once the component is rendered
    in the DOM.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS 组件的属性一旦在 DOM 中渲染，就不能更改。
- en: Properties define the declarative interface of the component. In a `h1` element
    that renders a name property, for example, you can't change this name once it's
    rendered, unless you create another instance of the component and render it in
    the same place in the DOM, replacing the old rendered component.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 属性定义了组件的声明式接口。例如，在一个渲染名称属性的 `h1` 元素中，一旦渲染，你无法更改此名称，除非你创建另一个组件实例并在 DOM 的同一位置重新渲染，以替换旧的渲染组件。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This happens because ReactJS represents the state of your component at any
    point in time and not only at initialization. Consider the following example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 ReactJS 代表了组件在任何时间点的状态，而不仅仅是初始化时。考虑以下示例：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The input text being rendered is considered to be a controlled component because
    it won't change the value even if you try typing on it. If we don't specify the
    `valu`e property of the input then it is considered to be an uncontrolled component.
    Controlled components have their data updated via the ReactJS data flow and component
    cycle. However, if you did not specify the value property, the value property
    would not be controlled by ReactJS and would exist externally to the ReactJS data
    flow. The correct way to change the value from forms inputs or other components
    is to set up `state` for them, which will be described in more detail in the next
    chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正在渲染的输入文本被视为受控组件，因为它即使在尝试键入时也不会更改值。如果我们没有指定 `value` 属性，则被视为非受控组件。受控组件通过 ReactJS
    数据流和组件周期来更新其数据。然而，如果你没有指定值属性，值属性将不由 ReactJS 控制，并且存在于 ReactJS 数据流之外。从表单输入或其他组件更改值的正确方法是设置它们的
    `state`，这将在下一章中更详细地描述。
- en: Data flow with properties
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性的数据流
- en: One of the ReactJS fundamentals and best practices is to pass data to nested
    components through properties. In that way, the children components can have the
    single responsibility of rendering only what they have to render and pass the
    job to further components, thus ensuring the separation of concerns. It's also
    used for configuring nested components so that the ones at the top of the hierarchy
    can say what particular aspects the children components should have, just by passing
    properties. It's also common to define functions on parent nodes and pass them
    to children as a callback to be triggered whenever the child component wants,
    improving the component reusability and testability.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS 的一个基本原理和最佳实践是通过属性将数据传递给嵌套组件。这样，子组件只需负责渲染它们必须渲染的内容，并将任务传递给更进一步的组件，从而确保关注点的分离。这也用于配置嵌套组件，以便层次结构顶部的组件可以通过传递属性来指定子组件应具有的特定方面。这还常见于在父节点上定义函数并将它们作为回调传递给子节点，以便在子组件需要时触发，从而提高组件的可重用性和可测试性。
- en: 'Let''s demonstrate a small example simulating a static to-do list. The list
    is split into small components that render only the necessary and pass properties
    down to children components, defining the whole functionality of the view. This
    is what it is going to render at the end:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个小示例来模拟一个静态待办事项列表。列表被拆分成小的组件，这些组件只渲染必要的部分并将属性传递给子组件，从而定义整个视图的功能。这就是最终将要渲染的内容：
- en: '![Data flow with properties](img/00005.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![带有属性的流程图](img/00005.jpeg)'
- en: 'We''re going to break our view into smaller components and will start doing
    it from the innermost one to the topmost one. Before we start, let''s discuss
    a little more about each component and its role in view:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的视图拆分成更小的组件，并从最内层的组件开始。在我们开始之前，让我们更详细地讨论每个组件及其在视图中的作用：
- en: '`TaskList` – This component represents a list (the `ul` element) that accepts
    an array of tasks to be rendered. It iterates through the tasks array creating
    a `TaskItem` component. Along with passing the task details through a property,
    to be rendered in the `TaskItem` component, it also passes some function callbacks
    that, for now, will just fake some operations to simplify the demonstration.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskList` – 这个组件代表一个列表（`ul` 元素），它接受一个要渲染的任务数组。它遍历任务数组，创建一个 `TaskItem` 组件。除了通过属性传递任务详情以在
    `TaskItem` 组件中渲染外，它还传递了一些函数回调，目前这些回调将只是模拟一些操作以简化演示。'
- en: '`TaskItem` – This component represent a single task (the `li` element) that
    renders the task name, an input checkbox representing whether the task is completed,
    and a button to remove the task. Again, the input and the button will just log
    some text to simplify the demonstration.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskItem` – 这个组件代表一个单独的任务（`li` 元素），它渲染任务名称、一个表示任务是否完成的输入复选框以及一个删除任务的按钮。同样，输入和按钮将只记录一些文本以简化演示。'
- en: 'The `TaskItem` component should look like this:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TaskItem` 组件应该看起来像这样：'
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `TaskList` component should be as follows:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TaskList` 组件应该如下所示：'
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The task list has a bit more functionality and code. It takes care of rendering
    the list of tasks and handles operations on it. This is a very common pattern
    in ReactJS, to maintain the control of your model objects in a single place that
    is, of course, if it's responsibility for doing so. In a more complicated scenario,
    you would have some "controllers" or "containers" (as they like to call them in
    the ReactJS community), each one having its own task and encapsulating what they
    are responsible for. Thus, all of the containers are having their own responsibility
    and not interfering with each other.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 任务列表有更多的功能和代码。它负责渲染任务列表并处理其上的操作。这是 ReactJS 中一个非常常见的模式，即在单一位置维护你的模型对象的控制权，当然，如果它有责任这样做的话。在更复杂的场景中，你会有一些“控制器”或“容器”（ReactJS
    社区喜欢这样称呼它们），每个容器都有自己的任务并封装它们负责的内容。因此，所有的容器都有自己的责任，不会相互干扰。
- en: 'There is just one missing part in our static task list example, which is to
    render the component in an HTML element:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的静态任务列表示例中，只有一个缺失的部分，那就是在 HTML 元素中渲染组件：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We're passing some static tasks to the list to explain how properties work and
    some practices on how to use them. We think that small examples as to-do/tasks/hello-worlds
    don't represent the real-world problems that we face day by day; although they
    are great for starting to learn a tool functionality, they fail when you try to
    make more reasonable examples that have asynchronous operations, deal with outside
    APIs, authentication, and so on. For that reason, the following topics will cover
    how to set up our real scenario applications using Facebook API (also known as
    Open-Graph API), logins into Facebook, and lists that a logged-in user likes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向列表传递了一些静态任务来解释属性的工作原理以及一些使用它们的实践。我们认为像待办事项、任务或 hello-world 这样的简单示例并不能代表我们每天面对的真实世界问题；尽管它们对于开始学习工具功能来说很棒，但当尝试制作更合理的示例时，例如具有异步操作、处理外部
    API、身份验证等，它们就失败了。因此，以下主题将涵盖如何使用 Facebook API（也称为 Open-Graph API）设置我们的真实场景应用程序，包括
    Facebook 登录以及登录用户喜欢的列表。
- en: Configuring Facebook Open-Graph API
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Facebook Open-Graph API
- en: In the following sections, we're going to learn more about Facebook Open-Graph
    API and configure it so we can start crafting some code to build our awesome application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习更多关于 Facebook Open-Graph API 的知识，并对其进行配置，以便我们可以开始编写代码来构建我们出色的应用程序。
- en: What it is and how to configure it
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是什么以及如何配置
- en: '**Facebook Open-Graph API** is a service for getting, editing, and adding common
    Facebook resources. Some of its functionalities that you can use in your own application
    are: login; request user-specific resource permissions such as manage events,
    post to friends walls, and the list goes on. It has a bunch of functionalities
    that you can use and integrate your app with. One of the main functionalities
    used by third-party applications is, of course, the login integration. You can
    use it just as a login platform, for instance, if you don''t want or don''t have
    time to build one.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Facebook Open-Graph API** 是一个用于获取、编辑和添加常见 Facebook 资源的服务。您可以在自己的应用程序中使用的一些功能包括：登录；请求特定于用户的资源权限，如管理事件、在朋友墙上发布，等等。它有一系列您可以使用并集成到应用程序中的功能。第三方应用程序使用的主要功能之一当然是登录集成。您可以用它作为一个登录平台，例如，如果您不想或没有时间构建一个。'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The API documentation is provided at [https://developers.facebook.com/](https://developers.facebook.com/)
    and it's recommended that you check this out.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: API 文档可在 [https://developers.facebook.com/](https://developers.facebook.com/)
    查找，建议您查看。
- en: 'If you want to test some requests to their API, without having to start developing
    an application from scratch, you can use a very useful tool called *Graph API
    Explorer*. It''s commonly used for testing out an endpoint before developing it
    or just checking how the response JSON result is returned. Graph API Explorer
    can be found at the **Tools & Support** menu item at the top header. This is what
    the tool looks like:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试一些对他们的 API 的请求，而不必从头开始开发应用程序，您可以使用一个非常有用的工具，称为 *Graph API Explorer*。它通常用于在开发之前测试端点或只是检查返回的
    JSON 结果。Graph API Explorer 可在顶部导航栏的 **工具 & 支持** 菜单项中找到。这个工具看起来是这样的：
- en: '![What it is and how to configure it](img/00006.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![它是做什么的以及如何配置](img/00006.jpeg)'
- en: Most of the resources available on Facebook Open-Graph API require authorization.
    Just a few are available without having to provide an **access token**. An access
    token is a kind of ticket used by your application to act on the user's behalf,
    so you can get or submit data. Basically, you ask Facebook for some user's permissions;
    Facebook opens a popup asking the user to log in and shows the permissions your
    app is requesting; once the user allows them, Facebook will send back the user
    information/object to your page with the generated access token. From that time
    on, you have access to other Open-Graph API resources that your app needs. You
    just have to provide this token to every subsequent request you make. This is
    how *OAuth* authorization standards work but this book will not cover OAuth in
    detail, as it is not the purpose of this book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook Open-Graph API 上大多数可用的资源都需要授权。只有少数资源可以在不提供 **访问令牌** 的情况下使用。访问令牌是一种票据，您的应用程序使用它代表用户行事，因此您可以获取或提交数据。基本上，您向
    Facebook 请求一些用户的权限；Facebook 打开一个弹出窗口，要求用户登录并显示您的应用程序请求的权限；一旦用户允许，Facebook 将通过生成的访问令牌将用户信息/对象发送回您的页面。从那时起，您就可以访问应用程序需要的其他
    Open-Graph API 资源。您只需在您发出的每个后续请求中提供此令牌即可。这是 *OAuth* 授权标准的工作方式，但本书不会详细介绍 OAuth，因为它不是本书的目的。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more details about *OAuth* at [http://oauth.net/2/](http://oauth.net/2/).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [http://oauth.net/2/](http://oauth.net/2/) 找到有关 *OAuth* 的更多详细信息。
- en: 'In Graph API Explorer, you can get an access token by clicking on the button
    **Get Access Token**. This will open a popup with a bunch of permissions that
    your operation can use. Once you have selected the permissions you want, Graph
    API Explorer will show a popup requesting you to confirm the permissions requested.
    This process generates a new access token that allows you to make request actions
    to those restricted resources. Try checking out the `user_likes` permission and
    requesting your user''s list of likes through the endpoint `/me/likes`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Graph API Explorer 中，您可以通过点击 **获取访问令牌** 按钮来获取访问令牌。这将打开一个弹出窗口，其中包含您的操作可以使用的一组权限。一旦您选择了所需的权限，Graph
    API Explorer 将显示一个弹出窗口，要求您确认请求的权限。这个过程生成一个新的访问令牌，允许您对这些受限制的资源进行请求操作。尝试检查 `user_likes`
    权限，并通过 `/me/likes` 端点请求您的用户喜欢的列表：
- en: '![What it is and how to configure it](img/00007.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![它是做什么的以及如何配置](img/00007.jpeg)'
- en: You will probably see a JSON result in the box below the **Submit** button.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在 **提交** 按钮下方的框中看到 JSON 结果。
- en: This works very well when in Graph API Explorer but this is used just for testing
    purposes. In order to make that work, we have to create an application (APP-ID)
    at the Facebook developers site. This follows the OAuth standards specification
    and allows the user, who is logging in to your app, to know more about your application
    before granting access. In order to create an application in Facebook and obtain
    this APP-ID, go to the **My Apps** menu at the header of the page; there will
    be an option for creating a new app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这在Graph API Explorer中工作得非常好，但这只是为了测试目的。为了使其工作，我们必须在Facebook开发者网站上创建一个应用程序（APP-ID）。这遵循OAuth标准规范，并允许登录到你的应用程序的用户在授予访问权限之前了解更多关于你的应用程序的信息。为了在Facebook上创建一个应用程序并获得这个APP-ID，请转到页面顶部的“我的应用”菜单；那里将有一个创建新应用的选项。
- en: '![What it is and how to configure it](img/00008.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![它是做什么的以及如何配置它](img/00008.jpeg)'
- en: At the time of writing this book, the Facebook Open-Graph API recommended version
    was v.2.2.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这本书的时候，Facebook Open-Graph API推荐使用的版本是v.2.2。
- en: Creating an app-id on the Facebook developers site
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Facebook开发者网站上创建应用ID
- en: When you click the **Add a New App** button shown in the preceding image, Facebook
    will ask you which type of application you need.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击前面图片中显示的“添加新应用”按钮时，Facebook会询问你需要哪种类型的应用。
- en: '![Creating an app-id on the Facebook developers site](img/00009.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![在Facebook开发者网站上创建应用ID](img/00009.jpeg)'
- en: 'Choose the **Website** option, which indicates our app is going to run in a
    separate web page with no Facebook content around. After that, give it a fancy,
    original, and unpredictable name as I did: `learning-reactjs`. Once it''s done,
    you will be redirected to the app details and configuration page that looks something
    like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“网站”选项，这表示我们的应用将在一个独立的网页上运行，周围没有Facebook内容。之后，给它起一个花哨的、原创的、不可预测的名字，就像我这样做：“learning-reactjs”。完成之后，你将被重定向到应用详情和配置页面，看起来可能像这样：
- en: '![Creating an app-id on the Facebook developers site](img/00010.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![在Facebook开发者网站上创建应用ID](img/00010.jpeg)'
- en: Yay! We have our app-id ready; now we can use it to make request calls to Facebook
    Open-Graph API.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！我们的应用ID已经准备好了；现在我们可以用它来向Facebook Open-Graph API发起请求调用。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One important thing to note is that some permissions require further analysis
    from Facebook before going into production. As we are going to use this just for
    getting the data of our own user, it's OK. If you try to log in with a different
    user, it won't be possible as the `user_likes` permission requires your application
    to be submitted to analysis and doing that takes lots of time and should be done
    just in case you want to put your application into production.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事情需要注意，即某些权限在生产前需要Facebook进行进一步分析。由于我们只是用它来获取我们自己的用户数据，所以没问题。如果你尝试用不同的用户登录，将不可能成功，因为`user_likes`权限要求你的应用程序提交给分析，而这需要花费很多时间，并且只有在你想将应用程序投入生产时才应该这样做。
- en: Open-Graph JavaScript SDK
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Open-Graph JavaScript SDK
- en: Facebook Open-Graph API provides SDKs for common programming languages to ease
    the pain of consuming their resources. The JavaScript SDK can be found at [https://developers.facebook.com/docs/javascript](https://developers.facebook.com/docs/javascript).
    Their documentation ([https://developers.facebook.com/docs/javascript/quickstart/v2.5](https://developers.facebook.com/docs/javascript/quickstart/v2.5))
    is comprehensive and they have tutorials such as logging in, working with multiple
    requests, and so on. If you're considering taking an advanced course in learning
    Open-Graph API using JavaScript SDK, it is worth taking a look afterward.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook Open-Graph API为常见的编程语言提供了SDK，以简化使用其资源的过程。JavaScript SDK可以在[https://developers.facebook.com/docs/javascript](https://developers.facebook.com/docs/javascript)找到。他们的文档([https://developers.facebook.com/docs/javascript/quickstart/v2.5](https://developers.facebook.com/docs/javascript/quickstart/v2.5))非常全面，他们还提供了登录、处理多个请求等教程。如果你考虑学习使用JavaScript
    SDK的高级课程来学习Open-Graph API，那么在之后查看它是有价值的。
- en: 'Just to recap what we''re about to do: we''re going to create a simple HTML
    page that will load the Facebook JavaScript SDK. After that, we''re going to log
    in to Facebook and request our logged-in user list of likes and pass it to a ReactJS
    component, which we will also create, through properties.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了回顾一下我们即将要做的事情：我们将创建一个简单的HTML页面，该页面将加载Facebook JavaScript SDK。之后，我们将登录到Facebook，请求我们的登录用户喜欢的列表，并通过属性将其传递给我们将要创建的ReactJS组件。
- en: 'The Facebook JavaScript SDK needs to be loaded in the background, without the
    waiting time (asynchronously) after the page finishes loading. In order to do
    that, we need to create a `script` HTML element, put its `src` (source) attribute
    to point to the SDK script, and, finally, insert that into the DOM. Fortunately,
    the SDK page has an example ready to use and you just need to replace the `APP-ID`
    property within it. We are going to use their example. This is what the script
    looks like:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook JavaScript SDK需要在后台加载，页面加载完成后不需要等待时间（异步）。为了做到这一点，我们需要创建一个`script` HTML元素，将其`src`（源）属性指向SDK脚本，并将其最终插入DOM中。幸运的是，SDK页面有一个现成的示例可以使用，你只需要替换其中的`APP-ID`属性。我们将使用他们的示例。脚本看起来是这样的：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`window.fbAsyncInit` is an initialization function with your Facebook `appId`
    and other details.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.fbAsyncInit`是一个初始化函数，包含你的Facebook `appId`和其他详细信息。'
- en: Once the asynchronous initialization is done, if the concerned element is found,
    then JavaScript(js) connects with `//connect.facebook.net/en_US/sdk/debug.js`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦异步初始化完成，如果找到相关元素，JavaScript（js）就会连接到`//connect.facebook.net/en_US/sdk/debug.js`。
- en: We need to change the `appId` parameter to `t Facebook-app-id`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将`appId`参数更改为`t Facebook-app-id`。
- en: 'So, let''s get started by creating an `index.html` file inside a separate folder
    to organize things. The page will be like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始创建一个位于单独文件夹中的`index.html`文件来组织这些内容。页面将如下所示：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are commenting the `js.src` line and duplicating it with a debug JavaScript
    file. This helps with finding errors and debugging your script.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在注释`js.src`行，并使用一个调试JavaScript文件进行复制。这有助于查找错误和调试你的脚本。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A **Content Delivery Network** or **Content Distribution Network** (**CDN**)
    is a globally distributed network of proxies. Source: https://en.wikipedia.org/wiki/Server_(computing)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容分发网络**或**内容分发网络**（**CDN**）是一个全球分布式的代理网络。来源：https://en.wikipedia.org/wiki/Server_(computing)'
- en: 'Servers are deployed in multiple data centers. Source: [https://en.wikipedia.org/wiki/Data_center](https://en.wikipedia.org/wiki/Data_center)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器部署在多个数据中心。来源：[https://en.wikipedia.org/wiki/Data_center](https://en.wikipedia.org/wiki/Data_center)
- en: The goal of a CDN is to serve content to end users with high availability and
    high performance. Source [https://en.wikipedia.org/wiki/Content_delivery_network](https://en.wikipedia.org/wiki/Content_delivery_network)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CDN的目标是以高可用性和高性能向最终用户提供服务。来源 [https://en.wikipedia.org/wiki/Content_delivery_network](https://en.wikipedia.org/wiki/Content_delivery_network)
- en: First, we need to reference ReactJS dependencies and we are referencing the
    CDN version ones to make it easier to demonstrate and for learning purposes. After
    referencing the dependencies, we create some HTML elements, a title, a logout
    anchor to log out from Facebook, and a `div` that will be the host for the ReactJS
    component to be rendered. Later, we configure the Facebook Open-Graph JavaScript
    SDK as explained before, but with one extra command, `checkLoginStatusAndLoadUserLikes();`,
    that will be explained soon. Lastly, we reference our `index.jsx` file that will
    contain the magic to make it all happen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要引用ReactJS依赖项，我们将引用CDN版本以使其更容易演示和学习目的。在引用依赖项之后，我们创建一些HTML元素，一个标题，一个用于从Facebook注销的锚点，以及一个`div`，它将成为要渲染的ReactJS组件的宿主。稍后，我们将按照之前解释的方式配置Facebook
    Open-Graph JavaScript SDK，但增加一个额外的命令`checkLoginStatusAndLoadUserLikes();`，这个命令将在稍后解释。最后，我们将引用包含使一切发生的魔法的`index.jsx`文件。
- en: We put the `checkLoginStatusAndLoadUserLikes` call within the `fbAsyncInit`
    function because the Open-Graph SDK JavaScript triggers that function once it
    is loaded, so this is the right place to call Open-Graph API calls. Continuing
    with our development, inside our `index.jsx` file, let's implement the `logout`
    and `checkLoginStatusAndLoadUserLikes` functions and test it out in order to see
    the Facebook integration working.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`checkLoginStatusAndLoadUserLikes`调用放在了`fbAsyncInit`函数中，因为Open-Graph SDK
    JavaScript会在加载后触发该函数，所以这里是调用Open-Graph API调用的正确位置。继续我们的开发，在`index.jsx`文件内部，让我们实现`logout`和`checkLoginStatusAndLoadUserLikes`函数，并测试一下以查看Facebook集成是否工作。
- en: 'The `logout` function should be as simple as this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`logout`函数应该像这样简单：'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will just log the user out of Facebook, requiring him to log in again.
    As we''ll keep it simple, for learning purposes, we''re not going to handle the
    scenario where the user logs in and out to manage the list of likes when these
    events happen in sequence. So, let''s implement our `checkLoginStatusAndLoadUserLikes`
    function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅将用户从 Facebook 上注销，需要他再次登录。由于我们将保持简单，为了学习目的，我们不会处理用户在发生这些事件时注销和登录来管理点赞列表的情况。因此，让我们实现我们的
    `checkLoginStatusAndLoadUserLikes` 函数：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is a very straightforward code as well. Every call made by the Open-Graph
    JavaScript SDK will be done asynchronously, so we have to provide a functions
    callback that will be triggered once the request made to Facebook API returns
    with the response. In this code, we''re going to log in to the console once we''ve
    logged in to the app. This process will call a Facebook login popup:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也非常简单明了。Open-Graph JavaScript SDK 所做的每个调用都将异步执行，因此我们必须提供一个函数回调，该回调将在向 Facebook
    API 发出请求并返回响应时触发。在这段代码中，我们将在登录到应用后登录到控制台。这个过程将调用 Facebook 登录弹出窗口：
- en: '![Open-Graph JavaScript SDK](img/00011.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Open-Graph JavaScript SDK](img/00011.jpeg)'
- en: Try it out! Load the screen and once logged in, click the logout anchor and
    reload the page again, check out the console from your browser, and see the log
    we've printed. The following image shows the login popup.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下！加载屏幕，一旦登录，点击注销锚点并重新加载页面，从您的浏览器中查看控制台，查看我们打印的日志。以下图像显示了登录弹出窗口。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to make it work in `localhost:3000`, it's necessary that you run the
    Python `SimpleHTTPServer` command from inside the code folder, `python -m SimpleHTTPServer`.
    For more details about this command and other ways of running your app, check
    [Chapter 1](part0015_split_000.html#page "Chapter 1. Getting Started with ReactJS"),
    *Getting Started with ReactJS*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其在 `localhost:3000` 上工作，您需要在代码文件夹内运行 Python 的 `SimpleHTTPServer` 命令，即 `python
    -m SimpleHTTPServer`。有关此命令和其他运行您应用的方法的更多详细信息，请参阅[第1章](part0015_split_000.html#page
    "第1章. 使用 ReactJS 入门"), *使用 ReactJS 入门*。
- en: 'You can also make it work by using the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下命令实现：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'httpster: Is a simple http server to run the static content. In chrome browser
    the `index.html` file sometime''s doesn''t render due to X-origin error. Hence
    running this webserver from your application directory, will be easier to test
    your application in Chrome. Just run the command httpster from your application''s
    `root` directory.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: httpster：这是一个简单的 http 服务器，用于运行静态内容。在 Chrome 浏览器中，`index.html` 文件有时会因为 X-origin
    错误而无法渲染。因此，从您的应用程序目录运行此 web 服务器将更容易测试您的应用程序。只需从您的应用程序的 `root` 目录运行 httpster 命令。
- en: By Default the server runs in port `3333`, thus `localhost:3333` in the browsers
    should render the `index.html` page of your application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务器在端口 `3333` 上运行，因此浏览器中的 `localhost:3333` 应该显示您应用的 `index.html` 页面。
- en: 'Now that we have our integration working, let''s get this list of likes for
    the logged-in user. Change your `checkLoginStatusAndLoadUserLikes` function to
    be like so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的集成工作已经完成，让我们获取已登录用户的点赞列表。将您的 `checkLoginStatusAndLoadUserLikes` 函数修改如下：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first step is to check out where the user is already logged in. Calling
    the `FB.getLoginStatus` function can do this. Inside the callback function, the
    parameter passed represents the response from the API. This response contains
    information about the login status for the user. This will be a very common parameter
    as other API calls also return a response object back to your callback function.
    The status that represents that the user has authorized the app and has successfully
    logged in is the `connected` one. If the user is already logged in, we just call
    the `loadUserAndLikes` function, but if it's not connected then it calls another
    function that will log in and then call the API to load the user's list of likes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是检查用户已经登录的位置。调用 `FB.getLoginStatus` 函数可以做到这一点。在回调函数内部，传递的参数代表来自 API 的响应。此响应包含有关用户登录状态的信息。这将是一个非常常见的参数，因为其他
    API 调用也会将响应对象返回到您的回调函数。表示用户已授权应用并成功登录的状态是 `connected`。如果用户已经登录，我们只需调用 `loadUserAndLikes`
    函数，但如果未连接，则调用另一个函数来登录，然后调用 API 加载用户的点赞列表。
- en: 'The function `loginAndLoadUserLikes` should be as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `loginAndLoadUserLikes` 应该如下所示：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The login functionality has been moved to this method. Once the login operation
    is complete then we call `loadUserAndLikes`. Notice that we now pass an object
    at the end of the login function c`all {scope: ''user_likes''}`; this object represents
    the scope/permissions on Facebook, as required by our applicaton. In the following
    example, within the first function call (`loadUserAndLikes`), the `userResponse`
    of the logged-in user is returned. Then the API lists all the likes of that logged-in
    user.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '登录功能已移动到这个方法。一旦登录操作完成，我们就调用 `loadUserAndLikes`。注意，我们现在在登录函数调用末尾传递一个对象 `{scope:
    ''user_likes''}`；这个对象代表 Facebook 上的作用域/权限，这是我们的应用程序所要求的。在下面的示例中，在第一个函数调用（`loadUserAndLikes`）中，返回了登录用户的
    `userResponse`。然后 API 列出了该登录用户的全部点赞。'
- en: 'The function `loadUserAndLikes` should look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `loadUserAndLikes` 应该如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can have as much JavaScript code as you want inside JSX files. It's not
    a specific type of file that understands only its own syntax, it just converts
    the places where you use JSX-specific syntax markup instead.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 JSX 文件中包含尽可能多的 JavaScript 代码。它不是一种只理解其自身语法的特定类型的文件，它只是将您使用 JSX 特定语法标记的地方转换过来。
- en: 'Notice that we are making two requests for the API: the first one will get
    the user details and the other will get the user''s list of likes. We are logging
    them to the console in order to test first before we implement our ReactJS component
    to render it. This is what it logs out for my user:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在对 API 进行两次请求：第一个请求将获取用户详情，另一个请求将获取用户的点赞列表。我们在实现我们的 ReactJS 组件以渲染它之前，将它们记录到控制台以进行测试。这是我用户的输出：
- en: '![Open-Graph JavaScript SDK](img/00012.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Open-Graph JavaScript SDK](img/00012.jpeg)'
- en: Until now, we have explored Facebook Open-Graph API and ways to configure it.
    You might be wondering what it has to do with learning ReactJS? All I can say
    is that, in my experience, all the examples that most people try to provide when
    teaching a new library or framework, rely on **To-Do** apps, synchronous operations
    and, when they use an external. It doesn't make common integration tasks such
    as login. Such integration gives a better idea of how the thing being taught works
    when we put more realistic scenarios into place and try to make them as straightforward
    as possible. After finishing this example, we will have an idea about how to integrate
    ReactJS with your own private API, for instance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了 Facebook Open-Graph API 及其配置方法。你可能想知道这与学习 ReactJS 有什么关系？我只能说，根据我的经验，大多数人在教授一个新的库或框架时，所提供的示例都依赖于
    **待办事项** 应用程序、同步操作，并且当它们使用外部资源时。这并不适用于常见的集成任务，如登录。这种集成让我们更好地了解当我们将更现实的场景放入其中并尽可能使其简单时，所教授的事物是如何工作的。完成这个示例后，我们将了解如何将
    ReactJS 与您自己的私有 API 集成，例如。
- en: Rendering data in a ReactJS component
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 ReactJS 组件中渲染数据
- en: 'We now have our data to pass to the ReactJS component we''re going to create.
    First, let''s start with the `UserDetails` component. This is going to show a
    link with the logged-in username and the source to this user Facebook page. First,
    remove our old logout anchor from the `index.html` file as this is not going to
    be necessary anymore. Our logout functionality will be moved to our ReactJS component
    instead. We''ll also create another `div`, named `user`, above the main `div`;
    this new element will hold the `UserDetails` component. The changes in `index.html`
    should look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了要传递给我们要创建的 ReactJS 组件的数据。首先，让我们从 `UserDetails` 组件开始。这个组件将显示一个带有登录用户名的链接以及该用户的
    Facebook 页面链接。首先，从 `index.html` 文件中移除我们的旧登录锚点，因为这个功能现在不再需要了。我们的登出功能将移动到我们的 ReactJS
    组件中。我们还会在主 `div` 上方创建另一个 `div`，命名为 `user`；这个新元素将包含 `UserDetails` 组件。`index.html`
    中的更改应该如下所示：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can create the `UserDetails` ReactJS component at the bottom of the `index.jsx`
    file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `index.jsx` 文件的底部创建 `UserDetails` ReactJS 组件：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we need to change the `loadUserAndLikes` function to call the `React.render`
    method, pointing it to the user HTML `div` element:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将 `loadUserAndLikes` 函数修改为调用 `React.render` 方法，将其指向用户 HTML 的 `div` 元素：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the `UserDetails` ReactJS component is very straightforward
    and basic; it works like a template and just renders data that is passed to it.
    Don't be disappointed with this because we're going to give this more functionality
    in coming chapters, such as rendering a login button when logged out, instead
    of asking to refresh the page, hiding the list, and showing a loading `gif` image
    when waiting for the SDK response. All of those features require that we deal
    with a state and this is going to be covered in the next chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`UserDetails` ReactJS 组件非常简单和基本；它就像一个模板，只是渲染传递给它的数据。不要对此感到失望，因为我们将在接下来的章节中给它添加更多功能，例如，在用户注销时渲染登录按钮，而不是要求刷新页面，隐藏列表，在等待
    SDK 响应时显示加载 `gif` 图像。所有这些功能都需要我们处理状态，这将在下一章中介绍。
- en: You can test it by refreshing the page, clicking the logout button, and refreshing
    the page again. Once you log in on Facebook, the user details should be displayed
    in the browser, below the title of our page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过刷新页面、点击注销按钮，然后再次刷新页面来测试它。一旦你在 Facebook 上登录，用户详情应该显示在浏览器中，位于我们页面标题下方。
- en: 'We now need to render the user''s list of likes and substitute the ugly `console.log(2,
    likesResponse);` command to a ReactJS render function. First, let''s create our
    `UserLikesList` component at the bottom of the `index.jsx` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要渲染用户的点赞列表，并将丑陋的 `console.log(2, likesResponse);` 命令替换为 ReactJS 渲染函数。首先，让我们在
    `index.jsx` 文件的底部创建我们的 `UserLikesList` 组件：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We create an array of `UserLikeItem` components called `items` and we''re rendering
    them inside the list `<ul>` element. The `UserLikeItem` component should look
    like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `items` 的 `UserLikeItem` 组件数组，并在列表 `<ul>` 元素内部渲染它们。`UserLikeItem`
    组件应该看起来像这样：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We put our property data in a separate variable to avoid long names inside
    the component markup. Note that we are also displaying an image from the liked
    Facebook resource; because of that, we also need to ask that in our API call and
    render our component passing this list of likes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将属性数据放在一个单独的变量中，以避免在组件标记中存在长名称。请注意，我们还在显示来自点赞的 Facebook 资源的照片；因此，我们还需要在我们的
    API 调用中请求这一点，并通过传递这个点赞列表来渲染我们的组件：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've changed the `loadUserAndLikes` function to ask the API to also bring a
    picture of the liked Facebook resource. By default, it's omitted from the response.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `loadUserAndLikes` 函数更改为请求 API 也带来点赞的 Facebook 资源的照片。默认情况下，它被省略在响应中。
- en: 'Try it out and see if you get a list of your likes displayed in the page. It
    might be looking very odd because we haven''t created any style. Create a style
    element in the `index.html` page for styling our list: a very basic one but just
    for making our example more pleasing to look at:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，看看你是否能在页面上显示你的点赞列表。它可能看起来非常奇怪，因为我们还没有创建任何样式。在 `index.html` 页面中创建一个样式元素来为我们的列表添加样式：一个非常基本的样式，但只是为了使我们的示例看起来更令人愉悦：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Rendering data in a ReactJS component](img/00013.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![在 ReactJS 组件中渲染数据](img/00013.jpeg)'
- en: OK, maybe it's bad without styling. Anyway, you can always ask a designer for
    help!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，可能没有样式看起来不太好。无论如何，你总是可以向设计师寻求帮助！
- en: ReactJS properties make your components configurable and changeable. As you
    can see, it's very straightforward to create ReactJS components and render them
    in your page, even in an existing one. You don't need to make the whole app support
    the framework or start one from scratch. You simply define what your components
    are, considering them as a set, avoiding big ones that are difficult to maintain,
    and render them somewhere in the page. Its power increases by intelligently working
    with stateful components, and this is our next step in learning ReactJS.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS 属性使你的组件可配置和可更改。正如你所见，创建 ReactJS 组件并在你的页面上渲染它们非常简单，即使在现有的页面上也是如此。你不需要让整个应用支持框架或从头开始创建一个。你只需定义你的组件是什么，将它们视为一个集合，避免创建难以维护的大组件，并在页面的某个位置渲染它们。通过智能地处理有状态的组件，它的功能得到了增强，这是我们学习
    ReactJS 的下一步。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned how to pass properties to ReactJS components
    and render the UI based on those components. We have also learned how to make
    a parent component to communicate with its children. We have seen how to configure
    Facebook Open-Graph API, how to integrate that with ReactJS using login functionality,
    and how to render the response of an API request call into a set of smaller ReactJS
    components.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何向ReactJS组件传递属性，并根据这些组件渲染UI。我们还学习了如何创建父组件与其子组件进行通信。我们看到了如何配置Facebook
    Open-Graph API，如何使用登录功能将其与ReactJS集成，以及如何将API请求调用的响应渲染成一系列较小的ReactJS组件。
- en: In the next chapter, we are going to dive into stateful components and explore
    how to make mutable ReactJS components based on a user's input or for any other
    reason that requires the state to change and your UI to represent that automatically.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨有状态组件，并了解如何根据用户的输入或任何其他需要状态改变以及UI自动表示该状态的原因来创建可变的ReactJS组件。
