- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Creating Dynamic Angular Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动态Angular组件
- en: When we are creating components, the flexibility and reusability of those components
    should be top priorities. You don’t want unnecessary dependencies inside your
    component and want to ensure the component can serve as many scenarios as possible
    without becoming overcomplicated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建组件时，组件的灵活性和可重用性应该是首要考虑的。你不想在组件内部有不必要的依赖，并确保组件可以在尽可能多的场景下提供服务，而不会变得过于复杂。
- en: This chapter will teach you how to create truly dynamic UI components using
    content projection, template references, and template outlets. We will learn how
    to dynamically render components using the component outlet directive and the
    view container reference.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何使用内容投影、模板引用和模板出口创建真正动态的UI组件。我们将学习如何使用组件出口指令和视图容器引用动态渲染组件。
- en: By the end of this chapter, you will know when and how to project content into
    UI components, effectively use templates inside your components, and output code
    in different places, depending on certain conditions. You will also be able to
    load and render components dynamically, enhancing the flexibility and performance
    of your application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解何时以及如何将内容投影到UI组件中，有效地在你的组件内部使用模板，并根据某些条件在不同的地方输出代码。你还将能够动态加载和渲染组件，从而提高应用程序的灵活性和性能。
- en: 'This chapter will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: A deep dive into Angular content projection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨Angular内容投影
- en: Using template references and variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板引用和变量
- en: Rendering components dynamically
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态渲染组件
- en: A deep dive into Angular content projection
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨Angular内容投影
- en: Often, when creating a component, you need to display a wide variety of content
    inside it. Some good examples include a modal component, a card, or a tab component.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在创建一个组件时，你需要在其中显示各种内容。一些好的例子包括模态组件、卡片组件或标签页组件。
- en: Let’s consider the **modal component**; you want the component to have a visible
    and hidden state, a backdrop, and some shared styling so that all your modals
    have the same look and feel. Yet the content inside each instance of the modal
    component will be wildly different. Sometimes, you want to display a form inside
    the modal, while other times, you want to use it to display text or provide actions
    or configurations to the user. Most likely, each modal you have within your application
    will have different content inside.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下**模态组件**；你希望该组件具有可见和隐藏状态、背景以及一些共享样式，以便所有模态都具有相同的视觉和感觉。然而，模态组件每个实例中的内容将大相径庭。有时，你希望在模态中显示一个表单，而其他时候，你希望用它来显示文本或向用户提供操作或配置。很可能，你应用程序中的每个模态都将包含不同的内容。
- en: 'So, a question arises: how do we facilitate this need and create a component
    that can house any content it needs within its HTML template?'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个问题出现了：我们如何满足这种需求并创建一个可以在其HTML模板中容纳任何所需内容的组件？
- en: You could hardcode all the options and use inputs to configure the component,
    but this becomes unmaintainable really fast! Using **content projection** is the
    correct way to create a component that needs to display a wide variety of content
    inside its template. Angular content projection lets you define placeholders inside
    the HTML template of a component. You can fill these placeholders with any content
    by projecting the content inside the placeholder from the parent component HTML
    template where the dynamic component is declared. We will explore and use content
    projection ourselves by creating a modal component.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以硬编码所有选项并使用输入来配置组件，但这很快就会变得难以维护！使用**内容投影**是创建需要在模板内部显示各种内容的组件的正确方式。Angular内容投影允许你在组件的HTML模板中定义占位符。你可以通过从声明动态组件的父组件HTML模板中投影占位符内的内容来填充这些占位符。我们将通过创建模态组件来探索和使用内容投影。
- en: Creating a modal component using content projection
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内容投影创建模态组件
- en: 'Let’s start by creating a modal component inside the `common-components` library
    of your *Nx monorepo*. Inside the `component` class, add an input for the shown
    status of the modal and an output for the close event. Also, add input for the
    modal title:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在*Nx monorepo*的`common-components`库中创建一个模态组件开始。在`component`类中，添加一个用于模态显示状态的输入和一个用于关闭事件的输出。还要添加一个用于模态标题的输入：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s create the HTML template for the modal component. Start with an
    `ng-container` element. Inside the `ng-container` element sits the modal container
    and the backdrop. We must also place a `*ngIf` directive with the shown status
    on the `ng-container` element:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为模态组件创建HTML模板。从`ng-container`元素开始。在`ng-container`元素内部放置模态容器和背景。我们还需要在`ng-container`元素上放置一个带有显示状态的`*ngIf`指令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, you can add a modal header and modal content area inside the modal container.
    The modal header will contain the title and a “X” button to close the modal:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以在模态容器内部添加模态标题和模态内容区域。模态标题将包含标题和一个“X”按钮来关闭模态：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Lastly, you have to add the modal content area. This is where we will create
    the placeholder for our content projection:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您必须添加模态内容区域。这是我们创建内容投影占位符的地方：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can find the CSS for the modal component in this book’s GitHub repository:
    [https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-five/dynamic-components](https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-five/dynamic-components).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到模态组件的CSS：[https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-five/dynamic-components](https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-five/dynamic-components)。
- en: 'As you can see, inside the modal content area, we defined an `ng-content` element:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在模态内容区域内，我们定义了一个`ng-content`元素：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This `ng-content` element is the placeholder for the projected content. The
    `ng-content` element will display everything we project from the parent component
    into the modal component.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此`ng-content`元素是投影内容的占位符。`ng-content`元素将显示我们从父组件投影到模态组件中的所有内容。
- en: 'You project content from the parent component into the modal component by placing
    content between the component’s opening and closing selector tags. To test the
    content projection of your modal, import the modal component inside the `expenses-overview`
    component and add a Boolean property, `addExpenseShown`. Next, add the model component
    to the HTML template and project `addExpenseForm`, which we created in the previous
    chapter, inside the modal component, like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过在组件的打开和关闭选择器标签之间放置内容，从父组件将内容投影到模态组件中。为了测试模态的内容投影，请在`expenses-overview`组件内部导入模态组件，并添加一个布尔属性`addExpenseShown`。然后，将模态组件添加到HTML模板中，并在模态组件内部投影我们在上一章中创建的`addExpenseForm`，如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, when the modal is shown, it displays the add expense form we projected
    into the component. The `ng-content` element inside the HTML template of the modal
    will be replaced with the add expense form we projected into the modal component.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当模式显示时，它显示我们投影到组件中的添加费用表单。模态的HTML模板中的`ng-content`元素将被我们投影到模态组件中的添加费用表单所替换。
- en: As you can see, the `ng-content` slot provides the flexibility you need for
    your modal component and allows you to project any content easily into the modal.
    Any logic related to the projected content is handled in the parent component
    and not inside the modal component itself, resulting in good separations of concerns.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ng-content`插槽为您提供了模态组件所需的灵活性，并允许您轻松地将任何内容投影到模态中。与投影内容相关的任何逻辑都在父组件中处理，而不是在模态组件内部，从而实现了关注点的良好分离。
- en: In the case of our projected form, if you want to handle the `addExpense` output
    event of the form component, you handle the event inside the `expenses-overview`
    component. The same goes for styling the projected content. If you want to style
    your projected content, you must do so inside the CSS file of the component where
    you project the content. In our example, this would be the `add-expense.component.scss`
    file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们投影的表单的情况下，如果您想处理表单组件的`addExpense`输出事件，您需要在`expenses-overview`组件内部处理该事件。对于投影内容的样式也是如此。如果您想对投影内容进行样式设置，您必须在您投影内容的组件的CSS文件中进行。在我们的例子中，这将是在`add-expense.component.scss`文件中。
- en: You now know how to project content into a single `ng-content` slot. Next, you’ll
    learn how to handle more complex projection scenarios by using multiple `ng-content`
    slots.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道如何将内容投影到单个`ng-content`插槽中。接下来，您将通过使用多个`ng-content`插槽来学习如何处理更复杂的投影场景。
- en: Exploring multi-slot content projection with ng-content select
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索使用ng-content选择的多插槽内容投影
- en: Using a single `ng-content` slot provides a lot of flexibility, but sometimes,
    you need multiple places to project content.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个`ng-content`插槽提供了很多灵活性，但有时您需要多个位置来投影内容。
- en: 'Let’s say that in some of the modal designs you have, there is custom content
    between the title and closing buttons of the modal. To cover this use case, you
    need two places to project content: one in the content area and one in the header.
    When using multiple `ng-content` elements in a component, you need to use `ng-content`
    with a `select` attribute defined on the element:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在一些模态设计中，标题和关闭按钮之间有自定义内容。为了覆盖这种情况，您需要两个地方来投影内容：一个在内容区域，一个在标题区域。当在组件中使用多个 `ng-content`
    元素时，您需要在元素上使用具有定义 `select` 属性的 `ng-content`：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we added the additional `ng-content` element inside the modal header and
    assigned the select attribute with a value of `header-content`. If we added the
    second `ng-content` element without defining the select attribute, all projected
    content would end up inside the last `ng-content` element in the HTML template
    of the modal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在模态标题内添加了额外的 `ng-content` 元素，并分配了值为 `header-content` 的选择属性。如果我们添加第二个 `ng-content`
    元素而没有定义选择属性，所有投影的内容都将最终出现在模态的 HTML 模板中的最后一个 `ng-content` 元素内。
- en: 'For projected content to end up in a specific `ng-content` element, the projected
    content needs to match the select attribute value of `ng-content`. For the header’s
    `ng-content` element, this means you need to add a `header-content` attribute
    to the HTML you want to project to the header slot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使投影内容最终出现在特定的 `ng-content` 元素中，投影内容需要匹配 `ng-content` 的选择属性值。对于标题的 `ng-content`
    元素，这意味着您需要将 `header-content` 属性添加到您想要投影到标题槽中的 HTML 中：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can project as much HTML as you want to a specific `ng-content` element.
    There are three scenarios when Angular determines where your content will be projected.
    Let’s explore these scenarios one by one:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将尽可能多的 HTML 投影到特定的 `ng-content` 元素中。当 Angular 确定内容将被投影的位置时，有三种场景。让我们逐一探索这些场景：
- en: If the projected content matches the select attribute value of an `ng-content`
    element in your template, the content is projected to `ng-content` with the matching
    select value.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果投影的内容与模板中 `ng-content` 元素的选择属性值匹配，则内容将被投影到具有匹配选择值的 `ng-content`。
- en: If the content matches multiple `ng-content` selectors, the content is projected
    into the first `ng-content` element with a matching select value.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果内容匹配多个 `ng-content` 选择器，内容将被投影到第一个具有匹配选择值的 `ng-content` 元素中。
- en: 'If the projected HTML doesn’t match any of the `ng-content` select values,
    the content is projected to the fallback `ng-content` element – that is, `ng-content`
    – without a `select` attribute assigned:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果投影的 HTML 不匹配任何 `ng-content` 选择值，内容将被投影到后备 `ng-content` 元素上——即没有分配 `select`
    属性的 `ng-content`：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In our modal component, the fallback slot is defined inside the content area
    of the modal. If all content slots have a select attribute defined, there is no
    fallback slot. When there is no fallback `ng-content` element, any projected content
    that doesn’t match with at least one of the `select` attribute values will not
    be projected and rendered.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模态组件中，后备槽定义在模态的内容区域内。如果所有内容槽都定义了选择属性，则没有后备槽。当没有后备 `ng-content` 元素时，任何不与至少一个
    `select` 属性值匹配的投影内容将不会被投影和渲染。
- en: The `select` attribute of the `ng-content` tag allows you to create powerful
    selectors that can match various things. You can match HTML attributes like we
    did in our modal component, but you can also match HTML tags.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-content` 标签的 `select` 属性允许您创建强大的选择器，可以匹配各种内容。您可以根据我们在模态组件中做的那样匹配 HTML 属性，但您也可以匹配
    HTML 标签。'
- en: 'For example, let’s say we want to project all `div` HTML tags into the header
    slot. We can adjust the selector like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要将所有的 `div` HTML 标签投影到标题槽中。我们可以调整选择器如下：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <div>special header content</div>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <div>特殊的标题内容</div>
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <ng-content select="div, p"></ng-content>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <ng-content select="div, p"></ng-content>
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <ng-content select=".header"></ng-content>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <ng-content select=".header"></ng-content>
- en: <ng-content select="#header"></ng-content>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <ng-content select="#header"></ng-content>
- en: <ng-content select="[type='text']"></ng-content>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <ng-content select="[type='text']"></ng-content>
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <div *ngFor="let item of [1,2,3]">
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <div *ngFor="let item of [1,2,3]">
- en: <ng-content></ng-content>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <ng-content></ng-content>
- en: </div>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <bt-libs-modal [shown]="addExpenseShown" [title]="'Add expenses'">
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <bt-libs-modal [shown]="addExpenseShown" [title]="'Add expenses'">
- en: <div *ngFor="let header of headers" header-content>{{header}}</div>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <div *ngFor="let header of headers" header-content>{{header}}</div>
- en: </bt-libs-modal>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: </bt-libs-modal>
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '@Directive({'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '@Directive({'
- en: 'selector: ‹[btLibsScalesProjection]'','
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'selector: ‹[btLibsScalesProjection]'','
- en: 'standalone: true,'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'standalone: true,'
- en: '})'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '})'
- en: export class ScalesProjectionDirective {
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: export class ScalesProjectionDirective {
- en: 'constructor(public templateRef: TemplateRef<unknown>) { }'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor(public templateRef: TemplateRef<unknown>) { }`'
- en: '}'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '@Input({ required: true }) scaleSizes!: number[];'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input({ required: true }) scaleSizes!: number[];`'
- en: '@ContentChild(ScalesProjectionDirective) content!: ScalesProjectionDirective;'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ContentChild(ScalesProjectionDirective) content!: ScalesProjectionDirective;`'
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <div *ngFor="let size of scaleSizes; let i = index" [style.transform]="'scale('
    + size + ')'">
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div *ngFor="let size of scaleSizes; let i = index" [style.transform]="''scale(''
    + size + '')''">`'
- en: <ng-container [ngTemplateOutlet]=»content.templateRef»></ng-container>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ng-container [ngTemplateOutlet]=»content.templateRef»></ng-container>`'
- en: </div>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`</div>`'
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <bt-libs-display-scales [scaleSizes]="[0.8, 1, 1.2, 1.4]">
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`<bt-libs-display-scales [scaleSizes]="[0.8, 1, 1.2, 1.4]">`'
- en: <ng-template btLibsScalesProjection>I scale!</ng-template>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ng-template btLibsScalesProjection>I scale!</ng-template>`'
- en: </bt-libs-display-scales>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`<bt-libs-display-scales>`'
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '@QueryList, you need to loop over QueryList and create an ng-container element
    for each node in the list. You can achieve this by turning QueryList into an array
    and using the *ngFor directive to output each item in the list:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`@QueryList`，你需要遍历QueryList并为列表中的每个节点创建一个`ng-container`元素。你可以通过将QueryList转换为数组并使用`*ngFor`指令输出列表中的每个项来实现这一点：'
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you want to project content into different slots, as we did with the `ng-content`
    tags and `select` attribute, you need to create multiple projection directives
    like `ScalesProjectionDirective` and use multiple `@ContentChild` decorators to
    separate the project’s `ng-template` elements:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将内容投影到不同的槽位，就像我们使用`ng-content`标签和`select`属性所做的那样，你需要创建多个投影指令，如`ScalesProjectionDirective`，并使用多个`@ContentChild`装饰器来分离项目的`ng-template`元素：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <ng-container [ngTemplateOutlet]="content.templateRef"></ng-container>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ng-container [ngTemplateOutlet]="content.templateRef"></ng-container>`'
- en: <ng-container [ngTemplateOutlet]="ng-template elements and use the *ngFor, *ngIf,
    and *ngSwitch directives or control flow syntax in combination with projected
    content.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ng-container [ngTemplateOutlet]="ng-template elements and use the *ngFor,
    *ngIf, and *ngSwitch directives or control flow syntax in combination with projected
    content.``'
- en: Now, let’s explore what else we can do with the `ng-template` element, what
    template variables are, and how we can use them effectively in our components.
    We will start by learning about template variables.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索我们还可以用`ng-template`元素做什么，模板变量是什么，以及我们如何在组件中有效地使用它们。我们将从了解模板变量开始。
- en: Using template variables effectively
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`有效地使用模板变量`'
- en: When building components, we often need to use one part of the HTML template
    in another part of the HTML template. You can access elements from your HTML template
    using decorators such as `@ViewChild` or `@ContentChild`, but you can also use
    **template variables**. Using template variables helps simplify your code because
    you can handle situations where you need one part of the template in another place,
    all in your HTML; there’s no need to create a property in your component class
    and use this variable inside your HTML template.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建组件时，我们经常需要在一个HTML模板的一部分中使用另一个HTML模板的一部分。你可以使用如`@ViewChild`或`@ContentChild`之类的装饰器从你的HTML模板中访问元素，但你也可以使用**模板变量**。使用模板变量可以帮助简化你的代码，因为你可以处理在HTML模板的另一个地方需要模板的一部分的情况，所有这些都在你的HTML中；不需要在你的组件类中创建一个属性并在你的HTML模板中使用这个变量。
- en: 'A template variable can refer to five different elements:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模板变量可以引用五个不同的元素：
- en: DOM elements within the HTML template
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML模板中的DOM元素
- en: Directives used within the HTML template
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML模板中使用的指令
- en: Components used within the HTML template
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML模板中使用的组件
- en: '`TemplateRef` from `ng-template` elements used within the HTML template'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`从HTML模板中使用的`ng-template`元素的`TemplateRef`'
- en: A web component
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Web组件
- en: 'Template variables are created using the hashtag (`#`) sign combined with a
    variable name. For example, if you want to create a template variable from a `div`
    element in your template, you can use this syntax:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 模板变量是通过使用井号（`#`）符号与变量名结合来创建的。例如，如果你想从模板中的`div`元素创建一个模板变量，你可以使用以下语法：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<div>Template var says: {{exampleVar.innerText}} </div>'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div>模板变量说：{{exampleVar.innerText}}</div>`'
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<input #name placeholder="Enter your name" />'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`<input #name placeholder="Enter your name" />`'
- en: <button (click)="submitName(name.value)">Submit</button>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`<button (click)="submitName(name.value)">提交</button>`'
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<bt-libs-modal #modal [(shown)]="addExpenseShown"> ………'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`<bt-libs-modal #modal [(shown)]="addExpenseShown"> ……</bt-libs-modal>`'
- en: </bt-libs-modal>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`<bt-libs-modal>`'
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<form #expenseForm="ngForm"> ……… </form>'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`<form #expenseForm="ngForm">……</form>`'
- en: <div *ngIf="!expenseForm.form.valid">
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div *ngIf="!expenseForm.form.valid">`'
- en: <p>Invalid form</p>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`<p>无效的表单</p>`'
- en: </div>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`</div>`'
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <ng-template TemplateRef element, either by using the ng-template element (with
    or without a template variable) or by using the TemplateRef in your component
    class, is the topic of the next section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用 ng-template 元素（带有或没有模板变量）或使用组件类中的 TemplateRef 来显示 `TemplateRef`
    元素。
- en: Using TemplateRef elements effectively
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有效使用 TemplateRef 元素
- en: Template references can be defined inside your HTML templates using the `ng-template`
    element. You can access a `TemplateRef` element in your component and directive
    classes using the `TemplateRef` class. The `TemplateRef` class and the `ng-template`
    element are the same thing in different forms.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引用可以在您的 HTML 模板中使用 `ng-template` 元素定义。您可以在组件和指令类中使用 `TemplateRef` 类访问 `TemplateRef`
    元素。`TemplateRef` 类和 `ng-template` 元素在形式上不同，但本质上是同一事物。
- en: A `TemplateRef` element can be used for many use cases. As shown at the start
    of the *Using template references and variables* section of this chapter, `TemplateRef`
    can be used for content projection when you need to combine the projected content
    with a structural directive such as `*ngFor`, `*ngIf`, or `*ngSwitch`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemplateRef` 元素可以用于许多用例。正如本章开头 *使用模板引用和变量* 部分的示例所示，当需要将投影内容与结构指令（如 `*ngFor`、`*ngIf`
    或 `*ngSwitch`）结合时，可以使用 `TemplateRef` 进行内容投影。'
- en: Another place where `TemplateRef` is used is within custom structural directives.
    Structural directives add or remove `TemplateRef` elements to/from the view container
    based on some logic. We added and removed template references to the view container
    in [*Chapter 3*](B21625_03.xhtml#_idTextAnchor058) when we created our custom
    structural directive.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemplateRef` 另一个被使用的地方是在自定义结构指令中。结构指令根据某些逻辑向视图容器添加或删除 `TemplateRef` 元素。当我们创建自定义结构指令时，我们在
    [*第 3 章*](B21625_03.xhtml#_idTextAnchor058) 中添加和删除了模板引用到视图容器。'
- en: A `TemplateRef` element can also be combined with template context to build
    truly dynamic components that can display different templates using different
    data sources. You can also use `TemplateRef` to display content in different places
    on your page – for example, when you have the same piece of content located on
    different locations of the page for your mobile and desktop designs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `TemplateRef` 元素也可以与模板上下文结合，构建真正动态的组件，可以使用不同的数据源显示不同的模板。您还可以使用 `TemplateRef`
    在页面的不同位置显示内容——例如，当您在移动和桌面设计中将相同的内容放置在页面的不同位置时。
- en: Another place where the `ng-template` element shines is when you need to render
    content conditionally based on the outcome of a `*ngIf` directive. Let’s continue
    by exploring the use cases for `TemplateRef` and create some examples.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-template` 元素在需要根据 `*ngIf` 指令的结果条件性地渲染内容时也表现出色。让我们继续探讨 `TemplateRef` 的用例，并创建一些示例。'
- en: Combining ng-template with *ngIf
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ng-template 与 *ngIf 结合
- en: 'You can display an `ng-template` element based on the outcome of a `*ngIf`
    statement. Often, you’ll see something like this in the HTML templates of Angular
    applications:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据 `*ngIf` 语句的结果显示 `ng-template` 元素。在 Angular 应用的 HTML 模板中，您经常会看到类似的东西：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can do the same thing with the `ng-template` element and define a template
    that is shown when the `*ngIf` statement isn’t met:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `ng-template` 元素做同样的事情，并定义一个在 `*ngIf` 语句不满足时显示的模板：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Instead of declaring the `*ngIf` directive on both `div` elements, we used
    the `*ngIf` `else` syntax. We referenced the template variable that was placed
    on the `ng-template` element for the `else` statement. Now, when there are no
    expenses, the loading template is shown. This is just a simple example, but if
    you have large templates to display conditionally, using templates helps separate
    the HTML. Also, when your `*ngIf` statement uses the `async` pipe, which is often
    the case, you cannot use the first approach:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在两个 `div` 元素上声明 `*ngIf` 指令，而是使用了 `*ngIf` `else` 语法。我们引用了放置在 `ng-template`
    元素上的模板变量，用于 `else` 语句。现在，当没有支出时，将显示加载模板。这只是一个简单的例子，但如果您需要显示条件性大模板，使用模板有助于分离 HTML。此外，当您的
    `*ngIf` 语句使用 `async` 管道时，这通常是情况，您不能使用第一种方法：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When you use the `async` pipe inside your `*ngIf` directive, you cannot use
    the logical not operator (`!`) in your template. You could set a value inside
    your component class using an RxJS pipe operator on your observable value. Still,
    it would be a lot simpler and cleaner to use the `*ngIf` `else` statement and
    an `ng-template` element, like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `*ngIf` 指令内部使用 `async` 管道时，你无法在模板中使用逻辑非运算符（`!`）。你可以在组件类中使用 RxJS 管道运算符在你的可观察值中设置一个值。然而，使用
    `*ngIf` `else` 语句和一个 `ng-template` 元素会更简单、更干净，如下所示：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using the syntax mentioned previously lets you use the `async` pipe to handle
    your observable and display an alternative template, so long as no value has been
    resolved by the observable or the result of the observable has been mapped to
    a false, null, or undefined value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面提到的语法，你可以使用 `async` 管道来处理你的可观察值并显示一个替代模板，只要可观察值没有解析出任何值，或者可观察值的结果被映射到假、空或未定义的值。
- en: 'You can even take it a step further and split up all your HTML into separate
    templates using the `*ngIf` `then-else` syntax combined with `ng-template` elements.
    Using the `if-then-else` syntax gives you a clear separation in your HTML and
    helps improve maintainability when you have large templates where you have to
    display multiple blocks of content conditionally:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以更进一步，将所有的 HTML 分割成单独的模板，使用 `*ngIf` `then-else` 语法结合 `ng-template` 元素来实现。使用
    `if-then-else` 语法在你的 HTML 中实现清晰的分离，并在你有大模板且需要条件性地显示多个内容块时，有助于提高可维护性：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What solution you use is primarily up to your preference and your team’s preference.
    There is no real convention or best practice. When working with the `async` pipe,
    I like to use the `ng-template` syntax instead of using a pipe operator on my
    observable to assign a component property, which can be used for the `*ngIf` statement
    with the logical not operator.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用什么解决方案主要取决于你的偏好和团队的偏好。没有真正的约定或最佳实践。当与 `async` 管道一起工作时，我喜欢使用 `ng-template`
    语法，而不是在我的可观察值上使用管道运算符来分配组件属性，这可以用于带有逻辑非运算符的 `*ngIf` 语句。
- en: For simple scenarios with synchronous values, I mostly use `*ngIf` and `*ngIf`
    with the logical not operator to display the correct HTML content – unless there
    are two large blocks of HTML content, in which case I prefer using templates.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的同步值场景，我通常使用 `*ngIf` 和带有逻辑非运算符的 `*ngIf` 来显示正确的 HTML 内容 - 除非有两个大块 HTML 内容，在这种情况下，我更喜欢使用模板。
- en: Now that you know how you can use the `ng-template` element combined with the
    `*ngIf` directive to display templates conditionally, let’s explore how to use
    `ng-template` to display templates in different locations on the same page.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用 `ng-template` 元素结合 `*ngIf` 指令来条件性地显示模板，让我们来探讨如何使用 `ng-template`
    在同一页面的不同位置显示模板。
- en: Displaying content in the correct spot using ng-template
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ng-template 在正确的位置显示内容
- en: 'Often, you have a design where the same block of content is placed on a different
    location of the page for your mobile and desktop view:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你的设计是这样的，同一块内容在移动端和桌面端视图中被放置在页面的不同位置：
- en: '![Figure 5.1: Content placement for the mobile and desktop views](img/B21625_05_1.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：移动端和桌面端视图的内容放置](img/B21625_05_1.jpg)'
- en: 'Figure 5.1: Content placement for the mobile and desktop views'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：移动端和桌面端视图的内容放置
- en: As shown in *Figure 5**.1*, on mobile, the content blocks, *C* and *D*, are
    shown below element *B*; on the desktop view, the same content is shown above
    element *B*. The same goes for block *A*, only in reverse. You don’t want to duplicate
    the HTML for blocks *A*, *C*, and *D* and place it once above and once below block
    *B*. Duplicating the HTML would break the **Don’t Repeat Yourself** (**DRY**)
    principle and result in a harder-to-maintain and read HTML template.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5.1* 所示，在移动端，内容块 *C* 和 *D* 显示在元素 *B* 下方；在桌面端视图，相同的内容显示在元素 *B* 之上。对于块 *A*，情况相反。你不想重复
    HTML 以块 *A*、*C* 和 *D* 为例，一次放在块 *B* 之上，一次放在块 *B* 之下。重复 HTML 会破坏 **不要重复自己** （**DRY**）原则，并导致更难以维护和阅读的
    HTML 模板。
- en: 'The `ng-template` element comes to the rescue in this scenario and lets you
    display the same template in different places on the page without duplicating
    the HTML:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`ng-template` 元素可以提供帮助，让你可以在页面的不同位置显示相同的模板，而无需重复 HTML：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see in the preceding HTML snippet, we used one `ng-template` element
    to define the HTML for the `A` block and one `ng-template` element to define the
    HTML for the `C` and `D` blocks combined. We display the templates using `ng-container`
    elements with an `ngTemplateOutlet` directive referencing the template variables
    declared on the `ng-template` elements.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述 HTML 片段所示，我们使用了一个 `ng-template` 元素来定义 `A` 块的 HTML，以及一个 `ng-template` 元素来定义
    `C` 和 `D` 块的 HTML。我们使用带有 `ngTemplateOutlet` 指令的 `ng-container` 元素显示模板，该指令引用在 `ng-template`
    元素上声明的模板变量。
- en: In this example, we used an `isMobile` Boolean to hide or show the correct `ng-container`
    elements, but you can also wrap them inside a `div` element and hide them with
    CSS. Using the `ng-template` element combined with the `ng-container` element,
    we only have to create the HTML for the `A`, `C`, and `D` blocks once, resulting
    in a cleaner and more maintainable HTML template.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个 `isMobile` 布尔值来隐藏或显示正确的 `ng-container` 元素，但你也可以将它们包裹在一个 `div`
    元素中，并通过 CSS 隐藏它们。使用 `ng-template` 元素和 `ng-container` 元素结合，我们只需创建一次 `A`、`C` 和 `D`
    块的 HTML，从而得到一个更干净、更易于维护的 HTML 模板。
- en: You can clean up the HTML even more and assign the `aboveB` and `belowB` templates
    inside your component class. I don’t like to add the additional logic for this
    inside my component class, but it’s a preference.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以进一步清理 HTML，并在你的组件类中分配 `aboveB` 和 `belowB` 模板。我不喜欢在我的组件类中添加额外的逻辑，但这只是我的个人偏好。
- en: 'Here’s an example of how you can handle this in your component class. First,
    adjust your HTML to this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个如何在你的组件类中处理这个例子。首先，调整你的 HTML 如下：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, inside your component class, get a reference to the `A` and `CD` templates
    by using the `@ViewChild()` decorator and create a variable for the `aboveB` and
    `belowB` `TemplateRef` elements:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的组件类中，通过使用 `@ViewChild()` 装饰器获取 `A` 和 `CD` 模板引用，并为 `aboveB` 和 `belowB`
    `TemplateRef` 元素创建一个变量：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Inside the `ngAfterViewInit` life cycle hook, you can assign the variables
    with the correct template:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ngAfterViewInit` 生命周期钩子中，你可以使用正确的模板分配变量：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If your component is set to the *OnPush* change detection strategy, you need
    to manually trigger change detection for the view to update and display the templates.
    If you don’t use the *OnPush* change detection strategy, your view will be updated
    automatically.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的组件设置为 *OnPush* 变更检测策略，你需要手动触发变更检测以更新和显示模板。如果你不使用 *OnPush* 变更检测策略，你的视图将自动更新。
- en: 'Something similar can be done when you have a page with multiple modals. Instead
    of defining multiple modal components and projecting the correct content into
    each modal, you can create one modal that contains an `ng-container` element with
    the `ngTemplateOutlet` directive and set the correct template when the modal is
    opened:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个包含多个模态的页面时，也可以做类似的事情。而不是定义多个模态组件并将正确的内容投影到每个模态中，你可以创建一个包含 `ng-container`
    元素和 `ngTemplateOutlet` 指令的模态，并在模态打开时设置正确的模板：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code snippet, we created an `openModel` function, which will
    be called from the HTML template when one of the modal components needs to be
    opened. We will pass along a title for the modal and a `TemplateRef` element for
    the content:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码片段中，我们创建了一个 `openModel` 函数，该函数将在需要打开其中一个模态组件时从 HTML 模板中被调用。我们将传递模态的标题和内容
    `TemplateRef` 元素：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the HTML, we now only display one modal and display the `TemplateRef` element
    inside, which is set in the `openModal` method in our component class. When the
    corresponding button is clicked, we send the `TemplateRef` element from the HTML
    template to our `openModal` function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 中，我们现在只显示一个模态，并在其中显示 `TemplateRef` 元素，该元素在组件类的 `openModal` 方法中设置。当相应的按钮被点击时，我们将
    HTML 模板中的 `TemplateRef` 元素发送到我们的 `openModal` 函数。
- en: As you may have noticed, the `ng-template` element and `ngTemplateOutlet` can
    bring a lot of flexibility to your components and let you easily display different
    templates in different locations. But `ng-template` can offer us even more flexibility
    by adding context and using `TemplateRef` as an input.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，`ng-template` 元素和 `ngTemplateOutlet` 可以给你的组件带来很多灵活性，并让你轻松地在不同的位置显示不同的模板。但通过添加上下文和使用
    `TemplateRef` 作为输入，`ng-template` 可以提供更多的灵活性。
- en: Creating dynamic components using templates and context
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板和上下文创建动态组件
- en: We have already seen how we can combine content projection and the `ng-template`
    element. In this section, we will use `TemplateRef` as a component input and provide
    additional context to `TemplateRef` to make it even more dynamic. A good example
    to showcase `ng-template` with context is by creating a dynamic select component,
    so go ahead and create a select component inside the `common-components` library,
    next to the `modal` and `display-scales` components.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: “我们已经看到了如何结合内容投影和 `ng-template` 元素。在本节中，我们将使用 `TemplateRef` 作为组件输入，并为 `TemplateRef`
    提供额外的上下文，使其更加动态。展示带有上下文的 `ng-template` 的一个好例子是创建一个动态选择组件，因此请创建一个选择组件，位于 `common-components`
    库中，紧挨着 `modal` 和 `display-scales` 组件。”
- en: 'Once you’ve created the `select` component, start by adding an input for the
    select options and a `TemplateRef` element. Also, add an input for the default
    `selectedIndex` options and an output for when the selection changes. Lastly,
    add a function to set the selected index when a selection is made and emit the
    selected value using the output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: “一旦创建了 `select` 组件，首先添加一个用于选择选项的输入和一个 `TemplateRef` 元素。此外，添加一个用于默认 `selectedIndex`
    选项的输入和一个输出，当选择发生变化时。最后，添加一个在做出选择时设置选定索引的函数，并使用输出发射选定值：”
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we will add the HTML for our dynamic select component. Start by creating
    a select element and an option for when there is no selected value. Next, add
    an `ng-container` element with a `*ngFor` directive looping over each option that’s
    received in the options input. We will also track the index of the `for` loop
    because we will use the index for the option value. Inside the `*ngFor` element,
    we’ll define an option element and another `ng-container` element that defines
    the `ngTemplateOutlet` directive to either display a default template or the template
    received as input. The default template can be used when the select options have
    no special display needs. In all other scenarios, a template can be provided through
    the `optionTemplate` input:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: “接下来，我们将添加动态选择组件的 HTML。首先创建一个选择元素和一个当没有选定值时的选项。接下来，添加一个带有 `*ngFor` 指令的 `ng-container`
    元素，该指令遍历在选项输入中接收到的每个选项。我们还将跟踪 `for` 循环的索引，因为我们将在选项值中使用该索引。在 `*ngFor` 元素内部，我们将定义一个选项元素和一个另一个
    `ng-container` 元素，该元素定义了 `ngTemplateOutlet` 指令，用于显示默认模板或作为输入接收到的模板。当选择选项没有特殊显示需求时，可以使用默认模板。在所有其他情况下，可以通过
    `optionTemplate` 输入提供模板：”
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, we also added the `ngTemplateOutletContext` directive to the
    `ng-container` element, which will display the template. The `ngTemplateOutletContext`
    directive is assigned to an object containing a `$implicit` property. The object
    you assign to the `ngTemplateOutletContext` directive can be used within the `ng-template`
    element, as we did in the preceding code snippet. You can use the `$implicit`
    value from the preceding code example inside an `ng-template` element. To use
    the `$implicit` value, you must use the `let-propertyName` syntax, as shown here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: “如您所见，我们还在 `ng-container` 元素中添加了 `ngTemplateOutletContext` 指令，它将显示模板。`ngTemplateOutletContext`
    指令被分配给一个包含 `$implicit` 属性的对象。分配给 `ngTemplateOutletContext` 指令的对象可以在 `ng-template`
    元素中使用，就像我们在前面的代码片段中所做的那样。您可以在 `ng-template` 元素中使用前面代码示例中的 `$implicit` 值。要使用 `$implicit`
    值，您必须使用 `let-propertyName` 语法，如下所示：”
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[shown property so that it can be used in the ng-template element using this
    syntax:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`[显示属性，以便可以使用此语法在 ng-template 元素中使用：`'
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <ng-template let-shownValue="shown">
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ng-template let-shownValue="shown">`'
- en: <div>{{shownValue}}</div>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div>{{shownValue}}</div>`'
- en: </ng-template>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`</ng-template>`'
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <bt-libs-select (selectedChange)="onOptionChange($event)" [options]="['Test',
    'Test 2']">
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`<bt-libs-select (selectedChange)="onOptionChange($event)" [options]="[''Test'',
    ''Test 2'']">`'
- en: </bt-libs-select>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`</bt-libs-select>`'
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[{expense: ''Food'',amount: 10},{expense: ''Gas'',amount: 20}]'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`[{expense: ''Food'',amount: 10},{expense: ''Gas'',amount: 20}]`'
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<ng-template #expenseSelect let-expense>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ng-template #expenseSelect let-expense>`'
- en: '<span>Product: {{ expense.expense }}, Amount: {{ expense.amount }}</span>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`<span>产品: {{ expense.expense }}, 金额: {{ expense.amount }}</span>`'
- en: </ng-template>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`</ng-template>`'
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: <bt-libs-select (selectedChange)="onOptionChange($event)" [optionTemplate]="expenseSelect"
    [options]="expenses">
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`<bt-libs-select (selectedChange)="onOptionChange($event)" [optionTemplate]="expenseSelect"
    [options]="expenses">`'
- en: </bt-libs-select>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`</bt-libs-select>`'
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <ng-container *ngComponentOutlet="widget.component" />
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ng-container *ngComponentOutlet="widget.component" />`'
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'export interface widget { component: Type<any> | null };'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`export interface widget { component: Type<any> | null };`'
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '@Input() widget: widget = {component: null};'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input() widget: widget = {component: null};`'
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: <bt-libs-widget-container *ngIf="activeWidget" [widget]="activeWidget"></bt-libs-widget-container>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`<bt-libs-widget-container *ngIf="activeWidget" [widget]="activeWidget"></bt-libs-widget-container>`'
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'activeWidget!: widget;'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'activeWidget!: widget;'
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: protected readonly cd = inject(ChangeDetectorRef);
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: protected readonly cd = inject(ChangeDetectorRef);
- en: showWeather = true;
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: showWeather = true;
- en: ngOnInit() {
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ngOnInit() {
- en: setInterval(() => {
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: setInterval(() => {
- en: 'this.activeWidget = { component: this.showWeather ? WeatherWidgetComponent
    : ClockWidgetComponent };'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'this.activeWidget = { component: this.showWeather ? WeatherWidgetComponent
    : ClockWidgetComponent };'
- en: this.showWeather = !this.showWeather;
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: this.showWeather = !this.showWeather;
- en: this.cd.detectChanges();
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: this.cd.detectChanges();
- en: '}, 5000)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '}, 5000)'
- en: '}'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<ng-container *ngComponentOutlet="widget.component; injector property:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <ng-container *ngComponentOutlet="widget.component; 注入属性：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'export interface WeatherWidgetData {city: string; message: string;}'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'export interface WeatherWidgetData {city: string; message: string;}'
- en: export const WEATHERWIDGET = new InjectionToken<WeatherWidgetData>('weather
    widgets');
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: export const WEATHERWIDGET = new InjectionToken<WeatherWidgetData>('weather
    widgets');
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: widgetData = inject(WEATHERWIDGET);
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: widgetData = inject(WEATHERWIDGET);
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<p>{{widgetData.city}}: {{widgetData.message}}</p>'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '<p>{{widgetData.city}}: {{widgetData.message}}</p>'
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '{ component: WeatherWidgetComponent }'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '{ component: WeatherWidgetComponent }'
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Injector.create()
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Injector.create()
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '{ providers: [{ provide: WEATHERWIDGET, useValue: { city: ''Amsterdam'', message:
    ''Sunny'' } }] }'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '{ providers: [{ provide: WEATHERWIDGET, useValue: { city: ''Amsterdam'', message:
    ''Sunny'' } }] }'
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Injector.create({ providers: [{ provide: WEATHERWIDGET, useValue: { city: ''Amsterdam'',
    message: ''Sunny'' } }] })'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'Injector.create({ providers: [{ provide: WEATHERWIDGET, useValue: { city: ''Amsterdam'',
    message: ''Sunny'' } }] })'
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '{ component: WeatherWidgetComponent, injector: Injector.create({ providers:
    [{ provide: WEATHERWIDGET, useValue: { city: ''Amsterdam'', message: ''Sunny''
    } }] }) }'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '{ component: WeatherWidgetComponent, injector: Injector.create({ providers:
    [{ provide: WEATHERWIDGET, useValue: { city: ''Amsterdam'', message: ''Sunny''
    } }] }) }'
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '@Input() city: string;'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '@Input() city: string;'
- en: '@Input() message: string;'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '@Input() message: string;'
- en: '[PRE61]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '<ng-container *ngComponentOutlet="widget.component; inputs property of the
    ngComponentOutlet directive needs to receive an object; in our case, we named
    the object widgetInputs. The object has a key for each input property of the component
    and a corresponding value. So, in our case, the widgetInputs object looks like
    this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <ng-container *ngComponentOutlet="widget.component; 输入属性 ngComponentOutlet 指令的
    inputs 属性需要接收一个对象；在我们的例子中，我们把这个对象命名为 widgetInputs。这个对象有一个键对应于组件的每个输入属性和相应的值。所以，在我们的例子中，widgetInputs
    对象看起来是这样的：
- en: '[PRE62]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Using the `inputs` property is a lot easier, but it can only provide objects
    with simple values. Using the `injector` property provides more flexibility because
    it can provide simple values but also classes, services, and everything else you
    can inject within Angular applications.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `inputs` 属性要容易得多，但它只能提供具有简单值的对象。使用 `injector` 属性提供了更多的灵活性，因为它可以提供简单值，也可以提供类、服务以及你可以在
    Angular 应用程序中注入的任何其他内容。
- en: Our widget system can already render components dynamically and provide injectors
    to the dynamically created components. But the dynamically rendered components
    are still loaded eagerly, so we still need to improve a bit so that we only load
    the widget components when they need to be rendered.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小部件系统已经可以动态渲染组件并提供注入器给动态创建的组件。但是，动态渲染的组件仍然会预先加载，所以我们还需要稍作改进，以确保我们只在需要渲染时加载小部件组件。
- en: Lazy loading dynamic components
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载动态组件
- en: To improve things further, we can lazy load our dynamic components. Currently,
    when you load the page, all widgets will be loaded upfront. It would be better
    if we only loaded the widget components if we needed them, or in other terms lazy
    loaded the components. We need to change our widget container component so that
    it lazy loads our dynamically rendered components.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步改进，我们可以懒加载我们的动态组件。目前，当你加载页面时，所有小部件都会预先加载。如果我们只在需要时加载小部件组件，或者换句话说，懒加载组件，那就更好了。我们需要更改我们的小部件容器组件，以便它懒加载我们的动态渲染组件。
- en: 'Let’s start by creating a new file named `widget-loaders.ts`. The `widget-loaders.ts`
    file will list some types and an object with the import statements for the lazy
    loaded widgets, a bit like lazy loading components with the router:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `widget-loaders.ts` 的新文件开始。`widget-loaders.ts` 文件将列出一些类型和一个带有懒加载小部件导入语句的对象，有点像使用路由懒加载组件：
- en: '[PRE63]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We started by creating a `widgetKeys` constant; here, you define all the keys
    you can use inside the `widgetLoaders` object. Next, we make a type of the `widgetKeys`
    constant to create a type-safe `WidgetLoader` type. The `WidgetLoader` type defines
    a key-value pair where the keys can only be values declared inside the `widgetKeys`
    constant.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个 `widgetKeys` 常量；在这里，你定义了可以在 `widgetLoaders` 对象内部使用的所有键。接下来，我们创建了一个
    `widgetKeys` 常量的类型，以创建一个类型安全的 `WidgetLoader` 类型。`WidgetLoader` 类型定义了一个键值对，其中键只能是
    `widgetKeys` 常量中声明的值。
- en: Next, we created the `widgetLoaders` object, which types with the `WidgetLoader`
    type. The `widgetLoaders` object will hold key-value pairs where the keys are
    values from the `widgetKeys` constant and the values import statements for the
    lazy loaded widgets.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了 `widgetLoaders` 对象，它使用 `WidgetLoader` 类型。`widgetLoaders` 对象将包含键值对，其中键是来自
    `widgetKeys` 常量的值，值是懒加载小部件的导入语句。
- en: Lastly, we created a `WidgetOption` type, which allows you to take a single
    value of the `widgetLoaders` object and nothing else. Now that we’ve created a
    type-safe way to define and select widget loaders, we can start to adjust the
    widget container component.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个 `WidgetOption` 类型，它允许你从 `widgetLoaders` 对象中获取单个值，而无需其他任何东西。现在，我们已经创建了一种类型安全的方式来定义和选择小部件加载器，我们可以开始调整小部件容器组件。
- en: 'First, we must remove the widget input we had and replace it with a regular
    input property. Then, we can add an input for the `injector` property and one
    for a `WidgetOption` property from the `widgetLoaders` object:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须移除我们已有的小部件输入，并用一个常规输入属性替换它。然后，我们可以添加一个 `injector` 属性的输入和一个来自 `widgetLoaders`
    对象的 `WidgetOption` 属性的输入：
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You also need to inject `ChangeDetectorRef` because we have to trigger change
    detection manually:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要注入 `ChangeDetectorRef`，因为我们必须手动触发变更检测：
- en: '[PRE65]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, you must add the `ngOnChanges` life cycle hook with the `async` keyword
    in front because we will use async `await` to load the dynamic component:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你必须添加带有 `async` 关键字的 `ngOnChanges` 生命周期钩子，因为我们将会使用异步 `await` 来加载动态组件：
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Inside the `ngOnChanges` life cycle hook, we will get the current value of
    the `widgetLoader` input:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ngOnChanges` 生命周期钩子内部，我们将获取 `widgetLoader` 输入的当前值：
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we’ll use the `widgetLoader` value to lazy load the widget component.
    When the widget component is loaded, we will assign the widget property using
    the lazy-loaded component and the `injector` property. Lastly, we need to trigger
    change detection to reflect the changes within the UI:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `widgetLoader` 值来懒加载小部件组件。当小部件组件加载完成后，我们将使用懒加载的组件和 `injector` 属性分配小部件属性。最后，我们需要触发变更检测以反映
    UI 中的更改：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'With the preceding changes added to the widget container component, everything
    is in place, and you can lazy load and render widget components dynamically. To
    test this, we need to use the widget container component inside another component
    and give it a widget loader and injector as input:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在将前面的更改添加到小部件容器组件后，一切就绪，你可以动态地懒加载和渲染小部件组件。为了测试这一点，我们需要在另一个组件中使用小部件容器组件，并给它一个小部件加载器和注入器作为输入：
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As an example, if you want to alternate between the clock and weather widget,
    you can add the following code to the component class where you’ve added the widget
    container in the template:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想交替显示时钟和天气小部件，你可以在模板中添加小部件容器的组件类中添加以下代码：
- en: '[PRE70]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When you inspect the **Network** tab of your browser’s developer tools, you
    will see the weather and clock widget components being loaded when they enter
    the view for the first time. When the widgets are displayed again, and the components
    are already loaded, the browser won’t load them again because the browser caches
    them for you. Now, you have a truly dynamic widget system where you can lazy load
    and render widgets on demand.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查浏览器开发者工具的 **网络** 选项卡时，你会看到当它们第一次进入视图时，天气和时钟小部件组件正在被加载。当小部件再次显示，并且组件已经加载时，浏览器不会再次加载它们，因为浏览器已经为你缓存了它们。现在，你有一个真正动态的小部件系统，你可以按需懒加载和渲染小部件。
- en: Rendering components dynamically using the defer control flow
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用延迟控制流动态渲染组件
- en: In Angular 17, the `defer-widget`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 17 中，`defer-widget`。
- en: 'This `DeferWidgetComponent` will have the same functionality as our `widget-container`
    component, only it will use the defer control flow instead of the `ngComponentOutlet`
    directive. You can start by creating a component named `defer-widget`, next to
    the `widget-container` component. Once you’ve created the component. create a
    `widgets.enum.ts` file in the newly created `defer-widget` folder. Add the following
    `enum` inside the `widgets.enum.ts` file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `DeferWidgetComponent` 将具有与我们的 `widget-container` 组件相同的功能，只是它将使用延迟控制流而不是
    `ngComponentOutlet` 指令。你可以从创建一个名为 `defer-widget` 的组件开始，紧挨着 `widget-container`
    组件。一旦你创建了组件，就在新创建的 `defer-widget` 文件夹中创建一个 `widgets.enum.ts` 文件。在 `widgets.enum.ts`
    文件中添加以下 `enum`：
- en: '[PRE71]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, you need to add an input for the active widget, the widget data, and
    a property with a reference to the `Widgets` enum inside `DeferWidgetComponent`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要为活动小部件添加一个输入，即小部件数据，并在`DeferWidgetComponent`内部添加一个引用`Widgets`枚举的属性：
- en: '[PRE72]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Inside the HTML template of `DeferWidgetComponent`, you need to add your widget
    components inside a defer block. Defer blocks receive a trigger as a parameter.
    When the defer trigger is triggered, the defer block will load and render the
    content that is inside the defer block. For your widget component, you need to
    use the `when` trigger. The `when` trigger loads and renders the content when
    the provided condition resolves to `true`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DeferWidgetComponent`的HTML模板内部，您需要在延迟块内添加您的组件。延迟块接收一个触发器作为参数。当延迟触发器被触发时，延迟块将加载并渲染延迟块内的内容。对于您的小部件组件，您需要使用`when`触发器。`when`触发器在提供的条件解析为`true`时加载并渲染内容。
- en: 'We also want our content to hide again when the condition is `false` again.
    To hide your content when the condition is `false`, you also need to add a `*ngIf`
    directive or use the `if` control flow. I will use the `*``ngIf` directive:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望当条件再次为`false`时，内容能够再次隐藏。要隐藏当条件为`false`时的内容，您还需要添加一个`*ngIf`指令或使用`if`控制流。我将使用`*ngIf`指令：
- en: '[PRE73]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Without the `*ngIf` directive or if control flow syntax, the widget will not
    disappear if the condition returns `false`. The `when` statement of the `defer`
    syntax will not evaluate the condition again after it has resolved to true.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`*ngIf`指令或控制流语法，当条件返回`false`时，小部件将不会消失。`defer`语法的`when`语句在解析为`true`后不会再次评估条件。
- en: The aforementioned code is everything you need to lazy load and render widgets.
    As you can see, this is a lot easier compared to using the `ngComponentOutlet`
    directive.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是您需要用于懒加载和渲染小部件的所有内容。如您所见，这比使用`ngComponentOutlet`指令要简单得多。
- en: 'Because we already had some code in place, we still need to make some changes
    to the weather widget for our new defer solution to work. Inside the weather widget
    component, you have a `widgetData` property. You can place this under `comment`
    and replace it with a `@Input()` property, like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在某些地方放置了一些代码，我们仍然需要对天气小部件进行一些更改，以便我们的新延迟解决方案能够正常工作。在天气小部件组件内部，您有一个`widgetData`属性。您可以将它放在`comment`下，并用一个`@Input()`属性替换，如下所示：
- en: '[PRE74]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `widgetData` property we commented out is used for the `ngComponentOutlet`
    directive approach. For our new defer approach, we will use a regular component,
    `@Input()`. You can also update the HTML template of the weather component and
    only render the city and message if we receive the `widgetData` property:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前注释掉的`widgetData`属性用于`ngComponentOutlet`指令方法。对于我们的新延迟方法，我们将使用常规组件，`@Input()`。您还可以更新天气组件的HTML模板，并且只有在接收到`widgetData`属性时才渲染城市和消息：
- en: '[PRE75]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, everything should work! To test `DeferWidgetComponent`, we can use it
    in `expensesOverviewComponent`, where we now use `widgetContainerComponent`. In
    the HTML template, you can swap the old widget container with the new defer widget:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切应该都能正常工作！为了测试`DeferWidgetComponent`，我们可以在`expensesOverviewComponent`中使用它，我们现在使用`widgetContainerComponent`。在HTML模板中，您可以替换旧的容器小部件为新延迟小部件：
- en: '[PRE76]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, we only need `widget` and `widgetData` properties inside `expensesOverviewComponent`
    and must set their values. You can comment out the old `widget` and `injector`
    properties we used for the widget container and add these two properties instead:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在`expensesOverviewComponent`内部设置`widget`和`widgetData`属性。您可以取消注释我们之前用于小部件容器的旧`widget`和`injector`属性，并添加这两个属性：
- en: '[PRE77]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Lastly, we have to change the logic inside `setInterval`. Once again, you can
    comment out the old code we used to alternate the weather and clock widgets for
    the widgets container and replace it with this code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须更改`setInterval`内部的逻辑。再次，您可以取消注释我们之前用于交替小部件容器中天气和时钟小部件的旧代码，并用此代码替换：
- en: '[PRE78]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now, when you save everything, the new defer widget component should work identically
    to the widget container component. After 5 seconds, the clock widget will be lazy
    loaded and rendered, and 5 seconds after that, the weather widget will be lazy
    loaded and rendered. The two widgets will alternate every 5 seconds.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您保存一切时，新的延迟小部件组件应该与容器小部件组件工作得完全一样。5秒后，时钟小部件将被懒加载并渲染，再过5秒，天气小部件将被懒加载并渲染。这两个小部件将每5秒交替一次。
- en: With that, you’ve created a widget component with lazy loaded widgets using
    the `ngComponentOutlet` directive and the defer control flow syntax. With the
    `ngComponentOutlet` directive, you can provide injectors and you don’t have to
    remove the widgets with the `*ngIf` directive, but overall, the defer control
    flow syntax feels a lot cleaner and easier.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经使用`ngComponentOutlet`指令和延迟控制流语法创建了一个带有懒加载小部件的组件。使用`ngComponentOutlet`指令，你可以提供注入器，而且不需要使用`*ngIf`指令来移除小部件，但总体来说，延迟控制流语法感觉要干净和容易得多。
- en: Summary
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter! First, you learned how to make components
    more flexible using content projection. We created a modal component and showcased
    content projection with a single slot and multiple slots. We also learned that
    you can’t combine structural directives on projected content.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多！首先，你学习了如何使用内容投影使组件更加灵活。我们创建了一个模态组件，并展示了使用单个插槽和多个插槽的内容投影。我们还了解到，你无法在投影内容上组合结构指令。
- en: Next, we did a deep dive into template variables and template references. You
    learned how to create flexible and dynamic components using `ng-template`, how
    to access the values of components and input properties using template variables,
    and how to display different templates based on specific conditions. You also
    learned how to provide context to `ng-template` elements to build truly dynamic
    components that can fit almost all design needs you could have for a component.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们深入探讨了模板变量和模板引用。你学习了如何使用`ng-template`创建灵活和动态的组件，如何使用模板变量访问组件值和输入属性，以及如何根据特定条件显示不同的模板。你还学习了如何为`ng-template`元素提供上下文，以构建真正动态的组件，这些组件可以满足你对组件的所有设计需求。
- en: Lastly, you learned about dynamic component rendering and loading. You learned
    when you should use dynamically rendered or loaded components and how you can
    dynamically render and lazy load components at runtime using the `ngComponentOutlet`
    and `@``defer` syntax.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了关于动态组件渲染和加载的内容。你学习了何时应该使用动态渲染或加载的组件，以及如何使用`ngComponentOutlet`和`@defer`语法在运行时动态渲染和懒加载组件。
- en: In the next chapter, we will start to learn about conventions and design patterns
    within Angular so that we can improve the setup and implementation of our code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始学习Angular中的约定和设计模式，以便我们可以改进代码的设置和实现。
- en: '[PRE79]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
