- en: Typography - Control Font Look and Feel
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字体排版 - 控制字体外观和感觉
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Types of typography
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体排版类型
- en: Using theme colors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主题颜色
- en: Aligning text
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本对齐
- en: Wrapping text
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本换行
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The `Typography` component is used by Material-UI to render text on the screen.
    You can use `Typography` on its own, but it is also used internally by other Material-UI
    components that render text. Instead of using other HTML elements to render your
    text, using `Typography` components allows Material-UI to handle the application
    of theme styles using consistent font types, and also handle font behavior in
    a uniform way.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`Typography`组件由Material-UI用于在屏幕上渲染文本。你可以单独使用`Typography`，但它也被其他渲染文本的Material-UI组件内部使用。使用`Typography`组件而不是其他HTML元素来渲染你的文本，允许Material-UI使用一致的字体类型应用主题样式，并且以统一的方式处理字体行为。'
- en: Types of typography
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字体排版类型
- en: The `Typography` component is used any time you want to render text in a Material-UI
    application. The type of text, or variant, is specified as a string value that's
    passed to the `variant` property.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想在Material-UI应用程序中渲染文本时，`Typography`组件就会被使用。文本类型或变体被指定为一个字符串值，该值传递给`variant`属性。
- en: How to do it...
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here''s an example that shows how to render all of the available `Typography`
    variants:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了如何渲染所有可用的`Typography`变体：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s what the heading variants look like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是标题变体的样子：
- en: '![](img/b59dd456-677f-42c8-9c42-947eb3c87276.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b59dd456-677f-42c8-9c42-947eb3c87276.png)'
- en: 'Finally, here are what the remaining variants look like:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是剩余变体的样子：
- en: '![](img/f8e3d466-87b7-46a6-aac3-5b88d64e8c54.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8e3d466-87b7-46a6-aac3-5b88d64e8c54.png)'
- en: How it works...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The value that you pass to the `variant` property determines the styles that
    are applied to the text. The styles for each of these variants are defined by
    the theme, and can be customized from theme to theme.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您传递给`variant`属性的值决定了应用于文本的样式。每个这些变体的样式由主题定义，并且可以从一个主题定制到另一个主题。
- en: It can be tempting to add your own variant names, or to add font styles outside
    of the typography variants. I would advise against this, because doing so breaks
    the common font vocabulary based on Material Design. If you stray from the typography
    variant conventions, you'll end up with variant names that only make sense to
    you, or worse, variants that don't work because of font styles applied to text
    from outside of the typography system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会诱使你添加自己的变体名称，或者在外部添加字体样式。我建议不要这样做，因为这样做会破坏基于Material Design的通用字体词汇。如果你偏离了字体变体约定，你最终会得到只有你才能理解的变体名称，或者更糟糕的是，由于从字体系统外部应用到文本上的字体样式，变体将无法工作。
- en: There's more...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you want your `Typography` component to inherit the variant styles from
    its parent, you can use the `inherit` variant value, as shown in the following
    example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的`Typography`组件从其父组件继承变体样式，你可以使用`inherit`变体值，如下面的示例所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The parent `Typography` component uses the `title` variant. It also changes
    its component to be a `div` element, because it's not actually rendering text
    as direct children—think of it as a container for font styles. Inside, there are
    three child `Typography` components. The first two have `inherit` as the `variant`
    property value, so they'll actually get the `title` variant. The third `Typography`
    child uses `caption` as its variant, so it will not inherit `title`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 父`Typography`组件使用`title`变体。它还将它的组件更改为`div`元素，因为它实际上并没有将文本作为直接子元素渲染——把它看作是字体样式的容器。在里面，有三个子`Typography`组件。前两个将`inherit`作为`variant`属性值，因此它们实际上会得到`title`变体。第三个`Typography`子组件使用`caption`作为其变体，因此它不会继承`title`。
- en: 'Here''s what the result looks like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是结果的样子：
- en: '![](img/2c6d9f33-4905-4797-8f12-c97b4a0cec62.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c6d9f33-4905-4797-8f12-c97b4a0cec62.png)'
- en: 'One adjustment to this approach that you might consider is to have `inherit`
    as the default variant. This way, you don''t have to keep typing `variant="inherit"`
    if you have lots of child `Typography` components that need to inherit font styles.
    Here''s a component that does this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能考虑对这个方法的一个调整是将`inherit`作为默认变体。这样，如果你有很多需要继承字体样式的子`Typography`组件，你就不必一直输入`variant="inherit"`。以下是一个执行此操作的组件：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `MyTypography` component will render a `Typography` component with a `variant`
    value of `inherit`, but only if the `variant` property wasn''t passed. Let''s
    change the preceding code to use this new component:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyTypography` 组件将渲染一个 `Typography` 组件，其 `variant` 值为 `inherit`，但前提是未传递 `variant`
    属性。让我们将前面的代码更改为使用这个新组件：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result is exactly the same. The only difference is that now you don't need
    to provide the `variant` property for variants that you want to inherit.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 结果完全相同。唯一的区别是现在你不需要为想要继承的变体提供 `variant` 属性。
- en: See also
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '`Typography` demos: [https://material-ui.com/style/typography/](https://material-ui.com/style/typography/)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Typography` 演示：[https://material-ui.com/style/typography/](https://material-ui.com/style/typography/)'
- en: '`Typography` API documentation: [https://material-ui.com/api/typography/](https://material-ui.com/api/typography/)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Typography` API 文档：[https://material-ui.com/api/typography/](https://material-ui.com/api/typography/)'
- en: Using theme colors
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主题颜色
- en: Text that is rendered using the `Typography` component can use colors from the
    Material-UI theme used by the app.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Typography` 组件渲染的文本可以使用应用使用的 Material-UI 主题中的颜色。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'For this example, you''ll find a Storybook control that allows you to change
    the color of the text using predefined Color names from the theme, as shown in
    the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你将找到一个 Storybook 控件，允许你使用主题中预定义的颜色名称更改文本颜色，如下面的截图所示：
- en: '![](img/32c1c6cc-1e5d-4025-89bc-2ef334b41d34.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32c1c6cc-1e5d-4025-89bc-2ef334b41d34.png)'
- en: 'Here''s the source for the example that uses the selected color by passing
    it to the `color` property of each `Typography` component:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用通过传递给每个 `Typography` 组件的 `color` 属性来选择颜色的示例的源代码：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s walk through how each of these colors change the appearance of the different
    `Typography` variants:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些颜色如何改变不同 `Typography` 变体的外观：
- en: '| Default | The `default` color uses whatever color is defined in the styles
    for the `Typography` variant in question | ![](img/bec821cd-8a6c-4af8-9d2b-0a197b5989d0.png)
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 默认 | `default` 颜色使用为所讨论的 `Typography` 变体定义的任何颜色 | ![图片](img/bec821cd-8a6c-4af8-9d2b-0a197b5989d0.png)
    |'
- en: '| Error | The `error` color applies the `palette.error.main` theme color to
    the text | ![](img/6c45a04b-a9a9-4744-8112-17c2b3ac12ee.png) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | `error` 颜色将 `palette.error.main` 主题颜色应用到文本上 | ![图片](img/6c45a04b-a9a9-4744-8112-17c2b3ac12ee.png)
    |'
- en: '| Inherit | The `Typography` component will inherit the font color of its parent
    component | ![](img/f735faab-8cdd-4293-99ec-ff5efa2db060.png) |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 继承 | `Typography` 组件将继承其父组件的字体颜色 | ![图片](img/f735faab-8cdd-4293-99ec-ff5efa2db060.png)
    |'
- en: '| Primary | The `primary` color applies the `palette.primary.main` theme color
    to the text | ![](img/2670db74-17d2-4d95-ace4-2c19488c4a58.png) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 主要 | `primary` 颜色将 `palette.primary.main` 主题颜色应用到文本上 | ![图片](img/2670db74-17d2-4d95-ace4-2c19488c4a58.png)
    |'
- en: '| Secondary | The `secondary` color applies the `palette.secondary.main` theme
    color to the text | ![](img/16e4bc47-53ff-4f27-97a1-53d24f2eb71e.png) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 次要 | `secondary` 颜色将 `palette.secondary.main` 主题颜色应用到文本上 | ![图片](img/16e4bc47-53ff-4f27-97a1-53d24f2eb71e.png)
    |'
- en: '| Text Primary | The `textPrimary` color applies the `palette.text.primary`
    theme color to the text |       ![](img/98b25a5e-9c81-422c-a004-c5fada42004c.png)
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 文本主要 | `textPrimary` 颜色将 `palette.text.primary` 主题颜色应用到文本上 | ![图片](img/98b25a5e-9c81-422c-a004-c5fada42004c.png)
    |'
- en: '| Text Secondary | The `textSecondary` color applies the `palette.text.secondary` theme
    color to the text | ![](img/bab90430-9c5a-4ff3-98e9-fd073be471d4.png) |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 文本次要 | `textSecondary` 颜色将 `palette.text.secondary` 主题颜色应用到文本上 | ![图片](img/bab90430-9c5a-4ff3-98e9-fd073be471d4.png)
    |'
- en: See also
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '`Typography` demos: [https://material-ui.com/style/typography/](https://material-ui.com/style/typography/)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Typography` 演示：[https://material-ui.com/style/typography/](https://material-ui.com/style/typography/)'
- en: '`Typography` API documentation: [https://material-ui.com/api/typography/](https://material-ui.com/api/typography/)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Typography` API 文档：[https://material-ui.com/api/typography/](https://material-ui.com/api/typography/)'
- en: Aligning text
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对齐文本
- en: Aligning text in user interfaces is common. Unfortunately, it isn't easy. With
    Material-UI grids and typography, you can create abstractions that make it a little
    easier to align text.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面中对齐文本是常见的。不幸的是，这并不容易。使用 Material-UI 网格和排版，你可以创建抽象，使对齐文本变得稍微容易一些。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'If you''re trying to align your text horizontally to the left, right, or center,
    then you can use the `align` property of your `Typography` component, as demonstrated
    in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图将文本水平对齐到左、右或居中，那么你可以使用 `Typography` 组件的 `align` 属性，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is shorthand for using the `text-align` style, so that you don't have to
    keep adding CSS to your components for the more common alignment scenarios. However,
    sometimes you need the ability to align your text both horizontally and vertically.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种使用 `text-align` 样式的简写，这样你就不必为更常见的对齐场景不断向你的组件添加 CSS。然而，有时你需要能够水平和垂直地对齐你的文本。
- en: 'For example, let''s say that you have a 200x200 `Paper` element, and you need
    the ability to render text in the bottom-right corner. Let''s illustrate this
    example with some code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个 200x200 的 `Paper` 元素，你需要能够在右下角渲染文本。让我们通过一些代码来演示这个例子：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here''s what you''ll see when the screen first loads:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次加载时，你会看到以下内容：
- en: '![](img/c3ee840e-943d-41c2-8e3a-49d423ad693a.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3ee840e-943d-41c2-8e3a-49d423ad693a.png)'
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are two Storybook controls for aligning the text, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook 中有两个用于对齐文本的控制，如下所示：
- en: '![](img/02a88e6b-a19a-4b6b-ae7d-ce4671f52b3c.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02a88e6b-a19a-4b6b-ae7d-ce4671f52b3c.png)'
- en: The horizontal alignment control changes the `horizontalAlign` property that
    is passed to the `MyPaper` component. Likewise, the vertical alignment control
    changes the `verticalAlign` property value. The `horizontalAlign` value is passed
    to the `justify` property of the `Grid` component, while the `verticalAlign` property
    goes to the `alignContent` property.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 水平对齐控制会改变传递给 `MyPaper` 组件的 `horizontalAlign` 属性。同样，垂直对齐控制会改变 `verticalAlign`
    属性的值。`horizontalAlign` 值传递给 `Grid` 组件的 `justify` 属性，而 `verticalAlign` 属性则传递给 `alignContent`
    属性。
- en: What's neat about the `Grid` components is that you can pass them a `component`
    property and this will be rendered instead of the `div` element that's rendered
    by default. In other words, you can make the `Paper` component a grid container
    and the `Typography` component that you're trying to align a grid item. You don't
    have to render the `Grid` components and then your actual content as children.
    You can make your content the grid.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid` 组件的妙处在于你可以传递一个 `component` 属性，这将渲染默认渲染的 `div` 元素。换句话说，你可以将 `Paper` 组件变成一个网格容器，而你要对齐的
    `Typography` 组件则变成一个网格项。你不需要先渲染 `Grid` 组件，然后再将实际内容作为子元素渲染。你可以使你的内容成为网格。'
- en: 'Here''s what the grid looks like when you set `justify="center"` and `alignContent="flex-end"`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置 `justify="center"` 和 `alignContent="flex-end"` 时，网格看起来是这样的：
- en: '![](img/a800dcfa-373a-478a-91fe-2856d96b66a6.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a800dcfa-373a-478a-91fe-2856d96b66a6.png)'
- en: 'And here''s what it looks like what you set `justify="flex-end"` and `alignContent="flex-start"`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了当你设置 `justify="flex-end"` 和 `alignContent="flex-start"` 时它看起来是什么样子：
- en: '![](img/46a27b1a-014c-4860-adc2-c830410f84dc.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46a27b1a-014c-4860-adc2-c830410f84dc.png)'
- en: See also
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Typography` demos: [https://material-ui.com/style/typography/](https://material-ui.com/style/typography/)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Typography` 演示：[https://material-ui.com/style/typography/](https://material-ui.com/style/typography/)'
- en: '`Typography` API documentation: [https://material-ui.com/api/typography/](https://material-ui.com/api/typography/)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Typography` API 文档：[https://material-ui.com/api/typography/](https://material-ui.com/api/typography/)'
- en: Wrapping text
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本换行
- en: The `Typography` components that you use to render text in your application
    need to be aware of scenarios where text wraps. This means that, when there isn't
    enough horizontal space to render a line of text, it continues onto the next line.
    This can have undesirable layout consequences if you don't anticipate how text
    might wrap.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你在应用程序中用于渲染文本的 `Typography` 组件需要知道文本换行的情况。这意味着，当没有足够的空间渲染一行文本时，它将继续到下一行。如果你没有预料到文本可能会换行，这可能会导致不理想的布局后果。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s look at an example where you have two `Paper` components that render
    text using `Typography` components:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，其中你有两个 `Paper` 组件，它们使用 `Typography` 组件来渲染文本：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s what you''ll see when the screen first loads:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次加载时，你会看到以下内容：
- en: '![](img/854a205f-4486-4388-9972-1f48a25029c3.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/854a205f-4486-4388-9972-1f48a25029c3.png)'
- en: The first `Paper` component doesn't have a set the `height` component, and has
    a single line of text that fits within the current screen width. The second `Paper`
    component does have a set `height`, and the text in the second `Paper` component
    is wrapped so that it fits on the screen.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `Paper` 组件没有设置 `height` 组件，并且只有一行文本适合当前屏幕宽度。第二个 `Paper` 组件设置了 `height`，第二个
    `Paper` 组件中的文本被换行，以便适合屏幕。
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, let''s try changing the screen resolution, making the available width
    in which to render text smaller. Here''s what you''ll see:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试更改屏幕分辨率，使可用于渲染文本的可用宽度更小。你会看到以下内容：
- en: '![](img/1b4c4ee4-0539-4002-9153-838622c59b28.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b4c4ee4-0539-4002-9153-838622c59b28.png)'
- en: There are wrapping issues in both `Paper` components. In the first, the wrapped
    text causes the the height of the component to change because it doesn't have
    a fixed height. This has a domino effect with regard to layout that may or may
    not be problematic, depending on your design. In the second `Paper` component, `height`
    is fixed, which means that the wrapped text overflows out of the component, which
    looks terrible.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`Paper`组件中都有换行问题。在第一个中，换行文本导致组件的高度改变，因为它没有固定的高度。这可能会对布局产生多米诺效应，这可能是问题也可能是问题，这取决于你的设计。在第二个`Paper`组件中，`height`是固定的，这意味着换行文本会溢出组件，看起来很糟糕。
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s fix the text wrapping in both of the `Paper` components in this example.
    The following is a modified version:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修复这个例子中两个`Paper`组件中的文本换行问题。以下是一个修改后的版本：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, when you shrink the width of the screen, this is what the two components
    look like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你缩小屏幕宽度时，这两个组件看起来是这样的：
- en: '![](img/221fc2d0-bfe2-490b-a0b8-eb9d04a983b2.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/221fc2d0-bfe2-490b-a0b8-eb9d04a983b2.png)'
- en: The first `Paper` component was fixed by adding the `noWrap` property to the
    `Typography` component. This will ensure that the `height` component of the component
    never changes, by hiding text overflow and adding an ellipsis to indicate that
    the text has been truncated. This works because you know ahead of time that this
    is just a single line of text that will never need to wrap when shown on wider
    displays. The second `Paper` component, on the other hand, needs a different approach,
    because it does need the ability to wrap.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`Paper`组件通过向`Typography`组件添加`noWrap`属性来修复。这将确保组件的`height`组件永远不会改变，通过隐藏文本溢出并添加省略号来表示文本已被截断。这是因为你知道这只是一行文本，在更宽的显示上永远不会需要换行。另一方面，第二个`Paper`组件需要不同的方法，因为它确实需要换行的能力。
- en: The solution was to use the Material-UI media query functionality. The call
    to `theme.breakpoints.down('xs')` results in a class name that's prefixed by a
    media query for the specified breakpoint, in this case, `xs`. Now, when the screen
    width shrinks to the `xs` breakpoint, the same styles used for the `noWrap` property
    are applied to the component.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用Material-UI的媒体查询功能。调用`theme.breakpoints.down('xs')`会导致一个以媒体查询为前缀的类名，在这种情况下，是`xs`。现在，当屏幕宽度缩小到`xs`断点时，应用于组件的`noWrap`属性的相同样式被应用。
- en: See also
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Typography` demos: [https://material-ui.com/style/typography/](https://material-ui.com/style/typography/)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Typography` 演示：[https://material-ui.com/style/typography/](https://material-ui.com/style/typography/)'
- en: '`Typography` API documentation: [https://material-ui.com/api/typography/](https://material-ui.com/api/typography/)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Typography` API 文档：[https://material-ui.com/api/typography/](https://material-ui.com/api/typography/)'
