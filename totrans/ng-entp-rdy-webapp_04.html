<html><head></head><body>
  <div id="_idContainer181">
    <h1 class="chapterNumber">4</h1>
    <h1 class="chapterTitle" id="_idParaDest-115">Automated Testing, CI, and Release to Production</h1>
    <p class="normal">Ship it, or it never happened! In <em class="italics">Chapter 3</em>, <em class="italics">Creating a Basic Angular App</em>, you created a local weather application that could retrieve current weather data. You have created some amount of value in doing this; however, if you don't put your app on the web, you end up creating zero value. This motivation to ship your work is prevalent in many industries. However, delivering a piece of work to someone else or opening it up to public scrutiny can be terrifying. In software engineering, delivering anything is difficult; delivering something to production is even more difficult. This chapter is going to help you implement a <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) pipeline. A CI pipeline is going to help you achieve frequent, reliable, high-quality, and flexible releases.</p>
    <p class="normal">Frequent and reliable releases are only possible if we have a set of automated tests that can quickly verify the correctness of our code for us. The app we created in the previous chapter has failing unit and <strong class="bold">end-to-end</strong> (<strong class="bold">e2e</strong>) tests. We need to fix these unit tests and then ensure that they never break again by leveraging GitHub flow and CircleCI. Then we're going to cover how you can deliver your Angular app to the web. In <em class="italics">Chapter 9</em>, <em class="italics">DevOps Using Docker</em>, we are going to cover <strong class="bold">Continuous Delivery</strong> (<strong class="bold">CD</strong>) pipelines, which can also automate your delivery.</p>
    <div class="packt_tip">
      <p>Check out my 2018 talk, <em class="italics">Ship It or It Never Happened: The Power of Docker, Heroku &amp; CircleCI</em>, at <a href="https://bit.ly/ship-it-or-it-never-happened"><span class="url">https://bit.ly/ship-it-or-it-never-happened</span></a>.</p>
    </div>
    <p class="normal">This chapter covers:</p>
    <ul>
      <li class="list">Unit testing with test doubles</li>
      <li class="list">Angular unit tests using Jasmine</li>
      <li class="list">Angular e2e tests</li>
      <li class="list">GitHub flow</li>
      <li class="list">Production readiness</li>
      <li class="list">CI using CircleCI </li>
      <li class="list">Deploying an app on the web using Vercel Now</li>
    </ul>
    <p class="normal">The most up-to-date versions of the sample code for the book are on GitHub at the following linked repository. The repository contains the code in its final and complete state. You can verify your progress at the end of this chapter by looking for the end-of-chapter snapshot of code under the <code class="Code-In-Text--PACKT-">projects</code> folder.</p>
    <p class="normal">For <em class="italics">Chapter 4</em>:</p>
    <ol>
      <li class="list">Clone the repo <a href="https://github.com/duluca/local-weather-app "><span class="url">https://github.com/duluca/local-weather-app</span></a></li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm install</code> on the root folder to install dependencies</li>
      <li class="list">The code sample for this chapter is in the following sub-folder:
        <pre class="programlisting"><code class="hljs">projects/ch4
</code></pre>
      </li>
      <li class="list">To run the Angular app for this chapter, execute:
        <pre class="programlisting"><code class="hljs nginx"><span class="hljs-attribute">npx</span> ng serve ch4
</code></pre>
      </li>
      <li class="list">To run Angular unit tests for this chapter, execute:
        <pre class="programlisting"><code class="hljs bash">npx ng <span class="hljs-built_in">test</span> ch4 --watch=<span class="hljs-literal">false</span>
</code></pre>
      </li>
      <li class="list">To run Angular e2e tests for this chapter, execute:
        <pre class="programlisting"><code class="hljs nginx"><span class="hljs-attribute">npx</span> ng e2e ch4
</code></pre>
      </li>
      <li class="list" value="7">To build a production-ready Angular app for this chapter, execute:
        <pre class="programlisting"><code class="hljs ada">npx ng build ch4 <span class="hljs-comment">--prod</span>
</code></pre>
        <div class="packt_tip">
          <p>Note that the <code class="Code-In-Text--PACKT-">dist/ch4</code> folder at the root of the repository will contain the compiled result.</p>
        </div>
      </li>
    </ol>
    <div class="note">
      <p class="Information-Box--PACKT-">Beware that the source code in the book or on GitHub may not always match the code generated by the Angular CLI. There may also be slight differences in implementation between the code in the book and what's on GitHub because the ecosystem is ever-evolving. It is natural for the sample code to change over time. Also, on GitHub, expect to find corrections, fixes to support newer versions of libraries, or side-by-side implementations of multiple techniques for the reader to observe. You are only expected to implement the ideal solution recommended in the book. If you find errors or have questions, please create an issue or submit a pull request on GitHub for the benefit of all readers.</p>
    </div>
    <div class="packt_tip">
      <p>You can read more about updating Angular in <em class="italics">Appendix C</em>, <em class="italics">Keeping Angular and Tools Evergreen</em>. You can find this appendix online from <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen."><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf</span></a> or at <a href="https://expertlysimple.io/stay-evergreen"><span class="url">https://expertlysimple.io/stay-evergreen</span></a>.</p>
    </div>
    <p class="normal">Throughout this chapter, you need to sign up for accounts at CircleCI and Vercel Now. But before we can deploy our app, we need to ensure we have automated tests in place to ensure the quality of our app over time. First, we will deep dive into unit testing fundamentals to familiarize you with the benefits of test-driven development and cover principles like FIRST and SOLID.</p>
    <h1 class="title" id="_idParaDest-116">Unit testing</h1>
    <p class="normal">Unit testing is crucial to ensure that the behavior of your application doesn't unintentionally <a id="_idIndexMarker279"/>change over time. Unit tests are going to enable you and your team to continue making changes to your application without introducing changes to previously verified functionality. Developers write unit tests, where each test is scoped to <a id="_idIndexMarker280"/>test only the code that exists in the <strong class="bold">Function Under Test</strong> (<strong class="bold">FUT</strong>) or <strong class="bold">Class Under Test</strong> (<strong class="bold">CUT</strong>). Angular components and services are all classes; however, you <a id="_idIndexMarker281"/>are also encouraged to develop reusable functions. Unit tests should be plentiful, automated, and fast. You should write unit tests alongside the original code. If they are separated from the implementation, even by a day or two, you are going to start forgetting the details of your code. Because of that, you may forget to write tests for potential edge cases.</p>
    <p class="normal">Unit tests should adhere to the FIRST principle:</p>
    <ul>
      <li class="list"><strong class="bold">F</strong>ast</li>
      <li class="list"><strong class="bold">I</strong>solated</li>
      <li class="list"><strong class="bold">R</strong>epeatable</li>
      <li class="list"><strong class="bold">S</strong>elf-verifying</li>
      <li class="list"><strong class="bold">T</strong>imely</li>
    </ul>
    <p class="normal">A unit test should be fast, taking only milliseconds to run, so that we can have thousands of them running in just a few minutes. For fast tests to be possible, a unit test should be isolated. It shouldn't talk to a database, make requests over the network, or interact with the DOM. Isolated tests are going to be repeatable, so that every run of the test returns the same result. Predictability means we can assert the correctness of a test without relying on any outside environment, which makes our tests self-verifying. As mentioned earlier, you should write unit tests promptly; otherwise, you lose the benefits of writing unit tests.</p>
    <p class="normal">It is possible to adhere to the FIRST principle if your tests focus only on a single FUT/CUT. But what about other classes, services, or parameters we must pass into the FUT/CUT? A unit test <a id="_idIndexMarker282"/>can isolate the behavior of the FUT/CUT by leveraging test doubles. A test double allows us to control outside dependencies, so instead of injecting an <code class="Code-In-Text--PACKT-">HttpService</code> to your component, you may instead inject a fake or mocked <code class="Code-In-Text--PACKT-">HttpService</code>. Using test doubles, we can control the effects of outside dependencies and create fast and repeatable tests.</p>
    <div class="packt_tip">
      <p>How much testing is enough testing? You should have at least as much test code as production code. If you don't, then you're nowhere near writing enough tests.</p>
    </div>
    <p class="normal">Unit tests aren't the only kind of tests you can create, but they are by far the kind you should create the most of. Let's consider the three major classes of tests you can create: unit, integration, and UI.</p>
    <p class="normal">As we've said, unit tests only focus on a single FUT/CUT at a time. Integration tests test the integration of various components so that they can include database calls, network requests, and interaction with the DOM. Due to their nature, integration tests are slow to run, and they need to be frequently maintained. Increases in runtime and maintenance mean that over time, integration tests are more expensive than unit tests. UI tests test the application as if a user is using it, filling in fields, clicking on buttons, and observing the expected outcome. </p>
    <p class="normal">You may imagine that these tests are the slowest and most fragile kind of tests. The UI of an application changes frequently, and it is very tough to create repeatable tests with UI testing.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">We can leverage a mixture of integration and UI testing to create acceptance tests. Acceptance tests are written to automate the business acceptance of the functionality that we deliver. Angular's e2e tests are a way to create acceptance tests.</p>
    </div>
    <p class="normal">We can visualize the pros and cons of the three major classes of automated testing with Mike Cohn's Testing Pyramid, shown as following:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_04_01.png"/></figure>
    <p class="packt_figref">Figure 4.1: Mike Cohn's Testing Pyramid</p>
    <p class="normal">The testing pyramid effectively summarizes the relative amount of tests of each kind we should <a id="_idIndexMarker283"/>create for our applications while considering their speed and cost.</p>
    <p class="normal">In terms of implementation, unit tests are made up of three parts:</p>
    <ul>
      <li class="list">Arrange – setup</li>
      <li class="list">Act – run the thing you want to test</li>
      <li class="list">Assert – verify the results</li>
    </ul>
    <p class="normal">During the arrange step, we set up test doubles, expected outcomes, and any other requisite dependencies. During the act step, we execute the line of code we're testing. Finally, in the assert stage, we verify if the outcome of the act step matches the expected results defined in the arrange step. We are going to see how arrange, act, and assert work in practice in the next section.</p>
    <p class="normal">Let's look into what unit tests mean in Angular.</p>
    <h1 class="title" id="_idParaDest-117">Angular unit tests</h1>
    <p class="normal">The definition of a unit test in Angular is slightly different from the strict definition of unit testing <a id="_idIndexMarker284"/>we defined in the previous section. Angular CLI auto-generates unit tests for us using the Jasmine framework. However, these so-called unit tests include DOM-interactions because they render the view of the component.</p>
    <p class="normal">Consider the architecture of an Angular component from <em class="italics">Chapter 1</em>, <em class="italics">Introduction to Angular and Its Concepts</em>:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_04_02.png"/></figure>
    <p class="packt_figref">Figure 4.2: Anatomy of a Component</p>
    <p class="normal">Since Angular uses binding, the component class and its template are inseparable, effectively representing a unit. We can still write pure unit tests by testing individual functions, but otherwise, a component and its template are considered the smallest possible units to test.</p>
    <div class="packt_tip">
      <p>As your application grows, you may find that Angular unit tests are slow to run, because they render views and resolve the dependency tree. There are various ways to deal with this problem, including the parallelization of test runs, opting out of using the Angular TestBed, and more aggressive use of test doubles.</p>
    </div>
    <p class="normal">As you may note, we can inject services into the component or use other components in our template. We are going to leverage test double mechanisms provided by Jasmine to isolate our <a id="_idIndexMarker285"/>components from such external dependencies.</p>
    <p class="normal">Let's go over what Jasmine is.</p>
    <h2 class="title" id="_idParaDest-118">Jasmine</h2>
    <p class="normal">Jasmine is a behavior-driven testing framework for browser and Node.js tests. Jasmine also supports Ruby and Python. Jasmine is a batteries-included framework. It supports elemental <a id="_idIndexMarker286"/>unit testing needs, such as test fixtures, asserts, mocks, spies, and reporters.</p>
    <p class="normal">The naming <a id="_idIndexMarker287"/>convention of a Jasmine test file involves using <code class="Code-In-Text--PACKT-">spec.ts</code> after the file name, as in <code class="Code-In-Text--PACKT-">fileUnderTest.spec.ts</code>. Jasmine tests are organized in <code class="Code-In-Text--PACKT-">describe</code> blocks, which can be grouped in levels to reflect the structure of a file, class, or multiple tests that belong to a single function. Individual test cases, or specs, are represented in <code class="Code-In-Text--PACKT-">it</code> blocks. The following sample shows a file named <code class="Code-In-Text--PACKT-">converters.ts</code> exporting a function that converts Celsius to Fahrenheit:</p>
    <pre class="programlisting"><code class="hljs coffeescript"><strong>Sample Jasmine Test</strong>
describe(<span class="hljs-string">'Converters'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  describe(<span class="hljs-string">'convertCtoF'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    it(<span class="hljs-string">'should convert 0c to 32f'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      ...
    })
  })
})
</code></pre>
    <p class="normal">Specs are organized in a manner so that when they execute, they read like a sentence. In this case, the outcome would be <em class="italics">Converters convertCtoF should convert 0c to 32f</em>.</p>
    <p class="normal">For more <a id="_idIndexMarker288"/>information on Jasmine, visit <a href="https://jasmine.github.io"><span class="url">https://jasmine.github.io</span></a>.</p>
    <p class="normal">Next, let's cover the major categories of features of Jasmine and most other testing frameworks – fixtures and matches – which help you write coherent unit tests using the act, arrange, and assert structure.</p>
    <h3 class="title" id="_idParaDest-119">Fixtures</h3>
    <p class="normal">As mentioned earlier, a unit test has three parts: arrange, act, and assert. The arrange part of unit <a id="_idIndexMarker289"/>tests can be repetitive as multiple test cases often require the <a id="_idIndexMarker290"/>same setup. Jasmine provides fixtures to help reduce the amount of repetition in your score.</p>
    <p class="normal">Following are the four fixtures:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">beforeAll()</code> – runs before <a id="_idIndexMarker291"/>all specs in <code class="Code-In-Text--PACKT-">describe</code></li>
      <li class="list"><code class="Code-In-Text--PACKT-">afterAll()</code> – runs after <a id="_idIndexMarker292"/>all specs in <code class="Code-In-Text--PACKT-">describe</code> per test fixtures</li>
      <li class="list"><code class="Code-In-Text--PACKT-">beforeEach()</code> – runs <a id="_idIndexMarker293"/>before each spec in <code class="Code-In-Text--PACKT-">describe</code></li>
      <li class="list"><code class="Code-In-Text--PACKT-">afterEach()</code> – runs <a id="_idIndexMarker294"/>after each spec in <code class="Code-In-Text--PACKT-">describe</code></li>
    </ul>
    <p class="normal">The fixtures execute before and after a spec or a group of specs as scoped with their <code class="Code-In-Text--PACKT-">describe</code> block.</p>
    <h3 class="title" id="_idParaDest-120">Matchers</h3>
    <p class="normal">In the <a id="_idIndexMarker295"/>assert part of a unit test, we need to let Jasmine know whether <a id="_idIndexMarker296"/>a spec passed or failed. We can do so by writing an assertion. There are two kinds of assertions:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">fail('message')</code> – this <a id="_idIndexMarker297"/>explicitly fails a spec</li>
      <li class="list"><code class="Code-In-Text--PACKT-">expect()</code> – given a <a id="_idIndexMarker298"/>matcher, this dynamically asserts if the expected outcome matches the actual outcome</li>
    </ul>
    <p class="normal">The expect assertion requires matchers to determine the outcome of a test. The combination of expect and matcher is meant to read like a sentence. Following are common matchers that you may use:</p>
    <pre class="programlisting"><code class="hljs reasonml"><strong>Jasmine Matchers</strong>
expect(expected).<span class="hljs-keyword">to</span><span class="hljs-constructor">Be(<span class="hljs-params">actual</span>)</span>
                .<span class="hljs-keyword">to</span><span class="hljs-constructor">Equal(<span class="hljs-params">actual</span>)</span>
                .<span class="hljs-keyword">to</span><span class="hljs-constructor">BeDefined()</span>
                .<span class="hljs-keyword">to</span><span class="hljs-constructor">BeFalsy()</span>
                .<span class="hljs-keyword">to</span><span class="hljs-constructor">Throw(<span class="hljs-params">exception</span>)</span>
                .nothing<span class="hljs-literal">()</span>
</code></pre>
    <p class="normal">For the <a id="_idIndexMarker299"/>full extent of Jasmine matchers, see <a href="https://jasmine.github.io/api/edge/matchers.html"><span class="url">https://jasmine.github.io/api/edge/matchers.html</span></a>.</p>
    <div class="packt_tip">
      <p>Other libraries with richer features exist, such as Jest, Mocha, or testdouble.js. However, when getting started with a new framework like Angular, it's important to keep your toolset minimal. Sticking to defaults is a good idea.</p>
    </div>
    <p class="normal">Additionally, Jasmine <a id="_idIndexMarker300"/>provides spies, which support stubbing and <a id="_idIndexMarker301"/>mocking, with the <code class="Code-In-Text--PACKT-">spyOn</code> function. We are going to cover these test doubles in more detail later in the chapter.</p>
    <h2 class="title" id="_idParaDest-121">Anatomy of auto-generated unit tests</h2>
    <p class="normal">Out of the box, Angular is configured so that you can compose your unit tests with Jasmine. Karma <a id="_idIndexMarker302"/>is the test runner, which can continuously monitor changes to your code and automatically re-run your unit tests.</p>
    <p class="normal">Angular's default configuration leverages <code class="Code-In-Text--PACKT-">TestBed</code>, which is an Angular-specific component that facilitates the provision of modules, dependency injection, mocking, the triggering of Angular life-cycle events like <code class="Code-In-Text--PACKT-">ngOnInit</code>, and the execution of template logic.</p>
    <p class="normal">As discussed before, when you leverage <code class="Code-In-Text--PACKT-">TestBed</code>, it is not possible to call these tests unit tests in the strictest definition of the term. This is because, by default, <code class="Code-In-Text--PACKT-">TestBed</code> injects actual instances of your dependencies. This means when you execute your test, you're also executing code in services or other components, whereas you should be testing only the code that resides in the service or component that is currently under test. We leverage test doubles to help us write isolated and repeatable unit tests.</p>
    <p class="normal">In <em class="italics">Chapter 3</em>, <em class="italics">Creating a Basic Angular App</em>, the Angular CLI created unit test files as you created new components and services, such as <code class="Code-In-Text--PACKT-">current-weather.component.spec.ts</code> and <code class="Code-In-Text--PACKT-">weather.service.spec.ts</code>. Take a look at the following spec file and observe the <code class="Code-In-Text--PACKT-">should create</code> test. The framework asserts that any component of the <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> type should not to be null or undefined, but instead should be truthy:</p>
    <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/current-weather/current-weather.component.spec.ts</strong>
describe(<span class="hljs-string">'CurrentWeatherComponent'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  let component: CurrentWeatherComponent
  let fixture: ComponentFixture&lt;CurrentWeatherComponent&gt;
  beforeEach(
    async(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      TestBed.configureTestingModule({
        declarations: [CurrentWeatherComponent],
      }).compileComponents()
    })
  )
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    fixture = TestBed.createComponent(CurrentWeatherComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })
  it(<span class="hljs-string">'should create'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    expect(component).toBeTruthy()
  })
})
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">WeatherService</code> spec contains a similar test. However, you'll note that each type of tests <a id="_idIndexMarker303"/>is set up slightly differently:</p>
    <pre class="programlisting"><code class="hljs routeros"><strong>src/app/weather/weather.service.spec.ts</strong>
describe(<span class="hljs-string">'WeatherService'</span>, () =&gt; { 
  let service: WeatherService
  
  beforeEach(() =&gt; {
    TestBed.configureTestingModule({})
   <span class="hljs-built_in"> service </span>= TestBed.inject(WeatherService);
  })
  it(<span class="hljs-string">'should be created'</span>, () =&gt; {
      expect(service).toBeTruthy()
    })
  )
})
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">WeatherService</code> spec's <code class="Code-In-Text--PACKT-">beforeEach</code> function, the CUT is injected into <code class="Code-In-Text--PACKT-">TestBed</code>. On the other hand, the <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> spec has two <code class="Code-In-Text--PACKT-">beforeEach</code> functions. The first <code class="Code-In-Text--PACKT-">beforeEach</code> function declares and compiles the component's dependent modules asynchronously, while the second <code class="Code-In-Text--PACKT-">beforeEach</code> function creates a test fixture and starts listening to changes in the component, ready to run the tests once the compilation is complete.</p>
    <p class="normal">Next, let's execute our unit tests to see how many are passing or failing.</p>
    <h2 class="title" id="_idParaDest-122">Unit test execution</h2>
    <p class="normal">The Angular CLI <a id="_idIndexMarker304"/>uses the Jasmine unit testing <a id="_idIndexMarker305"/>library to define unit tests and the Karma test runner to execute them. Best of all, these testing tools are configured to be run out of the box. You may execute the unit tests with the following command:</p>
    <pre class="programlisting"><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm <span class="hljs-built_in">test</span></span>
</code></pre>
    <p class="normal">The tests are run by the Karma test runner in a new Chrome browser window. The main benefit of <a id="_idIndexMarker306"/>Karma is that it brings live-reloading capabilities similar to what the Angular CLI achieves with webpack when developing your application.</p>
    <p class="normal">After the <a id="_idIndexMarker307"/>initial execution of the <code class="Code-In-Text--PACKT-">npm test</code> command, you're likely to run into compilation errors, because when we implemented our application code we didn't update the corresponding unit test code.</p>
    <div class="packt_tip">
      <p>During the development process, it is normal to run into many errors. So, don't be frustrated! See <em class="italics">Appendix A</em>, <em class="italics">Debugging Angular</em>, to learn how to troubleshoot and debug errors using Chrome/Edge Dev Tools and VS Code.</p>
    </div>
    <p class="normal">Let's how you can address these errors.</p>
    <h3 class="title" id="_idParaDest-123">Compilation errors</h3>
    <p class="normal">It is important to update your unit test code as you develop your application code. Failing to <a id="_idIndexMarker308"/>do so usually results in compilation errors.</p>
    <div class="packt_tip">
      <p>Remember that test code is not built when you build your Angular app. You must execute <code class="Code-In-Text--PACKT-">npm test</code> to build and run your test code.</p>
    </div>
    <p class="normal">When you execute the tests, you should see an error message like the one following:</p>
    <pre class="programlisting"><code class="hljs routeros"><span class="hljs-builtin-name">ERROR</span> <span class="hljs-keyword">in</span> src/app/app.component.spec.ts:21:16 - <span class="hljs-builtin-name">error</span> TS2339:
Property <span class="hljs-string">'title'</span> does <span class="hljs-keyword">not</span> exist on<span class="hljs-built_in"> type </span><span class="hljs-string">'AppComponent'</span>.
21     expect(app.title).toEqual(<span class="hljs-string">'local-weather-app'</span>)
</code></pre>
    <p class="normal">The first test we need to correct is under <code class="Code-In-Text--PACKT-">app.component.spec.ts</code>, named <code class="Code-In-Text--PACKT-">'should have as title "local-weather-app"'</code>. We deleted the app property <code class="Code-In-Text--PACKT-">title</code> from <code class="Code-In-Text--PACKT-">AppComponent</code> in the previous chapter because we were not using it. So, we don't need this unit test anymore.</p>
    <ol>
      <li class="list" value="1">Delete the <code class="Code-In-Text--PACKT-">should have as title 'local-weather-app'</code> unit test.<div class="packt_tip">
          <p>As discussed before, Jasmine combines the text provided in the <code class="Code-In-Text--PACKT-">describe</code> and <code class="Code-In-Text--PACKT-">it</code> functions. As a result, this test is called <code class="Code-In-Text--PACKT-">'AppComponent should have as title 'local-weather-app''</code>. This is a convenient convention for quickly locating tests. As you write new tests, it is up to you to maintain readable descriptions of your specs.</p>
        </div>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The second test to fix is under <code class="Code-In-Text--PACKT-">AppComponent</code> and is named <code class="Code-In-Text--PACKT-">should render title</code>. We render the words LocalCast Weather as the title now, so let's change the test.</p>
      </li>
      <li class="list">Update the <code class="Code-In-Text--PACKT-">should render title</code> test as shown:
        <pre class="programlisting"><code class="hljs stylus"><strong>src/app/app<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.ts</span></strong>
<span class="hljs-function"><span class="hljs-title">it</span><span class="hljs-params">(<span class="hljs-string">'should render title'</span>, ()</span></span> =&gt; {
  ... 
  expect(compiled.querySelector(<span class="hljs-string">'h1'</span>).textContent)
    .toContain(<span class="hljs-string">'LocalCast Weather'</span>) 
})
</code></pre>
      </li>
      <li class="list" value="3">Commit <a id="_idIndexMarker309"/>your code changes.</li>
    </ol>
    <p class="normal">We have fixed the logical issues in our unit tests. They should now execute without compilation errors. However, you should expect all of them fail because we haven't yet configured Angular's <code class="Code-In-Text--PACKT-">TestBed</code>.</p>
    <h3 class="title" id="_idParaDest-124">Test results</h3>
    <p class="normal">You should <a id="_idIndexMarker310"/>observe the last message on the Terminal to be <code class="Code-In-Text--PACKT-">TOTAL: 2 FAILED, 2 SUCCESS</code>. This is normal because we haven't been paying attention to the tests at all, so let's fix them all.</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_04_03.png"/></figure>
    <p class="packt_figref">Figure 4.3: Karma Runner showing Jasmine unit test results</p>
    <div class="packt_tip">
      <p>Keep the Karma Runner window open side by side with VS Code so that you can instantly see the results of your changes.</p>
    </div>
    <p class="normal">Let's now <a id="_idIndexMarker311"/>configure TestBed.</p>
    <h2 class="title" id="_idParaDest-125">Configuring TestBed</h2>
    <p class="normal">TestBed has <a id="_idIndexMarker312"/>three major features that assist you <a id="_idIndexMarker313"/>in creating unit-testable components:</p>
    <ul>
      <li class="list">Declarations – builds <a id="_idIndexMarker314"/>component classes, along with their template logic, to facilitate testing</li>
      <li class="list">Providers – provides <a id="_idIndexMarker315"/>component classes without template logic and dependencies that need to be injected</li>
      <li class="list">Imports – imports <a id="_idIndexMarker316"/>support modules to be able to render template logic or other platform functionality</li>
    </ul>
    <div class="packt_tip">
      <p>TestBed is not <a id="_idIndexMarker317"/>a hard requirement to write unit tests in Angular, a topic covered well at <a href="https://angular.io/guide/testing"><span class="url">https://angular.io/guide/testing</span></a>. My colleague and reviewer of this book, Brendon Caulkins, contributed a bed-less spec file to <em class="italics">Chapter 12</em>, <em class="italics">Recipes – Master/Detail, Data Tables, and NgRx</em> code samples, named <code class="Code-In-Text--PACKT-">current-weather.component.nobed.spec.ts</code>. He cites significant performance increases in running the tests, with fewer imports and less maintenance, but a higher level of care and expertise required to implement the tests. If you're <a id="_idIndexMarker318"/>on a large project, you should seriously consider skipping the TestBed.</p>
      <p>You can find the sample code on GitHub at <a href="https://github.com/duluca/local-weather-app/tree/master/projects/ch12"><span class="url">https://github.com/duluca/local-weather-app/tree/master/projects/ch12</span></a>.</p>
    </div>
    <p class="normal">Let's go <a id="_idIndexMarker319"/>over these features one by one while <a id="_idIndexMarker320"/>fixing the tests at hand so they can run successfully.</p>
    <h3 class="title" id="_idParaDest-126">Declarations</h3>
    <p class="normal">Declarations allow <a id="_idIndexMarker321"/>us to provide all components necessary <a id="_idIndexMarker322"/>to render the component under test. Normally, you will only be declaring the component that is under test. So, <code class="Code-In-Text--PACKT-">app.component.spec.ts</code> declares <code class="Code-In-Text--PACKT-">AppComponent</code> and <code class="Code-In-Text--PACKT-">current-weather.component.spec.ts</code> declares <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> and so forth.</p>
    <p class="normal">Note that we use <code class="Code-In-Text--PACKT-">&lt;app-current-weather&gt;</code> within the template of <code class="Code-In-Text--PACKT-">AppComponent</code>; however, this does not mean that we need to also declare <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> in <code class="Code-In-Text--PACKT-">app.component.spec.ts</code>. Previous versions of Angular's TestBed required child components to be declared as part of the parent component's unit tests, causing significant overhead in creating unit tests. Including multiple components in declarations has the side effect of needing to inject all dependencies of all components declared, not just those of the one that is under test. This meant adding unrelated dependencies to our "unit" tests, making them integration tests.</p>
    <div class="packt_tip">
      <p>In this case, <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> is a hard-coded dependency of <code class="Code-In-Text--PACKT-">AppComponent</code>. It is possible to decouple the two components further in two ways: one way is to inject the component dynamically using an <code class="Code-In-Text--PACKT-">ng-container</code>, and the other would be to leverage the Angular Router and <code class="Code-In-Text--PACKT-">router-outlet</code>. The <code class="Code-In-Text--PACKT-">router-outlet</code> strategy is how we structure the vast majority of multi-screen Angular apps, which I cover in later chapters. Properly decoupling components using <code class="Code-In-Text--PACKT-">ng-container</code> is left as an exercise for the reader.</p>
    </div>
    <p class="normal">You may try out declaring <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> in <code class="Code-In-Text--PACKT-">app.component.spec.ts</code>:</p>
    <pre class="programlisting"><code class="hljs jboss-cli"><strong>src/app/app.component.spec.ts</strong>
<span class="hljs-string">...</span>
TestBed.configureTestingModule<span class="hljs-params">({
  declarations: [AppComponent, CurrentWeatherComponent],
})</span><span class="hljs-string">.compileComponents</span><span class="hljs-params">()</span>
<span class="hljs-string">...</span>
</code></pre>
    <p class="normal">Note that doing so introduces <code class="Code-In-Text--PACKT-">HttpClient</code>-related errors for <code class="Code-In-Text--PACKT-">AppComponent</code> tests, even though <code class="Code-In-Text--PACKT-">AppComponent</code> itself doesn't import <code class="Code-In-Text--PACKT-">WeatherService</code>. In fact, <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> imports <code class="Code-In-Text--PACKT-">WeatherService</code>, which itself imports <code class="Code-In-Text--PACKT-">HttpClient</code>. You can see how the complexity of the dependencies can quickly get out of hand. Angular <a id="_idIndexMarker323"/>unit tests are configured to not require the <a id="_idIndexMarker324"/>declaration of the child component, but note that the unit test framework is throwing a warning regarding the unknown element:</p>
    <pre class="programlisting"><code class="hljs ada">WARN: '<span class="hljs-symbol">'app</span>-current-weather' <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a known element
</code></pre>
    <p class="normal">In programming, warnings are almost as serious as errors. Not resolving warnings is bound to cause trouble down the line. We will cover how to properly resolve this issue when we cover mocks later.</p>
    <div class="packt_tip">
      <p>Be sure to undo your change before moving on.</p>
    </div>
    <p class="normal">For now, you don't need to declare child components for parent component tests, making it easier to have passing unit tests initially. There are certain cases where you must declare dependent components, such as when you are creating a custom control and you need to test whether your control works properly within the context of a component. An example of creating a custom control is included in <em class="italics">Chapter 11</em>, <em class="italics">Recipes – Reusability, Routing, and Caching</em>.</p>
    <p class="normal">In the next section, we will look at providers, which help us inject real and fake implementations of dependencies so that we can avoid testing dependencies like <code class="Code-In-Text--PACKT-">WeatherService</code> and only test the "unit."</p>
    <h3 class="title" id="_idParaDest-127">Providers</h3>
    <p class="normal">Providers allow us to provide components without template logic or services that are injected to <a id="_idIndexMarker325"/>our component under test. You'll note that our <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> tests are not passing with an error complaining about the <a id="_idIndexMarker326"/>lack of provider for <code class="Code-In-Text--PACKT-">HttpClient</code>:</p>
    <pre class="programlisting"><code class="hljs yaml"><span class="hljs-string">CurrentWeatherComponent</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">should</span> <span class="hljs-string">create</span>
<span class="hljs-attr">NullInjectorError:</span> <span class="hljs-string">R3InjectorError(DynamicTestModule)[WeatherService</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">HttpClient</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">HttpClient]:</span> 
  <span class="hljs-attr">NullInjectorError:</span> <span class="hljs-literal">No</span> <span class="hljs-string">provider</span> <span class="hljs-string">for</span> <span class="hljs-string">HttpClient!</span>
</code></pre>
    <p class="normal">This is because <code class="Code-In-Text--PACKT-">WeatherService</code>, which is injected into <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code>, needs a provider for <code class="Code-In-Text--PACKT-">HttpClient</code>. However, <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> has no knowledge of <code class="Code-In-Text--PACKT-">HttpClient</code>. It only knows about <code class="Code-In-Text--PACKT-">WeatherService</code>. You may guess that we're perhaps not strictly unit testing but actually integration testing, and you would be right. </p>
    <p class="normal">However, let's play <a id="_idIndexMarker327"/>along and add the provider for <code class="Code-In-Text--PACKT-">WeatherService</code> to <code class="Code-In-Text--PACKT-">current-weather.component.spec.ts</code>. Provide the <code class="Code-In-Text--PACKT-">WeatherService</code> in the declarations in <code class="Code-In-Text--PACKT-">current-weather.component.spec.ts</code>, as shown:</p>
    <pre class="programlisting"><code class="hljs stylus"><strong>src/app/current-weather/current-weather<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.ts</span></strong>
...
<span class="hljs-function"><span class="hljs-title">beforeEach</span><span class="hljs-params">(async(()</span></span> =&gt; { 
  TestBed.configureTestingModule({ 
    declarations: [...], 
    providers: [WeatherService], 
  })
  ...
})
...
</code></pre>
    <p class="normal">In this example, we have <a id="_idIndexMarker328"/>provided the actual implementation of <code class="Code-In-Text--PACKT-">WeatherService</code>, which doesn't resolve the issue at hand. The implementation of <code class="Code-In-Text--PACKT-">WeatherService</code> still depends on <code class="Code-In-Text--PACKT-">HttpClient</code> and the error persists.</p>
    <div class="packt_tip">
      <p>Be sure to undo your change before moving on.</p>
    </div>
    <p class="normal">Providers allow us to provide alternative implementations of a dependency, like a fake or a mock of that dependency.</p>
    <p class="normal">If we deﬁne a fake implementation of <code class="Code-In-Text--PACKT-">WeatherService</code> named <code class="Code-In-Text--PACKT-">FakeWeatherService</code>, we can provide the fake instead of the actual implementation with <code class="Code-In-Text--PACKT-">useClass</code> shown as follows:</p>
    <pre class="programlisting"><code class="hljs groovy"><span class="hljs-string">providers:</span> [{ <span class="hljs-string">provide:</span> WeatherService, <span class="hljs-string">useClass:</span> FakeWeatherService }]
</code></pre>
    <p class="normal">A fake implementation would break the dependency on <code class="Code-In-Text--PACKT-">HttpClient</code> and resolve our issue. I go over how to implement fakes in the upcoming section on test doubles.</p>
    <p class="normal">Alternatively, if we create a mock for <code class="Code-In-Text--PACKT-">WeatherService</code> named <code class="Code-In-Text--PACKT-">mockWeatherService</code>, we can provide the mock with <code class="Code-In-Text--PACKT-">useValue</code> shown as follows:</p>
    <pre class="programlisting"><code class="hljs groovy"><span class="hljs-string">providers:</span> [{ <span class="hljs-string">provide:</span> WeatherService, <span class="hljs-string">useValue:</span> mockWeatherService }]
</code></pre>
    <p class="normal">With a mock, we wouldn't even have to implement a fake class and ensure that we're only testing <a id="_idIndexMarker329"/>the component under test. The upcoming section on test doubles covers mocks in detail.</p>
    <p class="normal">Now that <a id="_idIndexMarker330"/>we have a good understanding of what providers can and can't do for us, let's see how imports round out <code class="Code-In-Text--PACKT-">TestBed</code>.</p>
    <h3 class="title" id="_idParaDest-128">Imports</h3>
    <p class="normal">Imports help bring in code that can facilitate the rendering of views or other dependencies <a id="_idIndexMarker331"/>to the test. Currently, the tests are still failing, because <code class="Code-In-Text--PACKT-">WeatherService</code> itself depends on <code class="Code-In-Text--PACKT-">HttpClient</code>, so we need to provide <code class="Code-In-Text--PACKT-">HttpClient</code>. If we do, then our unit test will attempt to make calls over HTTP. We don't want our tests <a id="_idIndexMarker332"/>to depend on other services, as this goes against the FIRST principles covered earlier in the chapter. So, we shouldn't provide the actual <code class="Code-In-Text--PACKT-">HttpClient</code>.</p>
    <p class="normal">Angular provides a test double for <code class="Code-In-Text--PACKT-">HttpClient</code> named <code class="Code-In-Text--PACKT-">HttpClientTestingModule</code>. To leverage it, you must import it, which automatically provides the test double for you.</p>
    <p class="normal">Import <code class="Code-In-Text--PACKT-">HttpClientTestingModule</code> for <code class="Code-In-Text--PACKT-">current-weather.component.spec.ts</code>:</p>
    <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/current-weather/current-weather.component.spec.ts</strong>
<span class="hljs-keyword">import</span> { HttpClientTestingModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http/testing'</span>
...
  describe(<span class="hljs-string">' CurrentWeatherComponent'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { 
    beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { 
      TestBed.configureTestingModule({ 
        imports: [HttpClientTestingModule], 
        ...
      })
    ...
  })
...
</code></pre>
    <div class="packt_tip">
      <p>Similar to <code class="Code-In-Text--PACKT-">HttpClientTestingModule</code>, there's also a <code class="Code-In-Text--PACKT-">RouterTestingModule</code> and a <code class="Code-In-Text--PACKT-">NoopAnimationsModule</code>, which are mock versions of the real services, so the unit tests can focus on only testing the component or service code that you write. In later chapters, we also cover how you can write your own mocks.</p>
    </div>
    <p class="normal">Phew! Now, all your unit tests should be passing. As you can see, the <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> tests are not our unit tests, because they are using the actual <code class="Code-In-Text--PACKT-">WeatherService</code>, which itself depends on <code class="Code-In-Text--PACKT-">HttpClient</code>.</p>
    <p class="normal">Now, let's look into how test doubles can help us write unit tests that adhere to FIRST principles.</p>
    <h2 class="title" id="_idParaDest-129">Test doubles</h2>
    <p class="normal">Only the <a id="_idIndexMarker333"/>code in the CUT should be exercised. In the case of the <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code>, we need to ensure that the service code is not executed. For <a id="_idIndexMarker334"/>this reason, you should <em class="italics">never</em> provide the actual implementation of the service.</p>
    <p class="normal">We need <a id="_idIndexMarker335"/>to go over two types of test doubles:</p>
    <ul>
      <li class="list">Fakes</li>
      <li class="list">Mocks, stubs, or spies</li>
    </ul>
    <p class="normal">In general, it is easier to reason about fakes, so we will start with that. Once you're comfortable with unit testing and your existing set of tests are in working order, I highly recommend switching over to exclusively using mocks, as it'll make your tests more robust, efficient, and maintainable.</p>
    <h3 class="title" id="_idParaDest-130">Fakes</h3>
    <p class="normal">A fake is <a id="_idIndexMarker336"/>an alternative, simplified implementation of an existing class. It's like a fake service, where no actual HTTP calls are made, but your service returns pre-baked responses. During unit testing, a fake is instantiated and is used like the real class. In the previous section, we used <code class="Code-In-Text--PACKT-">HttpClientTestingModule</code>, which is a fake <code class="Code-In-Text--PACKT-">HttpClient</code>. Our custom service is <code class="Code-In-Text--PACKT-">WeatherService</code>, so we must provide our implementation of a test double.</p>
    <p class="normal">We create a test double by creating a fake of the service. Since the fake of the <code class="Code-In-Text--PACKT-">WeatherService</code> is used in tests for multiple components, your implementation should be in a separate file. For the sake of the maintainability and discoverability of your codebase, one class per file is a good rule of thumb to follow. Keeping classes in separate files saves you from committing certain coding sins, like mistakenly creating or sharing global state or standalone functions between two classes, keeping your code decoupled in the process.</p>
    <p class="normal">We also need to ensure that APIs for the actual implementation and the test double don't go out of sync over time. We can accomplish this by creating an interface for the service.</p>
    <ol>
      <li class="list" value="1">Add <code class="Code-In-Text--PACKT-">IWeatherService</code> to <code class="Code-In-Text--PACKT-">weather.service.ts</code>, as shown:
        <pre class="programlisting"><code class="hljs routeros"><strong>src/app/weather/weather.service.ts</strong>
<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> interface </span>IWeatherService {
  getCurrentWeather(
  city: string, 
  country: string
  ): Observable&lt;ICurrentWeather&gt; 
}
</code></pre>
      </li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">WeatherService</code> so that it implements the new interface:
        <pre class="programlisting"><code class="hljs angelscript"><strong>src/app/weather/weather.service.ts</strong>
export <span class="hljs-keyword">class</span> <span class="hljs-symbol">WeatherService</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">IWeatherService</span>
</code></pre>
      </li>
      <li class="list">Create a new file <code class="Code-In-Text--PACKT-">weather/weather.service.fake.ts</code></li>
      <li class="list">Implement <a id="_idIndexMarker337"/>a basic fake in <code class="Code-In-Text--PACKT-">weather.service.fake.ts</code>, as follows:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/weather/weather.service.fake.ts</strong>
<span class="hljs-keyword">import</span> { Observable, of } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
<span class="hljs-keyword">import</span> { IWeatherService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./weather.service'</span>
<span class="hljs-keyword">import</span> { ICurrentWeather } <span class="hljs-keyword">from</span> <span class="hljs-string">'../interfaces'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fakeWeather: ICurrentWeather = {
  city: <span class="hljs-string">'Bethesda'</span>,
  country: <span class="hljs-string">'US'</span>,
  date: <span class="hljs-number">1485789600</span>,
  image: <span class="hljs-string">''</span>,
  temperature: <span class="hljs-number">280.32</span>,
  description: <span class="hljs-string">'light intensity drizzle'</span>,
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> WeatherServiceFake <span class="hljs-keyword">implements</span> IWeatherService {
  <span class="hljs-keyword">public</span> getCurrentWeather(
    city: <span class="hljs-built_in">string</span>,
    country: <span class="hljs-built_in">string</span>): Observable&lt;ICurrentWeather&gt; { 
      <span class="hljs-keyword">return</span> of(fakeWeather)
  }
}
</code></pre>
        <div class="note">
          <p class="Information-Box--PACKT-">We're leveraging the existing <code class="Code-In-Text--PACKT-">ICurrentWeather</code> interface that our fake data has correctly shaped, but we must also turn it into an <code class="Code-In-Text--PACKT-">Observable</code>. This is easily achieved using <code class="Code-In-Text--PACKT-">of</code>, which creates an observable sequence, given the provided arguments.</p>
        </div>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Now you're ready to provide the fake to <code class="Code-In-Text--PACKT-">AppComponent</code> and <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code>.</p>
      </li>
      <li class="list">Update the provider in <code class="Code-In-Text--PACKT-">current-weather.component.spec.ts</code> to use <code class="Code-In-Text--PACKT-">WeatherServiceFake</code> so that the fake is used instead of the actual service:
        <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/current-weather/current-weather.component.spec.ts</strong>
  ...
  beforeEach( 
    async(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      TestBed.configureTestingModule({
        ...
        providers: [{
          provide: WeatherService, useClass: WeatherServiceFake
        }],
        ...
</code></pre>
        <div class="packt_tip">
          <p>Note that this alternate implementation is provided under a different file named <code class="Code-In-Text--PACKT-">current-weather.component.fake.spec</code>, part of the sub-folder <code class="Code-In-Text--PACKT-">projects/ch4</code> on GitHub.</p>
        </div>
      </li>
      <li class="list">Remove <code class="Code-In-Text--PACKT-">HttpClientTestingModule</code> from the imports, since it is no longer needed
      <div class="note">
        <p class="Information-Box--PACKT-">As your services and components get more complicated, it's easy to provide an incomplete or inadequate test double. You may see errors such as <code class="Code-In-Text--PACKT-">NetworkError: Failed to execute 'send' on 'XMLHttpRequest'</code>, <code class="Code-In-Text--PACKT-">Can't resolve all parameters</code>, or <code class="Code-In-Text--PACKT-">[object ErrorEvent] thrown</code>. In case of the latter error, click on the <strong class="screen-text">Debug</strong> button in Karma to discover the view error details, which may look like <strong class="screen-text">Timeout - Async callback was not invoked within timeout specified by jasmine</strong>. Unit tests are designed to run in milliseconds, so it should be impossible to actually hit the default 5-second timeout. The issue is almost always with the test setup or configuration.</p>
      </div></li>
      <li class="list" value="7">Verify that all tests are passing</li>
    </ol>
    <p class="normal">With fakes, we were <a id="_idIndexMarker338"/>able to somewhat reduce test complexity and improve isolation. We can do much better with mocks, stubs, and spies.</p>
    <h3 class="title" id="_idParaDest-131">Mocks, stubs, and spies</h3>
    <p class="normal">A mock, stub, or spy does not contain any implementation whatsoever. Mocks are configured <a id="_idIndexMarker339"/>in the unit test file to respond to specific function <a id="_idIndexMarker340"/>calls with a set of responses that can be made to vary <a id="_idIndexMarker341"/>from test to test with ease.</p>
    <p class="normal">Earlier in the <em class="italics">Declarations</em> section, we discussed the need to declare <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> in <code class="Code-In-Text--PACKT-">app.component.spec.ts</code> to resolve the <strong class="screen-text">not a known element</strong> warning. If we declare the real <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code>, then the <code class="Code-In-Text--PACKT-">AppComponent</code> test configuration becomes overly complicated with a lot of configuration elements, because we must resolve the dependency tree for the child component, including <code class="Code-In-Text--PACKT-">WeatherService</code> and <code class="Code-In-Text--PACKT-">HttpClient</code>. In addition, creating a whole fake service just to provide fake weather data is overkill and is not a flexible solution. What if we <a id="_idIndexMarker342"/>wanted to test different service responses, given different inputs? We would have to start introducing logic into our fake service, and before <a id="_idIndexMarker343"/>you know it, you're dealing with two separate implementations of the <code class="Code-In-Text--PACKT-">WeatherService</code>.</p>
    <p class="normal">An alternative <a id="_idIndexMarker344"/>to creating a fake would be to create an empty object that parades as the real thing but contains no implementation. These objects are called mocks. We will leverage two different techniques to create a mock component and a mock service below.</p>
    <h4 class="title">Mock components</h4>
    <p class="normal">If we <a id="_idIndexMarker345"/>were to provide a <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> in <code class="Code-In-Text--PACKT-">app.component.spec.ts</code>, we could resolve the <strong class="screen-text">not a known element</strong> warning and not have to worry about all the components and services that <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> depends on.</p>
    <p class="normal">If you were to implement it by hand, a mock component would look like this:</p>
    <pre class="programlisting"><code class="hljs less"><span class="hljs-variable">@Component</span>({
  <span class="hljs-attribute">selector</span>: <span class="hljs-string">'app-current-weather'</span>,
  <span class="hljs-attribute">template</span>: <span class="hljs-built_in">``</span>,
})
class MockCurrentWeatherComponent {}
</code></pre>
    <p class="normal">However, this can get tedious really fast, which is why I published a unit test helper library <a id="_idIndexMarker346"/>called <strong class="bold">angular-unit-test-helper</strong> to make it easier to mock a component. With the library, you can just replace the component in the declaration with this function call:</p>
    <pre class="programlisting"><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">createComponentMock</span><span class="hljs-params">(<span class="hljs-string">'CurrentWeatherComponent'</span>)</span></span>
</code></pre>
    <p class="normal">Let's update <code class="Code-In-Text--PACKT-">app.component.spec.ts</code> to use mocked components:</p>
    <ol>
      <li class="list" value="1">Execute <code class="Code-In-Text--PACKT-">npm i -D angular-unit-test-helper</code></li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">AppComponent</code> with the mocked components:
        <pre class="programlisting"><code class="hljs gradle"><strong>src<span class="hljs-regexp">/app/</span>app.component.spec.ts</strong>
<span class="hljs-keyword">import</span> { createComponentMock } <span class="hljs-keyword">from</span> <span class="hljs-string">'angular-unit-test-helper'</span>
  TestBed.configureTestingModule({
    declarations: [ ...,
      createComponentMock(<span class="hljs-string">'CurrentWeatherComponent'</span>)
    ],
    ...
  })
</code></pre>
      </li>
      <li class="list">Remove the <code class="Code-In-Text--PACKT-">providers</code> property altogether</li>
      <li class="list" value="4">Clean up unused imports</li>
    </ol>
    <p class="normal">Observe that the <a id="_idIndexMarker347"/>unit test file remains lean and the warning is resolved. <strong class="bold">angular-unit-test-helper</strong> infers that <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> represents an HTML tag like <code class="Code-In-Text--PACKT-">&lt;app-current-weather&gt;</code> and provides it in the window object of the browser. The <code class="Code-In-Text--PACKT-">createComponentMock</code> function then properly decorates the empty class <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> by assigning the selector <code class="Code-In-Text--PACKT-">'app-current-weather'</code> and an empty template. <code class="Code-In-Text--PACKT-">TestBed</code> is then able to resolve <code class="Code-In-Text--PACKT-">&lt;app-current-weather&gt;</code> as this mocked component. <code class="Code-In-Text--PACKT-">createComponentMock</code> also allows you to provide a custom selector or <a id="_idIndexMarker348"/>a fake template that you can pass depending on your needs. This is a solution that scales, cutting imports by more than half and adhering to FIRST principles.</p>
    <p class="normal">The concept of mocks extends to all kinds of objects we can define, including Angular services. By mocking a service, we don't have to worry about any dependencies that may be injected into that service.</p>
    <p class="normal">Let's see how we can mock a service.</p>
    <h4 class="title">Mock services</h4>
    <p class="normal">Let's write <a id="_idIndexMarker349"/>two new unit tests for <code class="Code-In-Text--PACKT-">CurrentWeatherComponent</code> to demonstrate the value of mocking a service instead of implementing a fake for it. Mocks allow us to create an empty object and give us the option to supply only the functions that may be needed for a test. We can then stub out the return values of these functions per test or spy on them to see whether our code called them or not. Spying is especially useful if the function in question has no return value. We need to set up our spy in the arrange part of our spec.</p>
    <ol>
      <li class="list" value="1">Let's start by creating a spy <code class="Code-In-Text--PACKT-">WeatherService</code>, using <code class="Code-In-Text--PACKT-">jasmine.createSpyObj</code>, as shown:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/current-weather/current-weather.component.spec.ts</strong>
<span class="hljs-keyword">import</span> {
  ComponentFixture,
  TestBed,
  <span class="hljs-keyword">async</span>
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core/testing'</span>
<span class="hljs-keyword">import</span> { injectSpy } <span class="hljs-keyword">from</span> <span class="hljs-string">'angular-unit-test-helper'</span>
<span class="hljs-keyword">import</span> { WeatherService } <span class="hljs-keyword">from</span> <span class="hljs-string">'../weather/weather.service'</span>
<span class="hljs-keyword">import</span> {
  CurrentWeatherComponent
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./current-weather.component'</span>
describe(<span class="hljs-string">'CurrentWeatherComponent'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  ...
  <span class="hljs-keyword">let</span> weatherServiceMock: jasmine.SpyObj&lt;WeatherService&gt;
  beforeEach(<span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> weatherServiceSpy =
      jasmine.createSpyObj(
        <span class="hljs-string">'WeatherService'</span>,
        [<span class="hljs-string">'getCurrentWeather'</span>]
      )
    
    TestBed.configureTestingModule({ ... })
  })
</code></pre>
      </li>
      <li class="list">Provide <code class="Code-In-Text--PACKT-">weatherServiceSpy</code> as the value of <code class="Code-In-Text--PACKT-">WeatherService</code> with <code class="Code-In-Text--PACKT-">useValue</code></li>
      <li class="list">Finally, get the injected instance from <code class="Code-In-Text--PACKT-">TestBed</code> and assign the value to <code class="Code-In-Text--PACKT-">weatherServiceMock</code>, using the <code class="Code-In-Text--PACKT-">injectSpy</code> method from angular-unit-test-helper as shown:
        <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/current-weather/current-weather.component.spec.ts</strong>
    beforeEach(async(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { 
      ...
      TestBed.configureTestingModule({
      ...,
       providers: [{
         provide: WeatherService, useValue: weatherServiceSpy
       }]
    }).compileComponents()
    weatherServiceMock = injectSpy(WeatherService)
}
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p>Note that <code class="Code-In-Text--PACKT-">injectSpy</code> is a shorthand for <code class="Code-In-Text--PACKT-">TestBed.inject(WeatherService)</code> as any.</p>
    </div>
    <p class="normal">In the <a id="_idIndexMarker350"/>preceding example, we have a mocked version of <code class="Code-In-Text--PACKT-">WeatherService</code>, where declared that it has a function named <code class="Code-In-Text--PACKT-">getCurrentWeather</code>. However, note that you're now getting an error:</p>
    <pre class="programlisting"><code class="hljs crmsh">TypeError: Cannot <span class="hljs-keyword">read</span> <span class="hljs-keyword">property</span><span class="hljs-title"> </span>'subscribe' of undefined
</code></pre>
    <p class="normal">This is because <code class="Code-In-Text--PACKT-">getCurrentWeather</code> is not returning an observable. Using <code class="Code-In-Text--PACKT-">weatherServiceMock</code>, we can spy on whether <code class="Code-In-Text--PACKT-">getCurrentWeather</code> is being called or not, but also stub out its return value depending on the test.</p>
    <p class="normal">In order <a id="_idIndexMarker351"/>to manipulate the return value of <code class="Code-In-Text--PACKT-">getCurrentWeather</code>, we need to update the <strong class="bold">should create</strong> test to reflect the arrange, act, and assert structure. To do this, we need to move <code class="Code-In-Text--PACKT-">fixture.detectChanges()</code> from the second <code class="Code-In-Text--PACKT-">beforeEach</code>, so we can control its execution order to be after the arrange part.</p>
    <pre class="programlisting"><code class="hljs reasonml"><strong>src/app</strong><strong>/current-weather/current-weather.component.spec.ts</strong>
  import { <span class="hljs-keyword">of</span> } from 'rxjs'<span class="hljs-operator">
  ...
  </span>before<span class="hljs-constructor">Each(()</span> =&gt; {
    fixture = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TestBed</span>.</span></span>create<span class="hljs-constructor">Component(CurrentWeatherComponent)</span>
    component = fixture.componentInstance
  })
  it('should create',<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Arrange</span>
    weatherServiceMock.getCurrentWeather.<span class="hljs-keyword">and</span>.return<span class="hljs-constructor">Value(<span class="hljs-params">of</span>()</span>)
    <span class="hljs-comment">// Act</span>
    fixture.detect<span class="hljs-constructor">Changes()</span> <span class="hljs-comment">// triggers ngOnInit</span>
    <span class="hljs-comment">// Assert</span>
    expect(component).<span class="hljs-keyword">to</span><span class="hljs-constructor">BeTruthy()</span>
  })
</code></pre>
    <p class="normal">In the arrange part, we configure that <code class="Code-In-Text--PACKT-">getCurrentWeather</code> should return an empty observable <a id="_idIndexMarker352"/>using the <code class="Code-In-Text--PACKT-">RxJS\of</code> function. In the act part, we trigger TestBed's <code class="Code-In-Text--PACKT-">detectChanges</code> function, which triggers lifecycle events like <code class="Code-In-Text--PACKT-">ngOnInit</code>. Since the code we're testing is in <code class="Code-In-Text--PACKT-">ngOnInit</code>, this is the right thing to execute. Finally, in the assert part, we confirm our assertion that the component was successfully created.</p>
    <p class="normal">In this next test, we can verify that the <code class="Code-In-Text--PACKT-">getCurrentWeather</code> function is being called exactly once:</p>
    <pre class="programlisting"><code class="hljs reasonml"><strong>src/app/current-weather/current-weather.component.spec.ts</strong>
  it('should get currentWeather from weatherService',<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Arrange</span>
    weatherServiceMock.getCurrentWeather.<span class="hljs-keyword">and</span>.return<span class="hljs-constructor">Value(<span class="hljs-params">of</span>()</span>)
    <span class="hljs-comment">// Act</span>
    fixture.detect<span class="hljs-constructor">Changes()</span> <span class="hljs-comment">// triggers ngOnInit()</span>
    <span class="hljs-comment">// Assert</span>
    expect(weatherServiceMock.getCurrentWeather)
      .<span class="hljs-keyword">to</span><span class="hljs-constructor">HaveBeenCalledTimes(1)</span>
  })
</code></pre>
    <p class="normal">And finally, we can test out the fact that the values that are being returned are correctly assigned in the component class, but also that they are correctly rendered on the template:</p>
    <pre class="programlisting"><code class="hljs reasonml"><strong>src/app/current-weather/current-weather.component.spec.ts</strong>
import { By } from '@angular/platform-browser'
import { fakeWeather } from '../weather/weather.service.fake'<span class="hljs-operator">
...
  </span>it('should eagerly load currentWeather <span class="hljs-keyword">in</span> Bethesda from weatherService',<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Arrange</span>
    weatherServiceMock.getCurrentWeather
      .<span class="hljs-keyword">and</span>.return<span class="hljs-constructor">Value(<span class="hljs-params">of</span>(<span class="hljs-params">fakeWeather</span>)</span>)
    <span class="hljs-comment">// Act</span>
    fixture.detect<span class="hljs-constructor">Changes()</span> <span class="hljs-comment">// triggers ngOnInit()</span>
    <span class="hljs-comment">// Assert</span>
    expect(component.current).<span class="hljs-keyword">to</span><span class="hljs-constructor">BeDefined()</span>
    expect(component.current.city).<span class="hljs-keyword">to</span><span class="hljs-constructor">Equal('Bethesda')</span>
    expect(component.current.temperature).<span class="hljs-keyword">to</span><span class="hljs-constructor">Equal(280.32)</span>
    <span class="hljs-comment">// Assert on DOM</span>
    const debugEl = fixture.debugElement
    const titleEl: HTMLElement = debugEl.query(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">By</span>.</span></span>css('span'))
      .nativeElement
    expect(titleEl.textContent).<span class="hljs-keyword">to</span><span class="hljs-constructor">Contain('Bethesda')</span>
  })
</code></pre>
    <p class="normal">In the preceding example, you can see that we're providing a <code class="Code-In-Text--PACKT-">fakeWeather</code> object, where the <a id="_idIndexMarker353"/>city name is Bethesda. We are then able to assert that the current property has the correct <code class="Code-In-Text--PACKT-">city</code>, and also that the <code class="Code-In-Text--PACKT-">&lt;div&gt;</code> element with <code class="Code-In-Text--PACKT-">class=mat-title</code> contains the text Bethesda.</p>
    <p class="normal">You should now have seven passing tests:</p>
    <pre class="programlisting"><code class="hljs yaml"><span class="hljs-attr">TOTAL:</span> <span class="hljs-number">7</span> <span class="hljs-string">SUCCESS</span>
</code></pre>
    <p class="normal">Using mocks, stubs, and spies, we can rapidly test permutations of what outside dependencies can and cannot return and we are able to verify our assertions on the code that resides in the component or service class by observing the DOM.</p>
    <div class="packt_tip">
      <p>To learn <a id="_idIndexMarker354"/>more about mocks, stubbing, and spies, refer to <a href="https://jasmine.github.io"><span class="url">https://jasmine.github.io</span></a>. Also, I've found Jasmine 2 Spy Cheat Sheet by Dave Ceddia, located at <a href="https://daveceddia.com/jasmine-2-spy-cheat-sheet"><span class="url">https://daveceddia.com/jasmine-2-spy-cheat-sheet</span></a>, to be a useful resource.</p>
    </div>
    <p class="normal">In general, your unit tests should be asserting one or two things at most. To achieve adequate unit test coverage, you should focus on testing the correctness of functions that contain business logic: usually wherever you see an <code class="Code-In-Text--PACKT-">if</code> or <code class="Code-In-Text--PACKT-">switch</code> statement.</p>
    <p class="normal">To write <a id="_idIndexMarker355"/>unit-testable code, be sure to adhere to the Single Responsibility and Open/Closed principles of the SOLID principles.</p>
    <div class="packt_tip">
      <p>Check out the <strong class="bold">ng-tester</strong> library <a id="_idIndexMarker356"/>that my colleague Brendan Sawyer created at <a href="https://www.npmjs.com/package/ng-tester"><span class="url">https://www.npmjs.com/package/ng-tester</span></a>. It creates <a id="_idIndexMarker357"/>opinionated spec files for your Angular <a id="_idIndexMarker358"/>components that leverage <strong class="bold">angular-unit-test-helper</strong> to assist with mocking. In addition, the library demonstrates how to mock dependencies and create tests without using <code class="Code-In-Text--PACKT-">TestBed</code>.</p>
      <p>You may install the library <code class="Code-In-Text--PACKT-">npm install -D ng-tester</code> and create a unit test with the command <code class="Code-In-Text--PACKT-">npx ng generate ng-tester:unit</code>.</p>
    </div>
    <p class="normal">In addition to unit tests, the Angular CLI also generates and configures e2e tests for your application. Next, let's learn about e2e tests.</p>
    <h1 class="title" id="_idParaDest-132">Angular e2e tests</h1>
    <p class="normal">While unit tests focus on isolating the CUT, e2e tests are about integration testing. The Angular CLI <a id="_idIndexMarker359"/>leverages Protractor along with WebDriver so that you can write <strong class="bold">Automated Acceptance Tests</strong> (<strong class="bold">AAT</strong>) from the perspective of a user interacting <a id="_idIndexMarker360"/>with your application in a browser. As a rule of thumb, you should always write an order of magnitude more unit tests than AATs, because your app changes frequently, and as a result, AATs are vastly more fragile and expensive to maintain compared to unit tests.</p>
    <div class="packt_tip">
      <p>If the term web driver sounds familiar, it's because it is an evolution of the canonical Selenium WebDriver. On March 30th, 2017, WebDriver was proposed as an official <a id="_idIndexMarker361"/>web standard at the W3C. You read more about it at <a href="https://www.w3.org/TR/webdriver"><span class="url">https://www.w3.org/TR/webdriver</span></a>. If you're familiar with Selenium, you should feel right at home, since a lot of the patterns and practices are nearly identical.</p>
    </div>
    <p class="normal">The CLI provides e2e tests for the initial <code class="Code-In-Text--PACKT-">AppComponent</code> and depending on the complexity <a id="_idIndexMarker362"/>and the feature set of your application. It's up to you to follow the provided pattern to organize your tests better. There are two files generated per component under the e2e folder:</p>
    <pre class="programlisting"><code class="hljs typescript"><strong>e2e/src/app.e2e-spec.ts</strong>
<span class="hljs-keyword">import</span> { browser, logging } <span class="hljs-keyword">from</span> <span class="hljs-string">'protractor'</span>
<span class="hljs-keyword">import</span> { AppPage } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.po'</span>
describe(<span class="hljs-string">'workspace-project App'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">let</span> page: AppPage
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    page = <span class="hljs-keyword">new</span> AppPage()
  })
  it(<span class="hljs-string">'should display welcome message'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    page.navigateTo()
    expect(page.getTitleText())
      .toEqual(<span class="hljs-string">'local-weather-app app is running!'</span>)
  })
  afterEach(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// Assert that there are no errors emitted from the browser</span>
    <span class="hljs-keyword">const</span> logs = <span class="hljs-keyword">await</span> browser
      .manage()
      .logs()
      .get(logging.Type.BROWSER)
    expect(logs).not.toContain(
      jasmine.objectContaining({
        level: logging.Level.SEVERE,
      } <span class="hljs-keyword">as</span> logging.Entry)
    )
  })
})
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">app.e2e-spec.ts</code> is written in Jasmine and implements acceptance tests. The spec is dependent upon the page object (<code class="Code-In-Text--PACKT-">po</code>) file, which is defined beside the <code class="Code-In-Text--PACKT-">spec</code> file:</p>
    <pre class="programlisting"><code class="hljs typescript"><strong>e2e/src/app.po.ts</strong>
<span class="hljs-keyword">import</span> { browser, by, element } <span class="hljs-keyword">from</span> <span class="hljs-string">'protractor'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppPage {
  navigateTo(): <span class="hljs-built_in">Promise</span>&lt;unknown&gt; {
    <span class="hljs-keyword">return</span> browser.get(browser.baseUrl) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Promise</span>&lt;unknown&gt;
  }
  getTitleText(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
    <span class="hljs-keyword">return</span> element(by.css(<span class="hljs-string">'app-root div h1'</span>))
      .getText() <span class="hljs-keyword">as</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;
  }
}
</code></pre>
    <p class="normal">Consider the <a id="_idIndexMarker363"/>following diagram, which represents the e2e test architecture visually:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_04_04.png"/></figure>
    <p class="packt_figref">Figure 4.4: The Architecture of e2e Tests</p>
    <p class="normal">The goal of the <strong class="bold">'should display welcome message'</strong> test is to verify that <code class="Code-In-Text--PACKT-">app.component.html</code> displays the correct text. The page object file, <code class="Code-In-Text--PACKT-">app.po.ts</code>, encapsulates web driver implementation to retrieve the message with the <code class="Code-In-Text--PACKT-">getTitleText</code> function. Finally, the test is written as a Jasmine test in the <code class="Code-In-Text--PACKT-">app.e2e-spec.ts</code> file. AATs are the most fragile kind of tests. Having a page object layer between the HTML and the spec files results in easy-to-maintain, human-readable tests. By separating concerns at this level, you keep the fragility of AATs to one location. By leveraging class inheritance, you can build a robust collection of page objects that can be easier to maintain over time.</p>
    <h2 class="title" id="_idParaDest-133">e2e test execution</h2>
    <p class="normal">You can <a id="_idIndexMarker364"/>execute e2e tests with the following command in the terminal; ensure that the <code class="Code-In-Text--PACKT-">npm test</code> process is not running:</p>
    <pre class="programlisting"><code class="hljs dockerfile">$ npm <span class="hljs-keyword">run</span><span class="bash"> e2e</span>
</code></pre>
    <p class="normal">Note that the test execution is different as compared to unit tests. While you can configure a <a id="_idIndexMarker365"/>watcher to continually execute unit tests with Karma, due to the user-driven and stateful nature of e2e tests, it is not a good practice to attempt a similar configuration with e2e tests. Running the tests once and stopping the test harness ensures a clean state with every run.</p>
    <h2 class="title" id="_idParaDest-134">The e2e page object and spec</h2>
    <p class="normal">After <a id="_idIndexMarker366"/>executing the e2e tests, you should see an error message similar to the one here:</p>
    <pre class="programlisting"><code class="hljs markdown"><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span>
<span class="hljs-bullet">*                    </span>Failures                    *
<span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span>
1) web-app App should display welcome message
<span class="hljs-bullet">  - </span>Failed: No element found using locator: By(css selector, app-root .content span)
Executed 1 of 1 spec (1 FAILED) in 0.659 sec.
</code></pre>
    <p class="normal">The test <a id="_idIndexMarker367"/>is failing because we significantly altered the structure of the HTML in <code class="Code-In-Text--PACKT-">app.component.html</code> and the <code class="Code-In-Text--PACKT-">getTitleText</code> method in our page object is no longer correct.</p>
    <ol>
      <li class="list" value="1">Begin by correcting <code class="Code-In-Text--PACKT-">getTitleText</code> so it retrieves the correct text:
        <pre class="programlisting"><code class="hljs cs">e2e/src/app.po.<span class="hljs-function">ts
  <span class="hljs-title">getTitleText</span>(<span class="hljs-params"/>): Promise&lt;<span class="hljs-keyword">string</span>&gt;</span> {
    <span class="hljs-keyword">return</span> element(<span class="hljs-keyword">by</span>.css(<span class="hljs-string">'app-root div h1'</span>)).
      getText() <span class="hljs-keyword">as</span> Promise&lt;<span class="hljs-keyword">string</span>&gt;
  }
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that the error message now says:</p>
        <pre class="programlisting"><code class="hljs applescript">- Expected 'LocalCast Weather' <span class="hljs-keyword">to</span> <span class="hljs-keyword">equal</span> '<span class="hljs-keyword">local</span>-weather-app app <span class="hljs-keyword">is</span> <span class="hljs-built_in">running</span>!'.
</code></pre>
      </li>
      <li class="list">Update the <code class="Code-In-Text--PACKT-">spec</code> to expect the correct header as follows:
        <pre class="programlisting"><code class="hljs coffeescript">e2e/src/app.e2e-spec.ts
  it(<span class="hljs-string">'should display welcome message'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    page.navigateTo()
    expect(page.getTitleText()).toEqual(<span class="hljs-string">'LocalCast Weather'</span>)
  })
</code></pre>
      </li>
      <li class="list">Re-run the tests; they should be passing now:
        <pre class="programlisting"><code class="hljs angelscript">Jasmine started
web-app App
√ should display welcome message
Executed <span class="hljs-number">1</span> of <span class="hljs-number">1</span> spec SUCCESS <span class="hljs-keyword">in</span> <span class="hljs-number">0.676</span> sec.
</code></pre>
      </li>
      <li class="list" value="4">Commit your code changes.</li>
    </ol>
    <p class="normal">Our unit <a id="_idIndexMarker368"/>tests and e2e tests are now working.</p>
    <div class="packt_tip">
      <p>There are more robust tools for automated acceptance testing, such as <a href="https://cypress.io"><span class="url">https://cypress.io</span></a> and <a href="https://github.com/bigtestjs"><span class="url">https://github.com/bigtestjs</span></a>. Consider using <a id="_idIndexMarker369"/>these tools instead of Angular's e2e tests.</p>
      <p>You may find a sample implementation of Cypress, integrated with CircleCI, for the <a id="_idIndexMarker370"/>LemonMart project, covered in <em class="italics">Chapter 7</em>, <em class="italics">Creating a Router-First Line-of-Business App</em>, at <a href="https://github.com/duluca/lemon-mart"><span class="url">https://github.com/duluca/lemon-mart</span></a>. </p>
      <p>Execute <code class="Code-In-Text--PACKT-">npm run cypress:run</code> to see Cypress in action. Cypress can record and replay test runs for easy debugging; it is a robust tool for your next enterprise project.</p>
    </div>
    <p class="normal">Going forward, make sure that your tests remain in working condition.</p>
    <p class="normal">Next, we need <a id="_idIndexMarker371"/>to ready our app for production deployments, which means building the app in prod mode and setting the appropriate environment variables.</p>
    <h1 class="title" id="_idParaDest-135">Production readiness</h1>
    <p class="normal">When you run <code class="Code-In-Text--PACKT-">npm start</code>, Angular builds in debug mode, which enables faster build times, breakpoint debugging, and live reloading. This also means that the bundle size of a small app <a id="_idIndexMarker372"/>balloons to over 7 MB. A 7 MB bundle size results in over two minutes of loading time on a slow 3G connection when we expect our app to load in mere seconds. Additionally, in debug mode, we use environment variables meant for local development. However, in production, we need to use different settings so our application can run in a hosted environment correctly.</p>
    <p class="normal">Let's start by implementing an <code class="Code-In-Text--PACKT-">npm</code> script to help us build in prod mode.</p>
    <h2 class="title" id="_idParaDest-136">Building for production</h2>
    <p class="normal">Angular ships with a robust build tool that can optimize the size of your bundle by removing <a id="_idIndexMarker373"/>redundant, unused, and inefficient code from the debug build and pre-compiling sections of code so browsers can interpret it faster. So, a 7 MB bundle can become 700 KB and load in under 7 seconds even on a slow 3G connection.</p>
    <p class="normal">By default, the <code class="Code-In-Text--PACKT-">ng build</code> command builds your code in debug mode. By adding the <code class="Code-In-Text--PACKT-">--prod</code> option to it, we can enable <code class="Code-In-Text--PACKT-">prod</code> mode.</p>
    <ol>
      <li class="list" value="1">Add a new script called <code class="Code-In-Text--PACKT-">build:prod</code> to <code class="Code-In-Text--PACKT-">package.json</code>, as shown:
        <pre class="programlisting"><code class="hljs actionscript"><strong><span class="hljs-class"><span class="hljs-keyword">package</span>.<span class="hljs-title">json</span></span></strong><span class="hljs-class">
"<span class="hljs-title">scripts</span>": {</span>
  ...
  <span class="hljs-string">"build:prod"</span>: <span class="hljs-string">"ng build --prod"</span>
}
</code></pre>
      </li>
      <li class="list" value="2">Test the script by executing:
        <pre class="programlisting"><code class="hljs dockerfile">$ npm <span class="hljs-keyword">run</span><span class="bash"> build:prod</span>
</code></pre>
      </li>
    </ol>
    <p class="normal">This is a critical configuration for the efficient delivery of Angular apps.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Do not ship an Angular app without first enabling prod mode.</p>
    </div>
    <p class="normal">Next, let's set the environment variables for prod.</p>
    <h2 class="title" id="_idParaDest-137">Setting environment variables</h2>
    <p class="normal">In <em class="italics">Chapter 3</em>, <em class="italics">Creating a Basic Angular App</em>, we configured the URL for the OpenWeatherMap APIs using environment variables stored in the <code class="Code-In-Text--PACKT-">src/environment/environment.ts</code> file. We need to update our variables for production <a id="_idIndexMarker374"/>use because the environment that our Angular app lives in is changing. The settings that work in a local or test environment are not necessarily going to work in the hosting environment.</p>
    <p class="normal">Apply the following changes to <code class="Code-In-Text--PACKT-">environment.prod.ts</code>:</p>
    <ol>
      <li class="list" value="1">Set <code class="Code-In-Text--PACKT-">production</code> to <code class="Code-In-Text--PACKT-">true</code></li>
      <li class="list">If necessary, provide a production <code class="Code-In-Text--PACKT-">appId</code> variable</li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">baseUrl</code> to <code class="Code-In-Text--PACKT-">https</code>:
        <pre class="programlisting"><code class="hljs dart"><strong>src/environments/environment.prod.ts</strong>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> environment = {
  production: <span class="hljs-keyword">true</span>,
  appId: <span class="hljs-string">'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'</span>,
  baseUrl: <span class="hljs-string">'https://'</span>,
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Setting <code class="Code-In-Text--PACKT-">production</code> to <code class="Code-In-Text--PACKT-">true</code> allows the application code to check the mode of the application <a id="_idIndexMarker375"/>to adjust its behavior. Also, we changed the <code class="Code-In-Text--PACKT-">baseUrl</code> from HTTP to HTTPS, because our app is hosted over HTTPS. Browsers don't allow the serving of mixed content, which weakens the overall security benefits that HTTPS delivers. If we don't switch over to HTTPS, then our calls to the OpenWeatherMap APIs fail.</p>
    <div class="packt_tip">
      <p>You can <a id="_idIndexMarker376"/>read more about mixed content at <a href="https://developers.google.com/web/fundamentals/security/prevent-mixed-content/what-is-mixed-content"><span class="url">https://developers.google.com/web/fundamentals/security/prevent-mixed-content/what-is-mixed-content</span></a>.</p>
    </div>
    <p class="normal">Next, let's set up CI to ensure that our tests are always passing before we deploy the app to production.</p>
    <h1 class="title" id="_idParaDest-138">Continuous Integration</h1>
    <p class="normal">Before pushing your code to production, you should enable CI. This basic setup helps ensure our <a id="_idIndexMarker377"/>application code keeps working even when we make changes to our code, by automating the execution of our unit tests.</p>
    <h2 class="title" id="_idParaDest-139">CircleCI</h2>
    <p class="normal">CircleCI makes it <a id="_idIndexMarker378"/>easy to get started, with a free tier <a id="_idIndexMarker379"/>and excellent documentation for beginners and pros alike. If you have unique enterprise needs, CircleCI can be brought on-premises, behind corporate firewalls, or as a private deployment in the cloud.</p>
    <p class="normal">CircleCI has pre-baked build environments for the virtual configuration of free setups, but it can also run builds using Docker containers, making it a solution that scales to the user's skills and needs, as covered in <em class="italics">Chapter 9</em>, <em class="italics">DevOps Using Docker</em>:</p>
    <ol>
      <li class="list" value="1">Create a CircleCI account at <a href="https://circleci.com/"><span class="url">https://circleci.com/</span></a>.</li>
      <li class="list">Sign up with GitHub:<figure class="mediaobject"><img alt="" src="../Images/B14094_04_05.png"/></figure>
        <p class="packt_figref">Figure 4.5: CircleCI Sign up page</p>
      </li>
      <li class="list">Add <a id="_idIndexMarker380"/>a new <a id="_idIndexMarker381"/>project:<figure class="mediaobject"><img alt="" src="../Images/B14094_04_06.png"/></figure>
        <p class="packt_figref">Figure 4.6: CircleCI Projects page</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">On the next screen, you have an option to select <strong class="screen-text">Linux</strong> or <strong class="screen-text">macOS</strong> build environments. The macOS build environments are good for building iOS or macOS apps. However, there is no free tier for those environments; only Linux instances with 1x parallelism are free.</p>
      </li>
      <li class="list">Search for <code class="Code-In-Text--PACKT-">local-weather-app</code> and click on <strong class="screen-text">Set Up Project</strong>.</li>
      <li class="list">Select <strong class="screen-text">Linux</strong>.</li>
      <li class="list">Select <strong class="screen-text">Language</strong> as <strong class="screen-text">Node</strong>, which provides a sample <code class="Code-In-Text--PACKT-">.yml</code> file.<div class="note">
          <p class="Information-Box--PACKT-">This section uses the <strong class="bold">local-weather-app</strong> repo. The <code class="Code-In-Text--PACKT-">config.yml</code> file for this section is named <code class="Code-In-Text--PACKT-">.circleci/config.ch4.yml</code>. You can also find a pull request that executes the yml file from this chapter on CircleCI: <a href="https://github.com/duluca/local-weatherapp/pull/52"><span class="url">https://github.com/duluca/local-weatherapp/pull/52</span></a> using the <code class="Code-In-Text--PACKT-">branch build_ch4</code>. Note that this branch has a modified configuration in <code class="Code-In-Text--PACKT-">config.yml</code> and <code class="Code-In-Text--PACKT-">Dockerfile</code> to use <code class="Code-In-Text--PACKT-">projects/ch4</code> code from <strong class="bold">local-weather-app</strong>.</p>
        </div>
      </li>
      <li class="list">In your <a id="_idIndexMarker382"/>source code, create a folder <a id="_idIndexMarker383"/>named <code class="Code-In-Text--PACKT-">.circleci</code> and add a file named <code class="Code-In-Text--PACKT-">config.yml</code>:
        <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">.circleci/config.yml</span></strong>
<span class="hljs-attr">version:</span> <span class="hljs-number">2.1</span>
<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">build:</span>
    <span class="hljs-attr">docker:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">circleci/node:lts-browsers</span>
    <span class="hljs-attr">working_directory:</span> <span class="hljs-string">~/repo</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">checkout</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">restore_cache:</span>
          <span class="hljs-attr">keys:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">v1-dependencies-{{</span> <span class="hljs-string">checksum</span> <span class="hljs-string">"package-lock.json"</span> <span class="hljs-string">}}</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">ci</span>
      <span class="hljs-comment"># force update the webdriver</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">cd</span> <span class="hljs-string">./node_modules/protractor</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">npm</span> <span class="hljs-string">i</span> <span class="hljs-string">webdrivermanager@latest</span>
      <span class="hljs-comment"># because we use "npm ci" to install NPM dependencies</span>
      <span class="hljs-comment"># we cache "~/.npm" folder</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">save_cache:</span>
          <span class="hljs-attr">key:</span> <span class="hljs-string">v1-dependencies-{{</span> <span class="hljs-string">checksum</span> <span class="hljs-string">"package-lock.json"</span> <span class="hljs-string">}}</span>
          <span class="hljs-attr">paths:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">~/.npm</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">style</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">lint</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build:prod</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">test:coverage</span> <span class="hljs-string">--</span> <span class="hljs-string">--watch=false</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">e2e</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">Tar</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">Gzip</span> <span class="hljs-string">compiled</span> <span class="hljs-string">app</span>
          <span class="hljs-attr">command:</span> <span class="hljs-string">tar</span> <span class="hljs-string">zcf</span> <span class="hljs-string">dist.tar.gz</span> <span class="hljs-string">dist/local-weather-app</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">store_artifacts:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">dist.tar.gz</span>
<span class="hljs-attr">workflows:</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">build-and-test:</span>
    <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
</code></pre>
      </li>
      <li class="list">Sync <a id="_idIndexMarker384"/>your changes to Github.</li>
      <li class="list">On CircleCI, click <strong class="bold">Start building</strong> to register your project.</li>
    </ol>
    <p class="normal">If everything <a id="_idIndexMarker385"/>goes well, you should have a passing, <em class="italics">green</em>, build. If not, you see a failed, <em class="italics">red</em>, build. The following screenshot shows a failed build, <strong class="screen-text">#97</strong>, and a subsequent build, <strong class="screen-text">#98</strong>, which was successful:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_04_07.png"/></figure>
    <p class="packt_figref">Figure 4.7: Green Build on CircleCI</p>
    <p class="normal">Now that <a id="_idIndexMarker386"/>you have a green build, you can leverage CircleCI to enforce the execution <a id="_idIndexMarker387"/>of your automated pipeline with every code push. GitHub flow allows us to control how code flows into our repositories.</p>
    <h2 class="title" id="_idParaDest-140">GitHub flow</h2>
    <p class="normal">The main reason we're developing software is to deliver value. In automating the way we deliver <a id="_idIndexMarker388"/>software, we are creating a value delivery stream. It is easy to deliver broken software; however, to reliably deliver value, each change <a id="_idIndexMarker389"/>to the codebase should flow through a stream of checks and balances. </p>
    <p class="normal">With control gates, we can enforce standards, make our quality control process repeatable for every team member, and have the ability to isolate changes. If something goes wrong or the work doesn't live up to your standards, you can easily discard the proposed changes and restart.</p>
    <p class="normal">GitHub flow is <a id="_idIndexMarker390"/>an essential part of defining a value delivery stream and <a id="_idIndexMarker391"/>implement control gates. As GitHub puts it, <em class="italics">"GitHub flow is a lightweight, branch-based workflow that supports teams and projects where deployments are made regularly."</em></p>
    <p class="normal">GitHub flow consists of 6 steps, as shown in the following graphic from GitHub:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_04_08.png"/></figure>
    <p class="packt_figref">Figure 4.8: GitHub flow diagram</p>
    <ol>
      <li class="list" value="1"><strong class="bold">Branch</strong> – always add new code for a bug or a feature in a new branch</li>
      <li class="list"><strong class="bold">Commit</strong> – make multiple commits to your branch</li>
      <li class="list"><strong class="bold">Create a pull request</strong> – signal the readiness of your work to your team members and view CI results in a pull request</li>
      <li class="list"><strong class="bold">Discuss and review</strong> – request a review of your code changes, address general or line-level comments, and make necessary modifications</li>
      <li class="list"><strong class="bold">Deploy</strong> – optionally test your code on a test server or in production with the ability to roll back to the master</li>
      <li class="list" value="6"><strong class="bold">Merge</strong> – apply your changes to the master branch</li>
    </ol>
    <p class="normal">Using GitHub flow, you can ensure that only high-quality code ends up in the master branch. A solid foundation sets other team members up for success when they start making their changes. In order to enforce GitHub flow, you need to restrict push access to the master branch.</p>
    <p class="normal">Let's enable branch protection for the master branch:</p>
    <ol>
      <li class="list" value="1">Navigate to the GitHub settings tab for your project</li>
      <li class="list">Select <strong class="screen-text">Branches</strong> from the left navigation pane</li>
      <li class="list">Click the <strong class="screen-text">Add rule</strong> button</li>
      <li class="list">Configure <a id="_idIndexMarker392"/>your rule as shown in the following image:<figure class="mediaobject"><img alt="" src="../Images/B14094_04_09.png"/></figure>
        <p class="packt_figref">Figure 4.9: GitHub Branch protection rule</p>
      </li>
      <li class="list">After you've <a id="_idIndexMarker393"/>saved your changes, you should see your new rule on the <strong class="screen-text">Branches</strong> page as shown:</li>
    </ol>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_04_10.png"/></figure>
    <p class="packt_figref">Figure 4.10: GitHub Branches</p>
    <p class="normal">You are no <a id="_idIndexMarker394"/>longer able to commit code to your <a id="_idIndexMarker395"/>master branch directly. To commit code, you first need to create a branch from the master, commit your changes to the new branch, and when you're ready, create a pull request using the new branch. If you're not familiar with <code class="Code-In-Text--PACKT-">git</code> commands, you can use GitHub Desktop to assist you with these operations. See the handy <strong class="screen-text">Branch</strong> menu in GitHub Desktop here:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_04_11.png"/></figure>
    <p class="packt_figref">Figure 4.11: GitHub Desktop Branch menu</p>
    <p class="normal">After creating <a id="_idIndexMarker396"/>a pull request, you can now observe <a id="_idIndexMarker397"/>checks running against your branch. Now that we have CircleCI configured, if everything went well, you should be able to merge a pull request, as shown: </p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_04_12.png"/></figure>
    <p class="packt_figref">Figure 4.12: GitHub.com Status Checks Passing</p>
    <p class="normal">When the checks fail, you are forced to fix any issues before you can merge the new code. Also, you may run into merge conflicts if a team member merged to the master while you <a id="_idIndexMarker398"/>were working on your branch. In this case, you may <a id="_idIndexMarker399"/>use GitHub Desktop's <strong class="bold">Update from master</strong> feature to catch up your branch <a id="_idIndexMarker400"/>with the latest branch from the master.</p>
    <p class="normal">Observe the state of a failing pull request in the following image:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_04_13.png"/></figure>
    <p class="packt_figref">Figure 4.13: GitHub.com status checks failing</p>
    <div class="packt_tip">
      <p>Note that I have an additional check, DeepScan, which runs additional tests against <a id="_idIndexMarker401"/>my codebase. You can register your repo with DeepScan at <a href="https://deepscan.io"><span class="url">https://deepscan.io</span></a>. In <em class="italics">Chapter 9</em>, <em class="italics">DevOps Using Docker</em>, I demonstrate how you can enforce unit test code coverage using Coveralls.</p>
    </div>
    <p class="normal">For more information, refer to <a href="https://guides.github.com/introduction/flow"><span class="url">https://guides.github.com/introduction/flow</span></a>.</p>
    <p class="normal">Now that we have ensured that our automated checks are being enforced, we can be reasonably sure that we won't push a broken app to production. Next, let's learn how we can deploy our app to the cloud.</p>
    <h1 class="title" id="_idParaDest-141">Deploying to the Cloud</h1>
    <p class="normal">If delivering something to production is difficult from a coding perspective, it is very complicated <a id="_idIndexMarker402"/>to do it right from an infrastructure perspective. In <em class="italics">Chapter 13</em>, <em class="italics">Highly Available Cloud Infrastructure on AWS</em>, I cover how to provision a world-class <a id="_idIndexMarker403"/>AWS <strong class="bold">Elastic Container Service</strong> (<strong class="bold">ECS</strong>) infrastructure for your applications, but that won't help if you need to demonstrate an idea quickly or don't need a highly configurable solution. Enter Vercel Now.</p>
    <h2 class="title" id="_idParaDest-142">Vercel Now</h2>
    <p class="normal">Vercel Now, <a href="https://vercel.com"><span class="url">https://vercel.com</span></a>, is a multi-cloud service that enables real-time global deployments <a id="_idIndexMarker404"/>of applications <a id="_idIndexMarker405"/>directly from the CLI. Vercel Now works with static files, Node.js, PHP, Go applications, and any custom stack of software you're willing to write a custom builder for, which makes it quite straightforward to work with. Vercel Now, which is currently on version 2, has a free tier that you can use to deploy the <code class="Code-In-Text--PACKT-">dist</code> folder of your Angular applications very quickly. In <em class="italics">Chapter 9</em>, <em class="italics">DevOps Using Docker</em>, I demonstrate how you can also deploy a containerized version of your Angular app. </p>
    <p class="normal">Refer to <em class="italics">Chapter 2</em>, <em class="italics">Setting Up Your Development Environment</em>, for instructions on installing Vercel Now.</p>
    <p class="normal">With the <code class="Code-In-Text--PACKT-">now</code> tool, we're ready to deploy our app to the web.</p>
    <h2 class="title" id="_idParaDest-143">Deploying static files</h2>
    <p class="normal">After you build an Angular project, the build output resides in the <code class="Code-In-Text--PACKT-">dist</code> folder. The files in this folder <a id="_idIndexMarker406"/>are considered static files; all a web server needs to do is deliver these files to a client browser, unmodified, and then the browser executes your code dynamically. </p>
    <p class="normal">This means that any web server is able to serve up your Angular project. However, <code class="Code-In-Text--PACKT-">now</code> makes it exceedingly easy, and free, to pull off.</p>
    <p class="normal">Let's get started with deploying your Angular app using <code class="Code-In-Text--PACKT-">now</code>'s static file hosting capabilities.</p>
    <ol>
      <li class="list" value="1">Add two new scripts to <code class="Code-In-Text--PACKT-">package.json</code>, as shown:
        <pre class="programlisting"><code class="hljs jboss-cli"><strong>package.json</strong>
<span class="hljs-string">...</span>
<span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">...</span>
  <span class="hljs-string">"prenow:publish"</span>: <span class="hljs-string">"npm run build:prod"</span>,
  <span class="hljs-string">"now:publish"</span>: <span class="hljs-string">"now --platform-version 2 dist/local-weather-app"</span>
}
</code></pre>
        <div class="packt_tip">
          <p>To deploy Chapter 4-specific code from <a href="https://github.com/duluca/local-weather-app"><span class="url">https://github.com/duluca/local-weather-app</span></a>, you need to execute <code class="Code-In-Text--PACKT-">now --platform-version 2 dist/ch4</code>. Accept the default options for the CLI prompts. In my case, the app deployed to <a href="https://ch4-dun.now.sh/"><span class="url">https://ch4-dun.now.sh/</span></a>.</p>
        </div>
      </li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm run now:publish</code>.</li>
      <li class="list">Accept <a id="_idIndexMarker407"/>the default options for the CLI prompts.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">In the terminal window, observe that the Angular project is built first and then uploaded to <code class="Code-In-Text--PACKT-">now</code>:</p>
        <pre class="programlisting"><code class="hljs angelscript">$ npm run now:publish
&gt; localcast-<span class="hljs-symbol">weather@</span><span class="hljs-number">9.0</span><span class="hljs-number">.0</span> prenow:publish C:\dev\local-weather-app
&gt; npm run build:prod
&gt; localcast-<span class="hljs-symbol">weather@</span><span class="hljs-number">9.0</span><span class="hljs-number">.0</span> build:prod C:\dev\local-weather-app
&gt; ng build --prod
Generating ES5 bundles <span class="hljs-keyword">for</span> differential loading...
ES5 bundle generation complete.
chunk {<span class="hljs-number">2</span>} polyfills-es2015.ca64e4516afbb1b890d5.js (polyfills) <span class="hljs-number">35.6</span> kB [initial] [rendered]
chunk {<span class="hljs-number">3</span>} polyfills-es5<span class="hljs-number">.1</span>d087d4db6b105875851.js (polyfills-es5) <span class="hljs-number">128</span> kB [initial] [rendered]
chunk {<span class="hljs-number">1</span>} main-es2015<span class="hljs-number">.941</span>dc398feac35a1a67d.js (main) <span class="hljs-number">485</span> kB [initial] [rendered]
chunk {<span class="hljs-number">1</span>} main-es5<span class="hljs-number">.941</span>dc398feac35a1a67d.js (main) <span class="hljs-number">577</span> kB [initial] [rendered]chunk {<span class="hljs-number">0</span>} runtime-es2015<span class="hljs-number">.0811</span>dcefd377500b5b1a.js (runtime) <span class="hljs-number">1.45</span> kB [entry] [rendered]
chunk {<span class="hljs-number">0</span>} runtime-es5<span class="hljs-number">.0811</span>dcefd377500b5b1a.js (runtime) <span class="hljs-number">1.45</span> kB [entry] [rendered]
chunk {<span class="hljs-number">4</span>} styles<span class="hljs-number">.1938720</span>bb6985e81892f.css (styles) <span class="hljs-number">62</span> kB [initial] [rendered]Date: <span class="hljs-number">2020</span><span class="hljs-number">-03</span><span class="hljs-number">-24</span>T00:<span class="hljs-number">14</span>:<span class="hljs-number">52.939</span>Z - Hash: <span class="hljs-number">4</span>d78a666345c6761dc95 - Time: <span class="hljs-number">14719</span>ms  
&gt; localcast-<span class="hljs-symbol">weather@</span><span class="hljs-number">9.0</span><span class="hljs-number">.0</span> now:publish C:\dev\local-weather-app
&gt; now --platform-version <span class="hljs-number">2</span> --prod dist/local-weather-app
&gt; UPDATE AVAILABLE Run `npm i <span class="hljs-symbol">now@</span>latest` to install Now CLI <span class="hljs-number">17.1</span><span class="hljs-number">.1</span>
&gt; Changelog: https:<span class="hljs-comment">//github.com/zeit/now/releases/tag/now@17.1.1</span>
Now CLI <span class="hljs-number">17.0</span><span class="hljs-number">.4</span>
? Set up <span class="hljs-keyword">and</span> deploy <span class="hljs-string">"C:\dev\local-weather-app\dist\local-weather-app"</span>? [Y/n] y
? Which scope <span class="hljs-keyword">do</span> you want to deploy to? Doguhan Uluca
? Found project <span class="hljs-string">"duluca/local-weather-app"</span>. Link to it? [Y/n] y
<span class="mediaobject"><img alt="" src="../Images/B14094_04_15.png"/></span>  Linked to duluca/local-weather-app (created .now <span class="hljs-keyword">and</span> added it to .gitigre)
<span class="mediaobject"><img alt="" src="../Images/B14094_04_16.png"/></span>  Inspect: https:<span class="hljs-comment">//zeit.co/duluca/local-weather-app/jy2k1szdi [2s]       </span>
<span class="mediaobject"><img alt="" src="../Images/B14094_04_17.png"/></span>  Production: https:<span class="hljs-comment">//local-weather-app.duluca.now.sh [copied to clipboard] [4s]</span>
</code></pre>
      </li>
      <li class="list" value="4">Follow <a id="_idIndexMarker408"/>the URL displayed on the screen to see that your app has been successfully deployed, in my case, <a href="https://local-weather-app.duluca.now.sh"><span class="url">https://local-weather-app.duluca.now.sh</span></a>.<div class="note">
          <p class="Information-Box--PACKT-">Note the warning about a missing <code class="Code-In-Text--PACKT-">now.json</code> file. When we run the command, we specify our platform version as version 2 with the option <code class="Code-In-Text--PACKT-">--platform-version 2</code>, so a configuration file is not strictly necessary. However, if you wish to customize any aspect of your deployment, perhaps by using a custom domain, selecting a geographical region, or using scaling options, you should <a id="_idIndexMarker409"/>configure this file. For further information on how to make the best of <code class="Code-In-Text--PACKT-">now</code>, please refer to <a href="https://vercel.com/docs"><span class="url">https://vercel.com/docs</span></a>.</p>
        </div>
      </li>
    </ol>
    <p class="normal">If your deployment went successfully you should see your app display the current weather from Bethesda, US:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_04_14.png"/></figure>
    <p class="packt_figref">Figure 4.14: Successful deployment</p>
    <p class="normal">And you're <a id="_idIndexMarker410"/>done! Congratulations, your Angular app is live on the internet!</p>
    <h1 class="title" id="_idParaDest-144">Summary</h1>
    <p class="normal">In this chapter, you learned about the importance of unit testing and mastered Angular unit and e2e test configuration and setup. You learned how to configure Angular's TestBed and how to write unit tests using test doubles. You configured your Angular app for a production deployment. You ensured the quality of your application by creating a value delivery stream using a CI pipeline and GitHub flow. Finally, you successfully deployed a web application to the cloud.</p>
    <p class="normal">Now you know what it takes to build a production-ready Angular application that is reliable, resilient, and containerized to allow for a flexible deployment strategy. In the next chapter, we go over how you can add Angular Material to your project and make your Local Weather App look great. In the process, you will learn about the negative performance impact that user control or UI component libraries can have on your application, including essential Material components; Angular Flex Layout; accessibility; typography; theming; and how to update Angular Material.</p>
    <h1 class="title" id="_idParaDest-145">Further reading</h1>
    <ul>
      <li class="list"><em class="italics">Succeeding with Agile: Software Development Using Scrum</em>, Mike Cohn, 2009.</li>
      <li class="list"><em class="italics">TestPyramid</em>, Martin Fowler, 2012, <a href="https://martinfowler.com/bliki/TestPyramid.html"><span class="url">https://martinfowler.com/bliki/TestPyramid.html</span></a>.</li>
      <li class="list"><em class="italics">Jasmine 2 Spy Cheat Sheet</em>, Dave Ceddia, 2015, <a href="https://daveceddia.com/jasmine-2-spy-cheat-sheet"><span class="url">https://daveceddia.com/jasmine-2-spy-cheat-sheet</span></a>.</li>
      <li class="list"><em class="italics">The Practical Test Pyramid</em>, Ham Vocke, 2018, <a href="https://martinfowler.com/articles/practical-test-pyramid.html"><span class="url">https://martinfowler.com/articles/practical-test-pyramid.html</span></a>.</li>
      <li class="list"><em class="italics">SOLID Principles</em>, Wikipedia, 2019, <a href="https://en.wikipedia.org/wiki/SOLID"><span class="url">https://en.wikipedia.org/wiki/SOLID</span></a>.</li>
    </ul>
    <h1 class="title" id="_idParaDest-146">Questions</h1>
    <p class="normal">Answer the following questions as best as you can to ensure that you've understood the key concepts from this chapter without Googling. Do you need help answering the questions? See <em class="italics">Appendix D</em>, <em class="italics">Self-Assessment Answers</em> online at <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf"><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf</span></a> or visit <a href="https://expertlysimple.io/angular-self-assessment"><span class="url">https://expertlysimple.io/angular-self-assessment</span></a>.</p>
    <ol>
      <li class="list">What is the test pyramid?</li>
      <li class="list">What are fixtures and matchers?</li>
      <li class="list">What are the differences between a mock, spy, and a stub?</li>
      <li class="list">What is the benefit of building Angular in prod mode?</li>
      <li class="list">How does GitHub flow work?</li>
      <li class="list">Why should we protect the master branch?</li>
    </ol>
  </div>
</body></html>