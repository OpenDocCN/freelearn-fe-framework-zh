- en: '*Chapter 7*: Component Harnesses'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a fundamental part of software development. It helps ensure that
    the code that's delivered covers the feature requirements and is free of implementation
    issues. Sometimes, when testing UI code, it is hard to avoid performing tightly
    coupled tests on the DOM structure. However, Angular Ivy brings a new solution
    for this. Component testing harnesses make it possible to develop a testing API
    for our components using the industry-standard Page Object pattern, but on a more
    granular level.
  prefs: []
  type: TYPE_NORMAL
- en: To top this off, component harnesses for the Angular Material directives and
    components are already included in Angular Ivy. In this chapter, we will learn
    how to use the component testing harnesses in Angular Components and how to implement
    custom component harnesses to make it easier to test our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular Material's component harnesses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a component harness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have gained an overview of how and where
    to use component harnesses.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular Material's component harnesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You saw an example of how to use the **Material Button harness** in [*Chapter
    4*](B16295_04_ePub_RK.xhtml#_idTextAnchor055), *Exploring Angular Components Features.*
    Now, let's explore how to test the **theme** component using the material test
    harnesses with a *Test as a user* strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might remember, the theme component lets us select the color and size
    settings for Angular Academy. The user can do this by selecting a color by going
    to the `MatInputHarness` with the `#headerBackground` selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we expect the default setting to be `'#00aa00'`. We retrieve the value
    from the test harness using the `getValue` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we could also simply find the value in the input field with
    the `''#headerBackground''` ID and check its value. So, let''s build a more complicated
    test where we should be able to change the header background color theme setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we did earlier, we will use the component harness to interact with the `'#ffbbccc'`
    and check that this setting has been picked up by the theme setting.
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice that we did not write `fixture.detectChanges()`in this test?
    We can avoid this because we are using the component harness that will handle
    the DOM operations here. Clicking this input field and interacting with the color
    selector as the user would have done is somewhat complex using DOM operations,
    but here, we are using the operations on the component testing harness instead.
    By doing this, we can avoid brittle changes in the test related to change detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can use `MatSliderHarness` to `MatInputHarness` to avoid performing
    DOM operations when testing the **Video Size** slider setting for the theme component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can retrieve the default `videoSize` setting from the theme service
    and the screen component to check that it is `7` by using API operations from
    the test harness. Using the `async`/`await` construct in combination with the
    test harness leads to fairly compact code here.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should know how to use the existing material component harnesses.
    Next, let's dive into how to build component harnesses for the Angular Academy
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a component harness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine that we want to expose our `Video` component so that it can be
    integrated with other applications. Here, it would make sense to write a test
    harness for it – but how should we structure it? Our example of displaying YouTube
    videos using a YouTube Player component inside a `Video` component, which will
    be inside a Course component, turns out to be difficult to test using a "test
    as a user" approach in the DOM directly. So, let's take a layered approach here.
  prefs: []
  type: TYPE_NORMAL
- en: 'When constructing a component, we should strive to only have a single reference
    point – the DOM – for each page. Taking a layered approach, we start the test
    from the Course component, which knows about the Video component, which, in turn,
    knows about the YouTube Player component. By doing this, we can test from the
    `Course` component by exposing the `Video` harness that encapsulates the `workspace-video`
    selector as a Page Object for each of the instances of the `Video` component,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can display the text for each video by using the `getText()` call from
    the `course.component.spec.ts` file. Then, we can use the supplied `textEquals`
    call to test for equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we looped through all the rendered videos for course `'1'` in the course
    component and checked that each of the texts accompanying the rendered videos
    contain the course title we can retrieve via the course service. Note that the
    `textEquals` function is supplied from the test harness here, which means we can
    change that function in a later version of the component library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will let the `Video` harness hide the DOM operations related to the videos
    using a Page Object approach. The `Video` harness will then know about the implementation
    that''s specific to the `YouTubePlayer` harness, which encapsulates the `youtube-player`
    selector, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When rendering videos using the Angular YouTube Player, we expect the video
    IDs to be available. The trick here is that we want to hide the implementation
    details for the Angular YouTube Player from the test for the Course component.
    So, let''s introduce the `getVideoId` function to the `Video` harness so that
    it is available when we test from the Course component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The full `Video` harness will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can expose the `Video` test harness, along with the `Video`
    component, to anyone that wants to use our `Video` component in their application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some examples of how to use some of the existing
    test Material UI test harnesses in the context of the Angular Academy application.
    Additionally, we introduced how to implement a component harness for the `Video`
    component that is used in the Angular Academy application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will wrap up our Angular Academy application by showing
    you how to use the new provider scopes.
  prefs: []
  type: TYPE_NORMAL
