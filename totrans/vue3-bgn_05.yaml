- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leveraging Computed Properties and Methods in Vue.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about `<template>` section of our component.
    In this chapter, we are going to move our focus to the `<script>` tag and learn
    how to ensure that the logic of our component is abstracted.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter aims to introduce you to two features: **methods** and **computed**.
    These Vue.js features are essential to ensuring that your component logic remains
    performant and readable. We will go over the components that we created in previous
    chapters and use the preceding techniques to make them easier to read. Throughout
    the chapter, we will also continue to add further details to features that we
    have learned about in previous chapters, such as Refs variables and directives.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is going to be broken down into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting functionality using methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating dynamic data using computed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the difference between methods and computed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to abstract your logic within methods,
    create reactive variables using computed properties, and most importantly, understand
    the difference between them.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to follow this chapter, you should use a branch called `CH05`. To
    pull this branch, run the following command or use your GUI software of choice
    to support you in this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting functionality using methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the components shown within tutorials and training, such as the ones
    shared in this book so far, always appear to be easy to read and extremely small,
    but this is not always the case. Components written in real applications can easily
    get bloated with logic and become very hard to read. Most of the time, this complexity
    is the result of multiple iterations and feature changes.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to try and keep the components as clean as possible. The
    easiest way to achieve this is by abstracting the logic from the HTML and moving
    it within `<script>`, but what can we use to simplify our components?
  prefs: []
  type: TYPE_NORMAL
- en: This is where methods come in handy. Methods are JavaScript functions that can
    be used within a Vue.js component instance. Methods can be described as helpers
    that allow you to perform an action within your component.
  prefs: []
  type: TYPE_NORMAL
- en: Methods could be used in a wide variety of cases, from fetching data from an
    API to validating user input, and will be our go-to Vue.js feature to simplify
    our component’s logic.
  prefs: []
  type: TYPE_NORMAL
- en: Writing methods while using the Composition API syntax is extremely simple as
    methods are just simple JavaScript functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is time to check out the correct branch from our repository as previously
    mentioned in the *Technical requirements* section and see methods in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to look at the HTML of the `SocialPost.vue` component within the
    `components/molecules` folders and try to find some logic that can be extracted.
    What we are looking for is any JavaScript code that we have written within the
    HTML elements of our components that can be turned into a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you analyze a component, the best candidates for refactoring into methods
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Logic associated with events (click, change)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic that requires a parameter (loop index)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic that performs a side effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our preceding code, we have two instances of click events that have some
    logic associated with them: `@click="selected = !selected"` within the first `<DIV>`
    and `@click="showComments = !showComments"` in the `Show` `Comments` button.'
  prefs: []
  type: TYPE_NORMAL
- en: These are great candidates to be refactored as that logic should not live within
    the DOM (Document Object Model) but be moved out within the `<script>` tag of
    our component. Refactoring this code is done in two simple steps. First, we will
    create a method within our `<script>` and then we will replace the logic with
    our newly created method.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create two functions within our component logic called `onSelectedClick`
    `and` `onShowCommentClick`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Prefix your event handler with “on”
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that I have prefixed the event method name with the word
    “on” and suffixed it with the event name (click). This is good practice as it
    makes the code more readable and helps you identify methods that are associated
    with events.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the Composition API syntax, we can group our functionalities by adding
    the methods right below the Ref's initialization, making our code clean and easy
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: Read and write Ref in the <script> tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that the code has something different from the logic that
    we used in the HTML. The `selected` and `showComments` Refs have a different syntax
    as they are followed by `.value`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding `.value` to a Ref is a requirement when reading and writing Ref within
    the `<script>` tag and does not apply to Reactive variables, which can be accessed
    with normal variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a visual to help clarify the difference between Ref and Reactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Table displaying the differences when reading and writing Ref
    and Reactive within the <script> and <template> tags](img/B21130_05_01_BW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Table displaying the differences when reading and writing Ref and
    Reactive within the <script> and <template> tags'
  prefs: []
  type: TYPE_NORMAL
- en: I know that this may be confusing at first, but by the end of the book, you
    will have mastered this difference as we will iterate and use this multiple times
    in the course of our development.
  prefs: []
  type: TYPE_NORMAL
- en: Why do Ref need .value
  prefs: []
  type: TYPE_NORMAL
- en: Vue reactivity is built on top of the proxy object that listens for “get” and
    “set” events of a variable. This proxy is not available in primitive values such
    as string, number, and Booleans (the type used with ref). To overcome this, these
    primitives are transformed into objects with a single property of `.value`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our methods have been created, it is time to call them. We are going
    to call these methods from the HTML of our component. To do so, we are going to
    remove the previous logic that was assigned to the `@click` event and replace
    it with the methods that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our main `<div>` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Show Comments` button will transform into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the logic associated with our click events has
    been moved into the `<``script>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The change we made may seem very irrelevant and not worth it, but small readability
    improvements such as this one contribute to a code that is not only easy to read
    but also easy to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify our component one more time and assume that we have been tasked
    to trigger a log using `console.log` every time the `<script>` tag of our component
    and they can easily be expanded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Adding `console.log` could not be easier. We We modified the methods methods
    using our existing JavaScript knowledge, as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn
  prefs: []
  type: TYPE_NORMAL
- en: Try to create your own methods. My suggestions would be to try and add `console.log`
    to a message when one of the components mounts (you can use `onMounted`) or continue
    to practice using Ref and Reactive by creating a method that logs how many posts
    and comments the application has.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to refactor your components by using methods and improve
    the readability of your code. Breaking down complex code into smaller functions
    will help us keep our components maintainable. In the next section, we are going
    to look at a similar feature offered by Vue.js called computed properties.
  prefs: []
  type: TYPE_NORMAL
- en: Creating dynamic data using computed properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to simplify our component by abstracting
    the logic of our click events. We are going to continue on the subject of “refactoring”
    and introduce a new feature called **computed properties**.
  prefs: []
  type: TYPE_NORMAL
- en: When people first learn about computed properties, they usually compare them
    to methods due to their similarities, but in reality, this feature is more closely
    related to props and Ref than methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computed properties can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties enable you to create a dynamic property that can be used
    to modify, manipulate, and display your component data (refs, reactive, and properties).
    - [https://blog.logrocket.com/](https://blog.logrocket.com/)
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used Ref, Reactive, and props to pass and display data within
    our application, but there are times when the data received may need to be formatted,
    or when we need to create new data altogether.
  prefs: []
  type: TYPE_NORMAL
- en: When the need for dynamic properties arises, a computed property is the correct
    feature to use.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start to modify the Companion App, let’s introduce a couple of real-life
    examples to help better understand computed properties and their goal.
  prefs: []
  type: TYPE_NORMAL
- en: '*Scenario 1 –* *student list*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s assume we receive data from an API that returns all students from a school,
    but we just want to filter out female students. We can use a computed property
    to create a filtered array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Scenario 2 – toggle on* *array length*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we have been asked to show a button only if five or more entries
    exist in our list. We can use computed properties to check the length of our entries
    and create a new property with a Boolean value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Scenario 3 –* *concatenate values*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine an application that has a first name and last name as properties, and
    you wish to have access to a variable including the full name. Well, we can use
    a computed property to create this value, which will depend on the first and second
    names.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Scenario 4 –* *snippets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have you ever encountered a blog in which you see just a small part of the blog
    post and can click “show more” to show the full article? Well, to achieve this,
    we can create computer properties that take our blog post and just return a certain
    number of characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you re-read the preceding example, you may notice that they all have something
    in common. In fact, all the scenarios that we proposed have the following similarities:'
  prefs: []
  type: TYPE_NORMAL
- en: They all create a new piece of data / value that is required within the component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They do not produce any side effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They all depend on another piece of data (props, Refs, or Reactive)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding bullets are present in all of the scenarios that I proposed, not
    because of my choice, but because they are the prerequisites of computed properties.
  prefs: []
  type: TYPE_NORMAL
- en: A computed property is simply a feature that allows us to use one or more existing
    pieces of data (Refs, Reactive, and props) to create a new value.
  prefs: []
  type: TYPE_NORMAL
- en: It is time to start and look at some examples to be able to learn how and when
    to use this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of a computed property is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When using a computed property, we need to first import it from Vue and then
    assign it to a new constant. The computed property accesses a callback that is
    going to include the logic required to create a new variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a simple example and show how a computed property that creates a
    full name would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created a new dynamic property called `fullName`.
    This will act just like a normal property and can be used everywhere without our
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like we said before, the computed property fulfills our requirements,
    which are as follows: it creates new data (`fullName`), depends on another value
    (`name` and `surname`), and returns a value.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding computed properties to the companion application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is now time to update our component and see how we can leverage computed
    properties to simplify our code even further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in the previous section, we are going to continue to modify the `SocialPost.vue`
    file. Let’s review the file and try to see what a good candidate would be for
    a computed property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we can see that the logic associated with the `v-show`
    directive has been highlighted. This is our best candidate to be turned into a
    computed property.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties need to return a value that depends on another value and
    has no side effect, and the preceding highlighted logic does just that. In fact,
    it returns a boolean of `true` or `false`, it depends on the value of `comments`,
    and it does nothing else that can be defined as a side effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like methods, to be able to convert this logic into a computed property,
    we need to move its logic into the `<script>` tag of our component. Let’s see
    the steps required to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import `computed` at the top of our `<``script>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a function that uses a computed property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we are going to add our logic as the first argument of the computed method
    as a callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Last, we replace the existing logic in the HTML with the new computed property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the preceding code, we have now created a new property within our component
    called `hasComments`. This property, just like every other Vue.js variable, is
    responsive and will change as soon as the `comments` array changes.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing performance with cached values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating computed properties not only improves the readability of our component
    but also improves the performance of our application by caching the value.
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that the actual function included within the computed property
    just gets run once, when the component mounts, but it does not run again when
    the component renders unless the dependent value changes.
  prefs: []
  type: TYPE_NORMAL
- en: This may not bring a massive improvement to our simple example, but it does
    make a big difference in large applications where the computed property could
    actually be a large array with 100s of entries!
  prefs: []
  type: TYPE_NORMAL
- en: Formatting your data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computed properties are not very common among other major frameworks and they
    are seen as a new technique/feature for most Vue.js developers. Due to their unique
    nature, it can be hard at times to grasp and use them in real life. To ensure
    that the topic has been fully understood, we are going to create a couple of extra
    examples that make use of computed properties.
  prefs: []
  type: TYPE_NORMAL
- en: If you open the file called `TheWelcome.vue` and check the `posts` Reactive
    value, you will notice that there are extra parameters in the object. In fact,
    the value of `likes` and `retweets` has been added to our posts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: The posts Reactive property including extra likes and retweets
    entries](img/B21130_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: The posts Reactive property including extra likes and retweets
    entries'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to create a new dynamic property that will hold
    the total number of interactions. We are going to do so by adding all the different
    interactions, including comments, likes, and retweets.
  prefs: []
  type: TYPE_NORMAL
- en: This new computed property will be called `interactions`, and in the case in
    which our post has 2 comments, 2 likes, and 1 retweet, it will return a value
    of `5` (2 + 2 + 1).
  prefs: []
  type: TYPE_NORMAL
- en: This example should help you understand that the computed property is not just
    a way to prettify your component, but is actually a powerful tool that helps you
    enhance the features of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Give it a try
  prefs: []
  type: TYPE_NORMAL
- en: Why don’t you give it a try and attempt to create the computed property by yourself?
    Creating this computed property will require you to put into practice everything
    you learned until now, so why not take a little challenge?
  prefs: []
  type: TYPE_NORMAL
- en: Successfully creating a computed property to display our interaction requires
    a couple of steps. The following diagram shows how the data flows through the
    component, and it will help contextualize the steps we will have to take to fully
    define our computed property.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Data flow from the parent component to the computed property](img/B21130_05_03_BW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Data flow from the parent component to the computed property'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we have already covered each of the preceding entries,
    but this will be the first time that we are using them all together in one single
    exercise. Generating a full data flow like this will be very common in your development
    life, so it is beneficial to get some early practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over the preceding data flow one step at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set data in the** **parent component**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s open TheWelcome.vue and check the parameters available in the posts Reactive
    within the <script> tag:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As shown in the preceding code, the properties of likes and retweets are already
    set for us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The new properties are added to the instance of the** **child component**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As explained in a previous chapter, a component requires properties to be passed
    to it, before it can use them. So, in our case, we need to add the new likes and
    retweets properties to the instances of <SocialPost>:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding example shows how you can add it to the first entry and how you
    can replicate the same for the second one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The new properties are read by the child component** **using definedProps:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To achieve this step, we need to open the SocialPost.vue file and add the new
    properties of likes and retweets in the list of definedProps. These are both going
    to be Number types:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Create a new computed property that uses the** **new properties**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The computed function is going to use the newly created properties and create
    a new dynamic property called interactions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just like every computed property, our preceding function creates a new `interactions`
    value using the `computed()` function and returns a value, which, in our case,
    is the sum of different properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The computed value is added to `<template>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we used our knowledge of string interpolation to print the value of interactions
    within the component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Style** **the HTML**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last step requires us to style the HTML. This can be done by using plain
    CSS within the <style> tag of our component:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After following the steps defined previously, our new property for `interactions`
    is fully set up and available within our companion application, as shown in the
    following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Companion application screenshot showing interactions](img/B21130_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Companion application screenshot showing interactions'
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties will be a vital part of your Vue.js application and it is
    vital to understand when you should use them and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn
  prefs: []
  type: TYPE_NORMAL
- en: Try to create your own computed property. Open up the `TheHeader.vue` file and
    try to replace the current implementation of `Welcome {{ username }}` with a new
    computed property called `welcomeMessage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we learned how to enhance our components by creating dynamic
    properties using computed properties. We have explained the three factors that
    make a computed property, which are as follows: it produces no side effect, creates
    a new variable, and depends on other component variables. Finally, we went over
    two different coding exercises to better understand the meaning and usage of computed
    properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the difference between methods and computed properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During my career, I have seen many people misusing methods and computed properties.
    In this section, we are going to clarify the difference between the two features
    and provide you with a guide that you can revisit during the course of your early
    career.
  prefs: []
  type: TYPE_NORMAL
- en: Technical differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It may be a good starting point to re-iterate what we discussed in the previous
    two sections and see side by side what the technical differences are between these
    two Vue.js features:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: A table showing the technical differences between methods and
    computed properties](img/B21130_05_05_BW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: A table showing the technical differences between methods and computed
    properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s focus on some of the main differences displayed in *Figure 5**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time of initialization**: Methods can be initialized on demand by the user,
    while computed properties are triggered during the component creation life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters and dependencies**: While methods can accept parameters, computed
    properties can just use other component props and data that are called dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluation**: Methods are evaluated every time they are called, making them
    very expensive, while computed properties are cached and just re-evaluated if
    any of their dependencies are updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Side effect**: Side effects occur when a method or a function modifies a
    value or triggers an action outside of its local scope. So, for example, triggering
    an API call is a side effect, or changing a variable that is not returned by the
    method is a side effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of a computed property is to create a new variable and it should never
    include any side effect, while the main scope of methods is to produce side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If someone were asked to define the difference between computed properties
    and methods in a single sentence, I would say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods are helper functions that allow you to complete an action, while computed
    properties allow you to create a new component property.
  prefs: []
  type: TYPE_NORMAL
- en: How to spot them in your component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we spoke about the technical differences between methods
    and computed properties, while in this section we will see where we would find
    these helpers within a component.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing where computed properties and methods are used within the component
    structure will help you make the correct choice. To better see whether we can
    make the correct choice, we are going to use a dummy component. This component
    has a few placeholders delimited by `???`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spend a couple of minutes to try and understand whether this is going to be
    methods or computed properties and why you have made this choice. When you are
    ready, you can read my explanation and see whether it matches your choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The first placeholder is `fetchBlog`. This is going to be a method. The decision
    is based on the fact that `fetchBlog` is not only going to trigger a side effect,
    contacting an external API, but it is also called in the `onMounted` life cycle.
    As we previously defined, only methods can be triggered on demand.
  prefs: []
  type: TYPE_NORMAL
- en: The second one is `onShowAll`. This is going to run an action, something that
    will be triggered when the user clicks a button. Again, in this instance, we are
    going to define this as a method because it is triggered by an event, will include
    a side effect, and will accept parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have `snippets`. This variable is used in the template just like
    a variable. As we should know by now, creating dynamic variables is the perfect
    match for a computed property. In this instance, `snippets` is going to be a computed
    property that will depend on the blog content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what the `updates` script may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: With all the examples we have covered so far, you should have obtained a good
    understanding of these two different features.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced methods and used them to clean up the components
    of our Companion App. We learned the difference between Refs and Reactive and
    learned how to use them within the `<script>` section of components, and then
    we moved forward and learned how to create dynamic properties using computed properties.
    To complete the chapter, we fortified our knowledge of these two topics by going
    over a few more examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to create and manage events using
    Vue event handling. Up until now, we have focused on the individual components,
    but with the introduction of events and events handling, we will be able to define
    two-way communication between components. Event propagation is an essential skill
    to have to be able to develop scalable and clear component-based applications.
  prefs: []
  type: TYPE_NORMAL
