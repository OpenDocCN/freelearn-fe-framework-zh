<html><head></head><body>
		<div id="_idContainer138">
			<h1 id="_idParaDest-249" class="chapter-number"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.2.1">Testing PrimeNG Components</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will dive into the critical aspects of testing Angular applications powered by PrimeNG components. </span><span class="koboSpan" id="kobo.3.2">Throughout the journey, you will learn how to effectively test your PrimeNG components, ensuring their reliability </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and functionality.</span></span></p>
			<p><span class="koboSpan" id="kobo.5.1">By understanding the principles, techniques, and tools of testing, you can enhance the quality, stability, and maintainability of your Angular applications. </span><span class="koboSpan" id="kobo.5.2">Throughout this chapter, you will acquire fundamental knowledge on setting up tests and efficiently testing your Angular components through various examples. </span><span class="koboSpan" id="kobo.5.3">Additionally, you will become acquainted with best practices and libraries that can enhance and support your </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">testing endeavors.</span></span></p>
			<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.9.1">Getting started with basic </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Angular testing</span></span></li>
				<li><span class="koboSpan" id="kobo.11.1">Writing tests for </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">PrimeNG components</span></span></li>
				<li><span class="koboSpan" id="kobo.13.1">Utilizing testing tips </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and tricks</span></span></li>
			</ul>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.16.1">This chapter contains various code samples for testing. </span><span class="koboSpan" id="kobo.16.2">You can find the related source code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.17.1">chapter-13</span></strong><span class="koboSpan" id="kobo.18.1"> folder of the following GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">repository: </span></span><a href="https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-13"><span class="No-Break"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-13</span></span></a><a href="https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG"/></p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.21.1">Getting started with basic Angular testing</span></h1>
			<p><span class="koboSpan" id="kobo.22.1">In this section, we will </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.23.1">introduce you to the fundamentals of testing in Angular applications. </span><span class="koboSpan" id="kobo.23.2">Testing is an essential part of the development process that allows early bug detection, faster feedback cycles, and improved code stability. </span><span class="koboSpan" id="kobo.23.3">Moreover, when continuously making changes to your code over time, following testing best practices can effectively mitigate potential issues, preserve existing functionality, and ensure the delivery of high-quality software to </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">your users.</span></span></p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.25.1">Introduction to Angular testing fundamentals</span></h2>
			<p><span class="koboSpan" id="kobo.26.1">Angular provides a </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.27.1">robust testing framework that allows you to write tests for your components, services, and other parts of your application. </span><span class="koboSpan" id="kobo.27.2">Testing in Angular is based on the principles of unit testing, where individual units of code are tested in isolation. </span><span class="koboSpan" id="kobo.27.3">This approach helps ensure that each unit functions correctly and meets the </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">expected requirements.</span></span></p>
			<p><span class="koboSpan" id="kobo.29.1">Testing in Angular involves writing test cases that simulate user interactions, verify component behavior, and assert expected outcomes. </span><span class="koboSpan" id="kobo.29.2">These tests help you identify and fix bugs, validate business logic, and ensure that your application works </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">as intended.</span></span></p>
			<p><span class="koboSpan" id="kobo.31.1">When you first install an Angular project, it comes </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.32.1">with </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">Karma</span></strong><span class="koboSpan" id="kobo.34.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">Jasmine</span></strong><span class="koboSpan" id="kobo.36.1"> as the </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.37.1">main testing frameworks. </span><span class="koboSpan" id="kobo.37.2">You can see the packages and configurations under </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">package.json</span></strong><span class="koboSpan" id="kobo.39.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">angular.json</span></strong><span class="koboSpan" id="kobo.41.1"> in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">code block:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.43.1">
// package.json
"devDependencies": {
  ...
</span><span class="koboSpan" id="kobo.43.2">  "@types/jasmine": "~4.3.0",
  "jasmine-core": "~4.6.0",
  "karma": "~6.4.0",
  "karma-chrome-launcher": "~3.2.0",
  "karma-coverage": "~2.2.0",
  "karma-jasmine": "~5.1.0",
  "karma-jasmine-html-reporter": "~2.1.0",
}
// angular.json
"test": {
  "builder": "@angular-devkit/build-angular:karma",
  "options": {
    "polyfills": [
      "zone.js",
      "zone.js/testing"
    ],
    "tsConfig": "tsconfig.spec.json",
    ...
</span><span class="koboSpan" id="kobo.43.3">  }
}</span></pre>			<p><span class="koboSpan" id="kobo.44.1">This code </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.45.1">snippet is part of the configuration files for setting up testing in an Angular application. </span><span class="koboSpan" id="kobo.45.2">Let’s break this code </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">block down:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">devDependencies: {...}</span></strong><span class="koboSpan" id="kobo.48.1">: This contains the packages for running tests in Angular. </span><span class="koboSpan" id="kobo.48.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">karma-jasmine-html-reporter</span></strong><span class="koboSpan" id="kobo.50.1"> generates a detailed HTML report after </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">tests run.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">karma</span></strong><span class="koboSpan" id="kobo.53.1">: This is a popular test runner for JavaScript applications. </span><span class="koboSpan" id="kobo.53.2">It allows you to execute tests in multiple browsers, capture the results, and report them. </span><span class="koboSpan" id="kobo.53.3">When you run </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">ng test</span></strong><span class="koboSpan" id="kobo.55.1">, Karma</span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.56.1"> launches a development server, opens specified browsers, and executes Jasmine tests in </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">those browsers.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">jasmine</span></strong><span class="koboSpan" id="kobo.59.1">: This </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.60.1">is a </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">behavior-driven development</span></strong><span class="koboSpan" id="kobo.62.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.63.1">BDD</span></strong><span class="koboSpan" id="kobo.64.1">) testing framework for JavaScript. </span><span class="koboSpan" id="kobo.64.2">In the context of Angular, Jasmine</span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.65.1"> is often used as the testing framework for writing and running </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">unit tests.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">"builder": "@angular-devkit/build-angular:karma"</span></strong><span class="koboSpan" id="kobo.68.1">: This is a builder provided by the Angular DevKit, and it’s used as a target for running </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">Karma tests.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.70.1">In order to</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.71.1"> run a test in Angular, you can run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">npm run test</span></strong><span class="koboSpan" id="kobo.73.1"> command, which will generate the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">following result:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.75.1">
npm run test
&gt; primeng-book@0.0.0 test
&gt; ng test
 Browser application bundle generation complete.
</span><span class="koboSpan" id="kobo.75.2">15 11 2023 09:42:30.460:WARN [karma]: No captured browser, open http://localhost:9876/
15 11 2023 09:42:30.500:INFO [karma-server]: Karma v6.4.2 server started at http://localhost:9876/
15 11 2023 09:42:30.500:INFO [launcher]: Launching browsers Chrome with concurrency unlimited
15 11 2023 09:42:30.503:INFO [launcher]: Starting browser Chrome
15 11 2023 09:42:33.251:INFO [Chrome 119.0.0.0 (Mac OS 10.15.7)]: Connected on socket 3D7e73rrBAAAB with id 37006674
Chrome 119.0.0.0 (Mac OS 10.15.7): Executed 0 of 3 SUCCESS (
Chrome 119.0.0.0 (Mac OS 10.15.7): Executed 1 of 3 SUCCESS (
Chrome 119.0.0.0 (Mac OS 10.15.7): Executed 2 of 3 SUCCESS (
Chrome 119.0.0.0 (Mac OS 10.15.7): Executed 3 of 3 SUCCESS (
Chrome 119.0.0.0 (Mac OS 10.15.7): Executed 3 of 3 SUCCESS (0.139 secs / 0.12 secs)
TOTAL: 3 SUCCESS</span></pre>			<p><span class="koboSpan" id="kobo.76.1">The result of the </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.77.1">test will also appear in the terminal and </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">the browser:</span></span></p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<span class="koboSpan" id="kobo.79.1"><img src="image/B18805_13_01.jpg" alt="Figure 13.1 – Karma test result"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.80.1">Figure 13.1 – Karma test result</span></p>
			<p><span class="koboSpan" id="kobo.81.1">As a result, when you run </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.82.1">the command for testing, Karma will open the browser and successfully execute the tests from </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">AppComponent</span></strong><span class="koboSpan" id="kobo.84.1">. </span><span class="koboSpan" id="kobo.84.2">Additionally, you will be able to observe the executed tests and </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">their outcomes.</span></span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.86.1">Angular testing with Jest</span></h2>
			<p><span class="koboSpan" id="kobo.87.1">In Angular, Karma and Jasmine </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.88.1">have been the default testing framework choices, but with the introduction of</span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.89.1"> Angular v16, </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">Jest</span></strong><span class="koboSpan" id="kobo.91.1"> has been included as an experimental alternative for writing unit tests. </span><span class="koboSpan" id="kobo.91.2">The decision to adopt Jest stems from the fact that Karma, while effective, relies on a real web browser, leading to slower and heavier tests. </span><span class="koboSpan" id="kobo.91.3">Additionally, the use of a real browser introduces complexities </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.92.1">in </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">continuous integration</span></strong><span class="koboSpan" id="kobo.94.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.95.1">CI</span></strong><span class="koboSpan" id="kobo.96.1">). </span><span class="koboSpan" id="kobo.96.2">Another</span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.97.1"> factor to consider is that</span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.98.1"> Karma has been </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">deprecated (</span></span><a href="https://github.com/karma-runner/karma"><span class="No-Break"><span class="koboSpan" id="kobo.100.1">https://github.com/karma-runner/karma</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.101.1">).</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.102.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.103.1">CI is a development practice that involves automatically integrating code changes from multiple contributors into a shared repository. </span><span class="koboSpan" id="kobo.103.2">It includes automated processes such as building and testing to detect integration issues early in the development cycle. </span><span class="koboSpan" id="kobo.103.3">CI promotes collaboration, accelerates development, and ensures code quality by providing immediate feedback on the health of the code base. </span><span class="koboSpan" id="kobo.103.4">Popular CI tools include Jenkins, Travis CI, CircleCI, and </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">GitHub Actions.</span></span></p>
			<p><span class="koboSpan" id="kobo.105.1">Here are some other benefits when </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">running Jest:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.107.1">Snapshot testing</span></strong><span class="koboSpan" id="kobo.108.1">: This </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.109.1">simplifies the process of visually inspecting changes in the UI and helps prevent </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">unintended regressions.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.111.1">Fast and parallel test execution</span></strong><span class="koboSpan" id="kobo.112.1">: Jest is known for its speed and efficient test execution. </span><span class="koboSpan" id="kobo.112.2">It can run tests in parallel, providing quicker feedback </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">during development.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.114.1">Easy to integrate</span></strong><span class="koboSpan" id="kobo.115.1">: Jest is easily set up with Angular projects without requiring </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">complex configuration.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.117.1">Built-in code coverage reports</span></strong><span class="koboSpan" id="kobo.118.1">: Jest includes built-in support for generating code coverage reports. </span><span class="koboSpan" id="kobo.118.2">This allows developers to assess how much of their code is covered by tests, aiding in identifying areas that may need </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">additional testing.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.120.1">Mocking and spying simplified</span></strong><span class="koboSpan" id="kobo.121.1">: Jest provides a convenient API for creating mocks and spies, making it easier to isolate components or services </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">during testing.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.123.1">Watch mode with intelligent test re-runs</span></strong><span class="koboSpan" id="kobo.124.1">: Jest’s watch mode intelligently re-runs only the tests affected by code changes, significantly speeding up the feedback loop </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">during development.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.126.1">Ecosystem and community</span></strong><span class="koboSpan" id="kobo.127.1">: Jest has a vibrant and active community with a growing ecosystem of plugins and extensions. </span><span class="koboSpan" id="kobo.127.2">This can be advantageous when looking for solutions, support, or integrations within the broader JavaScript and </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">testing </span></span><span class="No-Break"><a id="_idIndexMarker679"/></span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">ecosystem.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.130.1">So, let’s </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.131.1">change our </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.132.1">testing framework to Jest instead. </span><span class="koboSpan" id="kobo.132.2">First, you need to install Jest packages by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">following command:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.134.1">
npm install jest jest-environment-jsdom --save-dev</span></pre>			<p><span class="koboSpan" id="kobo.135.1">This command will install </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">jest</span></strong><span class="koboSpan" id="kobo.137.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">jest-environment-jsdom</span></strong><span class="koboSpan" id="kobo.139.1">, which is an environment for Jest that simulates a browser-like environment </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">using JSDOM.</span></span></p>
			<p><strong class="bold"><span class="koboSpan" id="kobo.141.1">JSDOM</span></strong><span class="koboSpan" id="kobo.142.1"> is a</span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.143.1"> JavaScript-based library that emulates a web browser’s </span><strong class="bold"><span class="koboSpan" id="kobo.144.1">Document Object Model</span></strong><span class="koboSpan" id="kobo.145.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.146.1">DOM</span></strong><span class="koboSpan" id="kobo.147.1">) in </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.148.1">a Node.js environment. </span><span class="koboSpan" id="kobo.148.2">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">jest-environment-jsdom</span></strong><span class="koboSpan" id="kobo.150.1">, Jest tests can run in a simulated browser environment, allowing you to write and run tests that interact with the DOM, handle events, and perform other </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">browser-related operations.</span></span></p>
			<p><span class="koboSpan" id="kobo.152.1">After that, let’s update our </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">testing target:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.154.1">
// angular.json
"test": {
</span><strong class="bold"><span class="koboSpan" id="kobo.155.1">  "builder": "@angular-devkit/build-angular:jest",</span></strong><span class="koboSpan" id="kobo.156.1">
  "options": {
    "polyfills": ["zone.js", "zone.js/testing"],
    "tsConfig": "tsconfig.spec.json"
  }
}</span></pre>			<p><span class="koboSpan" id="kobo.157.1">By</span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.158.1"> changing</span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.159.1"> the builder from </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">@angular-devkit/build-angular:karma</span></strong><span class="koboSpan" id="kobo.161.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">@angular-devkit/build-angular:jest</span></strong><span class="koboSpan" id="kobo.163.1">, we now can utilize Jest for running our </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">unit tests.</span></span></p>
			<p><span class="koboSpan" id="kobo.165.1">Let’s have a look at the test result by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">npm </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">run test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.169.1">
&gt; primeng-book@0.0.0 test
&gt; ng test
NOTE: The Jest builder is currently EXPERIMENTAL and not ready for production use.
</span><span class="koboSpan" id="kobo.169.2">Application bundle generation complete. </span><span class="koboSpan" id="kobo.169.3">[1.619 seconds]
(node:22351) ExperimentalWarning: VM Modules is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
PASS  dist/test-out/app.component.spec.mjs
  AppComponent
     should create the app (123 ms)
     should have as title 'Welcome to chapter-13' (27 ms)
     should render title (25 ms)
Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        1.398 s
Ran all test suites.</span></pre>			<p><span class="koboSpan" id="kobo.170.1">You will notice that there is no difference in the process of writing unit tests and the execution speed of the tests is </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">significantly faster.</span></span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.172.1">Step-by-step guide to writing your initial Angular tests</span></h2>
			<p><span class="koboSpan" id="kobo.173.1">Now that we have covered the preparation part, let’s dive into writing your first set of tests. </span><span class="koboSpan" id="kobo.173.2">In unit testing, you can utilize </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.174.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">Arrange, Act, and Assert</span></strong><span class="koboSpan" id="kobo.176.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.177.1">AAA</span></strong><span class="koboSpan" id="kobo.178.1">) pattern, a common methodology for structuring and organizing unit tests. </span><span class="koboSpan" id="kobo.178.2">Each part of AAA serves a </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">distinct purpose:</span></span></p>
			<ol>
				<li><strong class="bold"><span class="koboSpan" id="kobo.180.1">Arrange</span></strong><span class="koboSpan" id="kobo.181.1">: In this step, you set up the test environment. </span><span class="koboSpan" id="kobo.181.2">This involves creating instances of the components or services you want to test, providing any necessary dependencies, and configuring the initial state of </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">the test.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.183.1">Act</span></strong><span class="koboSpan" id="kobo.184.1">: This is where you perform the action or trigger the behavior that you want to test. </span><span class="koboSpan" id="kobo.184.2">It might involve calling a method, interacting with a component, or simulating </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">an event.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.186.1">Assert</span></strong><span class="koboSpan" id="kobo.187.1">: In the final step, you check the results of the action to ensure that it matches the expected outcome. </span><span class="koboSpan" id="kobo.187.2">This is where you make assertions about the state of your application after the action has </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">been performed.</span></span></li>
			</ol>
			<p><span class="koboSpan" id="kobo.189.1">Using the AAA pattern helps to keep tests organized, readable, and focused on specific behaviors. </span><span class="koboSpan" id="kobo.189.2">It provides a clear structure for writing and understanding tests, making it easier to maintain and troubleshoot them as your code </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">base evolves.</span></span></p>
			<p><span class="koboSpan" id="kobo.191.1">In the next section, let’s have a look at a real </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">Angular test.</span></span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.193.1">Breaking down a simple unit test</span></h2>
			<p><span class="koboSpan" id="kobo.194.1">When we first create an</span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.195.1"> Angular application, the CLI helps to generate a test file for your </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">AppComponent</span></strong><span class="koboSpan" id="kobo.197.1">. </span><span class="koboSpan" id="kobo.197.2">Let’s have a look at the sample </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">test file:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.199.1">
// app.component.spec.ts
describe('AppComponent', () =&gt; {
  // Arrange
  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      imports: [AppComponent]
    }).compileComponents()
  })
  it('should render title', () =&gt; {
    // Arrange
    const fixture = TestBed.createComponent(AppComponent)
    const compiled = fixture.nativeElement as HTMLElement
    // Act
    fixture.detectChanges()
    // Assert
    expect(compiled.querySelector('h1')?.textContent).toContain(
      'Welcome to chapter-13'
    )
  })
})</span></pre>			<p><span class="koboSpan" id="kobo.200.1">The provided code</span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.201.1"> snippet is an Angular test script for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">AppComponent</span></strong><span class="koboSpan" id="kobo.203.1"> component. </span><span class="koboSpan" id="kobo.203.2">Let’s break this code block down in the following list so we can understand </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">it more:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">describe('AppComponent', ()...</span></strong><span class="koboSpan" id="kobo.206.1">: This is a test suite that groups related tests. </span><span class="koboSpan" id="kobo.206.2">In this case, it groups tests </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">AppComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">beforeEach(async () =&gt; ...)</span></strong><span class="koboSpan" id="kobo.211.1">: This function is a setup function that runs before each individual test case. </span><span class="koboSpan" id="kobo.211.2">It is an asynchronous function that configures the testing module using </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">TestBed.configureTestingModule</span></strong><span class="koboSpan" id="kobo.213.1">, which is a key part of Angular’s testing infrastructure provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">TestBed</span></strong><span class="koboSpan" id="kobo.215.1"> utility. </span><span class="koboSpan" id="kobo.215.2">It allows you to configure the testing module by specifying the necessary dependencies, providers, and imports for the component undergoing testing. </span><span class="koboSpan" id="kobo.215.3">In this case, it imports </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">AppComponent</span></strong><span class="koboSpan" id="kobo.217.1">. </span><span class="koboSpan" id="kobo.217.2">This is also the Arrange step in the </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">AAA pattern.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">it('should render title'...</span></strong><span class="koboSpan" id="kobo.220.1">: This function is a test case that defines a specific behavior to be tested. </span><span class="koboSpan" id="kobo.220.2">In this case, the test case is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">should render title</span></strong><span class="koboSpan" id="kobo.222.1">. </span><span class="koboSpan" id="kobo.222.2">Let’s break this </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.223.1">function down based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">AAA pattern:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.225.1">Arrange</span></strong><span class="koboSpan" id="kobo.226.1">: We created an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">AppComponent</span></strong><span class="koboSpan" id="kobo.228.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">TestBed.createComponent</span></strong><span class="koboSpan" id="kobo.230.1">, and retrieved the compiled HTML element </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">fixture.nativeElement</span></strong></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.233.1">Act</span></strong><span class="koboSpan" id="kobo.234.1">: We triggered the ability to detect changes </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">fixture.detectChanges()</span></strong></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.237.1">Assert</span></strong><span class="koboSpan" id="kobo.238.1">: We verified that the text content of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">&lt;h1&gt;</span></strong><span class="koboSpan" id="kobo.240.1"> element contains the string </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">Welcome </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">to chapter-13</span></strong></span></li></ul></li>
			</ul>
			<p><span class="koboSpan" id="kobo.243.1">Overall, this </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.244.1">test verifies that </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">AppComponent</span></strong><span class="koboSpan" id="kobo.246.1"> correctly renders a title with the expected text content. </span><span class="koboSpan" id="kobo.246.2">It sets up the component, triggers change detection, and asserts the </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">expected outcome.</span></span></p>
			<p><span class="koboSpan" id="kobo.248.1">In short, by using basic testing techniques, we can set a solid foundation for ensuring the quality and reliability of our Angular applications. </span><span class="koboSpan" id="kobo.248.2">Now that we have a grasp of basic testing concepts, let’s dive into a specific use case: writing tests for PrimeNG components. </span><span class="koboSpan" id="kobo.248.3">We will also write our unit tests while utilizing Jest as our unit </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">testing framework.</span></span></p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.250.1">Writing test for PrimeNG components</span></h1>
			<p><span class="koboSpan" id="kobo.251.1">Testing PrimeNG components follows </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.252.1">the same principles as testing </span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.253.1">regular Angular components. </span><span class="koboSpan" id="kobo.253.2">This similarity arises from the fact that PrimeNG components are essentially Angular components under the hood. </span><span class="koboSpan" id="kobo.253.3">In the following sections, we will explore a few of these tests to gain insights and knowledge in </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">this area.</span></span></p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.255.1">How PrimeNG tests its components</span></h2>
			<p><span class="koboSpan" id="kobo.256.1">First, let’s have a look at how </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.257.1">PrimeNG tests its own components. </span><span class="koboSpan" id="kobo.257.2">Due to space limitations in this book, it is not possible to display the entire test file, as it is quite lengthy. </span><span class="koboSpan" id="kobo.257.3">However, we can focus on a specific section that illustrates how PrimeNG tests its components in its source code. </span><span class="koboSpan" id="kobo.257.4">Here is the example code of a PrimeNG </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">Button</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.259.1"> component:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
describe('Button', () =&gt; {
    let button: Button;
    let fixture: ComponentFixture&lt;Button&gt;;
    beforeEach(() =&gt; {
        TestBed.configureTestingModule({
            imports: [NoopAnimationsModule],
            declarations: [Button]
        });
        fixture = TestBed.createComponent(Button);
        button = fixture.componentInstance;
    });
    it('should disabled when disabled is true', () =&gt; {
        button.disabled = true;
        fixture.detectChanges();
        const buttonEl = fixture.debugElement.query(By.css('.p-button'));
        expect(buttonEl.nativeElement.disabled).toBeTruthy();
    });
    it('should display the label and have a text only class', () =&gt; {
        button.label = 'PrimeNG';
        fixture.detectChanges();
        const buttonEl = fixture.debugElement.query(By.css('.p-button'));
        expect(buttonEl.nativeElement.textContent).toContain('PrimeNG');
        expect(buttonEl.nativeElement.children.length).toEqual(1);
    });
    ...
</span><span class="koboSpan" id="kobo.260.2">})</span></pre>			<p><span class="koboSpan" id="kobo.261.1">Let’s break down the </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.262.1">code in the following list so we can understand its </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">different sections:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">beforeEach(...)</span></strong><span class="koboSpan" id="kobo.265.1">: This </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.266.1">function is used to set up the testing environment before each test case. </span><span class="koboSpan" id="kobo.266.2">In this case, it is used to configure the testing module by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">TestBed.configureTestingModule</span></strong><span class="koboSpan" id="kobo.268.1">. </span><span class="koboSpan" id="kobo.268.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">imports</span></strong><span class="koboSpan" id="kobo.270.1"> property specifies any required modules, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">declarations</span></strong><span class="koboSpan" id="kobo.272.1"> property specifies the component being tested. </span><span class="koboSpan" id="kobo.272.2">In this case, it imports </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">NoopAnimationsModule</span></strong><span class="koboSpan" id="kobo.274.1"> and adds </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Button</span></strong><span class="koboSpan" id="kobo.276.1"> to the </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">declarations array.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">should disabled when disabled is true</span></strong><span class="koboSpan" id="kobo.279.1">: This test case sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">disabled</span></strong><span class="koboSpan" id="kobo.281.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">Button</span></strong><span class="koboSpan" id="kobo.283.1"> component to </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">true</span></strong><span class="koboSpan" id="kobo.285.1">, triggers change detection using </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">fixture.detectChanges()</span></strong><span class="koboSpan" id="kobo.287.1">, and then queries the DOM for the button element using </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">fixture.debugElement.query</span></strong><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">It asserts that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">disabled</span></strong><span class="koboSpan" id="kobo.291.1"> property of the button element is </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">true</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.293.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">expect(...).toBeTruthy()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">should display the label and have a text only class</span></strong><span class="koboSpan" id="kobo.297.1">: This test case sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">label</span></strong><span class="koboSpan" id="kobo.299.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">Button</span></strong><span class="koboSpan" id="kobo.301.1"> component to </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">PrimeNG</span></strong><span class="koboSpan" id="kobo.303.1">, triggers change detection, and queries the DOM for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">button</span></strong><span class="koboSpan" id="kobo.305.1"> element. </span><span class="koboSpan" id="kobo.305.2">It asserts that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">button</span></strong><span class="koboSpan" id="kobo.307.1"> element’s text content contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">PrimeNG</span></strong><span class="koboSpan" id="kobo.309.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">expect(...).toContain(...)</span></strong><span class="koboSpan" id="kobo.311.1">, and it verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">button</span></strong><span class="koboSpan" id="kobo.313.1"> element has only one child element </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">expect(...).toEqual(1)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.317.1">The purpose of these tests is to verify the expected behavior of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">Button</span></strong><span class="koboSpan" id="kobo.319.1"> component. </span><span class="koboSpan" id="kobo.319.2">By changing its properties and triggering change detection, the tests ensure that the component renders correctly and behaves </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">as intended.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.321.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.322.1">In the PrimeNG source code (</span><a href="https://github.com/primefaces/primeng/tree/master/src/app/components"><span class="koboSpan" id="kobo.323.1">https://github.com/primefaces/primeng/tree/master/src/app/components</span></a><span class="koboSpan" id="kobo.324.1">), there are existing tests that you can study and use as references to enhance </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">your understanding.</span></span></p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.326.1">Creating and testing our own component</span></h2>
			<p><span class="koboSpan" id="kobo.327.1">Putting the previous </span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.328.1">examples and knowledge into practice, let’s create a</span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.329.1"> test for the following </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">card component:</span></span></p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<span class="koboSpan" id="kobo.331.1"><img src="image/B18805_13_02.jpg" alt="Figure 13.2 – Sample card component"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.332.1">Figure 13.2 – Sample card component</span></p>
			<p><span class="koboSpan" id="kobo.333.1">By examining the screenshot, you can observe the visual representation of the card component we created. </span><span class="koboSpan" id="kobo.333.2">To ensure the proper functioning of this component, it is essential to write tests that validate the correct rendering of its title, subtitle, and buttons. </span><span class="koboSpan" id="kobo.333.3">The following code block is an example of the </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">test code:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.335.1">
// sample-test.component.spec.ts
describe('SampleTestComponent', () =&gt; {
  let component: SampleTestComponent
  let fixture: ComponentFixture&lt;SampleTestComponent&gt;
  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      imports: [SampleTestComponent],
    }).compileComponents()
    fixture = TestBed.createComponent(SampleTestComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })
  it('should create', () =&gt; {
    expect(component).toBeTruthy()
  })
  it('should display the product title and subtitle', () =&gt; {
    fixture.detectChanges()
    const card = fixture.debugElement.query(By.css('p-card'))
    expect(card.nativeElement.textContent).toContain('Super Laptop PRO X')
    expect(card.nativeElement.textContent).toContain('Best for Nomads')
  })
  it('should have a footer', () =&gt; {
    fixture.detectChanges()
    const footerCard = fixture.debugElement.query(By.css('.p-card-footer'))
    const ctaButtons = fixture.debugElement.queryAll(By.css('.p-button'))
    expect(footerCard).toBeTruthy()
    expect(ctaButtons).toBeTruthy()
    expect(ctaButtons.length).toEqual(2)
  })
})</span></pre>			<p><span class="koboSpan" id="kobo.336.1">Let’s break down the code</span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.337.1"> in the following list so that we can understand its</span><a id="_idIndexMarker699"/> <span class="No-Break"><span class="koboSpan" id="kobo.338.1">different sections:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">should create</span></strong><span class="koboSpan" id="kobo.340.1">: The test case checks whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">component</span></strong><span class="koboSpan" id="kobo.342.1"> instance is </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">Truthy</span></strong><span class="koboSpan" id="kobo.344.1">, meaning that it has been </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">successfully created.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">should display the product title and subtitle</span></strong><span class="koboSpan" id="kobo.347.1">: This test case triggers change detection and then queries the DOM for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">p-card</span></strong><span class="koboSpan" id="kobo.349.1"> element using </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">fixture.debugElement.query</span></strong><span class="koboSpan" id="kobo.351.1">. </span><span class="koboSpan" id="kobo.351.2">It asserts that the content of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">p-card</span></strong><span class="koboSpan" id="kobo.353.1"> element contains the expected product </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">title</span></strong><span class="koboSpan" id="kobo.355.1"> value and </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">subtitle</span></strong><span class="koboSpan" id="kobo.357.1"> value </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">expect(...).toContain(...)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">should have a footer</span></strong><span class="koboSpan" id="kobo.362.1">: This test case triggers change detection, then queries the DOM for the footer element with the</span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">.p-card-footer</span></strong><span class="koboSpan" id="kobo.364.1"> class and all the buttons with the</span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">.p-button</span></strong><span class="koboSpan" id="kobo.366.1"> class. </span><span class="koboSpan" id="kobo.366.2">It asserts that both the footer element and the buttons are </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">Truthy</span></strong><span class="koboSpan" id="kobo.368.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">expect(...).toBeTruthy()</span></strong><span class="koboSpan" id="kobo.370.1">, and it also verifies that there are two buttons present by checking the length of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">ctaButtons</span></strong><span class="koboSpan" id="kobo.372.1"> array </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">expect(...).toEqual(2)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.376.1">After running the test, you can see that it </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">passes successfully:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.378.1">
PASS   chapter-13  apps/chapter-13/src/app/pages/sample-test/sample-test.component.spec.ts
SampleTestComponent
   should create (95 ms)
   should display the product title and subtitle (23 ms)
   should have a footer (17 ms)
Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        6.411 s</span></pre>			<p><span class="koboSpan" id="kobo.379.1">In conclusion, writing </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.380.1">tests for PrimeNG components equips you </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.381.1">with the ability to ensure the functionality and reliability of these components within your Angular applications. </span><span class="koboSpan" id="kobo.381.2">Now that we have explored the process of writing tests for PrimeNG components, let’s further enhance our testing practices by utilizing helpful tips and tricks to improve the effectiveness and efficiency of </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">our tests.</span></span></p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.383.1">Utilizing testing tips and tricks</span></h1>
			<p><span class="koboSpan" id="kobo.384.1">Even though </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.385.1">testing enables us to ensure the correctness and stability of our code, writing effective tests can sometimes be challenging. </span><span class="koboSpan" id="kobo.385.2">In this section, we will explore various tips and tricks that can help you improve your testing practices, using the following editable table as </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">an example:</span></span></p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<span class="koboSpan" id="kobo.387.1"><img src="image/B18805_13_03.jpg" alt="Figure 13.3 – Sample editable table"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.388.1">Figure 13.3 – Sample editable table</span></p>
			<p><span class="koboSpan" id="kobo.389.1">The table </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.390.1">presents a list of products that are editable and removable. </span><span class="koboSpan" id="kobo.390.2">Upon clicking the delete icon, a confirmation dialog appears to verify the </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">deletion action.</span></span></p>
			<p><span class="koboSpan" id="kobo.392.1">So, let’s now look at some </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">testing tips.</span></span></p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.394.1">Isolate unit tests</span></h2>
			<p><span class="koboSpan" id="kobo.395.1">When writing </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.396.1">unit tests, it’s crucial to isolate the component or service undergoing testing from its dependencies. </span><span class="koboSpan" id="kobo.396.2">Angular’s </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">TestBed</span></strong><span class="koboSpan" id="kobo.398.1"> provides</span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.399.1"> a powerful </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.400.1">toolset for creating and configuring testing modules. </span><span class="koboSpan" id="kobo.400.2">By leveraging TestBed, we can mock dependencies and provide fake implementations, enabling us to focus solely on the unit we want </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">to test.</span></span></p>
			<p><span class="koboSpan" id="kobo.402.1">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">following example:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.404.1">
// tips.component.spec.ts
const productsStub = [
  ...
</span><span class="koboSpan" id="kobo.404.2">]
describe('TipsComponent', () =&gt; {
  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      imports: [TipsComponent],
      providers: [
        ...
</span><span class="koboSpan" id="kobo.404.3">        {
          provide: ShopService,
          useValue: {
</span><strong class="bold"><span class="koboSpan" id="kobo.405.1">            getProducts: jest.fn().mockReturnValue(productsStub),</span></strong><span class="koboSpan" id="kobo.406.1">
          },
        },
      ],
    }).compileComponents()
  })
  ..
</span><span class="koboSpan" id="kobo.406.2">})</span></pre>			<p><span class="koboSpan" id="kobo.407.1">In this example, we</span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.408.1"> use </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">TestBed.configureTestingModule</span></strong><span class="koboSpan" id="kobo.410.1"> to set up the testing module. </span><span class="koboSpan" id="kobo.410.2">By specifying </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">imports</span></strong><span class="koboSpan" id="kobo.412.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">providers</span></strong><span class="koboSpan" id="kobo.414.1">, we can mock dependencies and ensure they are correctly injected into the component</span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.415.1"> or service being tested. </span><span class="koboSpan" id="kobo.415.2">In this case, instead of calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">getProducts()</span></strong><span class="koboSpan" id="kobo.417.1"> function from </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">ShopService</span></strong><span class="koboSpan" id="kobo.419.1">, we replace the result with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">productsStub</span></strong><span class="koboSpan" id="kobo.421.1"> value, which makes it isolated and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">to test.</span></span></p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.423.1">Utilize NO_ERRORS_SCHEMA</span></h2>
			<p><span class="koboSpan" id="kobo.424.1">When testing Angular</span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.425.1"> components, we often encounter</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.426.1"> situations where we don’t need to assert the behavior or rendering of child components such as Angular Material components. </span><span class="koboSpan" id="kobo.426.2">In such cases, </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">NO_ERRORS_SCHEMA</span></strong><span class="koboSpan" id="kobo.428.1"> can be a handy tool to simplify our </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">test setup.</span></span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">NO_ERRORS_SCHEMA</span></strong><span class="koboSpan" id="kobo.431.1"> tells Angular’s compiler to ignore unrecognized elements and attributes within the component template. </span><span class="koboSpan" id="kobo.431.2">This allows us to focus on testing the component’s logic without the need to provide detailed mock implementations of </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">child components.</span></span></p>
			<p><span class="koboSpan" id="kobo.433.1">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">an example:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.435.1">
import { NO_ERRORS_SCHEMA } from '@angular/core';
describe('AppComponent', () =&gt; {
  let component: AppComponent;
  let fixture: ComponentFixture&lt;AppComponent&gt;;
  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      declarations: [AppComponent],
</span><strong class="bold"><span class="koboSpan" id="kobo.436.1">      schemas: [NO_ERRORS_SCHEMA]</span></strong><span class="koboSpan" id="kobo.437.1">
    }).compileComponents();
  });
  // Additional tests go here
});</span></pre>			<p><span class="koboSpan" id="kobo.438.1">In this example, we specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">schemas: [NO_ERRORS_SCHEMA]</span></strong><span class="koboSpan" id="kobo.440.1"> in the testing module configuration. </span><span class="koboSpan" id="kobo.440.2">This allows us to test </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">AppComponent</span></strong><span class="koboSpan" id="kobo.442.1"> without worrying about the presence or </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.443.1">behavior of any </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">child</span></span><span class="No-Break"><a id="_idIndexMarker712"/></span><span class="No-Break"><span class="koboSpan" id="kobo.445.1"> components.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.446.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.447.1">Avoid using </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">NO_ERRORS_SCHEMA</span></strong><span class="koboSpan" id="kobo.449.1"> if you are writing integration tests. </span><span class="koboSpan" id="kobo.449.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">NO_ERRORS_SCHEMA</span></strong><span class="koboSpan" id="kobo.451.1"> option will ignore template errors for unknown elements and attributes. </span><span class="koboSpan" id="kobo.451.2">It allows Angular to run tests even if there are issues with child components’ templates. </span><span class="koboSpan" id="kobo.451.3">You can </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.452.1">read more </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">at </span></span><a href="https://angular.io/guide/testing-components-scenarios#no_errors_schema"><span class="No-Break"><span class="koboSpan" id="kobo.454.1">https://angular.io/guide/testing-components-scenarios#no_errors_schema</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.455.1">.</span></span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.456.1">Utilize the spyOn method</span></h2>
			<p><strong class="bold"><span class="koboSpan" id="kobo.457.1">Method spying</span></strong><span class="koboSpan" id="kobo.458.1"> is a</span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.459.1"> powerful technique that allows us to observe and control the behavior of methods during testing. </span><span class="koboSpan" id="kobo.459.2">Jest/Jasmine provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">spyOn</span></strong><span class="koboSpan" id="kobo.461.1"> function, along </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.462.1">with the spy object, to facilitate </span><a id="_idIndexMarker716"/><span class="No-Break"><span class="koboSpan" id="kobo.463.1">method spying.</span></span></p>
			<p><span class="koboSpan" id="kobo.464.1">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">spyOn</span></strong><span class="koboSpan" id="kobo.466.1">, we can replace a method with a spy function that records all invocations and provides additional capabilities, such as returning specific values or throwing exceptions. </span><span class="koboSpan" id="kobo.466.2">This enables us to verify whether a method was called, how many times it was called, and with </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">which arguments.</span></span></p>
			<p><span class="koboSpan" id="kobo.468.1">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">following example:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
// tips.component.spec.ts
beforeEach(async () =&gt; {
  await TestBed.configureTestingModule({
    imports: [TipsComponent],
    ...
</span><span class="koboSpan" id="kobo.470.2">  }).compileComponents()
  fixture = TestBed.createComponent(TipsComponent)
  confirmDialog = fixture.debugElement.query(
    By.css('p-confirmdialog')
  ).componentInstance
})
it('should show accept message on delete', () =&gt; {
  const messageSpy = jest.spyOn(messageService, 'add')
  component.onRowDelete(1)
  fixture.detectChanges()
  confirmDialog.accept()
  expect(messageSpy).toHaveBeenCalledWith({
    severity: 'info',
    summary: 'Confirmed',
    detail: 'Your product is deleted',
  })
})</span></pre>			<p><span class="koboSpan" id="kobo.471.1">Let’s break down the</span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.472.1"> code in the following list and learn </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.473.1">what </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">it does:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">('should show accept message on delete', () =&gt; { ... </span><span class="koboSpan" id="kobo.475.2">})</span></strong><span class="koboSpan" id="kobo.476.1">: This is a test case description. </span><span class="koboSpan" id="kobo.476.2">In this case, it is checking whether a specific message is shown after deleting </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">a row.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">const messageSpy = jest.spyOn(messageService, 'add')</span></strong><span class="koboSpan" id="kobo.479.1">: This line creates a spy using Jest’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">spyOn</span></strong><span class="koboSpan" id="kobo.481.1"> function. </span><span class="koboSpan" id="kobo.481.2">It spies on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">add</span></strong><span class="koboSpan" id="kobo.483.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">messageService</span></strong><span class="koboSpan" id="kobo.485.1"> object. </span><span class="koboSpan" id="kobo.485.2">This allows us to track whether and how this method is called during </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">the test.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">component.onRowDelete(1)</span></strong><span class="koboSpan" id="kobo.488.1">: This line calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">onRowDelete</span></strong><span class="koboSpan" id="kobo.490.1"> method of the component under test and passes </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">1</span></strong><span class="koboSpan" id="kobo.492.1"> as an argument. </span><span class="koboSpan" id="kobo.492.2">This simulates the deletion of a row with an index </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">fixture.detectChanges()</span></strong><span class="koboSpan" id="kobo.497.1">: This line triggers change detection in the test fixture. </span><span class="koboSpan" id="kobo.497.2">It ensures that any changes in the component’s template are applied and updates are reflected in the </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">test environment.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">confirmDialog.accept()</span></strong><span class="koboSpan" id="kobo.500.1">: This line simulates the user accepting a confirmation dialog. </span><span class="koboSpan" id="kobo.500.2">It assumes that the component has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">confirmDialog</span></strong><span class="koboSpan" id="kobo.502.1"> object with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">accept</span></strong><span class="koboSpan" id="kobo.504.1"> method, which is called to confirm </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">the deletion.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">expect(messageSpy).toHaveBeenCalledWith({ ... </span><span class="koboSpan" id="kobo.506.2">})</span></strong><span class="koboSpan" id="kobo.507.1">: This line uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">expect</span></strong><span class="koboSpan" id="kobo.509.1"> function to make an assertion. </span><span class="koboSpan" id="kobo.509.2">It checks whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">add</span></strong><span class="koboSpan" id="kobo.511.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">messageService</span></strong><span class="koboSpan" id="kobo.513.1"> object was called with the expected argument. </span><span class="koboSpan" id="kobo.513.2">In this case, it expects that the method was called with an object containing </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.514.1">specific properties such </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.515.1">as </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">severity</span></strong><span class="koboSpan" id="kobo.517.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">summary</span></strong><span class="koboSpan" id="kobo.519.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">detail</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.523.1">In conclusion, the spying method is a powerful tool for tracking and controlling function calls during testing, providing insights into the behavior of your application. </span><span class="koboSpan" id="kobo.523.2">As we transition to the next section, let’s explore how to handle asynchronous code and manage time-related operations in </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">Angular testing.</span></span></p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.525.1">Working with fakeAsync</span></h2>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">fakeAsync</span></strong><span class="koboSpan" id="kobo.527.1"> is a </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.528.1">utility in Angular</span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.529.1"> testing that enables synchronous testing of asynchronous code. </span><span class="koboSpan" id="kobo.529.2">It runs the test in a special “fake” zone where asynchronous operations can be controlled using </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">tick()</span></strong><span class="koboSpan" id="kobo.531.1">. </span><span class="koboSpan" id="kobo.531.2">Here is a simple demonstration of </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">fakeAsync</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.533.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">tick</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.536.1">
import { fakeAsync, flush, tick } from '@angular/core/testing'
describe('FakeAsync Example', () =&gt; {
  it('should test asynchronous code using fakeAsync', fakeAsync(() =&gt; {
    let value: string | undefined
    // Simulate an asynchronous operation
    setTimeout(() =&gt; {
      value = 'completed'
    }, 1000)
    // Use tick to simulate the passage of time
    tick(500) // Simulate 500 milliseconds passed
    expect(value).toBeUndefined() // Value should still be undefined
    tick(500) // Simulate another 500 milliseconds passed
    expect(value).toBe('completed')
    flush()
  }))
})</span></pre>			<p><span class="koboSpan" id="kobo.537.1">In this</span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.538.1"> example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">fakeAsync</span></strong><span class="koboSpan" id="kobo.540.1"> is used to wrap the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">test</span></strong><span class="koboSpan" id="kobo.542.1"> function. </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">setTimeout</span></strong><span class="koboSpan" id="kobo.544.1"> is used to simulate an asynchronous operation, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">tick</span></strong><span class="koboSpan" id="kobo.546.1"> is used to simulate the passage of time. </span><span class="koboSpan" id="kobo.546.2">By calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">tick(500)</span></strong><span class="koboSpan" id="kobo.548.1">, you simulate the passing of 500</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.549.1"> milliseconds, and then you can make assertions about the state of your application. </span><span class="koboSpan" id="kobo.549.2">This is useful for testing asynchronous behavior in a </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">synchronous manner.</span></span></p>
			<p><span class="koboSpan" id="kobo.551.1">Now let’s have a look at some more example code that tests the behavior of PrimeNG </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">MessageService</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.553.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">TipsComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.556.1">
// tips.component.spec.ts
import {
  fakeAsync, flush, tick
} from '@angular/core/testing'
it('should show close message on delete', fakeAsync(() =&gt; {
  const messageSpy = jest.spyOn(messageService, 'add')
  component.onRowDelete(1)
  fixture.detectChanges()
  tick(300)
  // Send Escape event
  const escapeEvent: any = document.createEvent('CustomEvent')
  escapeEvent.which = 27
  escapeEvent.initEvent('keydown', true, true)
  document.dispatchEvent(escapeEvent as KeyboardEvent)
  expect(messageSpy).toHaveBeenCalledWith({
    severity: 'warn',
    summary: 'Cancelled',
    detail: 'You have cancelled',
  })
  flush()
}))</span></pre>			<p><span class="koboSpan" id="kobo.557.1">This test </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.558.1">verifies whether the message displays the correct value </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.559.1">upon pressing the </span><em class="italic"><span class="koboSpan" id="kobo.560.1">Esc</span></em><span class="koboSpan" id="kobo.561.1"> button. </span><span class="koboSpan" id="kobo.561.2">The following bullet points outline the flow of </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">the test:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.563.1">First, we trigger the delete action through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">component.onRowDelete(1)</span></strong><span class="koboSpan" id="kobo.565.1"> function, so the confirmation dialog </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">shows up.</span></span></li>
				<li><span class="koboSpan" id="kobo.567.1">After that, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">tick</span></strong><span class="koboSpan" id="kobo.569.1"> to advance the virtual clock by a specified amount of time. </span><span class="koboSpan" id="kobo.569.2">In this case, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">tick(300)</span></strong><span class="koboSpan" id="kobo.571.1"> to simulate a </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">300-millisecond delay.</span></span></li>
				<li><span class="koboSpan" id="kobo.573.1">After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">tick</span></strong><span class="koboSpan" id="kobo.575.1"> function is used, we simulate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">Escape</span></strong><span class="koboSpan" id="kobo.577.1"> keydown event by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">KeyboardEvent</span></strong><span class="koboSpan" id="kobo.579.1"> object and dispatching it on </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">the document.</span></span></li>
				<li><span class="koboSpan" id="kobo.581.1"> After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">Escape</span></strong><span class="koboSpan" id="kobo.583.1"> event is dispatched, we can assert on the message service </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">via </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">expect(messageSpy).toHaveBeenCalledWith({...})</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">.</span></span></li>
				<li><span class="koboSpan" id="kobo.587.1">Finally, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">flush</span></strong><span class="koboSpan" id="kobo.589.1"> to flush any pending asynchronous tasks, ensuring that all asynchronous operations have been completed before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">test</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.591.1">function exits.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.592.1">In this section, we’ve gained insights into managing asynchronous operations in Angular testing. </span><span class="koboSpan" id="kobo.592.2">In the next section, we will delve into a powerful testing utility that simplifies and enhances our testing </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">capabilities: Spectator.</span></span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.594.1">Utilizing third-party libraries – Spectator</span></h2>
			<p><strong class="bold"><span class="koboSpan" id="kobo.595.1">Spectator</span></strong><span class="koboSpan" id="kobo.596.1"> (</span><a href="https://ngneat.github.io/spectator"><span class="koboSpan" id="kobo.597.1">https://ngneat.github.io/spectator</span></a><span class="koboSpan" id="kobo.598.1">) provides</span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.599.1"> a set of utilities and</span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.600.1"> techniques that facilitate writing concise and expressive tests </span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.601.1">for Angular components. </span><span class="koboSpan" id="kobo.601.2">It allows you to create component instances, mock dependencies, access the component’s DOM, and assert the component’s behavior with minimal boilerplate code. </span><span class="koboSpan" id="kobo.601.3">It also provides a clean and intuitive syntax that makes test cases more readable </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">and maintainable.</span></span></p>
			<p><span class="koboSpan" id="kobo.603.1">To use it, first, we need to</span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.604.1"> install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">spectator</span></strong><span class="koboSpan" id="kobo.606.1"> package by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">following command:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.608.1">
npm install @ngneat/spectator --save-dev</span></pre>			<p><span class="koboSpan" id="kobo.609.1">After that, let’s create an example test in which we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">Spectator</span></strong><span class="koboSpan" id="kobo.611.1"> for testing an </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">Angular component:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.613.1">
// spectator.component.spec.ts
import {
  Spectator,
  createComponentFactory,
  mockProvider,
} from '@ngneat/spectator/jest'
describe('TipsComponent', () =&gt; {
  let spectator: Spectator&lt;TipsComponent&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.614.1">  const createComponent = createComponentFactory({</span></strong><span class="koboSpan" id="kobo.615.1">
    component: TipsComponent,
    providers: [
      mockProvider(ShopService, {
        getProducts: () =&gt; productsStub,
      }),
    ],
  })
  beforeEach(() =&gt; (spectator = createComponent()))
  it('should show table content', () =&gt; {
</span><strong class="bold"><span class="koboSpan" id="kobo.616.1">    const table = spectator.query('p-table')</span></strong><span class="koboSpan" id="kobo.617.1">
    expect(table?.textContent).toContain('Product 1')
    expect(table?.textContent).toContain('Product 2')
  })
})</span></pre>			<p><span class="koboSpan" id="kobo.618.1">The given code utilizes </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.619.1">Spectator to test the behavior of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">TipsComponent</span></strong><span class="koboSpan" id="kobo.621.1"> instance. </span><span class="koboSpan" id="kobo.621.2">Let’s break down the code block in the following list so we can understand</span><a id="_idIndexMarker732"/> <span class="No-Break"><span class="koboSpan" id="kobo.622.1">each part:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">const createComponent = createComponentFactory({ ... </span><span class="koboSpan" id="kobo.623.2">})</span></strong><span class="koboSpan" id="kobo.624.1">: This defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">createComponent</span></strong><span class="koboSpan" id="kobo.626.1"> function using </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">createComponentFactory</span></strong><span class="koboSpan" id="kobo.628.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">Spectator</span></strong><span class="koboSpan" id="kobo.630.1">. </span><span class="koboSpan" id="kobo.630.2">This function is used to create an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">TipsComponent</span></strong><span class="koboSpan" id="kobo.632.1"> for testing. </span><span class="koboSpan" id="kobo.632.2">It also provides a mock instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">ShopService</span></strong><span class="koboSpan" id="kobo.634.1"> through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">providers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.636.1"> array.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">beforeEach(() =&gt; (spectator = createComponent()))</span></strong><span class="koboSpan" id="kobo.638.1">: This is a setup step that runs before each test case. </span><span class="koboSpan" id="kobo.638.2">It creates a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">TipsComponent</span></strong><span class="koboSpan" id="kobo.640.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">createComponent</span></strong><span class="koboSpan" id="kobo.642.1"> function and assigns it to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">spectator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.644.1"> variable.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">it('should show table content', () =&gt; { ... </span><span class="koboSpan" id="kobo.645.2">})</span></strong><span class="koboSpan" id="kobo.646.1">: This line defines a test case with the description </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">should show table content</span></strong><span class="koboSpan" id="kobo.648.1">. </span><span class="koboSpan" id="kobo.648.2">This test case verifies that the table in </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">TipsComponent</span></strong><span class="koboSpan" id="kobo.650.1"> contains the expected content. </span><span class="koboSpan" id="kobo.650.2">This is broken down in more detail </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">as follows:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">const table = spectator.query('p-table')</span></strong><span class="koboSpan" id="kobo.653.1">: This uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">query</span></strong><span class="koboSpan" id="kobo.655.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">spectator</span></strong><span class="koboSpan" id="kobo.657.1"> object to find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">&lt;p-table&gt;</span></strong><span class="koboSpan" id="kobo.659.1"> element in the </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">component’s template.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">expect(table?.textContent).toContain(...)</span></strong><span class="koboSpan" id="kobo.662.1">: This asserts that </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">textContent</span></strong><span class="koboSpan" id="kobo.664.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">table</span></strong><span class="koboSpan" id="kobo.666.1"> element (if it exists) contains the string </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">Product 1</span></strong><span class="koboSpan" id="kobo.668.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">Product 2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">.</span></span></li></ul></li>
			</ul>
			<p><span class="koboSpan" id="kobo.671.1">As we conclude </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.672.1">our exploration of </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">Spectator</span></strong><span class="koboSpan" id="kobo.674.1">, we’ve </span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.675.1">discovered its efficacy in simplifying and improving our testing workflow for Angular components. </span><span class="koboSpan" id="kobo.675.2">Now, let’s have a look at another helpful library to enhance our testing </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">practices: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">ng-mocks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">.</span></span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.679.1">Utilizing third-party libraries – ng-mocks</span></h2>
			<p><span class="koboSpan" id="kobo.680.1">Another powerful</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.681.1"> third-party library for testing Angular </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.682.1">applications is </span><strong class="bold"><span class="koboSpan" id="kobo.683.1">ng-mocks</span></strong><span class="koboSpan" id="kobo.684.1"> (</span><a href="https://ng-mocks.sudo.eu"><span class="koboSpan" id="kobo.685.1">https://ng-mocks.sudo.eu</span></a><span class="koboSpan" id="kobo.686.1">). </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">ng-mocks</span></strong><span class="koboSpan" id="kobo.688.1"> simplifies</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.689.1"> the testing </span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.690.1">process by providing flexible mocking and stubbing capabilities, making it easier to isolate components and services </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">during testing.</span></span></p>
			<p><span class="koboSpan" id="kobo.692.1">With ng-mocks, we can create mock implementations of Angular components and services, define custom behavior for methods, and verify interactions. </span><span class="koboSpan" id="kobo.692.2">This allows us to focus on testing specific units without worrying about the complexities of </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">real implementations.</span></span></p>
			<p><span class="koboSpan" id="kobo.694.1">To use it, first, we need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">ng-mocks</span></strong><span class="koboSpan" id="kobo.696.1"> package by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">following command:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.698.1">
npm install ng-mocks --save-dev</span></pre>			<p><span class="koboSpan" id="kobo.699.1">Now let’s</span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.700.1"> have a look at how to use ng-mocks in </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">Angular</span></span><span class="No-Break"><a id="_idIndexMarker740"/></span><span class="No-Break"><span class="koboSpan" id="kobo.702.1"> testing:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.703.1">
// ng-mocks.component.spec.ts
import { MockInstance, MockProvider } from 'ng-mocks'
describe('TipsComponent', () =&gt; {
  beforeAll(() =&gt;
    </span><strong class="bold"><span class="koboSpan" id="kobo.704.1">MockInstance</span></strong><span class="koboSpan" id="kobo.705.1">(ShopService, () =&gt; ({
      getProducts: () =&gt; productsStub,
    }))
  )
  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      imports: [TipsComponent],
      providers: [
provideNoopAnimations(),
</span><strong class="bold"><span class="koboSpan" id="kobo.706.1">MockProvider(ShopService)</span></strong><span class="koboSpan" id="kobo.707.1">
],
    }).compileComponents()
    fixture = TestBed.createComponent(TipsComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })
})</span></pre>			<p><span class="koboSpan" id="kobo.708.1">Let’s break </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.709.1">down the code block in the following list so that </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.710.1">we can understand what </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">it does:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">providers: [MockProvider(ShopService)]</span></strong><span class="koboSpan" id="kobo.713.1">: This is used to create a mock version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">ShopService</span></strong><span class="koboSpan" id="kobo.715.1"> and configure it as a provider in the test environment. </span><span class="koboSpan" id="kobo.715.2">This ensures that the test uses the mock version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">ShopService</span></strong><span class="koboSpan" id="kobo.717.1"> instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">actual implementation.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">beforeAll(() =&gt; MockInstance(ShopService, () =&gt; ({ ... </span><span class="koboSpan" id="kobo.719.2">})))</span></strong><span class="koboSpan" id="kobo.720.1">: This </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">beforeAll</span></strong><span class="koboSpan" id="kobo.722.1"> hook is executed once before all the test cases in the suite. </span><span class="koboSpan" id="kobo.722.2">It mocks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">ShopService</span></strong><span class="koboSpan" id="kobo.724.1"> dependency by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">MockInstance</span></strong><span class="koboSpan" id="kobo.726.1"> function from </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">ng-mocks</span></strong><span class="koboSpan" id="kobo.728.1">. </span><span class="koboSpan" id="kobo.728.2">It replaces the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">getProducts</span></strong><span class="koboSpan" id="kobo.730.1"> method with a mocked implementation that </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">productsStub</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">.</span></span></li>
			</ul>
			<p class="callout-heading"><span class="koboSpan" id="kobo.734.1">Note</span></p>
			<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">ng-mocks</span></strong><span class="koboSpan" id="kobo.736.1"> also works fine with </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">spectator</span></strong><span class="koboSpan" id="kobo.738.1">. </span><span class="koboSpan" id="kobo.738.2">You can read more </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">at </span></span><a href="https://ng-mocks.sudo.eu/extra/with-3rd-party"><span class="No-Break"><span class="koboSpan" id="kobo.740.1">https://ng-mocks.sudo.eu/extra/with-3rd-party</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.741.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.742.1">And with that, we’ve delved into the intricacies of Angular testing, uncovering practical tips and tricks that empower you to enhance the efficiency and resilience of your </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">test suites.</span></span></p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.744.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.745.1">In this chapter, you learned how to effectively test PrimeNG components in your Angular applications. </span><span class="koboSpan" id="kobo.745.2">By leveraging Jest, a powerful testing framework, you gained the ability to ensure the functionality and reliability of </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">these components.</span></span></p>
			<p><span class="koboSpan" id="kobo.747.1">Throughout this chapter, you explored various concepts and techniques related to testing PrimeNG components. </span><span class="koboSpan" id="kobo.747.2">You started by understanding the importance of testing and the benefits it brings to your development workflow. </span><span class="koboSpan" id="kobo.747.3">Then, you delved into the specific steps involved in writing unit tests for PrimeNG components, including component setup, testing component behavior, and validating component appearance </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">and interactions.</span></span></p>
			<p><span class="koboSpan" id="kobo.749.1">In addition, you also encountered practical examples, code snippets, and best practices that demonstrated how to effectively test PrimeNG components. </span><span class="koboSpan" id="kobo.749.2">By following along and implementing these testing strategies, you gained hands-on experience in verifying the correctness, reliability, and performance of your </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">PrimeNG components.</span></span></p>
			<p><span class="koboSpan" id="kobo.751.1">As we transition to the next chapter, we will shift our focus to the world of building a responsive web application utilizing </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">PrimeNG components.</span></span></p>
		</div>
	

		<div id="_idContainer139" class="Content">
			<h1 id="_idParaDest-268" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.1.1">Part 4: Real-World Application</span></h1>
			<p><span class="koboSpan" id="kobo.2.1">In this final part, you will apply all the knowledge and skills you have acquired throughout the previous chapters to build a real-world responsive web application. </span><span class="koboSpan" id="kobo.2.2">This part will provide you with hands-on experience, allowing you to put your PrimeNG and Angular expertise to </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">practical use.</span></span></p>
			<p><span class="koboSpan" id="kobo.4.1">By the end of this part, you will have completed a fully functional responsive web application using PrimeNG </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">and Angular.</span></span></p>
			<p><span class="koboSpan" id="kobo.6.1">This part includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">following chapter:</span></span></p>
			<ul>
				<li><a href="B18805_14.xhtml#_idTextAnchor288"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 14</span></em></a><span class="koboSpan" id="kobo.9.1">, </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Building a Responsive Web Application</span></em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer140">
			</div>
		</div>
		<div>
			<div id="_idContainer141" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>