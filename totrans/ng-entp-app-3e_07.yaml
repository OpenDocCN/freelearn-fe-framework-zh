- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Working with REST and GraphQL APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与REST和GraphQL API一起工作
- en: In *Chapter 1*, *Angular’s Architecture and Concepts*, I introduced you to the
    wider architecture in which web applications exist, and in *Chapter 3*, *Architecting
    an Enterprise App*, we discussed various performance bottlenecks that can impact
    the success of your app. However, your web app can only perform as well as your
    full-stack architecture performs. If you’re working with an inadequate API design
    or a slow database, you will spend your time implementing band-aid solutions instead
    of addressing the root cause of the issues. The moment we move away from the minimalist
    mindset and start patching holes, we are on our way to constructing a fragile
    tower that is at risk of collapsing or very expensive to maintain. In short, the
    choices made in full-stack architecture can profoundly impact the success of your
    web application. You and your team simply cannot afford to be ignorant of how
    APIs are designed. Often, the correct way to implement a new feature or fix a
    performance issue is by redesigning an API endpoint. The **MEAN** stack, using
    **MongoDB**, **Express**, **Angular**, and **Node.js**, is a popular set of technologies
    aligned around similar technologies that should ease adoption by web developers.
    My take on the MEAN stack is minimal MEAN, which prioritizes ease of use, well-being,
    and effectiveness, the main ingredients for a great **DevEx**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一章*，*Angular的架构和概念*中，我向您介绍了网络应用存在的更广泛的架构，而在*第三章*，*构建企业应用*中，我们讨论了可能影响您应用成功的一系列性能瓶颈。然而，您的网络应用的表现只能与您的全栈架构的表现相匹配。如果您正在使用不充分的API设计或缓慢的数据库，您将花费时间实施临时解决方案，而不是解决问题的根本原因。当我们摆脱最小化思维并开始修补漏洞时，我们就在构建一个可能崩溃或维护成本极高的脆弱塔楼的道路上。简而言之，全栈架构中做出的选择可以深刻影响网络应用的成功。您和您的团队根本无法忽视API的设计方式。通常，实现新功能或修复性能问题的正确方法是通过重新设计API端点。使用**MongoDB**、**Express**、**Angular**和**Node.js**的**MEAN**栈是一套围绕类似技术构建的流行技术集合，这些技术应该有助于网络开发者的采用。我对MEAN栈的看法是“最小化MEAN”，它优先考虑易用性、健康和有效性，这些都是构建出色的**DevEx**的主要成分。
- en: In the past two chapters, we designed and implemented a **Role-Based Access
    Control** (**RBAC**) mechanism for our app. In *Chapter 5*, *Designing Authentication
    and Authorization*, we dove into security considerations, covered how JWT authentication
    works, learned how to safely handle data with TypeScript, and tapped into **Object
    Oriented Programming** (**OOP**) design with inheritance and abstraction to build
    an extendable auth service. In *Chapter 6*, *Implementing Role-Based Navigation*,
    we designed a conditional navigation experience using our auth service and implemented
    auth providers for custom APIs and Google Firebase.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去两章中，我们为我们的应用设计并实现了一个**基于角色的访问控制**（**RBAC**）机制。在*第五章*，*设计身份验证和授权*中，我们深入探讨了安全考虑因素，介绍了JWT身份验证的工作原理，学习了如何使用TypeScript安全地处理数据，并利用面向对象编程（**OOP**）的设计，通过继承和抽象来构建一个可扩展的认证服务。在*第六章*，*实现基于角色的导航*中，我们使用我们的认证服务设计了一个条件导航体验，并实现了针对自定义API和Google
    Firebase的认证提供者。
- en: In this chapter, I’ll introduce you to the LemonMart server, which implements
    JWT auth, REST, and GraphQL APIs. We will use these APIs to implement two custom
    auth providers in Angular. This will allow you to make authenticated calls to
    support recipes I will cover in *Chapter 8*, *Recipes – Reusability, Forms, and
    Caching, and Caching*, and *Chapter 9*, *Recipes – Master/Detail, Data Tables,
    and NgRx*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您介绍LemonMart服务器，该服务器实现了JWT身份验证、REST和GraphQL API。我们将使用这些API在Angular中实现两个自定义认证提供者。这将允许您对*第八章*，*食谱
    – 可重用性、表单和缓存*和*第九章*，*食谱 – 主/详细、数据表和NgRx*中将要介绍的食谱进行身份验证调用。
- en: This chapter covers a lot of ground. It is designed to serve as a roadmap to
    the GitHub repository ([https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)).
    I cover the architecture, design, and major components of the implementation.
    I highlight important pieces of code to explain how the solution comes together
    but avoid going into implementation details. It is more important that you understand
    why we are implementing various components rather than having a strong grasp of
    the implementation details. For this chapter, I recommend that you read and understand
    the server code versus trying to recreate it on your own.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。它旨在作为GitHub仓库的路线图。[GitHub仓库](https://github.com/duluca/lemon-mart-server)。我涵盖了架构、设计和实现的主要组件。我强调了一些重要的代码片段来解释解决方案是如何组合在一起的，但避免深入到实现细节。更重要的是，你需要理解我们为什么要实现各种组件，而不是对实现细节有深刻的掌握。对于本章，我建议你阅读并理解服务器代码，而不是试图自己重新创建它。
- en: We begin by covering full-stack architecture, the LemonMart server’s monorepo
    design, and how to use Docker Compose to run a three-tier application with a web
    app, server, and database. Then, we will review REST and GraphQL API design, implementation,
    and documentation. For REST, we will leverage the **OpenAPI** specification with
    **SwaggerUI**. For GraphQL, we will leverage **GraphQL schemas** with **Apollo
    Studio**. Both APIs will be implemented using Express.js and TypeScript. Then,
    we will cover the implementation of a MongoDB **Object Document Mapper** (**ODM**)
    using the DocumentTS library to store users with login credentials. Finally, we
    will implement a token-based auth function to secure our APIs and the corresponding
    auth providers in Angular.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍全栈架构、LemonMart服务器的monorepo设计以及如何使用Docker Compose运行具有Web应用、服务器和数据库的三层应用程序。然后，我们将回顾REST和GraphQL
    API的设计、实现和文档。对于REST，我们将利用**OpenAPI**规范和**SwaggerUI**。对于GraphQL，我们将利用**GraphQL
    schemas**和**Apollo Studio**。这两个API都将使用Express.js和TypeScript实现。然后，我们将介绍使用DocumentTS库实现MongoDB的**对象文档映射器（ODM**）以存储具有登录凭证的用户。最后，我们将实现基于令牌的身份验证功能来保护我们的API和Angular中的相应身份验证提供者。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Full-stack architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全栈架构
- en: Working with monorepos
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与monorepos一起工作
- en: Designing APIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计API
- en: Implementing APIs with Express.js
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express.js实现API
- en: A MongoDB ODM with DocumentTS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DocumentTS的MongoDB ODM
- en: Implementing JWT auth
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现JWT身份验证
- en: A custom server auth provider
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义服务器身份验证提供者
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The most up-to-date versions of the sample code for the book can be found on
    GitHub at the following linked repository. The repository contains the final and
    completed state of the code. This chapter requires the Docker Desktop and Postman
    applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍示例代码的最新版本可以在GitHub上的以下链接仓库中找到。[链接仓库](https://github.com/duluca/lemon-mart-server)。该仓库包含代码的最终和完成状态。本章需要Docker
    Desktop和Postman应用程序。
- en: It is critical that you get **lemon-mart-server** up and running on your development
    environment and have **lemon-mart** communicate with it. Refer to the instructions
    documented here or in the `README` on GitHub to get your server up and running.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在开发环境中启动**lemon-mart-server**并且**lemon-mart**能够与之通信至关重要。请参考此处或GitHub上的`README`中的说明来启动你的服务器。
- en: 'For server-side implementation in *Chapter 7*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第7章的服务端实现：
- en: 'Clone the `lemon-mart-server` repository using the `--recurse-submodules` option:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--recurse-submodules`选项克隆`lemon-mart-server`仓库：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the VS Code terminal, execute `cd web-app; git checkout master` to ensure
    the submodule from [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
    is on the master branch.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在VS Code终端中，执行`cd web-app; git checkout master`以确保从[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)克隆的子模块位于master分支。
- en: Later, in the *Git submodules* section, you can configure the `web-app` folder
    to pull from your `lemon-mart` server.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在后面的*Git子模块*部分，你可以配置`web-app`文件夹以从你的`lemon-mart`服务器拉取。
- en: Execute `npm install` in the `root` folder to install dependencies.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`root`文件夹中执行`npm install`以安装依赖项。
- en: Note that running the `npm install` command in the root folder triggers a script,
    which also installs dependencies under the `server` and `web-app` folders.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在根目录中运行`npm install`命令会触发一个脚本，该脚本还会在`server`和`web-app`文件夹下安装依赖项。
- en: Execute `npm run init:env` in the root folder to configure environment variables
    in `.env` files.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根目录中执行`npm run init:env`以配置`.env`文件中的环境变量。
- en: This command will create two `.env` files, one in the root folder and the other
    under the `server` folder, to contain your private configuration information.
    The initial files are generated based on the `example.env` file. You can modify
    these files later and set your own secure secrets.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将在根目录和 `server` 文件夹下创建两个 `.env` 文件，以包含您的私有配置信息。初始文件基于 `example.env` 文件生成。您可以在以后修改这些文件并设置自己的安全密钥。
- en: Execute `npm run build` in the root folder, which builds the server and the
    web app.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根目录中执行 `npm run build` 以构建服务器和网页应用。
- en: Note that the web app is built using a new configuration named `--configuration=lemon-mart-server`,
    which uses `src/environments/environment.lemon-mart-server.ts`.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，网页应用使用名为 `--configuration=lemon-mart-server` 的新配置构建，该配置使用 `src/environments/environment.lemon-mart-server.ts`。
- en: Execute `docker compose up --build` to run containerized versions of the server,
    web app, and a MongoDB database.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `docker compose up --build` 以运行服务器、网页应用和MongoDB数据库的容器化版本。
- en: Note that the web app is containerized using a new file named `nginx.Dockerfile`.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，网页应用使用名为 `nginx.Dockerfile` 的新文件进行容器化。
- en: Navigate to `http://localhost:8080` to view the web app.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到 `http://localhost:8080` 查看网页应用。
- en: To log in, click the **Fill** button to populate the email and password fields
    with the default demo credentials.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要登录，单击**填写**按钮以使用默认的演示凭据填写电子邮件和密码字段。
- en: Navigate to `http://localhost:3000` to view the server landing page:![A screenshot
    of a phone  Description automatically generated](img/B20960_07_01.png)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到 `http://localhost:3000` 查看服务器着陆页面：![手机截图  自动生成的描述](img/B20960_07_01.png)
- en: 'Figure 7.1: LemonMart Server landing page'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.1：LemonMart服务器着陆页面
- en: Navigate to `http://localhost:3000/api-docs` to view interactive API documentation.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到 `http://localhost:3000/api-docs` 查看交互式API文档。
- en: You can use `npm run start:database` to only start the database, and `npm start`
    on the `server` folder for debugging.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `npm run start:database` 仅启动数据库，并在 `server` 文件夹中使用 `npm start` 进行调试。
- en: You can use `npm run start:backend` to only start the database and the server,
    and `npm start` on the `web-app` folder for debugging.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `npm run start:backend` 仅启动数据库和服务器，并在 `web-app` 文件夹中使用 `npm start` 进行调试。
- en: 'For client-side implementations in *Chapter 7*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第7章中的客户端实现：
- en: 'Clone the repository: [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆仓库：[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)。
- en: Execute `npm install` in the root folder to install dependencies.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根目录中执行 `npm install` 以安装依赖项。
- en: 'The beginning state of the project is reflected at:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目的初始状态反映在：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The end state of the project is reflected at:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目的最终状态反映在：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将阶段名称添加到任何 `ng` 命令中，以仅对该阶段执行操作：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the `dist/stage10` folder at the root of the repository will contain
    the compiled result.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，仓库根目录下的 `dist/stage10` 文件夹将包含编译结果。
- en: Beware that the source code provided in the book and the version on GitHub are
    likely to be different. The ecosystem around these projects is ever-evolving.
    Between changes in how Angular CLI generates new code, bug fixes, new versions
    of libraries, and side-by-side implementations of multiple techniques, there are
    a lot of variations that are impossible to account for. If you find errors or
    have questions, please create an issue or submit a pull request on GitHub.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，书中提供的源代码和GitHub上的版本可能不同。这些项目周围的生态系统不断演变。由于Angular CLI生成新代码的方式、错误修复、库的新版本以及多种技术的并行实现，存在许多难以计数的变体。如果您发现错误或有疑问，请在GitHub上创建问题或提交拉取请求。
- en: With your LemonMart server up and running, we are ready to explore the architecture
    of the MEAN stack. By the end of this section, you should have your own version
    of LemonMart communicating with the server.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的LemonMart服务器启动并运行时，我们准备探索MEAN栈的架构。到本节结束时，您应该有自己的LemonMart版本与服务器通信。
- en: Full-stack architecture
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全栈架构
- en: '**Full-stack** refers to the entire stack of software that makes an application
    work, from databases to servers, APIs, and the web and/or mobile apps that leverage
    them. The mythical full-stack developer is all-knowing and can comfortably operate
    in all verticals of the profession. It is next to impossible to specialize in
    all things *software-related* and to be considered an expert in every given topic.
    However, to be considered an expert in a single topic, you must also be well-versed
    in related topics. When learning about a new topic, it is very helpful to keep
    your tooling and language consistent to absorb new information without additional
    noise.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**全栈**指的是使应用程序工作的整个软件堆栈，从数据库到服务器、API以及利用它们的Web和/或移动应用程序。传说中的全栈开发者无所不知，可以轻松地在职业的各个垂直领域操作。在所有与软件相关的事物上专长并被认为是每个给定主题的专家几乎是不可能的。然而，要被认为是某个主题的专家，你也必须对相关主题有深入的了解。在了解一个新主题时，保持你的工具和语言一致非常有帮助，这样你就可以在没有额外噪音的情况下吸收新信息。'
- en: For these reasons, I opted to introduce you to the MEAN stack, rather than Spring
    Boot using Java or ASP.NET using C#. By sticking to familiar tools and languages
    such as TypeScript, VS Code, npm, GitHub, Jasmine/Jest, Docker, and CircleCI,
    you can better understand how a full-stack implementation comes together and become
    a better web developer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我选择向你介绍MEAN堆栈，而不是使用Java的Spring Boot或使用C#的ASP.NET。通过坚持熟悉的工具和语言，如TypeScript、VS
    Code、npm、GitHub、Jasmine/Jest、Docker和CircleCI，你可以更好地理解全栈实现是如何结合在一起的，并成为一个更好的Web开发者。
- en: Minimal MEAN
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化MEAN
- en: 'Choosing the **ideal stack** for your project is difficult. First and foremost,
    your technical architecture should be adequate to meet business needs. For example,
    if you’re trying to deliver an artificial intelligence project with Node.js, you’re
    likely using the wrong stack. Our focus will be on delivering web applications,
    but beyond that, we have other parameters to consider, including the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的项目选择**理想的堆栈**是困难的。首先，你的技术架构应该足够满足业务需求。例如，如果你试图使用Node.js交付一个人工智能项目，你很可能会使用错误的堆栈。我们的重点将是交付Web应用程序，但除此之外，我们还有其他参数需要考虑，包括以下内容：
- en: Ease of use
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易用性
- en: Happiness
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸福
- en: Effectiveness
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率
- en: If your development team will be working on your application for an extended
    period, it is very important to consider factors beyond compatibility. Your stack,
    choice of tool, and coding style can have a significant impact if your codebase
    is easy to use, keeps your developers happy, or makes them feel like effective
    contributors to the project.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的开发团队将长期从事你的应用程序开发，考虑兼容性以外的因素非常重要。如果你的代码库易于使用，让你的开发者保持愉快，或者让他们觉得自己是项目的有效贡献者，你的堆栈、工具选择和编码风格可以产生重大影响。
- en: A well-configured stack is key for a great DevEx. This can be the difference
    between a towering stack of dried-out pancakes or a delicious short stack, with
    the right amount of butter and syrup.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好配置的堆栈对于优秀的DevEx至关重要。这可能是干燥的煎饼堆和美味的小份煎饼之间的区别，适量的黄油和糖浆。
- en: By introducing too many libraries and dependencies, you can slow down your progress,
    make your code difficult to maintain, and find yourself in a feedback loop of
    introducing more libraries to resolve the issues of other libraries. The only
    way to win this game is to simply not play it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入过多的库和依赖项，你可以减慢你的进度，使你的代码难以维护，并发现自己陷入引入更多库以解决其他库问题的反馈循环。赢得这场游戏的唯一方法就是简单地不参与。
- en: 'If you take your time to learn how to work with a few fundamental libraries,
    you can become a far more effective developer. In essence, you can do more with
    less. My advice would be to:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花时间学习如何使用几个基本的库，你可以成为一个更有效的开发者。本质上，你可以用更少的资源做更多的事情。我的建议是：
- en: '**Think** before you write a single line of code and apply the 80-20 rule.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写任何一行代码之前**思考**，并应用80-20规则。
- en: '**Wait** for libraries and tools to mature, skipping the betas.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等待**库和工具成熟，跳过测试版。'
- en: '**Fast** by reducing your gluttony for new packages and tools, mastering the
    fundamentals instead.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**通过减少对新包和工具的贪婪，掌握基础知识。'
- en: Watch my 2017 Ng conference talk entitled *Do More with Less JavaScript* on
    YouTube at [https://www.youtube.com/watch?v=Sd1aM8181kc](https://www.youtube.com/watch?v=Sd1aM8181kc).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在YouTube上观看我2017年Ng会议的演讲，标题为*用更少的JavaScript做更多的事情*，链接为[https://www.youtube.com/watch?v=Sd1aM8181kc](https://www.youtube.com/watch?v=Sd1aM8181kc)。
- en: 'This minimalist mindset is the design philosophy behind minimal MEAN. You can
    review a reference implementation on GitHub at [https://github.com/duluca/minimal-mean](https://github.com/duluca/minimal-mean).
    Refer to the following diagram for the overall architecture:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种极简主义思维是最小化MEAN的设计哲学。您可以在GitHub上查看参考实现：[https://github.com/duluca/minimal-mean](https://github.com/duluca/minimal-mean)。请参考以下图表以了解整体架构：
- en: '![](img/B20960_07_02.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_07_02.png)'
- en: 'Figure 7.2: Minimal MEAN software stack and tooling'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：最小化MEAN软件栈和工具
- en: 'Let’s go over the components of the architecture:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下架构的组件：
- en: '**Angular**: You know this one. Angular is the presentation layer. The output
    of an Angular build is a set of static files that can be hosted using the minimal
    Docker container, `duluca/minimal-nginx-web-server,` or `duluca/minimal-node-web-server`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular**: 您应该知道这个。Angular是表示层。Angular构建的输出是一组静态文件，可以使用最小化的Docker容器`duluca/minimal-nginx-web-server`或`duluca/minimal-node-web-server`托管。'
- en: '**Express.js**: This is our API layer. Express is a fast, unopinionated, and
    minimalist web framework for Node.js. Express has a vast plugin ecosystem that
    is almost guaranteed to meet every need. NestJS is built on Express and is a good
    alternative for well-established teams. In minimal MEAN, we leverage a few Express
    middleware:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Express.js**: 这是我们的API层。Express是一个快速、无偏见、极简的Node.js网络框架。Express拥有庞大的插件生态系统，几乎可以满足每一个需求。NestJS建立在Express之上，是成熟团队的不错替代品。在最小化MEAN中，我们利用了一些Express中间件：'
- en: '`cors`: configures cross-origin resource-sharing settings'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cors`: 配置跨源资源共享设置'
- en: '`compression`: zips packets sent across the wire to lower bandwidth use'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compression`: 压缩通过网络发送的数据包以降低带宽使用'
- en: '`morgan`: logs HTTP requests'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`morgan`: 记录HTTP请求'
- en: '`express.static:` function to serve the content of the `public` folder'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express.static:` 用于提供`public`文件夹内容的函数'
- en: '`graphql:` to host GraphQL endpoint'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql:` 用于托管GraphQL端点'
- en: You can read more about Express.js at [https://expressjs.com/](https://expressjs.com/)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://expressjs.com/](https://expressjs.com/)了解更多关于Express.js的信息
- en: '**Node.js**: This is the server runtime; Express runs on Node so that the business
    layer will be implemented in Node. Node is a lightweight and efficient JavaScript
    runtime that uses an event-driven, non-blocking I/O model that suits high-performance
    and real-time applications. You can increase the reliability of your Node applications
    by using TypeScript to develop your application.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js**: 这是服务器运行时；Express在Node上运行，因此业务层将在Node上实现。Node是一个轻量级且高效的JavaScript运行时，它使用事件驱动的、非阻塞的I/O模型，适用于高性能和实时应用。您可以通过使用TypeScript开发应用程序来提高Node应用程序的可靠性。'
- en: Node runs everywhere, from fridges to smartwatches. Refer to the blog post by
    Frank Rosner on non-blocking I/O for a more in-depth explanation of the topic
    at [https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/).
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Node可以在任何地方运行，从冰箱到智能手表。请参阅Frank Rosner的博客文章，深入了解非阻塞I/O主题：[https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/)。
- en: '**MongoDB**: This is the persistence layer. MongoDB is a document-oriented
    database with dynamic JSON-like schemas. Read more about MongoDB at [https://www.mongodb.com/](https://www.mongodb.com/).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**: 这是持久化层。MongoDB是一个具有动态JSON类似模式的文档型数据库。有关MongoDB的更多信息，请参阅[https://www.mongodb.com/](https://www.mongodb.com/)。'
- en: The MEAN stack is preferred because it leverages the major benefit of using
    a JSON-based database, which means that you don’t need to transform your data
    from one format to another, as it crosses the layers of your stack – a major pain
    point when dealing with .NET, Java, and SQL servers. You can retrieve, display,
    edit, and update the data using only JSON. In addition, the MongoDB native driver
    for Node is mature, performant, and capable. I have developed a library called
    `document-ts`, which aims to simplify interacting with MongoDB by introducing
    rich document objects that are easy to code. DocumentTS is a very thin TypeScript-based
    MongoDB helper with optional, rich ODM convenience features. Read more about DocumentTS
    at [https://github.com/duluca/document-ts](https://github.com/duluca/document-ts).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: MEAN堆栈更受欢迎，因为它利用了使用基于JSON的数据库的主要好处，这意味着你不需要将数据从一种格式转换到另一种格式，因为它跨越了你的堆栈层——在处理.NET、Java和SQL服务器时这是一个主要痛点。你可以仅使用JSON来检索、显示、编辑和更新数据。此外，Node的MongoDB原生驱动程序成熟、性能良好且功能强大。我开发了一个名为`document-ts`的库，旨在通过引入易于编码的丰富文档对象来简化与MongoDB的交互。DocumentTS是一个非常薄的基于TypeScript的MongoDB助手，具有可选的丰富ODM便利功能。更多关于DocumentTS的信息请参阅[https://github.com/duluca/document-ts](https://github.com/duluca/document-ts)。
- en: Minimal MEAN leverages most of the same tooling and languages we use for Angular
    development. This enables developers to switch between frontend and backend development
    with minimal context switching.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Minimal MEAN利用了我们用于Angular开发的相同工具和语言，这使得开发者可以在前端和后端开发之间进行最小化的上下文切换。
- en: NestJS
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NestJS
- en: Minimal MEAN intentionally sticks to the basics, so you can learn more about
    the underlying technologies. While I have delivered production systems using minimal
    MEAN for larger teams with varying skill levels, this barebones development experience
    may not be appropriate. In this case, you may consider NestJS, a popular framework
    for implementing full-stack Node.js apps. NestJS has a rich feature set with an
    architecture and coding style resembling Angular.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Minimal MEAN有意坚持基本原理，这样你可以更多地了解底层技术。虽然我使用Minimal MEAN为具有不同技能水平的大型团队交付了生产系统，但这种基础的开发体验可能并不合适。在这种情况下，你可能考虑NestJS，这是一个用于实现全栈Node.js应用的流行框架。NestJS具有丰富的功能集，其架构和编码风格类似于Angular。
- en: 'Feeling adventurous? Create a NestJS app by executing:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 想要冒险吗？通过执行以下命令创建一个NestJS应用：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Nest is built on Express and provides syntactic sugar and concepts to build
    a scalable backend solution. The framework heavily borrows ideas from Angular
    to implement dependency injection, guards, interceptors, pipes, modules, and providers.
    The built-in resource generator can scaffold entity classes, **CRUD** (**Create**,
    **Retrieve**, **Update**, **Delete**) controllers, **Data Transfer Objects** (**DTOs**),
    and services.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Nest建立在Express之上，并提供了构建可扩展后端解决方案的语法糖和概念。该框架大量借鉴了Angular的思想来实现依赖注入、守卫、拦截器、管道、模块和提供者。内置的资源生成器可以生成实体类、**CRUD**（**创建**、**检索**、**更新**、**删除**）控制器、**数据传输对象**（**DTOs**）和服务。
- en: 'For example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When creating a resource, you can choose between creating a REST, GraphQL,
    microservice, or WebSocket endpoint:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建资源时，你可以选择创建REST、GraphQL、微服务或WebSocket端点：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Nest supports OpenAPI for REST documentation, and GraphQL also supports schema-first
    and code-first development for GraphQL. For a library with so many features, Nest’s
    explicit Microservice support is welcome, where a fast boot-up time and small
    framework size are critical for operations. All these features are supported by
    detailed documentation at [https://docs.nestjs.com/](https://docs.nestjs.com/).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Nest支持OpenAPI用于REST文档，GraphQL也支持GraphQL的schema-first和code-first开发。对于具有如此多功能的库，Nest的显式微服务支持是受欢迎的，快速启动时间和小框架大小对于操作至关重要。所有这些功能都由详细的文档在[https://docs.nestjs.com/](https://docs.nestjs.com/)中支持。
- en: Kudos to Kamil Mysliwiec and Mark Pieszak for creating a great tool and fostering
    a vibrant community around NestJS. Should you ever need it, you can solicit consulting
    services at [https://trilon.io/](https://trilon.io/).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 向Kamil Mysliwiec和Mark Pieszak致敬，他们创建了一个伟大的工具，并在NestJS周围培养了一个充满活力的社区。如果你需要，可以在[https://trilon.io/](https://trilon.io/)寻求咨询服务。
- en: If you visit the documentation site, you may be overwhelmed with the many options
    on offer. This is why I recommend using a feature-rich library like this after
    you have mastered the basics with minimal MEAN.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问文档网站，可能会被提供的众多选项所淹没。这就是为什么我在你用最少的MEAN掌握了基础知识之后，推荐使用功能丰富的库的原因。
- en: You can read more about NestJS at [https://nestjs.com/](https://nestjs.com/).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://nestjs.com/](https://nestjs.com/)了解更多关于NestJS的信息。
- en: Next, let’s learn about monorepos, their benefits, and their downsides. I will
    share how you can combine Nx, Nest, and Angular in a monorepo, and then cover
    how LemonMart server uses Git submodules to create a monorepo.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解monorepo、它们的优点和缺点。我将分享如何在monorepo中结合Nx、Nest和Angular，然后介绍LemonMart服务器如何使用Git子模块创建monorepo。
- en: Working with monorepos
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在VS Code中使用多根工作区
- en: A **monorepo** (**monolithic repository**) is a software development strategy
    to host code from multiple projects in a single repository. This allows for unified
    versioning, simplified dependency management, and easier code sharing across projects.
    In a monorepo, developers can jump between projects within the same IDE window
    and reference code more easily across projects, such as sharing TypeScript interfaces
    between the frontend and the backend, ensuring that data objects line up every
    time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**monorepo**（**单体仓库**）是一种软件开发策略，用于在单个仓库中托管多个项目的代码。这允许统一版本控制、简化依赖关系管理，以及更容易地在项目之间共享代码。在monorepo中，开发者可以在同一个IDE窗口中跳转项目，并更容易地在项目之间引用代码，例如在前端和后端之间共享TypeScript接口，确保数据对象每次都保持一致。'
- en: You can enable access to multiple projects in the same IDE window using multi-root
    workspaces in VS Code, where you can add multiple projects to display in the *Explorer*
    window. However, a monorepo combines projects at the source control level, allowing
    us to build them together on our CI server. Read more about multi-root workspaces
    at [https://code.visualstudio.com/docs/editor/multi-root-workspaces](https://code.visualstudio.com/docs/editor/multi-root-workspaces).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用VS Code中的多根工作区在同一个IDE窗口中启用对多个项目的访问，你可以在*资源管理器*窗口中添加多个项目进行显示。然而，monorepo在源代码控制级别将项目组合在一起，允许我们在CI服务器上一起构建它们。有关多根工作区的更多信息，请参阅[https://code.visualstudio.com/docs/editor/multi-root-workspaces](https://code.visualstudio.com/docs/editor/multi-root-workspaces)。
- en: Having access to code from multiple projects makes it possible to commit atomic
    changes, meaning changes made across projects can be combined into a single commit.
    This brings a distinct advantage by making it easy to push changes that may otherwise
    require coordination across multiple repos, deployments, and systems in one place.
    All processes around maintaining code quality and standards also become simplified.
    There’s one **Pull Request** (**PR**) to review, one deployment to verify, and
    one set of checks to enforce.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 能够访问多个项目的代码使得提交原子更改成为可能，这意味着跨项目所做的更改可以合并为一个单独的提交。这通过将可能需要在多个仓库、部署和系统中协调的更改集中在一个地方，带来明显的优势。所有围绕维护代码质量和标准的过程也变得简化。只有一个**Pull
    Request**（**PR**）需要审查，一个部署需要验证，以及一组需要执行的检查。
- en: So why is every project not a monorepo? In large applications, having too many
    files in the project can become a significant issue. It would require every developer
    to have top-of-the-line hardware and CI/CD servers to run on expensive, high-performance
    hardware. In addition, automating the deployment of such a project can become
    a very complex task. Finally, a new team member joining the team can find it overwhelming.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么每个项目都不是monorepo呢？在大型的应用程序中，项目中的文件过多可能成为一个重大问题。它要求每个开发者都拥有顶级的硬件和CI/CD服务器，以便在昂贵的、高性能的硬件上运行。此外，自动部署这样的项目可能成为一个非常复杂的任务。最后，新加入团队的新成员可能会感到不知所措。
- en: While monorepos at least date back to the early 2000s, they were impractical
    to leverage as a strategy for most, except the top tech companies worldwide. In
    2019, when Google released the open-source Bazel build tool, itself based on a
    2015 internal project called Blaze, the idea became feasible for smaller-scale
    projects. In the JavaScript, TypeScript, and web app development world, Nx, developed
    by ex-Googlers, has risen to prominence. In terms of managing, building, and publishing
    packages, Lerna is a cousin of Nx.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 monorepos 至少可以追溯到2000年代初，但对于大多数公司来说，除了全球顶尖的科技公司外，它们并不实用。2019年，当谷歌发布了开源的Bazel构建工具，该工具基于2015年的内部项目Blaze时，这个想法对于小规模项目来说变得可行。在JavaScript、TypeScript和Web应用程序开发领域，由前谷歌员工开发的Nx已经崭露头角。在管理、构建和发布包方面，Lerna是Nx的近亲。
- en: Nx monorepo
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nx monorepo
- en: As mentioned in *Chapter 3*, *Architecting an Enterprise App*, Nx is a next-generation
    build system with first-class monorepo support and powerful integrations. Nx offers
    an opinionated architecture, which is welcome for large teams and enterprises.
    Nx also has a cloud offering, where it’ll leverage a distributed cache and parallelization
    to optimize builds without your team investing in complicated infrastructure work.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*第 3 章*中提到的，*构建企业级应用架构*，Nx 是一个下一代构建系统，具有一流的单一代码仓库支持和强大的集成功能。Nx 提供了一种有见地的架构，这对于大型团队和企业来说是非常受欢迎的。Nx
    还提供云服务，它将利用分布式缓存和并行化来优化构建，而无需你的团队投资复杂的底层基础设施工作。
- en: 'You can set up a new Nx workspace by executing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下命令来设置一个新的 Nx 工作空间：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you can migrate an existing project by executing the following
    command in the project folder:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在项目文件夹中执行以下命令来迁移现有项目：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By default, this will give you a monorepo configuration with one app. You can
    use Nx generators to add libraries that can be shared across components and other
    modules. By separating code into distinct libraries, multiple people working on
    the project simultaneously are less likely to have merge conflicts. However, if
    you follow the router-first architecture and segregate duties between feature
    modules, you can get similar results. There’s more at [https://nx.dev/getting-started](https://nx.dev/getting-started).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这将为你提供一个包含一个应用的单一代码仓库配置。你可以使用 Nx 生成器添加可以在组件和其他模块之间共享的库。通过将代码分离到不同的库中，同时参与项目工作的多个人不太可能遇到合并冲突。然而，如果你遵循先路由架构并在功能模块之间划分职责，你也能得到类似的结果。更多内容请参阅[https://nx.dev/getting-started](https://nx.dev/getting-started)。
- en: The question is, is it worth it? Many experts use it as a standard tool; however,
    in my pursuit of minimalism, I’m not a fan of bringing a tank to a knife fight.
    There’s a cost to introducing a sophisticated piece of tech like this to a team.
    There’s a steep learning curve to adopt such a tool.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，这值得吗？许多专家将其用作标准工具；然而，在我追求简约的过程中，我不喜欢在刀战中带来坦克。引入这样复杂的技术对团队来说是有成本的。采用这样的工具需要克服陡峭的学习曲线。
- en: When you layer JavaScript, TypeScript, Git, Nx, Angular, libraries, Node, npm,
    and other server-side tech on top of each other, the cognitive load required to
    navigate these tools goes through the roof. Furthermore, each one of these tools
    requires expertise to correctly configure, maintain, and upgrade them over time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 JavaScript、TypeScript、Git、Nx、Angular、库、Node、npm 和其他服务器端技术之上层层叠加时，导航这些工具所需的认知负荷会急剧增加。此外，这些工具中的每一个都需要专业知识来正确配置、维护和随着时间的推移进行升级。
- en: On modern hardware (at least ones not addled by enterprise-grade *slow-everything-down-so-we-can-make-extra-sure-you-don’t-have-a-virus*
    software installed on it), Angular apps with several hundred components build
    fast enough. With the adoption of esbuild and Vite, this should improve even further.
    Nx’s distributed cache and centralized dependency management features may tip
    the scales for you. Always assess your needs carefully before starting a new project;
    running on autopilot, it’s easy to either under- or overestimate your needs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代硬件上（至少不是被企业级*慢速一切以便我们可以额外确保你没有病毒*软件搞砸的硬件），拥有数百个组件的 Angular 应用构建速度足够快。随着 esbuild
    和 Vite 的采用，这应该会进一步改善。Nx 的分布式缓存和集中式依赖管理功能可能会对你产生决定性影响。在开始一个新项目之前，务必仔细评估你的需求；自动运行时，很容易低估或高估你的需求。
- en: I want to make one thing crystal clear. If you are working with thousands of
    components, then Nx is a requirement.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我要明确一点。如果你正在处理数千个组件，那么 Nx 是必需的。
- en: 'Most Angular monorepos only contain frontend code. To configure a full-stack
    monorepo using NestJS in an existing Angular workspace, install the Nest schematic
    and generate a new project within the Nx workspace:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Angular 单一代码仓库只包含前端代码。要在现有的 Angular 工作空间中使用 NestJS 配置一个全栈单一代码仓库，请安装 Nest
    脚本并在 Nx 工作空间内生成一个新项目：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can read more about this at [https://www.thisdot.co/blog/nx-workspace-with-angular-and-nest/](https://www.thisdot.co/blog/nx-workspace-with-angular-and-nest/).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处了解更多信息[https://www.thisdot.co/blog/nx-workspace-with-angular-and-nest/](https://www.thisdot.co/blog/nx-workspace-with-angular-and-nest/)。
- en: Next, let’s see how LemonMart server’s monorepo is configured.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 LemonMart 服务器的单一代码仓库是如何配置的。
- en: Git submodules
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git 子模块
- en: Git submodules help you share code between multiple repositories while keeping
    the commits separate. Frontend developers may choose to only work using the frontend
    repository, whereas full-stack developers will prefer access to all code. Git
    submodules also provide a convenient way for existing projects to be combined.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Git子模块帮助您在多个仓库之间共享代码，同时保持提交的分离。前端开发者可能选择仅使用前端仓库进行工作，而全栈开发者将更喜欢访问所有代码。Git子模块还为现有项目的合并提供了一个方便的方法。
- en: 'Observe the overall structure of the `lemon-mart-server` project, where you
    are going to have three main folders, as shown here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一下`lemon-mart-server`项目的整体结构，您将拥有三个主要文件夹，如图所示：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `bin` folder contains helper scripts or tools, the `web-app` folder represents
    your frontend, and `server` contains the source code for the backend. In our case,
    the `web-app` folder is the `lemon-mart` project. Instead of copying and pasting
    the code from the existing project, we leverage Git submodules to link two repositories
    together. The `package.json` file contains scripts that assist in the initialization,
    updating, and cleaning up of Git submodules, like `modules:update` to fetch the
    latest version of the web app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`bin`文件夹包含辅助脚本或工具，`web-app`文件夹代表您的前端，而`server`包含后端源代码。在我们的案例中，`web-app`文件夹是`lemon-mart`项目。我们不是复制粘贴现有项目的代码，而是利用Git子模块将两个仓库链接在一起。`package.json`文件包含帮助初始化、更新和清理Git子模块的脚本，如`modules:update`用于获取web应用的最新版本。'
- en: I recommend that you perform the following actions on the version of `lemon-mart-server`
    that you cloned from GitHub. Otherwise, you will need to create a new project
    and execute `npm init -y` to get things started.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您在从GitHub克隆的`lemon-mart-server`版本上执行以下操作。否则，您将需要创建一个新的项目并执行`npm init -y`以开始操作。
- en: 'To initialize the web-app folder with your project:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用您的项目初始化web-app文件夹：
- en: Update `webAppGitUrl` with the URL to your own project.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`webAppGitUrl`更新为您自己的项目的URL。
- en: Execute `webapp:clean` to remove the existing `web-app` folder.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`webapp:clean`以删除现有的`web-app`文件夹。
- en: 'Finally, execute the `webapp:init` command to initialize your project in the
    `web-app` folder:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行`webapp:init`命令以初始化`web-app`文件夹中的项目：
- en: '[PRE11]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Going forward, execute the `modules:update` command to update the code in the
    submodule. To pull the submodules after cloning the repo in another environment,
    execute `npm modules:init`. If you ever need to reset the environment and restart,
    then execute `webapp:clean` to clean Git’s cache and remove the folder.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进时，执行`modules:update`命令以更新子模块中的代码。在另一个环境中克隆仓库后，要拉取子模块，请执行`npm modules:init`。如果您需要重置环境并重新启动，请执行`webapp:clean`以清理Git的缓存并删除文件夹。
- en: Note that you can have multiple submodules in your repository. The `modules:update`
    command will update all the submodules.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以在您的仓库中拥有多个子模块。`modules:update`命令将更新所有子模块。
- en: 'Your web application code is now available in the folder named `web-app`. Additionally,
    you should be able to see both projects under VS Code’s **SOURCE CONTROL** pane,
    as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Web应用程序代码现在可在名为`web-app`的文件夹中找到。此外，您应该能够在VS Code的**源代码控制**面板下看到这两个项目，如图所示：
- en: '![](img/B20960_07_03.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_07_03.png)'
- en: 'Figure 7.3: VS Code source control providers'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：VS Code源代码控制提供者
- en: Using VS Code’s source control, you can independently perform Git actions on
    either repository.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用VS Code的源代码控制，您可以对任一仓库独立执行Git操作。
- en: If things get messy with your submodule, simply `cd` into the submodule directory,
    execute `git pull`, and then `git checkout main` to restore the main branch. Using
    this technique, you may check out any branch from your project and submit PRs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的子模块变得混乱，只需`cd`到子模块目录，执行`git pull`，然后`git checkout main`以恢复主分支。使用此技术，您可以从项目中的任何分支检出并提交PR。
- en: Now that our submodule is ready, let’s see how the server project is configured
    so that we can configure our CI server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在子模块已经准备好了，让我们看看服务器项目是如何配置的，这样我们就可以配置我们的CI服务器。
- en: CircleCI config
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CircleCI配置
- en: 'One of the benefits of using Git submodules is that we can verify that our
    frontend and backend work in the same CI pipeline. The `config.yml` file implements
    two jobs, part of the workflow shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Git子模块的一个好处是我们可以验证我们的前端和后端是否在同一个CI管道中工作。`config.yml`文件实现了两个作业，这是这里显示的工作流程的一部分：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The pipeline checks out the code, verifies the security of the packages we’re
    using with `audit-ci`, installs dependencies, checks for styling and linting errors,
    runs tests, and checks for code coverage levels.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 管道检出代码，使用 `audit-ci` 验证我们使用的包的安全性，安装依赖项，检查样式和 linting 错误，运行测试，并检查代码覆盖率水平。
- en: The test commands implicitly build the server code, which is stored under the
    `dist` folder. In the final step, we move the `dist` folder into the workspace
    so that we can use it at a later stage.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 测试命令隐式构建服务器代码，这些代码存储在 `dist` 文件夹下。在最后一步，我们将 `dist` 文件夹移动到工作区，以便我们可以在以后阶段使用它。
- en: The CI pipeline will build the server and the web app in parallel, with an option
    to run the `deploy` job if the jobs succeed on the main branch. There are more
    details on CI/CD in *Chapter 10, Releasing to Production* *with CI/CD*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: CI 管道将并行构建服务器和 Web 应用程序，如果主分支上的作业成功，可以选择运行 `deploy` 作业。关于 CI/CD 的更多细节可以在 *第
    10 章，使用 CI/CD 发布到生产* 中找到。
- en: Next, let’s see the difference between RESTful and GraphQL APIs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 RESTful 和 GraphQL API 之间的区别。
- en: Designing APIs
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计 API
- en: In *Chapter 3*, *Architecting an Enterprise App*, I cover the importance of
    a stateless, data-driven design as part of Router-first architecture. As part
    of this goal, I highlight identifying major data entities that your app will operate
    around as an important activity. It’s no mistake that API design also greatly
    benefits by designing around major data entities.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 章，构建企业应用程序架构* 中，我讨论了无状态、数据驱动设计作为 Router-first 架构的一部分的重要性。作为这一目标的一部分，我强调识别应用程序将围绕其操作的主要数据实体作为一项重要活动。API
    设计通过围绕主要数据实体进行设计也能带来极大的好处。
- en: In full-stack development, nailing down the API design early on is important.
    If your frontend and backend teams can agree on major data entities and the shape
    of those entities, then both teams can agree on a contract to go off and build
    their own respective pieces of software. In Router-first architecture, I highlight
    the importance of leveraging TypeScript interfaces to quickly stub out the architecture
    of your app. Backend teams can conduct similar activities.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在全栈开发中，尽早确定 API 设计非常重要。如果前端和后端团队能够就主要数据实体及其形状达成一致，那么两个团队就可以就一个合同达成一致，去构建他们各自的软件组件。在
    Router-first 架构中，我强调了利用 TypeScript 接口快速构建应用程序架构的重要性。后端团队也可以进行类似的活动。
- en: A little bit of early design work and agreement ensures integration between
    these components can be established very early on, and with CI/CD pipelines, we
    can ensure it doesn’t disintegrate.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一点早期的设计工作和协议确保了这些组件之间的集成可以非常早地建立，并且通过 CI/CD 管道，我们可以确保它不会分解。
- en: CI is critical to success. One of the most infamous cases where teams didn’t
    integrate critical systems until too late was the disastrous launch of HealthCare.gov
    in 2013\. Even though 300 people worked on it, and $300,000,000 was spent on this
    project, it failed. In total, 1.7 billion dollars had to be spent to rescue the
    project and make it successful. The US federal government can afford to do this.
    Your enterprise won’t be as accepting.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: CI 对于成功至关重要。最臭名昭著的案例之一是，团队直到太晚才整合关键系统，那就是 2013 年 HealthCare.gov 的灾难性发布。尽管有 300
    人参与其中，并且在这个项目上花费了 3 亿美元，但它失败了。总共花费了 17 亿美元来拯救该项目并使其成功。美国政府可以承担这样的费用。您的企业可能不会这么宽容。
- en: There are further considerations in designing your API, and if frontend and
    backend developers collaborate closely to achieve shared design goals, the chance
    of project success is greatly improved.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计您的 API 时，还有一些进一步的考虑因素，如果前端和后端开发者紧密合作以实现共同的设计目标，那么项目成功的几率将大大提高。
- en: 'Some high-level goals are listed as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列出以下高级目标：
- en: Minimize data transmitted between the client and server.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化客户端和服务器之间传输的数据。
- en: Stick to well-established design patterns (e.g., pagination API design).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坚持使用成熟的设计模式（例如，分页 API 设计）。
- en: Design to reduce business logic implementation on the client.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计以减少客户端上的业务逻辑实现。
- en: Design around major data entities.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕主要数据实体进行设计。
- en: Flatten data structures when crossing boundaries.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在跨越边界时简化数据结构。
- en: Do not expose database keys or foreign key relationships.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要暴露数据库密钥或外键关系。
- en: Version endpoints from the get-go.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一开始就版本化端点。
- en: You should aim to implement all the business logic behind your API surface.
    The frontend should only contain presentation logic. Any `if` statement implemented
    by the frontend should also be verified in the backend.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该旨在实现API表面背后的所有业务逻辑。前端应仅包含展示逻辑。任何由前端实现的`if`语句也应由后端验证。
- en: As discussed in *Chapter 1*, *Angular’s Architecture and Concepts*, it is critical
    to aim for a stateless design in both the backend and frontend. Every request
    should utilize non-blocking I/O methods and not rely on existing sessions. This
    is the key to seamlessly scaling your web application code on cloud platforms.
    Sessions are notorious for scaling out and using a lot of memory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第1章*Angular的架构和概念*中讨论的那样，在后台和前端实现无状态设计至关重要。每个请求都应该利用非阻塞I/O方法，并且不依赖于现有的会话。这是在云平台上无缝扩展你的Web应用程序代码的关键。会话因其扩展和占用大量内存而臭名昭著。
- en: Whenever you’re implementing a project, it is important to limit, if not eliminate,
    experimentation. This is especially true in full-stack projects. The downstream
    effect of missteps in API design can be profound and impossible to correct once
    your application goes live. Proofs of concept are ideal places to experiment and
    validate ideas and new technologies. Their one great feature is how disposable
    they are.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你在实施一个项目，限制，如果可能的话，消除实验是非常重要的。这在全栈项目中尤其如此。一旦你的应用程序上线，API设计中的失误可能会产生深远的影响，并且难以纠正。概念验证是实验和验证想法以及新技术理想的地方。它们的一个显著特点是它们的可丢弃性。
- en: Next, let’s go over designing REST and GraphQL APIs around major data entities.
    In this case, we’ll review the implementation of an API surrounding users, including
    authentication. In both cases, we will rely on an API specification language.
    For REST, we will use the OpenAPI specification, and for GraphQL, the schemas
    specification, to document the design so that we can concretely communicate the
    intent of the API to team members. Later, these specs become interactive tools,
    reflecting the capability of our APIs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来讨论围绕主要数据实体设计REST和GraphQL API。在这种情况下，我们将回顾围绕用户和认证的API实现。在两种情况下，我们将依赖API规范语言。对于REST，我们将使用OpenAPI规范，对于GraphQL，我们将使用模式规范，以记录设计，以便我们可以具体地向团队成员传达API的意图。稍后，这些规范将成为交互式工具，反映我们API的能力。
- en: REST APIs
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API
- en: '**REST** (**representational state transfer**) is commonly used to create stateless,
    reliable web applications leveraging HTTP methods (verbs) like **GET**, **POST**,
    **PUT**, and **DELETE**. REST APIs are well defined and static. Like any public
    API, once released, it is very difficult, if not impossible, to change their interface.
    It is always possible to extend but hard to optimize for emergent use cases, like
    mobile or purpose-built apps that need to use the API differently. This usually
    leads to a great expansion of the API surface as teams implement specific APIs
    to match new needs. This can lead to maintainability challenges if there are a
    half-dozen separate codebase to access the same piece of data.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**（**表示状态转移**）通常用于创建利用HTTP方法（动词）如**GET**、**POST**、**PUT**和**DELETE**的无状态、可靠的Web应用程序。REST
    API定义良好且静态。像任何公开API一样，一旦发布，就很难，如果不是不可能的，改变它们的接口。总是可以扩展，但很难针对新兴用例进行优化，例如需要以不同方式使用API的移动或专用应用程序。这通常会导致API表面的巨大扩展，因为团队实施特定的API来满足新的需求。如果有多个独立的代码库需要访问相同的数据，这可能会导致可维护性挑战。'
- en: From a frontend developer’s perspective, working with APIs they didn’t write
    can be a perplexing experience. Most public APIs and businesses that publish APIs
    usually resolve this by publishing high-quality documentation and examples. This
    takes time and money. However, a fast-moving team in an enterprise environment
    can’t afford to wait for such documentation to be manually created.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从前端开发者的角度来看，使用他们没有编写过的API可能是一种令人困惑的经历。大多数公开API和发布API的企业通常通过发布高质量的文档和示例来解决这个问题。这需要时间和金钱。然而，在企业环境中，一个快速发展的团队无法等待这样的文档被手动创建。
- en: Enter OpenAPI, aka Swagger. OpenAPI specs can document API names, routes, input
    and return parameter types, encoding, authentication, request headers, and expected
    HTTP status codes. This level of detail leaves little room for interpretation
    of how an API should be consumed, reducing friction and buggy code – all critical
    ingredients to avoid late-stage integration challenges.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 OpenAPI，也称为 Swagger。OpenAPI 规范可以记录 API 名称、路由、输入和返回参数类型、编码、身份验证、请求头和预期的 HTTP
    状态码。这种详细程度为 API 应如何使用留下了很少的解释空间，减少了摩擦和有缺陷的代码——所有这些都是避免后期集成挑战的关键因素。
- en: 'The OpenAPI spec can be defined in the YAML or JSON format. Using this spec
    file, you can render an interactive UI for your API. Install the Swagger Viewer
    VS Code extension and preview the `swagger.yaml` file under the `server` folder:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 规范可以用 YAML 或 JSON 格式定义。使用此规范文件，您可以为您 API 渲染一个交互式用户界面。安装 Swagger Viewer
    VS Code 扩展，并在 `server` 文件夹下预览 `swagger.yaml` 文件：
- en: There’s also the OpenAPI (Swagger) Editor extension, which is a feature-rich
    alternative. At the time of publishing, this extension doesn’t support OpenAPI
    version 3.1.0.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 OpenAPI (Swagger) 编辑器扩展，这是一个功能丰富的替代品。在发布时，此扩展不支持 OpenAPI 版本 3.1.0。
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_07_04.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B20960_07_04.png)'
- en: 'Figure 7.4: Swagger.yaml preview'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：Swagger.yaml 预览
- en: Using the Swagger UI view, you can try out commands and execute them against
    your server environment once it’s implemented.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Swagger UI 视图，您可以在实现后尝试命令并对其服务器环境执行它们。
- en: OpenAPI Spec
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenAPI 规范
- en: 'We are using the OpenAPI spec version `openapi: 3.1.0`. The OpenAPI spec can
    document metadata about your server, various components of your API, like security
    schemes, responses, data schemas, and input parameters, and finally, the paths
    that define your HTTP endpoints.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用 OpenAPI 规范版本 `openapi: 3.1.0`。OpenAPI 规范可以记录关于您的服务器、API 的各种组件（如安全方案、响应、数据模式、输入参数）以及定义您的
    HTTP 端点的路径的元数据。'
- en: 'Let’s go over the major components of the `swagger.yaml` file located under
    the `server` folder:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下位于 `server` 文件夹下的 `swagger.yaml` 文件的主要组件：
- en: 'The YAML file starts with general information and target servers:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: YAML 文件以一般信息和目标服务器开始：
- en: '[PRE13]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Under `components`, we define common `securitySchemes` and responses, which
    define the authentication scheme we intend to implement and how the shape of our
    error message response will appear:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `components` 下，我们定义常见的 `securitySchemes` 和响应，这些定义了我们打算实施的认证方案以及我们的错误消息响应的外观：
- en: '[PRE14]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note the usage of `$ref` to reuse repeating elements. You can see `ServerMessage`
    being defined here.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `$ref` 的使用，它可以重复使用重复的元素。您可以看到在这里定义了 `ServerMessage`。
- en: 'Under `components`, we define shared data `schemas`, which declare the data
    entities that we either take in as input or return to the client:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `components` 下，我们定义共享的数据 `schemas`，这些声明了我们作为输入接受的或返回给客户端的数据实体：
- en: '[PRE15]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Under `components`, we define shared `parameters`, making it easy to reuse
    common patterns such as paginated endpoints:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `components` 下，我们定义共享的 `parameters`，这使得重用如分页端点等常见模式变得容易：
- en: '[PRE16]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Under `paths`, we define REST endpoints, such as a `post` endpoint for the
    `/login` path:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `paths` 下，我们定义 REST 端点，例如 `/login` 路径的 `post` 端点：
- en: '[PRE17]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that `requestBody` defines input variables that are required with a type
    of `string`. Under `responses`, we can define how a successful `200` response
    and an unsuccessful `401` response to a request appear. In the former case, we
    return an `accessToken`, while in the latter case, we return an `UnauthorizedError`,
    as defined in *step 2*.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `requestBody` 定义了类型为 `string` 的必需输入变量。在 `responses` 下，我们可以定义对请求的 `200` 成功响应和
    `401` 不成功响应的外观。在前者的情况下，我们返回 `accessToken`，而在后者的情况下，我们返回在 *步骤 2* 中定义的 `UnauthorizedError`。
- en: 'Under `paths`, we define the remaining paths:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `paths` 下，我们定义剩余的路径：
- en: '[PRE18]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The OpenAPI spec is powerful, allowing you to define intricate requirements
    on how users should be able to interact with your API. The OpenAPI spec can be
    found at [https://spec.openapis.org/oas/latest.html](https://spec.openapis.org/oas/latest.html).
    It is an invaluable resource while developing your own API definition.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 规范功能强大，允许您定义复杂的用户如何与您的 API 交互的要求。OpenAPI 规范可在 [https://spec.openapis.org/oas/latest.html](https://spec.openapis.org/oas/latest.html)
    找到。在开发自己的 API 定义时，这是一个无价的资源。
- en: Our overarching goal is to integrate this interactive documentation with our
    Express.js APIs. Now, let’s see how you can implement such an API.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的总体目标是集成此交互式文档与我们的 Express.js API。现在，让我们看看您如何实现这样的 API。
- en: OpenAPI spec with Express
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenAPI 规范与 Express
- en: Configuring Swagger with Express is a manual process. But this is a good thing.
    Forcing yourself to manually document endpoints has a positive side effect. By
    slowing down, you will get the opportunity to consider your implementation from
    the perspective of the consumer of the API. This perspective will help you resolve
    potential issues with your endpoints during development, avoiding annoying, if
    not costly, rework.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Express 配置 Swagger 是一个手动过程。但这是一件好事。强迫自己手动记录端点有积极的影响。通过放慢速度，你将有机会从 API 消费者的角度考虑你的实现。这种视角将帮助你解决开发过程中端点可能存在的潜在问题，避免令人烦恼的，如果不是昂贵的，返工。
- en: 'Let’s look at an example of how you can directly embed the OpenAPI spec alongside
    your code in chunks:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将 OpenAPI 规范直接嵌入到代码中的示例：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, we use the `JSDoc` documentation syntax that starts with `/**`
    and then define the relevant part of the OpenAPI spec right after the `@openapi`
    identifier. We can still reference components defined elsewhere, as shown with
    the `$ref` statements to the `User` and `UnauthorizedError` objects.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用以 `/**` 开头的 `JSDoc` 文档语法，然后在 `@openapi` 标识符之后直接定义 OpenAPI 规范的相关部分。我们仍然可以引用其他地方定义的组件，如通过
    `$ref` 语句引用 `User` 和 `UnauthorizedError` 对象所示。
- en: The major benefit of integrating the spec alongside your code is that the developer
    knows exactly how the server should respond to a `/me GET` request. If a user
    exists, we respond with a `User` object; if not, we throw a `401` error that adheres
    to the shape of the `UnauthorizedError` object. Using some automated tools, we
    can still generate the same interactive Swagger UI covered earlier, so testers
    and developers can discover or test the API directly from a web interface.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将规范集成到代码旁边的最大好处是，开发者确切地知道服务器应该如何响应 `/me GET` 请求。如果存在用户，我们返回一个 `User` 对象；如果没有，我们抛出一个符合
    `UnauthorizedError` 对象形状的 `401` 错误。使用一些自动化工具，我们仍然可以生成之前提到的相同的交互式 Swagger UI，因此测试人员和开发者可以直接从
    Web 界面发现或测试 API。
- en: As the API implementation evolves, this setup makes it easy for developers to
    keep the spec up to date. By making it easy, we incentivize everyone involved
    with the desire to keep Swagger UI working because all team members benefit from
    it. By creating a virtuous cycle, we achieve the ideal of **living documentation**.
    Normally, initial designs become useless as they grow stale, but instead, we can
    have an automated and interactive solution that delivers ongoing value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 API 实现的演变，这种设置使开发者能够轻松地保持规范更新。通过使其变得容易，我们激励所有相关人员都有保持 Swagger UI 运作的动力，因为所有团队成员都从中受益。通过创建一个良性循环，我们实现了**活文档**的理想。通常，随着其变得过时，初始设计变得无用，但相反，我们可以有一个自动化和交互式的解决方案，提供持续的价值。
- en: 'We are going to use two helper libraries to help us integrate the inline spec
    into the codebase:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个辅助库来帮助我们集成内联规范到代码库中：
- en: '`swagger-jsdoc`: This allows us to implement OpenAPI specs right on top of
    the relevant code by using the `@openapi` identifier in a `JSDoc` comment block,
    generating a `swagger.json` file as output.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swagger-jsdoc`：这允许我们通过在 `JSDoc` 注释块中使用 `@openapi` 标识符，在相关代码上方实现 OpenAPI 规范，输出一个
    `swagger.json` 文件。'
- en: '`swagger-ui-express`: This consumes the `swagger.json` file to display the
    interactive Swagger UI web interface.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swagger-ui-express`：这个库消耗 `swagger.json` 文件以显示交互式的 Swagger UI Web 界面。'
- en: 'Let’s explore how Swagger is configured to work with Express.js:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 Swagger 如何配置与 Express.js 一起工作：
- en: 'The dependencies and type information for TypeScript are shown here:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TypeScript 的依赖和类型信息如下所示：
- en: '[PRE20]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s explore the `docs-config.ts` file, which configures the base OpenAPI
    definition:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们探索 `docs-config.ts` 文件，它配置了基本的 OpenAPI 定义：
- en: '[PRE21]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Modify the `servers` property to include the location of your testing, staging,
    or production environments. This allows consumers of your API to test the API
    using the web interface without additional tooling. Note that the `apis` property
    informs the code files that `swaggerJsdoc` should parse when constructing the
    `swagger.json` file. This routine runs during the bootstrapping of the server,
    which is why we reference the transpiled `.js` files instead of `.ts` files.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修改 `servers` 属性以包含你的测试、预发布或生产环境的位置。这允许 API 的消费者使用 Web 界面测试 API，而无需额外的工具。请注意，`apis`
    属性通知代码文件 `swaggerJsdoc` 在构建 `swagger.json` 文件时应解析的文件。这个程序在服务器引导过程中运行，这就是为什么我们引用了转译的
    `.js` 文件而不是 `.ts` 文件。
- en: 'Bootstrap the `swagger` config in `app.ts`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.ts` 中引导 `swagger` 配置：
- en: '[PRE22]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Specs contain the content of the `swagger.json` file, which is then passed to
    `swaggerUi`. Then, using the `server` middleware, we can configure `swaggerUi`
    to host the web interface at `/api-docs`. We can also serve the JSON file from
    an endpoint to consume it in another tool, at `/swagger`, as shown above.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 规范包含`swagger.json`文件的内容，然后传递给`swaggerUi`。然后，使用`server`中间件，我们可以配置`swaggerUi`在`/api-docs`上托管Web界面。我们还可以从端点提供JSON文件，以便在其他工具中使用，如上所示。
- en: Even after integrating the spec file alongside the code, developers must manually
    ensure that the spec and the code match. This process can be automated, including
    generating TypeScript-based API handlers to prevent coding mistakes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在将规范文件与代码集成之后，开发者也必须手动确保规范和代码的一致性。这个过程可以自动化，包括生成基于TypeScript的API处理程序以防止编码错误。
- en: A community-driven list of high-quality and modern tools for OpenAPI can be
    found at [https://openapi.tools/](https://openapi.tools/).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://openapi.tools/](https://openapi.tools/)找到由社区驱动的OpenAPI高质量和现代工具列表。
- en: Now that you understand how we can design a REST API and create living documentation
    around it, it’s time to learn about GraphQL, which bakes these ideas into its
    core design.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了我们如何设计REST API并在其周围创建活文档，现在是时候学习GraphQL了，它将这些想法融入其核心设计。
- en: GraphQL APIs
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL API
- en: '**GraphQL** (**Graph Query Language**), invented at Facebook, is a modern query
    language for APIs that offers a more flexible, robust, and efficient alternative
    to the traditional REST API. In GraphQL, instead of HTTP verbs, you write a query
    to GET data, a mutation to POST, PUT, or DELETE data, and subscriptions to push
    data in the style of WebSockets. Unlike REST, which exposes a fixed set of endpoints
    for each resource, GraphQL allows clients to request exactly the data they need,
    no more and no less. This means clients can shape the responses according to their
    requirements, leading to fewer over-fetching and under-fetching issues. We no
    longer need to design the perfect API surface to get optimal results.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**GraphQL**（**图查询语言**），由Facebook发明，是一种现代的API查询语言，它提供了一种比传统REST API更灵活、更健壮、更高效的替代方案。在GraphQL中，你不需要使用HTTP动词，而是编写一个查询来获取数据，一个突变来POST、PUT或DELETE数据，以及订阅以WebSocket风格推送数据。与REST不同，REST为每个资源暴露一组固定的端点，而GraphQL允许客户端请求他们确切需要的数据，不多也不少。这意味着客户端可以根据他们的需求来塑造响应，从而减少过度获取和不足获取的问题。我们不再需要设计完美的API表面来获得最佳结果。'
- en: In the realm of full-stack development, as touched upon in the *Designing APIs*
    section, the importance of designing around major data entities cannot be overstated.
    GraphQL shines in this aspect. Its type system ensures the API shapes around these
    major data entities, providing a clear contract between the frontend and backend
    teams. This type system, defined in the GraphQL schema, acts as the contract,
    specifying the data types that can be fetched and the set of operations available.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在全栈开发领域，正如在*设计API*部分中提到的，围绕主要数据实体进行设计的重要性不容忽视。GraphQL在这方面表现出色。其类型系统确保API围绕这些主要数据实体进行塑造，为前端和后端团队提供了一个清晰的合同。这个类型系统，定义在GraphQL模式中，作为合同，指定可以获取的数据类型和可用的操作集。
- en: For frontend developers, diving into a GraphQL API can be a refreshing experience.
    The introspective nature of GraphQL means that the schema can be queried for details
    about itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前端开发者来说，深入探索GraphQL API可以是一种令人耳目一新的体验。GraphQL的反思性意味着可以查询其自身的模式以获取详细信息。
- en: This self-documenting feature ensures that developers always have an up-to-date
    reference, eliminating the need for separate, manually maintained documentation.
    This is especially beneficial for agile teams in enterprise settings where waiting
    for documentation isn’t always feasible.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自文档特性确保开发者始终拥有最新的参考，消除了需要单独手动维护文档的需求。这对于企业环境中的敏捷团队特别有益，在这些环境中，等待文档并不总是可行的。
- en: Enter the GraphQL Playground or GraphiQL interactive environments, where developers
    can test and explore GraphQL queries in real time. Much like Swagger UI for OpenAPI,
    these tools provide immediate feedback, allowing developers to understand the
    structure, types, and operations of the API. This hands-on approach reduces the
    learning curve and fosters a deeper understanding of the API’s capabilities.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 进入GraphQL Playground或GraphiQL交互式环境，开发者可以实时测试和探索GraphQL查询。这些工具与OpenAPI的Swagger
    UI类似，提供即时反馈，使开发者能够理解API的结构、类型和操作。这种动手方法降低了学习曲线，并促进了开发者对API功能的更深入理解。
- en: Next, let’s explore how to design GraphQL APIs around major data entities, ensuring
    that they align with the principles laid out in our Router-first architecture
    and other best practices.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索如何围绕主要数据实体设计 GraphQL API，确保它们与我们在 Router-first 架构和其他最佳实践中概述的原则保持一致。
- en: GraphQL schema
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphQL 模式
- en: The GraphQL schema is at the heart of any GraphQL API, acting as the contract
    between the client and the server. It describes the structure and capabilities
    of the API by defining types and the relationships between the types. These types
    model the major data entities that the API operates on.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 模式是任何 GraphQL API 的核心，作为客户端和服务器之间的合约。它通过定义类型和类型之间的关系来描述 API 的结构和能力。这些类型模拟了
    API 操作的主要数据实体。
- en: 'Let’s begin by exploring the `graphql.schema` file located under `server/graphql`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索位于 `server/graphql` 下的 `graphql.schema` 文件开始：
- en: 'Using the `type` keyword, we can define data objects:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `type` 关键字，我们可以定义数据对象：
- en: '[PRE23]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This `User` type has scalar fields like the `id` and `email` fields, representing
    primitive value types like `ID`, `String`, `Int`, `Float`, and `Boolean`. The
    bang symbol `!` indicates these fields are required. We can also define relationships
    between types, such as `Name` or `Phone`. The square brackets `[]` indicate that
    `phones` is an array of `Phone` objects.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 `User` 类型具有标量字段，如 `id` 和 `email` 字段，代表原始值类型如 `ID`、`String`、`Int`、`Float`
    和 `Boolean`。感叹号 `!` 表示这些字段是必需的。我们还可以定义类型之间的关系，例如 `Name` 或 `Phone`。方括号 `[]` 表示
    `phones` 是 `Phone` 对象的数组。
- en: 'We can also define enums and use them like a scalar type:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以定义枚举并像标量类型一样使用它们：
- en: '[PRE24]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using the reserved type `Query`, we can define how data can be retrieved:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用保留类型 `Query`，我们可以定义如何检索数据：
- en: '[PRE25]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can define acceptable arguments and the return type.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以定义可接受的参数和返回类型。
- en: 'Using the reserved type `Mutation`, we can define how the state can be modified:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用保留类型 `Mutation`，我们可以定义如何修改状态：
- en: '[PRE26]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can define a login or a `createUser` method. Note that `createUser` takes
    an input object, which is required if we want to pass a whole object as an argument.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以定义一个登录或 `createUser` 方法。注意，`createUser` 接受一个输入对象，如果我们想传递整个对象作为参数，则该对象是必需的。
- en: 'Input objects are declared with the `input` keyword:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入对象使用 `input` 关键字声明：
- en: '[PRE27]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that any related object must also use the input declaration. Output types
    and input data can’t be mixed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何相关对象也必须使用输入声明。输出类型和输入数据不能混合。
- en: 'As you may have noticed, we can also add descriptions to document our API using
    the # symbol or, optionally, the triple quote `"""` syntax.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '如您可能已经注意到的，我们还可以使用 # 符号或可选的三重引号 `"""` 语法添加描述来记录我们的 API。'
- en: The schema is defined using the GraphQL **Schema Definition Language** (**SDL**).
    You can access the SDL specification at [https://graphql.org/](https://graphql.org/).
    It’s an essential resource for anyone crafting a well-defined GraphQL API.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 模式使用 GraphQL **模式定义语言**（**SDL**）定义。您可以在 [https://graphql.org/](https://graphql.org/)
    访问 SDL 规范。它是任何构建良好定义的 GraphQL API 的人的必备资源。
- en: Overall, the schema provides a strict contract between the client and the server.
    It makes explicit the data shapes and capabilities available. Frontend and backend
    teams can build features in parallel against this contract, and tooling like GraphQL
    Playground makes the schema interactive.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，该模式在客户端和服务器之间提供了一个严格的合约。它明确提供了可用的数据形状和能力。前端和后端团队可以针对此合约并行构建功能，并且像 GraphQL
    Playground 这样的工具使得模式交互式。
- en: We will use the Apollo GraphQL library to help construct the schema programmatically
    in our Express server.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Apollo GraphQL 库来帮助在我们的 Express 服务器中以编程方式构建模式。
- en: Apollo with Express
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apollo 与 Express
- en: 'Apollo GraphQL is a comprehensive and widely adopted suite of tools and services
    designed to help developers build, manage, and scale GraphQL applications with
    ease. Developed by the Meteor Development Group, Apollo has become synonymous
    with GraphQL development for many developers, due to its robust features and developer-friendly
    approach. Here’s a breakdown of Apollo GraphQL:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo GraphQL 是一套全面且广泛采用的工具和服务套件，旨在帮助开发者轻松构建、管理和扩展 GraphQL 应用程序。由 Meteor 开发组开发，Apollo
    由于其强大的功能和开发者友好的方法，已成为许多开发者进行 GraphQL 开发的同义词。以下是 Apollo GraphQL 的概述：
- en: '**Apollo Client**: A state-of-the-art GraphQL client that manages local and
    remote data. It integrates seamlessly with any JavaScript frontend framework,
    such as React, Vue, or Angular. Apollo Client provides features like caching,
    optimistic UI updates, and real-time subscriptions, making it easier to fetch,
    cache, and modify application data.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apollo Client**：一个先进的 GraphQL 客户端，用于管理本地和远程数据。它可以无缝集成到任何 JavaScript 前端框架中，如
    React、Vue 或 Angular。Apollo Client 提供了缓存、乐观 UI 更新和实时订阅等功能，使得获取、缓存和修改应用程序数据变得更加容易。'
- en: '**Apollo Server**: A community-driven, open-source GraphQL server that works
    with any GraphQL schema. Apollo Server provides performance tracing and error
    tracking and supports schema stitching, allowing for the merging of multiple GraphQL
    APIs into one unified API.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apollo Server**：一个由社区驱动的开源 GraphQL 服务器，可以与任何 GraphQL 模式一起工作。Apollo Server
    提供性能跟踪和错误跟踪，并支持模式拼接，允许将多个 GraphQL API 合并成一个统一的 API。'
- en: '**Apollo Client Developer Tools**: Browser extensions offering rich in-browser
    development experience. Developers can view their GraphQL store, inspect active
    queries, and interact with their GraphQL server using the built-in GraphiQL IDE.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apollo Client 开发者工具**：提供丰富的浏览器内开发体验的浏览器扩展。开发者可以查看他们的 GraphQL 存储，检查活动查询，并使用内置的
    GraphiQL IDE 与他们的 GraphQL 服务器进行交互。'
- en: Apollo provides more advanced dev tools with Apollo Studio as part of its cloud
    offering. Apollo Federation allows organizations to divide their monolithic GraphQL
    API into smaller, more maintainable microservices. It provides a means to compose
    multiple GraphQL services into a single data graph. Apollo Link allows developers
    to create chainable “links” to handle tasks like logging, request retries, and
    even offline caching.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo 作为其云服务的一部分提供了更高级的开发工具，即 Apollo Studio。Apollo Federation 允许组织将他们的单体 GraphQL
    API 划分为更小、更易于维护的微服务。它提供了一种将多个 GraphQL 服务组合成单个数据图的方法。Apollo Link 允许开发者创建可链式的“链接”来处理日志记录、请求重试甚至离线缓存等任务。
- en: In essence, Apollo GraphQL provides a holistic approach to GraphQL development,
    offering tools and services catering to beginners and advanced users. Whether
    you’re building a small application or scaling a large enterprise system, Apollo’s
    tools ensure great DevEx.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Apollo GraphQL 提供了一种全面的 GraphQL 开发方法，为初学者和高级用户提供工具和服务。无论您是构建小型应用程序还是扩展大型企业系统，Apollo
    的工具都能确保出色的开发体验。
- en: The GraphQL schema and the GraphQL library are inseparable, so we don’t have
    to take extra steps to configure the schema definition to work with the codebase,
    as we did with OpenAPI.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 模式和 GraphQL 库是不可分割的，因此我们不需要采取额外步骤来配置模式定义以与代码库一起工作，就像我们与 OpenAPI 一起做的那样。
- en: To generate types from a GraphQL schema, follow the guidance provided at [https://www.apollographql.com/docs/apollo-server/workflow/generate-types/](https://www.apollographql.com/docs/apollo-server/workflow/generate-types/).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 GraphQL 模式生成类型，请遵循 [https://www.apollographql.com/docs/apollo-server/workflow/generate-types/](https://www.apollographql.com/docs/apollo-server/workflow/generate-types/)
    提供的指南。
- en: 'Next, let’s see how you can configure your schema and Apollo with Express.js:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用 Express.js 配置您的模式和 Apollo：
- en: 'Install the Apollo server:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Apollo 服务器：
- en: '[PRE28]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Open the `api.graphql.ts` file, which configures the Apollo server:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `api.graphql.ts` 文件，该文件配置了 Apollo 服务器：
- en: '[PRE29]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using `node:fs`, we read the schema file into the `typeDefs` object and pass
    it into a new `ApolloServer` instance along with a reference to the resolvers.
    Finally, we call `server.start()` and export the `useGraphQL` function.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `node:fs`，我们将模式文件读取到 `typeDefs` 对象中，并将其传递给一个新的 `ApolloServer` 实例，同时传递一个对解析器的引用。最后，我们调用
    `server.start()` 并导出 `useGraphQL` 函数。
- en: 'Bootstrap the Apollo server in `index.ts`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `index.ts` 中启动 Apollo 服务器：
- en: '[PRE30]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In `index.ts`, right after we create an instance of the Express server, which
    is defined by the app variable, we call the `useGraphQL` function to start it
    up. This configuration allows us to implement REST and GraphQL APIs side by side.
    GraphQL APIs and the interactive Explorer tools can be accessed at `/graphql`,
    as shown below:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.ts` 中，在我们创建由 app 变量定义的 Express 服务器实例之后，我们调用 `useGraphQL` 函数来启动它。这种配置允许我们同时实现
    REST 和 GraphQL API。如以下所示，GraphQL API 和交互式探索工具可以通过 `/graphql` 访问：
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_07_05.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述自动生成](img/B20960_07_05.png)'
- en: 'Figure 7.5: GraphQL Explorer'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：GraphQL 探索器
- en: Now that you understand the differences between REST and GraphQL APIs and how
    we can configure them equivalently with Express.js, let’s take a look at the overall
    architecture of the server.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了 REST 和 GraphQL API 之间的区别以及我们如何使用 Express.js 等效地配置它们，让我们看一下服务器的整体架构。
- en: Implementing APIs with Express.js
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Express.js 实现API
- en: Let’s go over the architecture and file structure of our backend so that we
    get an understanding of how the server is bootstrapped, how routing is configured
    for API endpoints, how public resources are served, and how services are configured.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们后端的结构和文件结构，以便我们了解服务器是如何启动的，API 端点的路由是如何配置的，公共资源是如何提供的，以及服务是如何配置的。
- en: 'Review the file structure of our Express server:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的 Express 服务器文件结构：
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we’ll review the purpose and the interaction between these files by looking
    at a component diagram, giving us an overview of the architecture and the dependency
    tree:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过查看组件图来回顾这些文件的目的和交互，从而获得架构和依赖树的概览：
- en: '![](img/B20960_07_06.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_07_06.png)'
- en: 'Figure 7.6: Express server architecture'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：Express服务器架构
- en: '`index.ts` contains a `start` function, which bootstraps the application, leveraging
    four major helpers:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.ts` 包含一个 `start` 函数，该函数启动应用程序，利用四个主要助手：'
- en: '`config.ts`: Manages environment variables and settings.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.ts`：管理环境变量和设置。'
- en: '`app.ts`: Configures Express.js and defines all API paths, and then routers
    implement the paths and leverage services that contain the business logic. Services
    use models, such as `user.ts`, to access the database.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.ts`：配置 Express.js 并定义所有 API 路径，然后路由实现路径并利用包含业务逻辑的服务。服务使用模型，如 `user.ts`，来访问数据库。'
- en: '`api.graphql.ts`: Configures GraphQL, resolvers implement queries, and mutators
    leverage the same services and then resolvers implement queries and mutators and
    leverage the same services to access the database.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api.graphql.ts`：配置 GraphQL，解析器实现查询，并使用相同的解析器和突变器利用相同的服务来访问数据库。'
- en: '`document-ts`: Establishes a connection to the database, configures it, and
    leverages `user.ts` to configure a seed user during startup.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document-ts`：建立与数据库的连接，配置它，并在启动期间利用 `user.ts` 配置种子用户。'
- en: You can see that the components at the top of the diagram are responsible for
    startup and configuration chores, including configuring API paths, which represent
    the **API** layer. The **Business** layer should contain most of the business
    logic for the app, while data access is handled in the **Persistence** layer.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，图顶部的组件负责启动和配置任务，包括配置 API 路径，这代表了 **API** 层。**业务**层应该包含应用程序的大部分业务逻辑，而数据访问则在
    **持久层** 处理。
- en: 'Refer to the following implementation of `index.ts`, which shows a simplified
    version showing all major components in sequence:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下 `index.ts` 的实现，它展示了所有主要组件按顺序的简化版本：
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that the last line of code shown, `start()`, is the function call that
    triggers the server’s initialization.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，显示的最后一行代码 `start()` 是触发服务器初始化的功能调用。
- en: Now, let’s investigate how the Express server is set up.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来调查一下 Express 服务器是如何设置的。
- en: Bootstrapping the server
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器启动
- en: '`app.ts` configures Express.js, along with serving static assets, routing,
    and versioning. Express.js leverages middleware functions to integrate with libraries
    or your code. Middleware are functions that execute during the lifecycle of a
    request to the Express server. Middleware functions have access to the request
    and response objects and the following middleware function in the application’s
    request-response cycle. This access allows them to execute any code, make changes,
    end the request-response cycle, and call the next middleware in the stack. In
    the code below, cors, logger, and compression are library functions, and later
    in the chapter, we will go over the implementation of a custom authenticate middleware:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.ts` 配置 Express.js，包括提供静态资源、路由和版本控制。Express.js 利用中间件函数与库或您的代码集成。中间件是在对
    Express 服务器请求的生命周期中执行的函数。中间件函数可以访问请求和响应对象以及应用程序请求-响应周期中的下一个中间件函数。这种访问允许它们执行任何代码，进行更改，结束请求-响应周期，并调用堆栈中的下一个中间件。在下面的代码中，cors、logger
    和 compression 是库函数，在章节的后面，我们将介绍自定义认证中间件的实现：'
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, note that configuring Express is straightforward with
    the `use()` method. First, we configure `cors`, and then `express` parsers, `logger`,
    and `compression`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意，使用`use()`方法配置Express非常简单。首先，我们配置`cors`，然后是`express`解析器、`logger`和`compression`。
- en: Next, using the `express.static` function, we serve the `public` folder at the
    root’s route, `/`, so that we can display some useful information about our server,
    as shown in *Figure 7.1* at the beginning of this chapter.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`express.static`函数，我们在根路由`/`上提供`public`文件夹，这样我们就可以显示有关我们服务器的一些有用信息，如本章开头所示的*图7.1*。
- en: Finally, we configure the router, which is defined in `api.ts`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们配置路由器，该路由器在`api.ts`中定义。
- en: REST routes and versioning
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST路由和版本控制
- en: '`api.ts` configures the Express router. Refer to the following implementation:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`api.ts`配置Express路由器。请参考以下实现：'
- en: '[PRE34]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, we have two child routes for `v1` and `v2`. It is critical to
    always version the APIs you implement. Once an API becomes public, it can be tricky,
    even impossible sometimes, to simply phase out an API for a newer version. Even
    minor code changes or slight differences in the API can cause clients to break.
    You must pay careful attention to only making backward-compatible changes to your
    API.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有`v1`和`v2`两个子路由。始终对实现的API进行版本控制是至关重要的。一旦API公开，简单地淘汰一个API以支持新版本可能会变得很棘手，有时甚至不可能。即使是微小的代码更改或API的细微差异也可能导致客户端崩溃。你必须仔细注意，只对你的API进行向后兼容的更改。
- en: At some point, you will need to completely rewrite the endpoint to meet new
    requirements, performance, and business needs, at which point, you can simply
    implement a `v2` version of your endpoint while leaving the `v1` implementation
    unchanged. This allows you to innovate at the pace you need to while keeping legacy
    consumers of your app functional.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能需要完全重写端点以满足新的要求、性能和业务需求，此时，你可以简单地实现端点的`v2`版本，同时保持`v1`实现不变。这允许你以你需要的速度进行创新，同时保持你的应用程序的旧版消费者功能正常。
- en: In short, you should version every API you create. By doing this, you force
    your consumers to version their HTTP calls to your API. Over time, you can transition,
    duplicate, and retire APIs under different versions. Consumers then have a choice
    to call whichever version of the API works for them.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你应该为创建的每个API进行版本控制。通过这样做，你迫使你的消费者对你的API的HTTP调用进行版本控制。随着时间的推移，你可以在不同的版本下过渡、复制和退役API。消费者随后可以选择调用对他们有用的API版本。
- en: 'Configuring a route is trivial. Let’s see the configuration for `v2`, as shown:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 配置路由很简单。让我们看看`v2`的配置，如下所示：
- en: '[PRE35]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The question mark at the end of `/users?` means that both `/user` and `/users`
    will work against operations implemented in `userRouter`. This is a great way
    to avoid typos while allowing the developer to choose the plurality that makes
    sense for the operation.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`/users?`结尾的问号意味着`/user`和`/users`都将针对`userRouter`中实现的操作工作。这是一种避免拼写错误的同时允许开发者选择对操作有意义的复数形式的好方法。'
- en: 'In `userRouter`, you can implement the GET, POST, PUT, and DELETE operations.
    Refer to the following implementation:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在`userRouter`中，你可以实现GET、POST、PUT和DELETE操作。请参考以下实现：
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, you can observe the use of route parameters. You can
    consume route parameters through a request object, such as `req.params.userId`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以观察到路由参数的使用。你可以通过请求对象，如`req.params.userId`，来消费路由参数。
- en: Note that all routes in the sample code are tagged as `async` because they will
    all make a database call, which we are going to await. If your route is synchronous,
    then you don’t require the `async` keyword.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，示例代码中的所有路由都被标记为`async`，因为它们都会进行数据库调用，我们将等待这些调用。如果你的路由是同步的，那么你不需要`async`关键字。
- en: Next, let’s investigate GraphQL resolvers.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们调查GraphQL解析器。
- en: GraphQL resolvers
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL解析器
- en: GraphQL resolvers are implemented in `resolvers.ts`. The GraphQL server performs
    a breadth-first traversal of the query and recursively calls resolvers to generate
    the response.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL解析器在`resolvers.ts`中实现。GraphQL服务器对查询进行广度优先遍历，并递归调用解析器以生成响应。
- en: Let me elaborate – when a GraphQL server gets a query, it processes the request
    layer by layer, starting from the top-level fields and moving horizontally across
    the structure, like a search that moves across each level of a tree before going
    deeper, known as breadth-first traversal. For each field it encounters, the server
    invokes a specific function called a resolver, designed to fetch the data for
    that field. If a field is complex and contains nested subfields, the resolver
    for that field will, in turn, call upon other resolvers for each of these subfields.
    This process repeats itself, descending into the query’s hierarchy as needed until
    all the data for the query is retrieved and can be assembled into the structured
    response that matches the original query layout.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我详细说明一下——当一个GraphQL服务器接收到一个查询时，它会逐层处理请求，从顶层字段开始，水平地穿过结构，就像在树的每一层移动之前先进行搜索，这被称为广度优先遍历。对于它遇到的每个字段，服务器将调用一个特定的函数，称为解析器，用于获取该字段的数据。如果一个字段复杂且包含嵌套子字段，该字段的解析器将依次调用其他解析器来获取每个子字段的数据。这个过程会重复进行，根据需要进入查询的层次结构，直到检索到查询的所有数据，并将其组装成与原始查询布局相匹配的结构化响应。
- en: 'Refer to the following implementation:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下实现：
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For non-scalar types, arrays, or enums, we may need to provide a transformation
    so that GraphQL can appropriately unpack the data retrieved from the database.
    The good part is we only need to provide a resolver for specific properties of
    objects that need such manipulation.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非标量类型、数组或枚举，我们可能需要提供转换，以便GraphQL可以适当地解包从数据库检索到的数据。好处是我们只需要为需要此类操作的对象的特定属性提供解析器。
- en: Resolvers may seem simple, but they can fulfill very complex needs, e.g., a
    simple request from a client may involve making multiple service and database
    calls and collating the results into an efficient response, just so the client
    can display it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器可能看起来很简单，但它们可以满足非常复杂的需求，例如，一个简单的客户端请求可能涉及多次调用服务和数据库，并将结果汇总成一个高效的响应，以便客户端可以显示它。
- en: The atomic nature of resolvers means we only need to implement them once. Next,
    let’s explore how services are configured.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器的原子性质意味着我们只需要实现一次。接下来，让我们探索如何配置服务。
- en: Services
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: We don’t want to implement our business logic in the router files, which represent
    our API layer. The API layer should largely consist of transforming data and making
    calls to the business logic layer.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在表示我们的API层的路由器文件中实现我们的业务逻辑。API层应主要包含转换数据和调用业务逻辑层。
- en: You can implement services using Node.js and TypeScript features. No fancy dependency
    injection is necessary. The sample application implements two services – `authService`
    and `userService`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Node.js和TypeScript功能来实现服务。不需要复杂的依赖注入。示例应用程序实现了两个服务 - `authService`和`userService`。
- en: 'For example, in `userService.ts`, you can implement a function called `createNewUser`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`userService.ts`中，您可以实现一个名为`createNewUser`的函数：
- en: '[PRE39]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`createNewUser` accepts `userData` in the shape of `IUser`, and when it is
    done creating the user, it returns an instance of `User`. We can then use this
    function in our router as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`createNewUser`接受`userData`，其形状为`IUser`，当它完成用户创建后，返回一个`User`实例。然后我们可以在我们的路由器中如下使用此函数：'
- en: '[PRE40]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can await the result of `createNewUser` and, if successful, return the created
    object as a response to the POST request.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以等待`createNewUser`的结果，如果成功，将创建的对象作为对POST请求的响应返回。
- en: Note that even though we cast `req.body` as `IUser`, this is only a development
    time comfort feature. At runtime, the consumer may pass any number of properties
    to the body. Careless handling of request parameters is one of the primary ways
    your code can be maliciously exploited.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们将`req.body`转换为`IUser`，但这只是一个开发时的便利功能。在运行时，消费者可能将任意数量的属性传递到主体中。粗心处理请求参数是您的代码可能被恶意利用的主要方式之一。
- en: Congratulations! Now, you have a good understanding of how our Express server
    works. Next, let’s look at how to connect to MongoDB.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在，您已经很好地理解了我们的Express服务器是如何工作的。接下来，让我们看看如何连接到MongoDB。
- en: MongoDB ODM with DocumentTS
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB ODM with DocumentTS
- en: DocumentTS acts as an **ODM**, implementing a layer of models to enable rich
    and customizable interaction with database objects. ODM is the document-based
    database equivalent of an **Object Relational Mapper** (**ORM**) in relational
    databases. Think of Hibernate or Entity Framework. If you’re not familiar with
    these concepts, I recommend that you do further research before moving on.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: DocumentTS充当一个**ODM**，实现了一层模型，以实现与数据库对象的丰富和可定制的交互。ODM是关系数据库中**对象关系映射器**（ORM）的文档数据库等价物。想想Hibernate或Entity
    Framework。如果您不熟悉这些概念，我建议您在继续之前进行进一步的研究。
- en: To get started, you can check out the following article, *MongoDB ORMs, ODMs,
    and Libraries*, at [https://www.mongodb.com/developer/products/mongodb/mongodb-orms-odms-libraries](https://www.mongodb.com/developer/products/mongodb/mongodb-orms-odms-libraries).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您可以查看以下文章，*MongoDB ORMs，ODMs和库*，在[https://www.mongodb.com/developer/products/mongodb/mongodb-orms-odms-libraries](https://www.mongodb.com/developer/products/mongodb/mongodb-orms-odms-libraries)。
- en: 'At its core, DocumentTS leverages the Node.js driver for MongoDB. The makers
    of MongoDB implement this driver. It guarantees the best performance and feature
    parity with new MongoDB releases, whereas third-party libraries often lag in supporting
    new features. By using the `database.getDbInstance` method, you can access the
    native driver directly. Otherwise, you will access Mongo through the models that
    you implement. Refer to the following diagram for an overview:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，DocumentTS利用MongoDB的Node.js驱动程序。MongoDB的制作者实现了这个驱动程序。它保证了最佳性能和与新MongoDB版本的功能一致性，而第三方库通常在支持新功能方面落后。通过使用`database.getDbInstance`方法，您可以直接访问原生驱动程序。否则，您将通过您实现的模型访问Mongo。参考以下图表以获取概述：
- en: '![](img/B20960_07_07.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_07_07.png)'
- en: 'Figure 7.7: DocumentTS overview'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：DocumentTS概述
- en: You can read more about MongoDB’s Node.js driver at [https://mongodb.github.io/node-mongodb-native/](https://mongodb.github.io/node-mongodb-native/).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://mongodb.github.io/node-mongodb-native/](https://mongodb.github.io/node-mongodb-native/)上了解更多关于MongoDB的Node.js驱动程序的信息。
- en: For more details on how DocumentTS works and the configuration details, refer
    to the project wiki on GitHub at [https://github.com/duluca/document-ts/wiki](https://github.com/duluca/document-ts/wiki).
    The wiki covers connecting to the database, defining models that implement `IDocument`,
    and configuring serialization and deserialization of data. Models allow calculated
    properties like `fullName` to be included in client responses while excluding
    fields like passwords. Passwords are also prevented from being saved to the database
    in clear text.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 有关DocumentTS的工作方式和配置细节的更多详细信息，请参阅GitHub上的项目Wiki [https://github.com/duluca/document-ts/wiki](https://github.com/duluca/document-ts/wiki)。Wiki涵盖了连接到数据库、定义实现`IDocument`的模型以及配置数据的序列化和反序列化。模型允许包含计算属性，如`fullName`，在客户端响应中，同时排除如密码等字段。密码也被防止以明文形式保存到数据库中。
- en: The overview continues by demonstrating how to create indexes and query the
    database with aggregation. It creates a unique index on email, so duplicate emails
    cannot be registered. A weighted text index assists in filtering query results.
    DocumentTS aims to provide a convenient yet optional layer on top of the native
    MongoDB driver to help build fully async web applications. Developers are directly
    exposed to the MongoDB driver, so they learn how to work with the database instead
    of just the library.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 概述继续通过演示如何创建索引和使用聚合查询数据库。它为电子邮件创建了一个唯一索引，因此不能注册重复的电子邮件。一个加权文本索引有助于过滤查询结果。DocumentTS旨在在原生MongoDB驱动程序之上提供一个方便且可选的层，以帮助构建完全异步的Web应用程序。开发者直接接触到MongoDB驱动程序，因此他们学习如何与数据库而不是仅仅与库一起工作。
- en: Let’s see how you can fetch data using the new user model.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用新的用户模型来获取数据。
- en: Implementing JWT auth
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现JWT认证
- en: In *Chapter 5*, *Designing Authentication and Authorization*, we discussed implementing
    a JWT-based authentication mechanism. In LemonMart, you implemented a base auth
    service that can be extended for custom authentication services.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5章*，*设计认证和授权*中，我们讨论了实现基于JWT的认证机制。在LemonMart中，您实现了一个基础认证服务，它可以扩展为自定义认证服务。
- en: 'We’ll leverage three packages for our implementation:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用三个包来实现我们的实现：
- en: '`jsonwebtoken`: Used to create and encode JWTs'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonwebtoken`: 用于创建和编码JWT'
- en: '`bcryptjs`: Used to hash and salt a user’s password before saving it in the
    database, so we never store a user’s password in plain text'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bcryptjs`: 用于在数据库中保存用户密码之前对其进行哈希和加盐，因此我们永远不会以明文形式存储用户的密码'
- en: '`uuid`: A generated universally unique identifier that is useful when resetting
    a user’s password to a random value'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uuid`：一个生成的全局唯一标识符，当需要将用户的密码重置为随机值时非常有用'
- en: A hash function is a consistently repeatable, one-way encryption method, which
    means you get the same output every time you provide the same input, but even
    if you have access to the hashed value, you cannot readily figure out what information
    it stores. We can, however, compare whether the user has entered the correct password
    by hashing the user’s input and comparing the hash of their input to that of the
    stored hash of their password.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 散列函数是一种一致可重复的单向加密方法，这意味着每次提供相同的输入时都会得到相同的输出，即使您有权访问散列值，也无法轻易地找出它存储的信息。然而，我们可以通过散列用户的输入并将其与存储的密码散列值进行比较，来验证用户是否输入了正确的密码。
- en: The auth service hashes user passwords before storing them and compares hashed
    passwords on login. The `createJwt` function generates a JWT access token upon
    successful login. The authenticate middleware decodes the JWT and loads the user
    into the response stream for authenticated endpoints.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 认证服务在存储用户密码之前对其进行散列，并在登录时比较散列密码。`createJwt`函数在成功登录后生成JWT访问令牌。认证中间件解码JWT并将用户加载到响应流中，以便认证端点可以访问。
- en: Note the vagueness of the incorrect email/password messages in the code. This
    is done so that bad actors cannot fish the system to exploit the authentication
    system.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码中不正确的电子邮件/密码消息的模糊性。这样做是为了防止恶意行为者利用认证系统。
- en: For password hashing, the `User` model’s `setPassword` method uses bcrypt’s
    `genSalt` and `hash` functions. The `comparePassword` method compares the hashed
    stored password with the hashed user input. This ensures passwords are never stored
    in plain text.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于密码散列，`User`模型的`setPassword`方法使用bcrypt的`genSalt`和`hash`函数。`comparePassword`方法将存储的散列密码与用户输入的散列密码进行比较。这确保密码永远不会以纯文本形式存储。
- en: 'The login API endpoint finds the user by email, calls `comparePassword` to
    validate the password, and, on success, calls `createJwt` to generate a signed
    JWT with user details like email, role, etc. The JWT is returned to the client
    as the `accessToken`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 登录API端点通过电子邮件查找用户，调用`comparePassword`来验证密码，成功后调用`createJwt`生成包含电子邮件、角色等用户详情的已签名JWT，并将JWT作为`accessToken`返回给客户端：
- en: '[PRE41]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The authenticate middleware decodes the JWT, finds the user by the encoded
    `id`, and injects the user into `res.locals.currentUser`. Authenticated endpoints
    like `/me` can conveniently access the user’s info. It also handles role-based
    access by checking options like `requiredRole`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 认证中间件解码JWT，通过编码的`id`查找用户，并将用户注入到`res.locals.currentUser`中。像`/me`这样的认证端点可以方便地访问用户信息。它还通过检查如`requiredRole`之类的选项来处理基于角色的访问：
- en: '[PRE42]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When retrieving a user by email, remember that emails are case-insensitive,
    so you should always convert the input to lowercase. You can improve this implementation
    further by validating the email and stripping any white space, script tags, or
    even rogue Unicode characters. Consider using libraries such as `express-validator`
    or `express-sanitizer`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过电子邮件检索用户时，请记住电子邮件是不区分大小写的，因此您应该始终将输入转换为小写。您可以通过验证电子邮件并删除任何空白、脚本标签或甚至恶意Unicode字符来进一步改进此实现。考虑使用`express-validator`或`express-sanitizer`等库。
- en: Authenticating middleware
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证中间件
- en: The `authenticate` function is a middleware we can use in our API implementations
    to ensure that only authenticated users with appropriate permissions can access
    an endpoint. Remember that real security is achieved in your backend implementation,
    and this `authenticate` function is your gatekeeper.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate`函数是我们可以在API实现中使用的中间件，以确保只有具有适当权限的认证用户可以访问端点。请记住，真正的安全性是在您的后端实现中实现的，而这个`authenticate`函数是您的守门人。'
- en: '`authenticate` takes a nullable `options` object to verify the current user’s
    role with the `requiredRole` property, so if an API is configured as shown below,
    only a manager can access that API:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate`接受一个可空的`options`对象，使用`requiredRole`属性验证当前用户的角色，因此如果API配置如下，则只有经理可以访问该API：'
- en: '[PRE43]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In certain cases, we want a user to be able to update their own records but
    also allow managers to update everyone else’s records. In this case, we leverage
    the `permitIfSelf` property, as shown here:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望用户能够更新自己的记录，同时也允许经理更新其他所有人的记录。在这种情况下，我们利用`permitIfSelf`属性，如下所示：
- en: '[PRE44]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, if the `_id` of the updated record matches the current user’s
    `_id`, then the user can update their own record. Since `requiredRoleCanOverride`
    is set to `true`, a manager can update any record. If it were set to `false`,
    this wouldn’t be allowed. By mixing and matching these properties, you can cover
    a vast majority of your gatekeeping needs.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果更新记录的 `_id` 与当前用户 `_id` 匹配，则用户可以更新自己的记录。由于 `requiredRoleCanOverride`
    设置为 `true`，经理可以更新任何记录。如果设置为 `false`，则不允许这样做。通过混合和匹配这些属性，你可以覆盖大多数门控需求。
- en: Note that `idGetter` is a function delegate so that you can specify how the
    `_id` property should be accessed when the `authenticate` middleware executes.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`idGetter` 是一个函数委托，这样你就可以指定在 `authenticate` 中间件执行时 `_id` 属性应该如何访问。
- en: 'See the following example implementation of a simplified `authenticate` middleware
    and its usage:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下简化版 `authenticate` 中间件及其使用的示例实现：
- en: The full implementation can be found at `server/src/services/auth.service.ts`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 完整实现可以在 `server/src/services/auth.service.ts` 中找到。
- en: '[PRE45]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `authenticate` method is implemented as Express.js middleware. It can read
    the request header for an authorization token, verify the validity of the JWT
    provided, load the current user, and inject it into the response stream, so an
    authenticated API endpoint can conveniently access the current user’s information.
    This is shown by the `me` API above. If successful, the middleware calls the `next()`
    function to yield control back to Express. If unsuccessful, then the API can’t
    be called.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate` 方法作为 Express.js 中间件实现。它可以读取请求头中的授权令牌，验证提供的 JWT 的有效性，加载当前用户，并将其注入到响应流中，以便认证的
    API 端点可以方便地访问当前用户的信息。这在上面的 `me` API 中显示。如果成功，中间件调用 `next()` 函数将控制权交还给 Express。如果失败，则无法调用
    API。'
- en: Note that `authenticateHelper` returns useful error messages, so users aren’t
    confused if they try to execute an action they’re not permitted to execute.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`authenticateHelper` 返回有用的错误消息，所以如果用户尝试执行他们无权执行的操作，他们不会感到困惑。
- en: 'In GraphQL, authentication and authorization are handled separately. At the
    Express.js level, we apply the `authenticate` middleware to the `/graphql` route.
    However, for explorer, introspection, and login functions to work, we must create
    exceptions to the rule. See the code below, which implements this logic:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 中，认证和授权是分开处理的。在 Express.js 层级上，我们将 `authenticate` 中间件应用于 `/graphql`
    路由。然而，为了使探索、内省和登录函数正常工作，我们必须对规则进行例外处理。请参阅下面的代码，它实现了这种逻辑：
- en: '[PRE46]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: See `server/src/graphql/resolvers.ts` to see the full implementation of the
    auth in action.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `server/src/graphql/resolvers.ts` 以了解认证实现的完整示例。
- en: The `authOverridingOperations` property signals to `authenticate` that it should
    permit calls for introspection and the `Login` function. All other calls to other
    GraphQL functions will now be authenticated with the authentication context available
    in resolvers. In the resolvers, we can use the `authorize` method (located at
    `server/src/graphql/helpers.ts`) to check if the requestor can see the resource
    they’re trying to access. The `contextValue` stores the session context similar
    to how `res.local` works in Express.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`authOverridingOperations` 属性通知 `authenticate` 允许调用内省和 `Login` 函数。现在对其他 GraphQL
    函数的所有调用都将使用在解析器中可用的认证上下文进行认证。在解析器中，我们可以使用 `authorize` 方法（位于 `server/src/graphql/helpers.ts`）来检查请求者是否可以查看他们试图访问的资源。`contextValue`
    存储会话上下文，类似于 Express 中的 `res.local`。'
- en: Next, let’s implement two custom auth providers, one for REST and another for
    GraphQL.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现两个自定义认证提供者，一个用于 REST，另一个用于 GraphQL。
- en: Custom server auth provider
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义服务器认证提供者
- en: 'Now that you understand the auth implementation in our server, we can implement
    a custom auth provider in LemonMart, as covered in *Chapter 6*, *Implementing
    Role-Based Navigation*:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了我们服务器中的认证实现，我们可以在 LemonMart 中实现一个自定义认证提供者，如第 6 章*实现基于角色的导航*所述：
- en: You must implement this custom auth provider in your Angular app.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在你的 Angular 应用中实现这个自定义认证提供者。
- en: The code sample for this section is in the `projects/stage10` folder in the
    `lemon-mart-app` `app` or `web-app` folder.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码示例位于 `lemon-mart-app` 的 `app` 或 `web-app` 文件夹中的 `projects/stage10` 文件夹。
- en: Start by creating a `baseUrl` variable in `environment.ts` so that we can connect
    to your server.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `environment.ts` 中创建一个 `baseUrl` 变量，以便我们可以连接到你的服务器。
- en: In `environment.ts` and `environment.prod.ts`, implement a `baseUrl` variable.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `environment.ts` 和 `environment.prod.ts` 中实现一个 `baseUrl` 变量。
- en: 'Also, select `authMode` as `AuthMode.CustomServer`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，选择 `authMode` 为 `AuthMode.CustomServer`：
- en: '[PRE47]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Install a helper library to programmatically access TypeScript enum values:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一个辅助库以编程方式访问 TypeScript 枚举值：
- en: '[PRE48]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the RESTful custom authentication provider using `HttpClient`, as
    shown here:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，使用 `HttpClient` 实现基于 RESTful 的自定义身份验证提供者：
- en: '[PRE49]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `authProvider` method calls our `/v1/auth/login` method, and `getCurrentUser`
    calls `/v1/auth/me` to retrieve the current user.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`authProvider` 方法调用我们的 `/v1/auth/login` 方法，而 `getCurrentUser` 调用 `/v1/auth/me`
    来检索当前用户。'
- en: Ensure that calls to `login` methods always happen on HTTPS. Otherwise, you
    will send user credentials on the open internet. This is ripe for eavesdroppers
    on public Wi-Fi networks to steal user credentials.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保对 `login` 方法的调用始终发生在 HTTPS 上。否则，你将在开放的互联网上发送用户凭据。这很容易让公共 Wi-Fi 网络上的窃听者窃取用户凭据。
- en: 'Implement the GraphQL custom authentication provider using Apollo Client, as
    shown here:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，使用 Apollo Client 实现基于 GraphQL 的自定义身份验证提供者：
- en: '[PRE50]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that the `LOGIN` mutation and `Me` query are implemented in `auth.graphql.queries.ts`.
    Otherwise, they take up too much space for the service code to be readable.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`LOGIN` 变异和 `Me` 查询是在 `auth.graphql.queries.ts` 中实现的。否则，它们会占用太多空间，使得服务代码难以阅读。
- en: 'Update `authFactory` to return the new provider for the `AuthMode.CustomServer`
    option:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `authFactory` 以返回 `AuthMode.CustomServer` 选项的新提供者：
- en: '[PRE51]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Start your web app to make sure that things are working.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Web 应用程序以确保一切正常工作。
- en: Congratulations! You now grasp how code works across the entire software stack,
    from the database to the front and back ends.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经掌握了代码在整个软件栈中的工作方式，从数据库到前端和后端。
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered full-stack architecture. You learned about building
    a minimal MEAN stack. You now know how to create a monorepo for a full-stack application
    and configure a Node.js server with TypeScript. You learned about monorepos, containerizing
    a Node.js server, and declaratively defining infrastructure with Docker Compose.
    Using Docker Compose with CircleCI, we saw how you can verify your infrastructure
    in a CI environment.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了全栈架构。你学习了如何构建最小化的 MEAN 栈。你现在知道如何为全栈应用程序创建 monorepo 并配置 TypeScript
    的 Node.js 服务器。你学习了 monorepos、容器化 Node.js 服务器以及使用 Docker Compose 声明性地定义基础设施。通过使用
    Docker Compose 与 CircleCI，我们看到了如何在 CI 环境中验证你的基础设施。
- en: You learned how to design a RESTful API using OpenAPI and GraphQL using Apollo,
    set up an Express.js app, and configure it such that you can generate interactive
    documentation for your APIs. You learned about the benefits of using DocumentTS
    with MongoDB.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何使用 Apollo 和 OpenAPI 以及 GraphQL 设计 RESTful API，设置 Express.js 应用程序，并配置它以便为你的
    API 生成交互式文档。你了解了使用 DocumentTS 与 MongoDB 一起使用的优势。
- en: You then implemented a JWT-based authentication service with an `authenticate`
    middleware to secure API endpoints and allow for RBAC. Finally, you implemented
    two custom authentication providers in Angular. For REST, we used `HttpClient`,
    and for GraphQL, Apollo Client.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你实现了一个基于 JWT 的身份验证服务，使用 `authenticate` 中间件来保护 API 端点并允许 RBAC。最后，你在 Angular
    中实现了两个自定义身份验证提供者。对于 REST，我们使用了 `HttpClient`，而对于 GraphQL，我们使用了 Apollo Client。
- en: The next two chapters will explore Angular recipes to create forms and data
    tables. In *Chapter 8*, *Recipes – Reusability, Forms, and Caching*, and *Chapter
    9*, *Recipes – Master/Detail, Data Tables, and NgRx*, we will tie everything together
    by sticking to a decoupled component architecture, smartly choosing between creating
    user controls and components and maximizing code reuse, with various TypeScript,
    RxJS, NgRx, and Angular coding techniques.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两章将探索 Angular 的配方来创建表单和数据表。在第 8 章 *配方 – 可重用性、表单和缓存* 和第 9 章 *配方 – 主/详细信息、数据表和
    NgRx* 中，我们将通过坚持解耦组件架构、明智地选择创建用户控件和组件以及最大化代码重用，结合各种 TypeScript、RxJS、NgRx 和 Angular
    编码技术来整合一切。
- en: For the rest of the book, you will want your LemonMart server and MongoDB instance
    up and running to verify the correct functionality of your forms and tables as
    you implement them.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，你将需要确保你的 LemonMart 服务器和 MongoDB 实例运行正常，以便在实现表单和表格时验证它们的功能是否正确。
- en: Exercise
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: You secured your endpoints using the `authenticate` middleware. You configured
    Postman to send a valid token so that you can communicate with your secured endpoints.
    By way of an exercise, try removing the `authenticate` middleware and calling
    the same endpoint with and without a valid token. Re-add the middleware, and then
    try the same thing again. Observe the different responses you get from the server.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`authenticate`中间件来保护你的端点。你配置了Postman发送有效的令牌，以便你可以与受保护的端点通信。作为一个练习，尝试移除`authenticate`中间件，并使用有效的令牌和无令牌调用相同的端点。重新添加中间件，然后再次尝试相同的事情。观察服务器返回的不同响应。
- en: Further reading
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*What is DX? (Developer Experience)*, Albert Cavalcante, 2019, [https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9](https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9
    )'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*什么是DX？（开发者体验）*，Albert Cavalcante，2019，[https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9](https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9)'
- en: '*Overview of Blocking versus Non-Blocking*, 2023, [https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/](https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*阻塞与非阻塞概述*，2023，[https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/](https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/)'
- en: '*Explain Non-Blocking I/O like I’m Five, Frank Rosner*, 2019, [https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*像五岁孩子解释非阻塞I/O，Frank Rosner*，2019，[https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/)'
- en: '*OpenAPI Specification*, 2023, [https://swagger.io/docs/specification](https://swagger.io/docs/specification)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenAPI规范*，2023，[https://swagger.io/docs/specification](https://swagger.io/docs/specification)'
- en: '*Serialization*, 2023, [https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization)'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*序列化*，2023，[https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization)'
- en: '*JSON*, 2023, [https://en.wikipedia.org/wiki/JSON](https://en.wikipedia.org/wiki/JSON)'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JSON*，2023，[https://en.wikipedia.org/wiki/JSON](https://en.wikipedia.org/wiki/JSON)'
- en: '*Aggregation in MongoDB*, 2023, [https://docs.mongodb.com/manual/aggregation](https://docs.mongodb.com/manual/aggregation)'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MongoDB中的聚合*，2023，[https://docs.mongodb.com/manual/aggregation](https://docs.mongodb.com/manual/aggregation)'
- en: '*Apollo Authentication*, 2023, [https://www.apollographql.com/docs/react/networking/authentication](https://www.apollographql.com/docs/react/networking/authentication)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Apollo认证*，2023，[https://www.apollographql.com/docs/react/networking/authentication](https://www.apollographql.com/docs/react/networking/authentication)'
- en: '*Setting Up Authentication and Authorization with Apollo Federation*, 2023,
    [https://www.apollographql.com/blog/backend/auth/setting-up-authentication-and-authorization-apollo-federation/](https://www.apollographql.com/blog/backend/auth/setting-up-authentication-and-authorization-apollo-federation/)'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置Apollo Federation的认证和授权*，2023，[https://www.apollographql.com/blog/backend/auth/setting-up-authentication-and-authorization-apollo-federation/](https://www.apollographql.com/blog/backend/auth/setting-up-authentication-and-authorization-apollo-federation/)'
- en: '*Apollo Built-in error codes*, 2023, [https://www.apollographql.com/docs/apollo-server/data/errors#built-in-error-codes](https://www.apollographql.com/docs/apollo-server/data/errors#built-in-error-codes)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Apollo内置错误代码*，2023，[https://www.apollographql.com/docs/apollo-server/data/errors#built-in-error-codes](https://www.apollographql.com/docs/apollo-server/data/errors#built-in-error-codes)'
- en: '*Apollo Router & Gateway architecture*, 2023, [https://www.apollographql.com/docs/federation/building-supergraphs/router](https://www.apollographql.com/docs/federation/building-supergraphs/router
    )'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Apollo Router & Gateway架构*，2023，[https://www.apollographql.com/docs/federation/building-supergraphs/router](https://www.apollographql.com/docs/federation/building-supergraphs/router)'
- en: Questions
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to ensure you’ve understood the key concepts
    from this chapter without googling anything. Do you know if you got all the answers
    right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以确保你已理解本章的关键概念，无需使用谷歌搜索。你知道你是否答对了所有问题吗？访问[https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)获取更多信息：
- en: What are the main components that make for a great developer experience?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构成优秀开发者体验的主要组件有哪些？
- en: What is a `.env` file?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.env`文件有什么用途？'
- en: What is the purpose of the `authenticate` middleware?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`authenticate`中间件的目的是什么？'
- en: How does Docker Compose differ from using the Dockerfile?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose与使用Dockerfile有何不同？
- en: What is an ODM? How does it differ from an ORM?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ODM是什么？它与ORM有何不同？
- en: What is middleware?
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间件是什么？
- en: What are the uses of the OpenAPI spec?
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenAPI规范有哪些用途？
- en: How would you refactor code for the `/v2/users/{id} PUT` endpoint in `userRouter.ts`
    so that the code is reusable?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何重构`userRouter.ts`中的`/v2/users/{id} PUT`端点的代码，以便代码可重用？
- en: What are the major differentiators between REST and GraphQL?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST和GraphQL之间有哪些主要区别？
- en: What are the similarities between OpenAPI and the GraphQL schema?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenAPI和GraphQL模式之间有哪些相似之处？
- en: Join our community on Discord
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/AngularEnterpise3e](Chapter_7.xhtml)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/AngularEnterpise3e](Chapter_7.xhtml)'
- en: '![](img/QR_Code1116411172100421421.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1116411172100421421.png)'
