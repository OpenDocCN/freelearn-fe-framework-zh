- en: '*Chapter 11*: Similarities and Differences between Three Global State Libraries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this book, we introduced three global state libraries: Zustand, Jotai, and
    Valtio. Let''s discuss some similarities and differences between them. These three
    libraries have some comparable features.'
  prefs: []
  type: TYPE_NORMAL
- en: Zustand is similar to Redux (and React Redux) in terms of usage and the store
    model but, unlike Redux, it's not based on reducers.
  prefs: []
  type: TYPE_NORMAL
- en: Jotai is similar to Recoil ([https://recoiljs.org](https://recoiljs.org)) in
    terms of the API, but its goal is more to provide a minimal API for non-selector-based
    render optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Valtio is similar to MobX in terms of the mutating update model, but the level
    of similarity is only minor, and the render optimization implementation is very
    different.
  prefs: []
  type: TYPE_NORMAL
- en: All three libraries provide primitive features that fit with micro-state management.
    They differ in their coding style and approach to render optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we discuss each library by pairing it with its comparable
    library and then discuss the similarities and differences between the three. We
    will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Differences between Zustand and Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding when to use Jotai and Recoil
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Valtio and MobX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing Zustand, Jotai, and Valtio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are expected to have a moderate knowledge of React, including React hooks.
    Refer to the official site, [https://reactjs.org](https://reactjs.org), to learn
    more.
  prefs: []
  type: TYPE_NORMAL
- en: In some code, we use TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org)),
    and you should have a basic knowledge of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in this chapter is available on GitHub: [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_11](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_11).'
  prefs: []
  type: TYPE_NORMAL
- en: To run the code snippets, you need a React environment, for example, Create
    React App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  prefs: []
  type: TYPE_NORMAL
- en: Differences between Zustand and Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some use cases, the developer experience can be similar in Zustand and Redux.
    Both are based on one-way data flow. In one-way data flow, we dispatch `action`,
    which represents a command to update a state, and after the state is updated with
    `action`, the new state is propagated to where it's needed. This separation of
    dispatching and propagating simplifies the flow of data and makes the entire system
    more predictable.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, they differ in how to update states. Redux is based on reducers.
    A reducer is a pure function that takes a previous state and an `action` object
    and returns a new state. While updating states with reducers is a strict method,
    it leads to more predictability. Zustand takes a flexible approach and it doesn't
    necessarily use reducers to update states.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see a comparison by converting an example with Redux
    into Zustand. Then we will see the differences between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Example with Redux and Zustand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at one of the official Redux tutorials. This is the so-called modern
    Redux with the Redux toolkit: [https://redux-toolkit.js.org/tutorials/quick-start](https://redux-toolkit.js.org/tutorials/quick-start).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Redux store, we can use `configureStore` from the Redux Toolkit
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `configureStore` function takes reducers and returns a `store` variable.
    In this case, it uses one reducer – `counterReducer`.
  prefs: []
  type: TYPE_NORMAL
- en: '`counterReducer` is defined in a separate file, using `createSlice` from the
    Redux Toolkit library. First, we import `createSlice` and define `initialState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define `counterSlice` using `createSlice` and `initialState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `counterSlice` variable created with the `createSlice` function contains
    both a reducer and actions. To make them easily importable, we extract the reducer
    and action properties and export them separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the `Counter` component, which uses the created store. First, we import
    two hooks from the `react-redux` library and two actions from the `counterSlice`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the `Counter` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This component uses useSelector and useDispatch hooks from the React Redux library.
    We use a selector function to get the count value from the store state. Notice
    that this component doesn't use the created store directly. The useSelector hook
    takes the store from Context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `App` component looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We pass the `store` variable we created with the `Provider` component. This
    allows the `useSelector` hook in the `Counter` component to access the `store`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 11.1*, this works as expected. We have two `Counter` components
    in the `App` component, and they share the same `count` value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Screenshot of the app with Redux ](img/Figure_11.1_B17780.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Screenshot of the app with Redux
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how this can be implemented in Zustand.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a store with the `create` function from the Zustand library.
    We begin with importing the Zustand library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define `State` type for TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a `store` definition. In Zustand, a hook `useStore` represents
    a `store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This defines both the counter state and counter actions in the `store`. The
    reducer logic is implemented in the function body of the actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the `Counter` component, which uses the created store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We use the `useStore` hook to get the `count` value and the actions to update
    the `count` value. Notice that the `useStore` hook is directly imported from the
    store file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `App` component looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we don't use Context, we don't need a provider component.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss a comparison of the two.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing examples of Redux and Zustand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While two implementations of the example in the *Example with Redux and Zustand*
    section share some common concepts, there are notable differences:'
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest differences between the example of Redux and Zustand is the
    directory structure. Modern Redux suggests the `features` directory structure
    and the `createSlice` function is designed to follow the feature directory pattern.
    This is a useful pattern for large-scale apps. Zustand, on the other hand, is
    unopinionated regarding the structure. It's up to developers how to organize files
    and directories. While it's possible to follow the `features` directory structure
    with Zustand, there's no specific support from the library. Our Zustand example
    shows a pattern with `counterActions`, but it's only one possible pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another difference in the store creation code is the use of Immer ([https://immerjs.github.io/immer/](https://immerjs.github.io/immer/)).
    Immer allows a mutation style such as `state.value += 1;`. Modern Redux uses Immer
    by default. Zustand doesn't use it by default, and neither does our example. It
    is possible to use Immer in Zustand, but it's optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of store propagation, Redux uses Context, whereas Zustand uses module
    imports. Context allows the store to be injected at runtime, which works better
    in some use cases. Zustand optionally supports Context usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most importantly, Redux Toolkit is based on Redux, which is based on a one-way
    data flow. So, updating the state in Redux requires actions to be dispatched.
    This limitation is sometimes good for maintainability and scalability. Zustand
    is unopinionated regarding the data flow, and while it can be used for one-way
    data flow, there is no library support and developers need to take care of everything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, modern Redux is more opinionated about how to manage the state and
    Zustand is less opinionated about it. In the end, Zustand is a minimalistic library,
    while Redux and its family are a set of full-featured libraries. The usages of
    both modern Redux and Zustand seem similar, but the philosophies behind them are
    different.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw a comparison between modern Redux and Zustand. Next
    up, we will compare Recoil and Jotai.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding when to use Jotai and Recoil
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jotai's API is highly inspired by Recoil. In the beginning, it's intentionally
    designed to help migration from Recoil to Jotai. In this section, we will see
    a comparison by converting an example with Recoil into Jotai. Then, we will discuss
    the differences between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Example with Recoil and Jotai
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the Recoil tutorial at [https://recoiljs.org/docs/introduction/getting-started](https://recoiljs.org/docs/introduction/getting-started)
    and see how an example in the Recoil tutorial is converted to Jotai.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with the Recoil example, we need to import some functions from the
    Recoil library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are five of them used in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first state for the text string is created with the `atom` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It takes two properties – the `key` string and the `default` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the defined state, we use the `useRecoilState` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`useRecoilState` returns the same value as `useState`. Hence, the rest of the
    code should be familiar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second state is a derived state. We use the `selector` function to define
    a derived state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It takes two properties – a `key` string and a `get` function. The `get` property
    is a function that returns a derived value. Another `get` function within a `get`
    property returns the value of other states created by other `atom` and `selector`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the second state, we use the `useRecoilValue` hook, which returns only
    the value part of the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This component will re-render when `textState` changes because `charCountState`
    is derived from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CharacterCounter` component is defined as follows to combine two components
    that are already defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the `App` component, we use the `RecoilRoot` component, which holds state
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 11.2*, this app works like this: if you type something
    in the text field, the text will be shown below the text field, and also the number
    of characters is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.2_B17780.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Screenshot of the app with Recoil
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's convert this example code into Jotai.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first import two functions from the Jotai library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Jotai's API tries to be minimal, and the minimal usage requires two functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first atom for the text string is created with the `atom` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is almost the same as Recoil, except that it only has the `default` value
    because Jotai doesn't require the `key` string. Suffixing the variable name with
    `Atom` instead of `State` is a convention that is technically unimportant.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the defined atom, we use the `useAtom` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `useAtom` function works like `useState`, and the rest of the code should
    be familiar to people who are used to `useState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second atom is a derived atom, which is defined with the `atom` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we pass a function to the `atom` function. The internal function
    computes the derived value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the second atom, we again use the `useAtom` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It's required to get the first part of the returned value with `[count]`. Other
    than that, the code and the behavior should be similar to Recoil.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CharacterCounter` component is defined as follows to combine two components
    that are already defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The minimal use case of Jotai doesn't require a `Provider` component.
  prefs: []
  type: TYPE_NORMAL
- en: The conversion from the Recoil example to the Jotai example is mostly syntactic,
    and the behavior is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss some of the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing examples of Recoil and Jotai
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although there are many differences in terms of features we didn''t use in
    the example, we''ll keep our discussion within the scope of the example we showed,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest difference is the existence of the `key` string. One of the big
    motivations of developing Jotai is to omit the `key` string. Thanks to this feature,
    the `atom ({ key: "textState", default: "" })` atom definition in Recoil can be
    `atom("")` in Jotai. Technically, it looks straightforward, but this makes a huge
    difference to the developer experience. Naming is a hard task in coding, especially
    because the `key` property has to be unique. Implementation-wise, Jotai utilizes
    `WeakMap` and relies on the reference of atom objects. On the other hand, Recoil
    is based on the `key` strings, which don''t rely on object references. The benefit
    of `key` strings is that they''re serializable. This should facilitate implementing
    persistence, which requires serialization. Jotai would require some techniques
    to overcome serialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another difference related to the `key` string is the unified `atom` function.
    The `atom` function in Jotai works for both `atom` and `selector` in Recoil. However,
    there's a downside. It can't be fully expressive and may require other functions
    in Jotai to support other use cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last but not least, the provider-less mode in Jotai, which allows omission of
    the `Provider` component, is technically simple, but very developer-friendly to
    lower the mental barrier as regards using the library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic functionalities are the same in both Recoil and Jotai and developers would
    need to make a choice based on other requirements or just their preference in
    terms of the API. Jotai's API is minimalistic, the same as Zustand.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw a comparison between Recoil and Jotai. Next up, we will
    see a comparison between MobX and Valtio.
  prefs: []
  type: TYPE_NORMAL
- en: Using Valtio and MobX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the motivation is quite different, Valtio is often compared to MobX
    ([https://mobx.js.org](https://mobx.js.org)). Usage-wise, there are some similarities
    in Valtio and MobX regarding their React binding. Both are based on mutable states
    and developers can directly mutate state, which results in similar usage. JavaScript
    is based on mutable objects, so the syntax of mutating an object is very natural
    and compact. This is a big win for mutable states compared to immutable states.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, there is a difference in how they optimize renders. For
    render optimization, while Valtio uses a hook, MobX React uses a **higher-order
    component** (**HoC**): [https://reactjs.org/docs/higher-order-components.html](https://reactjs.org/docs/higher-order-components.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will convert a simple MobX example into Valtio. Then we
    will see the differences between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, Valtio is comparable to Immer ([https://immerjs.github.io/immer/](https://immerjs.github.io/immer/)).
    Both try to bridge immutable and mutable states. Valtio is based on mutable states
    and converts states to immutable ones, whereas Immer is based on immutable states
    and uses mutable states (drafts) temporarily.
  prefs: []
  type: TYPE_NORMAL
- en: Example involving MobX and Valtio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take an example from MobX''s documentation: [https://mobx.js.org/README.html#a-quick-example](https://mobx.js.org/README.html#a-quick-example).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first import some functions from the MobX libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As the MobX library is framework-agnostic, the React-related function is imported
    from the MobX React library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to define the business logic, which is a timer. We create
    a class and then instantiate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It has one property and two functions to mutate the property. `makeAutoObservable`
    is used to make the `myTimer` instance an observable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the mutating function anywhere within the code. As an example,
    let''s set an interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will increase the `secondsPassed` property every second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the component to use `timer` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `observer` function is an HoC. It understands `timer.secondsPassed` is used
    in a render function, and will trigger re-renders when `timer.secondsPassed` changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `App` component has the `TimerView` component with the `myTimer`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As *Figure 11.3* shows, if you run this app, it will show a button with a label
    showing the number of seconds that have passed. The label changes every second.
    Clicking this button will reset the number.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.3_B17780.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Screenshot of the app with MobX
  prefs: []
  type: TYPE_NORMAL
- en: Now, what would this look like with Valtio? Let's see the same example with
    Valtio.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first import two functions from the Valtio library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Although Valtio is a library for React, it has a vanilla bundle for non-React
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `proxy` function to define a `myTimer` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It has a `secondsPassed` property for a number value and two function properties
    to update the number value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use one of the function properties to increase the `secondsPassed` property
    periodically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This `setInterval` usage is exactly the same as MobX.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the `TimerView` component using `useSnapshot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In Valtio, `useSnapshot` is a hook to understand how a state is used in a render
    function and will trigger re-renders when the used part in the state is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `App` component is the same as MobX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the end, we should have the same behavior as MobX. It shows a button with
    a label. The label shows the number of seconds that have passed, and clicking
    the button will reset the value.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss some differences.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing examples of MobX and Valtio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two examples in MobX and Valtio look similar, but there are two major differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The first difference is the updating method. Although both use mutations, the
    MobX example is class-based, whereas the Valtio example is object-based. It's
    mostly stylistic, and Valtio is not very opinionated regarding the styles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the styles Valtio allows is the separation of functions from the state
    object. The same example can be implemented in the following approach:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define updating functions outside the state object defined by the `proxy`
    function. The benefit of this approach is that it allows code-splitting, minification,
    and dead code elimination. In the end, we can expect an optimized bundle size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second difference is the render optimization method. While MobX takes the
    observer approach, Valtio takes the hook approach. There are pros and cons to
    each. The observer approach is more predictable. The hook approach is more "concurrent
    rendering" friendly. Implementing this approach is likely very different. There's
    also a stylistic difference; some developers prefer the HoC style, while other
    developers prefer the hook style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As of the time of writing, we only have limited information about concurrent
    rendering. It's our best observation at this point, but it's not guaranteed whether
    the statement will hold in the future.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we saw a comparison between MobX and Valtio. Next up, we will
    discuss a comparison between Zustand, Jotai, and Valtio.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Zustand, Jotai, and Valtio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter so far, we have compared the following pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: Zustand and Redux in the *Differences between Zustand and Redux* section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jotai and Recoil in the *Understanding when to use Jotai and Recoil* section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Valtio and MobX in the *Using Valtio and MobX* section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We compared these pairs because there are some similarities. In this section,
    we will compare Zustand, Jotai, and Valtio.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, all three libraries are provided by the Poimandres GitHub organization
    ([https://github.com/pmndrs](https://github.com/pmndrs)). It''s a developer collective
    providing many libraries. Three micro-state management libraries from a single
    GitHub organization may sound counter-intuitive, but they are in different styles.
    There is also a philosophy that is common in the three libraries: their small
    API surfaces. All three libraries try their best to provide small API surfaces
    and let developers compose the APIs as they want.'
  prefs: []
  type: TYPE_NORMAL
- en: But then, what are the differences between the three libraries?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`countAtom`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `countAtom` variable holds a config object, and it doesn't hold a value.
    The atom values are stored in a `Provider` component. Hence, `countAtom` can be
    reused for multiple components. Implementing the same behavior is tricky with
    module states. With Zustand and Valtio, we would end up using React Context. On
    the other hand, accessing component states from outside React is technically not
    possible. We'll likely need some sort of module state to connect to the component
    states.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Whether we use module states or component states depends on the app requirements.
    Usually, using either module states or component states for global states fulfills
    the app requirements, but in some rare cases, using both types of states may make
    sense.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`state = { count: 0 }`. If you want to update the count in the immutable state
    model, you need to create a new object. Hence, incrementing the count by `1` should
    be `state = { count: state.count + 1 }`. In the mutable state mode, it could be
    `++state.count`. This is because JavaScript objects are mutable by nature. The
    benefit of the immutable model is that you can compare the object references to
    know whether anything has changed. It helps improve performance for large, nested
    objects. Because React is mostly based on the immutable model, Zustand with the
    same model has compatibility. Thus, Zustand is a very thin library. On the other
    hand, Valtio, with the mutable state model, requires filling the gap between the
    two models. In the end, Zustand and Valtio take different state updating styles.
    The mutable updating style is very handy, especially when an object is deeply
    nested. Revisit the example in *The pros and cons of this approach* section of
    [*Chapter 9*](B17780_09_Final_VK_ePub.xhtml#_idTextAnchor116), *Use Case Scenario
    3 – Valtio*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note Regarding the Use of Immer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It's possible to use Immer to allow mutations to update states in Zustand and
    Jotai. Compared to the combination of Zustand and Immer, Valtio is more optimized
    for the mutable state model. It has smaller API surfaces and it also optimizes
    re-renders. The combination of Jotai and Immer is useful for big objects, and
    the Jotai library provides a specific feature to integrate Immer. However, Jotai
    atoms are usually small, and in such a case, the immutable updating style is not
    a big issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are some minor differences among the three libraries, but what's important
    is the fact that they are based on different principles. If we were to choose
    one of them, we would need to see which principle fits well with our app requirements
    and our mental model.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we summarized the differences between the three libraries for
    a global state we explained in this book. They are different because they are
    based on different models.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, micro-state management involves choosing the right solution and
    the right library for a specific problem. Micro state management requires you
    to understand what your problem is and what solutions are available for your problem.
    We hope that this book has covered some topics that will help developers find
    the right solution.
  prefs: []
  type: TYPE_NORMAL
- en: Hi!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am Daishi Kato, author of Micro State Management with React Hooks. I really
    hope you enjoyed reading this book and found it useful for increasing your productivity
    and efficiency in React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: It would really help me (and other potential readers!) if you could leave a
    review on Amazon sharing your thoughts on Micro State Management with React Hooks
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the link below or scan the QR code to leave your review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/r/1801812373](https://packt.link/r/1801812373)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code  Description automatically generated](img/QR_code_B17780.png)'
  prefs: []
  type: TYPE_IMG
- en: Your review will help me to understand what's worked well in this book, and
    what could be improved upon for future editions, so it really is appreciated.
  prefs: []
  type: TYPE_NORMAL
- en: Best wishes,
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Author_photo.png)'
  prefs: []
  type: TYPE_IMG
- en: Daishi Kato
  prefs: []
  type: TYPE_NORMAL
