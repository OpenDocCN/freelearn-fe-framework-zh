- en: Testing Personal Trainer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试个人教练
- en: Unless you are a superhero who codes perfectly, you need to test what you build.
    Also, unless you have loads of free time to test your application again and again,
    you need some test automation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您是一位编写代码完美的超级英雄，否则您需要测试您所构建的内容。此外，除非您有大量空闲时间不断测试您的应用程序，否则您需要一些测试自动化。
- en: When we say Angular was built with testability in mind, we really mean it. It
    has a strong **Dependency Injection** (**DI**) framework, some good mock constructs,
    and awesome tools that make testing in an Angular app a fruitful endeavor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说 Angular 是以可测试性为设计理念时，我们确实是认真的。它有一个强大的 **依赖注入**（**DI**）框架，一些良好的模拟构造，以及使在
    Angular 应用中进行测试变得富有成效的出色工具。
- en: This chapter is all about testing and is dedicated to testing what we have built
    over the course of this book. We test everything from components to pipes, services,
    and our app directives.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于测试，致力于测试本书过程中我们所构建的内容。我们从组件到管道、服务以及我们的应用指令，测试了所有内容。
- en: 'The topics we cover in this chapter include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括：
- en: '**Understanding the big picture**: We will try to understand how testing fits
    into the overall context of Angular app development. We will also discuss the
    types of testing Angular supports, including unit and **end-to-end** (**E2E**)
    testing.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解大局**：我们将尝试理解测试如何融入 Angular 应用开发的整体背景。我们还将讨论 Angular 支持的测试类型，包括单元测试和 **端到端**（**E2E**）测试。'
- en: '**Overview of tools and frameworks**: We will cover the tools and frameworks
    that help in both unit and end-to-end testing with Angular. These include **Karma**
    and **Protractor**.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具和框架概述**：我们将介绍帮助使用 Angular 进行单元测试和端到端测试的工具和框架。这些包括 **Karma** 和 **Protractor**。'
- en: '**Writing unit tests**: You will learn how to do unit testing with Angular
    using **Jasmine** and **Karma** inside a browser. We will unit test what we have
    built in the last few chapters. This section also teaches us how to unit-test
    various Angular constructs, including pipes, components, services, and directives.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写单元测试**：您将学习如何在浏览器中使用 **Jasmine** 和 **Karma** 进行 Angular 的单元测试。我们将对上一章构建的内容进行单元测试。本节还将教会我们如何对各种
    Angular 构造进行单元测试，包括管道、组件、服务和指令。'
- en: '**Creating end-to-end tests**: Automated end-to-end tests work by mimicking
    the behavior of the actual user through browser automation. You will learn how
    to use Protractor combined with WebDriver to perform end-to-end testing.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建端到端测试**：自动化的端到端测试通过模拟实际用户的行为并通过浏览器自动化来实现。您将学习如何使用 Protractor 结合 WebDriver
    进行端到端测试。'
- en: Let the testing begin!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让测试开始吧！
- en: 'As you start reading this chapter, we suggest that you download the code for
    `checkpoint 7.1`. It is available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub. If
    you are not using Git, download the snapshot of `checkpoint7.1` (a ZIP file) from
    this GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始阅读本章时，我们建议您下载 `checkpoint 7.1` 的代码。它可以在 GitHub 上供所有人下载（[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)）。检查点作为
    GitHub 上的分支实现。如果您不使用 Git，可以从此 GitHub 位置下载 `checkpoint7.1` 的快照（ZIP 文件）：[https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip)。在首次设置快照时，请参考
    `trainer` 文件夹中的 `README.md` 文件。
- en: This checkpoint contains the tests that were generated by the Angular CLI as
    we created components, services, pipes, and directives in the earlier chapters.
    We have made minor changes in these tests so that they all pass. For the most
    part these are basic "Hello World" tests that confirm the creation of a component
    or other Angular construct. We will not be covering these tests in this chapter,
    but encourage you to review them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此检查点包含在前面章节创建组件、服务、管道和指令时由 Angular CLI 生成的测试。我们对这些测试进行了细微的修改，以确保它们都能通过。大部分这些测试都是基本的“Hello
    World”测试，用于确认组件或其他 Angular 构造的创建。我们将在本章中不涉及这些测试，但鼓励您进行回顾。
- en: The need for automation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化的需求
- en: The size and complexity of apps being built for the web are growing with each
    passing day. The plethora of options that we now have to build web apps is just
    mind-boggling. Add to this the fact that the release cycles for products/apps
    have shrunk drastically from months to days, or even multiple releases per day!
    This puts a lot of burden on software testing. There is too much to be tested.
    Multiple browsers, multiple clients and screen sizes (desktop and mobile), multiple
    resolution, and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，为网络构建的应用的大小和复杂性都在增长。我们现在构建网络应用的可选方案繁多，令人眼花缭乱。再加上产品/应用的发布周期已经从几个月缩短到几天，甚至每天有多个版本发布！这给软件测试带来了很大的负担。有太多东西需要测试。多个浏览器、多个客户端和屏幕尺寸（桌面和移动）、多个分辨率等等。
- en: To be effective in such a diverse landscape, automation is the key. *Automate
    everything that can be automated* should be our mantra.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样一个多样化的环境中要有效，自动化是关键。“*自动化一切可以自动化的内容*”应该是我们的座右铭。
- en: Testing in Angular
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 中的测试
- en: The Angular team realized the importance of testability and hence created a
    framework that allowed easy testing (automated) for apps built on it. The design
    choice of using DI constructs to inject dependencies everywhere has helped. This
    will become clear as the chapter progresses and we build a number of tests for
    our apps. However, before that, let's understand the types of testing that we
    target when building apps on this platform.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 团队意识到了可测试性的重要性，因此创建了一个框架，使得基于该框架构建的应用可以轻松进行测试（自动化）。使用 DI 构造来注入依赖的设计选择有助于这一点。随着章节的推进，我们将为我们的应用构建多个测试，这一点将会变得清晰。然而，在那之前，让我们了解在构建该平台上的应用时，我们针对哪些类型的测试。
- en: Types of testing
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'There are broadly two forms of testing that we do for a typical Angular app:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的 Angular 应用，我们主要进行两种形式的测试：
- en: '**Unit testing**: Unit testing is all about testing a component in isolation
    to verify the correctness of its behavior. Most of the dependencies of the component
    under test need to be replaced with mock implementations to make sure that the
    unit tests do not fail due to failure in a dependent component.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：单元测试完全是针对组件进行隔离测试，以验证其行为的正确性。被测试组件的大多数依赖项需要用模拟实现来替换，以确保单元测试不会因为依赖组件的失败而失败。'
- en: '**End-to-end testing**: This type of testing is all about executing the application
    like a real end user and verifying the behavior of the application. Unlike unit
    testing, components are not tested in isolation. Tests are done against a running
    system in real browsers, and assertions are done based on the state of the user
    interface and the content displayed.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：这种测试类型完全模拟真实用户的操作，并验证应用的行为。与单元测试不同，组件不是单独测试的。测试是在真实浏览器中针对运行中的系统进行的，断言是基于用户界面状态和显示的内容进行的。'
- en: Unit testing is the first line of defense against bugs, and we should be able
    to iron out most issues with code during unit testing. But unless E2E is done,
    we cannot confirm that the software is working correctly. Only when all the components
    within a system interact in the desired manner can we confirm that the software
    works; hence, E2E testing becomes a necessity.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是防止错误的第一个防线，我们应该能够在单元测试期间用代码解决大多数问题。但除非进行了端到端测试，否则我们无法确认软件是否正确运行。只有当系统中的所有组件以期望的方式交互时，我们才能确认软件是正常工作的；因此，端到端测试成为了一种必需。
- en: You can view these two types of testing like a pyramid with E2E testing on the
    top and unit testing on the bottom. The pyramid indicates that the number of unit
    tests you write should substantially exceed the number of E2E tests. The reason
    is that with unit tests you are breaking your application down into small testable
    units, whereas with integration tests you are spanning multiple components from
    the UI through to the backend. Also setting up E2E tests tends to be more complicated
    than unit tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这两种测试类型看作是一个金字塔，端到端测试位于顶部，单元测试位于底部。金字塔表明，你编写的单元测试数量应该远多于端到端测试的数量。原因是，通过单元测试，你将应用分解成小的可测试单元，而通过集成测试，你跨越了从
    UI 到后端的多个组件。此外，设置端到端测试通常比单元测试更复杂。
- en: Who writes unit and E2E tests and when are they written are important questions
    to answer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 谁编写单元测试和端到端测试，以及何时编写，都是需要回答的重要问题。
- en: Testing – who does it and when?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 – 谁来做，何时做？
- en: Traditionally, E2E testing was done by the **Quality Assurance** (**QA**) team
    and developers were responsible for unit-testing their code before submitting.
    Developers did some amount of E2E testing too, but overall the E2E testing process
    was manual.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，端到端测试（E2E testing）是由**质量保证**（**QA**）团队执行的，而开发人员则负责在提交代码前进行单元测试。开发人员也会进行一定程度的端到端测试，但总体来说，端到端测试过程是手动的。
- en: With the changing landscape, modern testing tools, especially on the web front,
    have allowed developers to write automated E2E tests themselves and execute them
    against any deployment setup (such as development/stage/production). Tools such
    as Selenium, together with WebDrivers, allow easy browser automation, thus making
    it easy to write and execute E2E tests against real web browsers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着形势的变化，现代测试工具，尤其是在网络前端，已经允许开发人员自己编写自动化的端到端测试，并针对任何部署设置（如开发/测试/生产）执行它们。例如，Selenium
    与 WebDriver 一起使用，可以轻松实现浏览器自动化，从而使得编写和执行针对真实网络浏览器的端到端测试变得容易。
- en: A good time to write E2E scenario tests is when the development is complete
    and ready to be deployed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发完成并准备部署时是编写端到端场景测试的好时机。
- en: When it comes to unit testing, there are different schools of thought around
    when a test should be written. A *Test Driven Developer* writes tests before the
    functionality is implemented. Others write tests when the implementation is complete
    to confirm the behavior. Some write while developing the component itself. Choose
    a style that suits you, keeping in mind that the earlier you write your tests,
    the better.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到单元测试时，关于何时编写测试存在不同的观点。*测试驱动开发者*在功能实现之前编写测试。其他人则在实现完成后编写测试以确认行为。有些人则在开发组件的同时编写测试。选择一种适合你的风格，同时记住，你编写测试的时间越早，效果越好。
- en: We are not going to give any recommendations, nor are we going to get into an
    argument over which one is better. Any amount of unit tests is better than nothing.
    Our personal preference is to use the *middle approach*. With TDD, we feel that
    the test creation effort at times is lost as the specifications/requirements change.
    Tests written at the start are prone to constant fixes as the requirement changes.
    The problem with writing unit tests at the end is that our target is to create
    tests that pass according to the current implementation. The tests that are written
    are retrofitted to test the implementation where they should test the specifications.
    Adding tests somewhere in the middle works best for us.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会给出任何建议，也不会就哪种方法更好而争论。任何数量的单元测试都比没有好。我们个人的偏好是采用*中间方法*。在使用测试驱动开发（TDD）时，我们有时觉得测试创建的努力因为规格/需求的变化而白费。一开始编写的测试容易因为需求变化而需要不断修正。在最后编写单元测试的问题在于，我们的目标是创建符合当前实现的测试。编写的测试是为了测试实现，而不是测试规格。在中间某个地方添加测试对我们来说效果最好。
- en: Let's now try to understand the tooling and technology landscape available for
    Angular testing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来了解一下可用于 Angular 测试的工具和技术环境。
- en: The Angular testing ecosystem
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 测试生态系统
- en: 'Look at the following diagram to understand the tools and frameworks that support
    Angular testing:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表，了解支持 Angular 测试的工具和框架：
- en: '![](img/00070.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00070.jpeg)'
- en: The tools and frameworks that support Angular testing
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 支持Angular测试的工具和框架
- en: As we can see, we write our tests using unit testing libraries such as **Jasmine**
    or **Mocha**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们使用单元测试库，如**Jasmine**或**Mocha**来编写测试。
- en: At the moment, the Angular testing library works by default with *Jasmine*.
    However, the Angular team has indicated that they have made the framework more
    generic so that you can use other testing libraries such as Mocha with it. The
    Angular documentation has not yet been updated to include how to do this. For
    a discussion of using Mocha with the Angular CLI testing commands see [https://github.com/angular/angular-cli/issues/4071](https://github.com/angular/angular-cli/issues/4071).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Angular 测试库默认与*Jasmine*一起工作。然而，Angular 团队已经表明，他们已经使框架更加通用，这样你就可以使用其他测试库，如
    Mocha。Angular 文档尚未更新以包含如何做到这一点。有关使用 Mocha 与 Angular CLI 测试命令的讨论，请参阅[https://github.com/angular/angular-cli/issues/4071](https://github.com/angular/angular-cli/issues/4071)。
- en: These tests are executed by either Karma or Protractor depending on whether
    we are writing unit or integration tests. These test runners in turn run our tests
    in a browser such as Chrome, Firefox, IE, or headless browsers such as PhantomJS.
    It is important to highlight that not only E2E, but also unit tests are executed
    in a real browser.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试根据我们是否编写单元测试或集成测试，由 Karma 或 Protractor 执行。这些测试运行器反过来在浏览器（如 Chrome、Firefox、IE）或无头浏览器（如
    PhantomJS）中运行我们的测试。重要的是要强调，不仅端到端测试，单元测试也是在真实浏览器中执行的。
- en: All the tests in this chapter are written using Jasmine (both unit and integration
    tests). Karma will be our test runner for unit tests and Protractor for E2E tests.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有测试都是使用 Jasmine 编写的（包括单元测试和集成测试）。Karma 将作为单元测试的测试运行器，而 Protractor 将用于端到端测试。
- en: Getting started with unit testing
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用单元测试
- en: 'The ultimate aim of unit testing is to test a specific piece of code/component
    in isolation to make sure that the components work according to the specification.
    This reduces the chances of failures/bugs in the component when integrated with
    other parts of the software. Before we start writing tests, there are some guidelines
    that can help us write good and maintainable tests:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的最终目的是在隔离状态下测试特定的代码/组件，以确保组件按照规范工作。这减少了组件与其他软件部分集成时出现失败/错误的机会。在我们开始编写测试之前，有一些指导原则可以帮助我们编写良好且可维护的测试：
- en: One unit should test one behavior. For obvious reasons, testing one behavior
    per unit test makes sense. A failing unit test should clearly highlight the problem
    area. If multiple behaviors are tested together, a failed test requires more probing
    to assert what behavior was violated.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单元应该测试一个行为。出于明显的原因，每个单元测试测试一个行为是有意义的。失败的单元测试应清楚地突出问题区域。如果一起测试多个行为，失败的测试需要更多的调查来确定违反了哪个行为。
- en: Dependencies in a unit test should be mocked away using test doubles such as
    fakes, mocks, or st. Unit testing, as the name suggests, should test the unit
    and not its dependencies.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试中的依赖项应使用测试替身（如模拟、模拟或 st）来模拟。正如其名所示，单元测试应该测试单元，而不是其依赖项。
- en: Unit tests should not change the state of the component being tested permanently.
    If it does happen, other tests may get affected.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试不应该永久改变被测试组件的状态。如果发生了这种情况，其他测试可能会受到影响。
- en: The order of execution of unit tests should be immaterial. One unit test should
    not be dependent on another unit test to execute before it. This is a sign of
    a brittle unit test. It may also mean that the dependencies are not mocked.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的执行顺序应该是无关紧要的。一个单元测试不应该依赖于另一个单元测试在它之前执行。这是脆弱单元测试的迹象。这也可能意味着依赖项没有被模拟。
- en: Unit tests should be fast. If they are not fast enough, developers will not
    run them. This is a good reason to mock all dependencies such as database access,
    remote web service call, and others in a unit test.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该快速。如果它们不够快，开发者就不会运行它们。这是一个在单元测试中模拟所有依赖项（如数据库访问、远程Web服务调用等）的好理由。
- en: 'Unit tests should try to cover all code paths. Code coverage is a metric that
    can help us assess the effectiveness of unit tests. If we have covered all positive
    and negative scenarios during testing, the coverage will indeed be higher. A word
    of caution here: high code coverage does not imply that the code is bug-free,
    but low coverage clearly highlights a lack of areas covered in unit tests.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应尝试覆盖所有代码路径。代码覆盖率是一个可以帮助我们评估单元测试有效性的指标。如果在测试期间覆盖了所有正面和负面场景，覆盖率确实会更高。在此提醒一点：高代码覆盖率并不意味着代码没有错误，但低覆盖率明显表明单元测试中未覆盖的区域。
- en: Unit tests should test both positive and negative scenarios. Just don't concentrate
    on positive test cases; all software can fail, and hence unit testing failure
    scenarios are as important to test as success scenarios.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应测试正面和负面场景。只是不要只关注正面测试用例；所有软件都可能失败，因此单元测试失败场景与成功场景一样重要。
- en: These guidelines are not framework-specific, but give us enough ammunition for
    writing good tests. Let's begin the process of unit testing by setting up the
    components required for it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指导原则不是框架特定的，但为我们编写良好测试提供了足够的弹药。让我们通过设置单元测试所需的组件来开始单元测试的过程。
- en: Setting up Karma and Jasmine for unit testing
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为单元测试设置 Karma 和 Jasmine
- en: 'When we created our project using the Angular CLI, the CLI configured the setup
    for unit testing our code with Karma and Jasmine. It did so by adding several
    Karma and Jasmine modules to our project. It also added a Karma configuration
    file—`karma.config.js`—to the root directory of our application—`trainer/`—and
    a file called `tests.ts` in the `trainer/src` directory. The CLI makes use of
    these files at runtime to create the configuration for executing our tests. This
    means that we can run our tests by simply using the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Angular CLI 创建项目时，CLI 会配置使用 Karma 和 Jasmine 对我们的代码进行单元测试的设置。它是通过向我们的项目中添加几个
    Karma 和 Jasmine 模块来实现的。它还在应用程序的根目录 `trainer/` 中添加了一个名为 `karma.config.js` 的 Karma
    配置文件，并在 `trainer/src` 目录中添加了一个名为 `tests.ts` 的文件。CLI 在运行时使用这些文件来创建执行我们的测试的配置。这意味着我们可以通过简单地使用以下命令来运行我们的测试：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And the CLI will also watch our tests for changes and automatically rerun them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 还会监视我们的测试以检测更改，并自动重新运行它们。
- en: We will not be covering the configuration files in detail here. The out-of-the-box
    settings will be fine for our purposes. Refer to the Karma documentation ([http://karma-runner.github.io/1.0/config/configuration-file.html](http://karma-runner.github.io/1.0/config/configuration-file.html))
    to understand more about the various Karma configuration options.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会详细讲解配置文件。默认设置对我们的目的来说已经足够了。有关各种 Karma 配置选项的更多信息，请参阅 Karma 文档（[http://karma-runner.github.io/1.0/config/configuration-file.html](http://karma-runner.github.io/1.0/config/configuration-file.html)）。
- en: Organization and naming of our test files
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们测试文件的组织和命名
- en: To unit test our app, we should have one test (such as `workout-runner.spec.ts`)
    file for each TypeScript file that we plan to test in our project. And this is
    what the Angular CLI does for us. When we create a component, service, pipe, or
    directive using the CLI, the CLI will generate a corresponding test and place
    it in the same file directory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要对应用程序进行单元测试，我们应该为项目中计划测试的每个 TypeScript 文件有一个测试文件（例如 `workout-runner.spec.ts`）。这正是
    Angular CLI 为我们做的事情。当我们使用 CLI 创建组件、服务、管道或指令时，CLI 将生成相应的测试并将其放置在相同的文件目录中。
- en: Naming the test files with the name of the file under test plus `.spec` is a
    convention that is used by developers who test with Jasmine. It is also used to
    facilitate the mapping of files to tests in the configuration steps that we outlined
    previously.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用被测试文件名称加上 `.spec` 来命名测试文件是使用 Jasmine 进行测试的开发者所采用的一种约定。它也用于便于我们在之前概述的配置步骤中映射文件到测试。
- en: 'This test file contains the unit test specification for the corresponding component,
    as shown in the following screenshot (taken in the Karma debugger when running
    our unit tests):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试文件包含对应组件的单元测试规范，如下面的截图所示（在运行单元测试时在 Karma 调试器中捕获）：
- en: '![](img/00071.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00071.jpeg)'
- en: Unit-testing Angular applications
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试 Angular 应用程序
- en: Over the course of this book, we have built components that cover every construct
    available in Angular. We have built components, pipes, a few services, and finally
    some directives too. All of these are testable in unit tests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们构建了涵盖 Angular 中每个构造的组件。我们构建了组件、管道、一些服务，最后还有一些指令。所有这些都可以在单元测试中进行测试。
- en: The code for the rest of this chapter can be found in `checkpoint 7.2`. It is
    available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub. If
    you are not using Git, download the snapshot of `checkpoint7.2` (a ZIP file) from
    this GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint7.2.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余的代码可以在 `checkpoint 7.2` 中找到。它可以在 GitHub 上供每个人下载（[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)）。检查点作为
    GitHub 上的分支实现。如果您不使用 Git，可以从以下 GitHub 位置下载 `checkpoint7.2` 的快照（ZIP 文件）：[https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip)。在首次设置快照时，请参考
    `trainer` 文件夹中的 `README.md` 文件。
- en: 'Just to get the hang of unit testing with Jasmine, let''s test the smallest
    and easiest component first: the pipe.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉使用 Jasmine 进行单元测试，让我们首先测试最小且最简单的组件：管道。
- en: Unit-testing pipes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试管道
- en: Pipes are the easiest to test as they have minimum or zero dependencies on other
    constructs. The `SecondsToTimePipe` that we created for *Workout Runner* (the
    *7 Minute Workout* app) has no dependencies and can be easily unit-tested.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是最容易测试的，因为它们对其他构造的依赖最小或为零。我们为*Workout Runner*（*7分钟锻炼*应用程序）创建的`SecondsToTimePipe`没有依赖关系，可以轻松地进行单元测试。
- en: Look at the Jasmine framework documentation to understand how to write unit
    tests using Jasmine. The CLI is using Jasmine 2.6 for our unit tests ([http://jasmine.github.io/2.6/introduction.html](http://jasmine.github.io/2.0/introduction.html)).
    Jasmine has some of the best documentations available and the overall framework
    is very intuitive to use. We strongly recommend that you head over to the Jasmine
    site and get yourself familiar with the framework before you proceed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Jasmine框架文档，了解如何使用Jasmine编写单元测试。CLI正在使用Jasmine 2.6进行我们的单元测试（[http://jasmine.github.io/2.6/introduction.html](http://jasmine.github.io/2.0/introduction.html)）。Jasmine拥有一些最好的文档，并且整个框架非常直观易用。我们强烈建议您访问Jasmine网站，在继续之前熟悉这个框架。
- en: 'Open the  `seconds-to-time.pipe.spec.ts` file in the `trainer/src/app/shared `
    folder and update the unit test in there as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trainer/src/app/shared`文件夹中打开`seconds-to-time.pipe.spec.ts`文件，并按照以下方式更新那里的单元测试：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's take a look at what we are doing here in our test file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在我们的测试文件中我们正在做什么。
- en: 'Not surprisingly, we import `SecondsToTimePipe`, which we are going to test.
    This is just like the imports we have used elsewhere in our TypeScript classes.
    Notice that we use a relative path to the file in which it is located `''./seconds-to-time.pipe''`.
    In Angular, this means to look for the component to test in the same directory
    as the test itself. As you recall, this is the way we set up our file structure:
    putting our tests in the same directory as the file under test.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们导入了`SecondsToTimePipe`，这是我们将要测试的。这就像我们在TypeScript类中其他地方使用的导入一样。请注意，我们使用了一个相对路径来指向该文件的位置
    `'./seconds-to-time.pipe'`。在Angular中，这意味着在测试本身所在的目录中查找要测试的组件。如您所回忆的，这是我们设置文件结构的方式：将我们的测试放在与被测试文件相同的目录中。
- en: In the next line, we start using Jasmine syntax. First, we wrap the test in
    a `describe` function that identifies the test. The first parameter of this function
    is a user-friendly description of the test; in this case, it is `SecondsToTimePipe`.
    For the second parameter, we pass a lambda (fat arrow) function that will contain
    our test. After setting up a local variable to hold the pipe, we call Jasmine's
    `beforeEach` function and use this to inject an instance of our pipe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们开始使用Jasmine语法。首先，我们用`describe`函数包裹测试以标识测试。这个函数的第一个参数是对测试的用户友好描述；在这种情况下，它是`SecondsToTimePipe`。对于第二个参数，我们传递一个lambda（胖箭头）函数，它将包含我们的测试。在设置一个本地变量来保存管道后，我们调用Jasmine的`beforeEach`函数，并使用它来注入我们的管道实例。
- en: Since the `beforeEach` function runs before every test that is in our `describe` function,
    we can use it for common code that will run in each of our tests. In this case,
    it is not strictly necessary since there is only one test in our `describe` function.
    But it is a good idea to get into the habit of using it for common setup scenarios,
    as we will see going forward.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`beforeEach`函数在`describe`函数中的每个测试之前运行，我们可以用它来运行每个测试中都会运行的公共代码。在这种情况下，它不是严格必要的，因为我们的`describe`函数中只有一个测试。但养成使用它的习惯是一个好主意，正如我们将看到的那样。
- en: Next, we call Jasmine's `it` function and pass it a title, along with three
    calls to Jasmine's `expect` function (Jasmine's name for assertions). These are
    all self-explanatory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用Jasmine的`it`函数，并传递一个标题，以及三个对Jasmine的`expect`函数（Jasmine对断言的称呼）的调用。这些都是不言自明的。
- en: It is not necessary to explicitly import these Jasmine functions in our test.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中不需要显式导入这些Jasmine函数。
- en: Running our test files
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的测试文件
- en: 'Now it''s time to run our tests using the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用以下命令运行我们的测试了：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Angular CLI will transpile our TypeScript files to JavaScript and then watch
    for changes in these files.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI将把我们的TypeScript文件转换为JavaScript，并监视这些文件的变化。
- en: 'We should then see this output in the Terminal window (the total number of
    tests may be different for you):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在终端窗口中看到这个输出（对于您来说，测试的总数可能不同）：
- en: '![](img/00072.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: The last line shows that our test passed successfully (along with all our other
    tests).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行显示我们的测试成功通过（以及我们所有的其他测试）。
- en: 'You can also view the test results in the browser window that Karma will launch
    when it runs our tests:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在Karma运行我们的测试时它启动的浏览器窗口中查看测试结果：
- en: '![](img/00073.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00073.jpeg)'
- en: You'll notice here that Karma displays the `describe` statement (SecondsToTimePipe)
    that is used for our pipe tests and nests under it under the `it` statement (should
    convert integer to time format) for the test we have created in order to show
    us the expected results for our test. Reading the results as they are displayed
    makes it very easy to understand the outcome of our test.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这里，Karma 显示了用于我们管道测试的 `describe` 语句（SecondsToTimePipe），并且在其下嵌套了 `it` 语句（应将整数转换为时间格式），以展示我们创建的测试的预期结果。以显示的格式读取结果使得理解测试结果变得非常容易。
- en: 'To make sure that it is reporting the correct pass/fail results, let''s make
    a change in the test to cause one of the expectations to fail. Change the time
    in the first expectation to six seconds rather than five, like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它报告正确的通过/失败结果，让我们在测试中做一个更改，导致其中一个期望失败。将第一个期望中的时间从五秒更改为六秒，如下所示：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We get the following error message:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下错误消息：
- en: '![](img/00074.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00074.jpeg)'
- en: What's nice about this error message is that it combines the `describe` and
    `it` descriptions into a complete sentence that provides a clear summary of the
    error. This shows how Jasmine allows us to write readable tests so that someone
    who is new to our code can quickly understand any problems that may arise in it.
    The next line shows us which expectation was not met, what was expected, and what
    the actual results were that did not meet this expectation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误消息的优点是它将 `describe` 和 `it` 描述合并成一个完整的句子，提供了对错误的清晰总结。这显示了 Jasmine 如何允许我们编写可读的测试，以便新接触我们代码的人可以快速理解其中可能出现的任何问题。下一行显示了哪个期望未满足，期望的是什么，以及实际结果是什么，这些结果没有满足这个期望。
- en: 'We also get a stack trace below this message and a final line that shows the
    overall results of our tests:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此消息下方，我们还得到一个堆栈跟踪和一个显示我们测试总体结果的最后一条线：
- en: '![](img/00075.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00075.jpeg)'
- en: 'And in the browser, we see the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们看到以下内容：
- en: '![](img/00076.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00076.jpeg)'
- en: One thing you'll notice is that when we make the change to our test, we do not
    have to rerun Karma. Instead, it watches for any changes in our files and related
    tests and immediately reports success or failure whenever we make a change.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当我们更改测试时，我们不必重新运行 Karma。相反，它监视我们文件和相关测试的任何更改，并在我们做出更改时立即报告成功或失败。
- en: Pretty cool! Let's undo the last change that we made and put the test back into
    a passing state.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 非常酷！让我们撤销我们做的最后一个更改，将测试恢复到通过状态。
- en: Unit-testing components
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试组件
- en: Testing Angular components is more complicated than testing simple pipes or
    services. That is because Angular components are associated with views and also
    usually have more dependencies than services, filters, or directives.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 Angular 组件比测试简单的管道或服务更复杂。这是因为 Angular 组件与视图相关联，并且通常比服务、过滤器或指令有更多的依赖项。
- en: Angular testing utilities
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 测试实用工具
- en: Because of their complexity, Angular has introduced utilities that enable us
    to test our components more easily. These testing utilities include the `TestBed`
    class (which we previously used to initialize our tests) and several helper functions
    in `@angular/core/testing`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的复杂性，Angular 引入了使我们可以更容易地测试组件的实用工具。这些测试实用工具包括 `TestBed` 类（我们之前用来初始化测试的）和
    `@angular/core/testing` 中的几个辅助函数。
- en: '`TestBed` has a `createComponent` method that returns a `ComponentFixture`
    containing several members and methods, including:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestBed` 有一个 `createComponent` 方法，它返回一个包含多个成员和方法的 `ComponentFixture`，包括：'
- en: '`debugElement`: For debugging a component'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debugElement`：用于调试组件'
- en: '`componentInstance`: For accessing the component properties and methods'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentInstance`：用于访问组件属性和方法'
- en: '`nativeElement`: For accessing the view''s markup and other DOM elements'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nativeElement`：用于访问视图的标记和其它DOM元素'
- en: '`detectChanges`: For triggering the component''s change detection cycle'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detectChanges`：用于触发组件的变更检测周期'
- en: '`ComnponentFixture` also contains methods for overriding the view, directives,
    bindings, and providers of a component. Going forward, we will be using `TestBed`
    throughout the rest of our tests.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComnponentFixture` 还包含用于覆盖组件视图、指令、绑定和提供者的方法。从现在开始，我们将在剩余的测试中使用 `TestBed`。'
- en: '`TestBed` has a method called `configureTestingModule` that we can use to set
    up our testing as its own module. This means we can bypass the initial bootstrap
    process and compile our components under test within our test files. We can also
    use `TestBed` to specify additional dependencies and identify the providers that
    we will need.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestBed` 有一个名为 `configureTestingModule` 的方法，我们可以使用它来设置我们的测试作为一个单独的模块。这意味着我们可以绕过初始引导过程，并在我们的测试文件中编译要测试的组件。我们还可以使用
    `TestBed` 来指定额外的依赖项并识别我们需要的提供者。'
- en: According to the Angular documentation (https://angular.io/guide/testing#testbed-class-summary),
    it is important to *call TestBed methods within a* `beforeEach`*to ensure a fresh
    start before each individual test*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Angular文档（https://angular.io/guide/testing#testbed-class-summary），在 `beforeEach`
    中调用 `TestBed` 方法对于确保每个单独测试前的全新开始非常重要。
- en: Managing dependencies in our tests
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的测试中管理依赖项
- en: Components in Angular integrate the view with everything else. Due to this,
    components normally have more dependencies compared to any of the services, filters,
    or directives.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 中的组件将视图与所有其他内容集成。因此，与任何服务、过滤器或指令相比，组件通常有更多的依赖项。
- en: Notwithstanding the fact that our unit tests focus on the code within the component
    itself, we still need to account for these dependencies in our tests or else the
    tests will fail (we skipped the dependency setup for pipe testing as it did not
    have external dependencies).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的单元测试专注于组件内部的代码，但我们仍然需要在测试中考虑这些依赖项，否则测试将失败（我们跳过了管道测试的依赖项设置，因为它没有外部依赖）。
- en: 'Two approaches exist for handling these dependencies: inject them into our
    component or create a mock or fake for them that we can use in our tests. If a
    dependency is simple enough, we can just inject an instance of it into our test
    class. However, if the dependency is significantly complicated, especially if
    it has dependencies of its own and/or makes remote server calls, then we should
    be mocking it. The Angular testing library provides the tools for us to do that.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些依赖项有两种方法：将它们注入到我们的组件中或为它们创建一个模拟或伪造，我们可以在测试中使用它。如果一个依赖项足够简单，我们只需将其实例注入到测试类中即可。然而，如果一个依赖项非常复杂，特别是如果它有自己的依赖项并且/或者进行远程服务器调用，那么我们应该模拟它。Angular
    测试库为我们提供了进行此操作的工具。
- en: The component that we plan to test in this section is the `WorkoutRunner` component.
    Located inside `trainer/src/components/workout-runner/`, this is the component
    that runs a specific workout.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节计划测试的组件是 `WorkoutRunner` 组件。位于 `trainer/src/components/workout-runner/`
    中，这是运行特定锻炼的组件。
- en: Unit-testing WorkoutRunnerComponent
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试 WorkoutRunnerComponent
- en: With this background, let's get started with unit testing `WorkoutRunnerComponent`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，让我们开始对 `WorkoutRunnerComponent` 进行单元测试。
- en: 'First, open `workout-runner-component.spec.ts` and update the imports to the
    following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 `workout-runner-component.spec.ts` 并更新导入如下：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These imports identify the test utilities (and things such as `Router` and `of`
    from `RxJS`) that we will be using in our tests along with the types and dependencies
    that our component requires. We'll discuss these dependencies in a moment. One
    import that looks different from the others is the one that imports `NO_ERRORS_SCHEMA`
    from `@angular/core`. We will use this import to ignore elements in the component
    that we will not be testing. Again, we will discuss that further in a moment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些导入标识了我们在测试中将使用的测试工具（以及来自 `RxJS` 的 `Router` 和 `of` 等东西），以及我们的组件所需的类型和依赖项。我们稍后会讨论这些依赖项。其中一个与其他导入不同的导入是导入
    `@angular/core` 中的 `NO_ERRORS_SCHEMA`。我们将使用这个导入来忽略我们不会测试的组件中的元素。同样，我们稍后会进一步讨论这一点。
- en: One more thing to note with the imports is that `@angular/core/testing` is a
    part of the core module and not in a separate testing module. This is a common
    pattern with imports for Angular testing. For example, when we get to testing
    HTTP, you will see that we are importing from `@angular/http/testing`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于导入还有一点需要注意，即 `@angular/core/testing` 是核心模块的一部分，而不是单独的测试模块。这是Angular测试导入的常见模式。例如，当我们到达HTTP测试时，你会看到我们是从
    `@angular/http/testing` 导入的。
- en: Setting up component dependencies
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置组件依赖项
- en: 'Next, we need to establish our component''s dependencies and determine whether
    we need to inject or mock them. If we look at the code for the `WorkoutRunner`
    component, we see that there are three dependencies being injected into our component:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定我们的组件依赖项，并确定我们是否需要注入或模拟它们。如果我们查看 `WorkoutRunner` 组件的代码，我们会看到有三个依赖项被注入到我们的组件中：
- en: '`WorkoutHistoryTracker`: This is a component that has some behavior attached
    to it. So we definitely want to mock it.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Router`: We''ll have to mock this too in order to isolate `WorkoutRunner`
    from the rest of the application and prevent our test from trying to navigate
    away from the `WorkoutRunner` view.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorkoutService:` This is a service that we will use to make an HTTP call to
    retrieve our workouts. We will mock this service as well since we don''t want
    to be making a call to an external system within our test.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking dependencies - workout history tracker
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular allows us to mock our dependencies in a straightforward manner using
    simple classes. Let''s start with mocking `WorkoutHistoryTracker`. To do that,
    add the following class just after the imports:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We do not need to mock the entire `WorkoutHistoryTracker` class, but only the
    methods that `WorkoutRunner` will be calling. In this case, those methods are
    `startTracking()`, `endTracking()`, and `exerciseComplete()`. We have made these
    methods empty because we do not need anything returned from them in order to test
    `WorkoutRunner`. Now we can inject this dummy implementation into `WorkoutRunner` wherever
    it is looking for `WorkoutHistoryTracker`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Mocking dependencies – workout service
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Chapter 5, *Supporting Server Data Persistence*, we extended the workout
    service to make a remote call to retrieve the data that populates a workout. For
    unit testing the workout runner, we will want to replace that call with a mock
    implementation that returns some static data that we can use to run the test.
    So we will add a third mock class, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that the `getWorkout` method is returning an `Observable`, as indicated
    by the use of the `of` operator. Otherwise the class is self-explanatory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Mocking dependencies - router
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with `WorkoutHistoryTracker` and `WorkoutService`, we also will be using
    mocking to handle the dependency that we have on the Angular router. But here
    we will be taking a slightly different approach. We will assign a Jasmine spy
    to a `navigate` method on our mock:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will be sufficient for our purposes because we only want to make sure that
    the router's `navigate` method is being called with the appropriate route (`finished`)
    as a parameter. The Jasmine spy will allow us to do that as we will see later.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our test using TestBed
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our imports and dependencies out of the way, let''s get started
    with the tests themselves. We begin by adding a Jasmine `describe` function that
    will wrap our tests, followed by setting two local variables using `let`: one
    for `fixture` and the other for `runner`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next we''ll add a `beforeEach` function that sets up our test configuration:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `beforeEach` method executes before each test, which means that we will
    only have to set this up once in our test file. Inside `beforeEach`, we add an
    `async` call. This is required because of the asynchronous `compileComponents`
    method that we are calling.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The Angular documentation indicates that the `async` function arranges for the
    tester's code to run in a special `async` test zone that hides the mechanics of
    asynchronous execution, just as it does when passed to an `it` test. For more
    information refer to `https://angular.io/docs/ts/latest/guide/testing.html#!#async-in-before-each`.
    We'll discuss this in more detail shortly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Angular文档表明，`async`函数安排测试者的代码在一个特殊的`async`测试区域内运行，这个区域隐藏了异步执行的机制，就像它传递给`it`测试时一样。有关更多信息，请参阅`https://angular.io/docs/ts/latest/guide/testing.html#!#async-in-before-each`。我们将在稍后详细讨论这一点。
- en: Let's go through each method call in the order that they are executed. The first
    method, `configureTestingModule`, allows us to build on the base configuration
    of the testing module and add things such as imports, declarations (of the components,
    directives, and pipes we will be using in our test), and providers. In the case
    of our test, we are first adding declarations for the workout runner, our component
    under test, and the `SecondsToTimePipe:`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照它们执行的顺序逐一查看每个方法调用。第一个方法是`configureTestingModule`，它允许我们在测试模块的基本配置上构建，并添加诸如导入、声明（我们将在测试中使用的组件、指令和管道）和提供者等。在我们的测试中，我们首先添加了关于锻炼运行者、我们正在测试的组件以及`SecondsToTimePipe`的声明：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we add three providers for our `Router`, `WorkoutHistoryTracker`, and
    `WorkoutService`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为我们的`Router`、`WorkoutHistoryTracker`和`WorkoutService`添加了三个提供者：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For each of these providers, we set the `useClass` property to our mocks instead
    of the actual components. Now, anywhere in our test, when the `WorkoutRunner`
    requires any of these components, the mock will be used instead.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些提供者中的每一个，我们将`useClass`属性设置为我们的模拟而不是实际组件。现在，在我们的测试中，当`WorkoutRunner`需要这些组件中的任何一个时，将使用模拟。
- en: 'The next configuration may seem a bit mysterious:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配置可能看起来有点神秘：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This setting allows us to bypass the errors we would otherwise get regarding
    the custom elements associated with two components that we are using in the component's
    template: `ExerciseDescriptionComponent` and `VideoPlayerComponent`. At this point,
    we don't want to be testing these components within the test for the `WorkoutRunnerComponent`.
    Instead, we should be testing them separately. One thing to be aware of, however,
    when you use this setting is that it will suppress all schema errors related to
    elements and attributes in the template of the component under test; so it may
    hide other errors that you do want to see.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置允许我们绕过与我们在组件模板中使用的两个组件（`ExerciseDescriptionComponent`和`VideoPlayerComponent`）相关的自定义元素可能产生的错误。在这个阶段，我们不想在`WorkoutRunnerComponent`的测试中测试这些组件。相反，我们应该单独测试它们。然而，需要注意的是，当你使用这个设置时，它将抑制与测试组件模板中的元素和属性相关的所有模式错误；因此，它可能会隐藏你希望看到的其他错误。
- en: When you set up a test using `NO_ERRORS_SCHEMA`, you are creating what is called
    a shallow test, one that does not go deeper than the component you are testing.
    Shallow tests allow you to reduce complexities in the templates within the component
    you are testing and reduce the need for mocking dependencies.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`NO_ERRORS_SCHEMA`设置测试时，你正在创建一个所谓的浅测试，它不会深入到你正在测试的组件。浅测试允许你减少你正在测试的组件模板中的复杂性，并减少对模拟依赖的需求。
- en: 'The final steps in the configuration of our test are to compile and instantiate
    our components:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试配置的最后一步是编译和实例化我们的组件：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As mentioned previously, we are using an `async` function in our `beforeEach`
    method because this is required when we call the `compileComponents` method. This
    method call is asynchronous and we need to use it here because our component has
    an external template that is specified in a `templateUrl`. This method compiles
    that external template and then inlines it so that it can be used by the `createComponent`
    method (which is synchronous) to create our component fixture. This component
    fixture in turn contains a `componentInstance`-`WorkoutRunner`. We then assign
    both the `fixture` and the `componentInstance` to local variables.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们在`beforeEach`方法中使用了一个`async`函数，因为当我们调用`compileComponents`方法时这是必需的。这个方法调用是异步的，我们需要在这里使用它，因为我们的组件有一个外部模板，该模板在`templateUrl`中指定。此方法编译该外部模板，然后将其内联，以便它可以由`createComponent`方法（它是同步的）使用来创建我们的组件固定装置。这个组件固定装置反过来包含一个`componentInstance`-`WorkoutRunner`。然后我们将`fixture`和`componentInstance`都分配给局部变量。
- en: As mentioned previously, the `async` function we are using creates a special
    `async` test zone in which our tests will run. You'll notice that this function
    is simplified from normal `async` programming and lets us do things such as using
    the `.then` operator without returning a promise.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: You can also compile and instantiate test components inside individual test
    methods. But the `beforeEach` method allows us to do it once for all our tests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have configured our test, let's move on to unit-testing `WorkoutRunner`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Starting unit testing
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from the loading of workout data to transitioning of exercises, pausing
    workouts, and running exercise videos, there are a number of aspects of the `WorkoutRunner`
    that we can test. The `workout.spec.ts` file (available in the `components/workout-runner`
    folder under `trainer/src`) contains a number of unit tests that cover the preceding
    scenarios. We will pick up some of those tests and work through them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s add a test case that verifies that the workout starts
    running once the component is loaded:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This test asserts that the total duration of the workout is correct and the
    workout is in the running state (that is, not paused).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: So let's execute the test. It fails (check the Karma console). Strange! All
    the dependencies have been set up correctly, but still the second `expect` function
    of the `it` block fails as it is undefined.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: We need to debug this test.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Debugging unit tests in Karma
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging unit tests in Karma is easy as the tests are run in the browser. We
    debug tests as we debug the standard JavaScript code. And since our Karma configuration
    has added mappings from our TypeScript files to our JavaScript files, we can debug
    directly in TypeScript.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: When Karma starts, it opens a specific browser window to run the tests. To debug
    any test in Karma, we just need to click on the Debug button available at the
    top of the browser window.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: There is one window opened by Karma and one when we click on Debug; we can use
    the original window for testing too, but the original window is connected to Karma
    and does a live reload. Also, the script files in the original window are timestamped,
    which changes whenever we update the test and hence requires us to put in a breakpoint
    again to test.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Once we click on Debug, a new tab/window opens with all the tests and other
    app scripts loaded for testing. These are scripts that were defined during the
    Karma configuration setup in the `karma.conf.js` files section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: To debug the preceding failure, we need to add breakpoints at two locations.
    One should be added inside the test itself and the second one inside  `WorkoutComponent`,
    where it loads the workout and assigns the data to the appropriate local variables.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to add a breakpoint in Google Chrome:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Open the Karma debug window/tab by clicking on the Debug button on the window
    loaded by Karma when it started.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the F12 key to open the developer console.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Sources tab and the TypeScript files for your application will be
    located in the `source` folder.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now put breakpoints at the required locations just by clicking on the
    line number. This is the standard mechanism to debug any script. Add breakpoints
    at the locations highlighted here:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: We refresh the Debug page (the one we opened when we clicked on the Debug button).
    The breakpoint in `workout-runner.ts` is never hit, causing the test to fail.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What we overlooked is that the code that we were trying to reach is within
    the `start` method of `workout-runner`, and the `start` method is not being called
    in the constructor. Instead it is called in `ngDoCheck` after the data for the
    workout has been loaded through a call to the `getWorkout` method in `ngOnInit`.
    Add calls to `ngOnInit` and `ngDoCheck` in your test, like so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save the change and Karma will run the test again. This time it will pass.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the number of tests grows, unit testing may require us to concentrate on
    a specific test or a specific suite of tests. Karma allows us to target one or
    more tests by prepending `f` to the existing `it` block; that is, `it` becomes
    `fit`. If Karma finds tests with `fit`, it only executes those tests. Similarly,
    a specific test suite can be targeted by prepending `f` to the existing `describe`
    block: `fdescribe`. Also, if you prepend `x` to an `it` block, making it `xit`,
    then that block will be skipped.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue unit-testing the component!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing WorkoutRunner continued...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What other interesting things can we test? We can test whether the first exercise
    has started. We add this test to `workout.spec.ts` after the one we just added:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second `expect` function in this test is interesting. It uses a Jasmine
    feature: spies. Spies can be used to verify method invocations and dependencies.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Using Jasmine spies to verify method invocations
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A spy is an object that intercepts every call to the function it is spying on.
    Once the call is intercepted, it can either return fixed data or pass the call
    to the actual function being invoked. It also records the call invocation details
    that can be used later in `expect` as we did in the preceding test.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Spies are very powerful and can be used in a number of ways during unit testing.
    Look at the documentation on spies at [http://jasmine.github.io/2.0/introduction.html#section-Spies](http://jasmine.github.io/2.0/introduction.html#section-Spies)
    to learn more about them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The second `expect` function verifies that the `startExercise` method was called
    when the workout started (`toHaveBeenCalledWith`). It is also asserting the correctness
    of the parameters passed to the function. The second `expect` statement asserts
    the behavior using a spy, but we first need to set up the spy to make this assert
    work.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using the spy to mock a call to the `startExercise` method.
    We can use the spy to determine whether the method has been called and with what
    parameters, using Jasmine's `toHaveBeenCalledWith` function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Look at the Jasmine documentation for the `toHaveBeenCalled` and `toHaveBeenCalledWith`
    functions to learn more about these assert functions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Here, the method is being called with the current `Exercise` as a parameter.
    Since the previous `expect` confirms that this is the first exercise, this `expect`
    confirms that a call to start that first exercise was executed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of things to note here. First, you have to be careful to
    put the setup for `spyOn` prior to calling `ngOnInit`. Otherwise, the spy will
    not be *spying* when the `startExercise` method is called and the method invocation
    will not be captured.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Second, since the spy is a mock, we will normally not be able to verify anything
    within the `startExercise` method. This is because the method itself is being
    mocked. This means that we cannot actually verify that the `currentExercise` property
    has been set, since that is being done inside the mocked method. However, Jasmine
    allows us to chain the spy with `and.callThrough`, which will mean that in addition
    to tracking the calls to the method, it will delegate to the actual implementation.
    This then allows us to test that the `currentExercise` has also been set correctly
    inside the `startExercise` method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Using Jasmine spies to verify dependencies
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we just used a spy to verify the call to a method within our class, Jasmine
    spies are also useful in mocking calls to external dependencies. But why test
    calls to our external dependencies at all? After all, we are trying to limit our
    testing to the component itself!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we mock a dependency to make sure that the dependency does
    not adversely affect the component under test. From a unit testing perspective,
    we still need to make sure that these dependencies are called by the component
    being tested at the right time with the correct input. In the Jasmine world, spies
    help us assert whether dependencies were invoked correctly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the `WorkoutRunner` implementation, we emit a message with the
    details of the workout whenever the workout starts. An external dependency, `WorkoutHistoryTracker`,
    subscribes to this message/event. So let's create a spy and confirm that `WorkoutHistoryTracker`
    started when the workout started.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this `it` block after the preceding one:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Within the `it` block, we add a spy on the `tracker`, a local instance of the
    `WorkoutHistoryTracker`. Then we use the spy to verify that the `startTracking`
    method of that dependency has been called. Simple and expressive!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: You may recall that we are using `MockHistoryWorkoutTracker` here; it contains
    a mock, a `startTracking` method that is empty and returns nothing. That is fine
    because we are not testing the `WorkoutHistoryTracker` itself, but just the method
    invocation on it being made by the `WorkoutRunner`. This test shows how useful
    it is to be able to combine mocks with spies to fully test the inner workings
    of the `WorkoutRunner`, separately and apart from its dependencies.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Testing event emitters
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examining the code for the `WorkoutRunner`, we see that it sets up several
    event emitters that look like the following one for `workoutStarted`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Angular documentation describes an event emitter as an output property that
    fires events to which we can subscribe with an event binding. In Chapter 2, *Building
    Our First App - 7 Minute Workout*, we described in detail how event emitters are
    used in Workout Runner. So we have a good understanding of what they do. But how
    do we unit-test our event emitters and determine that they are firing events in
    the way we expect?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s actually pretty easy to do. If we remember that an event emitter is an
    Observable Subject to which we can subscribe, we realize that we can simply subscribe
    to it in our unit test. Let''s revisit our test that verifies that a workout is
    starting and add the highlighted code to it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We injected the `WorkoutService` and added a subscription to the `WorkoutStarted`
    event emitter and an expectation that checks to see whether the property is emitting
    a `WorkoutPlan` when the event is triggered. The subscription is placed before
    `ngOnInit` because that is the method that results in the `workoutStarted` event
    being triggered, and we need to have our subscription in place before that happens.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Testing interval and timeout implementations
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the interesting challenges for us is to verify that the workout progresses
    as time elapses. The `Workout` component uses `setInterval` to move things forward
    with time. How can we simulate time without actually waiting?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The answer is the Angular testing library's `fakeAsync` function, which allows
    us to run otherwise asynchronous code synchronously. It does this by wrapping
    the function to be executed in a `fakeAsync` zone. It then supports using synchronous
    timers within that zone and also allows us to simulate the asynchronous passage
    of time with `tick()`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: For more information about `fakeAsync`, see the Angular documentation at [https://angular.io/guide/testing#async-test-with-fakeasync.](https://angular.io/guide/testing#async-test-with-fakeasync)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can use the `fakeAsync` function to test the timeout and
    interval implementations in our code. Add the following test to `workout-runner.spec.ts`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In addition to injecting `WorkoutRunner`, we first wrap the test in `fakeAsync`.
    Then we add a call to the `WorkoutRunner`'s `ngOnit()` method. This kicks off
    the timers for the exercises within `WorkoutRunner`. Then within the test, we
    use the `tick()` function set at various durations to test the operation of the
    timer for an exercise, and make sure that it continues running for the duration
    that we expected it to run. Using `tick()` allows us to fast forward through the
    code and avoid having to wait for the exercise to complete over several seconds
    as it would if we ran the code asynchronously.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we call `discardPeriodicTasks()` . This method is one of the Angular
    testing utilities and it can be used with  `fakeAsync` to clear any pending timers
    that may be in the task queue.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: More information about these and other Angular testing utilities can be found
    at [https://angular.io/guide/testing#testing-utility-apis](https://angular.io/guide/testing#testing-utility-apis)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try another similar test. We want to make sure that the `WorkoutRunner`
    is correctly transitioning from one exercise to the next. Add the following test
    to `workout-runner.ts`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again we wrap the test in `fakeAsync` and call `runner.ngOnInit` to start the
    timer. Then we grab the duration of the first exercise and use the `tick()` function
    within the following `TestHelper` method to advance the timer one second beyond
    the duration of that exercise:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we test the expectation that we are now in the `rest` exercise and thus
    have transitioned from the first exercise.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Testing workout pause and resume
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we pause a workout, it should stop and the time counter should not lapse.
    To check this, add the following time test:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The test starts with verifying the state of the workout as not paused, advances
    the time for one second, pauses it, and then verifies that the time of `workoutTimeRemaining`
    does not change after the pause.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing services
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing of services is not much different from unit-testing components.
    Once we get the hang of how to set up a component and its dependencies (mostly
    using mocks), it becomes a routine affair to apply that learning to testing services.
    More often than not, the challenge is to set up the dependencies for the services
    so that testing can be done effectively.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Things are a little different for services that make remote requests (using
    either `http` or `jsonp`). There is some setup required before we can test such
    services in isolation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We will target `WorkoutService` and write some unit tests for it. Since this
    service makes remote requests to load workout data, we will explore how to test
    such a service with a mock HTTP backend. Angular provides us with the `HttpTestingController` for doing
    that.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Mocking HTTP request/response with HttpTestingController
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When testing services (or, as a matter of fact, any other Angular construct)
    that make remote requests, we obviously do not want to make actual requests to
    a backend to check the behavior. That does not even qualify for a unit test. The
    backend interaction just needs to be mocked away. Angular provides for precisely
    that. Using `HttpTestingController`, we intercept HTTP requests, mock actual responses
    from the server, and assert endpoints invocation too.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-service.spec.ts`  and add the following import statements at
    the top of the file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In addition to the imports from the `core/testing` module, we are importing
    both `HttpClientTestingModule`  and  `HttpTestingController` from the `http/testing`
     module. We are also importing `WorkoutService` and `WorkoutPlan` that we will
    be testing.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the imports in place, we will begin creating the test with the
    Jasmine `describe`  statement that wraps our tests, and will set several local
    variables:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In addition to creating local variables for `HttpClient`, `HttpTestingController`,
    and `WorkoutService`, you'll also notice that we are setting local variables for
    our Mongo connection. To be clear, we are not setting these variables in order
    to make a remote call to Mongo, but instead to test that the connection properties
    are being set properly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is set up the providers and dependency injection for our tests.
    To handle the providers, add the following to the test file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we call `TestBed.configureTestingModule`  to import the `HttpClientTestingModule`
    and add the `WorkoutService`. According to the Angular documentation ([https://angular.io/api/common/http/testing/HttpClientTestingModule](https://angular.io/api/common/http/testing/HttpClientTestingModule)), `HttpClientTestingModule`
    sets up `HttpClient` to use `HttpClientTestingBackend` as `HttpBackend`. The nice
    thing here is that this setup is completely hidden from our test setup, so we
    don't have to write code to wire this up.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we use the `TestBed.get` method to populate our local variables—`httpClient`,
    `httpTestingController`, and `workoutService`. We''ll also add the following `afterEach`
    method to make sure that after every test completes there are no more pending
    requests:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this setup in place, we are now in a position to create tests for `WorkoutService`
    that avoid us making a remote call. We''ll start with a simple test that makes
    sure that `workoutService` loads:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While this test may seem trivial, it is important to place it here because it
    acts as a check to make sure that we have set up our configuration correctly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll add the following test to make sure that we are able to inject `HttpClient`
    when we instantiate `WorkoutService`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we''ll move to testing several of the methods in the workout-service.
    First, we will make sure that it returns all workouts when the `getWorkouts` method
    is called. To do that, add the following test:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We'll start by declaring two arrays of `WorkoutPlans`—`expectedWorkouts` and
    `actualWorkouts`. We'll then populate `expectedWorkouts` with four  `WorkoutPlans`.
    Because we are testing retrieval of the `WorkoutPlans` and not their content,
    we have made these minimal workouts.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Since the `Http` module returns `RxJS` Observables, we next use the pattern
    of subscribing to those Observables. You should be used to seeing this pattern
    from our coverage of Observables in Chapter 5, *Supporting Server Data Persistence*.
    Notice that we use `fail` as the second parameter, which will cause the test to
    fail if there is an issue with subscribing to the Observable.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we call a method on the `HttpTestingController` named `expectOne` passing
    our request URL. According to the Angular documentation ([https://angular.io/api/common/http/testing/HttpTestingController#expectone](https://angular.io/api/common/http/testing/HttpTestingController#expectone)),
    this method does two things: it expectsthat a request has been made that matches
    the URL provided in the method call and it returns a mock request. In the next
    line we make sure that the mock request is an HTTP GET. Finally, we flush the
    request with the `expectedWorkouts` and confirm that the `actualWorkouts` equal
    the `expectedWorkouts`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll follow the same pattern to build additional tests that confirm that
    we are able to do the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Return a `workout` plan with a specific name
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map `exercises` correctly within the `getWorkout` method
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can review these tests in the code for `checkpoint 7.2`. But one thing
    to note is that in both these tests we are testing two HTTP calls. For example,
    here is the code in the second of these two tests:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This may seem a little confusing at first until we realize that with the `getWorkout`
    method we are actually making two `Http` calls: one to retrieve a  `workout` and
    one to retrieve all  `exercises`. As you recall from Chapter 5, *Supporting Server
    Data Persistence*, we are doing that in order to create a fuller description of
    each `exercise` that is included within `workout`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: With that, we are finished with testing our service.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to learn how to test directives. The next section is dedicated
    to understanding the challenges in directive testing and how to overcome them.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing directives
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No other Angular constructs that we have tested so far do not involve any UI
    interaction. But directives, as we know, are a different beast. Directives are
    all about enhancing a component's view and extending the behavior of HTML elements.
    While testing directives, we cannot ignore the UI connections, and hence directive
    testing may not strictly qualify as unit testing.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'The good thing about directive testing is that its setup process is not as
    elaborate as that for services or components. The pattern to follow while unit-testing
    directives is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Take an HTML fragment containing the directive markup
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and link it to a mock component
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the generated HTML has the required attributes
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify if the changes that the directive created changes the state
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TestBed class
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, Angular provides the `TestBed` class to facilitate
    this kind of UI testing. We can use it to dig into the markup in a component's
    view and check for DOM changes that are triggered by events. Armed with this tool,
    let's get started with the testing of our directives. In this section, we are
    going to test `remoteValidator`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: This will be a good time to revisit the directives that we built in the previous
    chapter. Also, keep the code handy for the tests that we will create in the following
    sections.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Testing remote validator
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with unit-testing `remoteValidatorDirective`. Just to refresh our
    memory, `remoteValidatorDirective` validates an input against remote rules. It
    does so by calling a component method that returns a promise. If the promise is
    resolved with success, the validation passes; otherwise, the validation fails.
    The `[validateFunction]` attribute provides the link between the DOM and the component's
    method that checks for the duplication.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Similar to our other test files, we have a `remote-validator.directive.spec.ts`
    file in the shared folder. Refer to the file in `checkpoint 7.2` for the imports,
    which we will not cover at this point.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Just below the import statements, add the following component definition:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This component looks a lot like the components that we set up in our other tests
    to mock dependencies. Here, however, it is serving a slightly different purpose;
    it is acting as a host container for the directive that we will be testing. Using
    this minimal component, lets us avoid having to load the actual host for this
    directive, which is the `Workout` component.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice here is that we have set up a method for `validateWorkoutName`
    that will be called by our directive. It is essentially a stub that just returns
    a resolved `Promise` of `false`. Remember that we are not concerned with how this
    method handles its validation, but with verifying that the directive calls it
    and returns the correct result, either `true` or `false`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set up the `describe` statement for our test suite by adding the following
    code, which injects  `RemoteValidatorDirective` into our tests:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, we are setting up local variables for  `fixture`, its `componentInstance`,
    and `debugElement`. We are also using `by.css` (which we will see more of in our
    end-to-end tests) along with the query method on  `debugElement` to extract the
    `workoutName` input from our component. We'll be using these to delve into the
    rendered HTML in our directive.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to write our individual tests. First, we''ll write a test
    to confirm that we have been able to load  `RemoteValidatorDirective`. So add
    the following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What''s interesting about this test is that using the `debugElement`, we have
    been able to drill-down into the attributes of the input tag in our host component
    and find our validator, confirming that it has indeed been loaded. Also notice
    the use of `fakeAsync`, which we discussed in connection with unit testing. Using
    it makes it possible for us to write our tests in a synchronous fashion and avoid
    the complications that would otherwise exist with trying to manage the asynchronous
    rendering of our host component. Next, we''ll write two tests to confirm that
    our validator is working properly. The first test will make sure that an error
    is created if remote validation fails (that is, a workout with the same name as
    the one we are using is found). Add the following code for that test:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Again, we are using `fakeAsync` to eliminate the challenges that we would otherwise
    have with the async behavior associated with the rendering and execution of our
    `remoteValidatorDirective`. Next, we add a spy to track the invocation of the
    `validateWorkoutName` method. We also set the spy to call through to our method,
    because in this case, we are expecting it to return false. The spy is being used
    to verify that our method has indeed been invoked. Next, we set `fixture.detectChanges`,
    which triggers a change detection cycle. We then set the value of our input and
    call tick, which will, we hope, trigger the response we are expecting from our
    remote validator. We then grab the form encapsulating our input tag using the
    injector that is available from the child element array of the debug element.
    From there, we extract the form control for our input box. Then we run several
    expectations that confirm that an error has been added both to our control and
    to the form and that both are now in an invalid state. The next test is the mirror
    opposite of this test and it checks for a positive:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Other than changing the expectations, the only change we are making from the
    previous test is setting up our spy to return a value of `true`. Unit-testing
    our `remoteValidatorDirective` shows how powerful the `TestBed` utilities are
    in testing our UI and the elements and behaviors associated with it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with E2E testing
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated **E2E** testing is an invaluable asset if the underlying framework
    supports it. As the size of an app grows, automated E2E testing can save a lot
    of manual effort.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Without automation, it's just a never-ending battle to make sure that the app
    is functional. However, remember that in an E2E setup, not everything can be automated;
    automation may require a lot of effort. With due diligence, we can offload a sizable
    amount of manual effort, but not everything.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The process of E2E testing of a web-based application is about running the application
    in a real browser and asserting the behavior of the application based on the user
    interface state. This is how an actual user does testing.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Browser automation holds the key here, and modern browsers have become smarter
    and more capable in terms of supporting automation. Selenium tools for browser
    automation are the most popular option out there. Selenium has the WebDriver ([https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/))
    API that allows us to control the browser through the automation API that modern
    browsers natively support.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The reason behind bringing up Selenium WebDriver is that the Angular E2E testing
    framework/runner **Protractor** also uses **WebDriverJS**, which is a JavaScript
    binding of WebDriver on Node. These language bindings (like the preceding JavaScript
    binding) allow us to use the automation API in the language of our choice.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss Protractor before we start writing some integration tests for
    our app.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Introducting Protractor
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Protractor** is the de facto test runner for E2E testing in Angular. Protractor
    uses Selenium WebDriver to control a browser and simulate user actions.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical Protractor setup has the following components:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: A test runner (Protractor)
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Selenium server
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A browser
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We write our test in Jasmine and use some objects exposed by Protractors (which
    is a wrapper over WebDriverJS) to control the browser.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: When these tests run, Protractor sends commands to the Selenium server. This
    interaction happens mostly over HTTP.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: The Selenium server, in turn, communicates with the browser using the *WebDriver
    Wire Protocol*, and internally the browser interprets the action commands using
    the browser driver (such as *ChromeDriver* in the case of Chrome).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: It is not that important to understand the technicalities of this communication,
    but we should be aware of the E2E testing setup. Check out the article from the
    Protractor documentation at [http://angular.github.io/protractor/#/infrastructure](http://angular.github.io/protractor/#/infrastructure)
    to learn more about this flow.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to realize when using Protractor is that the overall
    interaction with the browser or the browser control flow is asynchronous in nature
    and promise-based. Any HTML element action, whether `sendKeys`, `getText`, `click`,
    `submit`, or any other, does not execute at the time of invocation; instead the
    action is queued up in a control flow queue. For this precise reason, the return
    value of every action statement is a promise that gets resolved when the action
    completes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle this asynchronicity in Jasmine tests, Protractor patches Jasmine,
    and therefore assertions like these work:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: They work despite the `getText` function returning a promise and not the element
    content.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: With this basic understanding of how Protractor works, let's set up Protractor
    for end-to-end testing.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Protractor for E2E testing
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Angular CLI has already set up our project to allow us to use Protractor.
    The configurations for that setup can be found in the `protractor.config.js` file
    in the `trainer` folder. For the most part, you should be able to use those configurations
    without change to run your end-to-end tests. We did, however, make one change
    in that configuration file. We did extend the `defaultTimeoutInterval` in that
    file to 60000 milliseconds in order to give our tests that are running the workouts
    more time to finish:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The configuration file documentation on the Protractor website ([https://github.com/angular/protractor/blob/master/lib/config.ts](https://github.com/angular/protractor/blob/master/lib/config.ts))
    contains details on other supported configurations.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'That is enough to start testing with Protractor. In order to run our tests
    we simply execute the following command in the `trainer` folder:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, let's get started with writing some end-to-end tests.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Writing E2E tests for the app
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start in a simple manner and test our app start page (`#/start`). This
    page has some static content, a workout listing section with search capabilities,
    and the ability to start a workout by clicking on any workout file.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: All our E2E tests will be added to the `e2e` folder under `trainer`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file called `app.e2e-spec.ts` to the `e2e` folder under `trainer`,
    which contains the following code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's walk through this simple test.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'The first interesting piece is the import at the top of the page—`import {
    AppPage } from ''./app.po'';`. This is referring to a file in the same directory
    that contains what is called a page object.  This page object contains the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The use of the page object allows us to simplify the code in our test so that
    it is more readable. So instead of directly calling `browser.get ('/')` in our
    test, we call the `navigateTo()` method from our page object.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The browser object referred to in our page object is a global object exposed
    by Protractor and it is used to control the browser-level actions. Underneath,
    it is just a wrapper around WebDriver. The `browser.get("")` method navigates
    the browser to start the app page, every time, before the start of the test.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'The same for the `getParagraphText()` method—it allows us to call that method
    in our test and look for some text on the screen without having to identify the
    exact location on the page where that will appear. We''ll discuss page objects
    in more detail as we get into more complicated end-to-end testing. The `getParagraphText()` in
    our page object also employs two new globals, `element` and `by`, which are made
    available by Protractor:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '`element`: This function returns an `ElementFinder` object. The primary job
    of `ElementFinder` is to interact with the selected element. We will be using
    the `element` function to select `ElementFinder` extensively in our tests.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the documentation at `http://www.protractortest.org/#/locators#actions`
    to learn more about element manipulation API support. Functions such as `getText()`
    are actually defined on `WebElement`, but are always accessed using `ElementFinder`.
    As the documentation suggests, `ElementFinder` can be treated as `WebElement`
    for most purposes. For more information, you can refer to `http://www.protractortest.org/#/locators#behind-the-scenes-elementfinders-versus-webelements`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '`by`: This object is there to locate elements. It has functions that create
    `locators`. In the preceding test, a locator is created to search for elements
    with a css tag equal to `abe-root h1` If you are familiar with CSS selectors,
    you will know that this identifies what we are looking for as an `h1` tag inside
    the custom element `abe-root`. There are a number of locators that can be used
    to search for a specific element. These include by class, by ID, and by css. Refer
    to the Protractor documentation on locators at [http://angular.github.io/protractor/#/locators](http://angular.github.io/protractor/#/locators)
    to learn about the supported locators.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just to reiterate what we discussed earlier, `getText()` in the page object
    does not return the actual text, but a Promise; we can still assert on the text
    value.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to the actual test, it uses the methods in the page object to verify
    that some content ("Ready for a Workout?") is present on the page.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: This simple test highlights another salient feature of Protractor. It automatically
    detects when the Angular app is loaded and when data is available for testing.
    There are no ugly hacks to delay testing (using `timeouts`) that may otherwise
    be required in standard E2E testing scenarios.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Remember, this is an *SPA*; full-page browser refresh does not happen, so it
    is not that simple to determine when the page is loaded and when the data that
    is rendered for AJAX calls is available. Protractor makes it all possible.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Protractor may still time out while trying to assess whether the page is available
    for testing. If you are hitting timeout errors with Protractor, this article from
    the Protractor documentation can be really helpful ([http://www.protractortest.org/#/timeouts](http://www.protractortest.org/#/timeouts))
    for debugging such issues.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Setting up backend data for E2E testing
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up backend data for E2E testing is a challenge, irrespective of the
    E2E framework that we employ for testing. The ultimate aim is to assert the behavior
    of an application against some data, and unless the data is fixed, we cannot verify
    the behavior that involves getting or setting data.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: One approach to setting up data for E2E tests is to create a test data store
    specifically for E2E tests with some seed data. Once the E2E tests are over, the
    data store can be reset to its original state for future testing. For *Personal
    Trainer*, we can create a new database in MongoLab dedicated exclusively to E2E
    testing.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: This may seem a lot of effort, but it is necessary. Who said E2E testing is
    easy! In fact, this challenge is there even if we do manual testing. For a real
    app, we always have to set up data stores/databases for every environment, whether *dev*,
    *test*, or *production*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will continue to use our existing backend, but go ahead and
    add another workout that we will use for testing. Name this workout `1minworkout`
    and give it a title of `1 Minute Workout`. Add two exercises to the workout: Jumping
    Jacks and Wall Sit. Set the duration of each exercise to 15 seconds and the rest
    time to one second.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: We have deliberately kept our new workout short so that we can complete our
    end-to-end testing of this workout within the normal timeouts provided by Protractor.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: More E2E tests
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get back to testing the workout search features on the start page. With
    the addition of *1 Minute Workout*, we now have two workouts and we can assert
    search behaviors against these.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: If you have added other workouts to the backend, just adjust the numbers in
    this test accordingly.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this test after the existing test in `workout-runner.spec.ts`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The test uses `ElementFinder` and `Locator API` to look for elements on the
    page. Check the second line of the test. We are using the `element.all` function
    together with the `by.css` locator to do a multi-element match on all elements
    on the screen that are using the `.workout.tile` CSS class. This gives us a list
    of workouts against which the next line asserts the element count of 3.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: The test then gets hold of the search input using the `element` function along
    with the `by.css` locator to do a single element match for an element using the
    `.form-contol` CSS class. We then use the `sendKeys` function to simulate data
    entry in the search input.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The last two expect operations check for the count of elements in our list,
    which after the search should be 1\. Also, they check whether the correct workout
    is filtered based on a `div` tag using the `title` CSS class that is a child of
    the element that contains our workout. This last expect statement highlights how
    we can chain element filtering and get hold of child elements in HTML.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more test associated with the start page that we should add. It
    tests the navigation from the start page to the workout runner screen. Add this
    code for that test:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This test uses the `click`  function to simulate clicking on a workout tile,
    and then we use the `browser.getCurrentUrl` function to confirm that the navigation
    is correct.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Run the test again (`protractor tests/protractor.conf.js`) and once again observe
    the magic of browser automation as the tests run one after another.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Can we automate E2E testing for *Workout Runner*? Well, we can try.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Testing Workout Runner
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major challenges with testing Workout Runner is that everything is
    time-dependent. With unit testing, at least we were able to mock the interval,
    but not anymore. Testing exercise transitions and workout completion is definitely
    difficult.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we tackle this problem or try to find an acceptable workaround,
    let''s digress and learn about an important technique to manage E2E testing: page
    objects!'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Using page objects to manage E2E testing
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We touched on page objects earlier. The concept of page objects is simple. We
    encapsulate the representation of page elements into an object so that we do not
    have to litter our E2E test code with `ElementFinder` and `locators`. If any page
    element moves, we just need to fix the page object.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we can represent our Workout Runner page:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This page object now encapsulates many of the elements that we want to test.
    By organizing the element selection code in one place, we increase the readability
    and hence the maintainability of E2E tests.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the Workout Runner page object to the top of the test file. We''ll
    use it in a test for the workout runner. Add the following new describe block
    containing the first of our workout runner tests:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The test verifies that the workout is loaded and the correct data is shown.
    We make full use of the page object that we defined earlier. Run the test and
    verify that it passes.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get back to the challenge of testing code based on `interval` or `timeout`.
    Let''s add a test that confirms a click event on the screen, when the pause button
    is pushed:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What is interesting here is that we use the `browser.sleep` function within
    a promise to verify that the exercise time remaining is the same before and after
    the button is clicked. We are again using our `WorkoutRunner` page object to make
    the test more readable and understandable.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to wrap up the chapter and summarize our learning.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We do not need to reiterate how important unit- and E2E-testing are for any
    application. The way the Angular framework has been designed makes testing the
    Angular app easy. In this chapter, we covered how to write unit tests and E2E
    tests using libraries and frameworks that target Angular.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: For unit testing, we used Jasmine to write our tests and Karma to execute them.
    We tested pipes, components, services, and directives from *Personal Trainer*.
    In the process, we learned about the challenges and the techniques used to effectively
    test these types.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: For E2E testing, the framework of choice was Protractor. We still wrote out
    tests in Jasmine, but the test runner this time was Protractor. We learned how
    Protractor automates E2E testing using Selenium WebDriver, as we did some scenario
    testing for the *Start* and *Workout Runner* pages.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: If you have reached this point, you are getting closer to becoming a proficient
    Angular developer. The next chapter reinforces this with more practical scenarios
    and implementations built using Angular. We will touch upon important concepts
    in the last chapter of this book; these include multilingual support, authentication
    and authorization, communication patterns, performance optimizations, and a few
    others. You certainly do not want to miss them!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
