- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Software Design Principles and Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设计原则和模式
- en: Software development is fundamentally a *human-intensive discipline.* This means
    that it requires knowledge of both techniques and technology, but also comprehension
    of the problem and the ability to make decisions to implement a solution on multiple
    levels of abstraction. Programming has much to do with how a developer thinks.
    Over the years, and within each context and language, guidelines and solutions
    have emerged to solve recurring problems. Knowledge of these *patterns* will help
    you identify when to apply them and speed your development on a sure footing.
    On the other hand, *principles* are guiding concepts that should be applied at
    every stage of the process and have more to do with how you approach the process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发本质上是一门*人密集型学科*。这意味着它需要了解技术和技术，同时也需要理解问题和在多个抽象层次上实施解决方案的决策能力。编程与开发者的思维方式有很大关系。多年来，在每个上下文和语言中，都出现了解决重复问题的指南和解决方案。了解这些*模式*将帮助您确定何时应用它们，并确保您的开发工作稳步推进。另一方面，*原则*是指导概念，应在过程的每个阶段应用，并且更多关乎您如何处理这个过程。
- en: In this chapter, we will take a look at a non-exclusive and non-exhaustive list
    of principles and patterns that are common in Vue 3 application development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在Vue 3应用程序开发中常见的非排他性和非详尽性的原则和模式列表。
- en: '| **Principles** | **Patterns** |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| **原则** | **模式** |'
- en: '|'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Separation of concerns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离
- en: Composition over inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合优于继承
- en: Single responsibility
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责
- en: Encapsulation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: KIC – keep it clean
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KIC – 保持清洁
- en: DRY – don’t repeat yourself
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRY – 不要重复自己
- en: KISS – keep it simple stupid
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KISS – 简单就是聪明
- en: Code for the next
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为未来编写代码
- en: '|'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Singleton
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: Dependency injection
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Observer
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: Command
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Proxy
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Decorator
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者
- en: Façade
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门面
- en: Callbacks
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调
- en: Promises
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: '|'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 2.1 – The principles and patterns covered in this chapter
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – 本章涵盖的原则和模式
- en: Understanding these principles and patterns will help you use the framework
    more efficiently and more often than not, it will prevent you from “reinventing
    the wheel”. Together with the first chapter, this will conclude the *foundational
    part* of this book and will give you the basis to follow the practical parts and
    implementation of application examples in the rest of the book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些原则和模式将帮助您更有效地使用框架，并且通常情况下，它将防止您“重新发明轮子”。与第一章一起，这将结束本书的*基础部分*，并为您跟随本书剩余部分的实际部分和应用示例的实现提供基础。
- en: What are the principles of software design?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设计原则是什么？
- en: In software development, design principles are high-level conceptual guidelines
    that should apply to the entire process. Not every project will use the same principles,
    and these are not mandatory rules to be enforced. They can appear in a project
    from the architecture down to the **user interface** (**UI**) and the last bit
    of code. In practice, some of these principles can also influence software attributes,
    such as maintainability and re-usability.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，设计原则是适用于整个过程的宏观概念性指南。并非每个项目都会使用相同的原理，这些也不是必须强制执行的规则。它们可以从架构到用户界面（**UI**）和最后一段代码出现在项目中。在实践中，这些原则中的一些也可以影响软件属性，如可维护性和可重用性。
- en: A non-exclusive list of design principles
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计原则的非排他性列表
- en: Design principles vary somewhat depending on the context, domain, and even the
    team one may be part of at the time. The principles included in this chapter are,
    therefore, non-exclusive.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 设计原则因上下文、领域，甚至一个人可能参与的团队而异。因此，本章包含的原则是非排他性的。
- en: Separation of concerns
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点分离
- en: This is perhaps the most important principle in software engineering. Separation
    of concerns implies that a system must be divided into subsystems of elements
    grouped by their function or service (the **concern**). For example, we can consider
    the human body as a *system* composed of many subsystems (respiratory, circulatory,
    digestive, etc.). These, in turn, are integrated by different organs, which are
    made of tissues, and so forth, down to the smallest cell. Following the same idea
    in software, an application can be divided into elements grouped by concerns,
    from the large architecture all the way down to the last function. Without this
    breakdown of complexity into manageable parts, creating a functional system would
    be much harder, if not impossible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是软件工程中最重要的原则。关注点的分离意味着一个系统必须被划分为由功能或服务（即**关注点**）组成的子系统。例如，我们可以将人体视为由许多子系统（呼吸、循环、消化等）组成的**系统**。这些子系统再由不同的器官整合，器官由组织构成，以此类推，直至最小的细胞。在软件中遵循同样的理念，一个应用程序可以被划分为按关注点分组的不同元素，从大型架构一直到最后的函数。如果没有将复杂性分解为可管理的部分，创建一个功能系统将会更加困难，甚至不可能。
- en: In general, the application of this principle starts with the big picture of
    what the system should be, looks into what it should do to accomplish that, and
    then breaks it down into manageable working parts.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这一原则的应用从系统应该是什么的大图景开始，考虑它应该做什么来实现这一点，然后将它分解为可管理的可工作部分。
- en: As an example, here is a crude graphical representation of separation of concerns
    for a web application. Each box in this diagram identifies a different *concern*
    that, in turn, can be detailed into smaller functional parts. Even better, you
    can see how this principle allows you to identify the integrating parts of a system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个关于Web应用程序关注点分离的粗略图形表示。这个图中的每个框都标识了一个不同的**关注点**，这些关注点反过来又可以细分为更小的功能部分。更好的是，你可以看到这一原则如何帮助你识别系统的整合部分。
- en: '![Figure 2.1 – A simple architectural view of a web application showing separation
    of concerns](img/Figure_2.01_B18602.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 一个简单的Web应用程序架构视图，展示了关注点的分离](img/Figure_2.01_B18602.jpg)'
- en: Figure 2.1 – A simple architectural view of a web application showing separation
    of concerns
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 一个简单的Web应用程序架构视图，展示了关注点的分离
- en: If we were to drill down into any of these small boxes within their respective
    domains, we could still find more concerns to subdivide until we reach an indivisible
    atomic element (a component or function, for example). This principle has much
    to do with and benefits from other principles, such as abstraction and single
    responsibility. We will review them further down the line in this same chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要深入到各自领域内的任何这些小框中，我们仍然可以找到更多需要进一步细分的关注点，直到达到不可分割的原子元素（例如组件或函数）。这一原则与许多其他原则有很大关系，并从中受益，如抽象和单一职责。我们将在本章的后面进一步讨论它们。
- en: Composition over inheritance
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合优于继承
- en: The principle of *composition over inheritance* comes directly from **Object-Oriented
    Programming** (**OOP**). It states that an object should attempt to use other
    objects’ functionality when needed, by referencing or instantiating them instead
    of creating a large and complex inheritance family tree of classes to add such
    functionality. Now, JavaScript is fundamentally a *functional* language, even
    though it supports multiple paradigms, including features from OOP, so this principle
    applies as well. There is one note of warning for those migrating from OOP into
    JavaScript, and that is to avoid the temptation to treat JavaScript as a pure
    OOP language. Doing so could create unnecessary complexity instead of benefiting
    from the virtues of the language.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合优于继承**的原则直接来源于**面向对象编程**（**OOP**）。它指出，一个对象在需要时应该尝试使用其他对象的功能，通过引用或实例化它们，而不是创建一个庞大而复杂的继承家族树来添加这样的功能。现在，JavaScript本质上是一种**函数式**语言，尽管它支持多种范式，包括来自OOP的特性，所以这一原则同样适用。对于那些从OOP迁移到JavaScript的人来说，有一个警告需要注意，那就是避免将JavaScript视为纯粹的OOP语言。这样做可能会创造不必要的复杂性，而不是从语言的优点中受益。'
- en: In Vue 3, there is no extension or inheritance of components. When we need shared
    or inherited functionality, we have a nice toolset of options to replace the inheritance
    paradigm. We will see later how we can comply with this principle by using *composable
    components* in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User Interface
    Composition* *with Components.*
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 3 中，没有组件的扩展或继承。当我们需要共享或继承功能时，我们有一套很好的工具集来替代继承范式。我们将在[第 4 章](B18602_04.xhtml#_idTextAnchor102)“用户界面组件组合”中看到如何通过使用*组合组件*来遵守这一原则。
- en: Single responsibility principle
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: This principle can be found in OOP as well as in functional programming. Simply
    put, it states that a class, method, function, or *component* should deal with
    only one responsibility or functionality. If you have worked in other disciplines
    and languages, this comes naturally. Multipurpose functions are hard to maintain
    and tend to grow out of control, especially in a language such as JavaScript,
    which is loosely typed and highly dynamic. The same concept also applies directly
    to Vue 3 components. Each component should deal with one specific operation and
    avoid attempting to do too much by itself. In practice, when a component grows
    beyond a certain scope, it is best to split it into multiple components or extract
    the behavior into external modules. There are cases when you may end up with a
    many-thousand-lines-long component, but in my experience, this is rarely necessary
    and can and should be avoided. A warning, though, is that too much specificity
    could also lead to unnecessary complexity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这一原则在面向对象编程以及函数式编程中都可以找到。简单来说，它指出一个类、方法、函数或*组件*应该只处理一个职责或功能。如果你在其他学科和语言中工作过，这会自然而然地发生。多功能函数难以维护，并且往往会失去控制，尤其是在像
    JavaScript 这样松散类型和高度动态的语言中。同样的概念也直接适用于 Vue 3 组件。每个组件应该处理一个特定的操作，避免试图自己完成太多。在实践中，当一个组件超出一定范围时，最好将其拆分为多个组件或将行为提取到外部模块中。有时你可能会得到一个数千行长的组件，但根据我的经验，这很少是必要的，并且可以也应该避免。不过，有一个警告，即过多的具体性也可能导致不必要的复杂性。
- en: 'As an example, let’s imagine a sign-in screen that also displays a sign-up
    option. This approach is common on many sites today. You could include all the
    functionalities inside just one component, but that would break this principle.
    A better alternative would be to split the components into at least three components
    for this task:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象一个同时显示注册选项的登录屏幕。这种做法在许多网站上都很常见。您可以将所有功能都包含在一个组件中，但这会违背这一原则。更好的选择是将组件拆分为至少三个组件来完成这项任务：
- en: A parent component that handles the UI logic. This component decides when to
    show/hide the sign-in and sign-up components.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 UI 逻辑的父组件。该组件决定何时显示/隐藏登录和注册组件。
- en: A child component that handles the sign-in function.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理登录功能的子组件。
- en: A child component that handles the sign-up function.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理注册功能的子组件。
- en: 'Here is a graphical representation of this configuration:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个配置的图形表示：
- en: '![Figure 2.2 – The composition of a sign-in/up interface using multiple components](img/Figure_2.02_B18602.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 使用多个组件组合的登录/注册界面](img/Figure_2.02_B18602.jpg)'
- en: Figure 2.2 – The composition of a sign-in/up interface using multiple components
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 使用多个组件组合的登录/注册界面
- en: I think that you can quickly grasp the benefits of this principle. It makes
    the code easy to manage, maintain, and adapt since web applications have the tendency
    to mutate and evolve very, very quickly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你可以很快地理解这一原则的好处。它使得代码易于管理、维护和适应，因为网络应用有快速变异和演化的趋势。
- en: Best practice tip
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践技巧
- en: Give components a single responsibility and functionality. Avoid mammoth monolithic
    components as much as possible.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 给组件赋予单一职责和功能。尽可能避免庞大的单体组件。
- en: Encapsulation
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation is the notion that you should wrap data and methods to act as
    a single unit while exposing a well-defined **application programming interface**
    (**API**). Often, this is done in the form of classes, modules, or libraries.
    JavaScript is not an exception, and it is highly recommended to follow this principle.
    In Vue 3, this concept applies to not only components but also CSS styles and
    HTML. The introduction of *single-file components* is a clear example of how the
    framework promotes this principle in action and how important it is for today’s
    development. With only a few edge-case situations, we should consider the (**UI**)
    components as black boxes that receive incoming parameters and provide outgoing
    data. Other components should not be *aware* of their inner workings, only the
    API. As we build example applications throughout this book, you will see this
    principle in action.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是指你应该将数据和函数包装成一个单一单元，同时暴露一个定义良好的**应用程序编程接口**（**API**）。通常，这以类、模块或库的形式完成。JavaScript也不例外，强烈建议遵循这个原则。在Vue
    3中，这个概念不仅适用于组件，也适用于CSS样式和HTML。*单文件组件*的引入是框架如何在实际中促进这个原则的一个明显例子，以及它对当今开发的重要性。在只有少数边缘情况的情况下，我们应该将（**UI**）组件视为接收传入参数并提供输出数据的黑盒，其他组件不应*了解*它们的内部工作方式，只有API。随着我们在本书中构建示例应用程序，你将看到这个原则是如何发挥作用的。
- en: KIC – keep it clean
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KIC – 保持清洁
- en: 'This principle refers mainly to the way *you write* code. I should emphasize
    here that KIC applies directly to two categories that strongly affect web and
    Vue 3 applications:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则主要指的是你编写代码的方式。我应该在这一点上强调，KIC直接应用于两个强烈影响Web和Vue 3应用程序的类别：
- en: How you format your code
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何格式化你的代码
- en: How you tidy up events and variables
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何整理事件和变量
- en: The first item includes the use of code conventions, comments, and indentation
    to the organization of the code and logical grouping of functions. For example,
    if you have methods that deal with **create, read, update, and delete** (**CRUD**)
    operations, it would be best to place them near each other in the code, rather
    than spread around the source file. Many **integrated development environments**
    (**IDEs**) contain features to collapse or expand the inner code of functions.
    This helps to quickly review and locate sections in the code with similar logic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项包括使用代码约定、注释和缩进来组织代码以及函数的逻辑分组。例如，如果你有处理**创建、读取、更新和删除**（**CRUD**）操作的方法，最好将它们放在代码的附近，而不是分散在源文件中。许多**集成开发环境**（**IDE**）包含折叠或展开函数内部代码的功能。这有助于快速审查和定位具有相似逻辑的代码部分。
- en: The second part of this principle has to do with memory and reference handling.
    JavaScript has a very good garbage collector, the function of which is to discard
    unused data to reclaim memory. However, there are occasions when the algorithm
    is prevented from freeing up resources because a reference is still pending. If
    you have worked with other languages, such as C/C++, this issue may sound familiar
    as you need to manually reserve and release memory when not in use. In JavaScript,
    if you register a function to listen to an event, it is best to manually deregister
    it at the appropriate life cycle event of your component when no longer needed.
    This will prevent memory leaks and waste of memory and also prevent some security
    risks (which are out of the scope of this book).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则的第二部分与内存和引用处理有关。JavaScript有一个非常好的垃圾回收器，其功能是丢弃未使用的数据以回收内存。然而，有时算法因为引用仍然挂起而无法释放资源。如果你使用过其他语言，如C/C++，这个问题可能听起来很熟悉，因为你需要在不再使用时手动分配和释放内存。在JavaScript中，如果你注册一个函数来监听一个事件，当不再需要时，最好在你的组件适当的生命周期事件中手动注销它。这将防止内存泄漏和内存浪费，同时也防止一些安全风险（这些风险超出了本书的范围）。
- en: 'We will review the component’s life cycle in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102)*,
    User Interface Composition with Components,* but for now, take the following example
    as a good application of this principle and keep it as best practice. In this
    example, we will create a *composable* component to detect when the window size
    changes, so in the `script setup` section we will find something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第4章*](B18602_04.xhtml#_idTextAnchor102)*，使用组件的用户界面组合*中回顾组件的生命周期，但到目前为止，以下示例是这一原则的良好应用，并作为最佳实践保留。在这个例子中，我们将创建一个*可组合*组件来检测窗口大小的变化，因此，在`script
    setup`部分，我们会找到如下内容：
- en: Registers a function on the window object’s resize event during the mounting
    state.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在挂载状态下，在窗口对象的resize事件上注册一个函数。
- en: Deregisters the event before the component is unmounted.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件卸载之前注销事件。
- en: 'Here is the code fragment:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码片段：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `onMounted` and `onBeforeUnmount` functions are part of the Vue 3 framework
    and are triggered by the appropriate component life cycle event. Here, we attach
    our function to the `resize` event when the component is mounted to the **Document
    Object Model** (**DOM**), and we release it just before it is removed. The important
    concept to remember is to clean up after yourself and *keep* *it clean*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMounted`和`onBeforeUnmount`函数是Vue 3框架的一部分，并由适当的组件生命周期事件触发。在这里，当组件挂载到**文档对象模型**（**DOM**）时，我们将函数附加到`resize`事件上，并在它被移除之前释放它。需要记住的重要概念是清理自己的工作并保持其整洁。'
- en: DRY – don’t repeat yourself
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DRY – 不要重复自己
- en: This principle is quite famous, almost to the point of turning into a cliché.
    Sadly, it is easily forgotten. It is credited to Andrew Hunt and David Thomas,
    who used it in the book *The Pragmatic Programmer*. It is mostly thought of as
    *don’t write the same thing twice* and is not far off, but it goes beyond that.
    It encompasses the notion of avoiding redundancy in the process as well as in
    the logic of the application. The core idea is that each process that executes
    business logic should exist in only one place in your entire application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则相当有名，几乎到了变成陈词滥调的地步。遗憾的是，它很容易被遗忘。它归功于安德鲁·亨特和大卫·托马斯，他们在《实用程序员》一书中使用了它。它主要被认为是“不要重复写同一件事”，虽然接近，但它的含义更广。它包括在过程以及应用程序的逻辑中避免冗余的概念。核心思想是，执行业务逻辑的每个过程应该只存在于整个应用程序的一个地方。
- en: For example, most web applications have some asynchronous connection with a
    server through the use of an API. There may also be multiple elements in the application
    that will use or need to use this remote computer/server communication. If you
    were going to code the entire code/logic to communicate with the server in each
    component, we would end up with not only duplication of code but also application
    logic. Maintaining such a system would open up the door to an amazing number of
    negative side effects and security concerns, poor user experience, and much more.
    According to this principle, a better approach is to abstract all communication
    code related to the server API into a single module, or class. In practice, in
    JavaScript this can even be delegated to a web worker in a separate thread. We
    will explore this implementation later in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186),
    *Multithreading with* *Web Workers*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，大多数Web应用程序都通过API使用与服务器的一些异步连接。应用程序中可能还有多个元素将使用或需要使用这种远程计算机/服务器通信。如果你打算在每个组件中编写与服务器通信的整个代码/逻辑，我们最终会得到代码重复以及应用程序逻辑。维护这样的系统会打开通往大量负面副作用和安全问题的门，包括糟糕的用户体验等等。根据这个原则，更好的方法是将与服务器API相关的所有通信代码抽象成一个单独的模块或类。在实践中，在JavaScript中，这甚至可以委托给一个单独线程中的Web
    Worker。我们将在[*第8章*](B18602_08.xhtml#_idTextAnchor186)，*使用Web Workers进行多线程*中探讨这种实现。
- en: As a rule of thumb, if you see yourself writing kind-of-the-same-code” in different
    components or classes, it is a clear opportunity to abstract the functionality
    into its own module or component.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，如果你发现自己正在不同的组件或类中编写“有点相似”的代码，那么将功能抽象成其自己的模块或组件是一个明显的机遇。
- en: KISS – keep it simple and short
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KISS – 保持简单和简洁
- en: 'This principle is not exclusive to the software design realm. It was coined
    by the US Navy back in the ’60s (according to Wikipedia, [https://en.wikipedia.org/wiki/KISS_principle](https://en.wikipedia.org/wiki/KISS_principle)).
    The idea is pure common sense: it is better to build simple, small functional
    parts that work together than attempt to create a big and complex program in one
    go. Also, algorithms should be implemented in the most simple and efficient way.
    In web development, this principle is essential. Modern web applications are composed
    of hundreds of working parts spread over multiple computers, servers, and environments.
    The more complex a system or code implementation is, the harder it is also to
    maintain and adapt.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则并不仅限于软件开发领域。它是在20世纪60年代由美国海军提出的（根据维基百科，[https://en.wikipedia.org/wiki/KISS_principle](https://en.wikipedia.org/wiki/KISS_principle)）。这个想法纯粹是常识：构建简单、小巧且能协同工作的功能部件，比一次性尝试创建一个庞大而复杂的程序要好。此外，算法应以最简单和最有效的方式进行实现。在Web开发中，这个原则至关重要。现代Web应用程序由数百个工作部件组成，这些部件分布在多个计算机、服务器和环境上。系统或代码实现越复杂，维护和适应的难度也越大。
- en: There is a warning, though. Keeping things simple does not mean over-simplification
    or unnecessary segregation. Too many small parts can introduce unnecessary complexity
    in the system. Applying the KISS principle means staying in that sweet middle
    point where things are manageable and easy to understand.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个警告。保持简单并不意味着过度简化或不必要的隔离。太多的部分可能会在系统中引入不必要的复杂性。应用KISS原则意味着保持在那个事物可管理和易于理解的美好中间点。
- en: Code for the next
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为未来编写代码
- en: This principle is the idea that you should make your code readable and easy
    to understand for someone else besides you. Naming conventions, logic flow, and
    inter-line comments are all part of this. Not only for the case when you may need
    to delegate your code to another but also when you come back in a year or two
    to the same code. The last thing you want to do is to waste time thinking about
    what the past inexperienced you did with that clever line of spaghetti code Smart
    developers code as if they were going to teach somebody else, simply and elegantly.
    Especially if you are using or contributing to open-source code, this principle
    is vital for group collaboration. In this case, it is worth mentioning the *Boy
    Scout Principle,* which is similar but applies in groups. It states that when
    you find a hard-to-read or “spaghetti” code, you refactor it to make it clean.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则是指你应该让你的代码对除了你自己之外的其他人来说也是可读和易于理解的。命名约定、逻辑流程和行间注释都是这个原则的一部分。这不仅是为了在你可能需要将代码委托给其他人时，也是为了当你一年或两年后回到相同的代码时。你不想做的事情就是浪费时间思考过去那个缺乏经验的你用那行巧妙的意大利面代码做了什么。聪明的开发者编写代码就像他们要教给别人一样，简单而优雅。特别是如果你在使用或为开源代码做出贡献，这个原则对于团队协作至关重要。在这种情况下，值得提到的是*童子军原则*，它与前者类似，但适用于团队。它指出，当你发现难以阅读或“意大利面”代码时，你应该重构它以使其变得干净。
- en: Best practice tip
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践技巧
- en: Keep your code clean with on-source comments and documentation explaining your
    logic, as if teaching somebody else. More often than not, you will be teaching
    yourself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源代码注释和文档来解释你的逻辑，保持你的代码干净，就像在教别人一样。大多数情况下，你实际上是在教自己。
- en: Design principles apply to many different scenarios, some beyond the practice
    of software development. It is important to consider them until they become second
    nature. In general, the application of these and other principles, together with
    the application of design patterns, make an important mark on your professional
    development.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 设计原则适用于许多不同的场景，一些场景甚至超出了软件开发实践。考虑它们直到它们成为第二天性是很重要的。一般来说，这些原则以及其他原则的应用，以及设计模式的应用，对你的职业发展留下了重要的影响。
- en: What is a software design pattern?
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是软件设计模式？
- en: In software development, it is common for certain processes and tasks to appear
    in multiple projects, in one way or another, or with some degree of variation.
    A *design pattern* is a proven solution for such similar problems. It does not
    prescribe code but acts like a reasoning template, an approach that has been abstracted
    independent of the implementation to be reused and adapted to particular circumstances.
    In practice, there is plenty of room for creativity to apply a pattern. Entire
    books have been dedicated to this subject and provide more detail than the scope
    of this book allows. In the following pages, we will take a look at what I consider
    to be the most recurrent patterns to keep in mind for Vue 3 applications. Even
    though we see them in isolation for the purposes of studying them, the reality
    is that often the implementation overlaps, mixes, and encapsulates multiple patterns
    in a single piece of code. For example, you can use a **singleton** to act as
    a **decorator** and a **proxy** to simplify or alter the communication between
    services in your application (we will do this quite often, actually, and the full
    code can be seen in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186)*, Multithreading
    with* *Web Workers*).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，某些流程和任务以某种方式或某种程度的变化出现在多个项目中是很常见的。*设计模式*是解决此类类似问题的有效解决方案。它不规定代码，而更像是一个推理模板，一种独立于实现进行抽象、可重用和适应特定情况的方法。在实践中，有足够的空间发挥创意来应用模式。已经有许多书籍致力于这个主题，并提供了比本书范围更详细的信息。在接下来的几页中，我们将探讨我认为对于Vue
    3应用程序来说最常见且需要记住的模式。尽管我们为了研究它们而单独看待它们，但现实情况是，通常实现会重叠、混合和封装多个模式在一个代码块中。例如，你可以使用**单例**来充当**装饰器**和**代理**，以简化或改变应用程序中服务之间的通信（我们实际上会这样做很多次，完整的代码可以在[*第8章*](B18602_08.xhtml#_idTextAnchor186)*，使用*
    *Web Workers* *进行多线程* *中查看*）。
- en: Design patterns can also be understood as software engineering and development
    *best practices*. And the opposite of that, *bad practice*, is often referred
    to as an **anti-pattern**. Anti-patterns are “solutions” that, even though they
    fix an issue in the short term, create problems and bad consequences along the
    line. They generate the need to work around the problem and destabilize the whole
    structure and implementation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式也可以理解为软件工程和开发*最佳实践*。而与之相反的，*不良实践*通常被称为**反模式**。反模式是“解决方案”，尽管它们在短期内解决了问题，但沿着这条线会引发问题和不良后果。它们产生了绕过问题的需要，并使整个结构和实现不稳定。
- en: Let’s now view a list of patterns that should be part of your toolbox for Vue
    3 projects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们查看一个列表，这些模式应该是Vue 3项目工具箱的一部分。
- en: A quick reference list of patterns
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式快速参考列表
- en: 'Patterns are classified according to the type of function or problem they solve.
    There are plenty of patterns according to the context, language, and architecture
    of a system. Here is a non-exclusive list of patterns that we will use throughout
    this book and that, in my experience, are more likely to appear in Vue applications:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 模式根据它们解决的问题或功能类型进行分类。根据系统的上下文、语言和架构，有许多模式。以下是我们将在本书中使用的模式列表，以及根据我的经验，这些模式更有可能在Vue应用程序中出现：
- en: '**Creational patterns**: These deal with the approach to creating classes,
    objects, and data structures:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型模式**：这些处理创建类、对象和数据结构的方法：'
- en: Singleton pattern
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: Dependency injection pattern
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入模式
- en: Factory pattern
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式
- en: '**Behavioral patterns**: These deal with communication between objects, components,
    and other elements of the application:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为模式**：这些处理应用程序中对象、组件和其他元素之间的通信：'
- en: Observer pattern
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: Command pattern
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: '**Structural patterns**: These provide templates that affect the design of
    your application and the relationship between components:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构模式**：这些提供模板，影响应用程序的设计和组件之间的关系：'
- en: Proxy pattern
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式
- en: Decorator pattern
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: Façade pattern
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门面模式
- en: '**Asynchronous patterns**: These deal with data and process flow with asynchronous
    requests and events in single-threaded applications (heavily used in web applications):'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步模式**：这些模式处理单线程应用程序（在Web应用程序中大量使用）中的异步请求和事件的数据和流程：'
- en: Callbacks pattern
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调模式
- en: Promises pattern
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺模式
- en: Not by any means this list of patterns is exclusive. There are many more patterns
    and classifications, and a full library is dedicated to this subject. It is worth
    mentioning that the description and application for some of these may differ from
    one literature to another and there is some overlapping depending on the context
    and implementation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这个模式列表并不是唯一的。还有许多其他模式和分类，一个完整的库专门用于这个主题。值得一提的是，这些描述和应用可能因文献而异，并且根据上下文和实现可能存在一些重叠。
- en: With that introduction to design patterns, let’s look at them in detail with
    examples.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍完设计模式之后，让我们通过示例来详细探讨它们。
- en: The singleton pattern
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: This is a very common pattern in JavaScript and perhaps one of, if not the most
    important. The basic concept defines that one object’s instance must only exist
    once in the entire application, and all references and function calls are done
    through this object. A singleton can act as a gateway to resources, libraries,
    and data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 JavaScript 中非常常见的一种模式，也许是最重要的一种。基本概念定义了一个对象实例在整个应用程序中只能存在一次，所有的引用和函数调用都通过这个对象进行。单例可以作为资源、库和数据的网关。
- en: When to use it
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用
- en: 'Here is a short rule of thumb to know when to apply this pattern:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的规则，可以帮助您了解何时应用此模式：
- en: When you need to make sure a resource is accessed through only one gateway,
    for example, the global application state
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要确保资源只通过一个网关访问时，例如，全局应用程序状态
- en: When you need to encapsulate or simplify behavior or communications (used in
    conjunction with other patterns). For example, the API access object.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要封装或简化行为或通信（与其他模式结合使用时）。例如，API 访问对象。
- en: When the *cost* of multiple instantiations is detrimental. For example, the
    creation of web workers.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多次实例化的 *成本* 有害时。例如，创建网络工作者。
- en: Implementations
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: There are many ways that you can apply this pattern in JavaScript. In some cases,
    the implementation from other languages is migrated to JavaScript, often following
    Java examples with the use of a `getInstance()` method to obtain the singleton.
    However, there are better ways to implement this pattern in JavaScript. Let’s
    see them next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 JavaScript 中以多种方式应用此模式。在某些情况下，从其他语言迁移的实现会遵循 Java 示例，通常使用 `getInstance()`
    方法来获取单例。然而，在 JavaScript 中实现此模式有更好的方法。让我们看看下面的例子。
- en: Method 1
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法 1
- en: 'The simplest way is through a module that exports a plain object literal or
    a **JavaScript Object Notation** (**JSON**), which is a static object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是通过导出一个普通的对象字面量或 **JavaScript 对象表示法**（**JSON**），这是一个静态对象：
- en: ./chapter 2/singleton-json.js
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/singleton-json.js
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You then can import this module into other modules and still always have the
    same object. This works because bundlers and browsers are smart enough to avoid
    the repetition of imports, so once this object has been brought in the first time,
    it will ignore the next requests. When not using a bundler, the ES6 implementation
    of JavaScript also defines that modules are singletons.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此模块导入其他模块，并且始终拥有相同的对象。这是因为打包器和浏览器足够智能，可以避免重复导入，所以一旦这个对象第一次被引入，它将忽略后续的请求。当不使用打包器时，JavaScript
    的 ES6 实现也定义了模块是单例的。
- en: Method 2
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法 2
- en: 'This method creates a class and then, on the first instantiation, saves the
    reference for future calls. In order for this to work, we use a variable (traditionally
    called `_instance`) from the class and save the reference to the instance in the
    constructor. In the following calls, we check whether the `_instance` value exists,
    and if so, return it. Here is the code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个类，然后在第一次实例化时保存对未来的引用。为了使此方法生效，我们使用类中的一个变量（传统上称为 `_instance`）并在构造函数中保存对实例的引用。在后续调用中，我们检查
    `_instance` 值是否存在，如果存在，则返回它。以下是代码：
- en: ./chapter 2/singleton-class.js
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/singleton-class.js
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This second method may be more familiar to other language developers. Notice
    how we are also exporting a new instance of the class and not the class directly.
    This way, the invoker will not have to remember to instantiate the class every
    time, and the code will be the same as in *method 1*. This use case is something
    that needs to be coordinated with your team to avoid different implementations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法可能对其他语言开发者来说更为熟悉。注意我们也是导出一个新的类实例，而不是直接导出类。这样，调用者就不必每次都记住实例化类，代码将与 *方法 1*
    中的代码相同。这种情况需要与您的团队协调，以避免不同的实现。
- en: 'The invoker then can call methods from each one directly (assuming the singleton
    has a function/method called `myFunction()`):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者可以直接调用每个对象的方法（假设单例有一个名为 `myFunction()` 的函数/方法）：
- en: ./chapter 2/singleton-invoker.js
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/singleton-invoker.js
- en: '[PRE3]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The singleton pattern is extremely useful, though it rarely exists *in isolation*.
    Often, we use singletons to wrap the implementation of other patterns and make
    sure we have a single point of access. In our examples, we will use this pattern
    quite often.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式非常有用，尽管它很少**独立存在**。通常，我们使用单例来封装其他模式的实现，并确保我们有一个单一的访问点。在我们的示例中，我们将经常使用这个模式。
- en: The dependency injection pattern
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入模式
- en: 'This pattern simply states that the dependencies for a class or function are
    provided as inputs, for example, as parameters, properties, or other types of
    implementations. This simple statement opens a very wide range of possibilities.
    Let’s take, for example, a class that works with the browser’s `dbManager.js`
    file exposes an object that handles the operations with the database, and the
    `projects` object deals with CRUD operations for the projects table (or collection).
    Without using dependency injection, you will have something like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式简单地声明，一个类或函数的依赖项作为输入提供，例如作为参数、属性或其他类型的实现。这个简单的声明打开了一个非常广泛的可能性。以一个与浏览器的 `dbManager.js`
    文件一起工作的类为例，它公开了一个处理数据库操作的对象，而 `projects` 对象处理项目表的 CRUD 操作（或集合）。如果不使用依赖注入，你将得到类似这样的结果：
- en: ./chapter 2/dependency-injection-1.js
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/dependency-injection-1.js
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code shows a “normal” approach, where we import the dependencies
    at the beginning of the file and then use them in our code. Now, let’s tweak this
    same code to use dependency injection:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了“正常”的方法，即在文件开头导入依赖项，然后在我们的代码中使用它们。现在，让我们调整相同的代码以使用依赖注入：
- en: ./chapter 2/dependency-injection-2.js
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/dependency-injection-2.js
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the main difference is that `dbManager` is now passed as a parameter
    to the function. This is what is called **injection**. This opens up many ways
    to manage dependencies and, at the same time, pushes the hardcoding of dependencies
    up the implementation tree. This makes this class highly reusable, at least for
    as long as the dependency respects the expected API.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主要区别在于现在将 `dbManager` 作为参数传递给函数。这就是所谓的**注入**。这为依赖项管理开辟了许多途径，同时将依赖项的硬编码推到实现树的更高层次。这使得这个类非常易于重用，至少在依赖项遵守预期API的情况下是这样。
- en: 'The preceding example is not the only way to inject a dependency. We could,
    for example, assign it to a property for the object’s internal use. For example,
    if the `projects.js` file was implemented using the property approach instead,
    it would look like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例并不是注入依赖的唯一方式。例如，我们可以将其分配给对象的内部属性。例如，如果 `projects.js` 文件使用属性方法实现，它将看起来像这样：
- en: ./chapter 2/dependency-injection-3.js
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/dependency-injection-3.js
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, the invoker of the object (a singleton, by the way) needs to
    be aware of the property and assign it before calling on any of its functions.
    Here is an example of how that would look:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对象的调用者（顺便提一下，是一个单例）需要知道这个属性，并在调用任何函数之前将其分配。以下是一个示例：
- en: ./chapter 2/dependency-injection-4.js
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/dependency-injection-4.js
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But this approach is not recommended. You can clearly see that it breaks the
    principle of encapsulation, as we are directly assigning a property for the object.
    It also doesn’t feel like clean code even though it is valid code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法并不推荐。你可以清楚地看到，它打破了封装的原则，因为我们直接为对象分配了一个属性。尽管它是有效的代码，但它看起来并不像是整洁的代码。
- en: 'Passing the dependencies one function at a time is also not recommended. So,
    what is a better approach? It depends on the implementation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个传递依赖项也不是推荐的做法。那么，更好的方法是什么呢？这取决于实现方式：
- en: In a class, it is convenient to require the dependencies in the constructor
    (and if not found, throw an error)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个类中，在构造函数中要求依赖项（如果找不到，则抛出错误）是很方便的。
- en: In a plain JSON object, it is convenient to provide a function to set the dependency
    explicitly and let the object decide how to use it internally
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个普通的JSON对象中，提供一个函数来显式设置依赖项，并让对象决定如何内部使用它是很方便的。
- en: This last approach is also recommended for passing a dependency after the instantiation
    of an object when the dependency is not ready at the time of implementation
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法也推荐在对象实例化后传递依赖项，当依赖项在实现时未准备好时使用。
- en: 'Here is a code example for the first point mentioned in the preceding list:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面列表中提到的第一点的一个代码示例：
- en: ./chapter 2/dependency-injection-5.js
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/dependency-injection-5.js
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the constructor, we declare the expected parameter with a default value.
    If the dependency is not provided, we throw an error. Otherwise, we assign it
    to an internal private attribute for the use of the instance. In this case, the
    invoker should look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们声明一个具有默认值的预期参数。如果未提供依赖项，我们抛出错误。否则，我们将它分配给实例的一个内部私有属性以供使用。在这种情况下，调用者应该如下所示：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In an alternative implementation, we could have a function that basically does
    the same by receiving the dependency and assigning it to a private attribute:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一种实现中，我们可以有一个函数，它基本上通过接收依赖并将其分配给一个私有属性来完成相同的功能：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This approach is better than directly assigning the internal attribute, but
    you still need to remember to do the assignment before using any of the methods
    in the object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法比直接分配内部属性更好，但你仍然需要记住在使用对象中的任何方法之前进行分配。
- en: Best practice note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践提示
- en: Whatever approach you use for dependency injection, remain constant throughout
    your code base.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么方法进行依赖注入，都要在整个代码库中保持一致。
- en: You may have noticed that we have mainly been focusing on objects. As you may
    have already guessed, passing a dependency to a function is just the same as passing
    another parameter, so it does not deserve special attention.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们主要关注的是对象。正如你可能已经猜到的，将依赖项传递给函数与传递另一个参数是一样的，所以它不值得特别注意。
- en: 'This example has just moved the dependency implementation responsibility up
    to another class in the hierarchy. But what if we implement a singleton pattern
    to handle all or most of the dependencies in our application? This way, we could
    just delegate the loading of the dependencies to one class or object at a determined
    point in our application life cycle. But how do we implement such a thing? We
    will need the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只是将依赖实现的责任移动到层次结构中的另一个类。但如果我们实现一个单例模式来处理我们应用程序中的所有或大部分依赖呢？这样，我们就可以在应用程序生命周期中的某个确定点将依赖的加载委托给一个类或对象。但我们应该如何实现这样的功能？我们需要以下内容：
- en: A method to register the dependency
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册依赖的方法
- en: A method to retrieve the dependency by name
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名称检索依赖项的方法
- en: A structure to keep the reference to each dependency
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个结构来保持对每个依赖项的引用
- en: 'Let’s put that into action and create a very *naive* implementation of such
    a singleton. Please keep in mind that this is an academic exercise, so we are
    not considering error checking, de-registration, or other considerations:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其付诸实践，创建一个非常*天真*的单例实现。请记住，这是一个学术练习，所以我们不考虑错误检查、注销或其他考虑因素：
- en: ./chapter 2/dependency-injection-6.js
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/dependency-injection-6.js
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this bare minimum implementation, let’s look at each line by the line
    comment:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最基本实现的基础上，让我们逐行通过注释来看：
- en: We create a simple JavaScript object literal as a singleton.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个简单的JavaScript对象字面量作为单例。
- en: We declare an empty object to use as a dictionary to hold our dependencies by
    name.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个空对象，用作字典来按名称存储我们的依赖项。
- en: The `provide` function lets us register a dependency by name.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`provide`函数让我们可以通过名称注册依赖项。'
- en: Here, we just use the name as the field name and assign the dependency passed
    by argument (notice we are not checking pre-existing names, etc.).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们只使用名称作为字段名，并分配通过参数传递的依赖项（注意我们没有检查预存在的名称等）。
- en: Here, we return the source object, mainly for convenience so we can chain the
    invocation.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们返回源对象，主要是为了方便，这样我们就可以链式调用。
- en: The `inject` function will take the name as registered in the `provide` function.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`inject`函数将接受在`provide`函数中注册的名称。'
- en: We return the dependency or `null` if not found.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回依赖项或`null`（如果未找到）。
- en: 'With that singleton on board, we can now use it across our application to distribute
    the dependencies as needed. For that, we need a parent object to import them and
    populate the service. Here is an example of how that might look:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个单例之后，我们现在可以在整个应用程序中使用它，按需分配依赖项。为此，我们需要一个父对象来导入它们并填充服务。以下是一个示例，说明这可能看起来像什么：
- en: ./chapter 2/dependency-injection-7.js
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/dependency-injection-7.js
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, this module has hard-coded dependencies, and its work is to
    load them into the `dependencyService` object. Then, the dependent function or
    object needs only to import the service and retrieve the dependency it needs by
    the registration name like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这个模块有硬编码的依赖项，它的作用是将它们加载到 `dependencyService` 对象中。然后，依赖的函数或对象只需要导入服务，并通过注册名称检索所需的依赖项，如下所示：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This approach does create a tight coupling between components but is here as
    a reference. It has the advantage that we can control all the dependencies in
    a single location so that the maintenance benefits could be significant. The choice
    of names for the methods of the `dependencyService` object was not random either:
    these are the same used by Vue 3 inside the component’s hierarchy. This is very
    useful for implementing some User Interface design patterns. We will see this
    in more detail in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User Interface
    Composition with Components* and [*C**hapter 7*](B18602_07.xhtml#_idTextAnchor173),
    *Data* *Flow Management*.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实在组件之间创建了一个紧密的耦合，但这里提供它作为参考。它的优点是我们可以在一个位置控制所有的依赖项，这样维护的益处可能是显著的。`dependencyService`
    对象的方法名称的选择也不是随机的：这些名称与 Vue 3 在组件层次结构内部使用的名称相同。这对于实现一些用户界面设计模式非常有用。我们将在[*第 4 章*](B18602_04.xhtml#_idTextAnchor102)，*使用组件进行用户界面组合*和[*第
    7 章*](B18602_07.xhtml#_idTextAnchor173)，*数据流管理*中更详细地看到这一点。
- en: As you can see, this pattern is very important and is implemented in Vue 3 with
    the `provide`/`inject` functions. It's a great addition to our toolset, but there
    is more still. Let’s move on to the next one.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这种模式非常重要，并且在 Vue 3 中通过 `provide`/`inject` 函数实现。这是对我们工具集的一个很好的补充，但还有更多。让我们继续下一个。
- en: The factory pattern
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂模式
- en: 'The factory pattern provides us with a way to create objects without creating
    a direct dependency. It works through a function that, based on the input, will
    return an instantiated object. The use of such an implementation will be made
    through a common or standard interface. For example, consider two classes: `Circle`
    and `Square`. Both implement the same `draw()` method, which draws the figure
    to a canvas. Then, a `factory` function would work something like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式为我们提供了一种创建对象而不直接创建依赖项的方法。它通过一个函数来实现，该函数根据输入将返回一个实例化的对象。这种实现的用法将通过一个公共或标准接口进行。例如，考虑两个类：`Circle`
    和 `Square`。这两个类都实现了相同的 `draw()` 方法，该方法将图形绘制到画布上。然后，一个 `factory` 函数将类似于这样：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method is quite popular, especially in conjunction with other patterns,
    as we will see multiple times in this book.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法相当流行，尤其是在与其他模式结合使用时，正如我们将在本书中多次看到的。
- en: The observer pattern
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'The observer pattern is very useful and one of the basis of a reactive framework.
    It defines a relationship between objects where one is being observed (the **subject**)
    for changes or events, and other(s) are notified of such changes (the **observers**).
    The observers are also called **listeners**. Here is a graphical representation:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式非常有用，是响应式框架的基础之一。它定义了对象之间的关系，其中一个对象（**主题**）被观察以检测变化或事件，而其他对象（**观察者**）则被通知这些变化。观察者也被称为**监听器**。以下是它的图形表示：
- en: '![Figure 2.3 – The subject emits an event and notifies the observers](img/Figure_2.03_B18602.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 主题对象发出事件并通知观察者](img/Figure_2.03_B18602.jpg)'
- en: Figure 2.3 – The subject emits an event and notifies the observers
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 主题对象发出事件并通知观察者
- en: As you can see, the subject emits an event to notify the observers. It is for
    the subject to define what events and parameters it will **publish**. Meanwhile,
    the observers **subscribe** to each event by registering a function with the publisher.
    This implementation is why this pattern is often referred to as the **pub/sub**
    pattern, and it can have several variations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，主题对象会发出事件来通知观察者。主题对象需要定义它将**发布**哪些事件和参数。同时，观察者通过向发布者注册一个函数来**订阅**每个事件。这种实现方式使得这种模式通常被称为**发布/订阅**模式，并且它可以有多种变体。
- en: 'When looking into the implementation of this pattern, it is important to notice
    the cardinality of the publication: `1` event to `0..N` observers (functions).
    This means that the subject must implement, on top of its main purpose, the functionality
    to publish events and keep track of the subscribers. Since this would break a
    principle or two in the design (separation of concerns, single responsibility,
    etc.), it is common to extract this functionality into a middle object. The previous
    design then changes to add a middle layer:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑实现此模式时，重要的是要注意发布的基数：`1` 个事件对应 `0..N` 个观察者（函数）。这意味着主题必须在它的主要目的之上实现发布事件和跟踪订阅者的功能。由于这会打破设计中的几个原则（关注点分离、单一责任等），通常会将此功能提取到一个中间对象中。因此，先前的设计变为添加一个中间层：
- en: '![Figure 2.4 – An observer implementation with a dispatcher middle object](img/Figure_2.04_B18602.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 带有调度器中间对象的观察者实现](img/Figure_2.04_B18602.jpg)'
- en: Figure 2.4 – An observer implementation with a dispatcher middle object
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 带有调度器中间对象的观察者实现
- en: 'This middle object, sometimes referred to as an “**event dispatcher** encapsulates
    the basic functionality to register observers, receive events from the subject,
    and dispatch them to the observers. It also does some clean-up activities when
    an observer is no longer observing Let’s put these concepts into a simple and
    naive implementation of an event dispatcher in plain JavaScript:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间对象，有时被称为“**事件调度器**”，封装了注册观察者、从主题接收事件并将它们分发给观察者的基本功能。当观察者不再观察时，它还会执行一些清理活动。让我们将这些概念应用到纯
    JavaScript 中的简单且原始的事件调度器实现中：
- en: ./chapter 2/Observer-1.js
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/Observer-1.js
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding implementation is, again, naive. It doesn’t contain the necessary
    error and edge case handling that you would use in production, but it does have
    the bare basics for an event dispatcher. Let’s look into it line by line:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现再次是原始的。它不包含在生产环境中使用的必要错误和边缘情况处理，但它确实为事件调度器提供了基本的基本功能。让我们逐行查看它：
- en: In the constructor, we declare an object to use internally as a dictionary for
    our events.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们声明一个对象，将其用作内部字典来存储我们的事件。
- en: The `on` method allows the observers to register their functions. In this line,
    if the event is not initialized, we create an empty array.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`on` 方法允许观察者注册他们的函数。在这一行中，如果事件尚未初始化，我们创建一个空数组。'
- en: In this line, we just push the function to the array (as I said, this is a naive
    implementation, as we don’t check for duplicates, for example).
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一行中，我们只是将函数推送到数组中（正如我所说的，这是一个原始的实现，因为我们没有检查重复，例如）。
- en: The `emit` method allows the subject to publish an event by its name and pass
    some data to it. Here, we run over the array and execute each function passing
    the data we received as a parameter.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`emit` 方法允许主题通过其名称发布事件并向其传递一些数据。在这里，我们遍历数组并执行每个函数，传递我们接收到的作为参数的数据。'
- en: The `off` method is necessary to deregister the function once it is not used
    (see the *keep it clean* principle, earlier in this chapter).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`off` 方法是必要的，以便在不再使用函数时取消注册（参见本章早些时候提到的 *保持清洁* 原则）。'
- en: 'In order for this implementation to work, every observer and the subject need
    to reference the same implementation of the `ObserverClass`. The easiest way to
    secure this is to implement it through a *singleton pattern*. Once imported, each
    observer registers with the dispatcher with this line:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此实现工作，每个观察者和主题都需要引用相同的 `ObserverClass` 实现。最简单的方法是通过 *单例模式* 来实现它。一旦导入，每个观察者都会使用以下行向调度器注册：
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, the subject emits the event and passes the data with the following lines:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，主题通过以下行发出事件并传递数据：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, when the observer no longer needs to watch the subject, it needs to
    clean up the reference with the `off` method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当观察者不再需要监视主题时，它需要使用 `off` 方法清理与主题的引用：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are a good number of edge cases and controls that we have not covered
    here, and rather than reinventing the wheel, I suggest using a ready-made solution
    for these cases. In our book, we will use one named `mitt` ([https://www.npmjs.com/package/mitt](https://www.npmjs.com/package/mitt)).
    That has the same methods as in our example. We will see how to install packaged
    dependencies in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079), *Setting up a*
    *Working Project*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有涵盖许多边缘情况和控制，而不是重新发明轮子，我建议使用现成的解决方案来处理这些情况。在我们的书中，我们将使用一个名为`mitt`的解决方案（[https://www.npmjs.com/package/mitt](https://www.npmjs.com/package/mitt)）。它具有与我们示例中相同的方法。我们将在[*第3章*](B18602_03.xhtml#_idTextAnchor079)，*设置工作项目*中看到如何安装打包的依赖项。
- en: The command pattern
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令模式
- en: 'This pattern is very useful and easy to understand and implement. Instead of
    executing a function right away, the basic concept is to create an object or structure
    with the information necessary for the execution. This data package (the **command**)
    is then delegated to another object that will perform the execution according
    to some logic to handle it. For example, the commands can be serialized and queued,
    scheduled, reversed, grouped together, and transformed. Here is a graphical representation
    of this pattern with the necessary parts:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式非常有用且易于理解和实现。而不是立即执行一个函数，基本概念是创建一个包含执行所需信息的对象或结构。这个数据包（**命令**）然后委托给另一个对象，该对象将根据某些逻辑执行执行。例如，命令可以被序列化并排队、调度、反转、分组和转换。以下是这个模式的图形表示，包括必要的部分：
- en: '![Figure 2.5 – A graphical implementation of the command pattern](img/Figure_2.05_B18602.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 命令模式的图形实现](img/Figure_2.05_B18602.jpg)'
- en: Figure 2.5 – A graphical implementation of the command pattern
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 命令模式的图形实现
- en: The diagram shows how the clients submit their commands to the **Invoker**.
    The invoker usually implements some sort of queue or task array to handle the
    commands and then routes the execution to the proper **Receiver**. If there is
    any data to return, it also returns it to the proper client. It is also common
    that the invoker attaches additional data to the command to keep track of clients
    and receives, especially in the case of asynchronous executions. It also provides
    a single point of “entry” to the receivers and decouples the “clients” from them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了客户端如何向**调用者**提交他们的命令。调用者通常实现某种队列或任务数组来处理命令，然后将执行路由到适当的**接收者**。如果有任何数据要返回，它也会返回给适当的客户端。调用者通常还会将附加数据附加到命令中，以跟踪客户端和接收，特别是在异步执行的情况下。它还提供了一个“入口点”到接收者，并将“客户端”与它们解耦。
- en: 'Let’s again work on a naive implementation of an `Invoker` class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试一个`Invoker`类的简单实现：
- en: ./chapter 2/Command-1.js
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/Command-1.js
- en: '[PRE19]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we have implemented a bare-bones example of what an
    `Invoker` should have line by line:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们逐行实现了`Invoker`应该具备的裸骨示例：
- en: The `Invoker` exposes a method to add commands to the object. This is only necessary
    when the commands will be somehow queued, serialized, or processed according to
    some logic.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Invoker`提供了一个方法来向对象添加命令。这仅在命令需要以某种方式排队、序列化或根据某些逻辑处理时才是必要的。'
- en: This line executes the command according to the `action` field contained in
    the `command_data` parameter.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这行代码根据`command_data`参数中包含的`action`字段执行命令。
- en: Based on the `action` field, the *invoker* routes the execution to the proper
    receiver.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据`action`字段，*调用者*将执行路由到适当的接收者。
- en: There are many ways to implement the logic for routing the execution. It is
    important to notice that this pattern can be implemented on a larger scale depending
    on the context. For example, the invoker might not even be in the web client application
    and be on the server or on a different machine. We will see an implementation
    of this pattern in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186), *Multithreading
    with Web Workers*, where we use this pattern to process tasks between different
    threads and unload the main thread (where Vue 3 runs).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 实现路由执行逻辑的方法有很多。重要的是要注意，这个模式可以根据上下文在更大范围内实现。例如，调用者可能甚至不在Web客户端应用程序中，而是在服务器或不同的机器上。我们将在[*第8章*](B18602_08.xhtml#_idTextAnchor186)，*使用Web
    Workers进行多线程*中看到这个模式的实现，在那里我们使用这个模式在不同线程之间处理任务并卸载主线程（Vue 3运行的地方）。
- en: The proxy pattern
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理模式
- en: 'The definition for this pattern comes directly from its name, as the word “proxy”
    means something or someone who acts on behalf of another as if it was the same.
    That is a mouthful, but it will make you remember it. Let’s look into an example
    to clarify how this works. We will need at least three entities (components, objects,
    etc.):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的定义直接来源于其名称，因为“代理”一词意味着代表他人行事的人或事物，仿佛它就是同一个。这听起来有点复杂，但它会帮助你记住它。让我们通过一个例子来了解它是如何工作的。我们需要至少三个实体（组件、对象等）：
- en: A **client** entity that needs to access the API of a target entity
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个需要访问目标实体API的**客户端**实体
- en: A **target** entity that exposes a well-known API
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个暴露了知名API的**目标**实体
- en: A **proxy** object that sits in between and exposes the same API as the target
    while at the same time intercepting every communication from the client and relaying
    it to the target
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个位于中间并暴露与目标相同API的同时拦截来自客户端的每条通信并将其转发给目标的**代理**对象
- en: 'We can graphically represent the relationship between these entities in this
    way:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这种方式图形化地表示这些实体之间的关系：
- en: '![Figure 2.6 – The proxy object exposes the same API as the target](img/Figure_2.06_B18602.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 代理对象暴露与目标相同的API](img/Figure_2.06_B18602.jpg)'
- en: Figure 2.6 – The proxy object exposes the same API as the target
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 代理对象暴露与目标相同的API
- en: 'The key factor for this pattern is that the proxy behaves and exposes the same
    API as the target, in such a way that the client does not know or doesn’t need
    to know that it is dealing with a proxy and not the target object directly. So,
    why would we want to do such a thing? There are many good reasons, such as the
    following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的关键因素是代理的行为和暴露的API与目标相同，这样客户端就不知道或不需要知道它正在处理的是代理而不是目标对象。那么，我们为什么要这样做呢？有很多很好的理由，例如以下：
- en: 'You need to maintain the original unmodified API, but at the same time:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要保持原始未修改的API，但与此同时：
- en: Need to process the inputs or outputs for the client
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要处理客户端的输入或输出
- en: Need to intercept each API call to add internal functionality, such as maintenance
    operations, performance improvements, error checking, and validation
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要拦截每个API调用以添加内部功能，例如维护操作、性能改进、错误检查和验证
- en: The target is an expensive resource, so a proxy could implement logic to leverage
    their operations (for example, a cache)
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标是一个昂贵的资源，因此代理可以实现逻辑来利用它们的操作（例如，缓存）
- en: You need to change the client or the target but can’t modify the API
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要更改客户端或目标，但不能修改API
- en: You need to maintain backward compatibility
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要保持向后兼容性
- en: There are more reasons that you may come across, but I hope that by now you
    can see how this can be useful. Being a pattern, this template can be implemented
    on multiple levels, from a simple object proxy to a full application or server.
    It is quite common when performing partial upgrades of a system or application.
    On a lower level, JavaScript even natively includes a constructor for proxying
    objects that Vue 3 uses internally to create reactivity.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到更多理由，但希望到现在你能够看到这如何有用。作为一个模式，这个模板可以在多个级别上实现，从简单的对象代理到完整的应用程序或服务器。在执行系统的部分升级时，这相当常见。在较低级别上，JavaScript甚至原生包含一个用于代理对象的构造函数，Vue
    3使用它来创建响应性。
- en: In [*Chapter 1*](B18602_01.xhtml#_idTextAnchor017), *The Vue 3 Framework*, we
    reviewed the options for reactivity with the `ref()` but this new version of Vue
    also includes another alternative for complex structures, called `reactive()`.
    The first one uses pub/sub methods (the observer pattern!), but the latter uses
    native proxy handlers (this pattern!). Let’s look into an example of how this
    native implementation may work with a naive partial implementation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B18602_01.xhtml#_idTextAnchor017)，*Vue 3框架*中，我们回顾了使用`ref()`进行响应式的选项，但这个Vue的新版本还包括另一个用于复杂结构的替代方案，称为`reactive()`。第一个使用pub/sub方法（观察者模式！），但后者使用原生代理处理程序（这个模式！）。让我们看看这个原生实现可能如何与一个简单的部分实现一起工作。
- en: 'In this simple example, we will make an object with reactive properties automatically
    convert Celsius degrees to and back from Fahrenheit using a `Proxy` object:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们将创建一个具有反应性属性的自动将摄氏度转换为华氏度并反向转换的`Proxy`对象：
- en: ./chapter 2/proxy-1.js
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/proxy-1.js
- en: '[PRE20]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s review the code line by line to see how this works:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行审查代码，看看它是如何工作的：
- en: In this line, we declare the `temperature` object, which is going to be our
    target to be proxied. We initialize its two properties with an equal converted
    value.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一行，我们声明了`temperature`对象，它将成为我们要代理的目标。我们用相等的转换值初始化其两个属性。
- en: We declare a `handler` object, which will be our proxy for the temperature object.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个`handler`对象，它将成为我们的温度对象代理。
- en: 'The `set` function in the proxy handler receives three arguments: the target
    object, the key referred to, and the value attempted to be assigned. Notice that
    I say “attempted”, as the operation has been intercepted by the proxy.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理处理程序中的`set`函数接收三个参数：目标对象、引用的键以及尝试分配的值。请注意，我说“尝试”，因为操作已被代理拦截。
- en: On this line, we perform the assignment as intended to the object property.
    Here, we could have done other transformations or logic, such as validation or
    raised an event (the observer pattern again!).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一行，我们按照预期将赋值操作应用于对象属性。在这里，我们可能执行其他转换或逻辑，例如验证或引发事件（再次是观察者模式！）。
- en: Notice how we use a switch to filter the property names that we are interested
    in. When the key is `celsius`, we calculate and assign the value in Fahrenheit.
    The opposite happens when we receive an assignment for `fahrenheit` degrees. This
    is where the **reactivity** comes into play.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们如何使用switch来过滤我们感兴趣的属性名。当键是`celsius`时，我们计算并分配华氏值。当我们收到`fahrenheit`度数的赋值时，情况相反。这就是**响应性**发挥作用的地方。
- en: For the `get` function, at least in this example, we just specifically return
    the value requested. In the way this is implemented, it would be the same as if
    we skip the `getter` function. However, it is here as an example that we could
    operate and transform the value to be returned as this operation is also intercepted.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`get`函数，至少在这个例子中，我们只是返回请求的值。按照这种方式实现，它将等同于跳过`getter`函数。然而，它在这里作为一个例子，我们可以操作和转换要返回的值，因为这个操作也被拦截了。
- en: Finally, in line 7, we declare the `degrees` object as the proxy for `temperature`
    with the handler.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在第7行，我们使用处理程序将`degrees`对象声明为`temperature`的代理。
- en: On this line, we test the reactivity by assigning a value in *Celsius* to the
    member of the `degrees` object, just like we normally would to any other object.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一行，我们通过将*摄氏度*值赋给`degrees`对象的成员来测试响应性，就像我们通常对任何其他对象所做的那样。
- en: When we print the `degrees` object to the console, we notice that the `fahrenheit`
    property has been automatically updated.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们将`degrees`对象打印到控制台时，我们注意到`fahrenheit`属性已被自动更新。
- en: This is a rather limited and simple example of how the native `Proxy()` constructor
    works and applies the pattern. Vue 3 has a more complex approach to reactivity
    and tracking dependencies, using the proxy and observer patterns. However, this
    gives us a good idea of what approach is happening behind the scenes when we see
    the HTML updated live in front of our very eyes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当有限且简单的例子，说明了原生的`Proxy()`构造函数是如何工作并应用该模式的。Vue 3使用更复杂的方法来实现响应性和跟踪依赖，这涉及到代理和观察者模式。然而，这让我们对当我们亲眼看到HTML实时更新时幕后发生的方法有了很好的了解。
- en: 'The concept of proxying between a client and a target is also related to the
    next two patterns: the *decorator and the façade patterns* since they are also
    a sort of proxy implementation. The distinguishing key factor is that the proxy
    retains the same API as the original target object.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和目标之间代理的概念也与下两个模式相关：*装饰器模式和外观模式*，因为它们也是一种代理实现。区分的关键因素是代理保留了与原始目标对象相同的API。
- en: The decorator pattern
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: This pattern may, at first sight, seem very similar to the *proxy pattern*,
    and indeed it is, but it adds a few distinctive features that set it apart. It
    does have the same moving parts as the proxy, meaning there is a **Client**, a
    **Target**, and a **Decorator** in between that implements the same interface
    as the target (yes, just like in the proxy pattern). However, while in the *Proxy
    pattern* the intercepted API calls mainly deal with the data and internal maintenance
    (“housekeeping”), the decorator augments the functionality of the original object
    to do more. This is the defining factor that separates them.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式乍一看可能非常类似于*代理模式*，确实如此，但它增加了一些独特的特性，使其与众不同。它确实与代理模式有相同的移动部件，这意味着存在一个**客户端**、一个**目标**以及一个在目标之间实现相同接口的**装饰器**（是的，就像在代理模式中一样）。然而，在*代理模式*中，拦截的API调用主要处理数据和内部维护（“家务”），而装饰器则增强了原始对象的功能以执行更多操作。这是将它们区分开来的决定性因素。
- en: In the proxy example, notice how the additional functionality was an *internal
    reactivity* to keep the degrees in each scale synchronized. When you change one,
    it internally and automatically updates the other. In a decorator pattern, the
    proxy object performs additional operations before, during, or after executing
    the API call to the target object. Just like in the proxy pattern, all of this
    is transparent for the client object.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理示例中，注意额外的功能是如何作为一个*内部反应性*来保持每个刻度中的度数同步的。当你改变一个时，它会内部自动更新另一个。在装饰器模式中，代理对象在执行目标对象的API调用之前、期间或之后执行额外的操作。就像在代理模式中一样，所有这些对客户端对象都是透明的。
- en: 'For example, building on the previous code, imagine that now we want to log
    each call to the API of a certain target while keeping the same functionality.
    Graphically, it would look like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在之前的代码基础上，假设现在我们想要在保持相同功能的同时记录对某个目标API的每次调用。从图形上看，它将看起来像这样：
- en: '![Figure 2.7 – An example of a decorator that augments the target with a logging
    feature](img/Figure_2.07_B18602.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 一个增强目标以添加日志功能的装饰器示例](img/Figure_2.07_B18602.jpg)'
- en: Figure 2.7 – An example of a decorator that augments the target with a logging
    feature
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 一个增强目标以添加日志功能的装饰器示例
- en: 'Here, what was first a simple proxy, now by the mere act of performing a humble
    logging call, has now become a decorator. In the code, we only need to add this
    line before the end of the `set()` method (assuming there is also a function named
    `getTimeStamp()`):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最初只是一个简单的代理，现在仅仅通过执行一个谦逊的日志调用，它已经变成了一个装饰器。在代码中，我们只需要在`set()`方法结束前添加这一行（假设还有一个名为`getTimeStamp()`的函数）：
- en: '[PRE21]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Of course, this is a simple example just to make a point. In the real world,
    decoratorsare very useful for adding functionality to your application without
    having to rewrite the logic or significant portions of your code. On top of this,
    decorators can be *stackable* or *chainable*, meaning that you can create “decorators
    for decorators” if needed, so each one will represent one step of added functionality
    that would maintain the same API of the target object. And just like that, we
    are beginning to step into the boundaries of a **middleware pattern**, but we
    will not cover it in this book. Anyway, the idea behind that other pattern is
    to create layers of middleware functions with a specified API, each one that performs
    one action, but with the difference that any step can decide to abort the operation,
    so the target may or may not be called. But that is another story... let’s get
    back to decorators.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个简单的例子，只是为了说明问题。在现实世界中，装饰器非常有用，可以在不重写逻辑或代码的很大一部分的情况下为你的应用程序添加功能。在此基础上，装饰器可以是*可堆叠的*或*可链式的*，这意味着如果需要，你可以创建“装饰器的装饰器”，这样每个装饰器将代表添加功能的一个步骤，同时保持目标对象的相同API。就这样，我们开始步入**中间件模式**的边界，但在这本书中我们不会涉及它。无论如何，那个其他模式背后的想法是创建具有指定API的中间件函数层，每个函数执行一个动作，但不同之处在于任何步骤都可以决定终止操作，因此目标可能被调用也可能不被调用。但这又是另一个故事...让我们回到装饰器。
- en: Previously in this book, we mentioned that Vue 3 components do not have inheritance
    like plain JavaScript classes implemented by extending from one another. Instead,
    we can use the decorator pattern on components to add functionality or change
    the visual appearance. Let’s look at a brief example now, as we will see components
    and UI design in detail in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User
    Interface Composition* *with Components*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的之前部分，我们提到Vue 3组件没有像通过扩展彼此实现的纯JavaScript类那样具有继承。相反，我们可以使用装饰器模式在组件上添加功能或改变视觉外观。现在让我们看看一个简短的例子，因为我们将在[*第4章*](B18602_04.xhtml#_idTextAnchor102)中详细讨论组件和UI设计，*使用组件的用户界面组合*。
- en: 'Consider that we have the simplest of components that displays a humble `h1`
    tag with a title that receives the following as input:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个最简单的组件，它显示一个谦逊的`h1`标签，该标签接收以下作为输入：
- en: ./chapter 2/decorator-1.vue
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/decorator-1.vue
- en: '[PRE22]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this simple component, we declare a single input named `label` in line `//1`.
    Don’t worry about the syntax for now, as we will see this in detail in [*Chapte**r
    4*](B18602_04.xhtml#_idTextAnchor102)*,* *User Interface Composition with Components.*
    On line `//2`, we are interpolating the value plainly inside the `h1` tags just
    as expected.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的组件中，我们在第`//1`行声明了一个名为`label`的单个输入。现在不用担心语法，因为我们将在[*第4章*](B18602_04.xhtml#_idTextAnchor102)*，*使用组件的用户界面组合*中详细看到它。在第`//2`行，我们像预期的那样在`h1`标签内直接插值值。
- en: 'So, to create a decorator for this component we need to apply the following
    simple rules:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了为这个组件创建一个装饰器，我们需要应用以下简单的规则：
- en: It has to act on behalf of the component (object)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须代表组件（对象）执行操作
- en: It has to respect the same API (inputs, outputs, function calls, etc.)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须遵守相同的API（输入、输出、函数调用等）
- en: It has to augment the functionality or visual representation before, after,
    or during the execution of the target API
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须在目标API的执行之前、之后或期间增强功能或视觉表示
- en: 'With that in mind, we can create a decorator component that intercepts the
    label attribute, changes it a bit, and also modifies the visual appearance of
    the target component:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以创建一个装饰器组件，它拦截标签属性，稍作修改，并也修改目标组件的视觉外观：
- en: ./chapter 2/decorator-2.vue
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/decorator-2.vue
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this code, in line `//1`, you can see that we keep the same interface as
    the target component (that we imported in the previous line), and then in line
    `//2`, we modify (augment) the `color` attribute and in line `//3` we are also
    modifying the data passed to the target component by adding three exclamation
    marks. With those simple tasks, we have kept the conditions to build a decorator
    pattern extrapolated to Vue 3 components. Not bad at all.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，在行`//1`中，您可以看到我们保持了与目标组件（我们在上一行导入的）相同的接口，然后在行`//2`中，我们修改（增强）了`color`属性，在行`//3`中，我们通过添加三个感叹号来修改传递给目标组件的数据。通过这些简单的任务，我们保持了构建装饰器模式扩展到Vue
    3组件的条件。这并不坏。
- en: 'Decorators are very useful, but there is still one more proxy-like pattern
    that is also very common and handy: the façade pattern.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器非常有用，但还有一个类似于代理的、也非常常见且实用的模式：界面（facade）模式。
- en: The façade pattern
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 界面模式
- en: 'By now, you may have seen the progressive pattern in these, well, patterns.
    We started with a proxy to act on behalf of another object or entity, we augmented
    it with the use of decorators while keeping the same API, and now is the turn
    for the façade pattern. Its job is, in addition to the functions of a proxy and
    decorator, to simplify the API and hide the large complexity behind it. So, a
    façade sits between a client and a target, but now the target is highly complex,
    being an object or even a system or multiple subsystems. This pattern is also
    used to change the API of an object or to limit the exposure to the client. We
    can picture the interactions as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经看到了这些模式中的渐进模式。我们从代理开始，代表另一个对象或实体执行操作，通过使用装饰器增强了它，同时保持了相同的API，现在轮到界面模式了。它的作用除了代理和装饰器的功能外，还要简化API并隐藏其背后的巨大复杂性。因此，界面（facade）位于客户端和目标之间，但现在目标是高度复杂的，可能是一个对象，甚至是系统或多个子系统。这种模式也用于更改对象的API或限制对客户端的暴露。我们可以将交互想象如下：
- en: '![Figure 2.8 – A façade object simplifying the interaction with a complex API
    or system](img/Figure_2.08_B18602.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 简化与复杂API或系统交互的界面对象](img/Figure_2.08_B18602.jpg)'
- en: Figure 2.8 – A façade object simplifying the interaction with a complex API
    or system
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 简化与复杂API或系统交互的界面对象
- en: As you can see, the main purpose of the façade is to offer a simpler approach
    to a complex interaction or API. We will use this pattern many times during our
    examples to simplify native implementations in the browser with more developer-friendly
    approaches. We will use libraries to encapsulate the use of IndexedDB and create
    our own simplified communication with web workers in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186),
    *Multithreading with* *Web Workers*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，界面（facade）的主要目的是提供一个更简单的方法来处理复杂的交互或API。在我们的示例中，我们将多次使用这个模式，以使用更友好的方法简化浏览器中的原生实现。我们将使用库来封装IndexedDB的使用，并在[*第8章*](B18602_08.xhtml#_idTextAnchor186)“使用Web
    Workers进行多线程”中创建与Web Workers的简化通信。
- en: Needless to say, you will have seen this pattern in action before, as it is
    one of the foundational concepts of modern technology. *Hiding complexity* behind
    a simple interface (API) is all around us and is a big part of web development.
    After all, the entire internet is extremely complicated, with thousands of moving
    parts, and the technology that makes up web pages is close to magic. Without this
    pattern, we would still be programming with zeros and ones.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，您之前一定见过这种模式的应用，因为它是现代技术的基础概念之一。在简单的界面（API）背后*隐藏复杂性*无处不在，并且是Web开发的重要组成部分。毕竟，整个互联网极其复杂，有成千上万的移动部件，构成网页的技术几乎像是魔法。没有这种模式，我们仍然会使用零和一进行编程。
- en: 'In practice, you will add layers of simplification to your own applications
    to break down complexity. One way to do it is to use third-party libraries that
    provide a simplified interface. In the following chapters, we will use some of
    these, such as the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你会在自己的应用中添加简化层来分解复杂性。实现这一目标的一种方法就是使用提供简化界面的第三方库。在接下来的章节中，我们将使用其中的一些，例如以下这些：
- en: '**Axios**: To handle all **Asynchronous JavaScript and XML** (**AJAX**) communications
    with the server'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Axios**：用于处理与服务器所有**异步JavaScript和XML（AJAX**）通信'
- en: '**DexieDB**: To handle the API to IndexedDB (the browser’s local database)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DexieDB**：用于处理到IndexedDB（浏览器本地数据库）的API'
- en: '**Mitt**: To create event pipelines (we mentioned this in the Observer pattern)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mitt**：用于创建事件管道（我们在观察者模式中提到过）'
- en: '**Vue 3**: To create amazing UIs'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vue 3**：用于创建惊人的UI'
- en: In general, there are façade libraries for most of the native implementations
    of web technologies, which are well battle tested. Developers are very good at
    simplifying these and sharing the code with others, thanks to the open source
    movement. Still, when using other people’s modules, make sure they are “safe.”
    Don’t reinvent the wheel, and don’t repeat yourself But now, it is time to move
    on to the next pattern in our list.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大多数Web技术的本地实现都有门面库，这些库经过良好的实战测试。开发者非常擅长简化这些库，并通过开源运动与其他人共享代码。然而，当使用他人的模块时，请确保它们是“安全”的。不要重复造轮子，也不要重复自己。但现在，是时候继续到我们列表中的下一个模式了。
- en: The callback pattern
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调模式
- en: 'The callback pattern is easy to understand. It applies when an operation needs
    to be executed after a **synchronous** or **asynchronous** operation has finished.
    For this, the function invocation includes, as one of the parameters, a function
    to be executed when the operations are completed. Having said that, we need to
    distinguish between the following two types of code flow:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 回调模式易于理解。当需要在同步或异步操作完成后执行操作时适用。为此，函数调用包括一个参数，该参数是在操作完成后要执行的功能。话虽如此，我们需要区分以下两种代码流类型：
- en: Synchronous operations are executed one after another in sequential order. It
    is the basic code flow, top to bottom.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步操作按顺序依次执行。这是基本的代码流，从上到下。
- en: Asynchronous operations are executed out of the normal flow once invoked. Their
    length is uncertain, as well as their success or failure.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步操作一旦被调用，就会在正常流程之外执行。它们的长度不确定，以及它们的成功或失败。
- en: It is for asynchronous cases that the *callback pattern* is especially useful.
    Think, for example, of a network call. Once invoked, we don’t know how long it
    will take to get an answer from the server and whether it will succeed, fail,
    or throw an error. If we didn’t have asynchronous operations, our application
    would be *frozen*, waiting until a resolution happens. That would not be a good
    user experience, even though it would be computationally correct.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步情况，*回调模式*特别有用。例如，考虑一个网络调用。一旦调用，我们不知道从服务器获取答案需要多长时间，也不知道它是否会成功、失败或抛出错误。如果没有异步操作，我们的应用将会*冻结*，等待直到有结果出现。这不会是一个好的用户体验，尽管从计算上是正确的。
- en: One important feature in JavaScript is that, being single-threaded, asynchronous
    functions don’t block the main thread allowing the execution to continue. This
    is important since the rendering functions of the browser run on the same thread.
    However, this is not free as they do consume resources, but they won’t freeze
    the UI, at least in theory. In practice, it will depend on a number of factors
    heavily influenced by the browser environment and the hardware. Still, let’s stick
    to the theory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的一个重要特性是，由于它是单线程的，异步函数不会阻塞主线程，允许执行继续。这是很重要的，因为浏览器的渲染函数是在同一个线程上运行的。然而，这并不是免费的，因为它们确实消耗资源，但它们不会冻结UI，至少在理论上是如此。在实践中，这将取决于许多因素，这些因素受到浏览器环境和硬件的严重影响。不过，我们还是坚持理论。
- en: 'Let’s see an example of a synchronous callback function and turn it asynchronous.
    The example function is very simple: we will calculate the Fibonacci value of
    a given number using the callback pattern. But first, a refresher on the formula
    for the calculation:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个同步回调函数的例子，并将其转换为异步。示例函数非常简单：我们将使用回调模式计算给定数字的斐波那契值。但首先，让我们回顾一下计算公式：
- en: '[PRE24]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So, here is a JavaScript function that applies the formula and receives a callback
    to return the value. Notice that this function is synchronous:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里有一个JavaScript函数，它应用公式并接收一个回调来返回值。注意，这个函数是同步的：
- en: ./chapter 2/callback-1.js - Synchronous Fibonacci
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/callback-1.js - 同步斐波那契
- en: '[PRE25]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice how instead of returning the value with `return`, we are passing it
    as a parameter to the `callback` function. When is it useful to use such a thing?
    Consider these simple examples:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意看，我们不是用`return`返回值，而是将值作为参数传递给`callback`函数。什么时候使用这种做法是有用的呢？考虑以下简单的例子：
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Just by replacing the callback function, we can considerably alter how the
    result is presented. However, the example function has a fundamental flaw affecting
    the user experience. Being synchronous, the calculation time is proportional to
    the parameter passed: the larger `n`, the more time it will take. With a sufficiently
    large number, we can easily hang up the browser, but also, much before that, we
    can freeze the interface. You can test that the execution is synchronous with
    the following snippet:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 只需替换回调函数，我们就可以显著改变结果的呈现方式。然而，这个示例函数有一个影响用户体验的基本缺陷。由于它是同步的，计算时间与传递的参数成正比：`n`越大，所需时间越长。使用足够大的数字，我们很容易挂起浏览器，但在那之前，我们就可以冻结界面。你可以通过以下片段测试执行是否是同步的：
- en: '[PRE27]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To turn this simple function into an asynchronous function, you can simply
    wrap the logic inside a `setImmediate` call. This will take the execution out
    of the normal workflow. The new function now looks like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个简单的函数转换成异步函数，你只需将逻辑封装在`setImmediate`调用中即可。这将使执行脱离正常的工作流程。新的函数现在看起来是这样的：
- en: '[PRE28]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, we use an arrow function to wrap up the code without any modifications.
    Now, see the difference when we execute the same snippet as before with this function:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用箭头函数来封装代码，没有任何修改。现在，看看我们用这个函数执行与之前相同的片段时的区别：
- en: '[PRE29]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see by the output, the snippet outputs `After` before `34`. This
    is because our asynchronous operation has been taken out of the normal flow as
    expected. When calling an asynchronous function, the execution *does not wait*
    for a result and continues executing the next instruction. This can be confusing
    at times but is very powerful and useful. However, the pattern does not prescribe
    how to handle errors or failed operations or how to chain or sequentially run
    multiple calls. There are different ways to deal with those cases, but they are
    not part of the pattern. There is another way to handle asynchronous operations
    that offers more flexibility and control: *promises.* We will see this next, and
    in most cases, you can use either pattern interchangeably. I say, “in most cases,”
    not all!'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出片段在`34`之前输出了`After`。这是因为我们的异步操作已经按照预期从正常流程中移除。在调用异步函数时，执行*不会等待*结果，而是继续执行下一个指令。有时这可能会让人困惑，但它非常强大且有用。然而，这种模式并没有规定如何处理错误或失败的操作，或者如何链式或顺序地运行多个调用。处理这些情况有不同的方法，但它们不是模式的一部分。还有另一种处理异步操作的方法，它提供了更多的灵活性和控制：*承诺（promises）*。我们将在下一节看到这一点，在大多数情况下，你可以互换使用这两种模式。我说“在大多数情况下”，并不是所有情况！
- en: The promise pattern
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺模式
- en: 'The *promises pattern* is made primarily to deal with asynchronous operations.
    Just like with callbacks, the invocation of a promised function takes the execution
    out of the normal flow, but it returns a special object called `Promise`. This
    object exposes a simple API with three methods: `then`, `catch`, and `finally`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`promises`模式主要是为了处理异步操作。就像回调一样，承诺函数的调用会使执行脱离正常流程，但它返回一个特殊对象，称为`Promise`。这个对象提供了一个简单的API，包括三个方法：`then`、`catch`和`finally`：'
- en: The `then` method receives two callback functions, traditionally called `resolve`
    and `reject`. They are used in the asynchronous code to return a successful value
    (`resolve`) or a failed or negative value (`reject`).
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then`方法接收两个回调函数，传统上称为`resolve`和`reject`。在异步代码中，它们用于返回成功值（`resolve`）或失败或负值（`reject`）。'
- en: The `catch` method receives an `error` parameter and is triggered when the process
    throws an `error` and the execution is interrupted.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch`方法接收一个`error`参数，当过程抛出`error`并中断执行时被触发。'
- en: The `finally` method executes in either case and receives a callback function.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finally`方法在两种情况下都会执行，并接收一个回调函数。'
- en: While a promise is running, it is said to be in an *indeterminate* state until
    it is resolved or rejected. There is no time limit for how long a promise will
    wait in this state, something that makes it especially useful for lengthy operations
    such as network calls and **inter-process** **communication** (**IPC**).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个Promise正在运行时，它处于一个*不确定*状态，直到它被解决或拒绝。Promise在这个状态下等待的时间没有时间限制，这使得它在处理长时间操作（如网络调用和**进程间通信**（IPC））时特别有用。
- en: 'Let’s see how to implement the previous example with the Fibonacci series using
    promises:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Promise实现之前的斐波那契数列示例：
- en: '[PRE30]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At first sight, it is easy to see that the implementation has changed a bit.
    We start on line `//1` by immediately returning a `new Promise()` object. This
    constructor receives a callback function, that will, in turn, receive two callbacks
    named `resolve()` and `reject()`. We need to use these in our logic to return
    a value in case of success (`resolve`) or failure (`reject`). Also notice that
    we don’t have to wrap our code in a `setImmediate` function, as a promise is by
    nature asynchronous. We now check for negative numbers and then reject the operation
    in that case (line `//2`). The other change we make is to replace the `callback()`
    invocation for `resolve()` in lines`//3` and `//4`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，很容易看出实现方式略有变化。我们从第`//1`行开始，立即返回一个`new Promise()`对象。这个构造函数接收一个回调函数，该函数反过来会接收两个名为`resolve()`和`reject()`的回调。我们需要在我们的逻辑中使用这些回调，以便在成功时返回值（`resolve`）或失败时返回值（`reject`）。注意，我们不需要将我们的代码包裹在`setImmediate`函数中，因为Promise本质上就是异步的。我们现在检查负数，并在这种情况下拒绝操作（第`//2`行）。我们做的另一个改变是在第`//3`行和第`//4`行用`resolve()`替换了`callback()`调用。
- en: 'The invocation now also changes:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 调用现在也发生了变化：
- en: '[PRE31]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, we chain to the invocation, the `then` method, and pass to
    it the two functions for success and failure (`resolve` and `reject` in our code).
    Just like before, we get the same output. Now, this may seem more verbose (it
    is), but the benefits greatly outweigh the extra typing. Promises are chainable,
    meaning that for successful operations, you can return a new promise and, that
    way, have a sequential operation. Here is an example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将`then`方法链接到调用，并传递给它成功和失败的两个函数（在我们的代码中是`resolve`和`reject`）。就像之前一样，我们得到了相同的结果。现在，这可能会显得更冗长（确实是），但好处远远超过了额外的输入。Promise是可链式的，这意味着对于成功的操作，你可以返回一个新的Promise，从而实现顺序操作。以下是一个例子：
- en: '[PRE32]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are other methods exposed by the `Promise` constructor, such as `.all`,
    but I will refer you to the documentation to dig deeper into the possibilities
    and syntax ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)).
    Still, quite verbose. Lucky for us, JavaScript provides us with a simplified syntax
    to handle promises, **async/await,** and think of them as a way to code in a more
    “traditional” way. This only applies to the invocation of promised functions and
    can only be used in functions.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`构造函数还公开了其他方法，例如`.all`，但我将向您推荐查阅文档以深入了解可能性和语法（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)）。尽管如此，仍然相当冗长。幸运的是，JavaScript为我们提供了一个简化的语法来处理Promise，即**async/await**，我们可以将其视为一种更“传统”的编码方式。这仅适用于Promise函数的调用，并且只能在函数中使用。'
- en: 'To see this as an example, let’s imagine that we have three functions that
    return promises, named `MyFuncA`, `MyFuncB`, and `MyFuncC` (yes, I know, not the
    greatest names). Each one returns, in case of success, *one single value* (this
    is a condition). These are then used within `MyProcessFunction` with the new syntax.
    Here is the declaration:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们假设我们有三个返回Promise的函数，分别命名为`MyFuncA`、`MyFuncB`和`MyFuncC`（是的，我知道，这些名字不是很好）。每个函数在成功的情况下返回一个*单个值*（这是一个条件）。然后，这些函数在`MyProcessFunction`中使用新的语法。以下是声明：
- en: '[PRE33]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We start by declaring our function with the `async` keyword (line `//1`). This
    signals to the interpreter that we will use the `await` syntax inside our function.
    One condition is to wrap the code in a `try...catch` block. Then, we can use the
    `await` keyword in front of the invocation of each promised function call, as
    in line `//3`. By line `//4`, we are certain that each variable has received a
    value. Certainly, this approach is easier to follow and read.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `async` 关键字声明我们的函数（行 `//1`）。这向解释器表明我们将在函数内部使用 `await` 语法。一个条件是必须将代码包裹在
    `try...catch` 块中。然后，我们可以在每个承诺函数调用的调用前使用 `await` 关键字，就像行 `//3` 一样。到行 `//4` 时，我们可以确信每个变量都已接收到值。当然，这种方法更容易遵循和阅读。
- en: 'Let’s investigate the equivalences for the line:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查以下行的等价性：
- en: '[PRE34]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will match the *thenable* (using `.``then`) syntax:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这将与*thenable*（使用 `.then`）语法相匹配：
- en: '[PRE35]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, the problem with this last syntax is that we need to make sure that
    all the variables `a`, `b`, and `c` have values before we can run line `//4`,
    `console.log(a+b+c)`, which would mean chaining the invocations like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种最后一种语法的缺点是我们需要确保所有变量 `a`、`b` 和 `c` 都有值，我们才能运行行 `//4` 的 `console.log(a+b+c)`，这意味着需要像这样链式调用：
- en: '[PRE36]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This format is harder to follow and certainly more verbose. For these cases,
    the `async/await` syntax is preferred.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式更难遵循，当然也更冗长。在这些情况下，`async/await` 语法更受欢迎。
- en: The use of promises is great for wrapping lengthy or uncertain operations and
    integrating with other patterns that we have seen (façade, decorator, etc.). It
    is an important pattern to keep in mind that we will use extensively in our applications.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺（promises）来封装长时间或不确定的操作，以及与其他我们已看到的模式（如外观模式、装饰器模式等）集成是非常有用的。这是一个重要的模式，我们需要牢记，我们将在我们的应用程序中广泛使用它。
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen principles for software development and important
    design patterns, with examples in plain JavaScript and, when appropriate, hinted
    at implementations with Vue 3\. These patterns can be hard to grasp the first
    time you see them, but we will use them and return to them in the rest of the
    book so that this chapter will work as a reference. This will give you a better
    idea of when and how to apply different patterns according to the needs of your
    application.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了软件开发的原则和重要的设计模式，以及使用纯 JavaScript 的示例，在适当的时候，也暗示了使用 Vue 3 的实现。这些模式在第一次看到时可能很难理解，但我们将使用它们，并在本书的其余部分回顾它们，以便本章可以作为参考。这将让您更好地了解根据您应用程序的需求何时以及如何应用不同的模式。
- en: In the next chapter, we will start to implement a project from scratch and will
    set the foundations for the applications we will build in the rest of the book.
    As we move forward, we will reference these patterns to help you consolidate their
    application.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从头开始实现一个项目，并为本书其余部分将要构建的应用程序奠定基础。随着我们的前进，我们将参考这些模式来帮助您巩固它们的应用。
- en: Review questions
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: What is the difference between a principle and a pattern?
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原则和模式之间的区别是什么？
- en: Why is the singleton pattern so important?
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式为什么如此重要？
- en: How can you manage dependencies?
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何管理依赖关系？
- en: What patterns make reactivity possible?
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些模式使得反应性成为可能？
- en: Do patterns intertwine? Why? Can you give an example?
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式是否交织在一起？为什么？你能给出一个例子吗？
- en: What is asynchronous programming, and why is it so important?
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程是什么，为什么它如此重要？
- en: Can you think of use cases for *promised* functions?
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能想到哪些适用于*承诺*函数的使用案例吗？
