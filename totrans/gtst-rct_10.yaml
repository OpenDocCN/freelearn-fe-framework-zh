- en: Chapter 10. What's Next
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。接下来是什么
- en: Until now, we have covered all the topics from building a React-based JavaScript
    application from scratch, integrating it with the Facebook Graph API, digging
    into the various stages of a component, it's life cycle, validating, testing,
    and deploying the apps. With that, we have reached the end of this book, but let's
    explore some advanced topics in React world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从零开始构建基于React的JavaScript应用程序，将其与Facebook Graph API集成，深入探讨组件的各个阶段，生命周期，验证，测试和部署应用程序的所有主题。有了这些，我们已经到达了这本书的结尾，但让我们探索React世界的一些高级主题。
- en: 'In this chapter, we will be exploring the following topics briefly because
    it''s not possible to cover everything in detail within one chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要探讨以下主题，因为在一章中不可能详细涵盖所有内容：
- en: AJAX in React
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React中的Ajax
- en: React Router
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router
- en: Server-side rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: Isomorphic applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同构应用程序
- en: Hot reloading
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热重载
- en: Redux React
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux React
- en: Relay and GraphQL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Relay和GraphQL
- en: React Native
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native
- en: AJAX in React
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React中的Ajax
- en: 'Like in any other applications, AJAX in a React-based application can be used
    to fetch data asynchronously. According to the Facebook documentation of loading
    the data from the server using AJAX ([https://facebook.github.io/react/tips/initial-ajax.html](https://facebook.github.io/react/tips/initial-ajax.html)),
    you need to remember some of the key points as mentioned here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在任何其他应用程序中一样，在基于React的应用程序中，可以使用Ajax异步获取数据。根据Facebook关于使用Ajax从服务器加载数据的文档([https://facebook.github.io/react/tips/initial-ajax.html](https://facebook.github.io/react/tips/initial-ajax.html))，你需要记住以下提到的关键点：
- en: 'Include the jQuery library in your HTML:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的HTML中包含jQuery库：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because there is no separate Ajax-only library from jQuery that can be used,
    the entire jQuery has to be used in a React-based application, while using Ajax.
    Downloading the minified version of jQuery from cdn results in much less load
    time.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于没有单独的Ajax库可以从jQuery中引用，因此在React应用程序中使用Ajax时，必须使用整个jQuery，这会导致下载jQuery的压缩版本，从而大大减少加载时间。
- en: Load the data in the life cycle phase of `componentDidMount`. This method occurs
    only once during the life cycle on the client, and any child components can be
    accessed in this phase. Any external js library or loading data using AJAX is
    advised to be done in this phase.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`componentDidMount`的生命周期阶段加载数据。此方法在客户端的生命周期中只发生一次，并且在这个阶段可以访问任何子组件。建议在此阶段执行任何外部js库或使用Ajax加载数据。
- en: The `isMounted` method is used to check whether the component is mounted in
    the DOM. Although this is used with AJAX before `setState()`, this method will
    be deprecated while using ES6 syntaxes, which use `React.component`, and may be
    entirely removed in future React versions. Refer to [https://facebook.github.io/react/docs/component-api.html](https://facebook.github.io/react/docs/component-api.html).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isMounted`方法用于检查组件是否已挂载在DOM中。尽管这个方法在`setState()`之前与Ajax一起使用，但在使用ES6语法（使用`React.component`）时，这个方法将被弃用，并且可能在未来的React版本中完全删除。请参阅[https://facebook.github.io/react/docs/component-api.html](https://facebook.github.io/react/docs/component-api.html)。'
- en: 'Here is the code of `index.html`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`index.html`的代码：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the code for `index.js`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`index.js`的代码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![AJAX in React](img/00061.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![React中的Ajax](img/00061.jpeg)'
- en: React with Ajax ([https://facebook.github.io/react/tips/initial-ajax.html](https://facebook.github.io/react/tips/initial-ajax.html))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ajax的React ([https://facebook.github.io/react/tips/initial-ajax.html](https://facebook.github.io/react/tips/initial-ajax.html))
- en: React Router
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Router
- en: React Router is a library based on top of the React library, which helps in
    easy and quick routing of an application with multiple pages. Although it may
    be possible to build such a flow in the application without the React-router,
    as the application grows with many pages, it becomes cumbersome to identify the
    child-parent relationship between the pages. This is where React-router comes
    to our rescue, where it identifies how to build the nested UIs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: React Router是基于React库的库，它有助于轻松快速地路由具有多个页面的应用程序。尽管在没有React-router的情况下可能构建这样的应用程序流程，但随着应用程序的增长，拥有许多页面，识别页面之间的父子关系变得繁琐。这就是React-router发挥作用的地方，它确定了如何构建嵌套UI。
- en: 'Sources:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：
- en: '[https://github.com/reactjs/react-router](https://github.com/reactjs/react-router)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/reactjs/react-router](https://github.com/reactjs/react-router)'
- en: '[https://www.npmjs.com/package/react-router](https://www.npmjs.com/package/react-router)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.npmjs.com/package/react-router](https://www.npmjs.com/package/react-router)'
- en: Server-side rendering
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: Server-side rendering in ReactJS is done by JavaScript (NodeJS or io.js). This
    method actually prerenders the initial state of the React components at the server
    side. Thus, it is helpful in fast rendering of web pages, as the users can see
    the web pages without having to wait for the entire JavaScript at the client side
    to finish loading.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS 的服务器端渲染是通过 JavaScript（NodeJS 或 io.js）完成的。这种方法实际上在服务器端预先渲染 React 组件的初始状态。因此，它有助于快速渲染网页，因为用户可以在客户端的
    JavaScript 完成加载之前看到网页。
- en: However, this kind of rendering should not be used for those applications where
    a huge amount of data has to be piped from the server to the client side, which
    may slow the page load. In such cases, we may use pagination or bulk load the
    data in chunks, which won't slow the page load, but can be fetched from the server
    side in specific time intervals.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种渲染方式不适用于那些需要从服务器向客户端传输大量数据的应用程序，这可能会减慢页面加载速度。在这种情况下，我们可以使用分页或分块批量加载数据，这样不会减慢页面加载速度，但可以在特定的时间间隔内从服务器端获取。
- en: The following two methods from the React API provides the backbone of server-side
    rendering ([https://facebook.github.io/react/docs/top-level-api.html](https://facebook.github.io/react/docs/top-level-api.html)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: React API 的以下两种方法提供了服务器端渲染的骨干（[https://facebook.github.io/react/docs/top-level-api.html](https://facebook.github.io/react/docs/top-level-api.html)）。
- en: ReactDOMServer
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReactDOMServer
- en: The `react-dom/server` package allows you to render your components on the server.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-dom/server` 包允许您在服务器上渲染您的组件。'
- en: The `ReactDOMServer.renderToString` method returns a string. It generates two
    additional DOM attributes—`data-React-id` and `data-React-checksum`—which are
    used internally by the ReactJS library.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactDOMServer.renderToString` 方法返回一个字符串。它生成两个额外的 DOM 属性—`data-React-id` 和
    `data-React-checksum`—这些属性由 ReactJS 库内部使用。'
- en: This method renders an element of `ReactElement` to the initial HTML of the
    view and returns an HTML string.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将 `ReactElement` 的元素渲染到视图的初始 HTML 中，并返回一个 HTML 字符串。
- en: It should only be used while using the server-side rendering and at the server
    side.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 应仅在服务器端渲染和服务器端使用。
- en: During the initial page load, sending this method from the server to the client
    results in faster page load and enables web crawling for **search engine optimization**
    (**SEO**).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始页面加载期间，从服务器向客户端发送此方法会导致页面加载速度更快，并启用针对 **搜索引擎优化**（**SEO**）的网页抓取。
- en: When the `ReactDOM.render()` is called to any node previously, React will attach
    event handlers on those nodes, resulting in faster page loads.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ReactDOM.render()` 被调用到任何先前节点时，React 将在这些节点上附加事件处理器，从而加快页面加载速度。
- en: 'The syntax is:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `ReactDOMServer.renderToStaticMarkup` method is similar to `renderToString`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactDOMServer.renderToStaticMarkup` 方法与 `renderToString` 类似。'
- en: It is used mainly to generate static pages.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它主要用于生成静态页面。
- en: 'The syntax is:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to illustrate the example of the server-side rendering in ReactJS,
    we can use `express` (the minimalistic web framework for NodeJS applications)
    at the server side.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 ReactJS 服务器端渲染的示例，我们可以在服务器端使用 `express`（NodeJS 应用程序的简约型网络框架）。
- en: The `npm update`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm update`'
- en: The `npm install express`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm install express`'
- en: '`npm init`: This will generate a `package.json` file'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm init`：这将生成一个 `package.json` 文件'
- en: 'Add the content mentioned later in the `index.js` file to initiate a simple
    web application running on port `3000` using express. The same example can be
    found in the readme file of the `node_modules/express` directory:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将稍后提到的内容添加到 `index.js` 文件中，以使用 express 在端口 `3000` 上启动一个简单的网络应用程序。相同的示例可以在 `node_modules/express`
    目录的 readme 文件中找到：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We first begin with declaring the app as an instance of express.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明应用程序为 express 的一个实例。
- en: We then denote the basic routing by the express server. In this example, the
    express instance (app) is using the `GET` HTTP method. Thus, when `app.get` calls
    the default path (`/`) or any PATH on the server, the third parameter being the
    HANDLER, should send a response `Hello World` to the client (browser) when the
    route is matched.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 express 服务器来表示基本路由。在这个例子中，express 实例（app）正在使用 `GET` HTTP 方法。因此，当 `app.get`
    调用默认路径（`/`）或服务器上的任何路径时，第三个参数作为 HANDLER，应该当路由匹配时向客户端（浏览器）发送响应 `Hello World`。
- en: The application runs on port `3000`. You can run the app on any port as per
    your requirement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在端口 `3000` 上运行。您可以根据需要运行应用程序在任何端口上。
- en: Execute the application using the node command on the express file`:`
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 node 命令在 express 文件上执行应用程序：`
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using express, we can now see the example of ReactJS server-side rendering:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用express，我们现在可以看到ReactJS服务器端渲染的示例：
- en: 'Within your app directory, execute the following command to download express:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序目录中，执行以下命令来下载express：
- en: '[PRE7]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From the `express.js` file, we will be calling the React component
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `express.js` 文件中，我们将调用React组件
- en: 'Here is the code for creating the `ReactComponent`, without using JSX:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建 `ReactComponent` 的代码，不使用JSX：
- en: 'The `ReactComponent.js` file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactComponent.js` 文件：'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After running the express with the above command as node index.js from your
    app's root dir in the terminal, we will be seeing the following screenshot in
    our browser's `localhost:3000`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中从您的应用程序根目录运行以下命令 `node index.js` 来启动express后，我们将在浏览器中的 `localhost:3000`
    看到以下截图。
- en: '![ReactDOMServer](img/00062.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![ReactDOMServer](img/00062.jpeg)'
- en: Express JS simple app
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Express JS 简单应用程序
- en: Here is the explanation on the earlier-mentioned code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对之前提到的代码的解释。
- en: '`createElement` is the primary type of React, which has four properties (`types`,
    `properties`, `keys`, `ref`). The highlighted code mentioned earlier means that
    it will create a React element of the type list (`li`), which does not have any
    property but will pass the values from the React-rendered component''s property
    (whose key name is `argument`).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`createElement` 是React的主要类型，它有四个属性（`types`、`properties`、`keys`、`ref`）。之前提到的突出显示的代码意味着它将创建一个类型为列表（`li`）的React元素，它没有任何属性，但将从React渲染组件的属性（其键名为`argument`）传递值。'
- en: According to the Facebook documentation ([https://facebook.github.io/react/docs/top-level-api.html](https://facebook.github.io/react/docs/top-level-api.html))
    for the React API, the highlighted code with respect to `renderToStaticMarkup`
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Facebook文档（[https://facebook.github.io/react/docs/top-level-api.html](https://facebook.github.io/react/docs/top-level-api.html)）中的React
    API，关于 `renderToStaticMarkup` 的突出显示代码。
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*"Similar to `renderToString`, except this doesn''t create extra DOM attributes
    such as `data-react-id`, that React uses internally. This is useful if you want
    to use React as a simple static page generator, as stripping away the extra attributes
    can save lots of bytes."*'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"类似于 `renderToString`，但这个不会创建React内部使用的额外DOM属性，如 `data-react-id`。如果您想将React用作简单的静态页面生成器，移除这些额外属性可以节省大量字节。"*'
- en: '`renderToString` renders `ReactElement` to its initial HTML. This should only
    be used on the server. React will return an HTML string. You can use this method
    to generate HTML on the server and send the markup down on the initial request
    for faster page loads and to allow search engines to crawl your pages for SEO
    purposes.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToString` 将 `ReactElement` 渲染为其初始HTML。这应该在服务器上使用。React将返回一个HTML字符串。您可以使用此方法在服务器上生成HTML，并在初始请求中发送标记，以加快页面加载速度，并允许搜索引擎为了SEO目的抓取您的页面。'
- en: If you call `ReactDOM.render()` on a node that already has this server-rendered
    markup, React will preserve it and only attach event handlers, allowing you to
    have a very fast first-load experience.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在已经具有此服务器端渲染标记的节点上调用 `ReactDOM.render()`，React将保留它，并且只附加事件处理器，这样您就可以拥有非常快速的首次加载体验。
- en: 'The code for the `express.js` file is:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`express.js` 文件的代码如下：'
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After running the express with the above command as node index.js from your
    app's root dir in the terminal, we will be seeing the following screenshot in
    our browser's `localhost:4000`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中从您的应用程序根目录运行以下命令 `node index.js` 来启动express后，我们将在浏览器中的 `localhost:4000`
    看到以下截图。
- en: '![ReactDOMServer](img/00063.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![ReactDOMServer](img/00063.jpeg)'
- en: The screenshot of the application, React with server-side rendering, showing
    default pages. As we can see, the port in which the app is listening is `4000`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序的截图，显示了React服务器端渲染的默认页面。正如我们所见，应用程序监听的端口是 `4000`。
- en: In case of dynamic routes, this is the screenshot of React with server-side
    rendering, showing other pages.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态路由的情况下，这是React服务器端渲染的截图，显示了其他页面。
- en: '![ReactDOMServer](img/00064.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![ReactDOMServer](img/00064.jpeg)'
- en: As mentioned earlier, if we use `renderToString` instead of `renderToStaticMarkup`,
    we can see two attributes such as `data-react-id` and `data-react-checksum` in
    the React component.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果我们使用 `renderToString` 而不是 `renderToStaticMarkup`，我们可以在React组件中看到两个属性，例如
    `data-react-id` 和 `data-react-checksum`。
- en: '`data-react-id`: is the custom data attribute that the ReactJS library uses
    to specifically identify it''s components within DOM. It can be present both at
    the client or the server side, whereas the one present at the server starts with
    a dot followed by some letters and then numbers, the IDs present at client side
    are only numbers.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-react-id`：是ReactJS库用来在DOM中特定识别其组件的自定义数据属性。它可以在客户端或服务器端存在，而服务器端存在的ID以点开头，后面跟一些字母和数字，客户端侧的ID仅是数字。'
- en: 'The following example shows the earlier method `rederToString()`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了早期的方法`rederToString()`：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Rerunning the express with the above changes, will render the following in the
    browser's `localhost:4000`, as depicted in the screenshot below.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行express并应用上述更改，将在浏览器中的`localhost:4000`渲染以下内容，如以下截图所示。
- en: '![ReactDOMServer](img/00065.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![ReactDOMServer](img/00065.jpeg)'
- en: A screenshot of the application, React with server-side rendering, using method
    `renderToString`
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的截图，使用服务器端渲染的React，采用`renderToString`方法。
- en: To sum up, we can see that React-router is a library that is capable of running
    both at the server side and at the client side (browser). In order to use the
    server-side rendering, we use the `renderToString()` method along with the routes.
    During the request-response cycle, the React-router on the server matches with
    the requested route and renders the correct route from the server to the client
    (browser) using the `renderToString()` method of the React library.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以看到React-router是一个能够在服务器端和客户端（浏览器）运行的库。为了使用服务器端渲染，我们使用`renderToString()`方法和路由。在请求-响应周期中，服务器端的React-router与请求的路由匹配，并使用React库的`renderToString()`方法将正确的路由从服务器渲染到客户端（浏览器）。
- en: Isomorphic applications
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同构应用程序
- en: '**Isomorphic JavaScript applications** are those where JavaScript is used both
    at the server and client side. Thus, the same React component can be used both
    at the client as well as at the server side. Some of the advantages of building
    such applications are:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**同构JavaScript应用程序**是指JavaScript同时在服务器和客户端使用的情况。因此，相同的React组件可以在客户端以及服务器端使用。构建此类应用程序的一些优点包括：'
- en: Whenever required, render the view at the server side based on the application
    state
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要时，根据应用程序状态在服务器端渲染视图。
- en: The server will render the application in exactly the same way the client would
    have rendered for increased consistency
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器将以与客户端相同的方式渲染应用程序，以增加一致性。
- en: In case the JavaScript in the browser is not working, the application would
    still work because the same JavaScript is present at the server side as well.
    You need to send the action to the server in order to attain the same result.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果浏览器中的JavaScript无法正常工作，应用程序仍然可以工作，因为服务器端也存在相同的JavaScript。您需要将操作发送到服务器以获得相同的结果。
- en: Hot reloading
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热重载
- en: '**Hot reloading** is a term used in the JavaScript world, which is used to
    refer to live changes in the browser without the browser being refreshed. In the
    React ecosystem, React Hot Loader is widely used for the same purpose.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**热重载**是JavaScript世界中的一个术语，用来指代浏览器中的实时更改，而无需刷新浏览器。在React生态系统中，React Hot Loader被广泛用于相同的目的。'
- en: React Hot Loader is a plugin for Webpack, which results in instantaneous and
    live changes in the browser, without losing states. The changes can be visible
    while editing React components and functions as `LiveReload` for React.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: React Hot Loader 是一个针对 Webpack 的插件，它可以在浏览器中实现即时和实时的更改，而不会丢失状态。在编辑React组件和函数时，这些更改可以可见，就像React的`LiveReload`一样。
- en: Some limitations of the react hot loader first version have been discussed by
    the author (Dan Abramov) here at [https://medium.com/@dan_abramov/the-death-of-react-hot-loader-765fa791d7c4#.fc78lady9](https://medium.com/@dan_abramov/the-death-of-react-hot-loader-765fa791d7c4#.fc78lady9).
    The details of the project can be found at [https://gaearon.github.io/react-hot-loader/](https://gaearon.github.io/react-hot-loader/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作者（Dan Abramov）在这里讨论了React Hot Loader第一版本的局限性[https://medium.com/@dan_abramov/the-death-of-react-hot-loader-765fa791d7c4#.fc78lady9](https://medium.com/@dan_abramov/the-death-of-react-hot-loader-765fa791d7c4#.fc78lady9)。项目的详细信息可以在[https://gaearon.github.io/react-hot-loader/](https://gaearon.github.io/react-hot-loader/)找到。
- en: Redux React
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux React
- en: '**Redux** is a JavaScript library designed by Dan Abramov, which helps in containerization
    of the states for the JavaScript applications. As the application grows, the complexity
    rises due to the requirement of the back and forth state updatability between
    the model and the view. Redux came to the rescue to solve this crooked complex
    path of state mutation and asynchronism. Thus, it defines itself as an attempt
    to make predictable state mutations.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redux** 是由Dan Abramov设计的JavaScript库，它帮助JavaScript应用程序的状态容器化。随着应用程序的增长，由于模型和视图之间需要双向状态可更新性的要求，复杂性也随之增加。Redux的出现是为了解决这种扭曲的复杂状态变更和异步问题。因此，它将自己定义为尝试使状态变更可预测。'
- en: 'It can be used with React or any other view library. Some of the key points
    to be remembered while using Redux are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以与React或任何其他视图库一起使用。在使用Redux时需要记住的一些关键点如下：
- en: The state of the JavaScript application is stored entirely inside the same object
    tree inside a *single store*. Thus, even when the application grows, it's easier
    to debug. The development phase is also faster as the entire application state
    is in one place. The state is read only; there are only getters in the state and
    no setters as you are unable to write to this store.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript应用程序的状态完全存储在同一个对象树中的单个存储中。因此，即使应用程序增长，调试也更容易。由于整个应用程序状态都在一个地方，开发阶段也更快。状态是只读的；状态中只有获取器，没有设置器，因为你无法写入这个存储。
- en: Any change to the state can only be done by emitting an *action*. The action
    is nothing but an object that describes the changes that happened. These action
    objects can be logged, serialized, stored, and replayed later in order to debug.
    Except for these actions, no views or network callback can change the state. This
    restriction makes the changes in the state mutation predictable, without the hassle
    of looking out for any transient hidden changes.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对状态的任何更改都只能通过发出一个*动作*来完成。动作不过是一个描述发生变化的对象。这些动作对象可以被记录、序列化、存储，并在以后重新播放以进行调试。除了这些动作之外，没有任何视图或网络回调可以更改状态。这种限制使得状态变更可预测，无需寻找任何瞬时的隐藏变化。
- en: The third component in Redux is *reducers*. Reducers tell how the actions change
    the state tree. The reducers are nothing but functions that have the previous
    state and an action. The reducers therefore act as the setters for the state store
    as they are setting the new state. Any change to be performed is not on the actual
    state object but on the copy of the state object (new state object). A single
    root reducer can be used in simple applications, whereas you can delegate to multiple
    child reducers (by passing additional data) as the number of tasks grow.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux的第三个组件是*reducers*。Reducers告诉动作如何改变状态树。Reducers实际上就是具有前一个状态和动作的函数。因此，reducers充当状态存储的设置器，因为它们正在设置新状态。任何要执行的改变都不是在实际的状态对象上，而是在状态对象的副本（新状态对象）上。在简单应用程序中可以使用单个根reducer，而当任务数量增加时，可以委托给多个子reducers（通过传递额外的数据）。
- en: 'Source:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：
- en: '[http://redux.js.org/docs/basics/UsageWithReact.html](http://redux.js.org/docs/basics/UsageWithReact.html)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://redux.js.org/docs/basics/UsageWithReact.html](http://redux.js.org/docs/basics/UsageWithReact.html)'
- en: Relay and GraphQL
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Relay和GraphQL
- en: '**Relay** is a framework in ReactJS for **declarative data fetching**, which
    solves the problem of updating the data in a React-based application and where
    exactly it has to be updated. Using GraphQL, the Relay framework decouples *what*
    data is to be fetched from *how* it should be fetched.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Relay** 是ReactJS中的一个用于**声明式数据获取**的框架，它解决了在基于React的应用程序中更新数据以及确切更新位置的问题。使用GraphQL，Relay框架解耦了要获取的数据与如何获取数据之间的关系。'
- en: GraphQL is like a query language to query a graph though not typically a graph
    like those represented in pie charts, x, y axes, or Venn diagrams.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL就像是一种查询语言，用于查询一个图，尽管它通常不是一个像饼图、x轴、y轴或维恩图所表示的图。
- en: It's used to query from a relationship graph, where each node and the relationship
    between them are represented as edges.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于从关系图中查询，其中每个节点以及它们之间的关系都表示为边。
- en: In order to fetch data from a subset of such a relationship-based graph, GraphQL
    is very useful.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了从基于关系图的一个子集中获取数据，GraphQL非常有用。
- en: Unlike in representational state transfer (REST) where data is fetched from
    the server based on server endpoint using resources, in GraphQL data are fetched
    from the server based on the requirement by the client.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与在表示状态传输（REST）中不同，在REST中，数据是根据服务器端点使用资源从服务器获取的，而在GraphQL中，数据是根据客户端的要求从服务器获取的。
- en: Thus, the data is decoupled, and all the data are fetched at one go from the
    server within a single network request.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，数据被解耦，所有数据都在单个网络请求中一次性从服务器获取。
- en: Data can be stored and retrieved from a cache with ease and this results in
    faster performance.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以轻松地存储和检索缓存，这导致性能更快。
- en: Any write operation is named a mutation. It's not a 1:1 relationship between
    the data change in the disk which GraphQL stores and returns to the developer.
    The best way is to use a query that is the intersection between the cached-date
    and the data that may change.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何写操作都被称为变异。GraphQL存储在磁盘上的数据变化与返回给开发者的数据之间不是一对一的关系。最好的方法是使用一个查询，它是缓存数据和可能发生变化的数据的交集。
- en: For an in-depth understanding of the Relay framework, refer to [https://facebook.github.io/relay/docs/thinking-in-relay.html#content](https://facebook.github.io/relay/docs/thinking-in-relay.html#content).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入了解Relay框架，请参阅[https://facebook.github.io/relay/docs/thinking-in-relay.html#content](https://facebook.github.io/relay/docs/thinking-in-relay.html#content)。
- en: React Native
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native
- en: 'As the name suggests, **React Native** is used to build native applications
    in iOS and Android platforms using JavaScript and ReactJS. Some of the key features
    of React Native, favored by the Facebook developer teams ([https://facebook.github.io/react-native/](https://facebook.github.io/react-native/))
    for the native platforms, are mentioned here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，**React Native**用于在iOS和Android平台使用JavaScript和ReactJS构建原生应用程序。以下是React
    Native的一些关键特性，这些特性受到Facebook开发团队的青睐（[https://facebook.github.io/react-native/](https://facebook.github.io/react-native/)），用于原生平台：
- en: It has the power of consistency in look and feel using React component counterparts
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用React组件的对应物具有外观和感觉的一致性
- en: You can develop the app using Chrome developer tools and run in a simulator
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用Chrome开发者工具开发应用程序并在模拟器中运行
- en: There is asynchronous execution of all the code between the application and
    the native platform
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序和原生平台之间的所有代码都有异步执行
- en: React Native seamlessly handles touch events, polyfills, StyleSheet abstraction,
    designing common UI layouts
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native无缝处理触摸事件、polyfills、StyleSheet抽象、设计常见的UI布局
- en: It's widely used to extend native code creating iOS and Android modules and
    views and reusing them later, with ease
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被广泛用于扩展原生代码，创建iOS和Android模块和视图，并且可以轻松地稍后重用
- en: React Native's qualities of being declarative, asynchronous, and responsive
    are highly beneficial for iOS development
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native的声明性、异步性和响应性特性对于iOS开发非常有用
- en: References
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: Note that the list here is nothing near to an exhaustive one, there are plethora
    of good articles, blog posts, and newer ones budding each new day.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的列表远非详尽无遗，有大量的优秀文章、博客文章和每天新涌现的更多内容。
- en: 'Here are some of the sites to keep an eye on:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要关注的网站：
- en: '[https://facebook.github.io/react/blog/](https://facebook.github.io/react/blog/)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[React博客](https://facebook.github.io/react/blog/)'
- en: '[https://egghead.io](https://egghead.io)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[egghead.io](https://egghead.io)'
- en: '[https://code-cartoons.com/](https://code-cartoons.com/)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[代码漫画](https://code-cartoons.com/)'
- en: 'The following are some of the communities on social media:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些社交媒体上的社区：
- en: '[https://twitter.com/ReactJSNews](https://twitter.com/ReactJSNews)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ReactJS新闻](https://twitter.com/ReactJSNews)'
- en: '[https://twitter.com/reactjs](https://twitter.com/reactjs)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[reactjs](https://twitter.com/reactjs)'
- en: '[https://twitter.com/dan_abramov](https://twitter.com/dan_abramov)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[dan_abramov](https://twitter.com/dan_abramov)'
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: ReactJS is a vibrant JS community. There are many changes and advancements in
    the JavaScript ecosystem happening on a daily basis. Keeping ourselves up to date
    is a mammoth and essential task. We can closely track the latest in JS world by
    following them on social platforms, question-answer forums, their websites, attending
    conferences and, last but not the least, always getting our hands dirty.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS是一个充满活力的JS社区。JavaScript生态系统每天都在发生许多变化和进步。保持我们自己的更新是一个庞大而必要的任务。我们可以通过在社交平台上关注他们、问答论坛、他们的网站、参加会议以及最后但同样重要的是，始终保持我们的实践来密切跟踪JS世界的最新动态。
- en: For any comments, suggestions or discussion feel free to contact us at `@doelsengupta`,
    `@singhalmanu`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何评论、建议或讨论，请随时通过`@doelsengupta`，`@singhalmanu`联系我们。
