- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to this immersive chapter on testing in React. In this chapter, we will
    learn the importance of software testing, understand the different types of testing
    – including unit, integration, and **end-to-end** (**E2E**) testing – and delve
    into the use of popular testing tools such as Cypress, Jest, and the React Testing
    Library. In addition, we will demystify concepts such as stubbing and mocking,
    ensuring you are well-equipped to handle complex testing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Our overarching goal is to foster a solid understanding of testing strategies
    and their implementation in React. We aim to enhance your ability to write tests
    that make your application resilient to bugs and regressions and ensure the seamless
    addition of new features.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have a comprehensive understanding of React
    testing and be ready to implement efficient testing practices in your projects.
    So, let’s get started and step into the exciting world of React testing!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding why we need tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about different types of tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing individual units with Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about E2E tests using Cypress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GitHub repository has been created to host all the code we’ll discuss in this
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch5](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch5).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding why we need tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is not just an optional best practice; it’s a critical part of building
    reliable and maintainable software. Without tests, you’re essentially navigating
    the complex seas of software development without a compass. Let’s understand the
    multiple benefits that testing brings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ensuring code correctness**: Tests serve as a seal of validation that your
    code performs exactly the way it’s supposed to. A well-written test verifies that
    your functions return the expected output for a given input, your components render
    correctly, and your application behaves as anticipated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preventing regression**: As applications grow and evolve, new code can sometimes
    unintentionally break existing functionality. This is known as a **regression**.
    Automated tests act as a safety net, catching these regressions before they reach
    production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facilitating refactoring and maintenance**: Fear often surrounds the process
    of refactoring or updating legacy code. Tests alleviate this fear. They provide
    a comfort zone, assuring that if you accidentally break something during the update
    or refactoring process, your tests will catch it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boosting confidence in code quality**: Tests elevate the confidence level
    of your team. When a suite of well-written tests backs your code, you have a quantifiable
    measure of your code’s quality. This assurance is especially beneficial when you’re
    adding new features or making changes to the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: Tests also serve as a form of documentation. They provide
    a clear understanding of what a function or component is supposed to do, helping
    new developers on the team understand the project’s functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the subsequent sections, we’ll delve deeper into the various types of testing
    you’ll commonly use in React applications and learn how to use testing tools effectively.
    Buckle up for an engaging ride into the realm of software testing.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about different types of tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing, in the realm of software development, isn’t a one-size-fits-all approach.
    Rather, it is categorized into different types, each serving a distinct purpose
    and offering unique insights into the functionality and reliability of the application.
    It is important to understand these categories to ensure the overall health and
    robustness of your application. Typically, you will have unit tests, integration
    tests, and E2E tests in one code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define each type here briefly and discuss each type in detail in the
    following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: These tests focus on testing individual components or functions
    in isolation to ensure they work as expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration tests**: These tests examine the interactions between different
    modules or services to verify they work together cohesively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E2E tests**: These tests test the entire application flow from start to finish,
    mimicking real-world user behavior to validate that the system works as a whole'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How you structure your tests in a project also matters. For example, you should
    have a lot of unit tests that run fast and can provide detailed feedback, and
    you should have only a few E2E tests to ensure all the parts work together. This
    approach aligns with the principles of the test pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Originally conceived by Mike Cohn, the **test pyramid** recommends having a
    larger number of unit tests compared to integration or E2E tests. The reasoning
    is simple – unit tests are quicker, simpler, and more cost-effective to maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: The traditional test pyramid](img/B31103_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: The traditional test pyramid'
  prefs: []
  type: TYPE_NORMAL
- en: However, in the modern frontend world, this model is evolving. More value is
    being placed on integration and E2E tests due to the increasing complexity and
    interactivity of frontend applications. Tools such as Cypress and Puppeteer facilitate
    writing E2E tests that emulate user behavior on the browser, while libraries such
    as the React Testing Library encourage more integration tests by making it easier
    to test component interactions.
  prefs: []
  type: TYPE_NORMAL
- en: New types of tests are also introduced in frontend applications. The visual
    regression tests is one of them. **Visual regression testing** is a method of
    testing in which the visual aspects of a web application are captured and compared
    to previous states or versions. This type of testing is particularly useful in
    catching unintended visual bugs and changes in a user interface that may be introduced
    during development.
  prefs: []
  type: TYPE_NORMAL
- en: Visual regression tests work by taking screenshots (or snapshots) of web pages
    or components at different stages, and then comparing these screenshots pixel
    by pixel to identify any visual differences. When a difference is detected, it
    is flagged for review. The review can then determine if the change is expected
    (due to a new feature or design update) or if it’s an unintended regression that
    needs to be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: In frontend testing, **static checks** involve analyzing code without executing
    it to identify errors and ensure coding standards. This includes checking for
    syntax errors, enforcing coding style through linting, verifying correct data
    types with type checking, analyzing code complexity, examining dependencies, and
    identifying security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact shape of your test pyramid might vary depending on your application’s
    needs, but the critical takeaway is to have a balanced testing strategy that provides
    quick and useful feedback at different levels of your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: The enhanced test pyramid](img/B31103_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: The enhanced test pyramid'
  prefs: []
  type: TYPE_NORMAL
- en: The next sections in this chapter will give you hands-on experience in writing
    these types of tests for a React application, ensuring that you are well-equipped
    to bring these concepts into your projects. Let’s forge ahead!
  prefs: []
  type: TYPE_NORMAL
- en: Testing individual units with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests are the smallest and most foundational part of the testing pyramid,
    verifying the behavior of individual units of code in isolation, such as functions,
    methods, or components. These tests are quick to write and execute, offering immediate
    feedback to developers.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Jest to write unit tests and integration tests in this book. Jest
    is a comprehensive JavaScript testing framework built by Facebook, with a strong
    focus on simplicity. It’s feature-rich and supports asynchronous testing, mocking,
    and snapshot testing, making it a great choice for React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s write a simple test. Say you have an `add` function in a file called
    `math.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this function, you must create a `math.test.ts` file in the same directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve now written your first test! The `test` function takes two arguments:
    a string description of the test and a callback function that implements the test.
    `expect` is a Jest function that takes the actual value, and `toBe` is a matcher
    function that compares the actual value with the expected value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of writing a test is to use the `it` function. In Jest, `test`
    and `it` are actually the same function and can be used interchangeably; the names
    just come from different testing conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test`: This is a common name for a test function in many testing frameworks
    and languages. If you come from a background of using other testing libraries,
    you might find `test` to be more intuitive or familiar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it`: This comes from **behavior-driven development** (**BDD**) style frameworks
    such as Jasmine or Mocha.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea of using `it` is to make the tests read more like sentences. For example,
    `it("adds 1 + 2 to equal 3", () => expect(1 + 2).toBe(3))` reads like “it adds
    1 + 2 to equal 3.”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: BDD is a software development approach that emphasizes collaboration between
    developers, QA, and non-technical participants in a software project. It highlights
    the need to start with a clear understanding of desired behavior before development
    starts, thereby aligning development with business needs.
  prefs: []
  type: TYPE_NORMAL
- en: BDD encourages expressing software behaviors in plain, descriptive language
    that can be read and understood by all stakeholders. It leverages executable specifications,
    often written in a language such as Gherkin, that guide development and serve
    as acceptance criteria.
  prefs: []
  type: TYPE_NORMAL
- en: BDD aims to reduce misunderstandings by encouraging collaboration, making the
    behavior of a system explicit and understandable by all, and ensuring that the
    software developed truly meets the needs of the business.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a matter of team preference and what aligns best with your team’s testing
    philosophy – some teams prefer the sentence-like structure that it provides as
    it often makes it clearer what a test is trying to verify, especially to non-developers,
    while others might find `test` to be more straightforward and less verbose. We’re
    going to write tests that follow the BDD style in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grouping related tests in one block significantly improves the readability of
    your test files. By clearly delineating different areas of functionality, a block
    allows anyone reading the tests to understand the context of the test suite at
    a glance. This enhanced understanding is crucial for comprehension of what functionality
    is being verified. In a large code base, with numerous tests, this organization
    can greatly decrease the cognitive load required to understand how different parts
    of the application are tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Jest, we can use the `describe` function to group related tests into one
    unit. For instance, consider a function, `add`, that includes multiple cases:
    the addition of negative numbers, the combination of one negative and one positive
    number, decimal sums, or even computations involving imaginary numbers. It would
    be prudent to gather all these distinct cases under one `describe` block, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `describe` function is used to group related tests – in this case, tests
    for some math functions. Within this group, there are two `it` functions, each
    representing a single test. The first test checks if the `add` function correctly
    adds two positive numbers, and the second test checks if the `add` function correctly
    adds two negative numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Jest, you can nest `describe` blocks to organize your tests more systematically.
    For example, suppose we’re expanding our suite to include subtraction, multiplication,
    and division in our calculator functionality. We can structure our test suite
    in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we have a top-level `describe` block labeled `calculator`.
    Within this block, we have nested `describe` blocks for each mathematical operation.
    For instance, in the `addition` block, we have individual `it` tests for different
    scenarios of adding numbers. Similarly, we start a new describe block for `subtraction`.
    This nested structure makes our test suite more organized, readable, and easier
    to navigate, particularly when dealing with a large number of tests or complex
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Testing React components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, Jest is a great tool for testing different types
    of applications, and it supports React applications out of the box. Although it’s
    possible to use Jest alone, it would be a bit more cumbersome and verbose than
    using a dedicated library such as the **React** **Testing Library**.
  prefs: []
  type: TYPE_NORMAL
- en: The React Testing Library is a lightweight yet powerful library for testing
    React components. It’s built on top of the popular JavaScript testing framework,
    Jest, and adds specific utilities for working with React components. The philosophy
    of the React Testing Library is to encourage writing tests that closely resemble
    how your software is used. It encourages you to interact with your app just like
    how users would, meaning you test the functionality and not the implementation
    details. This approach leads to more robust and maintainable tests that will give
    you confidence that your app will work in production.
  prefs: []
  type: TYPE_NORMAL
- en: In the code provided in this book, the project has already been set up for you
    with the React Testing Library. Simply clone the code mentioned in the *Technical
    requirements* section into your local directory and you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'All right – let’s start with a simple React component to see how we can test
    it with the React Testing Library. The `Section` component is a presentational
    component that accepts two props, `heading` and `content`, and renders the props
    in an `article` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the component, we can create a new file next to `Section.tsx`, which
    we will call `Section.test.tsx`. This is where our test code will live. Then,
    we’ll use the React Testing Library to check the `Section` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This test code makes use of `@testing-library/react` to verify that the `Section`
    component behaves as expected – the text `@testing-library/react` is used to render
    the `Section` component with specific props: a heading of **Basic** and content
    of **Hello world**.'
  prefs: []
  type: TYPE_NORMAL
- en: Following the rendering, the `screen.getByText` function is used to query the
    DOM (which represents the rendered output of the `Section` component) for elements
    containing specific text.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `expect` and `toBeInTheDocument` are then used to make assertions about
    the state of these elements. Specifically, the test is asserting that there is
    an element with the `Section` component has correctly rendered its heading and
    content props.
  prefs: []
  type: TYPE_NORMAL
- en: This straightforward unit test for a React component serves as a useful starting
    point. However, in complex real-world projects, we often encounter scenarios where
    multiple components need to interact harmoniously. For instance, consider a checkout
    page that integrates an address collection component, a payment component, and
    a price calculation logic component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confidently ensure the seamless interaction of these distinct components,
    we must employ a more comprehensive testing strategy: integration tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration tests are positioned above unit tests in the pyramid, validating
    the interactions between multiple units of code. These could be component interactions
    or interactions between the client side and server side. Integration tests aim
    to identify issues that may arise when different parts of the system are combined.
  prefs: []
  type: TYPE_NORMAL
- en: One such scenario involves testing the interaction between two separate components
    to verify that they function correctly together – this is integration testing
    at a UI component level. Additionally, if you’re looking to ensure smooth collaboration
    between your frontend code and backend services, the tests you write for this
    purpose would also be classified as integration tests, which verify that different
    layers of your application are working correctly together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at an example of an integration test for a React component.
    In *Figure 5**.3*, there is a **Terms and Conditions** section, which includes
    a long text about the legal information, and a checkbox for the user to consent.
    There is also a **Next** button, which is disabled by default. However, once the
    user selects **Accept the Terms and Conditions**, the button will be enabled,
    and the user can proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: The Terms and Conditions component](img/B31103_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: The Terms and Conditions component'
  prefs: []
  type: TYPE_NORMAL
- en: 'This integration test can be described using the following code snippet – we
    are not testing the **Checkbox** and **Next** buttons separately, but verifying
    the interaction between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `describe` function is used to group all tests associated with the `TermsAndConditions`
    component, forming a so-called test suite. Within this suite, we have a single
    test case denoted by the it function. The description of this test is **renders
    learn react link**, which appears to be a misnomer considering the operations
    carried out in this test. A more suitable description might be **Enables the next
    button upon accepting terms** **and conditions**.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, the `render` function is invoked to display the `TermsAndConditions`
    component. This function produces a series of output, or render results, that
    can be queried in various ways to assess whether the component behaves as expected.
  prefs: []
  type: TYPE_NORMAL
- en: We then try to find a button by its text, `screen.getByText` function – which
    returns the element found on the page. At this point, we expect this button to
    be disabled, so we confirm this expectation by calling `expect(button).toBeDisabled()`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look for the checkbox using the `screen.getByRole` function. This function
    allows us to find the checkbox based on its role, which is `checkbox`.
  prefs: []
  type: TYPE_NORMAL
- en: The user interaction of ticking the checkbox is simulated using the `userEvent.click`
    function, which is wrapped in React’s `act` function. The `act` function ensures
    that all updates related to these actions are processed and applied before moving
    forward; this way, our assertions will examine the component in its updated state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we verify that the button is enabled after the checkbox has been clicked.
    This is done using `expect(button).toBeEnabled()`. If this statement holds true,
    we know that our component behaves as intended – that is, disabling the **Next**
    button until the user accepts the terms and conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at how the code is written. The `TermsAndConditions` component
    under test is composed of a few components – `heading`, `LegalContent`, and `UserConsent`.
    Plus, `UserConsent` itself is composed of `CheckBox` and `Button`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The sole component that gets exported in this code is `TermsAndConditions`,
    which is the primary subject of our testing strategy. In our tests, we employ
    `userEvent.click` to initiate a click event within the realm of a `jsdom` environment.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, our focus is not on testing the isolated React components (such
    as `CheckBox` and `Button`; they should have their own unit tests), but rather
    on the DOM elements and their interactions. It’s important to clarify that we’re
    not invoking a full-fledged browser here, but rather a headless `jsdom` variant
    that exists in memory. Yet, despite the simulated environment of these integration
    tests, they still provide us with the confidence that the click event and button
    enablement are functioning as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**jsdom** is a JavaScript-based headless browser that can be used to create
    a realistic testing environment that simulates a web browser’s environment. It
    is an implementation of web standards such as HTML, DOM, CSS, and others, entirely
    in JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: When we run JavaScript that manipulates the DOM in a browser, the browser provides
    the DOM. However, when we are running tests using a testing framework such as
    Jest in a Node.js environment, there isn’t a DOM by default. This is where `jsdom`
    comes into play. `jsdom` provides a virtual DOM, thereby allowing our tests to
    run as though they were in a browser-like environment, even when they’re running
    in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need `jsdom`? In modern frontend development, particularly with frameworks
    such as React, Angular, and Vue, our JavaScript code often interacts directly
    with the DOM. For our tests to be useful, they need to be able to simulate this
    interaction. `jsdom` allows us to do this without needing to open a browser window.
  prefs: []
  type: TYPE_NORMAL
- en: In integration tests, we concentrate on the interactions between various modules.
    However, even if these interactions function as expected, there’s still a possibility
    that the broader system may break. User journeys often involve multiple steps,
    so it’s essential to have a process that seamlessly connects these steps to ensure
    the software continues to work reliably.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about E2E tests using Cypress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: E2E tests are at the top of the test pyramid. E2E tests simulate real user flows
    and interactions, testing the system as a whole. These tests help ensure that
    all parts of the application work together as expected, from the user interface
    to the backend systems.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to use Cypress as the E2E test framework in this book. **Cypress**
    is a powerful tool for E2E testing of modern web applications. Its unique approach
    sets it apart from many other testing tools – instead of using Selenium, a common
    engine for many testing systems, Cypress operates directly on the actual browser,
    resulting in more reliable tests and a superior debugging experience.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Cypress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can either install Cypress into an existing project (like what we’re doing
    in this book) or install it in another folder other than your project. Cypress
    has been added as a project dependency in the code base in GitHub (provided in
    the *Technical requirements* section), so you only need to run `npm install` in
    the project root (refer to the official documentation for more information: [https://docs.cypress.io/guides/getting-started/installing-cypress](https://docs.cypress.io/guides/getting-started/installing-cypress)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed the package, simply run `npx cypress open` to launch
    the configuration wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: The Cypress wizard – choosing a test type](img/B31103_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: The Cypress wizard – choosing a test type'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the wizard to configure **E2E Testing**, and choose **Chrome** as the
    browser for running all the tests. After that, choose **Create** **new spec**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: The Cypress wizard – creating a spec from a template](img/B31103_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: The Cypress wizard – creating a spec from a template'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cypress will create a folder with all the necessary files for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break his structure down:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top level, we have the `cypress` directory, which is the root directory
    for all the Cypress-related files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `downloads` directory is usually where files downloaded during Cypress tests
    would be stored; we’re not going to use it here as we don’t have anything to save
    at this stage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `e2e` directory is where E2E test files are located. In this case, it contains
    `quote-of-the-day.spec.cy.js` (generated from the Cypress wizard), a Cypress test
    file for testing the quote-of-the-day feature of an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fixtures` directory is a place to put external static data that your tests
    will use. We can put some static files that can be used in our tests (for example,
    if our tests need some JSON data for mocking the network’s response).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `support` directory houses Cypress commands and support files, which we
    will not touch either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have the folder structure set up, we can proceed and write our first
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Running our first E2E test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s modify the `quote-of-the-day.spec.cy.js` file to make it access a remote
    website. Cypress will actively watch the files under the `cypress/e2e/` folder,
    and whenever the content changes, it will rerun the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have launched cypress in a terminal window (either Terminal for
    MacOS/Linux or Windows Terminal) with `npx` `cypress open`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, `describe` is used to declare a test suite – in this case,
    for the quote of the day feature. Within this suite, there’s a single test case
    defined by it, labeled `display the heading`. The purpose of this test case is
    to visit a web page – in this instance, [https://icodeit-juntao.github.io/quote-of-the-day/](https://icodeit-juntao.github.io/quote-of-the-day/)
    – and this web page returns a random quote each time the user refreshes the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it’s important to note that this test case doesn’t perform any actual
    tests or assertions yet. It merely navigates to the page. To make this a meaningful
    test, you would typically add assertions to check the state of specific elements
    on the page, such as the heading or a quote displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet is a meaningful test now. After visiting `https://icodeit-juntao.github.io/quote-of-the-day/`,
    this test now contains an additional check with the `cy.contains()` method. The
    `cy.contains()` method is used to search for and get a DOM element that contains
    the specified text – in this case, **Quote of the day**. This method will get
    the first element it finds that contains the text, and it will fail the test if
    no such element is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the test can pass, we’re confident that the URL is accessible to the public,
    and the page doesn’t throw any exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Running E2E tests inside Cypress Test Runner](img/B31103_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Running E2E tests inside Cypress Test Runner'
  prefs: []
  type: TYPE_NORMAL
- en: Note that in *Figure 5**.6*, on the right-hand side of the screen, you can see
    what is displayed on the real browser, while on the left-hand side, you can see
    the test cases and steps. You can even use the mouse to hover on a step to see
    the page snapshot at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we can add another test case to verify that a quote container
    is present on the page; that is the most important part of the quote of the day
    application – to make sure a quote shows up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this test, the `cy.get()` method is used to retrieve a DOM element by its
    `data-testid` attribute. This attribute is typically used for testing, allowing
    you to select elements without the need to worry about their CSS selectors or
    contents, which might change over time.
  prefs: []
  type: TYPE_NORMAL
- en: The element that’s being selected in this test has a `data-testid` attribute
    of `quote-container`. Once the element is retrieved, the `should()` method is
    invoked to assert something about the state of that element. In this case, it
    checks that the length of the element (that is, the number of matching elements)
    is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this test, after navigating to the web page, it looks for an element
    with the `data-testid` attribute of `quote-container`, and checks that exactly
    one such element exists. If it does, the test will pass; if not (either because
    there are no matching elements or more than one), the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is awesome, but there is a problem here: what if the page isn’t blank
    and the heading is rendered correctly, but the actual content of a quote doesn’t
    show up for some reason? Alternatively, what if the quotes are visible but we’re
    uncertain about the expected quotes when we’re writing the tests? Consider, for
    instance, the [https://icodeit-juntao.github.io/quote-of-the-day/](https://icodeit-juntao.github.io/quote-of-the-day/)
    website, which generates random quotes each time it’s accessed. Different users
    may encounter different quotes at various times. To address these variables, we
    need a structured method for testing applications with such unpredictable behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting the network request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, we don’t want to send actual network requests for the UI to work,
    while in other cases, it’s not practical to rely on the response directly. We
    want to verify whether the quote is rendered correctly by checking the content,
    but as the quoted content is generated randomly, we cannot predict it before we
    make the network request. This means we need a mechanism to pin down the response,
    but we would also like to send the request.
  prefs: []
  type: TYPE_NORMAL
- en: One way to achieve that is to intercept the network request that’s sent to the
    endpoint and return some fixed data. In Cypress, we can do that through the `cy.intercept`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we can define a data array in the `quote-of-the-day.spec.cy.js` file.
    It’s a normal JavaScript array that contains the data we expect to return from
    the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the testing code, we aim to capture any network requests that are sent to
    URLs beginning with `https://api.quotable.io/quotes/random`. Whenever the request
    is sent from React, Cypress will cancel the request and return the `quotes` array
    instead; this means the test doesn’t depend on whether the remote service is working
    or not. That way, our test is more stable. We can see the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `cy.intercept` function is being used to stub the HTTP GET request to the
    quote API. When such a request is detected, rather than letting the request go
    through to the actual API, Cypress will respond with a predefined HTTP response.
    This response has a status code of 200, indicating success, and the body of the
    response is set to be our predefined quotes data. This technique allows us to
    control the data being returned, making our test more deterministic and isolated
    from any potential instability or variation in the actual API.
  prefs: []
  type: TYPE_NORMAL
- en: The test then navigates to the quote web page. After the page is loaded, it
    verifies if the page contains the expected quote text and the quote author. If
    these two checks pass, the test case succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: Something is interesting here that we need to highlight. An E2E test, by definition,
    tests the whole software stack from the frontend through to the backend, including
    all the intermediate layers, such as databases and network infrastructure. E2E
    testing aims to simulate real-world scenarios and confirm that the entire application
    is functioning correctly.
  prefs: []
  type: TYPE_NORMAL
- en: However, when we use the `cy.intercept` function to stub HTTP requests, we are
    indeed modifying this behavior. We are no longer testing the complete E2E flow
    because we are controlling and replacing the actual backend response with a mock
    response. This technique transforms the test from an E2E test into something more
    akin to an integration test for the frontend as we are testing the integration
    of different components of the frontend while mocking the backend responses.
  prefs: []
  type: TYPE_NORMAL
- en: This is not necessarily a bad thing, however. Often, in testing, especially
    in complex systems, it is beneficial to isolate different parts of the system
    to gain more control over what we are testing and to ensure we can test different
    scenarios more reliably and deterministically.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve covered the basics of Cypress for E2E testing and you’re now
    equipped to write robust E2E tests for your web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we embarked on an exploration of the world of testing in a
    React application. We understood that the necessity of testing goes beyond mere
    validation of code correctness; it paves the path toward maintainability, improves
    readability, and drives the evolution of our application, ultimately ensuring
    we build software that meets expectations consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is a vital practice in software development – one that ensures our application
    not only works correctly but is also resilient to future changes. The React ecosystem,
    with tools such as Jest, the React Testing Library, and Cypress, provides us with
    a powerful arsenal to implement comprehensive testing strategies, thus bolstering
    the robustness and reliability of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look into the common refactoring techniques and see
    how tests can help us during the refactoring process.
  prefs: []
  type: TYPE_NORMAL
