<html><head></head><body>
<div id="_idContainer042">
<h1 class="chapter-number" id="_idParaDest-78"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-79"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.2.1">Combining Streams</span></h1>
<p><span class="koboSpan" id="kobo.3.1">So far, we have learned about the reactive pattern to fetch data as streams and have covered error-handling patterns. </span><span class="koboSpan" id="kobo.3.2">However, we have only explored the asynchronous data emitted from only one stream. </span><span class="koboSpan" id="kobo.3.3">What if we want to work with the asynchronous data emitted from different streams? </span><span class="koboSpan" id="kobo.3.4">Do you know how we </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">can proceed?</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Luckily, RxJS ships with one of the most powerful concepts: combining streams. </span><span class="koboSpan" id="kobo.5.2">Combining streams is the process of bringing together the emissions of multiple Observables in one stream. </span><span class="koboSpan" id="kobo.5.3">This allows you to explore multiple sources of asynchronous data as if they were a single stream. </span><span class="koboSpan" id="kobo.5.4">The main idea behind combining streams is manipulating asynchronous data in a more </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">structured way.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">This chapter revolves around a common use case, which is filtering data; we will resolve this by combining streams. </span><span class="koboSpan" id="kobo.7.2">We will start by explaining the filtering requirement, and then we will explore the imperative, classic pattern that can be used to implement this requirement, followed by a declarative, reactive implementation. </span><span class="koboSpan" id="kobo.7.3">Finally, we will highlight the common pitfalls to avoid when combining streams and discuss </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">best practices.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Defining the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">filtering requirement</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Exploring the imperative pattern for </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">filtering data</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Exploring the declarative pattern for </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">filtering data</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Highlighting common pitfalls and </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">best practices</span></span></li>
</ul>
<h1 id="_idParaDest-80"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">The source code of this chapter (except the samples) is available </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">at </span></span><a href="https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap05"><span class="No-Break"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap05</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.23.1">.</span></span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.24.1">Defining the filtering requirement</span></h1>
<p><span class="koboSpan" id="kobo.25.1">In our recipe application, we want to filter the</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.26.1"> displayed </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.27.1">recipes according to certain criteria to refine the results. </span><span class="koboSpan" id="kobo.27.2">The following figure shows the implementation of the mockup described in the </span><em class="italic"><span class="koboSpan" id="kobo.28.1">View 1 – The landing page</span></em><span class="koboSpan" id="kobo.29.1"> section of </span><a href="B21180_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.30.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.31.1">, </span><em class="italic"><span class="koboSpan" id="kobo.32.1">Walking Through </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.33.1">our Application</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.35.1"><img alt="Figure 5.1 – The filtering requirement" src="image/B21180_05_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.36.1">Figure 5.1 – The filtering requirement</span></p>
<p><span class="koboSpan" id="kobo.37.1">From a user’s perspective, the user will fill out some criteria in the </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">Filters</span></strong><span class="koboSpan" id="kobo.39.1"> area and click on the </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">See results</span></strong><span class="koboSpan" id="kobo.41.1"> button to see the</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.42.1"> results that match the </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.43.1">filled criteria. </span><span class="koboSpan" id="kobo.43.2">The user can filter by using the keywords in the recipe title, recipe category, ingredients, tags, preparation, and cooking time. </span><span class="koboSpan" id="kobo.43.3">A filtering functionality is a must in the majority of applications that display </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">data collections.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">When it comes to filtering, there are a lot of strategies you can adopt, and the choice depends highly on the size of </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">your data:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.47.1">If you have a small volume of data that you can fetch entirely on the client side, then it is unnecessary to perform server-side filtering; instead, it is faster to perform client-side filtering, which will not harm your </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">application’s performance.</span></span></li>
<li><span class="koboSpan" id="kobo.49.1">If you have a large amount of data, then you should be lazy when loading your data through pagination or virtual scroll in order to enhance the performance and the user experience as well. </span><span class="koboSpan" id="kobo.49.2">Therefore, in this case, conducting server-side filtering is unavoidable since you don’t have all the data on the </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">client side.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.51.1">For demonstration purposes, we will filter only 11 recipes in total. </span><span class="koboSpan" id="kobo.51.2">So we’re going to use client-side filtering (however, note that the</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.52.1"> reactive </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.53.1">pattern we’re going to discuss does not need a specific type of filtering – it can be used with both client and </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">server-side filtering).</span></span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.55.1">Exploring the imperative pattern for filtering data</span></h1>
<p><span class="koboSpan" id="kobo.56.1">In this section, we will explore </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.57.1">the imperative way to approach filtering data from the UI to the logic </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">of filtering.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Let’s start by setting up the UI code by creating a new standalone component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">RecipesFilterComponent</span></strong><span class="koboSpan" id="kobo.61.1">, under </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">src/app</span></strong><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">It is responsible for displaying the different filters to refine the initial results. </span><span class="koboSpan" id="kobo.63.3">The HTML template code of the filter component looks </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">like this:</span></span></p>
<pre class="source-code">
<a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.65.1">&lt;div class="rp-data-view"&gt;
    &lt;form [formGroup]="recipeForm"&gt;
        &lt;fieldset class="rp-filters-group"&gt;
            &lt;legend&gt;Filters&lt;/legend&gt;
            &lt;div class="rp-filter-button"&gt;
                &lt;p-button (onClick)="clearFilter()"
                label="Clear all"&gt;&lt;/p-button&gt;
            &lt;/div&gt;
            &lt;label for="title"&gt;Keyword:&lt;/label&gt;
            &lt;input type="text" id="title"
            formControlName="title"&gt;
            &lt;label for="category"&gt;Category:&lt;/label&gt;
            &lt;input type="text" id="category"
            formControlName="category"&gt;
            &lt;label for="ingredient"&gt;Ingredient:&lt;/label&gt;
            &lt;input type="text" id="ingredient"
            formControlName="ingredient"&gt;
            &lt;label for="text"&gt;Tags:&lt;/label&gt;
            &lt;input type="text" id="tags"
            formControlName="tags"&gt;
            &lt;label for="text"&gt;Preparation Time:&lt;/label&gt;
            &lt;input type="text" id="prepTime"
            formControlName="prepTime"&gt;
            &lt;label for="text"&gt;Cooking Time:&lt;/label&gt;
            &lt;input type="text" id="cookingTime"
            formControlName="cookingTime"&gt;
            &lt;div class="rp-filter-button"&gt;
                &lt;p-button class="rp-filter-button"
                (onClick)="filterResults()" label="See
                results"&gt;&lt;/p-button&gt;
            &lt;/div&gt;
        &lt;/fieldset&gt;
    &lt;/form&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.66.1">In the previous code, we used Angular reactive</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.67.1"> forms to display the search criteria inside a form. </span><span class="koboSpan" id="kobo.67.2">Then, we included two buttons: the </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">Clear all</span></strong><span class="koboSpan" id="kobo.69.1"> button to clear the filters and the </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">See results</span></strong><span class="koboSpan" id="kobo.71.1"> button to refine the displayed items by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">filterResults()</span></strong><span class="koboSpan" id="kobo.73.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">OnClick</span></strong><span class="koboSpan" id="kobo.75.1"> callback. </span><span class="koboSpan" id="kobo.75.2">This method will replace the displayed recipes with those that match the filled criteria. </span><span class="koboSpan" id="kobo.75.3">Then, the UI will be updated automatically, thanks to the Angular change </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">detection mechanism.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.77.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.78.1">For more details about Reactive forms, please refer </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">to </span></span><a href="https://angular.dev/guide/forms/reactive-forms"><span class="No-Break"><span class="koboSpan" id="kobo.80.1">https://angular.dev/guide/forms/reactive-forms</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.81.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Now, let’s move to </span><a id="_idIndexMarker194"/><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.84.1">, where we should consider a small change in the template. </span><span class="koboSpan" id="kobo.84.2">We should bind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">[value]</span></strong><span class="koboSpan" id="kobo.86.1"> input of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">p-dataView</span></strong><span class="koboSpan" id="kobo.88.1"> component to a new property, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">filteredRecipes</span></strong><span class="koboSpan" id="kobo.90.1"> property, that holds the filtered results. </span><span class="koboSpan" id="kobo.90.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">filteredRecipes</span></strong><span class="koboSpan" id="kobo.92.1"> property initially holds all the recipes requested from the server. </span><span class="koboSpan" id="kobo.92.2">This is what the template </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
&lt;div class="card"&gt;
    &lt;p-dataView #dv [value]="filteredRecipes"
    [paginator]="true" [rows]="9" filterBy="name"
    layout="grid"&gt;
    /** Extra code here **/
    &lt;/p-dataView&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.95.1">The focus is not the </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.96.1">HTML template, of course, but the process of filtering; however, it is important to point out when providing a </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">complete workflow.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">Now let’s look at the logic of the classic pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">RecipesListComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.102.1">
export class RecipesListComponent implements OnInit,
OnDestroy {
  filteredRecipes: Recipe[] = [];
  recipes: Recipe[] = [];
  private destroy$: Subject&lt;boolean&gt; = new
  Subject&lt;boolean&gt;();
  constructor(private service: RecipesService, private fb:
  FormBuilder) {
  }
  ngOnInit(): void {
    this.service.recipes$.pipe(takeUntil(this.destroy$))
      .subscribe((recipes) =&gt; {
        this.recipes = recipes;
        this.filteredRecipes = recipes;
      });
  }
  ngOnDestroy(): void {
    this.destroy$.next(true);
    this.destroy$.unsubscribe();
  }
  filterResults(recipe:Recipe) {
    this.filteredRecipes = this.recipes.filter(recipe =&gt;
    recipe.title?.indexOf(recipe.title) !=
    -1)
  }</span></pre> <p><span class="koboSpan" id="kobo.103.1">Let’s break down what is </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.104.1">happening. </span><span class="koboSpan" id="kobo.104.2">Here, we declared </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">three variables:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">filteredRecipes</span></strong><span class="koboSpan" id="kobo.107.1">: The array that contains the filtered recipes. </span><span class="koboSpan" id="kobo.107.2">It is the property binded in the HTML template to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">[value]</span></strong><span class="koboSpan" id="kobo.109.1"> input of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">p-dataview</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.111.1"> component.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">recipes</span></strong><span class="koboSpan" id="kobo.113.1">: The initial array </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">of recipes.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">destroy$</span></strong><span class="koboSpan" id="kobo.116.1">: A subject to clean up </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">the subscription.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.118.1">Then, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">ngOninit()</span></strong><span class="koboSpan" id="kobo.120.1"> method, we called the recipes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">recipes$</span></strong><span class="koboSpan" id="kobo.122.1">) that represent our Observable recipes. </span><span class="koboSpan" id="kobo.122.2">After that, we subscribe to it and initialize the recipes and </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">filteredRecipes</span></strong><span class="koboSpan" id="kobo.124.1"> arrays with the emitted array </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">recipes$</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">As we don’t use the async pipe in this example, we should clean up the subscription manually using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.130.1"> pattern or </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">takeUntilDestroyed()</span></strong><span class="koboSpan" id="kobo.132.1">, as explained in </span><a href="B21180_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.133.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.134.1">, </span><em class="italic"><span class="koboSpan" id="kobo.135.1">Fetching Data </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.136.1">as Streams</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">filterResults(recipe:Recipe)</span></strong><span class="koboSpan" id="kobo.140.1"> method called when clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">See results</span></strong><span class="koboSpan" id="kobo.142.1"> button filters the current recipes list and returns the recipes that match the filter. </span><span class="koboSpan" id="kobo.142.2">In this sample, we considered only the title when filtering the criteria. </span><span class="koboSpan" id="kobo.142.3">The criteria are retrieved from the method input value through </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">recipe.title;</span></strong><span class="koboSpan" id="kobo.144.1">, containing the value the user filled out in the </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">title input.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.146.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.147.1">For demonstration purposes, in this imperative implementation example, we’ve chosen to display </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">RecipesFilterComponent</span></strong><span class="koboSpan" id="kobo.149.1"> within </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.151.1">. </span><span class="koboSpan" id="kobo.151.2">This approach involves sending an output event, which encapsulates the filter form’s value available in </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">RecipesFilterComponent</span></strong><span class="koboSpan" id="kobo.153.1">, to </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.155.1">. </span><span class="koboSpan" id="kobo.155.2">Subsequently, </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.157.1"> executes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">filterResult</span></strong><span class="koboSpan" id="kobo.159.1"> method based on </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">this input</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">If you use server-side filtering, in other words, if you have a service that handles filtering data according to a given criteria, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">filterResults()</span></strong><span class="koboSpan" id="kobo.163.1"> should call a backend service and will look </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.165.1">
  filterResults() {
    this.filteredRecipes =
    this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`,
    {params:{criteria:this.recipeForm.value}});
  }</span></pre> <p><span class="koboSpan" id="kobo.166.1">That’s it! </span><span class="koboSpan" id="kobo.166.2">It works fine, and I would say this is probably how most people would approach implementing filtering in an Angular application. </span><span class="koboSpan" id="kobo.166.3">The imperative way is kind of the obvious way to </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">do it.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">However, you may have noticed that we are no longer able to take advantage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">recipes$</span></strong><span class="koboSpan" id="kobo.170.1"> as a stream in the template, as explained in </span><a href="B21180_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.171.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.172.1">, </span><em class="italic"><span class="koboSpan" id="kobo.173.1">Fetching Data as Streams</span></em><span class="koboSpan" id="kobo.174.1">. </span><span class="koboSpan" id="kobo.174.2">Plus, what if your recipes service emits new recipes? </span><span class="koboSpan" id="kobo.174.3">This will overwrite the active filter until the user clicks on </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">See results</span></strong><span class="koboSpan" id="kobo.176.1"> again to update the list with the current filter. </span><span class="koboSpan" id="kobo.176.2">This can be handled imperatively, of course, but it is a shame to use Observables and not take advantage of the power </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">of reactivity.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">So, without further ado, let’s explore a better way to implement the filtering requirement</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.179.1"> by using a declarative and reactive way using the fundamentals of </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">combining streams.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">Remember, I always really want to highlight the classic way and the reactive way straight after to enable a smooth transition from imperative </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">to declarative.</span></span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.183.1">Exploring the declarative pattern for filtering data</span></h1>
<p><span class="koboSpan" id="kobo.184.1">You should think of </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.185.1">everything as a stream; this is the </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">golden rule!</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">We have </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">recipes$</span></strong><span class="koboSpan" id="kobo.189.1">, which is already </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.190.1">our </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">data stream</span></strong><span class="koboSpan" id="kobo.192.1">, but what if we consider the click on the </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">See results</span></strong><span class="koboSpan" id="kobo.194.1"> button as a stream as well? </span><span class="koboSpan" id="kobo.194.2">We will call it the </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">action stream</span></strong><span class="koboSpan" id="kobo.196.1"> and consider it an asynchronous data flow; we don’t know when it happens, but every time the user clicks on </span><strong class="bold"><span class="koboSpan" id="kobo.197.1">See results</span></strong><span class="koboSpan" id="kobo.198.1">, the action stream should emit the value of </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">the filter.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">So, in total, we need </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">two streams:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.202.1">The data stream</span></em><span class="koboSpan" id="kobo.203.1">: In our case, it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">recipes$</span></strong><span class="koboSpan" id="kobo.205.1">, which is defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.207.1">, which we created in </span><a href="B21180_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.208.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.209.1">, </span><em class="italic"><span class="koboSpan" id="kobo.210.1">Fetching Data </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.211.1">as Streams</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.213.1">
  export class RecipesListComponent {
  /*Define The data stream */
  recipes$ = this.service.recipes$;
  constructor(private service: RecipesService) { }
}</span></pre></li> <li><em class="italic"><span class="koboSpan" id="kobo.214.1">The action stream</span></em><span class="koboSpan" id="kobo.215.1">: In our case, it’s named </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">filterRecipesSubject</span></strong><span class="koboSpan" id="kobo.217.1">; it is responsible for</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.218.1"> emitting the latest value of the filter every time the user clicks on the </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">Filter results</span></strong><span class="koboSpan" id="kobo.220.1"> button. </span><span class="koboSpan" id="kobo.220.2">We will create it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">RecipesService</span></strong><span class="koboSpan" id="kobo.222.1"> service (which we also created in </span><a href="B21180_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.223.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.224.1">, </span><em class="italic"><span class="koboSpan" id="kobo.225.1">Fetching Data as Streams</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.226.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.227.1">
  /*Create The action stream */
  Private filterRecipeSubject = new
  BehaviorSubject&lt;Recipe&gt;({title:''});
  /* Extract The readonly stream */
  filterRecipesAction$ =
  this.filterRecipeSubject.asObservable();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.228.1">Now, let’s explain the previous code block. </span><span class="koboSpan" id="kobo.228.2">Here, we created </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">two attributes:</span></span></p><ul><li><span class="koboSpan" id="kobo.230.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">private</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.232.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.233.1"> named </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">filterRecipeSubject</span></strong><span class="koboSpan" id="kobo.235.1"> to prevent the external parts of the code from emitting values in the stream, erroring out, or completing the stream. </span><span class="koboSpan" id="kobo.235.2">We initialized </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">filterRecipeSubject</span></strong><span class="koboSpan" id="kobo.237.1"> with a default value—an empty object—defined in the constructor argument. </span><span class="koboSpan" id="kobo.237.2">We can use either </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">Subject</span></strong><span class="koboSpan" id="kobo.239.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.241.1"> to create our </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">action stream:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">Subject</span></strong><span class="koboSpan" id="kobo.244.1"> is a special type of Observable in that it enables multicasting. </span><span class="koboSpan" id="kobo.244.2">We will explore multicasting in detail in </span><a href="B21180_09.xhtml#_idTextAnchor146"><em class="italic"><span class="koboSpan" id="kobo.245.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.246.1">, </span><em class="italic"><span class="koboSpan" id="kobo.247.1">Demystifying Multicasting</span></em><span class="koboSpan" id="kobo.248.1">. </span><span class="koboSpan" id="kobo.248.2">For now, keep in mind that a subject is an observer and an Observable at the same time, so you can use it to share values </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">among observers.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">BehaviourSubject</span></strong><span class="koboSpan" id="kobo.251.1"> is a special type of subject that requires an initial value and always retains the last value to emit it to new subscribers. </span><span class="koboSpan" id="kobo.251.2">In other words, if you have any subscribers coming late to the game, they will get the last value emitted by the stream. </span><span class="koboSpan" id="kobo.251.3">This will always give</span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.252.1"> you a value when you subscribe. </span><span class="koboSpan" id="kobo.252.2">We will discuss why we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">BehaviourSubject</span></strong><span class="koboSpan" id="kobo.254.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">Subject</span></strong><span class="koboSpan" id="kobo.256.1"> at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">the chapter.</span></span></li></ul></li><li><span class="koboSpan" id="kobo.258.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.259.1">public</span></strong><span class="koboSpan" id="kobo.260.1"> read-only stream named </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">filterRecipeAction$</span></strong><span class="koboSpan" id="kobo.262.1"> (created from </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">filterRecipeSubject</span></strong><span class="koboSpan" id="kobo.264.1"> through the method </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">asObservable()</span></strong><span class="koboSpan" id="kobo.266.1">) so that the other parts of the app can subscribe to and get </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">the data.</span></span></li></ul></li> </ul>
<p><span class="koboSpan" id="kobo.268.1">So, just to recap, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">RecipesService</span></strong><span class="koboSpan" id="kobo.270.1"> service will now look like this after adding the previous </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.272.1">
export class RecipesService {
  recipes$ =
    this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`);
  private filterRecipeSubject = new
    BehaviorSubject&lt;Recipe&gt;({title: '' });
  filterRecipesAction$ =
    this.filterRecipeSubject.asObservable();
  constructor(private http: HttpClient) { }
}</span></pre> <p><span class="koboSpan" id="kobo.273.1">Now, it is time to combine the streams. </span><span class="koboSpan" id="kobo.273.2">Both of the streams rely on each other; when </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">recipes$</span></strong><span class="koboSpan" id="kobo.275.1"> emits a new value, the filter should stay active, and when the filter emits a new value, the recipes list should be </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">updated accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">What we are really trying to do is get information from both streams. </span><span class="koboSpan" id="kobo.277.2">Whenever you want to join information from multiple Observables, you should think of the RxJS combination strategy. </span><span class="koboSpan" id="kobo.277.3">Instead of getting the data from both streams separately, we can combine it to form a single new stream. </span><span class="koboSpan" id="kobo.277.4">RxJS has a set of combination operators to use in that matter. </span><span class="koboSpan" id="kobo.277.5">In the next section, we will explore one of the most used combination operators, which</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.278.1"> is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">combineLatest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.280.1"> operator.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.281.1">The combineLatest operator</span></h2>
<p><span class="koboSpan" id="kobo.282.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">combineLatest</span></strong><span class="koboSpan" id="kobo.284.1"> operator will </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.285.1">combine the </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.286.1">latest values emitted by the input Observables. </span><span class="koboSpan" id="kobo.286.2">So, every time one of the Observables emits, </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">combineLatest</span></strong><span class="koboSpan" id="kobo.288.1"> will emit the last emitted value from each. </span><span class="koboSpan" id="kobo.288.2">Does that make sense? </span><span class="koboSpan" id="kobo.288.3">If not, don’t worry; we will detail it further by using a marble diagram </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">as usual:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.290.1"><img alt="Figure 5.2 – The combineLatest marble diagram" src="image/B21180_05_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.291.1">Figure 5.2 – The combineLatest marble diagram</span></p>
<p><span class="koboSpan" id="kobo.292.1">Let’s break </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">this down:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.294.1">The first line in the marble diagram represents the timeline of the first </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">input Observable.</span></span></li>
<li><span class="koboSpan" id="kobo.296.1">The second line represents the timeline of the second input Observable. </span><span class="koboSpan" id="kobo.296.2">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">combineLatest</span></strong><span class="koboSpan" id="kobo.298.1"> has </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">two inputs.</span></span></li>
<li><span class="koboSpan" id="kobo.300.1">The last line represents the timeline of the output Observable returned from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">combineLatest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1"> operator.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.303.1">Now, let’s dig deeper into </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">the execution.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">The first Observable emitted the value </span><strong class="bold"><span class="koboSpan" id="kobo.306.1">a</span></strong><span class="koboSpan" id="kobo.307.1"> first. </span><span class="koboSpan" id="kobo.307.2">At that time, the second Observable had not emitted anything, and nothing was emitted from </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">combineLatest</span></strong><span class="koboSpan" id="kobo.309.1">. </span><span class="koboSpan" id="kobo.309.2">Why? </span><span class="koboSpan" id="kobo.309.3">Because </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">combineLatest</span></strong><span class="koboSpan" id="kobo.311.1"> will not emit until all the input Observables emit one value each. </span><span class="koboSpan" id="kobo.311.2">So, when the second Observable emits </span><strong class="bold"><span class="koboSpan" id="kobo.312.1">1</span></strong><span class="koboSpan" id="kobo.313.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">combineLatest</span></strong><span class="koboSpan" id="kobo.315.1"> will </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">emit </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.317.1">a1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">Bear in mind</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.320.1"> that </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">combineLatest</span></strong><span class="koboSpan" id="kobo.322.1"> will not </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.323.1">emit an initial value until each Observable emits at least </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">one value.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">Then, the first Observable emitted another value, </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">b</span></strong><span class="koboSpan" id="kobo.327.1">. </span><span class="koboSpan" id="kobo.327.2">At that time, the second Observable had not emitted anything, but its last emitted value was </span><strong class="bold"><span class="koboSpan" id="kobo.328.1">1</span></strong><span class="koboSpan" id="kobo.329.1">, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">combineLatest</span></strong><span class="koboSpan" id="kobo.331.1"> will emit the last value emitted by each input stream, which is </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">b1</span></strong><span class="koboSpan" id="kobo.333.1">. </span><span class="koboSpan" id="kobo.333.2">Then, the second Observable emitted is </span><strong class="bold"><span class="koboSpan" id="kobo.334.1">2</span></strong><span class="koboSpan" id="kobo.335.1">. </span><span class="koboSpan" id="kobo.335.2">At that time, the latest value emitted by the first Observable was </span><strong class="bold"><span class="koboSpan" id="kobo.336.1">b</span></strong><span class="koboSpan" id="kobo.337.1">, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">combineLatest</span></strong><span class="koboSpan" id="kobo.339.1"> will emit </span><strong class="bold"><span class="koboSpan" id="kobo.340.1">b2</span></strong><span class="koboSpan" id="kobo.341.1">, and so on and </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">so forth.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">Let’s come back to our example and see how we can combine the data stream and the action stream that we have just created in order to filter results reactively using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">combineLatest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.345.1"> operator.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.348.1">, we will create a new stream named </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">filteredRecipes$</span></strong><span class="koboSpan" id="kobo.350.1">, which represents the result of combining the data and the </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">action stream:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.352.1">
filterRecipesAction$ = this.service.filterRecipesAction$;</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.353.1">
filteredRecipes$ = combineLatest([this.recipes$,
  this.filterRecipesAction$])</span></pre> <p><span class="koboSpan" id="kobo.354.1">So, here, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">combineLatest</span></strong><span class="koboSpan" id="kobo.356.1"> operator and passed to it (as a parameter) an array of two values: the first one is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">recipes$</span></strong><span class="koboSpan" id="kobo.358.1"> data stream, and the second one is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">filterRecipeAction$</span></strong><span class="koboSpan" id="kobo.360.1"> action stream. </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">combineLatest</span></strong><span class="koboSpan" id="kobo.362.1"> will then return an array of two values (as the number of input Observables): the first element of the array is the last emitted value from the first stream, and the second element of the array is the last emitted value from the second stream. </span><span class="koboSpan" id="kobo.362.2">It respects </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">the order.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">Now, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">filteredRecipes$</span></strong> <a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.366.1">from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.368.1"> template, where we will bind it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">[value]</span></strong><span class="koboSpan" id="kobo.370.1"> input of </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">p-dataview</span></strong><span class="koboSpan" id="kobo.372.1"> so that the </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">following occurs:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">filteredRecipes$</span></strong><span class="koboSpan" id="kobo.375.1"> should return all the recipes when loading </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">the page</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">filteredRecipes$</span></strong><span class="koboSpan" id="kobo.378.1"> should return only the recipes that match the selected criteria </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">when filtering</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.380.1">Then, the </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.381.1">HTML </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.382.1">code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.384.1"> template will look </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.386.1">
@if (filteredRecipes$ | async; as recipes) {
&lt;div class="card"&gt;
    &lt;p-dataView #dv [value]="recipes" [paginator]="true"
    [rows]="9" filterBy="name" layout="grid"&gt;
        /** Extra code here **/
    &lt;/p-dataView&gt;
&lt;/div&gt;
} @else {
&lt;div&gt;There are no recipes&lt;/div&gt;
}</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.387.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.388.1">In the template, we have included both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">RecipesList</span></strong><span class="koboSpan" id="kobo.390.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">RecipesFilter</span></strong><span class="koboSpan" id="kobo.392.1"> components. </span><span class="koboSpan" id="kobo.392.2">This separation of components enhances the maintainability and readability of the codebase, promoting a modular and scalable architecture for </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">Still, there is one change that we need to make in </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.396.1">. </span><span class="koboSpan" id="kobo.396.2">In our UI, we want to display all the recipes when loading the page and the filtered recipes when refining the results; because of this, we need to edit </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">filteredRecipes$</span></strong><span class="koboSpan" id="kobo.398.1"> so it should not return the result of the combination directly (and in most cases, that won’t happen anyway). </span><span class="koboSpan" id="kobo.398.2">Instead, we will process the result of the combination (the returned array), take the information that we need from the combined streams, and transform it into whatever </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">we need.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">In this case, we want to modify the result stream so that rather than just giving us the latest recipes and </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.401.1">criteria values, it </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.402.1">will give us an array of recipes filtered by the received criteria </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.404.1">
filteredRecipes$ = combineLatest([this.recipes$,
  this.filterRecipesAction$]).pipe(
    map((resultAsArray:[Recipe[], Recipe]) =&gt; {
      const filterTitle =
        resultAsArray[1]?.title?.toLowerCase() ?? </span><span class="koboSpan" id="kobo.404.2">'';
      return resultAsArray[0].filter(recipe =&gt;
        recipe.title?.toLowerCase().includes(filterTitle));
    })
  );</span></pre> <p><span class="koboSpan" id="kobo.405.1">The result of the combination is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">resultAsArray</span></strong><span class="koboSpan" id="kobo.407.1"> parameter. </span><span class="koboSpan" id="kobo.407.2">The first element, </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">resultAsArray [0]</span></strong><span class="koboSpan" id="kobo.409.1">, represents the last emitted recipes from </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">recipes$</span></strong><span class="koboSpan" id="kobo.411.1">, and the second element, </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">resultAsArray [1]</span></strong><span class="koboSpan" id="kobo.413.1">, represents the last emitted criteria </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">filterRecipesAction$</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">However, we can do even better! </span><span class="koboSpan" id="kobo.417.2">We can enhance the code using the array destructuring technique </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
filteredRecipes$ = combineLatest([this.recipes$,
  this.filterRecipesAction$]).pipe(
    map(([recipes, filter]: [Recipe[], Recipe]) =&gt; {
      const filterTitle =
        filter?.title?.toLowerCase() ?? </span><span class="koboSpan" id="kobo.419.2">'';
      return recipes.filter(recipe =&gt;
        recipe.title?.toLowerCase().includes(filterTitle))
    })
  );</span></pre> <p><span class="koboSpan" id="kobo.420.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">recipes</span></strong><span class="koboSpan" id="kobo.422.1"> parameter represents the first element of the returned array, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">filter</span></strong><span class="koboSpan" id="kobo.424.1"> parameter represents the second element of the returned array. </span><span class="koboSpan" id="kobo.424.2">After </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">:</span></strong><span class="koboSpan" id="kobo.426.1">, we have the parameter types, and that’s it. </span><span class="koboSpan" id="kobo.426.2">So, instead of obtaining the elements by using the index directly, the array destructuring technique provides you with a way to name the array elements and get the values directly from those variables. </span><span class="koboSpan" id="kobo.426.3">Finally, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">filter</span></strong><span class="koboSpan" id="kobo.428.1"> method to filter the list of</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.429.1"> recipes</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.430.1"> that match </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">the criteria.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">At this point, we put in place all the mechanisms to filter the values reactively. </span><span class="koboSpan" id="kobo.432.2">The last thing left to do is update the filter value every time it changes, and this is what we’re going to explore in the </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">next section.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.434.1">Updating the filter value</span></h2>
<p><span class="koboSpan" id="kobo.435.1">As we said, every </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.436.1">time the user clicks on the </span><strong class="bold"><span class="koboSpan" id="kobo.437.1">See results</span></strong><span class="koboSpan" id="kobo.438.1"> button, </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">filterRecipesAction$</span></strong><span class="koboSpan" id="kobo.440.1"> should emit the criteria so that our </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">combineLatest</span></strong><span class="koboSpan" id="kobo.442.1"> re-executes and returns the filtered recipes. </span><span class="koboSpan" id="kobo.442.2">To achieve this, we created a new method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">updateFilter</span></strong><span class="koboSpan" id="kobo.444.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">RecipesService</span></strong><span class="koboSpan" id="kobo.446.1"> that takes the filter value as input and simply emits it using the next method over the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">filterRecipesSubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.448.1"> subject:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.449.1">
  updateFilter(criteria:Recipe) {
    this.filterRecipeSubject.next(criteria);
  }</span></pre> <p><span class="koboSpan" id="kobo.450.1">Then, we will call this method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">RecipesFilterComponent</span></strong><span class="koboSpan" id="kobo.452.1"> when the user clicks on the </span><strong class="bold"><span class="koboSpan" id="kobo.453.1">See results</span></strong><span class="koboSpan" id="kobo.454.1"> button to update the </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">filter value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.456.1">
filterResults() {
  this.service.updateFilter(&lt;Recipe&gt;this.recipeForm.value);
}</span></pre> <p><span class="koboSpan" id="kobo.457.1">We passed the value of the “Filters” form created in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">RecipesFilterComponent</span></strong><span class="koboSpan" id="kobo.459.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">updateFilter</span></strong><span class="koboSpan" id="kobo.461.1"> method. </span><span class="koboSpan" id="kobo.461.2">That’s it; now, on every emission of </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.462.1">criteria, it will re-execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">combineLatest</span></strong><span class="koboSpan" id="kobo.464.1"> operator and will consequently filter </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">the values.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">To summarize, this is what the complete code looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">RecipesListComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
@Component({
  selector: 'app-recipes-list',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './recipes-list.component.html',
  styleUrls: ['./recipes-list.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class RecipesListComponent {
  /*The data stream */
  recipes$ = this.service.recipes$;
  filteredRecipes$ = combineLatest([this.recipes$,
  this.filterRecipesAction$]).pipe(
    map(([recipes, filter]: [Recipe[], Recipe]) =&gt; {
    const filterTitle = filter?.title?.toLowerCase() ?? </span><span class="koboSpan" id="kobo.470.2">'';
      return recipes.filter(recipe =&gt;
      recipe.title?.toLowerCase().includes(filterTitle)
    })
  );
  constructor(private service: RecipesService) {
  }
}</span></pre> <p><span class="koboSpan" id="kobo.471.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">RecipesFilterComponent</span></strong><span class="koboSpan" id="kobo.473.1"> component looks </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">like</span></span><span class="No-Break"><a id="_idIndexMarker217"/></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1"> this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.476.1">
@Component({
  selector: 'app-recipes-filter',
  standalone: true,
  imports: [ButtonModule, ReactiveFormsModule],
  templateUrl: './recipes-filter.component.html',
  styleUrl: './recipes-filter.component.css'
})
export class RecipesFilterComponent {
  recipeForm = this.fb.group&lt;Recipe&gt;({
    title: '',
    category: '',
    ingredients: '',
    tags: '',
    prepTime: undefined,
    cookingTime: undefined,
  });
constructor(private service: RecipesService, private fb:
  FormBuilder) { }
filterResults() {
this.service.updateFilter(&lt;Recipe&gt;this.recipeForm.value);
}
clearFilters() {
this.recipeForm.reset();
}</span></pre> <p><span class="koboSpan" id="kobo.477.1">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">RecipesService</span></strong><span class="koboSpan" id="kobo.479.1"> looks </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">like</span></span><span class="No-Break"><a id="_idIndexMarker218"/></span><span class="No-Break"><span class="koboSpan" id="kobo.481.1"> this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.482.1">
export class RecipesService {
  recipes$ = this.http.get&lt;Recipe[]&gt;(
  `${BASE_PATH}/recipes`);
  private filterRecipeSubject = new
  BehaviorSubject&lt;Recipe&gt;({ title: '' });
  filterRecipesAction$ =
  this.filterRecipeSubject.asObservable();
  constructor(private http: HttpClient) { }
  updateFilter(criteria:Recipe) {
    this.filterRecipeSubject.next(criteria);
  }
}</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.483.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.484.1">The complete code is available in the </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">Now, let’s answer the </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.487.1">question, Why did we choose </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.489.1"> instead </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">Subject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">?</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">Between loading the page and clicking on </span><strong class="bold"><span class="koboSpan" id="kobo.494.1">See results</span></strong><span class="koboSpan" id="kobo.495.1">, we need </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">filteredRecipes$</span></strong><span class="koboSpan" id="kobo.497.1"> to hold all the recipes, as explained in the </span><em class="italic"><span class="koboSpan" id="kobo.498.1">Combine streams</span></em><span class="koboSpan" id="kobo.499.1"> section. </span><span class="koboSpan" id="kobo.499.2">If we use a plain </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">Subject</span></strong><span class="koboSpan" id="kobo.501.1">, the criteria will only get emitted when we click on the button. </span><span class="koboSpan" id="kobo.501.2">That means that when loading the page, only </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">recipes$</span></strong><span class="koboSpan" id="kobo.503.1"> is emitted, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">combineLatest</span></strong><span class="koboSpan" id="kobo.505.1"> will wait for all the streams to emit one value before emitting more. </span><span class="koboSpan" id="kobo.505.2">In our UI, we would then get an </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">empty list.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">However, when we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.509.1">, it will emit the default value for all the subscribers immediately, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">combineLatest</span></strong><span class="koboSpan" id="kobo.511.1"> will emit a first value, and everything will work fine and that’s it. </span><span class="koboSpan" id="kobo.511.2">Seems like </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">magic, right?</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">Here’s an example of the filtered recipes when searching for </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">Lemon</span></strong><span class="koboSpan" id="kobo.515.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">the keyword:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.517.1"><img alt="Figure 5.3 – Filtered recipes" src="image/B21180_05_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.518.1">Figure 5.3 – Filtered recipes</span></p>
<p><span class="koboSpan" id="kobo.519.1">To sum up, </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.520.1">in order to resolve the use case we’ve looked at in this chapter, we started with defining the data stream responsible for getting the data; then, we created the action stream. </span><span class="koboSpan" id="kobo.520.2">Afterwards, we combined the streams, did some manipulation on the combined stream, binded it in our template, and, finally, updated the filter value in the </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">filter event.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">Now, let’s highlight some of the common pitfalls when </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">combineLatest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">.</span></span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.526.1">Highlighting common pitfalls and best practices</span></h1>
<p><span class="koboSpan" id="kobo.527.1">Here are some common pitfalls or scenarios to avoid when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">combineLatest</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.529.1">in RxJS:</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.530.1">Unnecessary subscriptions</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">combineLatest</span></strong><span class="koboSpan" id="kobo.532.1"> subscribes</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.533.1"> to all provided Observables automatically. </span><span class="koboSpan" id="kobo.533.2">Make sure you unsubscribe from the returned subscription when you no longer need the combined values, especially for long-running or infinite Observables. </span><span class="koboSpan" id="kobo.533.3">This prevents memory leaks and </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">unnecessary processing.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.535.1">Missing or incomplete values</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">combineLatest</span></strong><span class="koboSpan" id="kobo.537.1"> only emits a value when all its source Observables have emitted at least one value. </span><span class="koboSpan" id="kobo.537.2">If any Observable completes or throws an error before all have emitted, </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">combineLatest</span></strong><span class="koboSpan" id="kobo.539.1"> will also complete or error out, respectively. </span><span class="koboSpan" id="kobo.539.2">Consider using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">withLatestFrom</span></strong><span class="koboSpan" id="kobo.541.1"> operator if you only need the latest value from one Observable combined with the entire emission history </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">from another.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.543.1">Performance overhead</span></h2>
<p><span class="koboSpan" id="kobo.544.1">Combining a large number of Observables with </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">combineLatest</span></strong><span class="koboSpan" id="kobo.546.1"> can introduce performance overhead. </span><span class="koboSpan" id="kobo.546.2">Evaluate the need for combining so many streams and consider using simpler operators, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">forkJoin</span></strong><span class="koboSpan" id="kobo.548.1">, if you only need all emissions as a single array once all the Observables complete. </span><span class="koboSpan" id="kobo.548.2">We will delve into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">forkJoin</span></strong><span class="koboSpan" id="kobo.550.1"> operator in </span><a href="B21180_11.xhtml#_idTextAnchor170"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.551.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.552.1">, </span><em class="italic"><span class="koboSpan" id="kobo.553.1">Performing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.554.1">Bulk Operations</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.556.1">Confusing error handling</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">combineLatest</span></strong><span class="koboSpan" id="kobo.558.1"> propagates errors from any of its source Observables. </span><span class="koboSpan" id="kobo.558.2">If error handling is complex, consider using custom operators to handle errors for each Observable individually before combining them. </span><span class="koboSpan" id="kobo.558.3">Implement proper error handling by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">catchError</span></strong><span class="koboSpan" id="kobo.560.1"> operator on individual Observables or using a custom operator that combines the emissions and errors from </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">each source.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">As you can see, </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">combineLatest</span></strong><span class="koboSpan" id="kobo.564.1"> is a powerful operator for combining multiple Observables, but it’s important to understand its behavior and potential pitfalls in order to use it effectively </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.565.1">in your RxJS applications. </span><span class="koboSpan" id="kobo.565.2">Choose the right operator based on your specific use case and prioritize clear and </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">maintainable code.</span></span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.567.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.568.1">In this chapter, we embarked on a journey through filtering data, beginning with an exploration of the imperative pattern. </span><span class="koboSpan" id="kobo.568.2">We then transitioned to one of the most commonly used RxJS patterns for data filtering, which can be used in many use cases where data updates are triggered by actions. </span><span class="koboSpan" id="kobo.568.3">By delving deeper, we outlined the different steps needed to implement the reactive pattern, from creating the streams to their combination, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">combineLatest</span></strong><span class="koboSpan" id="kobo.570.1"> operator. </span><span class="koboSpan" id="kobo.570.2">We learned how this operator works and how we can use it in a practical implementation. </span><span class="koboSpan" id="kobo.570.3">We used the combined stream in our template and handled data updates reactively. </span><span class="koboSpan" id="kobo.570.4">Finally, we explored some of the common pitfalls to avoid when </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">combineLatest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">Combining streams is a fundamental concept in RxJS that enables you to build more complex and powerful asynchronous data processing. </span><span class="koboSpan" id="kobo.574.2">It allows you to join data from various sources and apply operators and transformations to create new streams that meet your specific </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">application requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.576.1">Now that we know about this useful pattern, let’s move on to the next reactive pattern, </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">transforming streams.</span></span></p>
</div>
</body></html>