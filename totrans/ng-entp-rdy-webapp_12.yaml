- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipes – Master/Detail, Data Tables, and NgRx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we complete the router-first architecture implementation on
    LemonMart by implementing the top two most used features in business applications:
    master/detail views and data tables. I demonstrate data tables with server-side
    pagination, highlighting the integration between the frontend and backend using
    LemonMart and LemonMart Server.'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to have your **lemon-mart-server** up and running as you implement
    the recipes outlined in this chapter. Refer to *Chapter 10*, *RESTful APIs and
    Full-Stack Implementation*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: We leverage the concept of router orchestration to orchestrate how our components
    load data or render. We use resolve guards to reduce boilerplate code when loading
    data before navigating to a component. We use auxiliary routes to lay out components
    through the router configuration. We reuse the same component in multiple contexts.
  prefs: []
  type: TYPE_NORMAL
- en: We then dive into NgRx using the LocalCast Weather app and explore NgRx Data
    with LemonMart, so you can become familiar with more advanced application architecture
    concepts in Angular. By the end of this chapter, we will have touched upon most
    of the major functionality that Angular and Angular Material have to offer.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers a lot of ground. It is organized in a recipe format, so
    you can quickly refer to a particular implementation when you are working on your
    projects. I cover the architecture, design, and major components of the implementation.
    I highlight important pieces of code to explain how the solution comes together.
    Leveraging what you've learned so far, I expect the reader to fill in routine
    implementation and configuration details. However, you can always refer to the GitHub
    repo if you get stuck.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading data with resolve guards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusable components with route data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master/detail views using auxiliary routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data tables with pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NgRx Store and Effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NgRx Data Library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked in the following list. The repository contains the final
    and completed state of the code. You can verify your progress at the end of this
    chapter by looking for the end-of-chapter snapshot of code under the `projects`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get set up for this chapter''s examples based on **lemon-mart**, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repo at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install` on the root folder to install dependencies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code sample for this chapter is under the following subfolder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the Angular app for this chapter, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run Angular unit tests for this chapter, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run Angular e2e tests for this chapter, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To build a production-ready Angular app for this chapter, execute the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `dist/ch12` folder at the root of the repository will contain
    the compiled result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare for this chapter''s examples based on **local-weather-app**, implement
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repo at [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install` on the root folder to install dependencies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code sample for this chapter is under the following subfolder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the Angular app for this chapter, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run Angular unit tests for this chapter, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run Angular e2e tests for this chapter, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To build a production-ready Angular app for this chapter, execute the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that the `dist/ch12` folder at the root of the repository will contain
    the compiled result.
  prefs: []
  type: TYPE_NORMAL
- en: Beware that the source code in the book or on GitHub may not always match the
    code generated by Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time. Also on GitHub, expect
    to find corrections, fixes to support newer versions of libraries, or side-by-side
    implementations of multiple techniques for the reader to observe. The reader is
    only expected to implement the ideal solution recommended in the book. If you
    find errors or have questions, please create an issue or submit a pull request
    on GitHub for the benefit of all readers.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about updating Angular in the *Appendix C*, *Keeping Angular
    and Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    or at [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about resolve guards so that we can simplify
    our code and reduce the amount of boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: Editing existing users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 11*, *Recipes – Reusability, Routing, and Caching*, we created a
    `ViewUserComponent` with an `editUser` function. We need this functionality later
    in the chapter when implementing a master/detail view in the system, where a manager
    can see all users in the system and have the ability to edit them. Before we can
    enable the `editUser` functionality, we need to make sure that the `ViewUserComponent`
    component alongside the `ProfileComponent` can load any user given their ID.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by implementing a resolve guard we can use for both components.
  prefs: []
  type: TYPE_NORMAL
- en: Loading data with resolve guard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A resolve guard is a type of router guard, as mentioned in *Chapter 8*, *Designing
    Authentication and Authorization*. A resolve guard can load necessary data for
    a component by reading record IDs from `route` parameters, asynchronously load
    the data, and have it ready by the time the component activates and initializes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major advantages of a resolve guard include reusability of the loading
    logic, a reduction of boilerplate code, and the shedding of dependencies because
    the component can receive the data it needs without having to import any service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `user.resolve.ts` class under `user/user`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that similar to the `updateUser` method in `UserService`, we use `map(User.Build)`
    to hydrate the `user` object, so it is ready to be used when a component loads
    data from the `route` snapshot, as we'll see next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Provide the resolver in `user.module.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's configure the `router` and `ProfileComponent` to be able to load
    an existing user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify `user-routing.module.ts` to add a new path, `profile/:userId`, with
    a route resolver and the `canActivate AuthGuard`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember to provide `UserResolve` and `AuthGuard` in `user.module.ts`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `profile` component to load the data from the `route` if it exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We first check to see whether a user is present in the `route` snapshot. If
    so, we call `patchUser` to load this user. Otherwise, we fall back to our conditional
    cache-loading logic.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `patchUser` method also sets the `currentUserId` and `nameInitialDate$`
    observables, as well as calling the `patchUpdateData` base to update the form
    data.
  prefs: []
  type: TYPE_NORMAL
- en: You can verify that the resolver is working by navigating to the profile with
    your user ID. Using the out-of-the-box settings, this URL will look something
    like `http://localhost:5000/user/profile/5da01751da27cc462d265913`.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing components with binding and route data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's refactor the `viewUser` component so that we can reuse it in multiple
    contexts. User information is displayed in two places in the app as per the mock-ups
    that were created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first place is the **Review** step of the user profile that we implemented
    in the previous chapter. The second place is on the user management screen on
    the `/manager/users` route, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_12_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Manager user management mock-up'
  prefs: []
  type: TYPE_NORMAL
- en: To maximize code reuse, we need to ensure that our shared `ViewUser` component
    can be used in both contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the **Review** step of the multi-step input form, we simply bind the current
    user to it. In the second use case, the component will need to load its own data
    using a resolve guard, so we don''t need to implement additional logic to achieve
    our goal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `viewUser` component to inject the `ActivatedRoute` object and set `currentUser$`
    from the route in `ngOnInit()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ngOnInit` will only fire once when the component is first initialized or has
    been routed to. In this case, if any data for the route has been resolved, then
    it''ll be pushed to `this.currentUser$` with the `next()` function.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now have two independent events to update data; one for `ngOnChanges`, which
    handles updates to the `@Input` value and pushes to it to `BehaviorSubject currentUser$`
    if `this.user` has been bound to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To be able to use this component across multiple lazy loaded modules, we must
    wrap it in its own module:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new `shared-components.module.ts` under `src/app`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ensure that you import the `SharedComponentsModule` module into each feature
    module you intended to use `ViewUserComponent` in. In our case, these will be
    `UserModule` and `ManagerModule`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remove `ViewUserComponent` from the `User` module declarations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly declare and export `NameInputComponent` in `SharedComponentsModule`,
    and then clean up its other declarations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the modules necessary to support `ViewUserComponent` and `NameInputComponent`
    in `SharedComponentsModule` as well, such as `FieldErrorModule`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have the key pieces in place to begin implementation of the master/detail
    view. Let's go over this next.
  prefs: []
  type: TYPE_NORMAL
- en: Master/detail view auxiliary routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The true power of router-first architecture comes to fruition with the use of
    auxiliary routes, where we can influence the layout of components solely through
    router configuration, allowing for rich scenarios where we can remix the existing
    components into different layouts. Auxiliary routes are routes that are independent
    of each other where they can render content in named outlets that have been defined
    in the markup, such as `<router-outlet name="master">` or `<router-outlet name="detail">`.
    Furthermore, auxiliary routes can have their own parameters, browser history,
    children, and nested auxiliaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will implement a basic master/detail view using
    auxiliary routes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a simple component with two named outlets defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new `userTable` component under manager
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `manager-routing.module.ts` to define the auxiliary routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that when a user navigates to `/manager/users`, they'll see the `UserTableComponent`,
    because it is implemented with the default path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Provide `UserResolve` in `manager.module.ts` since `viewUser` depends on it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a temporary button in `userTable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `skipLocationChange` directive navigates without pushing a new record into
    history. So if the user views multiple records and hits the **Back** button, they
    will be taken back to the previous screen, instead of having to scroll through
    the records they viewed first.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Imagine that a user clicks on a **View detail** button like the one defined
    previously – then, `ViewUserComponent` will be rendered for the user with the
    given `userId`. In the next screenshot, you can see what the **View Details**
    button will look like after we implement the data table in the next section:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14094_12_02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.2: View Details button'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can have as many combinations and alternative components defined for the
    master and detail, allowing for the infinite possibilities of dynamic layouts.
    However, setting up the `routerLink` can be a frustrating experience. Depending
    on the exact condition, you have to either supply or not supply all or some outlets
    in the link. For example, for the preceding scenario, if the link was `[''/manager/users'',
    { outlets: { master: [''''], detail: [''user'', {userId: row.id}] } }]`, the route
    will silently fail to load. Expect these quirks to be ironed out in future Angular
    releases.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we've completed the implementation of the resolve guard for `ViewUserComponent`,
    you can use Chrome DevTools to see the data being loaded correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before debugging, ensure that the **lemon-mart-server** we created in *Chapter
    10*, *RESTful APIs and Full-Stack Implementation*, is running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In Chrome DevTools, set a break point right after `this.currentUser` is assigned,
    as shown:![](img/B14094_12_03.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.3: Dev Tools debugging ViewUserComponent'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will observe that `this.currentUser` is correctly set without any boilerplate
    code for loading data inside the `ngOnInit` function, showing the true benefit
    of a resolve guard. `ViewUserComponent` is the detail view; now let's implement
    the master view as a data table with pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Data table with pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created the scaffolding to lay out our master/detail view. In the master
    outlet, we will have a paginated data table of users, so let's implement `UserTableComponent`,
    which will contain a `MatTableDataSource` property named `dataSource`. We will
    need to be able to fetch user data in bulk using standard pagination controls
    such as `pageSize` and `pagesToSkip` and be able to further narrow down the selection
    with user-provided `searchText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the necessary functionality to the `UserService`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a new `IUsers` interface to describe the data structure of the paginated
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the interface for `UserService` with a `getUsers` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `getUsers` to `UserService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the sort direction is represented by the keywords `asc` for ascending
    and `desc` for descending. When we want to sort a column in ascending order, we
    pass the column name as a parameter to the server. To sort a column in descending
    order, we prepend the column name with a minus sign.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set up `UserTable` with pagination, sorting, and filtering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define and initialize various properties to support loading paginated data.
    `items$` stores the user records, `displayedColumns` defines the columns of data
    we intend to display, `paginator` and `sort` provide pagination and sorting preferences,
    and `search` provides the text we need to filter our results by.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `ManagerMaterialModule` containing the following Material modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure that `manager.module.ts` correctly imports the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new `ManageMaterialModule`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The baseline `AppMaterialModule`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following required modules: `FormsModule`, `ReactiveFormsModule`, and `FlexLayoutModule`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implement the CSS for `userTable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, implement the `userTable` template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With just the master view in place, the table is as shown in the following
    screenshot (make sure you''ve updated to the latest version of Angular!):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14094_12_04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.4: User table'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you click on the **View** icon, `ViewUserComponent` will get rendered in
    the detail outlet, as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14094_12_05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.5: Master/detail view'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented the **Edit** button, passing the `userId`
    to the `UserProfile` so that the data can be edited and updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Edit** button to be taken to the `ProfileComponent`, edit the
    user record, and verify that you can update another user's record
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that you can view the updated user record in the data table
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This demonstration of data tables with pagination completes the major functionality
    of LemonMart for the purpose of this book. Now, before we move on, let's make
    sure that all of our tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: Updating unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go over some unit tests for `ProfileComponent` and `UserTableComponent`
    to see how we can leverage different techniques to test the components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the unit test file for `ProfileComponent` and identify the use of the
    `authServiceMock` object to provide initial data for the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that instead of using the `createComponentMock` function from `angular-unit-test-helper`
    to import `NameInputComponent` or `ViewUserComponent`, I import their actual implementations.
    This is because `createComponentMock` is not yet sophisticated enough to deal
    with binding data to child components. In the *Further reading* section, I've
    included a blog post by Aiko Klostermann that covers testing Angular components
    with `@Input()` properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the spec file for `UserTableComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After fixing up its providers and imports, you will notice that `UserTableComponent`
    is throwing an `ExpressionChangedAfterItHasBeenCheckedError` error. This is because the
    component initialization logic requires `dataSource` to be defined. If undefined,
    the component can''t be created. However, we can easily modify component properties
    in the second `beforeEach` method, which executes after `TestBed` has injected
    real, mocked, or fake dependencies into the component class. See the highlighted
    changes in the following snippet for the test data setup:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By now, you may have noticed that just by updating some of our central configuration
    files, such as `commonTestingProviders` and `commonTestingModules`, some tests
    are passing, and the rest of the tests can be resolved by applying the various
    patterns we have been using throughout the book. For example, `user-management.component.spec.ts`
    uses the common testing modules and providers we have created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you are mocking providers, keep in mind what module, component, service,
    or class is under test and take care only to mock dependencies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ViewUserComponent` is a special case where we can''t use our common testing
    modules and providers, otherwise, we would end up creating a circular dependency.
    In this case, manually specify the modules that need to be imported.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fix the unit test configurations so all of them are passing and no warnings
    are generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the heavy lifting of the implementation completed, we can now explore alternative
    architectures, tools, and libraries to better understand the best ways to architect
    Angular apps for various needs. Next, let's explore NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: NgRx Store and Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As covered in *Chapter 1*, *Introduction to Angular and Its Concepts*, the NgRx
    library brings reactive state management to Angular based on RxJS. State management
    with NgRx allows developers to write atomic, self-contained, and composable pieces
    of code, creating actions, reducers, and selectors. This kind of reactive programming
    allows side effects in state changes to be isolated. In essence, NgRx is an abstraction
    layer over RxJS to fit the Flux pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four major elements of NgRx:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Store**: The central location where state information is persisted. You implement
    a reducer to store a state transition in the store and a selector to read data
    out of the store. These are atomic and composable pieces of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view (or user interface) displays data from the store by using a selector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Action**: Unique events that happen throughout your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions are triggered from a view with the purpose of dispatching them to the
    store.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Dispatcher**: This is a method to send actions to the store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducers on the store listen for dispatched actions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Effect**: This is a combination of an action and a dispatcher. Effects are
    usually used for actions that are not triggered from a view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s revisit the following Flux pattern diagram, which now highlights an
    **Effect**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_12_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: Flux pattern diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Let's demonstrate how NgRx works by going over a concrete example. In order
    to keep it simple, we will be leveraging the LocalCast Weather app.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing NgRx for LocalCast Weather
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be implementing NgRx to execute the search functionality in the LocalCast
    Weather app. Consider the following architecture diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_12_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: LocalCast Weather architecture'
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve our implementation, we will use both the NgRx store and
    effects libraries. NgRx store actions are reflected in the diagram in light gray
    with a `WeatherLoaded` reducer and the app state. At the top, actions are represented
    as a stream of various data objects either dispatching actions or acting on dispatched
    actions, enabling us to implement the Flux pattern. The NgRx effects library extends
    the Flux pattern by isolating side effects in its own model without littering
    the store with temporary data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The effects workflow, represented in dark gray, begins with **Step 1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CitySearchComponent` dispatches the `search` action'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `search` action appears on the observable `@ngrx/action` stream (or data stream)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CurrentWeatherEffects` acts on the `search` action to perform a search'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WeatherService` performs the search to retrieve current weather information from
    the **OpenWeather API**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Store actions, represented in light gray, begin with **Step A**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CurrentWeatherEffects` dispatches the `weatherLoaded` action'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `weatherLoaded` action appears on the data stream
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `weatherLoaded` reducer acts on the `weatherLoaded` action
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `weatherLoaded` reducer transforms the weather information to be stored
    as a new state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new state is a persisted `search` state, part of the `appStore` state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that there's a parent-level `appStore` state, which contains a child `search`
    state. I intentionally retained this setup to demonstrate how the parent-level
    state scales as you add different kinds of data elements to the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a view reads from the store, beginning with **step a**:'
  prefs: []
  type: TYPE_NORMAL
- en: The `CurrentWeather` component subscribes to the `selectCurrentWeather` selector
    using the `async` pipe
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `selectCurrentWeather` selector listens for changes to the `store.search.current`
    property in the `appStore` state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `appStore` state retrieves the persisted data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using NgRx, when a user searches for a city, the actions to retrieve, persist,
    and display that information on the `CurrentWeatherComponent` happens automatically
    via individual composable and immutable elements.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing BehaviorSubject and NgRx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be implementing NgRx side by side with `BehaviorSubjects`, so you can
    see the differences in the implementation of the same feature. To do this, we
    will need a slide toggle to switch between the two strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: This section uses the **local-weather-app** repo. You can find the code samples
    for this chapter under the `projects/ch12` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Start by implementing a `<mat-slide-toggle>` element on `CitySearchComponent`,
    as shown in the following screenshot:![](img/B14094_12_08.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.8: LocalCast Weather slide toggle'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that the field is backed by a property on your component named `useNgRx`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Refactor the `doSearch` method to extract the `BehaviorSubject` code as its
    own function named `behaviorSubjectBasedSearch`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stub out a function called `ngRxBasedSearch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will be dispatching an action from the `ngRxBasedSearch` function that you
    just created.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up NgRx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may add the NgRx Store package with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a reducers folder with an `index.ts` file in it. Now add the
    NgRx effects package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We use the `--minimal` option here to avoid creating unnecessary boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, install the NgRx schematics library so you can take advantage of generators
    to create the boilerplate code for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Implementing NgRx can be confusing due to its highly decoupled nature, which
    may necessitate some insight into the inner workings of the library.
  prefs: []
  type: TYPE_NORMAL
- en: The sample project under `projects/ch12` configures `@ngrx/store-devtools` for
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to be able to `console.log` NgRx actions for debugging or
    instrumentation during runtime, refer to the *Appendix A*, *Debugging Angular*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining NgRx actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can implement effects or reducers, we first need to define the actions
    our app is going to be able to execute. For LocalCast Weather, there are two types
    of actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`search`: Fetches the current weather for the city or zip code that''s being
    searched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weatherLoaded`: Indicates that new current weather information has been fetched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create an action named `search` by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Take the default options when prompted.
  prefs: []
  type: TYPE_NORMAL
- en: The `--group` option groups actions under a folder named `action`. The `--creators`
    option uses creator functions to implement actions and reducers, which is a more
    familiar and straightforward way to implement these components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the two actions using the `createAction` function, providing
    a name and an expected list of input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The search action has the name `'[Search] Search'` and has `searchText` and
    an optional `country` parameter as inputs. The `weatherLoaded` action follows
    a similar pattern. At the end of the file, we create a union type of our actions,
    so we can group them under one parent type to use in the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that action names are prepended by `[Search]`. This is a convention that
    helps developers visually group related actions together during debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our actions are deﬁned, we can implement the effect to handle the search
    action and dispatch a `weatherLoaded` action.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing NgRx Effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, effects let us change the stored state without necessarily
    storing the event data that is causing the change. For example, we want our state
    to only have weather data, not the search text itself. Effects allow us to do
    this in one step, rather than forcing us to use an intermediate store for the
    `searchText` and a far more complicated chain of events to just turn that into
    weather data.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we would have to implement a reducer in between, to first store this
    value in the store, and then later retrieve it from a service and dispatch a `weatherLoaded`
    action. The effect will make it simpler to retrieve data from our service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add `CurrentWeatherEffects` to our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Take the default options when prompted.
  prefs: []
  type: TYPE_NORMAL
- en: You will have a new `current-weather.effects.ts` file under the `effects` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, `--group` is used to group effects under a folder of the same name.
    `--root` registers the effect in `app.module.ts` and we use creator functions
    with the `--creators` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CurrentWeatherEffects` ﬁle, start by implementing a private `doSearch`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that we're choosing to ignore errors thrown with the `EMPTY` function.
    You can surface these errors to the user with a `UiService` like the one you've
    implemented for LemonMart.
  prefs: []
  type: TYPE_NORMAL
- en: This function takes an action with search parameters, calls `getCurrentWeather`,
    and upon receiving a response, dispatches the `weatherLoaded` action, passing
    in the current weather property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create the effect itself, so we can trigger the `doSearch` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is where we tap into the observable action stream, `this.actions$`, and
    listen to actions of the `SearchAction.search` type. We then use the `exhaustMap`
    operator to register for the emitted event. Due to its unique nature, `exhaustMap`
    won't allow another search action to be processed until the `doSearch` function
    completes dispatching its `weatherLoaded` action.
  prefs: []
  type: TYPE_NORMAL
- en: Confused by all the different kinds of RxJS operators and worried you'll never
    remember them? See the *Appendix B*, *Angular Cheat Sheet*, for a quick reference.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing reducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `weatherLoaded` action triggered, we need a way to ingest the current
    weather information and store it in our `appStore` state. Reducers will help us
    handle specific actions, creating an isolated and immutable pipeline to store
    our data in a predictable way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a search reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Take the default options. Here, we use `--group` to keep files organized under
    the `reducers` folder and `--creators` to leverage the creator style of creating
    NgRx components. We also specify the location of our parent `appStore` state at
    `reducers/index.ts` with `--reducers`, so our new reducer can be registered with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: You may observe that `reducers.index.ts` has been updated to register the new
    `search.reducer.ts`. Let's implement it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `search` state, we will be storing the current weather, so implement
    the interface to reﬂect this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s specify the `initialState`. This is similar to how we need to define
    a default value of a `BehaviorSubject`. Refactor the `WeatherService` to export
    a `const defaultWeather: ICurrentWeather` object that you can use to initialize
    `BehaviorSubject` and `initialState`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement `searchReducer` to handle the `weatherLoaded` action using
    the `on` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We simply register for the `weatherLoaded` action and unwrap the data stored
    in it and pass it into the `search` state.
  prefs: []
  type: TYPE_NORMAL
- en: This is, of course, a very simplistic case. However, it is easy to imagine a
    more complicated scenario, where we may need to flatten or process a piece of
    data received and store it in an easy-to-consume manner. Isolating such logic
    in an immutable way is the key value proposition of utilizing a library like NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: Registering with Store using selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need `CurrentWeatherComponent` to register with the `appStore` state for
    updated current weather data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by dependency injecting the `appStore` state and registering the selector
    to pluck current weather from the `State` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We simply listen to state change events that flow through the store. Using the
    `select` function, we can implement an inline select to get the piece of data
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can refactor this a bit and make our selector reusable by using a `createSelector`
    to create a `selectCurrentWeather` property on `reducers/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, since we want to maintain the continued operation of the `BehaviorSubject`,
    we can implement a `merge` operator in `CurrentWeatherComponent` to listen to
    both `WeatherService` updates and `appStore` state updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are able to listen to store updates, let''s implement the final
    piece of the puzzle: dispatching the search action.'
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching store actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to dispatch the search action so that our search effect can fetch current
    weather data and update the store. Earlier in this chapter, you implemented a
    stubbed function called `ngRxBasedSearch` in the `CitySearchComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement `ngRxBasedSearch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to inject the `appState` store into the component!
  prefs: []
  type: TYPE_NORMAL
- en: And that's it! Now you should be able to run your code and test to see whether
    it all works.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, NgRx brings a lot of sophisticated techniques to the table to
    create ways to make data transformations immutable, well deﬁned, and predictable.
    However, this comes with considerable implementation overhead. Use your best judgment
    to determine whether you really need the Flux pattern in your Angular app. Often,
    the frontend application code can be made much simpler by implementing RESTful
    APIs that return ﬂat data objects, with complicated data manipulations handled
    server side.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing reducers and selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can implement unit tests for the `weatherLoaded` reducer and the `selectCurrentWeather`
    selector in `search.reducer.spec.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: These unit tests are fairly straightforward and will ensure that no unintentional
    changes to the data structure can happen within the store.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing components with MockStore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to update the tests for `CurrentWeatherComponent` so that we can inject
    a mock `Store` into the component to test the value of the `current$` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the delta of what needs to be added to the spec file to configure
    the mock store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now update the `''should get currentWeather from weatherService''` test
    to see whether `CurrentWeatherComponent` works with a mock store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The mock store allows us to set the current state of the store, which in turn
    allows the selector call in the constructor to fire and grab the provided fake
    weather data.
  prefs: []
  type: TYPE_NORMAL
- en: TestBed is not a hard requirement for writing unit tests in Angular, a topic
    covered well at [https://angular.io/guide/testing](https://angular.io/guide/testing).
    My colleague and reviewer of this book, Brendon Caulkins, contributed a bed-less
    spec file for this chapter, named `current-weather.component.nobed.spec.ts`. He
    cites significant performance increases when running the tests, with fewer imports
    and less maintenance, but a higher level of care and expertise required to implement
    the tests. If you're on a large project, you should seriously consider skipping
    the `TestBed`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the sample code on GitHub under the `projects/ch12` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and update the remainder of your tests and do not move on until they
    all start passing.
  prefs: []
  type: TYPE_NORMAL
- en: NgRx Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If NgRx is a configuration-based framework, NgRx Data is a convention-based
    sibling of NgRx. NgRx Data automates the creation of stores, effects, actions,
    reducers, dispatches, and selectors. If most of your application actions are **CRUD**
    (**Create**, **Retrieve**, **Update**, and **Delete**) operations, then NgRx Data
    can achieve the same result as NgRx with a lot less code needing to be written.
  prefs: []
  type: TYPE_NORMAL
- en: NgRx Data may be a much better introduction to the Flux pattern for you and
    your team. Then you can go on to NgRx itself.
  prefs: []
  type: TYPE_NORMAL
- en: '`@ngrx/data` works in tandem with the `@ngrx/entity` library. Together they
    offer a rich feature set, including transactional data management. Read more about
    it at [https://ngrx.io/guide/data](https://ngrx.io/guide/data).'
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will be switching back over to the LemonMart project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add NgRx Data to your project by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The sample project under `projects/ch12` configures `@ngrx/store-devtools` for
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to be able to `console.log` NgRx actions for debugging or
    instrumentation during runtime, refer to the *Appendix A*, *Debugging Angular*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing NgRx/Data in LemonMart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In LemonMart, we have a great use case for the `@ngrx/data` library with the
    `User` class and the `UserService`. It neatly represents an entity that could
    support CRUD operations. With a few modifications and the least amount of effort,
    you can see the library in action.
  prefs: []
  type: TYPE_NORMAL
- en: This section uses the **lemon-mart** repo. You can find the code samples for
    this chapter under the `projects/ch12` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining the `User` entity in `entity-metadata.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure that the `entityConfig` object is registered with `EntityDataModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `User` entity service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You now have all the basic elements in place to integrate the entity service
    with a component. In a sense, it is this easy to set up NgRx Data. However, we'll
    have to customize it somewhat to fit into our existing REST API structure, which
    will be covered in detail in the next section. If you were to follow the API implementation
    pattern that NgRx Data expects, then no changes would be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: NgRx Data wants to access the REST API via the `/api` path, hosted on the same
    port as your Angular app. To accomplish this during development, we need to leverage
    Angular CLI's proxy feature.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring proxy in Angular CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally, HTTP requests sent to our web server and our API server should have
    exactly the same URL. However, during development, we usually host both applications
    on two different ports of `http://localhost`. Certain libraries, including NgRx
    Data, require that HTTP calls be on the same port. This creates a challenge for
    creating a frictionless development experience. For this reason, Angular CLI ships
    with a proxy feature with which you can direct the `/api` path to a different
    endpoint on your localhost. This way, you can use one port to serve your web app
    and your API requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `proxy.conf.json` file under `src`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're working in the **lemon-mart-server** monorepo, this will be `web-app/src`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register the proxy with `angular.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the server that is started when you run `npm start` or `ng serve` can rewrite
    the URLs of any call made to the `/api` route with `http://localhost:3000`. This
    is the port that **lemon-mart-server** runs by default.
  prefs: []
  type: TYPE_NORMAL
- en: If your API is running a different port, then use the correct port number and
    child route.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's use the `UserEntityService`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Entity Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be updating the User Management master view, so we can optionally use
    `BehaviorSubject` or the `UserEntityService` we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Start by implementing a toggle switch in `user-table.component.ts`, similar
    to the way we did for LocalCast Weather and NgRx earlier in the chapter:![](img/B14094_12_09.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.9: UserTableComponent with the NgRx slide toggle'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inject the new service into `UserTableComponent` and merge its loading observable
    with the one that''s present on the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since `EntityDataModule` is registered in `app.module.ts` at the root of our
    application, we need to provide `UserService` in `app.module.ts` as well, so we
    can consume data from it in `UserEntityService`. Even though `UserEntityService`
    is provided in `UserModule`, the order of operations within NgRx Data doesn't
    lend itself to properly working with feature modules. This will probably be fixed
    at some point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can add CRUD methods to the component, as shown in the following code.
    However, we will be focused on just updating the `getUsers` function so there
    is no need to add the others:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `ngAfterViewInit`, refactor the call to `this.userService.getUsers` so that
    it is called from a method named `getUsers`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then implement a conditional call to `this.userEntityService.getAll()` and
    map out the return value so that it fits the `IUsers` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now your component can attempt to get data from either source by toggling the
    slide toggle and entering some new search text. However, our endpoint does not
    provide the data in the shape that NgRx Data expects, so we need to customize
    the entity service to overcome this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Entity Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can customize the behavior of NgRx Data in numerous places. We are interested
    in overriding the behavior of the `getAll()` function, so the data we're receiving
    is properly hydrated and the data can be extracted from the item's object.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will not attempt to restore the full pagination functionality
    using NgRx Data. To keep it simple, we focus on just getting an array of data
    into the data table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update User Entity Service to inject `UserService` and implement a `getAll`
    function that uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're iterating through the item's object and hydrating objects
    with our builder function, thus flattening and transforming `Observable<IUsers>`
    to `Observable<User[]>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After implementing this change, you should be able to see data flow into the
    user table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_12_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: User table with NgRx Data'
  prefs: []
  type: TYPE_NORMAL
- en: Note that all seven users are displayed at once, and as magnified in the preceding
    screenshot, the pagination functionality is not working. However, this implementation
    is adequate enough to demonstrate what NgRx Data brings to the table.
  prefs: []
  type: TYPE_NORMAL
- en: So, should you implement NgRx Data in your next app? It depends. Since the library
    is an abstraction layer on top of NgRx, you may find yourself lost and restricted
    if you don't have a good understanding of the internals of NgRx. However, the
    library holds a lot of promise for reducing boilerplate code regarding entity
    data management and CRUD operations. If you're doing lots of CRUD operations in
    your app, you may save time, but be careful to keep the scope of your implementation
    only to the areas that need it. Either way, you should keep an eye out for the
    evolution of this great library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed going over all major Angular app design considerations
    using router-first architecture, along with our recipes, to implement a line-of-business
    app with ease. We went over how to edit existing users, leverage a resolve guard
    to load user data, and hydrate and reuse a component in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented a master/detail view using auxiliary routes and demonstrated
    how to build data tables with pagination. We then learned about NgRx and the `@ngrx/data`
    libraries and their impact on our code base using the **local-weather-app** and
    **lemon-mart** projects.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, by using the router-first design, architecture, and implementation
    approach, we tackled our application's design with a good high-level understanding
    of what we wanted to achieve. By identifying code reuse opportunities early on,
    we were able to optimize our implementation strategy to implement reusable components
    ahead of time, without running the risk of grossly over-engineering our solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will set up a highly available infrastructure on AWS
    to host LemonMart. We will update the project with new scripts to enable no-downtime
    blue-green deployments. Finally, in the last chapter, we will update LemonMart
    with Google Analytics and go over advanced Cloud Ops concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Testing Angular Components With @Input()*, Aiko Klostermann, 2017, available
    at [https://medium.com/better-programming/testing-angular-components-with-input-3bd6c07cfaf6](https://medium.com/better-programming/testing-angular-components-with-input-3bd6c07cfaf6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is NgRx?*, 2020, available at [https://ngrx.io/docs](https://ngrx.io/docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NgRx Testing*, 2020, available at [https://ngrx.io/guide/store/testing](https://ngrx.io/guide/store/testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*@ngrx/data*, 2020, available at [https://ngrx.io/guide/data](https://ngrx.io/guide/data)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NgRx: Action Creators redesigned*, Alex Okrushko, 2019, available at [https://medium.com/angular-in-depth/ngrx-action-creators-redesigned-d396960e46da](https://medium.com/angular-in-depth/ngrx-action-creators-redesigned-d396960e46da)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Simplifying Frontend State Management with Observable Store*, Dan Wahlin,
    2019, available at [https://blog.codewithdan.com/simplifying-front-end-state-management-with-observable-store/](https://blog.codewithdan.com/simplifying-front-end-state-management-with-observable-store/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  prefs: []
  type: TYPE_NORMAL
- en: What is a resolve guard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of router orchestration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an auxiliary route?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does NgRx differ from using RxJS/Subject?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the value of NgRx data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `UserTableComponent`, why do we use `readonly isLoadingResults$: BehaviorSubject<Boolean>`
    over a simple Boolean to drive the loading spinner?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
