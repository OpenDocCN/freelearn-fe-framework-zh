- en: Chapter 8. Let's Get Social
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。让我们变得社交
- en: Since the time of the first videogame, a simple technique has been used to keep
    them interesting—**leaderboards** . Leaderboards are a simple way to keep the
    players playing your game. The players will try to perform better each time, better
    than their friends, or better than any other players in the world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自第一款视频游戏诞生以来，一种简单的技术一直被用来保持它们的趣味性——**排行榜**。排行榜是让玩家继续玩你的游戏的一种简单方法。玩家将尝试每次表现都更好，超过他们的朋友，或者比世界上其他任何玩家表现更好。
- en: Social networks add a new dimension to this simple idea by allowing the game
    to publish the player score to his/her timeline (or feed). This has many advantages,
    one of them being that it will help potential new players to learn about your
    game. If they see that one of their friends just played your game, then they may
    want to try it too!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 社交网络通过允许游戏将玩家的得分发布到他/她的时间线（或动态）为这个简单的想法增加了一个新的维度。这有很多优点，其中一个是它将帮助潜在的新玩家了解你的游戏。如果他们看到他们的一个朋友刚玩了你的游戏，那么他们可能也想试试！
- en: In this chapter, we will first show how to implement a simple server-side leaderboard
    using the same techniques we saw in the previous chapter. We will then see how
    to allow the player to log in with his/her Twitter account into the game and tweet
    the score on his/her behalf.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先将展示如何使用与前一章中看到的相同技术来实现一个简单的服务器端排行榜。然后，我们将看到如何允许玩家使用他/她的Twitter账户登入游戏并代表他/她发推文。
- en: Finally, we will see how to log in to the game using Facebook, publish events
    in the player's timeline, and create achievements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看到如何使用Facebook登入游戏，将事件发布到玩家的时间线，并创建成就。
- en: It's important to realize when you use Facebook or Twitter that you have to
    be careful to follow the rules they establish, and even stay informed about the
    change of the rules to keep your game compliant. It's been seen more than once
    that applications or games that were previously allowed to use those services
    were then banned.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Facebook或Twitter时，重要的是要意识到你必须小心遵循他们制定的规则，并且要随时了解规则的变化，以确保你的游戏合规。已经不止一次看到之前被允许使用这些服务的应用程序或游戏随后被禁止的情况。
- en: We will show you how to use these two social networks, but the base mechanisms
    are the same for almost any service around that provides the same kind of functionality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示如何使用这两个社交网络，但是几乎任何提供相同功能的服务的基本机制都是相同的。
- en: 'We will cover these subjects in the following order:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会按照以下顺序涵盖这些主题：
- en: Creating a simple self-hosted leaderboard
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的自托管排行榜
- en: Making cheating harder
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使作弊变得更困难
- en: Integrating the game with Twitter to allow the player to tweet his/her score
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将游戏与Twitter集成，以允许玩家发布他/她的得分
- en: Integrating the game with Facebook to allow the player to win achievements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将游戏与Facebook集成，以允许玩家赢得成就
- en: Creating a simple leaderboard
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的排行榜
- en: Obviously, creating a leaderboard will require some sort of database to keep
    a tab of the scores. As in the previous chapter, we will use PHP and MySQL to
    implement the server side of our game. However, unlike in [Chapter 7](ch07.html
    "Chapter 7. Making a Multiplayer Game"), *Making a Multiplayer Game*, playing
    together the solution presented here can be viable in real life. Requesting and
    saving highscores is an operation that takes very little server resources and
    isn't called that often; for each user, we will approximately query the server
    once every 10 seconds, as opposed to where we queried it many times per second
    for our MMORPG in [Chapter 7](ch07.html "Chapter 7. Making a Multiplayer Game"),
    *Making a Multiplayer Game*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，创建排行榜将需要某种类型的数据库来保存分数。与上一章一样，我们将使用PHP和MySQL来实现游戏的服务器端。但是，与[第7章](ch07.html
    "第7章。制作一个多人游戏") *制作一个多人游戏*不同，一起玩的方法在现实生活中可能是可行的。请求和保存高分是一个几乎不消耗服务器资源并且不经常调用的操作；对于每个用户，我们大约每10秒查询一次服务器，与我们在[第7章](ch07.html
    "第7章。制作一个多人游戏") *制作一个多人游戏*中每秒多次查询服务器的情况相比，这次不是那么频繁。
- en: 'First, we will need a metric to use as a score. Here, we will simply use the
    time it took for the player to finish a level, in seconds. The following diagram
    shows the user interaction workflow that we will use:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个作为得分的度量标准。在这里，我们将简单地使用玩家完成一级所需的时间，单位为秒。以下的图表展示了我们将使用的用户互动工作流程：
- en: '![Creating a simple leaderboard](img/5060OT_08_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的排行榜](img/5060OT_08_01.jpg)'
- en: As a UI, we will use two screens that we will implement in the same way we implemented
    the interface for the last chapter—simple `div` elements that we will make visible
    or invisible, as we need them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户界面，我们将使用两个屏幕，我们将以与上一章节界面相同的方式实现它们——简单的`div`元素，根据需要使它们可见或不可见。
- en: 'The first screen is simply there to announce the beginning of a level and prompt
    the user to get ready. The second one is more complex. It shows the result of
    the player, the list of the top five players, and if the player scored amongst
    them, give him/her the opportunity to save his/her name into this list. The following
    screenshot shows what this will look like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个屏幕只是用来宣布级别的开始，并提示用户准备好。第二个屏幕更复杂。它显示玩家的结果、前五名玩家的列表，并且如果玩家得分属于其中之一，给予他/她将姓名保存到此列表的机会。以下截图显示了这将是什么样子：
- en: '![Creating a simple leaderboard](img/5060OT_08_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的排行榜](img/5060OT_08_02.jpg)'
- en: We chose to use this mechanism instead of asking for the user's name at the
    beginning of the game, and then automatically save the score because this mimics
    the behavior of old arcade games.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用这种机制而不是在游戏开始时询问用户的姓名，然后自动保存分数，因为这模仿了旧式街机游戏的行为。
- en: 'This means there are two server-side actions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着有两个服务器端的动作：
- en: Retrieving the top five list of scores for a level.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索一个级别的前五名得分列表。
- en: Saving a score for a given level.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为给定级别保存分数。
- en: We will implement those two actions with two files, namely, `highscore.php`
    and `save.php`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用两个文件来实现这两个动作，分别是`highscore.php`和`save.php`。
- en: Saving highscores
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存高分
- en: 'The database table we will use holds three columns:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的数据库表格有三列：
- en: '`Level`: This is an integer that holds the index of the level'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Level`: 这是一个保存级别索引的整数。'
- en: '`Name`: This is a string that holds the username'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`: 这是一个保存用户名的字符串。'
- en: '`Time`: This is an integer that represents the number of seconds it took the
    user to finish the level'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Time`: 这是一个表示用户完成级别所用秒数的整数。'
- en: 'The script that saves the highscore is very simple—we will transmit the name,
    score, and level to the server. We will then save them to the database with the
    following SQL query:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 保存最高分的脚本非常简单——我们将传输姓名、分数和级别到服务器。然后我们将它们用以下 SQL 查询保存到数据库中：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The rest of the script is very similar to what we saw in the previous chapter,
    so we won't reproduce it here, but you can have a look at the full source code
    if you want.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的其余部分与我们在上一章中看到的非常相似，所以我们不会在这里重复，但如果你想要，你可以查看完整的源代码。
- en: Retrieving highscores
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索高分
- en: To retrieve the highscores, you can simply provide the level to the server and
    get the scores in return, but we have chosen a slightly more complex mechanism.
    We will give the task of deciding if the current user is part of the top five
    list, and if so, at which position. This will allow you to implement anti-cheating
    measures later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索高分，你只需向服务器提供级别，然后得到分数即可，但我们选择了一个稍微复杂的机制。我们将决定当前用户是否属于前五名列表，并且如果是，则在哪个位置。这将允许你稍后实现防作弊措施。
- en: 'So, you will provide the level and user''s time to the server and it will return
    a JSON file holding all the information you need to generate the leaderboard screen.
    We chose the following format for the JSON:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你将向服务器提供级别和用户的时间，它将返回一个 JSON 文件，其中包含生成排行榜屏幕所需的所有信息。我们选择了以下格式的 JSON：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The idea here is to have a flag to indicate that the player is in the top five
    list, `intop`. If this flag is true, then another variable named `pos` is present
    too. This variable holds the index in the array, `top`, that holds the player's
    time. All the other entries in `top` are the scores of players in the leaderboard,
    sorted from the first to the fifth. If `intop` is false, the array only holds
    the other player's scores.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是有一个标志来指示玩家是否在前五名列表中，`intop`。如果这个标志为真，那么另一个名为`pos`的变量也存在。此变量保存数组`top`中保存玩家时间的索引。`top`数组的所有其他条目都是排行榜中玩家的分数，从第一到第五排序。如果`intop`为假，则数组仅保存其他玩家的分数。
- en: 'To generate this response, we will first use a SQL query:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成这个响应，我们首先使用一个 SQL 查询：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This query starts like the other queries we used up until now, but at the end
    (highlighted in the preceding code above), it is a modifier that specifies that
    you want the result sorted by ascending times (`ORDER BY time ASC`) and that we
    only want five results (`LIMIT 5`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的开始和我们直到现在为止使用的其他查询类似，但在末尾（在上面的前面代码中突出显示）有一个修改器，指定了你希望结果按升序时间排序（`ORDER BY
    time ASC`）并且我们只需要五个结果（`LIMIT 5`）。
- en: 'There is not much work to do to parse the result and generate the JSON. The
    only subtlety is the insertion of the player''s score if it is good enough. Here
    is the complete code for this page:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 解析结果并生成 JSON 不需要做太多工作。唯一需要注意的细节是如果玩家的分数达到了要求，则需要插入玩家的分数。以下是此页面的完整代码：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The highlighted parts of this code are the ones that take care of the player's
    score.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的突出部分处理了玩家的得分。
- en: Displaying the highscores
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示高分榜
- en: 'On the client side, we will generate the screen with the result and an input
    field to allow the player to submit its name to the leaderboard, if he/she so
    wishes. Let''s have a look at the code that does this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们将生成带有结果的屏幕，并提供一个输入字段，允许玩家将其名称提交到排行榜中，如果他/她愿意的话。让我们看看执行此操作的代码：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code that generates the list itself is highlighted. Here, we create three
    input fields—one for the player to enter his/her name and two hidden ones to hold
    the level number and the player score. They are followed by a link that will be
    used to submit the score. The code that handles the link is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 生成列表本身的代码被突出显示了。在这里，我们创建了三个输入字段——一个用于玩家输入他/她的姓名，另外两个隐藏字段用于保存关卡号和玩家分数。它们后面跟着一个链接，用于提交分数。处理此链接的代码如下：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we simply retrieve the values of the input fields and then submit them
    to the server. As a small feedback to the player, we remove the submit button
    once it's done.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地检索输入字段的值，然后将它们提交到服务器。作为对玩家的小反馈，一旦完成，我们就删除提交按钮。
- en: Making cheating harder
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加大作弊难度
- en: There is no silver bullet to avoid a cheater in general. This is particularly
    true with games written in JavaScript, since their source code is so easy to access.
    Of course, you can obfuscate your code, but that will only slow down someone really
    motivated to figure out your code. There are, however, a few other techniques
    that you can use to make it more difficult or less efficient to cheat in your
    game.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 避免作弊并没有通用的灵丹妙药。对于使用 JavaScript 编写的游戏来说尤其如此，因为它们的源代码非常容易访问。当然，你可以混淆你的代码，但这只会延缓真正有动力破解你的代码的人。然而，还有一些其他技术可以使在你的游戏中作弊变得更加困难或者效率更低。
- en: Server-side verification
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端验证
- en: The safest way to prevent cheating is to move things on the server side. If
    you remember, that's exactly what we did with the fight mechanism in our MMORPG
    in [Chapter 7](ch07.html "Chapter 7. Making a Multiplayer Game"), *Making a Multiplayer
    Game*. To apply the same paradigm to a platformer would effectively mean transmitting
    every keystroke to the server and letting the server decide the resulting position
    for the player.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 预防作弊最安全的方法是在服务器端进行操作。如果你还记得，在[第 7 章](ch07.html "Chapter 7. Making a Multiplayer
    Game")中，我们在我们的 MMORPG 中的战斗机制中确实是这样做的，*Making a Multiplayer Game*。将相同的范式应用于平台游戏实际上意味着将每次按键都传输到服务器，并让服务器决定玩家的最终位置。
- en: In most cases, this is not a realistic solution. But you can still use the server-side
    logic to validate the score submitted by the player. You can have a series of
    invisible checkpoints distributed in the level where you ping the server. If the
    user submits a score without having passed through each of those, then something
    fishy is going on. You can also record a series of metrics, such as how many times
    the player dies or jumps.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这不是一个现实的解决方案。但你仍然可以使用服务器端逻辑来验证玩家提交的分数。你可以在关卡中分布一系列不可见的检查点，在这些检查点上进行服务器的响应。如果用户提交了一个分数，而没有通过每一个检查点，那么肯定是有问题的。你还可以记录一系列指标，比如玩家死亡或跳跃的次数。
- en: The thing is that you must really tailor the validation for your game; there
    is no general approach. However, it is very important that your anti-cheating
    measures don't flag an honest player as a cheater, because that will generate
    a lot of frustration. It's also important for you to think about how much effort
    you want to invest in this area, since the more time you spend on this, the less
    the time you will spend on your game's other areas.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于你必须真正为你的游戏定制验证方式；没有通用的方法。然而，非常重要的一点是，你的反作弊措施不应该将一个诚实的玩家标记为作弊者，因为那会引起很多沮丧。你还需要考虑要在这个领域投入多少精力，因为你在这方面花费的时间越多，你在游戏的其他领域花费的时间就越少。
- en: For your game, we will implement something simple. We know how fast the player
    is moving, we know how far the end of the level is, so we can compute a minimum
    time it will take the player to go through the level. We will compare the player's
    score to this and validate it if it's not smaller.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的游戏，我们将实现一些简单的东西。我们知道玩家的移动速度有多快，我们知道级别结束有多远，所以我们可以计算出玩家通过级别所需的最短时间。我们将把玩家的分数与此进行比较，如果不小，则进行验证。
- en: 'To do this, we will simply add those lines in `highscore.php`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需在`highscore.php`中添加这些行：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the player score was detected as `impossible`, it will still be displayed,
    but the player won't be prompted to enter his/her name.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家分数被检测为`impossible`，它仍将被显示，但玩家不会被提示输入他/她的姓名。
- en: Making your variables less readable
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使您的变量不太易读
- en: 'One thing you can do is make it harder for someone to cheat your game simply
    by opening the browser''s inspector and changing a value somewhere, since we used
    the hidden input field to store values before sending them back to the server,
    to save the highscore. This makes sense in a strictly semantic way and makes our
    server-side implementation rest, but is very easy to hack. The following screenshot
    shows what a user would see if he/she opens the page in Chrome''s page inspector:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以做的一件事是通过在浏览器的检查器中打开并更改某个值，使作弊游戏变得更加困难，因为我们在发送回服务器之前使用隐藏的输入字段来存储值，以保存最高分。这在纯语义上是有意义的，并使我们的服务器端实现得到了休息，但非常容易被黑客入侵。以下截图显示了用户如果在Chrome的页面检查器中打开页面将会看到什么：
- en: '![Making your variables less readable](img/5060OT_08_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使您的变量不太易读](img/5060OT_08_03.jpg)'
- en: 'One simple rule of thumb is to avoid storing any important information in the
    DOM, since it''s accessible to any user, even those without much programming knowledge.
    In our case, we will simply remove those from the call to `save.php` and use the
    session to store the values instead. In `highscore.php`, we can simply add the
    following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的经验法则是避免在 DOM 中存储任何重要信息，因为它对任何用户都是可访问的，即使是那些没有太多编程知识的用户也是如此。在我们的情况下，我们将从对`save.php`的调用中删除这些信息，并改用会话来存储这些值。在`highscore.php`中，我们可以简单地添加以下代码：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `save.php` file only has to look for the level and time into the session:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`save.php`文件只需在会话中查找级别和时间：'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This simple change already makes the game harder to cheat.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的改变已经使得游戏更难以作弊。
- en: Obfuscating your code
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对代码进行混淆
- en: 'Obfuscating your code is a very simple step, but will help you quite a lot.
    Once your code is obfuscated, it will be almost unreadable in the inspector. The
    following example is a piece of code that asks for the leaderboard:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对代码进行混淆是一个非常简单的步骤，但会对您有很大帮助。一旦您的代码被混淆，它在检查器中将几乎无法阅读。以下示例是要求排行榜的一段代码：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The same code once obfuscated (through UglifyJS) looks similar to the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 UglifyJS 进行混淆后的相同代码看起来类似于以下内容：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is already way more difficult to debug and at the same time, it's smaller!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经更难调试了，同时，代码量更小！
- en: Making your network protocol less readable
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使您的网络协议不太易读
- en: 'Once the client side of the code is fixed, there is still a place where a cheater
    could access the game variable—network traffic. Let''s have a look at what a sniffing
    application can see when the player finishes the level:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端代码修复好了，仍然有一个地方作弊者可以访问游戏变量——网络流量。让我们看看当玩家完成级别时，嗅探应用程序可以看到什么：
- en: '![Making your network protocol less readable](img/5060OT_08_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![使您的网络协议不太易读](img/5060OT_08_04.jpg)'
- en: 'This is a problem since without even having to hack the client-side code, a
    player could simply forge a packet with the right information to cheat. Here are
    three simple things that you could do to make it more difficult for a cheater
    to understand your network traffic:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个问题，因为即使不需要黑客客户端代码，玩家也可以简单地伪造一个带有正确信息的数据包来作弊。以下是您可以做的三件简单事情，使作弊者更难理解您的网络流量：
- en: Give random names to the variables so that by simply looking at them, the cheater
    cannot find out what value they hold.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为变量赋予随机名称，以便作弊者仅凭看它们就无法找出它们保存的值。
- en: Encode the content of the variables. This is very useful for this situation,
    because here the user typically knows the value of his/her score. He/she will
    only have to look for the variable that holds it to find out what he/she has to
    modify.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对变量的内容进行编码。这对于此情况非常有用，因为在这里用户通常知道自己分数的值。他/她只需查找保存它的变量，就可以找出需要修改的内容。
- en: Add a lot of random variables to make it harder to know which ones are really
    being used.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加大量随机变量，以使很难知道哪些真正被使用了。
- en: Like before, this will only make it slightly harder to cheat for a determined
    player but combined with all the other techniques in the following sections, it
    will probably discourage most of them. Let's implement each one of these.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 像以前一样，这只会让决心的玩家稍微难以作弊，但与以下各节中的所有其他技术结合起来，它可能会阻止大多数人。让我们实施这些技术。
- en: Encoding values
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码数值
- en: Let's first begin by encoding the values. This can be done in lots of ways,
    some more secure than others. Here, our goal is really only to prevent the cheater
    from searching for his/her score in the list of values to identify which one holds
    it. So, we don't need any complex encoding. We will simply use a left shift (`<<`
    on the client) and then a right shift (`>>` on the server).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先开始编码数值。这可以用许多方式来完成，有些比其他更安全。在这里，我们的目标只是防止作弊者从值列表中搜索他/她的分数以确定哪个持有它。所以，我们不需要任何复杂的编码。我们将简单地使用左移（客户端上的`<<`）然后右移（服务器上的`>>`）。
- en: 'Here is the client-side code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是客户端代码：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The server counterpart is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端对应如下：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To confuse the user even more, we will transmit the value in a clear manner
    in many other variables that won't be readable on the server side.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步迷惑用户，我们将以清晰的方式传输数值到许多其他变量中，这些变量在服务器端是无法读取的。
- en: Randomly naming the variables
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机命名变量
- en: 'There is not much to explain here; just replace the name of the variable! If
    you''re really paranoid, then you can change the variables each time you call
    the server, but that''s not what we will do here. Here is the client-side code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多需要解释的内容；只需替换变量的名称！如果你真的很偏执，那么每次调用服务器时都可以更改变量，但我们不会这样做。以下是客户端代码：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The server-side code is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端代码如下：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding random variables
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加随机变量
- en: 'Now that the names of the variables don''t convey their content anymore, it''s
    very important that you create more variables, otherwise it''s very easy to just
    try each of them to find out which one contains the score. Here is an example
    of what you could do on the client side:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变量的名称不再传达它们的内容，非常重要的是你创建更多变量，否则很容易只是尝试每一个来找出哪一个包含分数。以下是您在客户端可能做的示例：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The server doesn't have to change anything, since those new variables are just
    ignored. There will be some things that you may want to do, such as duplicate
    values and use the player score on the variable that won't be used.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器不需要做任何更改，因为这些新变量只是被忽略的。你可能想做一些事情，比如重复值，并在不会被使用的变量上使用玩家分数。
- en: While doing these things, you have to be very careful to annotate the code so
    that you remember which variables are the correct ones!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在做这些事情的同时，您必须非常小心地注释代码，以便记住哪些变量是正确的！
- en: Integrating with Twitter
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Twitter 集成
- en: 'Twitter is an amazing way to share simple information with other people. You
    may want to use it in two ways:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter 是与其他人分享简单信息的绝佳方式。您可能希望以两种方式使用它：
- en: Allow the player to log in, thus providing a unique username
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许玩家登录，从而提供一个唯一的用户名
- en: Allow the player to tweet his/her high score or progression in the game
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许玩家发布他/她在游戏中的最高分或进度
- en: You will now see two possibilities to integrate your game with it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将看到两种将你的游戏与之集成的可能性。
- en: Twitter for dummies
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twitter 入门指南
- en: 'There is a very simple way to use Twitter that doesn''t even require you to
    use any kind of API. If the user is already logged in to Twitter, you can prompt
    him/her to submit a prewritten tweet, simply by opening a URL. This URL is formatted
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种非常简单的方法可以使用 Twitter，甚至不需要您使用任何类型的 API。如果用户已经登录到 Twitter，您可以提示他/她通过打开一个 URL
    提交一个预先写好的推文。这个 URL 的格式如下：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The highlighted part of this address is the status you wrote for the player.
    What we could do in our game is to provide a `tweet` `this` link next to the **Submit**
    button on the leaderboard screen:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此地址的突出部分是您为玩家编写的状态。我们在游戏中可以做的是在排行榜屏幕上的**提交**按钮旁提供一个`tweet` `this`链接：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The highlighted part is where the magic happens. You will notice that we used
    JavaScript's `escape` function to make sure the string we provided is formatted
    for a URL.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的部分就是魔法发生的地方。您会注意到我们使用了 JavaScript 的`escape`函数来确保我们提供的字符串格式化为 URL。
- en: 'This method is very easy to implement, but has some limitations:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常容易实现，但有一些限制：
- en: If the user is not already logged in, he/she will have to do so before posting
    his/her tweet.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户尚未登录，则必须先登录后才能发布推文。
- en: You cannot access the user's Twitter handle to use it for the local leaderboard.
    This means that if the player wants to tweet and save his/her time, then the name
    will have to be entered here too.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您无法访问用户的 Twitter 账号来用于本地排行榜。这意味着如果玩家想要发送推文并节省时间，那么名字也必须在这里输入。
- en: For each tweet, a new window is opened and the player will have to confirm it.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每条推文，都会打开一个新窗口，玩家必须确认。
- en: If you want to allow the user to log in and automatically publish tweets without
    having to open a new window each time, then you will have to use Twitter's API.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要允许用户登录并自动发布推文，而无需每次都打开新窗口，则必须使用 Twitter 的 API。
- en: Full access to Twitter's API
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获得完整的 Twitter API 访问权限
- en: The more complete solution to integrate with Twitter is to ask the user for
    permission to connect his/her account to the game. The basic mechanism for this
    uses **OAuth**, which is an open authentication standard supported by a lot of
    companies such as Twitter, Google, and Facebook.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Twitter 集成的更完整的解决方案是要求用户允许将其账户连接到游戏。此基本机制使用 **OAuth**，这是一种得到很多公司支持的开放认证标准，如
    Twitter、Google 和 Facebook。
- en: 'To give the player the choice to log in using Twitter or not, we will slightly
    change the startup screen:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要让玩家选择是否使用 Twitter 登录，我们将稍微更改启动屏幕：
- en: '![Full access to Twitter''s API](img/5060OT_08_05.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![获得完整的 Twitter API 访问权限](img/5060OT_08_05.jpg)'
- en: If the player clicks on **Start game**, then he/she will start to play. If he/she
    clicks on **Log in with Twitter**, then he/she will be prompted to authorize the
    game with Twitter and then return to the game's startup screen.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家点击 **开始游戏**，那么他/她将开始游戏。如果他/她点击 **用 Twitter 登录**，那么他/她将被提示授权游戏与 Twitter，并然后返回游戏的启动屏幕。
- en: Registering your game with Twitter
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Twitter 注册您的游戏
- en: 'Before doing anything else, you have to register your game with Twitter. To
    do this, you first need to log in to the Twitter developer''s site ([https://dev.twitter.com](https://dev.twitter.com)).
    Then, you can click on **My Application**:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何其他事情之前，您必须先在 Twitter 上注册您的游戏。要做到这一点，首先您需要登录 Twitter 开发者网站 ([https://dev.twitter.com](https://dev.twitter.com))。然后，您可以点击
    **我的应用程序**：
- en: '![Registering your game with Twitter](img/5060OT_08_06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![在 Twitter 注册您的游戏](img/5060OT_08_06.jpg)'
- en: 'Here, you can click on **Create a new application**, fill in all the required
    fields, and agree to the terms and conditions of **Rules of the Road**. Once this
    is done, you will be prompted with a screen that presents to you all the properties
    of your newly created application:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以点击 **创建新应用**，填写所有必填字段，并同意 **规则** 条款和条件。一旦完成，您将收到一个屏幕提示，向您展示您新创建的应用程序的所有属性：
- en: '![Registering your game with Twitter](img/5060OT_08_07.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![在 Twitter 注册您的游戏](img/5060OT_08_07.jpg)'
- en: 'Please note the two areas of circled code in this screenshot; you''ll need
    them later. There is one last thing that you will need to configure here. Go to
    the **Settings** tab and scroll down to **Application Type**. Here, by default,
    **Read only** is selected. If you want to be able to publish tweets on the user''s
    behalf, you''ll need to change this to **Read and Write**:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意此屏幕截图中的两个圈起来的代码区域；您稍后会需要它们。在这里还有一件您需要配置的事情。转到 **设置** 选项卡，滚动到 **应用程序类型**。这里，默认选择
    **只读**。如果您想要能够代表用户发布推文，则需要将其更改为 **读写**：
- en: '![Registering your game with Twitter](img/5060OT_08_08.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![在 Twitter 注册您的游戏](img/5060OT_08_08.jpg)'
- en: That's it; your game should now be configured correctly on Twitter's side.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；你的游戏现在应该在 Twitter 方面正确配置了。
- en: Server-side helper library
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端辅助库
- en: You could implement all of the interactions with Twitter's API directly in PHP,
    but this would be tedious; thankfully, there exists a lot of libraries to help
    you with this. The one for PHP is called **twitteroauth** ([http://github.com/abraham/twitteroauth](http://github.com/abraham/twitteroauth)).
    Other languages have other libraries, so don't hesitate to look at Twitter's developers'
    documentation to learn more about those.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接在 PHP 中实现与 Twitter API 的所有交互，但这将是繁琐的；幸运的是，存在许多库可以帮助您。PHP 的一个叫做 **twitteroauth**（[http://github.com/abraham/twitteroauth](http://github.com/abraham/twitteroauth)）。其他语言有其他库，所以不要犹豫，查看
    Twitter 的开发者文档以了解更多信息。
- en: The very nice thing about twitteroauth is that you can install it on almost
    every kind of hosting that supports PHP. You just need to copy the library's file
    in the same directory where you have your game's file. In our example, we copied
    them in a subdirectory called `twitter`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: twitteroauth的非常好的一点是，你几乎可以将其安装在支持PHP的几乎任何类型的托管上。你只需要将库文件复制到与游戏文件相同的目录中即可。在我们的例子中，我们将它们复制到一个名为`twitter`的子目录中。
- en: 'Now, you need to configure the library. To do this, open `config.php` from
    the `twitteroauth` folder:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要配置该库。为此，请从`twitteroauth`文件夹中打开`config.php`：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this file, at `(1)` and `(2)`, you have to write the two values that you
    noted previously in your application page on Twitter's developer website. Then,
    at `(3)`, you have to write the URL of twitteroauth's `callback.php` file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，在`(1)`和`(2)`处，你必须写下你之前在Twitter开发者网站上的应用页面中记下的两个值。然后，在`(3)`处，你必须写下twitteroauth的`callback.php`文件的URL。
- en: 'The very last step is to edit `callback.php` and to replace the following line
    with the address of your game''s index file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是编辑`callback.php`，并用你游戏的索引文件的地址替换以下行：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Authentication
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份验证
- en: 'Here is the workflow used to authenticate and authorize your game with Twitter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于使用Twitter对您的游戏进行身份验证和授权的工作流程：
- en: '![Authentication](img/5060OT_08_09.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![身份验证](img/5060OT_08_09.jpg)'
- en: 'This is not as complicated as it looks, and a big part of this workflow is
    already implemented by twitteroauth. We will now create a login page with a **Twitter**
    button. We will use a simple link that points to twitteroauth''s `redirect.php`
    file. When the player clicks on it for the first time, he/she will be redirected
    to a page on Twitter''s website that asks him/her to authorize the game:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像看起来的那么复杂，而这个工作流程的一大部分已经由twitteroauth实现了。我们现在将创建一个带有**Twitter**按钮的登录页面。我们将使用一个简单的链接，指向twitteroauth的`redirect.php`文件。当玩家第一次点击它时，他/她将被重定向到Twitter网站上的一个页面，要求他/她授权该游戏：
- en: '![Authentication](img/5060OT_08_10.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![身份验证](img/5060OT_08_10.jpg)'
- en: Then, once the player does this, he/she will be redirected back to the URL you
    specified in the `callback.php` file. If the player has already done this once,
    he/she will just be able to log in directly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦玩家这样做，他/她将被重定向回您在`callback.php`文件中指定的URL。如果玩家已经这样做过一次，他/她将能够直接登录。
- en: 'What would be useful from now on is the ability to know in our JavaScript code
    whether a player is already connected or not. To do this, let''s transform our
    game HTML file into a PHP file and add the following code at its beginning:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始有用的是，在我们的JavaScript代码中知道玩家是否已经连接或没有。为此，让我们将我们的游戏HTML文件转换为PHP文件，并在其开头添加以下代码：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code enables session tracking, includes some files of the `twitteroauth`
    library, and then checks to see if an access token is stored in the session. This
    will be the case if the player logged in with Twitter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码启用了会话跟踪，包括`twitteroauth`库的一些文件，然后检查会话中是否存储了访问令牌。如果玩家使用Twitter登录，则会出现这种情况。
- en: 'Then, the server connects to Twitter to retrieve the user object. This is all
    well and good, but the JavaScript code still has no idea about all this. What
    we need for this is to create a custom script with the values we want to transmit
    to the client''s JavaScript:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器连接到Twitter以检索用户对象。这一切都很好，但JavaScript代码仍然对所有这些一无所知。我们需要的是创建一个自定义脚本，其中包含我们想要传输给客户端JavaScript的值：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, if the player is logged in with Twitter, we will have the global variable
    `twitter` set to `true` and the global variable `twitterName` holding the player's
    screen name.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果玩家使用Twitter登录，我们将全局变量`twitter`设置为`true`，并且全局变量`twitterName`保存玩家的屏幕名称。
- en: 'One last thing that you may want to do is to give feedback to the user that
    he/she is successfully logged in with Twitter and give him/her the possibility
    to log out. To do this, we will slightly change the start screen if the player
    is already logged in:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想做的最后一件事是向用户提供他/她已成功使用Twitter登录的反馈，并为他/她提供注销的可能性。为此，如果玩家已经登录，则我们将轻微更改开始屏幕：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With these relatively small changes, you've already implemented authentication
    through Twitter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些相对较小的更改，您已经通过Twitter实现了身份验证。
- en: Publishing high scores on Twitter
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Twitter上发布高分
- en: Now that the user is connected to Twitter, you can allow him/her to tweet his/her
    time in a much more seamless manner. To do this, we will create a new server-side
    script called `twitterPost.php`. This file will use Twitter's `statuses/update`
    API.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户已连接到 Twitter，你可以让他/她以更无缝的方式发布他/她的时间。为此，我们将创建一个名为 `twitterPost.php` 的新的服务器端脚本。这个文件将使用
    Twitter 的 `statuses/update` API。
- en: 'Let''s have a look at the complete script:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看完整的脚本：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You probably recognized most of the code from what we added at the beginning
    of our game page (only the highlighted part is new). The last two lines create
    and then send to Twitter the status you want to publish. It's pretty straightforward,
    but there is more to what we can do—since the player is logged in, you know his/her
    screen name, which you can use for the leaderboard.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认出我们在游戏页面开头添加的大部分代码（只有高亮部分是新的）。最后两行代码创建并发送到 Twitter 你想要发布的状态。这很简单直接，但我们可以做的更多——因为玩家已登录，你知道他/她的用户名，你可以用来制作排行榜。
- en: 'In the client-side code, we will generate a slightly different version of the
    leaderboard as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端代码中，我们将生成一个稍微不同版本的排行榜，如下所示：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we make the input field holding the player's name hidden and fill it with
    the user's screen name. Then, we write the screen name in the leaderboard. The
    nice thing with this is that the server-side code doesn't change at all.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将包含玩家名称的输入字段隐藏起来，并填入用户的用户名。然后，在排行榜中写入用户名。这个好处是，服务器端代码完全不需要改变。
- en: That's all that we will implement with Twitter here, but I encourage you to
    take a look at the complete Twitter API and be creative!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在 Twitter 中实现的所有内容了，但我鼓励你去看一看完整的 Twitter API，并且发挥创造力！
- en: Integrating with Facebook
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Facebook 集成
- en: In many ways, integration with Facebook resembles integration with Twitter.
    Facebook offers, however, much more game orientation. In our case, we will implement
    achievements for logged-in users. We will use Facebook's PHP SDK, but other languages
    are supported too.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多方面，与 Facebook 的集成类似于与 Twitter 的集成。然而，Facebook 提供了更多的游戏定向。在我们的情况下，我们将为已登录用户实施成就。我们将使用
    Facebook 的 PHP SDK，但也支持其他语言。
- en: 'As for Twitter, we need to first register our application in Facebook. To do
    this, log in to Facebook''s developer website ([https://developers.facebook.com/](https://developers.facebook.com/))
    and click on **Apps** in the header:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 至于 Twitter，我们需要首先在 Facebook 中注册我们的应用程序。要做到这一点，登录到 Facebook 的开发者网站（[https://developers.facebook.com/](https://developers.facebook.com/)）并点击页眉中的
    **Apps**：
- en: '![Integrating with Facebook](img/5060OT_08_11.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![与 Facebook 集成](img/5060OT_08_11.jpg)'
- en: 'Then, click on **Create New Apps** and fill in the required information. You
    will then be prompted with your newly created application page. Here, you''ll
    have to note the two values shown in the following screenshot (just as we did
    for Twitter):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击 **Create New Apps** 并填写所需的信息。然后你将看到新创建的应用程序页面。在这里，你需要记下下面截图中显示的两个值（就像我们为
    Twitter 所做的那样）：
- en: '![Integrating with Facebook](img/5060OT_08_12.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![与 Facebook 集成](img/5060OT_08_12.jpg)'
- en: If you look at the red arrow in the preceding screenshot, you'll notice that
    you can choose how your app and Facebook will interact. To have full access to
    Facebook's Open Graph API that allows you, amongst other things, to publish achievements,
    you need to select **App on Facebook**.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下上述截图中的红色箭头，你会注意到你可以选择你的应用和 Facebook 将如何交互。要完全访问 Facebook 的 Open Graph
    API，其中包括发布成就在内，你需要选择 **App on Facebook**。
- en: This will allow you to have your game load into an iframe in Facebook itself.
    To do this, you will, however, need to have a valid HTTPS certificate installed
    on your domain name. But if you only want your game to load from your own server,
    then you don't need any (you'll still need to enter an address in the corresponding
    field, and you can simply prefix your non-secure address with `https` to make
    it valid).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你的游戏加载到 Facebook 的 iframe 中。不过，你需要在你的域名上安装有效的 HTTPS 证书。但是，如果你只希望你的游戏从你自己的服务器加载，那么你就不需要任何（你仍然需要在相应字段中输入一个地址，并且你可以简单地在你的不安全地址前加上
    `https` 来使其有效）。
- en: 'There is one last step that you need to take to make it possible for your Facebook
    application to give achievements—register it as a game. To do this, simply click
    on **App Details** on the left. Then, select **Games** under **App Info** | **Category**,
    as shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个最后需要做的步骤，即使你的 Facebook 应用程序能够提供成就——将它注册为游戏。要做到这点，只需在左侧点击 **App Details**。然后，在
    **App Info** | **Category** 下选择 **Games**，如下面的截图所示：
- en: '![Integrating with Facebook](img/5060OT_08_13.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![与Facebook集成](img/5060OT_08_13.jpg)'
- en: Authenticating with Facebook
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Facebook进行身份验证
- en: The basic authentication mechanism for Facebook is very similar to that of Twitter.
    There is, however, a small difference with regard to the access—in Twitter, you
    had to define that your application needed read and write access in the developer's
    website, whereas with Facebook, the granularity of what access you ask the user
    for is much finer and it's only during the login phase that you specify those.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook的基本身份验证机制与Twitter的非常相似。然而，关于访问的一个小差别在于，在Twitter中，您必须定义您的应用程序在开发者网站上需要读取和写入访问权限，而在Facebook中，您要求用户的访问权限的细粒度要高得多，只有在登录阶段才能指定这些。
- en: 'Let''s have a look at the code required for authentication. Just as for Twitter,
    we will first write the instructions that try to get the user at the beginning
    of our game file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看身份验证所需的代码。就像对于Twitter一样，我们将首先编写在游戏文件的开头尝试获取用户的指令：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The highlighted line defines that we want our game to be able to publish entries
    on the player's timeline. The values, `(1)` and `(2)`, are the values that you
    noted in the application configuration page.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的行定义了我们希望我们的游戏能够在玩家的时间轴上发布条目。值`(1)`和`(2)`是你在应用程序配置页面中记录的值。
- en: 'If `$facebookUser` is null, it means that the user is already logged in, otherwise
    we will have to display a login button. To do this, we will write a code very
    similar to the one we wrote for Twitter:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`$facebookUser`为空，这意味着用户已经登录，否则我们将不得不显示一个登录按钮。为此，我们将编写一个与我们为Twitter编写的代码非常相似的代码：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, you can see that Facebook's PHP SDK offers a convenient method to generate
    the URL for logging the user in or out.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到Facebook的PHP SDK提供了一个方便的方法来生成用户登录或注销的URL。
- en: 'Now, we will add a small piece of code to indicate to the JavaScript code whether
    the user is logged in to Facebook or not. Once again, the code here is very similar
    to the code we used for Twitter:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一小段代码来指示JavaScript代码用户是否已经登录到Facebook。再一次，这里的代码与我们用于Twitter的代码非常相似：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Creating achievements
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建成就
- en: 'We will now create an achievement for our game. To do so, you will need two
    files on your server:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为我们的游戏创建一个成就。为此，您需要在服务器上有两个文件：
- en: An HTML file with a series of `meta` tags in the header
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有一系列`meta`标签的HTML文件
- en: An image file that will represent the achievement in the player's timeline
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一幅图像文件，将在玩家的时间轴上代表成就
- en: 'The HTML file will not only serve as a configuration file for your achievement,
    but it will also be linked to the achievement publication on your player''s timeline.
    For Facebook to recognize the achievement as valid, you need to have the following
    seven `meta` tags defined in the header:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文件不仅作为成就的配置文件，还将链接到在您玩家的时间轴上发布的成就。为了使Facebook认可成就有效，您需要在头部定义以下七个`meta`标签：
- en: '`og:type` contains the value `game.achievement`. It differentiates achievements
    from other kinds of OpenGraph entities.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`og:type`包含值`game.achievement`。它区分了成就与其他类型的OpenGraph实体。'
- en: '`og:title` is a very short description of the achievement.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`og:title`是成就的非常简短的描述。'
- en: '`og:url` is the URL of the current file.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`og:url`是当前文件的网址。'
- en: '`og:description` is a longer description of the achievement.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`og:description`是成就的较长描述。'
- en: '`og:image` is the image mentioned earlier. It can be in PNG, JPEG, or GIF format
    and have a minimum size of 50 x 50 pixels. The maximum aspect ratio is 3:1.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`og:image`是前面提到的图像。它可以是PNG、JPEG或GIF格式，并且至少有50 x 50像素的大小。最大的长宽比是3:1。'
- en: '`game:points` is the number of points associated with this achievement. In
    total, your game cannot give more than 1000 points and the smallest number allowed
    is 1\. Achievements with greater point values will have a higher probability to
    be displayed on the player''s friend''s news feed.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`game:points`是与此成就相关联的积分数。总共，您的游戏不能给出超过1000点，最小允许的数字是1。具有更高点值的成就将更有可能显示在玩家的好友的新闻动态中。'
- en: '`fb:app_id` is your application''s ID.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fb:app_id`是您的应用程序的ID。'
- en: 'The body of the HTML file can be a nice page explaining what this achievement
    is all about, or anything you really want. A very simple example of a complete
    achievement page is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文件的正文可以是一个很好的页面，解释这个成就到底是什么，或者任何你真正想要的东西。一个完整的成就页面的非常简单的例子如下：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The resulting achievement will appear similar to the following screenshot on
    the player''s timeline:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的成就将会在玩家的时间轴上显示如下截图：
- en: '![Creating achievements](img/5060OT_08_14.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![创建成就](img/5060OT_08_14.jpg)'
- en: But, writing this document is not enough for your achievement to be completely
    configured. You will have to submit it to Facebook. To do this, you have to do
    a `POST` request at the correct URL with the correct parameters. This request
    should also be associated with an application token.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅仅写这份文档还不足以完全配置您的成就。您需要将其提交给Facebook。为了做到这一点，您必须在正确的URL上使用正确的参数进行`POST`请求。这个请求还应该关联一个应用程序令牌。
- en: 'Application tokens are a way in which Facebook ensures that it''s really your
    game and not some other application that is communicating with it. The easiest
    way to do this is to write a PHP page that will in turn submit your achievement(s).
    Here is the complete code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序令牌是Facebook确保通信对象真的是您的游戏而不是其他应用程序的一种方式。最简单的方法是编写一个PHP页面来提交您的成就。下面是完整代码：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code is quite verbose, but you'll recognize most of it from the previous
    ones. The important part has been highlighted—first, we retrieve the application
    token, then we associate it with the future request, and finally we use the SDK
    to do the `POST` request.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常冗长，但您将会认出其中大部分内容。重要部分已经标出——首先，我们检索应用程序令牌，然后将其与将来的请求关联，最后使用SDK进行`POST`请求。
- en: 'The address for this `POST` request is formatted as follows: "Application ID"
    / "achievements". The transmitted parameter is simply the URL of the achievement
    file.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`POST`请求的地址格式如下："应用程序ID" / "achievements"。传输的参数就是成就文件的URL。
- en: Since the error message generated here (if something goes wrong) can be quite
    obscure, you may want to first validate your achievement file by using the debugging
    tool provided by Facebook at [https://developers.facebook.com/tools/debug/](https://developers.facebook.com/tools/debug/).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此处生成的错误消息（如果出现问题）可能相当难以理解，您可能首先希望使用Facebook提供的调试工具对成就文件进行验证，网址为[https://developers.facebook.com/tools/debug/](https://developers.facebook.com/tools/debug/)。
- en: Publishing the achievements
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布成就
- en: Now that Facebook has registered the achievement, we can award it to our players.
    The command to do this is also a `POST` request and must also be associated with
    an application token. For the sake of simplicity, we will create a simple PHP
    page that will award the achievement when called. This is far from optimal in
    a real-life situation, where you want to avoid having the user simply call the
    file himself/herself. You can award the achievement in the `highscore.php` file
    instead.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Facebook已经注册了成就，我们可以将其授予我们的玩家。执行这个命令也是一个`POST`请求，必须关联一个应用程序令牌。为了简单起见，我们将创建一个简单的PHP页面，在被调用时授予成就。在现实情况下，这绝不是最佳方案，在那种情况下，您希望避免让用户自行调用这个文件。您可以在`highscore.php`文件中授予成就。
- en: 'This is the complete code of this file; it is very similar to the file we used
    to register our achievements, and the differences are highlighted:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该文件的完整代码；它与我们用来注册成就的文件非常相似，不同之处已经标出：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This time, we create a `POST` request to a URL with the format: "User ID" /
    "achievements". Now, we simply have to asynchronously call this file from our
    game when the user finishes the first level:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们创建一个`POST`请求到一个URL，格式为："用户ID" / "achievements"。现在，我们只需在用户完成第一关时从游戏中异步调用此文件：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: We've learned a lot during this chapter, even though we have only scratched
    the surface of what kind of social interactions are possible with the new tools.
    Facebook and Twitter's APIs are large and change constantly. If you want to use
    them in the best possible way, I would really recommend reading their complete
    documentation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学到了很多，尽管我们只是探索了新工具所可能具有的社交互动的表面。Facebook和Twitter的API非常庞大且不断变化。如果您希望以最佳方式使用它们，我真的建议阅读它们的完整文档。
- en: But, when using third-party services, especially the free ones, you have to
    realize that you become dependent on them. They can change anything at any time,
    without giving you much notice. They can decide that they don't want your game
    to use their service anymore. Always keep this in mind, and if possible, make
    sure that you have an exit strategy in those situations!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当使用第三方服务时，尤其是免费的那些，您必须意识到您变得依赖它们了。它们可以随时更改任何内容，而不会通知您太多。它们可以决定不再让您的游戏使用它们的服务。始终记住这一点，如果可能的话，确保您在这些情况下有一个退出策略！
- en: In the next chapter, we will explore another hot topic—making your game mobile!
    For this, we will take our platformer and expand it to work on modern smartphones
    and tablets.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一个热门话题——使你的游戏适用于移动设备！为此，我们将把我们的平台游戏扩展到可以在现代智能手机和平板电脑上运行。
