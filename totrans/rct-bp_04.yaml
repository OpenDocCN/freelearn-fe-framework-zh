- en: Chapter 4. Building a Real-Time Search App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：构建实时搜索应用程序
- en: Search is an important feature in most apps. Depending on the kind of application
    you're developing, you can get away with setting up a field for looking up simple
    keywords, or you may have to delve into a world of fuzzy algorithms and lookup
    tables. In this chapter, we'll create a real-time search app that mimics a web
    search engine. We'll work on quick searches that appear as you type, displaying
    the search results and providing the endless scrolling feature. We'll also create
    our own search API to handle our requests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索是大多数应用程序中的一个重要功能。根据您正在开发的应用程序类型，您可能只需设置一个用于查找简单关键词的字段，或者您可能需要深入研究模糊算法和查找表的世界。在本章中，我们将创建一个实时搜索应用程序，该应用程序模仿了网络搜索引擎。我们将处理您输入时出现的快速搜索，显示搜索结果并提供无限滚动功能。我们还将创建自己的搜索
    API 来处理我们的请求。
- en: The application of these techniques are only limited by your imagination. On
    that note, let's get started.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术的应用仅限于您的想象力。在这方面，让我们开始吧。
- en: 'These are the major topics that we''ll cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在本章中介绍的主要主题：
- en: Creating your own search API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您自己的搜索 API
- en: Connecting your API to MongoDB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的 API 连接到 MongoDB
- en: Setting up API routing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 API 路由
- en: Performing regex-based searches
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于正则表达式的搜索
- en: Securing your API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护您的 API
- en: Creating a ReactJS search app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 ReactJS 搜索应用程序
- en: Setting up react-router to handle non-hashed routes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 react-router 以处理非哈希路由
- en: Listening to event handlers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听事件处理器
- en: Creating a service layer
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务层
- en: Connecting to your API
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到您的 API
- en: Pagination
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页
- en: Endless scrolling
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限滚动
- en: Creating your own search API
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的搜索 API
- en: Data fetching is a topic fraught with uncertainty, and there really does not
    exist a recommended way of dealing with it that will make sense to everyone.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取是一个充满不确定性的话题，实际上并不存在一种让所有人都觉得合理的推荐方法来处理它。
- en: 'Two of the main strategies you can search between are as follows: either query
    a data source directly or query an API. Which one is more extensible and future
    proof? Let''s look at it from the perspective of your search controller. Querying
    the data source directly means setting up connectors and the logic involved inside
    your app. You need to construct a proper search query, and then you usually need
    to parse the results. Your data fetching logic is now strongly tied to the data
    source.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下两种主要策略之间进行搜索：直接查询数据源或查询 API。哪一个更具可扩展性和未来性？让我们从您的搜索控制器角度来探讨这个问题。直接查询数据源意味着在您的应用程序内部设置连接器和相关逻辑。您需要构建一个合适的搜索查询，然后通常需要解析结果。您的数据获取逻辑现在与数据源紧密相连。
- en: Querying an API means sending a search query and retrieving a preformatted result.
    Now, your app is only loosely tied to the API, and switching it out is often simply
    a matter of changing the API URL.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查询 API 意味着发送一个搜索查询并检索预格式化的结果。现在，您的应用程序与 API 的联系仅是松散的，更换它通常只是更改 API URL 的问题。
- en: It's usually preferable to establish loose ties rather than strong ties, so
    we'll start this chapter by creating a Node.js API before moving on to the ReactJS
    app that will display the search results to the user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，建立松散的联系比建立紧密的联系更可取，因此我们将从创建一个 Node.js API 开始，然后再转向将显示搜索结果给用户的 ReactJS 应用程序。
- en: Getting started with your API
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用您的 API
- en: 'Let''s start by creating an empty project. Create a folder to store your files,
    open a terminal, and change the directory to the folder. Run `npm init`. The installer
    will ask you a number of questions, but the defaults are all fine so go ahead
    and press *Enter* until the command is finished. You will be left with a barebones
    `package.json` file that `npm` will use to store your dependency configuration.
    Next, install `express`, `mongoose`, `cors`, `morgan`, and `body-parser` by executing
    this command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个空项目开始。创建一个文件夹来存储您的文件，打开终端，并将目录更改为该文件夹。运行 `npm init`。安装程序将向您提出许多问题，但默认值都是可以接受的，所以请继续按下
    *Enter* 键，直到命令完成。您将留下一个仅包含 `package.json` 文件的裸骨项目，`npm` 将使用它来存储您的依赖配置。接下来，通过执行以下命令安装
    `express`、`mongoose`、`cors`、`morgan` 和 `body-parser`：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Morgan** is a middleware utility designed for automatic logging of requests
    and responses.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Morgan** 是一个为自动记录请求和响应而设计的中间件工具。'
- en: '**Mongoose** is a utility for connecting to **MongoDB**, a very simple and
    popular document-oriented non-relational database. It''s a good choice for the
    kind of API we want to create because it excels at query speeds and outputs **JSON**
    data by default.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mongoose** 是一个连接到 **MongoDB** 的实用工具，MongoDB 是一个非常简单且流行的面向文档的非关系型数据库。它非常适合我们想要创建的
    API 类型，因为它在查询速度上表现出色，并且默认输出 **JSON** 数据。'
- en: 'Before you continue, make sure you have MongoDB installed on your system. You
    can do this by typing in `mongo` in your terminal. If it''s installed, it will
    display something like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您已经在系统上安装了 MongoDB。您可以在终端中输入 `mongo` 来完成此操作。如果已安装，它将显示类似以下内容：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If it displays an error or **command not found**, you need to install MongoDB
    before proceeding. There are different ways to accomplish this depending on which
    operating system is installed on your computer. If you're on a Mac, you can install
    MongoDB with *Homebrew* by issuing `brew install mongodb`. If you don't have Homebrew,
    you can go to [http://brew.sh/](http://brew.sh/) for instructions on how to install
    it. Windows users and Mac users who don't want to use Homebrew can install MongoDB
    by downloading an executable from [https://www.mongodb.org/downloads](https://www.mongodb.org/downloads).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它显示错误或 **命令未找到**，您在继续之前需要安装 MongoDB。根据您计算机上安装的操作系统，有不同方法可以完成此操作。如果您使用的是 Mac，可以通过发出
    `brew install mongodb` 命令使用 *Homebrew* 安装 MongoDB。如果您没有 Homebrew，您可以访问 [http://brew.sh/](http://brew.sh/)
    获取有关如何安装它的说明。Windows 用户以及不想使用 Homebrew 的 Mac 用户可以通过从 [https://www.mongodb.org/downloads](https://www.mongodb.org/downloads)
    下载可执行文件来安装 MongoDB。
- en: Creating the API
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 API
- en: 'Create a file called `server.js` in the `root` folder and add the following
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `root` 文件夹中创建一个名为 `server.js` 的文件，并添加以下代码：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will set up our dependencies and make them ready for use. We're opening
    our app for cross-origin requests with the use of the **cors** library. This is
    necessary when we're not running the API on the same domain and port as the app
    itself.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置我们的依赖项并使其准备好使用。我们正在使用 **cors** 库来打开我们的应用以支持跨源请求。当我们不在与应用程序相同的域名和端口上运行 API
    时，这是必要的。
- en: We'll then create a schema that describes what kind of data we'll be working
    with. A schema in Mongoose maps to a MongoDB collection and defines the shape
    of the documents within that collection.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个描述我们将要处理的数据类型的模式。在 Mongoose 中，模式映射到 MongoDB 集合，并定义了该集合中文档的形状。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this is idiomatic to Mongoose as MongoDB is schema-less by default.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是 Mongoose 的习惯用法，因为 MongoDB 默认是无模式的。
- en: 'Add this schema to `server.js`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将此模式添加到 `server.js`：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, it's a very simple schema and all the attributes share the same
    `SchemaType` object. The permitted types are `String`, `Number`, `Date`, `Buffer`,
    `Boolean`, `Mixed`, `ObjectId`, and `Array`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常简单的模式，并且所有属性都共享相同的 `SchemaType` 对象。允许的类型有 `String`、`Number`、`Date`、`Buffer`、`Boolean`、`Mixed`、`ObjectId`
    和 `Array`。
- en: 'To use our schema definition, we need to convert our `siteSchema` object into
    a model we can work with. To do so, we pass it to `mongoose.model(modelName, schema)`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的模式定义，我们需要将我们的 `siteSchema` 对象转换为我们可以工作的模型。为此，我们将它传递给 `mongoose.model(modelName,
    schema)`：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to define our routes. We''ll start by defining a simple search
    route that takes a title as a query and returns a set of matching results:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义我们的路由。我们将从一个简单的搜索路由开始，该路由接受一个标题作为查询并返回一组匹配的结果：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s finish it up by starting the server:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过启动服务器来完成它：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we tell `express` to use our defined router and prefix it with `v1`. The
    full path to the API will be `http://localhost:5000/v1/search/title`. You can
    now start the API by executing `node server.js`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 `express` 使用我们定义的路由，并使用 `v1` 作为前缀。API 的完整路径将是 `http://localhost:5000/v1/search/title`。您现在可以通过执行
    `node server.js` 来启动 API。
- en: We have added `process.env` to some of the variables. The point of this is to
    make it easy to override the values when we start the app. If we want to start
    the app on port `2999`, we will need to start the app with `PORT=2999 node server.js`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `process.env` 添加到一些变量中。这样做是为了在启动应用程序时轻松覆盖这些值。如果我们想以端口 `2999` 启动应用程序，我们需要使用
    `PORT=2999 node server.js` 来启动应用程序。
- en: Importing documents
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入文档
- en: 'Inserting documents into a MongoDB collection isn''t very complicated. You
    log in to MongoDB via the terminal, select the database, and run `db.collection.insert({})`.
    Inserting documents manually looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将文档插入到 MongoDB 集合中并不复杂。您通过终端登录 MongoDB，选择数据库，然后运行 `db.collection.insert({})`。手动插入文档看起来是这样的：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will of course take a lot of time, and making up a set of titles, links,
    and descriptions is not a particularly fruitful endeavor. It''s fortunate that
    there''s a wide range of free and open sets available for us to use. One such
    database is [dmoz.org](http://dmoz.org), and I''ve taken the liberty of downloading
    a sample selection from the database and making it available at [https://websearchapi.herokuapp.com/v1/sites.json](https://websearchapi.herokuapp.com/v1/sites.json)
    in JSON format. Download this set and import it with the `mongoimport` tool, like
    this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然会花费很多时间，而且制作一组标题、链接和描述并不是一项特别有成效的工作。幸运的是，有许多免费和开源的集合可供我们使用。其中一个数据库是[dmoz.org](http://dmoz.org)，我已经下载了数据库的一个样本选择，并以JSON格式在[https://websearchapi.herokuapp.com/v1/sites.json](https://websearchapi.herokuapp.com/v1/sites.json)上提供。下载这个集合，并使用`mongoimport`工具导入，如下所示：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When executed, it will place 598 documents in your API database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，它将在你的API数据库中放置598个文档。
- en: Querying the API
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询API
- en: A `get` query can be executed by your browser. Just type in the address and
    a title from the sample JSON file, for instance, `http://localhost:5000/v1/search/CoreChain`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`get`查询可以通过你的浏览器执行。只需输入地址和样本JSON文件中的一个标题，例如，`http://localhost:5000/v1/search/CoreChain`。
- en: You may also use the command line with tools such as **cURL** or **HTTPie**.
    The latter is designed to make command-line interactions with web services more
    human-friendly than the likes of cURL, so it's absolutely worth checking it out,
    and it's the one we'll be using in this chapter to test our API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用命令行和像**cURL**或**HTTPie**这样的工具。后者旨在使与Web服务的命令行交互比cURL等人性化，因此绝对值得检查，我们将在本章中使用它来测试我们的API。
- en: 'Here''s the output from the preceding query with HTTPie:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是先前的查询使用HTTPie的输出：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is very nice, but notice that the routing we've created demands an exact
    match for the title. Searching for `corechain` or `Corechain` will not return
    any results. Querying `Cubism.js` will return one result, but *Cubism* will return
    nothing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但请注意，我们创建的路由要求标题完全匹配。搜索`corechain`或`Corechain`将不会返回任何结果。查询`Cubism.js`将返回一个结果，但`*Cubism*`将不会返回任何结果。
- en: Clearly, this is not a very query-friendly API.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是一个非常友好的查询API。
- en: Creating a wildcard search
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建通配符搜索
- en: Introducing wildcard searches would make the API more user-friendly, but you
    cannot use traditional SQL-based approaches, such as `LIKE`, since MongoDB doesn't
    support these kinds of operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 引入通配符搜索可以使API更易于使用，但你不能使用传统的基于SQL的方法，例如`LIKE`，因为MongoDB不支持这些类型的操作。
- en: On the other hand, MongoDB comes with full support for regular expressions,
    so it's entirely possible to construct a query that mimics `LIKE`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，MongoDB完全支持正则表达式，因此可以构建一个模仿`LIKE`的查询。
- en: 'In MongoDB, you can use a regular expression object to create a regular expression:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，你可以使用正则表达式对象创建正则表达式：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also create a regular expression with any of the following syntaxes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下任何一种语法创建正则表达式：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following `<options>` are available for use with a regular expression:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`<options>`可用于与正则表达式一起使用：
- en: '`i`: This is for case insensitivity to match uppercase and lowercase characters.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`：这是为了对大小写不敏感，以匹配大写和小写字符。'
- en: '`m`: For patterns that include anchors (that is, `^` for the start and `$`
    for the end), match the anchors at the beginning or end of each line for strings
    with multiline values. Without this option, these anchors will only match at the
    beginning or end of the string.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`：对于包含锚点（即，`^`表示开始和`$`表示结束）的模式，对于多行值的字符串，在每行的开始或结束处匹配锚点。如果没有这个选项，这些锚点将只匹配字符串的开始或结束。'
- en: '`x`: This is the "extended" capability to ignore all whitespace characters
    in the `$regex` pattern unless escaped or included in a `character` class.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`：这是“扩展”功能，可以忽略`$regex`模式中的所有空白字符，除非它们被转义或包含在`character`类中。'
- en: '`s`: This allows the dot character (`.`) to match all the characters, including
    newline characters.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：这允许点字符（`.`）匹配所有字符，包括换行符。'
- en: Using `x` and `s` requires `$regex` with the `$options` syntax.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`x`和`s`需要与`$options`语法一起使用`$regex`。
- en: 'Now that we know this, let''s start by creating a wildcard query:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这些，让我们先创建一个通配符查询：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to restart your node server instance every time you make changes to
    the query logic. You can do this by breaking the instance using a keyboard shortcut,
    such as *CTRL* + *C* (Mac), and then running `node server.js` again.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 记住每次更改查询逻辑时都要重新启动您的节点服务器实例。您可以通过使用键盘快捷键（如 *CTRL* + *C*（Mac））中断实例，然后再次运行 `node
    server.js` 来完成此操作。
- en: This query returns any titles that start with the search word, and it will perform
    a case-insensitive search.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回任何以搜索词开头的标题，并且它将执行不区分大小写的搜索。
- en: 'If you remove the first anchor (`^`), it will match all occurrences of the
    word in the string:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您移除第一个锚点（`^`），它将匹配字符串中该词的所有出现：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the query that we''ll be using for quick searches. It will return hits
    for *Cubism*, *cubism*, and even *ubi*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用于快速搜索的查询。它将返回 *立体主义*、*cubism* 和甚至 *ubi* 的命中：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will do for the kind of app we're building now. There are many ways to
    construct a regular expression, and you may further refine it according to your
    needs. More advanced matching is possible by implementing *soundex*, *fuzzy matching*,
    or *Levenshtein distance*, although none of these are supported by MongoDB.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们现在正在构建的应用类型来说已经足够了。构建正则表达式有许多方法，您可以根据需要进一步细化它。通过实现 *soundex*、*模糊匹配* 或 *Levenshtein
    距离*，可以实现更高级的匹配，尽管 MongoDB 都不支持这些。
- en: '**Soundex** is a phonetic algorithm for indexing names by sound as pronounced
    in English. It is appropriate when you want to do name lookups and allow users
    to find correct results despite minor differences in spelling.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Soundex** 是一种音位算法，用于通过英语中的发音来索引名称。当您想要进行名称查找并允许用户在拼写略有差异的情况下找到正确结果时，它是非常合适的。'
- en: '**Fuzzy matching** is the technique of finding strings that match a string,
    approximately, not exactly. The closeness of a match is measured in terms of operations
    necessary to convert the string into an exact match. A well-known and often used
    algorithm is **Levenshtein**. It''s a simple algorithm that provides good results,
    but it''s not supported by MongoDB. Measuring the Levenshtein distance must thus
    be done by fetching the entire result set and then applying the algorithm for
    the search query on all the strings. The speed of the operation grows linearly
    with the number of documents in your database, so unless you have a very small
    document set, this is most likely not worth doing.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**模糊匹配** 是一种寻找与字符串近似匹配而不是精确匹配的字符串的技术。匹配的接近程度是通过将字符串转换为精确匹配所需的操作来衡量的。一个众所周知且经常使用的算法是
    **Levenshtein**。这是一个简单的算法，可以提供良好的结果，但它不受 MongoDB 支持。因此，必须通过检索整个结果集然后对搜索查询中的所有字符串应用算法来测量
    Levenshtein 距离。操作的速度会随着数据库中文档数量的线性增长而增长，所以除非您有非常小的文档集，否则这很可能不值得做。'
- en: If you want these kinds of features, you need to look somewhere else. **Elasticsearch**
    ([https://www.elastic.co/](https://www.elastic.co/)) is a good alternative that's
    worth looking into. You can easily combine a node API, like the one we just created,
    with an `Elasticsearch` instance in the backend instead of MongoDB, or a combination
    of the two.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要这些功能，您需要另寻他处。**Elasticsearch** ([https://www.elastic.co/](https://www.elastic.co/))
    是一个值得考虑的良好替代品。您可以将我们刚刚创建的节点 API 与后端的 `Elasticsearch` 实例轻松结合，而不是使用 MongoDB，或者两者的组合。
- en: Securing your API
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护您的 API
- en: Right now, your API is accessible to anyone if you put it online. This is not
    an ideal situation, although you can argue that since you only support `GET` requests,
    it's not much different than putting up a simple website.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果您将其上线，您的 API 对任何人都是可访问的。这不是一个理想的情况，尽管您可以争辩说，由于您只支持 `GET` 请求，这并不比建立一个简单的网站有太大的不同。
- en: Suppose that you add `PUT` and `DELETE` at some point. You'd definitely want
    to protect it from anyone having complete access to it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在某个时候添加了 `PUT` 和 `DELETE`。您肯定希望保护它，防止任何人完全访问。
- en: 'Let''s look at a simple way of securing it by adding a bearer token to our
    app. We''ll be using the Node.js authentication module, **Passport**, to protect
    our API. Passport has more than 300 strategies of varying applicability. We''ll
    chose the bearer token strategy, so install the following two modules:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看通过向我们的应用程序添加令牌来简单保护它的方法。我们将使用 Node.js 身份验证模块 **Passport** 来保护我们的 API。Passport
    有超过 300 种不同适用性的策略。我们将选择令牌策略，因此请安装以下两个模块：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `index.js`, add the following import statements to the head of the file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.js` 文件开头添加以下导入语句：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, add the following code just below the line with `mongoose.connect`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `mongoose.connect` 行下面添加以下代码：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You also need to change the route, so replace the search route with this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要更改路由，所以将搜索路由替换为以下内容：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you restart the app, the request will now require the user to send a bearer
    token with *1234567890* as the content. If the token is correct, the app will
    return `true` and execute the query; if not, it will return a simple message saying
    **Unauthorized**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新启动应用时，现在请求将需要用户发送一个包含内容为 *1234567890* 的 bearer token。如果令牌正确，应用将返回 `true`
    并执行查询；如果不正确，它将返回一个简单的消息说 **未授权**：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Admittedly, bearer tokens provide a very weak security layer. It's still possible
    for a potential hacker to sniff your API request and reuse your tokens, but making
    the tokens short-lived and changing them every now and then can help increase
    the security. To make it really secure, it's often used in combination with user
    authentication.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，bearer tokens 提供了一个非常薄弱的安全层。仍然有可能让潜在的攻击者嗅探你的 API 请求并重用你的令牌，但使令牌短暂有效并时不时地更改它们可以帮助提高安全性。为了使其真正安全，它通常与用户身份验证结合使用。
- en: Creating your ReactJS search app
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的 ReactJS 搜索应用
- en: 'Start this project by making a copy of the scaffolding from [Chapter 1](ch01.html
    "Chapter 1. Diving Headfirst into ReactJS"), *Diving Headfirst into ReactJS*,
    (you will find the code file for this along with the code bundle for this book
    on the Packt Publishing website), and then add `React-Bootstrap` to your project.
    Open up a terminal, go to the root of your project, and issue an `npm install`
    command for React-Bootstrap:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制 [第 1 章](ch01.html "第 1 章。ReactJS 深入浅出")，*ReactJS 深入浅出*，中的脚手架来启动这个项目，你将在
    Packt Publishing 网站上找到这个代码文件以及这本书的代码包），然后将 `React-Bootstrap` 添加到你的项目中。打开终端，转到项目根目录，并运行
    `npm install` 命令来安装 React-Bootstrap：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `dependencies` section in `package.json` should now look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 中的 `dependencies` 部分现在应该看起来像这样：'
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If `package.json` doesn''t look like this, please update it and then run `npm
    install` in a terminal from the root of your project. You also need to add the
    `Bootstrap` CSS files to the `<head>` section of your `index.html` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `package.json` 不是这个样子，请更新它，然后在项目根目录下从终端运行 `npm install`。你还需要将 `Bootstrap`
    CSS 文件添加到你的 `index.html` 文件的 `<head>` 部分中：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Put the preceding code above the line with `app.css` so that you're able to
    override the styles from Bootstrap.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码放在带有 `app.css` 的行之上，这样你就可以覆盖Bootstrap的样式。
- en: Finally, create a `components` folder inside your `source` folder, then copy
    the components `fontawesome.jsx` and `picture.jsx` from [Chapter 3](ch03.html
    "Chapter 3. Responsive Web Development with ReactJS"), *Responsive Web Development
    with ReactJS*, into this folder.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `source` 文件夹内创建一个 `components` 文件夹，然后将来自 [第 3 章](ch03.html "第 3 章。使用 ReactJS
    进行响应式网页开发")，*使用 ReactJS 进行响应式网页开发*，的组件 `fontawesome.jsx` 和 `picture.jsx` 复制到这个文件夹中。
- en: Setting up your app
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的应用
- en: 'Let''s start with our application root, `source/app.jsx`. Replace the contents
    with this code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从应用程序的根目录开始，`source/app.jsx`。将内容替换为以下代码：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You need to create these four files in your `components` folder in order for
    the app to compile. We''ll do this shortly. Now, refer to the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用能够编译，你需要在你 `components` 文件夹中创建这四个文件。我们很快就会这样做。现在，参考以下内容：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code sets up a route with the browser history library. One of
    the primary benefits of this library is that you can avoid hashtags in your URL,
    so the app can reference absolute paths such as `http://localhost:3000/search`
    and `http://localhost:3000/search/term`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用浏览器历史库设置了一个路由。这个库的主要优点之一是你可以避免在URL中使用哈希标签，因此应用可以引用绝对路径，例如 `http://localhost:3000/search`
    和 `http://localhost:3000/search/term`：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's create the skeleton files for `SearchActions`, `Search`, `Results`, and
    the complete `Layout` file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `SearchActions`、`Search`、`Results` 和完整的 `Layout` 文件创建骨架文件。
- en: 'Create `source/actions/search.js` and add this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `source/actions/search.js` 并添加以下内容：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This sets up two actions that we'll use in `search.jsx`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了我们在 `search.jsx` 中将使用的两个操作。
- en: 'Create `source/components/search.jsx` and add this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `source/components/search.jsx` 并添加以下内容：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create `source/components/results.jsx` and add this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `source/components/results.jsx` 并添加以下内容：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create `source/components/layout.jsx` and add this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `source/components/layout.jsx` 并添加以下内容：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This code propagates pages from the router hierarchy that we set up in `app.jsx`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码传播了我们在 `app.jsx` 中设置的路由层次结构中的页面：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We''ll also create a basic fixed footer for our app, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为我们的应用创建一个基本的固定页脚，如下所示：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create `source/components/footer.jsx` and add this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `source/components/footer.jsx` 并添加以下内容：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The app should now compile and you''ll be greeted with a footer message. We''ll
    need to apply a few styles to fix it to the bottom of the page. Open `public/app.css`
    and replace the contents with this styling:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在应该可以编译，您将看到一个页脚消息。我们需要应用一些样式来将其固定在页面底部。打开`public/app.css`并替换其内容为以下样式：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Setting the page to 100 percent minimum height and setting the footer to the
    absolute position at the bottom will make sure it stays fixed. Now, have a look
    at this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将页面设置为100%最小高度，并将页脚设置为绝对位置在底部，这将确保它保持固定。现在，看看这个：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code is to avoid an outline border from appearing when you click
    on focused divisions. Next, complete the `public/app.css` with the following styling
    to make the search results stand out:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是为了避免在点击焦点部分时出现轮廓边框。接下来，使用以下样式完成`public/app.css`，以使搜索结果突出显示：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Creating a search service
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建搜索服务
- en: Before you go ahead and create a view layer for your search, you need a way
    to connect to your API. You could go about creating this in a variety of ways,
    and this is one situation where you won't find an authoritative answer. Some prefer
    to put this in the action layer, others in the store, and some would be perfectly
    happy to add it to the view layer.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在您继续为搜索创建视图层之前，您需要一种连接到您的API的方法。您可以通过多种方式来完成这项工作，而且这将是您找不到权威答案的情况之一。有些人喜欢将其放在动作层，有些人喜欢放在存储层，有些人可能会非常乐意将其添加到视图层。
- en: We're going to take a cue from the MVC architecture and create a service layer.
    We'll access the service from the `action` file you created earlier. We're going
    to do this for the simple reason that it separates the search into a small and
    easily testable subsection of our code. For simplified development and easy testing,
    you always want to make your components as small as possible.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将借鉴MVC架构并创建一个服务层。我们将从您之前创建的`action`文件中访问服务。我们这样做的原因很简单，因为它将搜索分离成我们代码中的一个较小且易于测试的子部分。为了简化开发和便于测试，您总是希望使您的组件尽可能小。
- en: 'Create a folder called `in service` within your `source` folder and add these
    three files: `index.js`, `request.js`, and `search.js`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`source`文件夹中创建一个名为`in service`的文件夹，并添加以下三个文件：`index.js`、`request.js`和`search.js`。
- en: 'Let''s start by adding the code for `request.js`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加`request.js`的代码开始：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**SuperAgent** is a light-weight client-side HTTP request library that makes
    working with AJAX a lot less painful than it normally is. It''s also fully compatible
    with **node**, which is a huge benefit when performing server-side rendering.
    We''ll delve into server-side rendering in [Chapter 9](ch09.html "Chapter 9. Creating
    a Shared App"), *Creating a Shared App*. Check out the following examples:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**SuperAgent**是一个轻量级的客户端HTTP请求库，它使得使用AJAX比通常要容易得多。它也与**node**完全兼容，这在执行服务器端渲染时是一个巨大的好处。我们将在第9章[创建共享应用程序](ch09.html
    "第9章。创建共享应用程序")中深入探讨服务器端渲染。查看以下示例：'
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We're actually only going to use the `get` function in our app. Other methods
    have been added as examples. You could make additions or deletions here, or even
    merge them into a common function (though that would increase the complexity of
    using the function).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上只会在我们的应用程序中使用`get`函数。其他方法已添加为示例。您可以在其中添加或删除内容，甚至将它们合并到一个公共函数中（尽管这会增加使用该函数的复杂性）。
- en: 'All operations are sent to the `httpAgent` function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作都发送到`httpAgent`函数：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We're adding the bearer token scheme that we developed in our API earlier. If
    you skipped that part, you can remove the preceding two lines, though it doesn't
    matter to the API if it receives a bearer token and has no method to handle it.
    In such cases, it will simply discard the information.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加我们在API中早期开发的bearer token方案。如果您跳过了那部分，您可以删除前面的两行，尽管如果API收到bearer token但没有处理它的方法，这对API来说并不重要。在这种情况下，它将简单地丢弃信息。
- en: 'It''s worth noting that hardcoding the token in the service is terribly unsecure.
    To make it more secure, you could, for instance, set up a scheme where you can
    create a new token in the browser''s session storage with regular intervals and
    replace the hardcoded variable with a lookup instead. Let''s take a look at the
    following code snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在服务中硬编码token非常不安全。为了使其更安全，例如，您可以设置一个方案，在浏览器会话存储中定期创建新的token，并用查找替换硬编码的变量。让我们看看以下代码片段：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After we''re done adding parameters, we need to send the request via the `sendAgent`
    function. This function returns a promise that we can listen to, which will in
    time be either rejected or resolved. A `promise` is a construct used for synchronization.
    It''s a proxy for a result that is initially unknown. When we return a promise
    in our code, we get an object that will eventually contain the data that we want:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加完参数后，我们需要通过`sendAgent`函数发送请求。这个函数返回一个我们可以监听的promise，它最终要么被拒绝要么被解决。`promise`是一个用于同步的构造。它是对最初未知的结果的代理。当我们在代码中返回一个promise时，我们得到一个最终将包含我们想要的数据的对象：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next file we''ll add code for is `search.js`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的下一个文件是`search.js`：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This simply imports and extends the code we created in `request.js`. As we don't
    need to extend or modify any of the request code, we'll simply leave it as it
    is.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是导入并扩展我们在`request.js`中创建的代码。由于我们不需要扩展或修改任何请求代码，我们将保持原样。
- en: 'The final file is `index.js`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个文件是`index.js`：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is where we specify the endpoint from where we connect to our API. The
    preceding setting specifies the API running at localhost. You can substitute this
    with the example interface at [http://websearchapi.herokuapp.com/v1/search/](http://websearchapi.herokuapp.com/v1/search/)
    if you'd like to test your code with an external service.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们指定连接到我们的API的端点的地方。前面的设置指定了运行在localhost上的API。如果您想使用外部服务测试您的代码，可以将此替换为[http://websearchapi.herokuapp.com/v1/search/](http://websearchapi.herokuapp.com/v1/search/)的示例接口。
- en: 'It''s usually a good idea to store endpoints and other configuration details
    in a separate `configuration` file. Let''s create a `config.js` file and place
    it in the `source` folder:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将端点和其他配置细节存储在单独的`configuration`文件中是个好主意。让我们创建一个`config.js`文件，并将其放置在`source`文件夹中：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, change the contents of `service/index.js` to this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`service/index.js`的内容更改为以下内容：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that we needed to dereference the config name from `config.js`. This is
    because we exported it as a named export with `exports` rather than `module.exports`.
    If we had declared the variable first and exported it with `module.exports`, we
    wouldn't have had to dereference it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要从`config.js`中取消对配置名称的引用。这是因为我们使用`exports`而不是`module.exports`作为命名导出。如果我们首先声明变量并使用`module.exports`导出它，我们就不需要取消引用。
- en: The difference is that `exports` is simply a helper to `module`. In the end,
    the module will use `module.exports`, and `Config` will be available as a named
    property to the module.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于`exports`仅仅是`module`的一个辅助工具。最终，模块将使用`module.exports`，并且`Config`将作为模块的一个命名属性可用。
- en: 'You can also import it with this command: `const Config = require(''../config.js'')`
    or `import * as Config from ''../config.js''`. Both variants will set up a `Config`
    variable that you can access with `Config.Config`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下命令导入它：`const Config = require('../config.js')` 或 `import * as Config
    from '../config.js'`。这两种方式都将设置一个`Config`变量，您可以通过`Config.Config`来访问它。
- en: Testing the service
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试服务
- en: 'We''ve made the service, but does it work? Let''s find out. We''ll use a small
    and very competent test framework called **Tape**. Install this with the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了服务，但它是否工作呢？让我们来看看。我们将使用一个小巧而高效的测试框架**Tape**。使用以下命令安装它：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We add `babel-tape-runner` since we're using ECMAScript 6 throughout our app
    and we'd like to use it in our test scripts as well.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加`babel-tape-runner`，因为我们整个应用程序都在使用ECMAScript 6，并且我们希望在测试脚本中也使用它。
- en: 'In the root of the project, create the `test/service` folders and add a file
    called `search.js` and add this code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录中创建`test/service`文件夹，并添加一个名为`search.js`的文件，并添加以下代码：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This test will import the search service and search for a specific title in
    the database. It will return `pass` if an exact match is found. You can run it
    by using a terminal and going to the root folder and executing `./.bin/babel-tape-runner
    test/service/search.js`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将导入搜索服务并在数据库中搜索特定的标题。如果找到精确匹配，它将返回`pass`。您可以通过在终端中进入根文件夹并执行`./.bin/babel-tape-runner
    test/service/search.js`来运行它。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the API server must be up and running before your start the test.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在您开始测试之前，API服务器必须处于运行状态。
- en: 'The result should look like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像这样：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if you install `tape` and `babel-tape-runner` globally with the `-g`
    flag, then you don't need to specify the binary version from `node_modules` and
    simply run the test with `babel-tape-runner test/service/search.js`. To make it
    even easier to run the tests, you can add a script inside the `scripts` section
    of your `package.json` file. If you add the test command to the `tests` script,
    you can execute the test by simply executing `npm test`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您使用`-g`标志全局安装`tape`和`babel-tape-runner`，那么您不需要从`node_modules`指定二进制版本，只需使用`babel-tape-runner
    test/service/search.js`运行测试即可。为了使运行测试更加容易，您可以在`package.json`文件的`scripts`部分添加一个脚本。如果您将测试命令添加到`tests`脚本中，只需执行`npm
    test`即可执行测试。
- en: Setting up the store
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置存储
- en: The store will be very simple. We're going to be performing the service calls
    in the action, so the store will simply hold the results of the service calls
    and pass them on to the components.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 存储将非常简单。我们将在动作中执行服务调用，所以存储将简单地持有服务调用的结果并将它们传递给组件。
- en: 'In the `source` folder, create a new folder and name it `store`. Then create
    a new file, name it `search.js` and add this code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`source`文件夹中，创建一个新的文件夹并命名为`store`。然后创建一个新的文件，命名为`search.js`并添加以下代码：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This is the store state. Setting the variable outside the store definition
    automatically makes this a private variable that is only accessible to the store
    itself, and not to the instances of the store. Refer to the ensuing code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是存储状态。在存储定义之外设置变量会自动使其成为一个私有变量，只能由存储本身访问，而不能由存储的实例访问。请参考以下代码：
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The line in `init()` sets up a listener for the `emitSearchData` action. Whenever
    this action is called, the `emitSearchResults` function is executed:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`中的行设置了一个监听器，用于监听`emitSearchData`动作。每当这个动作被调用时，`emitSearchResults`函数就会被执行：'
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: These lines look a bit complicated, so let's examine the logic from the last
    line up. The trigger action emits the results from the `_history` variable under
    the `results.query` key, which is the search term being used. The search term
    is wrapped with `JSON.stringify`, which is a method that converts JSON data into
    a string. This allows us to keep the query with spaces and use it as an object
    key for our `_history` variable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行看起来有点复杂，所以让我们从最后一行开始检查逻辑。触发动作在`results.query`键下发出`_history`变量的结果，这是正在使用的搜索词。搜索词被`JSON.stringify`包裹，这是一个将JSON数据转换为字符串的方法。这允许我们保留带有空格的查询并将其用作`_history`变量的对象键。
- en: 'The two lines that precede the trigger checks whether the search term has been
    stored in `_history` and adds it if it hasn''t. We currently don''t have a method
    to deal with the history, but it''s conceivable that the store could be extended
    with such a function later:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在触发检查之前的两行代码检查搜索词是否已存储在`_history`中，如果没有则添加它。我们目前没有处理历史记录的方法，但可以设想将来可能通过扩展存储添加这样的功能：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Creating the search view
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建搜索视图
- en: We're finally ready to start work on the view components. Let's open `search.jsx`
    and flesh it out with some content. We'll add a lot of code, so we'll take it
    step by step.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好开始处理视图组件了。让我们打开`search.jsx`并添加一些内容。我们会添加很多代码，所以我们将一步一步来。
- en: 'Start out by replacing the contents with this code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将内容替换为以下代码：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Remember to copy the `FontAwesome` and `Picture` components from [Chapter 3](ch03.html
    "Chapter 3. Responsive Web Development with ReactJS"), *Responsive Web Development
    with ReactJS*, to the `source/components` folder, let''s take a look at the following
    code snippet:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将`FontAwesome`和`Picture`组件从[第3章](ch03.html "第3章。使用ReactJS进行响应式Web开发")，*使用ReactJS进行响应式Web开发*，复制到`source/components`文件夹中，让我们看看以下代码片段：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`QuickSearch` will pop up a set of search results as you type. We want to keep
    this hidden initially, let''s take a look at the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuickSearch`会在你输入时弹出搜索结果集。我们希望最初将其隐藏，让我们看看以下代码：'
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The quick-search currently does nothing, let''s take a look at the following
    code snippet:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 快速搜索目前没有任何作用，让我们看看以下代码片段：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Using the `Picture` component means we can provide a high-resolution version
    for desktop and tablet users and a smaller version for mobile users. A full description
    of this component can be found in [Chapter 3](ch03.html "Chapter 3. Responsive
    Web Development with ReactJS"), *Responsive Web Development with ReactJS*. Now
    refer to the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Picture`组件意味着我们可以为桌面和平板用户提供一个高分辨率版本，为移动用户提供一个较小版本。该组件的完整描述可以在[第3章](ch03.html
    "第3章。使用ReactJS进行响应式Web开发")，*使用ReactJS进行响应式Web开发*中找到。现在请参考以下代码：
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This will propagate a children page from the routing setup in `app.jsx`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从一个名为 `app.jsx` 的路由设置中传播一个子页面：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Things are finally happening on screen. If you open your web browser now, you'll
    see a logo on the screen; below it, you'll find a search field with a magnifying
    glass to the left and a **Search** button to the right.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的事情终于开始了。如果你现在打开你的网络浏览器，你会在屏幕上看到一个标志；在其下方，你会找到一个带有左侧放大镜和右侧**搜索**按钮的搜索字段。
- en: However, nothing happens when you start typing, and no results appear when you
    click on the **Search** button. Clearly, there's more work ahead.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你开始输入时，没有任何反应，点击**搜索**按钮时也没有出现结果。显然，还有更多工作要做。
- en: 'Let''s flesh out the `QuickSearch` method. Replace the empty block with this
    code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们具体实现 `QuickSearch` 方法。用以下代码替换空块：
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And, replace the initial state block with this code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用以下代码替换初始状态块：
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `QuickSearch` method now iterates over the results from the state and adds
    a `ListGroupItem` item with an `onClick` handler, a header, a description, and
    a link. We'll add the `results` variable to the initial state to avoid the app
    from stopping because of an undefined `state` variable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuickSearch` 方法现在遍历状态中的结果，并添加一个带有 `onClick` 处理器、标题、描述和链接的 `ListGroupItem`
    项目。我们将 `results` 变量添加到初始状态中，以避免应用程序因为未定义的 `state` 变量而停止。'
- en: 'Next up, we need to add the `onClick` handler to the code. To do this, add
    the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在代码中添加 `onClick` 处理器。为此，添加以下代码：
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This code will force the browser to load the URL contained in the target index,
    which corresponds to `targetIndex`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将强制浏览器加载目标索引中包含的URL，这对应于 `targetIndex`。
- en: Yet, typing anything in the input field still doesn't do anything. Let's do
    something about it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在输入字段中输入任何内容仍然没有任何反应。让我们来解决这个问题。
- en: Performing searches
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行搜索
- en: The idea now is to present a real-time search while the user types in the search
    input. We've already created the setup for this to happen; all we need is to connect
    the act of typing into action.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的想法是在用户在搜索输入中输入时展示实时搜索。我们已经为这种情况创建了设置；我们只需要将输入动作与行动连接起来。
- en: 'The first idea that springs to mind is to add an `onChange` handler to the
    input field itself. This is the easiest way to accomplish the first milestone,
    presenting the search. It would look like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个想法是在输入字段本身添加一个 `onChange` 处理器。这是实现第一个里程碑、展示搜索的最简单方法。它看起来像这样：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, you''d add a `performSearch` method to the code, like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在代码中添加一个 `performSearch` 方法，如下所示：
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When you start typing now, the console log will immediately start filling up
    with values:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始输入时，控制台日志将立即开始填充值：
- en: '![Performing searches](img/B04943_04_01.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![进行搜索](img/B04943_04_01.jpg)'
- en: This is quite decent, but for a search page that only consists of a single input
    field and nothing more, it would be nice to not have to manually focus on the
    search field in order to input values.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当不错，但对于一个只包含单个输入字段而没有其他内容的搜索页面，最好不需要手动将焦点放在搜索字段上以便输入值。
- en: Let's drop the `onChange` handler and start the search process as soon as the
    user inputs data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除 `onChange` 处理器，并在用户输入数据时立即开始搜索过程。
- en: 'Add the following two methods to `search.jsx`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下两个方法添加到 `search.jsx` 中：
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This sets up two event listeners when the component mounts. The `keypress` event
    listener takes care of ordinary key events, while the `keydown` event listener
    makes sure we can capture the arrow key input as well.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在组件挂载时设置两个事件监听器。`keypress` 事件监听器负责处理普通按键事件，而 `keydown` 事件监听器确保我们可以捕获箭头键输入。
- en: The `handleKeypress` method is quite complex, so let's add the code and examine
    it step by step.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleKeypress` 方法相当复杂，所以让我们添加代码并逐步检查它。'
- en: 'When you''ve registered these event listeners, you''ll be able to capture every
    key event from the user. If the user hits the key *A*, an object will be sent
    to the `handleKeypress` function with a lot of information about the event. Here''s
    a subsection of the attributes from the event object that is of particular interest
    to us:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你注册了这些事件监听器后，你将能够捕获用户的每一个按键事件。如果用户按下键 *A*，一个包含大量关于事件信息的对象将被发送到 `handleKeypress`
    函数。以下是事件对象中对我们特别感兴趣的属性的一部分：
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It tells us it's a `keypress` event (the arrow keys would register as a `keydown`
    event). The `charCode` parameter is `97`, and neither the *Alt* key, the *Meta*
    key, the *Ctrl* key, or the *Shift* key was used in conjunction with the event.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们这是一个 `keypress` 事件（箭头键将注册为 `keydown` 事件）。`charCode` 参数是 `97`，并且没有使用 *Alt*
    键、*Meta* 键、*Ctrl* 键或 *Shift* 键与事件一起使用。
- en: We can decode `charCode` with a native JavaScript function. If you execute `String.fromCharCode(97)`,
    you'll get a string back with a lowercase `a`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用原生的 JavaScript 函数解码 `charCode`。如果您执行 `String.fromCharCode(97)`，您将得到一个包含小写字母
    `a` 的字符串。
- en: 'Working with key events based on knowing the numbers is doable, but it''s better
    to map the numbers to friendlier strings, so we''ll add an object to hold the
    `charCode` parameters for us. Add this to the top of the file, just below the
    imports but above the `createClass` definition:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数字处理按键事件是可行的，但将数字映射到更友好的字符串会更好，因此我们将添加一个对象来保存我们的 `charCode` 参数。将此添加到文件顶部，位于导入语句下方但
    `createClass` 定义之上：
- en: '[PRE65]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now we can type `keys.BACKSPACE` and it will send the number `8` and so on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以输入 `keys.BACKSPACE` 并发送数字 `8`，依此类推。
- en: 'Let''s add the `handleKeypress` function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加 `handleKeypress` 函数：
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we detect that the user is using either the *Ctrl* or *Meta* key (**CMD**
    on Mac), we terminate the function. This allows the user to use regular OS methods,
    such as copy/paste or *Ctrl* + *A* to select all of the text, let''s take a look
    at the following code snippet:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检测到用户正在使用 *Ctrl* 或 *Meta* 键（在 Mac 上为 **CMD**），我们将终止函数。这允许用户使用常规的操作系统方法，例如复制/粘贴或
    *Ctrl* + *A* 选择所有文本，让我们看一下以下代码片段：
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We define a variable to hold the input field, so we don''t have to look it
    up more than once. For compatibility reasons, we also make sure we get a valid
    character code by checking whether the character type passed to us is a number.
    Refer to the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个变量来保存输入字段，这样我们就不必多次查找它。出于兼容性原因，我们还确保通过检查传递给我们的字符类型是否为数字来获取有效的字符代码。请参阅以下内容：
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We add a `closeSearchField` function in order to hide the search results even
    if it''s populated. We do this because we don''t want it to remain open when the
    user has cleared out all of the text and is ready to start a new search, let''s
    take a look at the following code snippet:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个 `closeSearchField` 函数，以便即使在搜索结果已填充的情况下也能隐藏搜索结果。我们这样做是因为我们不希望当用户清除所有文本并准备开始新的搜索时，它仍然保持打开状态，让我们看一下以下代码片段：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We''ll also hide the search results if the user presses the *Esc* key, let''s
    take a look at the following code snippet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户按下 *Esc* 键，我们还将隐藏搜索结果，让我们看一下以下代码片段：
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'These checks don''t do anything, but they''ll prevent the switch to hit `default`
    and thus trigger a search, let''s take a look at the following code snippet:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检查没有任何作用，但它们将防止开关触达 `default` 并因此触发搜索，让我们看一下以下代码片段：
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We''ve added special handling for the arrow keys. When the user presses the
    up arrow, the `activeIndex` will decrease as long as it''s zero or above. This
    will make sure we''ll never have to deal with an invalid `activeIndex` parameter
    (less than `-1`):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为箭头键添加了特殊处理。当用户按下上箭头键时，只要 `activeIndex` 为零或更高，它就会递减。这将确保我们永远不会处理无效的 `activeIndex`
    参数（小于 `-1`）：
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We''ve defined that the maximum number of results for the quick search is `5`.
    This snippet will make sure `activeIndex` never goes above `5`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已定义快速搜索的最大结果数为 `5`。此代码片段将确保 `activeIndex` 永远不会超过 `5`：
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This switch does one of two things. First, if `activeIndex` is `-1`, it means
    the user has not navigated to any of the quick search results, and we'll simply
    go to the results page for all the matches. The same will happen if `activeIndex`
    is not `-1` but `inputfield` still has focus (`inputField === document.activeElement`).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此开关执行两种操作之一。首先，如果 `activeIndex` 为 `-1`，则表示用户尚未导航到任何快速搜索结果，我们将直接跳转到所有匹配项的结果页面。如果
    `activeIndex` 不是 `-1` 但 `inputfield` 仍然具有焦点（`inputField === document.activeElement`），也会发生相同的情况。
- en: 'Second, if `activeIndex` is not `-1`, the user has navigated below the input
    and made a choice. In that case, we''ll send the user to the desired URL:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果 `activeIndex` 不是 `-1`，则表示用户已导航到输入字段下方并做出了选择。在这种情况下，我们将用户发送到所需的 URL：
- en: '[PRE74]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Finally, if none of the switches are valid, for instance, a regular key has
    been pressed, then we'll perform a search. We'll also hide any potential complete
    results with the `SearchActions.hideResults()` action.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果没有一个开关有效，例如，按下了常规键，那么我们将执行搜索。我们还将使用 `SearchActions.hideResults()` 动作隐藏任何潜在的不完整结果。
- en: 'This code will not compile until we add `hideResults` to our actions, so open
    `actions/search.js` and add these lines to the actions object:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在添加`hideResults`到我们的操作之前无法编译，所以打开`actions/search.js`并在操作对象中添加这些行：
- en: '[PRE75]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The code will compile and when you start typing in the browser, the input field
    will be focused and will receive input. It''s finally time to hook up our search
    service, and we''ll do that in the `actions` file you just edited. Add these two
    lines at the top of the file, just beneath the first import:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将编译，并且当您在浏览器中开始输入时，输入字段将获得焦点并接收输入。现在是时候将我们的搜索服务连接起来，我们将在您刚刚编辑的`actions`文件中这样做。在文件顶部，在第一个导入下面添加这两行：
- en: '[PRE76]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We'll create a private `_history` variable to hold our search history. It's
    not strictly necessary, but we'll use it to reduce the number of API calls we're
    going to make.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个私有的`_history`变量来保存我们的搜索历史。这并不是严格必要的，但我们将使用它来减少我们将要进行的API调用次数。
- en: 'Next, add this snippet:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加此片段：
- en: '[PRE77]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This code will make sure we call our API whenever `performSearch` is triggered.
    Whenever a result is returned from the search service, we store it in our `_history`
    object, and we'll make sure to check whether there's a result ready for us before
    we send a new query to the search service. This will save us a trip to the API
    and the user will get a faster response.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将确保每当触发`performSearch`时，我们都会调用我们的API。每当搜索服务返回结果时，我们将它存储在我们的`_history`对象中，并在我们向搜索服务发送新查询之前，确保有结果准备好。这将节省我们一次API调用，并且用户将获得更快的响应。
- en: 'Next, add the code that will actually perform the search when we type or hit
    the button. Replace the code inside `performSearch()` with this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加当我们在文本框中输入或点击按钮时实际执行搜索的代码。用以下代码替换`performSearch()`内部的代码：
- en: '[PRE78]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We''ll need to do one more thing before we can see the results in the browser,
    but you can verify that it works by typing in search queries and examining the
    network traffic in the developer tools:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够在浏览器中看到结果之前，我们还需要做一件事，但您可以通过输入搜索查询并在开发者工具中检查网络流量来验证它是否工作：
- en: '![Performing searches](img/B04943_04_02.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![执行搜索](img/B04943_04_02.jpg)'
- en: To show our results in the browser, we'll need to add a listener that can react
    to the changes in the store.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要在浏览器中显示我们的结果，我们需要添加一个监听器，它可以对存储中的变化做出反应。
- en: 'Open `components/search.jsx` and add this code just before `getInitialState`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`components/search.jsx`并在`getInitialState`之前添加此代码：
- en: '[PRE79]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: What this code does is tell React to call `getSearchResults` when `SearchStore`
    emits new data. The function it calls stores up to five results in the component
    state. When you type in something now, a list group will pop up beneath the search
    field with the results.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的作用是告诉React在`SearchStore`发出新数据时调用`getSearchResults`。它调用的函数将最多存储五个结果在组件状态中。现在，当您输入某些内容时，一个列表组将出现在搜索字段下方，显示结果。
- en: You can use your mouse to hover over any result and click on it to visit the
    link it refers to.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用鼠标悬停在任何结果上，然后点击它以访问它所引用的链接。
- en: Navigating the search results with the arrow keys
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用箭头键导航搜索结果
- en: Since we've already put in so much work with the keyboard events, it would be
    a shame to not utilize it even more. You're already using your keyboard when you're
    searching, so it seems natural to be able to navigate the search results with
    the arrow keys as well, and then press *Enter* to go to the page you've selected.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经对键盘事件做了很多工作，不进一步利用它将是一件遗憾的事情。您在搜索时已经在使用键盘，所以能够使用箭头键导航搜索结果似乎很自然，然后按*Enter*键访问您选择的那一页。
- en: 'Open `search.jsx`. In `getInitialState` add this key:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`search.jsx`。在`getInitialState`中添加此键：
- en: '[PRE80]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, in the `renderQuickSearch` function, add the highlighted line with `className`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`renderQuickSearch`函数中，添加带有`className`的高亮行：
- en: '[PRE81]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now you'll be able to move up and down with the arrow keys and hit *Enter* to
    visit the active link. There's a couple of things about this solution that's a
    little bit annoying though. For one, when you're navigating up and down, the input
    field stays focused. If you enter something else, you'll get a new set of search
    results, but the active index will stay the same as before, possibly being out
    of bounds if the new result returns fewer results than the previous one. Second,
    the up and down action moves the cursor in the input field, and that is quite
    disconcerting.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将能够使用箭头键上下移动，并按*Enter*键访问活动链接。然而，这个解决方案有几个小问题让人感到有些烦恼。首先，当你上下导航时，输入字段保持聚焦。如果你输入其他内容，你会得到一组新的搜索结果，但活动索引将保持不变，如果新结果返回的结果少于上一个结果，可能会超出范围。其次，上下动作将光标移动到输入字段中，这会让人感到不安。
- en: The first problem is quite easy to solve; it's simply a matter of adding `activeIndex:-1`
    to the `getSearchResults` function, but the second problem requires us to resort
    to an old web developer trick. There's simply no way to "unfocus" the input field,
    so instead, we'll create a hidden and invisible input field that we'll send the
    focus to.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题很容易解决；只需将`activeIndex:-1`添加到`getSearchResults`函数中即可，但第二个问题需要我们求助于一个老牌的网页开发者技巧。简单地来说，没有方法可以“取消聚焦”输入字段，因此，我们将创建一个隐藏且不可见的输入字段，并将焦点发送到该字段。
- en: 'Add this code to just above the input field in the `render` method:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`方法中，将此代码添加到输入字段上方：
- en: '[PRE82]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'And then go to the `switch` method and add the highlighted line to the down
    arrow action:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后转到`switch`方法，并将高亮行添加到向下箭头动作中：
- en: '[PRE83]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'When the app recompiles, you''ll be able to navigate up and down, and the proper
    input field will only activate when you''ve navigated up to the top. The rest
    of the time the hidden input field will have focus, but as it''s placed outside
    the viewport, no one will see it or be able to use it. Let''s take a look at the
    following screenshot:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用重新编译时，你将能够使用箭头键上下导航，并且只有当你导航到顶部时，正确的输入字段才会激活。其余时间，隐藏的输入字段将拥有焦点，但由于它放置在视口之外，没有人会看到它或能够使用它。让我们看看下面的截图：
- en: '![Navigating the search results with the arrow keys](img/B04943_04_03.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![使用箭头键导航搜索结果](img/B04943_04_03.jpg)'
- en: Debouncing the search
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索防抖
- en: Every `keypress` class submits a new search to the API. Even with the history
    variable system we've implemented, that's quite a hammering we're bringing down
    on our API. It's not in the user's best interest either, because it will probably
    lead to a slew of irrelevant hits. Imagine you're interested in searching for
    JavaScript. You're probably not interested in getting results for j, ja, jav,
    Java, javas, javasc, javascr, javascri, and JavaScript, but this is currently
    what's happening.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`keypress`类都会向API提交一个新的搜索。即使我们有实现的历史变量系统，这也给我们的API带来了很大的压力。这对用户来说也不是最好的选择，因为它可能会引发一系列不相关的搜索结果。想象一下，你想要搜索JavaScript。你可能对j、ja、jav、Java、javas、javasc、javascri、javascri和JavaScript的结果不感兴趣，但当前的情况就是这样。
- en: 'Fortunately, it''s quite easy to improve the user experience by simply delaying
    the search. Go to the `switch` statement and replace the content with this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过简单地延迟搜索，我们可以很容易地提高用户体验。转到`switch`语句，并用以下内容替换内容：
- en: '[PRE84]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You''ll need the `delay` function as well, so add it to the top of the file,
    just below the imports:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要`delay`函数，所以将其添加到文件顶部，紧接在导入之后：
- en: '[PRE85]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This code will make sure the results are delayed just enough to allow the user
    to type in a query before exiting, but not make it feel sluggish. You should experiment
    with the milliseconds setting to suit your needs best.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将确保结果延迟足够长，以便用户在退出前可以输入查询，但不会感觉迟缓。你应该根据需要调整毫秒设置。
- en: Moving beyond the quick search to the results page
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从快速搜索到结果页面的过渡
- en: 'We''re almost done with the component now. The final piece of code we''ll add
    to `search.jsx` is the functionality for handling the search button and preparing
    to move on to the next page. To do this, add the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们几乎完成了组件的开发。接下来，我们将向`search.jsx`添加最后一段代码，用于处理搜索按钮和准备进入下一页。为此，请添加以下代码：
- en: '[PRE86]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This code will close the search field and send us to a new route using `push`
    from react-router.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将关闭搜索字段，并使用`push`从react-router导航到新的路由。
- en: 'The `push` parameter is supported by the 2.0 branch of react-router, so all
    we need to do is add a context type to our component. We can do this by adding
    these lines at the top of the component (just beneath the line with `React.createClass`):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`参数由react-router的2.0分支支持，所以我们只需要在我们的组件中添加一个上下文类型。我们可以通过在组件顶部添加以下行（在`React.createClass`行下方）来完成此操作：'
- en: '[PRE87]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Setting up the results page
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置结果页面
- en: The purpose of the results page is to show all of the search results. Traditionally,
    you show a list of 10-20 results and the paging functionality, which allows you
    to show more results until you reach the end.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 结果页面的目的是显示所有搜索结果。传统上，你显示10-20个结果和分页功能，这允许你显示更多结果，直到达到末尾。
- en: Let's set up the results page and start with a traditional pager.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置结果页面，并从传统的分页器开始。
- en: 'Open `components/results.jsx` and replace the contents with the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`components/results.jsx`，并用以下内容替换其内容：
- en: '[PRE88]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Setting the `contextType` object is necessary in order to retrieve the `query`
    parameter from the URL. Now look at the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`contextType`对象是为了从URL中检索`query`参数。现在看看以下内容：
- en: '[PRE89]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here we define that the results should be visible by default. This is necessary
    for users that go to the search page directly. We also define that we want to
    show 10 results per page, let''s take a look at the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们定义结果默认是可见的。这对于直接访问搜索页面的用户是必要的。我们还定义了每页显示10个结果，让我们看看以下代码：
- en: '[PRE90]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We want to kick off the search as soon as possible in order to have something
    to display to the user. If we''re moving on from the front page, the results will
    already be ready in the `_history` variable and will be available before the component
    is mounted. Refer to the following code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望尽可能快地启动搜索，以便向用户显示一些内容。如果我们是从首页继续，结果已经在`_history`变量中准备好了，并且将在组件挂载之前可用。参看以下代码：
- en: '[PRE91]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `hideResults` and `showResults` methods are actions that will be used when
    the user starts a new query. Instead of pushing the results down or displaying
    the quick search above the results, we simply hide the existing results:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`hideResults`和`showResults`方法是在用户开始新的查询时使用的操作。我们不是将结果向下推送或在上面的结果上方显示快速搜索，而是简单地隐藏现有的结果：'
- en: '[PRE92]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'These `setState` functions react to the preceding actions, as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`setState`函数响应前面的操作，如下所示：
- en: '[PRE93]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'When we retrieve fewer results than `this.state.resultsToShow`, we adjust the
    state variable to the number of results in the set, let''s take a look at the
    following code snippet:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检索的结果少于`this.state.resultsToShow`时，我们将状态变量调整为集合中的结果数量，让我们看看以下代码片段：
- en: '[PRE94]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This renderer is almost identical to the one in `search.jsx`. The main difference
    is that we return a button with a `link` style and that we don''t have an `activeIndex`
    attribute that we check, let''s take a look at the remaining code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个渲染器几乎与`search.jsx`中的那个相同。主要区别在于我们返回一个具有`link`样式的按钮，并且我们没有检查`activeIndex`属性，让我们看看剩余的代码：
- en: '[PRE95]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Setting up pagination
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置分页
- en: 'Let''s start by adding an attribute to `getInitialState` and a `resetState`
    function:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先给`getInitialState`添加一个属性和一个`resetState`函数：
- en: '[PRE96]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `resetState` function needs to be added to `getSearchResults`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在`getSearchResults`中添加`resetState`函数：
- en: '[PRE97]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: There's absolutely no problem running two `setStates` objects one after the
    other. They will simply be queued on a first come, first served basis.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 依次运行两个`setStates`对象完全没有问题。它们将简单地按先来先服务的顺序排队。
- en: 'Next, add a pager:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个分页器：
- en: '[PRE98]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This pager will automatically populate a number of buttons on the page, in this
    case, 10\. The number of items is determined by the number of results divided
    by the number of items to show on each page. `Math.ceil` rounds up to the nearest
    integer, so if you get 54 results, the number of pages will be rounded up to 6
    from 5.4\. The first five pages will show ten results, and the last page will
    show the remaining four results.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分页器将自动在页面上填充一定数量的按钮，在这个例子中是10个。项目的数量由结果数量除以每页显示的项目数量确定。`Math.ceil`向上取整到最接近的整数，所以如果你得到54个结果，页数将从5.4向上取整到6。前五页将显示十个结果，最后一页将显示剩余的四个结果。
- en: 'In order to use the pagination component, we need to add it to the imports
    section, so replace the react-bootstrap import with this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用分页组件，我们需要将其添加到导入部分，所以用以下内容替换`react-bootstrap`导入：
- en: '[PRE99]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'To show the pager, replace the render with this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示分页器，用以下内容替换`render`：
- en: '[PRE100]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'And, add the `handleSelect` function:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加`handleSelect`函数：
- en: '[PRE101]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'That''s all you need to set up a pager. There''s only one problem. When you
    click on **Next**, you are left at the bottom position, and as a user, that doesn''t
    feel right. Let''s add a nice scroll to it with this dependency:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要设置分页器的所有内容。只有一个问题。当你点击**下一步**时，你会被留在底部位置，作为一个用户，这感觉并不对。让我们用这个依赖项添加一个漂亮的滚动效果：
- en: '[PRE102]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We''ll add it to the imports section:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将它添加到导入部分：
- en: '[PRE103]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Add this to the `handleSelect` function:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`handleSelect`函数中：
- en: '[PRE104]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'There are lots of scroll variants to choose from. Here are some other settings
    you can try:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多滚动变体可供选择。以下是一些你可以尝试的其他设置：
- en: '[PRE105]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的截图：
- en: '![Setting up pagination](img/B04943_04_04.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![设置分页](img/B04943_04_04.jpg)'
- en: Setting up endless scroll
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置无限滚动
- en: '**Endless scroll** is a very popular functionality, and it so happens that
    it''s very easy to implement in ReactJS. Let''s go back to the state of the code
    as it was before we added the pager and implement endless scrolling instead.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**无限滚动**是一个非常受欢迎的功能，而且它很容易在ReactJS中实现。让我们回到添加分页器之前代码的状态，并实现无限滚动。'
- en: Endless scrolling works by simply loading more items as you reach the end of
    the page. There are no pagers involved. You simply scroll, and then you scroll
    some more.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 无限滚动通过简单地在你到达页面底部时加载更多项目来工作。没有分页器参与。你只需滚动，然后继续滚动。
- en: Let's see how we can add this to our code.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将这个功能添加到我们的代码中。
- en: 'First, we need to add a couple of attributes to `getInitialState`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向`getInitialState`添加几个属性：
- en: '[PRE106]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `threshold` variable is given in pixels and will activate when we reach
    60 pixels from the bottom. The `increase` variable is how many more items we'll
    load at a time. It's usually the same as the `resultToShow` variable, but in this
    case, three proved to be very visual.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`threshold`变量以像素为单位给出，当达到底部60像素时激活。`increase`变量是我们一次将加载多少个项目的数量。它通常与`resultToShow`变量相同，但在这个例子中，三个看起来非常直观。'
- en: 'We''ll then add an event listener to mount (and remove it when we''re done
    with it):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个事件监听器来挂载（并在我们完成时移除它）：
- en: '[PRE107]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: These event listeners will listen to the scroll event. It will also start `scrollListener`
    as soon as the component is mounted.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件监听器将监听滚动事件。它也会在组件挂载后立即启动`scrollListener`。
- en: 'Next, we''ll add the actual function:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加实际的功能：
- en: '[PRE108]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'While we still have more results, increase the number of results to show with
    the number in `this.state.increase`, let''s take a look at the following code:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们还有更多结果时，通过`this.state.increase`中的数字增加要显示的结果数量，让我们看看以下代码：
- en: '[PRE109]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'When we can increase no more, we set `resultsToShow` to be identical to the
    number of results received, let''s take a look at the following code snippet:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不能再增加时，我们将`resultsToShow`设置为与接收到的结果数量相同，让我们看看以下代码片段：
- en: '[PRE110]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: This function simply finds the top position of the component within the viewport.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只是找到组件在视口中的顶部位置。
- en: When you scroll down now, the page will load new snippets until it runs out
    of results. It can definitely be argued that this is a simplistic endless scroll
    and it's neither endless nor does it actually load more content.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你向下滚动时，页面将加载新的片段，直到没有更多结果。这绝对可以被认为是一个简单的无限滚动，它既不是无限的，实际上也没有加载更多内容。
- en: However, it's easy to modify it in such a way that instead of setting a new
    state immediately, it sends an action call that triggers a service call to load
    more data. In this case, the listener needs to be detached until a new set of
    data arrives, and when it does, reattach the listener and set up a new state like
    we did earlier. If you truly have an endless amount of data to fetch, this method
    will not let you down.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，很容易修改它，使其不是立即设置新状态，而是发送一个触发服务调用以加载更多数据的动作调用。在这种情况下，监听器需要在新的数据集到达之前断开连接，然后重新连接监听器并设置新的状态，就像我们之前做的那样。如果你确实有无限多的数据要获取，这种方法不会让你失望。
- en: We are getting close to completion. There's only one more thing to add. The
    input field is not populated when you go to the results page directly. It's not
    critically important, but it's a nice feature, so let's add it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接近完成。只剩下一件事要添加。当你直接访问结果页面时，输入字段不会被填充。这不是至关重要，但这是一个很好的功能，所以让我们添加它。
- en: 'In the `componentWillMount` function in `results.jsx`, add this line:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在`results.jsx`中的`componentWillMount`函数中添加以下行：
- en: '[PRE111]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Then, open `search.jsx` again and add this line to the mixins:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次打开`search.jsx`并添加以下行到mixins中：
- en: '[PRE112]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'In the same file, add the function that sets the input text:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，添加设置输入文本的函数：
- en: '[PRE113]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'And finally, in `actions/search.js`, add this to the `actions` object:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`actions/search.js`中，将以下内容添加到`actions`对象中：
- en: '[PRE114]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: If you navigate directly to the results page now, for instance, by going locally
    to your test site `http://localhost:3001/search?q=javascript` or remotely to the
    example app [http://websearchapp.herokuapp.com/search?q=javascript](http://websearchapp.herokuapp.com/search?q=javascript),
    you'll find the input field being set with whatever you would add to the `q` variable.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在直接导航到结果页面，例如，通过本地访问你的测试站点`http://localhost:3001/search?q=javascript`或远程访问示例应用程序[http://websearchapp.herokuapp.com/search?q=javascript](http://websearchapp.herokuapp.com/search?q=javascript)，你会发现输入字段被设置为你要添加到`q`变量中的任何内容。
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we made a working API and hooked it up to a MongoDB instance
    before marching to make a snappy search application that displays results as you
    search in real time. Furthermore, we looked at event listeners for keyboard actions
    as well as scroll actions and put them to work.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个可工作的API，并将其连接到MongoDB实例，然后着手制作一个快速搜索应用程序，该应用程序可以实时显示搜索结果。此外，我们还研究了键盘动作和滚动动作的事件监听器，并将它们投入使用。
- en: Congratulations! That was a lot of hard work.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这是一项艰巨的工作。
- en: Note
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The finished project can be viewed online at [https://reactjsblueprints-chapter4.herokuapp.com](https://reactjsblueprints-chapter4.herokuapp.com).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的项目可以在网上查看，地址为[https://reactjsblueprints-chapter4.herokuapp.com](https://reactjsblueprints-chapter4.herokuapp.com)。
- en: You can improve the project in many ways. For instance, the search component
    is quite long and hard to maintain. It's a good idea to split it up into a number
    of smaller components.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过许多方式改进项目。例如，搜索组件相当长，难以维护。将其拆分为多个较小的组件是个好主意。
- en: You can also implement an `update` method so that every click on a search result
    gets stored in your MongoDB instance. This makes it possible for you to range
    popular hits among your users.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以实现一个`update`方法，以便将每个搜索结果的点击都存储在你的MongoDB实例中。这使得你能够在你用户中查看热门点击。
- en: In the next chapter, we'll venture outside and look at making a map-based application
    and using the HTML5 Geolocation API.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将走出室内，探讨如何制作基于地图的应用程序，并使用HTML5地理位置API。
