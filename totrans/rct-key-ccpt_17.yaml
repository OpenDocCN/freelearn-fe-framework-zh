- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding React Suspense & The use() Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe the purpose and functionality of React’s Suspense feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Suspense with RSCs to show fallback content on a granular level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Suspense for client components via React’s `use()` Hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply different Suspense strategies for data fetching and fallback content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    , in the *Reducing Bundle Sizes via Code Splitting (Lazy Loading)* section, you
    learned about React’s `<Suspense>` component and how it may be used in the context
    of lazy loading and code splitting to show fallback content while a code bundle
    is being downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: As explained there, the purpose of the `Suspense` component is to simplify the
    process of showing fallback content, which, in turn, can lead to a better user
    experience. Since staring at outdated content or a blank page is not something
    most users appreciate, having a built-in feature that shows alternative content
    is very convenient.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn that React’s `Suspense` component is not limited
    to being used for code splitting. Instead, it can also be used for data fetching
    to show some temporary content while data is being loaded (e.g., from a database).
    Though, as you will also learn, `Suspense` can only be used for data fetching
    if the data is fetched in a certain way.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, this chapter will revisit the `use()` Hook, which was introduced
    in *Chapter 11* , *Working with Complex State* . As you will learn, besides using
    it for getting access to context values, this Hook can be used in conjunction
    with `Suspense` as well.
  prefs: []
  type: TYPE_NORMAL
- en: Showing Granular Fallback Content with Suspense
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When fetching data or downloading a resource (e.g., a code file), loading delays
    can occur—delays that can lead to a bad user experience. You should therefore
    consider showing some temporary fallback content while waiting for the requested
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, to simplify the process of rendering fallback content while
    waiting for some resource, React offers its `Suspense` component. As shown in
    *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities* , you
    can use the `Suspense` component as a wrapper around React elements that fetch
    some code or data. For example, when using it in the context of code splitting,
    you can show some temporary fallback content like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example (which is from a regular Vite-based React project), React’s
    `Suspense` component is wrapped around the conditionally rendered `DateCalculator`
    component. `DateCalculator` is created with the help of React’s `lazy()` function,
    which is used to lazily (i.e., on demand) load the code bundle that belongs to
    this component.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the entire other page content is shown right from the start. Only
    the conditionally displayed `DateCalculator` component is replaced with the fallback
    content ( `<p>Loading...</p>` ) while the code is being fetched. Thus, `Suspense`
    is used to render some fallback JSX code on a very granular level. Instead of
    replacing the entire page or component markup with some temporary content, only
    a small part of the UI is replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, `Suspense` therefore provides a functionality that would also be
    nice to have when fetching data—after all, delays occur frequently there, too.
  prefs: []
  type: TYPE_NORMAL
- en: Using Suspense for Data Fetching with Next.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained in the previous chapter, in the *Managing Loading States with Next.js*
    section, the process of data fetching also often comes with waiting times that
    can negatively impact user experience. That’s why, in that same section, you learned
    that Next.js allows you to define a `loading.js` file that contains some fallback
    component that’s rendered during such a delay.
  prefs: []
  type: TYPE_NORMAL
- en: However, using that approach essentially replaces the entire page (or the main
    area of that page) with the loading fallback component content. But that’s not
    always ideal—you instead might want to display some loading fallback content on
    a more granular level when fetching data.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, in Next.js projects, you can use `Suspense` in a similar way, as
    shown in the example from the previous section, to wrap it around components that
    fetch data. Since Next.js supports HTTP response streaming, it’s able to render
    the rest of the page immediately while streaming the content that depends on the
    fetched data to the client side once it’s available. Until the data is loaded
    and available, `Suspense` will render its defined fallback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, coming back to the example from the *Managing Loading States with
    Next.js* section of *Chapter 16* , *React Server Components & Server Actions*
    , you can take advantage of `Suspense` by outsourcing the data fetching code into
    a separate `UserGoals` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This `UserGoals` component can then be wrapped with `Suspense` in the `GoalsPage`
    component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code now utilizes React’s `Suspense` component to show a fallback paragraph
    while the `UserGoals` component is fetching data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete demo project code on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/02-data-fetching-suspense](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/02-data-fetching-suspense)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: As a result, when users navigate to `/goals` , they immediately see the title
    (the `<h1>` element) in combination with the fallback content. There is no need
    for a separate `loading.js` file anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screen shot of a computer screen  Description automatically generated](img/B31339_17_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.1: The fallback content is shown as part of the target page, instead
    of entirely replacing it'
  prefs: []
  type: TYPE_NORMAL
- en: However, the advantage of using `Suspense` in this situation is not just that
    the `loading.js` file isn’t needed anymore. Instead, data fetching and fallback
    content can now be managed on a very granular level.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a more complex online shop application, you could have a component
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `<header>` and `<section id="search">` elements are always
    visible and rendered. On the other hand, `<DailyDeal />` and `<Products />` are
    only rendered once their data has been fetched. Until then, their respective fallbacks
    are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a website  Description automatically generated](img/B31339_17_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.2: Placeholders are shown initially until loaded data is streamed
    in and rendered to the screen'
  prefs: []
  type: TYPE_NORMAL
- en: '`<DailyDeal />` and `<Products />` will be loaded and rendered independently
    from each other since they’re wrapped by two different `Suspense` blocks. Consequently,
    users will immediately see the header and search area, and then eventually see
    the daily deal and products—though either of the two may load and render first.'
  prefs: []
  type: TYPE_NORMAL
- en: What’s important about these examples is that the components wrapped by `Suspense`
    are RSCs that use `async/await` . As you will learn in the next section, not all
    React components will interact with the `Suspense` component. But React Server
    Components, in Next.js projects, will.
  prefs: []
  type: TYPE_NORMAL
- en: Using Suspense in Other React Projects—Possible, But Tricky
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous section explored how you may take advantage of `Suspense` for data
    fetching with RSCs in Next.js projects.
  prefs: []
  type: TYPE_NORMAL
- en: However, `Suspense` is not a Next.js-specific feature or concept—instead, it’s
    provided by React itself. Consequently, you can use it in any React project to
    show fallback content while data is being fetched.
  prefs: []
  type: TYPE_NORMAL
- en: At least, that’s the theory. But as it turns out, you can’t use it with all
    components and data fetching strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Suspense Does Not Work with useEffect()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since fetching data via `useEffect()` is a common strategy, you might be inclined
    to use `Suspense` in conjunction with this Hook to show some fallback content
    while data is being loaded via the effect function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following `BlogPosts` components uses `useEffect()` to load
    and display some blog posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You could wrap this component with `Suspense` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this will not work in the intended way, though. Instead of displaying
    the fallback content, nothing will be rendered while the data is being fetched.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this behavior is that `Suspense` is intended to suspend when
    fetching data during the component rendering process—not when fetching inside
    of some effect function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It helps to recall how `useEffect()` works (from *Chapter 8* , *Handling Side
    Effects* ): the effect function is executed after the component function is executed,
    i.e., after the first component render cycle is done.'
  prefs: []
  type: TYPE_NORMAL
- en: As a result, you can’t use `Suspense` to show fallback content when fetching
    data via `useEffect()` . Instead, in those cases, you need to manually manage
    and use some loading state in the component that performs the data fetching (i.e.,
    by manually managing different state slices like `isLoading` —for example, as
    explained and shown in *Chapter 11* , *Working with Complex State* , in the *Limitations
    of useState()* and *Managing State with useReducer()* sections.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Data while Rendering—the Incorrect Way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since `Suspense` intends to show fallback content while a component is fetching
    data during its rendering process, you could try to re-write the `BlogPosts` component
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But trying to use this code will yield an error in the browser developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A close-up of a message  Description automatically generated](img/B31339_17_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.3: React complains about async components on the client side'
  prefs: []
  type: TYPE_NORMAL
- en: React does not support the usage of `async/await` in client components. Only
    React Server Components may use that syntax (and therefore return promises). Consequently,
    regular React projects, which are not set up to support RSCs, can’t use this solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you could come up with a (problematic) alternative solution like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: But this approach was already discarded in *Chapter 8* , *Handling Side Effects*
    , in the *What’s the Problem?* section—the code creates an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: So, fetching data as part of a component’s rendering process is really difficult
    when not working with RSCs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Suspense Support Is Tricky
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since `Suspense` requires data fetching to occur during the rendering process,
    which is difficult to set up manually, the React documentation ( [https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading](https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading)
    ) itself mentions that *“only Suspense-enabled data sources will activate the
    Suspense component,”* further stating that those data sources include:'
  prefs: []
  type: TYPE_NORMAL
- en: Data fetching with Suspense-enabled frameworks like Relay and Next.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy-loading components code with `lazy()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the value of a Promise with `use()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the same page, the official documentation highlights that *“Suspense-enabled
    data fetching without the use of an opinionated framework is not yet supported.”*
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation may change over time—and so may React. But even though the exact
    wording may differ at the point of time you’re reading this, the way of using
    `Suspense` , and the fact that it can’t be used without special libraries or features
    like `lazy()` , is highly unlikely to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter was written when React 19 was released. You can visit the official
    changelog of this book to find out whether anything significant has changed since
    then: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, unless you plan on building your own Suspense-enabled library, you
    either have to stick to using `Suspense` for code-splitting (via `lazy()` ), use
    a third-party framework or library that integrates with `Suspense` , or explore
    the usage of that `use()` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the `lazy()` function (and how to use it with `Suspense` ) was already
    covered in *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    , in the *Reducing Bundle Sizes via Code Splitting (Lazy Loading)* section. But
    what about the other two options: `Suspense` -enabled libraries and the `use()`
    Hook?'
  prefs: []
  type: TYPE_NORMAL
- en: Using Suspense for Data Fetching with Supporting Libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you learned in the *Using Suspense for Data Fetching with Next.js* section,
    you can use `Suspense` for data fetching when working with Next.js. But while
    Next.js is one of the most popular React frameworks that supports `Suspense` ,
    it’s not the only option you have.
  prefs: []
  type: TYPE_NORMAL
- en: For example, TanStack Query (formerly known as React Query) is another popular
    third-party library that unlocks `Suspense` for data fetching. This library, unlike
    Next.js, is not a library that aims to help with building full-stack React apps
    or running code on the server side, though. Instead, TanStack Query is a library
    that’s all about helping with client-side data fetching, data mutations, and asynchronous
    state management. Since it runs on the client side, it therefore works in React
    projects that do not integrate with SSR and RSCs, too—although you can also use
    it in such projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'TanStack Query is a complex, feature-rich library—we could probably write an
    entire book about it. But the following short code snippet (which is from a Vite-based
    project, not from a Next.js project) shows how you may fetch data with the help
    of that library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `BlogPosts` component uses TanStack Query’s `useSuspenseQuery()`
    Hook, in conjunction with a custom `fetchPosts()` function, to fetch data via
    an HTTP request. As the name of the Hook implies, it integrates with React’s `Suspense`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the `BlogPosts` component can then be wrapped with `Suspense`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can tell, `Suspense` is used in the same way it was used with `lazy()`
    or Next.js. So, its functionality and usage don’t change—if you’re wrapping it
    around a component that integrates with `Suspense` (like `BlogPost` does, via
    TanStack Query’s `useSuspenseQuery()` Hook), `Suspense` can be used to output
    some fallback content while some data fetching process is underway.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete example project on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/05-tanstack-query](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/05-tanstack-query)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is just a simple example. You can do more with TanStack Query,
    and there also are other libraries that can be used in conjunction with `Suspense`
    . It’s just important to understand that there are other options than Next.js.
    But it’s also crucial to keep in mind that not all code (and also not all libraries)
    will work with `Suspense` .
  prefs: []
  type: TYPE_NORMAL
- en: Besides using libraries that directly integrate with `Suspense` (like TanStack
    Query via its `useSuspenseQuery()` Hook), you can also use `Suspense` for data
    fetching with the help of React’s built-in `use()` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: use()ing Data while Rendering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `use()` Hook offered by React is not limited to accessing context values,
    as shown in *Chapter 11* , *Working with Complex State* —instead, it may also
    be used to read values from a promise.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, you can use the `use()` Hook during a component’s rendering process to
    extract and use the value of a promise. `use()` will automatically interact with
    any wrapping `Suspense` component and let it know about the current status of
    the data fetching process (i.e., if the promise has been resolved or not).
  prefs: []
  type: TYPE_NORMAL
- en: 'The example from the *Fetching Data while Rendering—the Incorrect Way* section
    can therefore be adjusted to use the `use()` Hook like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `BlogPosts` component is now no longer a component that uses `async/await`
    . Instead, it uses the imported `use()` Hook to read the value of the promise
    produced by calling `fetchPosts()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, `use()` interacts with `Suspense` , hence `BlogPosts` can be
    wrapped with `Suspense` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this code, it might work as intended (depending on the React version
    you’re using), but it’s more likely to not yield any results or even show an error
    message in the browser developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A close-up of a computer error  Description automatically generated](img/B31339_17_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.4: The use() Hook only works with promises created by Suspense-compatible
    libraries'
  prefs: []
  type: TYPE_NORMAL
- en: As explained by this error message, the `use()` Hook is not intended to be used
    with regular promises as created in the previous example. Instead, it should be
    used on promises that are provided by *Suspense-compatible* libraries or frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to go against the official recommendation and try to build promises
    that support `use()` and `Suspense` , you can explore the official `Suspense`
    demo projects linked in the official React documentation ( [https://19.react.dev/reference/react/Suspense](https://19.react.dev/reference/react/Suspense)
    )—for example, this project: [https://codesandbox.io/p/sandbox/strange-black-6j7nnj](https://codesandbox.io/p/sandbox/strange-black-6j7nnj)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, as mentioned in the documentation, the approach used in that
    demo project uses unstable APIs and may not work with future React versions.
  prefs: []
  type: TYPE_NORMAL
- en: So, again, support from a third-party framework or library is needed. No matter
    if you try to use `Suspense` with components that fetch data as part of the rendering
    process with or without `use()` , you end up needing help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put in other words: to take advantage of `Suspense` , you either need to directly
    fetch data via a Suspense-compatible library or framework, or you need to use
    the `use()` Hook on a promise that’s generated by a Suspense-compatible library
    or framework.'
  prefs: []
  type: TYPE_NORMAL
- en: One such framework is, again, Next.js. Besides using `Suspense` around RSCs,
    as shown in the section *Using suspense for Data Fetching with Next.js* , you
    can also use `Suspense` in conjunction with the `use()` Hook on promises produced
    by Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: Using use() with Promises Created by Next.js
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next.js projects are able to create promises that will work with `use()` and
    `Suspense` . To be precise, any promise you create in an RSC and pass to a (client)
    component via props qualifies as a `use()` able promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, a promise is created by calling `fetchGoals()` and stored
    in a constant called `fetchGoalsPromise` . The created promise ( `fetchGoalsPromise`
    ) is then passed as a value for the `promise` prop to the `UserGoals` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with another component, this `UserGoals` component is defined in the
    `UserGoals.js` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, the `UserGoals` component uses `Suspense` to wrap the
    `Goals` component to which it essentially forwards the received `promise` prop
    value (via the `fetchGoalsPromise` prop). The `Goals` component then reads that
    promise value via the `use()` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Since the promise is created in an RSC ( `GoalsPage` ) that’s managed by Next.js,
    React will not complain about this code—Next.js creates promises that work with
    `use()` . Instead, it will show the fallback content ( `<p id="fallback">Fetching
    user goals...</p>` ) while data is being fetched and renders the final user interface
    once the data has arrived and has been streamed to the client.
  prefs: []
  type: TYPE_NORMAL
- en: As explained before, any elements not wrapped by Suspense (i.e., the `<h1>`
    element, in this example) will be displayed right from the start.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screen shot of a computer screen  Description automatically generated](img/B31339_17_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.5: The fallback text is shown next to the title while data is fetched
    via use()'
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth noting that both `UserGoals` and `Goals` are RSCs, too—nonetheless,
    they can use the `use()` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, Hooks can’t be used in RSCs but the `use()` Hook is special. Just
    as it may be used inside `if` statements or loops (as explained in *Chapter 11*
    , *Working with Complex State* ), it can be executed in both server and client
    components.
  prefs: []
  type: TYPE_NORMAL
- en: However, when working with a server component, you can also simply use `async/await`
    instead of `use()` . Thus, the `use()` Hook is really only useful when it comes
    to reading promise values in client components—there, `async/await` is not available.
  prefs: []
  type: TYPE_NORMAL
- en: Using use() in Client Components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides using it for accessing context, the `use()` Hook was introduced to help
    with reading values from promises in client components—i.e., in situations where
    you can’t use `async/await` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this updated *user goals* example, where some state is managed and
    a side effect is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Goals` component uses `useState()` to manage the information
    of which goal was marked as the main goal by the user. Furthermore, the `UserGoals`
    component (which uses `Suspense` ) utilizes the `useEffect()` Hook to send an
    analytics event once the component renders (i.e., before the suspended `Goals`
    component is displayed). Due to the usage of all these client-side exclusive features,
    the `'` `use client'` directive is required.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, `async/await` can’t be used in the `Goals` and `UserGoals` components.
    But since the `use()` Hook can be used in client components, it offers a possible
    solution for situations like this. And, since this example is from a Next.js application,
    React will not complain about the kind of promise being consumed by `use()` .
    Instead, this example code would lead to the fallback content being displayed
    while the goals data is fetched.
  prefs: []
  type: TYPE_NORMAL
- en: Suspense Usage Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have learned, the `Suspense` component can be wrapped around components
    that fetch data as part of their rendering process—as long as they do it in a
    compliant way.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in many projects, you may have multiple components that fetch data
    and that should display some fallback content while doing so. Thankfully, you
    can use the `Suspense` component as often as needed—you can even combine multiple
    `Suspense` components with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Revealing Content Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far, in all examples, `Suspense` was always wrapped around exactly one
    component. But there is no rule that would stop you from wrapping `Suspense` around
    multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, data fetching in the `DailyDeal` and `Products` components
    starts simultaneously. Since both components are wrapped by one single `Suspense`
    component, the fallback content is displayed unti both components are done fetching
    data. So, if one component (e.g., `DailyDeal` ) is done after one second, and
    the other component ( `Products` ) takes five seconds, both components are only
    revealed (and replace the fallback content) after five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_17_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.6: Data is fetched in parallel, and fallback content is shown via
    Suspense until all components are done'
  prefs: []
  type: TYPE_NORMAL
- en: Revealing Content as Soon as Possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, there are situations where you might want to display fallback content
    for multiple components, but where you don’t want to wait for all components to
    finish fetching data before showing any fetched content.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such situations, you can use `Suspense` multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this adjusted code example, `DailyDeal` and `Products` are wrapped with two
    different instances of the `Suspense` component. Thus, each component’s content
    will be revealed once available, independent from the other component’s data fetching
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_17_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.7: Each component replaces its fallback content with the final content
    once it’s done fetching'
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Suspended Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides fetching in parallel, you can also create more complex loading sequences
    with nested `Suspense` components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, initially, the paragraph with the text `Fetching shop data` is
    displayed. Behind the scenes, data fetching in the `DailyDeal` and `Products`
    components starts.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `DailyDeal` component is done fetching data, its content is displayed.
    At the same time, below `DailyDeal` , the fallback of the nested `Suspense` block
    is rendered if the `Products` component is still fetching data.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once `Products` has received its data, the inner `Suspense` component’s
    fallback content is removed, and the `Products` component is rendered instead.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_17_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.8: Nested Suspense blocks lead to sequential data fetching and content
    revelation'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, as you can see, you can use `Suspense` multiple times. In addition,
    you can combine different `Suspense` components such that you can create exactly
    the loading sequence and user experience you need.
  prefs: []
  type: TYPE_NORMAL
- en: Should You Fetch Data via Suspense or useEffect()?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned throughout this chapter, you can use `Suspense` in conjunction
    with RSCs, `Suspense` -enabled libraries, or the `use()` Hook (which also requires
    supporting libraries) to fetch data and show some fallback content while data
    is being fetched.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, as covered in *Chapter 11* , *Working with Complex State* , you
    can also fetch data and manually show fallback content via `useEffect()` and `useState()`
    or `useReducer()` . In that case, you essentially manage the state that determines
    whether to show some loading fallback content on your own; with `Suspense` , React
    does that for you.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, it’s up to you which approach you prefer. Using `Suspense` can
    save you quite a bit of code since you don’t need to manage these different state
    slices manually. Combined with frameworks like Next.js or libraries like TanStack
    Query, data fetching can therefore become significantly easier than when doing
    it manually via `useEffect()` . In addition, `Suspense` integrates with RSCs and
    SSR and therefore can be used to fetch data on the server side—unlike `useEffect()`
    , which has no effect (no pun intended) on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you’re not using any library or framework that supports `Suspense`
    or `use()` -enabled promises, you don’t have much of a choice other than to fall
    back to `useEffect()` (and hence not use `Suspense` for data fetching). This may
    change with future React versions, since they might provide tools that help with
    building promises that work with `use()` . But for the time being, it’s basically
    a decision between using (the right) libraries and `Suspense` or no libraries
    and `useEffect()` .
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Suspense` component can be used to show fallback content while data is
    fetched, or code is downloaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For data fetching, `Suspense` only works with components that fetch data via
    Suspense-enabled data sources during their rendering process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries and frameworks like TanStack Query and Next.js support using `Suspense`
    for data fetching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Next.js, you can wrap `Suspense` around server components that use `async/await`
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, `Suspense` can be wrapped around components that use React’s
    `use()` Hook for reading a promise value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use()` should only be used to read values of promises that resolve with `Suspense`
    in mind—e.g., promises created by Suspense-compatible third-party libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using Next.js, promises created in RSCs and passed to (client) components
    via props may be consumed via `use()` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `use()` Hook helps with reading values and using `Suspense` in components
    that also need to use client-specific features like `useState()` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Suspense` can be wrapped around as many components as needed to fetch data
    and display content simultaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Suspense` can also be nested to create complex loading sequences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React’s `Suspense` feature can be very useful since it helps with granularly
    showing fallback content while code or data is being fetched. At the same time,
    when it comes to data fetching, it can be tricky to use `Suspense` since it only
    works with components that fetch data in the correct way (e.g., via the `use()`
    Hook, if the promise passed to the Hook is `Suspense` -compatible).
  prefs: []
  type: TYPE_NORMAL
- en: That’s why this chapter also explored how to use `Suspense` and `use()` with
    Next.js, and how that framework simplifies the process of fetching data and showing
    fallback content with `Suspense` and `use()` .
  prefs: []
  type: TYPE_NORMAL
- en: Despite the potential complexity, `Suspense` can help with creating great user
    experiences since it allows you to easily show fallback content while a resource
    is pending.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also concludes the list of core React features you must know about
    as a React developer. Of course, you can always dive deeper to explore more patterns
    and third-party libraries. The next (and last) chapter will share some resources
    and possible next steps you could dive into after finishing this book.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to examples that can be
    found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/17-suspense-use/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/17-suspense-use/exercises/questions-answers.md)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the purpose of React’s `Suspense` component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do components need to fetch data in order to work with `Suspense` ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How may `Suspense` be used when working with Next.js?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the purpose of the `use()` Hook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which kind of promises can be read by the `use()` Hook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List three ways of using `Suspense` with multiple components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the newly gained knowledge about Next.js, it’s time to apply it to
    a real demo project.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you’ll find an activity that allows you to practice
    working with Next.js and `Suspense` . As always, you will also need to employ
    some of the concepts covered in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 17.1: Implement Suspense in the Mini Blog'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, your job is to build upon the finished project from *Activity
    16.1* . There, a very simple blog was built. Now, your task is to enhance this
    blog to show some fallback content while the list of blog posts or the details
    for an individual blog post are loading. To prove your knowledge, you should fetch
    data via `async/await` on the starting page ( `/` ), and via the `use()` Hook
    on the `blog/<some-id>` page.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the list of available blog posts should also be displayed below
    the details for a single blog post. Of course, while fetching that list data,
    some fallback text must be displayed—though, that text should be displayed independently
    from the fallback content for the blog post details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a starting project snapshot for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    , in this case) to use the right code snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: In the provided starting project, you’ll find functions for fetching all blog
    posts and a single post. These functions contain artificial delays to simulate
    slow servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading the code and running `npm install` in the project folder
    to install all required dependencies, the solution steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Outsource the logic for fetching and displaying a list of posts into a separate
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use that component on the starting page and use React’s `Suspense` component
    to display some fitting fallback content while the blog posts are being fetched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, outsource the logic for retrieving and rendering the details for a single
    blog post into a separate client (!) component. Output that newly created component
    on the `/blog/<some-id>` page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass a promise for fetching the details of a blog to that newly created component,
    and use the `use()` Hook to read its value. Also, take advantage of the `Suspense`
    component to output some fallback content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-use the component that fetches and renders a list of blog posts and output
    it below the blog post details on the `/blog/<some-id>` page. Use `Suspense` to
    show some fallback content, independently from the data fetching status of the
    blog post details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final page should look as shown in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_17_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.9: Fallback content is shown while the blog posts are fetched'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_17_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.10: Fallback content is shown while fetching blog post details and
    the list of blog posts'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the full code for this activity, and an example solution, here:
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1)
    .'
  prefs: []
  type: TYPE_NORMAL
