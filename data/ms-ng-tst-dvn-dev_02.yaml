- en: <st c="0">2</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">2</st>
- en: <st c="2">Using Jasmine and Karma to Test Angular Applications</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">使用茉莉和卡玛测试Angular应用程序</st>
- en: <st c="54">Jasmine</st> <st c="62">and Karma</st> <st c="72">are two powerful
    tools that developers can use to test their Angular applications.</st> <st c="156">Testing
    is an essential part of the development process as it helps ensure that the application
    works as expected and avoids any potential bugs</st> <st c="300">or issues.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54">茉莉</st> <st c="62">和</st> <st c="72">卡玛</st> <st c="72">是开发者可以用来测试他们的Angular应用程序的两个强大工具。</st>
    <st c="156">测试是开发过程中的一个重要部分，因为它有助于确保应用程序按预期工作，并避免任何潜在的错误</st> <st c="300">或问题。</st>
- en: <st c="310">Jasmine is a</st> **<st c="324">behavior-driven development</st>**
    <st c="351">(</st>**<st c="353">BDD</st>**<st c="356">) framework</st> <st c="368">for
    testing JavaScript code.</st> <st c="398">It provides a simple and readable syntax
    for writing tests, making it easier to understand and maintain the code.</st>
    <st c="512">With Jasmine, developers can define test suites and test cases, and
    then use various matchers to check the expected behavior of</st> <st c="640">their
    code.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="310">茉莉是一个</st> **<st c="324">行为驱动开发</st>** <st c="351">(</st>**<st c="353">BDD</st>**<st
    c="356">) 框架</st> <st c="368">用于测试JavaScript代码。</st> <st c="398">它提供了一个简单易读的语法来编写测试，使得代码更容易理解和维护。</st>
    <st c="512">使用茉莉，开发者可以定义测试套件和测试用例，然后使用各种匹配器来检查代码的预期行为。</st>
- en: <st c="651">Karma, on the other hand, is a test runner that allows developers
    to execute their tests in multiple browsers and environments.</st> <st c="780">It
    provides a seamless integration with Jasmine, allowing developers to easily run
    their Jasmine tests in different browsers and get real-time feedback on the test
    results.</st> <st c="953">Karma also offers additional features, such as code
    coverage reporting and continuous</st> <st c="1039">integration support.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="651">另一方面，卡玛是一个允许开发者在其多个浏览器和环境中执行测试的测试运行器。</st> <st c="780">它提供了与茉莉的无缝集成，使得开发者可以轻松地在不同的浏览器中运行茉莉测试，并获得测试结果的实时反馈。</st>
    <st c="953">卡玛还提供了一些额外的功能，例如代码覆盖率报告和持续</st> <st c="1039">集成支持。</st>
- en: <st c="1059">Using Jasmine and Karma together can greatly enhance the testing
    process for Angular applications.</st> <st c="1159">Developers can write comprehensive
    test suites using Jasmine’s expressive syntax, and then use Karma to run these
    tests in various browsers, ensuring compatibility across different environments.</st>
    <st c="1354">This helps catch any potential issues or bugs early on and promotes
    a more robust and</st> <st c="1440">reliable application.</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1059">将茉莉和卡玛结合使用可以极大地增强Angular应用程序的测试过程。</st> <st c="1159">开发者可以使用茉莉的表达式语法编写全面的测试套件，然后使用卡玛在不同的浏览器中运行这些测试，确保跨不同环境的兼容性。</st>
    <st c="1354">这有助于在早期捕捉任何潜在的问题或错误，并促进更健壮和</st> <st c="1440">可靠的应用程序。</st>
- en: <st c="1461">In this chapter, we will look into the basics of using Jasmine
    and Karma for testing Angular applications.</st> <st c="1569">We will learn how
    to set up the testing environment, write unit tests with Jasmine, and configure
    Karma to run the tests in</st> <st c="1693">different browsers.</st>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1461">在本章中，我们将探讨使用茉莉和卡玛测试Angular应用程序的基础知识。</st> <st c="1569">我们将学习如何设置测试环境，使用茉莉编写单元测试，并配置卡玛在不同的浏览器中运行测试。</st>
- en: <st c="1712">The following topics will be covered in</st> <st c="1753">this
    chapter:</st>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1712">本章将涵盖以下主题：</st>
- en: <st c="1766">Mastering Jasmine’s unit</st> <st c="1792">testing techniques</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1766">掌握茉莉的单元</st> <st c="1792">测试技术</st>
- en: <st c="1810">Writing your</st> <st c="1824">first unit tests in Angular related
    to</st> **<st c="1863">test-driven</st>** **<st c="1875">development</st>** <st
    c="1886">(</st>**<st c="1888">TDD</st>**<st c="1891">)</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1810">编写你的</st> <st c="1824">第一个与Angular相关的单元测试，关于</st> **<st c="1863">测试驱动开发</st>**
    **<st c="1875">（TDD）</st>** <st c="1886">(</st>**<st c="1888">TDD</st>**<st c="1891">)</st>
- en: <st c="1893">Utilizing code coverage and test result analysis</st> <st c="1942">with
    Karma</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1893">利用卡玛的代码覆盖率和测试结果分析</st>
- en: <st c="1952">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1952">技术要求</st>
- en: <st c="1975">To follow along with the examples and exercises in this chapter,
    you will need to have a basic understanding of Angular and TypeScript, as well
    as the following</st> <st c="2137">technical requirements:</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1975">为了跟随本章中的示例和练习，你需要对Angular和TypeScript有一个基本的了解，以及以下</st> <st c="2137">技术要求：</st>
- en: <st c="2160">Node.js LTS and npm LTS installed on</st> <st c="2198">your computer</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2160">在您的计算机上安装了 Node.js LTS 和 npm LTS</st>
- en: <st c="2211">Angular 17 or later CLI</st> <st c="2236">installed globally</st>
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2211">安装了 Angular 17 或更高版本的 CLI</st> <st c="2236">全局</st>
- en: <st c="2254">A code editor, such as Visual Studio Code, installed on</st> <st
    c="2311">your computer</st>
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2254">在</st> <st c="2311">您的计算机上安装了代码编辑器，例如 Visual Studio Code</st>
- en: <st c="2324">The code files of this chapter can be found</st> <st c="2369">at</st>
    [<st c="2372">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%202</st>](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%202)<st
    c="2470">.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2324">本章的代码文件可以在</st> <st c="2369">以下位置找到</st> [<st c="2372">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%202</st>](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%202)<st
    c="2470">。</st>
- en: <st c="2471">Mastering Jasmine’s unit testing techniques</st>
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2471">掌握 Jasmine 的单元测试技术</st>
- en: <st c="2515">In this section, we’ll explore the Jasmine framework by writing
    descriptive test suites, utilizing matchers, using spies for function testing,
    and testing asynchronous code.</st> <st c="2690">By leveraging these techniques,
    you can ensure the quality and reliability of your</st> <st c="2773">code base.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2515">在本节中，我们将通过编写描述性测试套件、使用匹配器、使用间谍进行函数测试以及测试异步代码来探索 Jasmine 框架。</st>
    <st c="2690">通过利用这些技术，您可以确保代码库的质量和可靠性。</st> <st c="2773">。</st>
- en: <st c="2783">What is Jasmine?</st>
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="2783">什么是 Jasmine？</st>
- en: <st c="2800">Jasmine</st> <st c="2808">is a widely used testing framework for
    JavaScript that’s commonly employed for writing tests for web applications and
    Node.js projects.</st> <st c="2945">With its clean and expressive syntax, Jasmine
    allows developers to create easy-to-understand and maintainable test suites and
    cases.</st> <st c="3078">It offers built-in functionalities for assertions, test
    spies, and asynchronous testing.</st> <st c="3167">Jasmine seamlessly integrates
    with numerous libraries and frameworks, including AngularJS and React, enabling
    developers to compose comprehensive and dependable tests for JavaScript applications.</st>
    <st c="3363">Its popularity stems from its simplicity, flexibility, and ability
    to facilitate the creation of robust and reliable tests for</st> <st c="3490">JavaScript
    code.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2800">Jasmine</st> <st c="2808">是一个广泛使用的 JavaScript 测试框架，通常用于编写 Web 应用程序和
    Node.js 项目的测试。</st> <st c="2945">凭借其简洁和表达性强的语法，Jasmine 允许开发者创建易于理解和维护的测试套件和案例。</st>
    <st c="3078">它提供了断言、测试间谍和异步测试的内置功能。</st> <st c="3167">Jasmine 与众多库和框架无缝集成，包括 AngularJS
    和 React，使开发者能够编写全面可靠的 JavaScript 应用程序的测试。</st> <st c="3363">其流行源于其简单性、灵活性和促进创建健壮可靠
    JavaScript 代码测试的能力。</st>
- en: <st c="3506">With Jasmine, developers can structure their tests using a BDD
    style, making it easy to write tests that are both descriptive and readable.</st>
    <st c="3647">It provides a set of built-in functions for assertions, which allow
    developers to verify the expected behavior of their code.</st> <st c="3773">These
    assertions cover a wide range of scenarios and make it simple to write tests that
    validate the correctness of the code</st> <st c="3898">being tested.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jasmine，开发者可以使用 BDD 风格来结构化他们的测试，这使得编写既描述性强又易于阅读的测试变得简单。<st c="3647">它提供了一套内置的断言函数，允许开发者验证他们代码的预期行为。</st>
    <st c="3773">这些断言涵盖了广泛的情况，使得编写验证被测试代码正确性的测试变得简单</st> <st c="3898">。</st>
- en: <st c="3911">Jasmine also includes features such as test spies, which enable
    developers to track function calls and arguments, as well as</st> <st c="4036">mock
    and stub function behavior.</st> <st c="4070">This helps in testing code that
    interacts with other components or</st> <st c="4137">external dependencies.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3911">Jasmine 还包括测试间谍等特性，这使开发者能够跟踪函数调用和参数，以及</st> <st c="4036">模拟和存根函数行为。</st>
    <st c="4070">这有助于测试与其它组件或</st> <st c="4137">外部依赖项交互的代码。</st>
- en: <st c="4159">Furthermore, Jasmine supports asynchronous testing, making it easy
    to write tests for code that involves asynchronous operations such as AJAX requests
    or timers.</st> <st c="4322">It provides mechanisms to handle asynchronous tasks
    and ensure that tests wait for completion before</st> <st c="4423">making assertions.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4159">此外，Jasmine 支持异步测试，这使得编写涉及异步操作（如 AJAX 请求或定时器）的代码的测试变得简单。</st> <st
    c="4322">它提供了处理异步任务和确保测试在断言之前等待完成的机制。</st>
- en: <st c="4441">Jasmine is highly extensible and can be used in conjunction with
    various libraries and frameworks, such as AngularJS, Angular, and React.</st>
    <st c="4580">It integrates seamlessly with these ecosystems, allowing developers
    to write comprehensive and reliable tests for their</st> <st c="4700">JavaScript
    applications.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4441">Jasmine 具有高度的扩展性，可以与各种库和框架一起使用，例如 AngularJS、Angular 和 React。</st>
    <st c="4580">它与这些生态系统无缝集成，允许开发者为其</st> <st c="4700">JavaScript 应用程序编写全面且可靠的测试。</st>
- en: <st c="4724">Overall, Jasmine’s simplicity, flexibility, and</st> <st c="4773">comprehensive
    feature set have contributed to its popularity as a testing framework for JavaScript.</st>
    <st c="4873">It empowers developers to write robust and reliable tests, ultimately
    leading to higher-quality code and more</st> <st c="4983">confident deployments.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4724">总的来说，Jasmine 的简洁性、灵活性以及</st> <st c="4773">全面的功能集为其成为 JavaScript
    测试框架的流行做出了贡献。</st> <st c="4873">它使开发者能够编写健壮且可靠的测试，最终导致代码质量更高和部署更加</st> <st c="4983">自信。</st>
- en: <st c="5005">Writing descriptive test suites</st>
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5005">编写描述性的测试套件</st>
- en: <st c="5037">One of the fundamental principles of effective unit testing is
    writing descriptive test suites.</st> <st c="5134">By logically organizing your
    tests and using descriptive names, you make it easier for yourself and other developers
    to understand the purpose and behavior of each test.</st> <st c="5304">In this
    section, we will explore strategies for creating meaningful test suite names and
    describing the expected behavior in clear and concise language.</st> <st c="5457">Additionally,
    we will discuss how descriptive test suites can serve as documentation for</st>
    <st c="5546">future reference.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5037">有效单元测试的一个基本原则是编写描述性测试套件。</st> <st c="5134">通过逻辑组织您的测试并使用描述性名称，您使自己和其他开发者更容易理解每个测试的目的和行为。</st>
    <st c="5304">在本节中，我们将探讨创建有意义的测试套件名称和在清晰简洁的语言中描述预期行为的策略。</st> <st c="5457">此外，我们还将讨论描述性测试套件如何作为未来参考的文档。</st>
- en: <st c="5563">A descriptive test suite is</st> <st c="5592">a collection of related
    test cases that focuses on a specific functionality or component of your code.</st>
    <st c="5695">It serves as a documentation tool and helps developers understand
    the purpose and behavior of each test.</st> <st c="5800">Descriptive test suites
    are essential for maintaining code quality, facilitating collaboration among team
    members, and ensuring that tests remain relevant and up-to-date over time.</st>
    <st c="5981">By investing time in creating descriptive test suites, you can improve
    the maintainability and readability of your</st> <st c="6096">test code.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5563">描述性测试套件是一组</st> <st c="5592">相关的测试用例，专注于代码的特定功能或组件。</st> <st c="5695">它作为文档工具，帮助开发者理解每个测试的目的和行为。</st>
    <st c="5800">描述性测试套件对于维护代码质量、促进团队成员之间的协作以及确保测试随着时间的推移保持相关性和更新至关重要。</st> <st c="5981">通过在创建描述性测试套件上投入时间，您可以提高测试代码的可维护性和可读性。</st>
- en: <st c="6106">Let’s consider a simple scenario where we have a JavaScript function
    called</st> `<st c="6183">calculateTotal</st>` <st c="6197">that calculates the
    total price of items in a shopping cart.</st> <st c="6259">We want to write a
    test to ensure that the function returns the correct total when given a set of
    items with their</st> <st c="6374">respective prices.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6106">让我们考虑一个简单的场景，其中我们有一个名为</st> `<st c="6183">calculateTotal</st>`
    <st c="6197">的 JavaScript 函数，该函数计算购物车中商品的总价。</st> <st c="6259">我们想要编写一个测试来确保当给定的商品及其</st>
    <st c="6374">相应价格集合时，该函数返回正确的总价。</st>
- en: <st c="6392">Choosing meaningful names</st>
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="6392">选择有意义的名称</st>
- en: <st c="6418">The first step in creating</st> <st c="6445">descriptive test suites
    is choosing meaningful names for your test suites and test cases.</st> <st c="6536">Use
    clear and concise language to describe the functionality or behavior being tested.</st>
    <st c="6623">Avoid ambiguous or generic names that don’t provide enough context.</st>
    <st c="6691">For example, instead of naming a test suite “Test Suite 1,” consider
    naming it “User Authentication Tests” to convey the purpose of the tests.</st>
    <st c="6834">Meaningful names make it easier for developers to locate specific
    tests and understand their purpose, even when revisiting the code base after a</st>
    <st c="6979">long time.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6418">创建描述性测试套件的第一步是为您的测试套件和测试用例选择有意义的名称。</st> <st c="6445">使用清晰简洁的语言来描述正在测试的功能或行为。</st>
    <st c="6536">避免使用模糊或通用的名称，这些名称不足以提供足够的上下文。</st> <st c="6623">例如，不要将测试套件命名为“测试套件1”，考虑将其命名为“用户身份验证测试”以传达测试的目的。</st>
    <st c="6691">有意义的名称使开发者更容易定位特定的测试并理解其目的，即使在长时间后重新访问代码库时也是如此。</st>
- en: <st c="6989">Structuring test suites</st>
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="6989">结构化测试套件</st>
- en: <st c="7013">Organizing your</st> <st c="7029">test suites in a logical and
    hierarchical structure is crucial for creating descriptive test suites in Jasmine.</st>
    <st c="7142">A well-structured test suite mirrors the structure of your code base,
    making it easier to locate and understand specific tests.</st> <st c="7270">Group
    related tests together to improve readability and maintainability.</st> <st c="7343">For
    example, if you are testing a user authentication module, create a test suite
    specifically for login functionality and another for registration.</st> <st c="7492">This
    separation helps you isolate and focus on specific features, making it easier
    to identify and resolve issues.</st> <st c="7607">Additionally, consider using
    nested describe blocks to further organize your tests hierarchically.</st> <st
    c="7706">Here’s</st> <st c="7713">an example:</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7013">在Jasmine中创建描述性测试套件时，以逻辑和层次结构组织您的测试套件至关重要。</st> <st c="7029">一个结构良好的测试套件反映了您的代码库的结构，这使得定位和理解特定的测试变得更容易。</st>
    <st c="7142">将相关的测试组合在一起以提高可读性和可维护性。</st> <st c="7270">例如，如果您正在测试用户身份验证模块，为登录功能创建一个特定的测试套件，并为注册创建另一个。</st>
    <st c="7343">这种分离有助于您隔离并专注于特定的功能，使您更容易识别和解决问题。</st> <st c="7492">此外，考虑使用嵌套的describe块来进一步组织您的测试层次结构。</st>
    <st c="7607">以下是一个示例：</st> <st c="7713">示例：</st>
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="7898">Writing clear and concise test descriptions</st>
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="7898">编写清晰简洁的测试描述</st>
- en: <st c="7942">Within each test</st> <st c="7960">case, write clear and concise
    descriptions that accurately describe the expected behavior.</st> <st c="8051">Use
    language that is easily understandable and avoids technical jargon whenever possible.</st>
    <st c="8141">A well-written test description should provide enough information
    for you and others to understand the purpose of the test without needing to dive
    into the implementation details.</st> <st c="8321">Consider using the “should”
    format to describe the expected behavior – for example, “should correctly calculate
    the total for a cart with multiple items.” By using descriptive language, future
    developers can quickly grasp the intent of the test and identify any deviations
    from the</st> <st c="8603">expected behavior.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7942">在每个测试用例中，编写清晰简洁的描述，准确描述预期的行为。</st> <st c="7960">尽可能使用易于理解的语言，并避免使用技术术语。</st>
    <st c="8051">良好的测试描述应提供足够的信息，让您和其他人无需深入了解实现细节就能理解测试的目的。</st> <st c="8141">考虑使用“应该”格式来描述预期的行为——例如，“应该正确计算包含多个项目的购物车的总额。”通过使用描述性语言，未来的开发者可以快速理解测试的意图并识别任何与预期行为的偏差。</st>
- en: <st c="8621">In addition to the test description, it is also helpful to include
    comments within the test code to provide further clarification or context where
    needed.</st> <st c="8777">These comments can explain the reasoning behind certain
    assertions or provide additional information about the test scenario.</st> <st
    c="8903">However, it is important to strike a balance and avoid excessive commenting
    that may clutter the</st> <st c="9000">test code.</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8621">除了测试描述外，在测试代码中包含注释也有助于提供进一步的澄清或上下文，当需要时。</st> <st c="8777">这些注释可以解释某些断言背后的推理或提供有关测试场景的额外信息。</st>
    <st c="8903">然而，重要的是要找到平衡，避免过度注释，这可能会使测试代码变得杂乱。</st>
- en: <st c="9010">Maintaining and updating descriptive test suites</st>
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="9010">维护和更新描述性测试套件</st>
- en: <st c="9059">Descriptive</st> <st c="9071">test suites are not a one-time effort
    but require ongoing maintenance and updates as the code base evolves.</st> <st
    c="9180">It is essential to review and update test suites regularly to ensure
    they remain relevant and accurate.</st> <st c="9284">When making changes to the
    code, developers should also update the corresponding tests to reflect the updated
    behavior.</st> <st c="9404">Additionally, if a test case becomes obsolete or redundant,
    it should be removed</st> <st c="9485">or refactored.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性的测试套件不是一次性的努力，但随着代码库的演变，需要持续维护和更新。定期审查和更新测试套件对于确保它们保持相关性和准确性至关重要。当对代码进行更改时，开发者还应更新相应的测试以反映更新的行为。此外，如果测试用例变得过时或冗余，应将其删除或重构。
- en: <st c="9499">When up</st><st c="9507">dating</st> <st c="9515">test suites,
    it is crucial to keep their descriptive nature intact.</st> <st c="9583">If a
    test case needs significant changes, it may be beneficial to create a new test
    case with an appropriate description instead of modifying the existing one.</st>
    <st c="9743">This helps maintain the clarity and transparency of the</st> <st
    c="9799">test suite.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新测试套件时，保持其描述性至关重要。如果测试用例需要重大更改，可能最好创建一个新的测试用例，并附上适当的描述，而不是修改现有的一个。这有助于保持测试套件的清晰性和透明度。
- en: <st c="9810">Let’s</st> <st c="9817">consider a simple scenario where we have
    a JavaScript</st> <st c="9871">function called</st> `<st c="9887">calculateTotal</st>`
    <st c="9901">that calculates the total price of items in a shopping cart.</st>
    <st c="9963">We want to write a test to ensure that the function returns the correct
    total when given a set of items with their</st> <st c="10078">respective prices:</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的场景，其中我们有一个名为 `<st c="9887">calculateTotal</st>` 的 JavaScript 函数，该函数计算购物车中商品的总价。我们想要编写一个测试来确保当给定一组具有相应价格的物品时，该函数返回正确的总额：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="10795">In the</st> <st c="10802">preceding example, we have created a
    test suite for</st> <st c="10855">the</st> `<st c="10859">calculateTotal</st>`
    <st c="10873">function.</st> <st c="10884">Within the test suite, we have two
    test cases, and the descriptions of the test cases clearly state what behavior
    is</st> <st c="11001">being tested:</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们为 `<st c="10859">calculateTotal</st>` <st c="10873">函数</st> 创建了一个测试套件。在测试套件中，我们有两个测试用例，测试用例的描述清楚地说明了正在测试的行为：
- en: <st c="11014">The first test case,</st> *<st c="11036">“should return 0 for
    an empty cart,”</st>* <st c="11072">verifies that the function correctly handles
    an empty shopping cart and returns a total</st> <st c="11161">of 0</st>
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个测试用例，*“对于空购物车应返回 0”，* <st c="11036">验证了函数正确处理空购物车并返回总额为 0</st>
- en: <st c="11165">The second test case,</st> *<st c="11188">“should correctly calculate
    the total for a cart with multiple items,”</st>* <st c="11258">tests the function
    with a cart containing multiple items and checks if the calculated total is</st>
    <st c="11354">as expected</st>
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个测试用例，*“应正确计算包含多个商品的购物车的总额”，* <st c="11258">测试了包含多个商品的购物车，并检查计算出的总额是否符合预期</st>
- en: <st c="11365">By providing descriptive test case descriptions, other developers
    can easily understand the intent and behavior of each test.</st> <st c="11492">These
    descriptions act as documentation, making it easier to maintain and update the
    tests as the code</st> <st c="11595">base evolves.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供描述性的测试用例描述，其他开发者可以轻松理解每个测试的意图和行为。这些描述充当文档，使得在代码库演变时更容易维护和更新测试。
- en: <st c="11608">In the next section, we’ll look at how to write our first unit
    tests using</st> <st c="11684">TDD principles.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用 TDD 原则编写我们的第一个单元测试。
- en: <st c="11699">Writing your first unit tests in an Angular project</st>
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 项目中编写第一个单元测试
- en: <st c="11751">Unit testing</st> <st c="11764">is a critical aspect of Angular
    development that ensures code quality, reliability, and maintainability.</st>
    <st c="11870">TDD is</st> <st c="11877">a software development approach that emphasizes
    writing tests before implementing the actual code.</st> <st c="11976">In this
    section, you’ll learn how to write your first unit tests in an Angular project
    while following the principles of TDD.</st> <st c="12102">By leveraging the Jasmine
    testing framework and Angular’s testing utilities, developers can create effective
    and robust unit tests that verify the correctness of</st> <st c="12264">their
    code.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11751">单元测试</st> <st c="11764">是Angular开发的关键方面，它确保了代码质量、可靠性和可维护性。</st>
    <st c="11870">TDD（测试驱动开发）</st> <st c="11877">是一种软件开发方法，强调在实际代码实现之前编写测试。</st> <st
    c="11976">在本节中，您将学习如何在遵循TDD原则的同时，在Angular项目中编写您的第一个单元测试。</st> <st c="12102">通过利用Jasmine测试框架和Angular的测试工具，开发者可以创建有效且健壮的单元测试，以验证其代码的正确性。</st>
- en: <st c="12275">We’ll be</st> <st c="12285">using the project we created in</st>
    [*<st c="12317">Chapter 1</st>*](B21146_01.xhtml#_idTextAnchor018) <st c="12326">to
    practice.</st> <st c="12340">Follow these</st> <st c="12352">steps to write your
    first</st> <st c="12379">unit test:</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12275">我们将使用</st> <st c="12285">我们在</st> [*<st c="12317">第一章</st>*](B21146_01.xhtml#_idTextAnchor018)
    <st c="12326">创建的项目</st> <st c="12340">进行练习。</st> <st c="12352">按照以下</st> <st
    c="12379">步骤编写您的第一个</st> <st c="12352">单元测试：</st>
- en: <st c="12389">Create a new component called</st> `<st c="12420">CalculatorComponent</st>`
    <st c="12439">by running the</st> <st c="12455">following command:</st>
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12389">通过运行以下命令创建一个名为</st> `<st c="12420">CalculatorComponent</st> <st
    c="12439">的新组件：</st>
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: import { ComponentFixture, TestBed } from '@angular/core/testing';
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import { ComponentFixture, TestBed } from '@angular/core/testing';
- en: import { CalculatorComponent } from './calculator.component';
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import { CalculatorComponent } from './calculator.component';
- en: describe('CalculatorComponent', () => {
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: describe('CalculatorComponent', () => {
- en: 'let calculator: CalculatorComponent;'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'let calculator: CalculatorComponent;'
- en: 'let fixture: ComponentFixture<CalculatorComponent>;'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'let fixture: ComponentFixture<CalculatorComponent>;'
- en: beforeEach(async () => {
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: beforeEach(async () => {
- en: await TestBed.configureTestingModule({
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: await TestBed.configureTestingModule({
- en: 'declarations: [ CalculatorComponent ]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'declarations: [ CalculatorComponent ]'
- en: '})'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '})'
- en: .compileComponents();
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .compileComponents();
- en: fixture = TestBed.createComponent(CalculatorComponent);
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fixture = TestBed.createComponent(CalculatorComponent);
- en: calculator = fixture.componentInstance;
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: calculator = fixture.componentInstance;
- en: fixture.detectChanges();
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fixture.detectChanges();
- en: '});'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: it('should create', () => {
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: it('should create', () => {
- en: expect(calculator).toBeTruthy();
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: expect(calculator).toBeTruthy();
- en: '});'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: '});'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE3]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="14000">Now, we’ll</st> <st c="14012">write the actual test case using
    the</st> `<st c="14049">it</st>` <st c="14051">function.</st> <st c="14062">In</st>
    <st c="14065">this case, we’ll test the</st> `<st c="14091">add</st>` <st c="14094">method
    of</st> `<st c="14105">CalculatorComponent</st>` <st c="14124">by passing it two
    numbers and expecting the result to be</st> `<st c="14182">5</st>`<st c="14183">.
    The</st> `<st c="14189">expect</st>` <st c="14195">function is used to define
    the expected behavior and check the actual result.</st> <st c="14274">The following
    code must be added to the test suite – that is, inside the</st> `<st c="14347">describe</st>`
    <st c="14355">function:</st>
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14000">现在，我们将</st> <st c="14012">使用</st> `<st c="14049">it</st> <st c="14051">函数</st>`
    <st c="14062">编写实际的测试用例。</st> <st c="14065">在这种情况下，我们将通过传递两个数字来测试</st> `<st c="14091">add</st>
    <st c="14094">方法</st> <st c="14091">的</st> `<st c="14105">CalculatorComponent</st>`
    <st c="14124">，并期望结果为</st> `<st c="14182">5</st> <st c="14183">。`<st c="14189">expect</st>
    <st c="14195">函数用于定义期望的行为并检查实际结果。</st> <st c="14274">以下代码必须添加到测试套件中——即，在</st>
    `<st c="14347">describe</st> <st c="14355">函数</st>` <st c="14274">内部：</st>
- en: '[PRE4]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="14481">You will get an error in your code editor telling you that the</st>
    `<st c="14545">add</st>` <st c="14548">function</st> <st c="14558">doesn’t exist:</st>
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14481">您将在代码编辑器中遇到一个错误，提示您</st> `<st c="14545">add</st> <st c="14548">函数</st>
    <st c="14558">不存在：</st>
- en: '![Figure 2.1 – Code error](img/B21146_02_1.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 代码错误](img/B21146_02_1.jpg)'
- en: <st c="14684">Figure 2.1 – Code error</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14684">图2.1 – 代码错误</st>
- en: <st c="14707">This is normal as it hasn’t been</st> <st c="14741">created yet.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14707">这是正常的，因为它还没有被</st> <st c="14741">创建。</st>
- en: <st c="14753">Upon</st> <st c="14758">returning to our Karma server, we’ll see
    that</st> <st c="14804">our test case isn’t displayed in</st> `<st c="14838">CalculatorComponent</st>`
    <st c="14857">and that in the terminal, we have an error related to the non-existence
    of the function and a message indicating that no test</st> <st c="14984">has succeeded.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14753">当我们返回到 Karma 服务器时，我们会看到</st> <st c="14758">我们的测试用例没有显示在</st> `<st
    c="14838">CalculatorComponent</st>` <st c="14857">中，并且在终端中，我们有一个与函数不存在相关的错误，以及一条消息表明没有测试</st>
    <st c="14984">成功。</st>
- en: <st c="14998">Don’t panic – it’s the red of TDD!</st> <st c="15034">Well done!</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14998">别慌张 – 这是 TDD 的红色阶段！</st> <st c="15034">做得好！</st>
- en: <st c="15044">Next, we will implement the</st> `<st c="15073">add</st>` <st
    c="15076">function in</st> `<st c="15089">calculator.component.ts</st>`<st c="15112">.
    Having defined our first test case, we can proceed to implement</st> `<st c="15178">calculator.component.ts</st>`
    <st c="15201">for the test to pass.</st> <st c="15224">Following the TDD approach,
    write the minimum amount of code necessary to pass</st> <st c="15303">the tests:</st>
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="15044">接下来，我们将实现</st> `<st c="15073">add</st>` <st c="15076">函数，在</st>
    `<st c="15089">calculator.component.ts</st>`<st c="15112">中。定义了我们的第一个测试用例后，我们可以继续实现</st>
    `<st c="15178">calculator.component.ts</st>` <st c="15201">以使测试通过。</st> <st c="15224">遵循
    TDD 方法，编写通过测试所需的最少代码：</st>
- en: '[PRE5]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="15365">You’ll see the following result on your</st> <st c="15406">Karma
    server:</st>
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15365">你将在你的</st> <st c="15406">Karma 服务器上看到以下结果：</st>
- en: '![Figure 2.2 – The test succeeded](img/B21146_02_2.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 测试成功](img/B21146_02_2.jpg)'
- en: <st c="15665">Figure 2.2 – The test succeeded</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15665">图 2.2 – 测试成功</st>
- en: <st c="15696">In your terminal, you will receive the</st> <st c="15736">following
    message:</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15696">在你的终端中，你会收到以下消息：</st>
- en: '![Figure 2.3 – The test was executed successfully](img/B21146_02_3.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 测试执行成功](img/B21146_02_3.jpg)'
- en: <st c="15890">Figure 2.3 – The test was executed successfully</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15890">图 2.3 – 测试执行成功</st>
- en: <st c="15937">With that, we’re</st> <st c="15954">at the green stage of TDD
    and writing the</st> <st c="15997">minimum amount of code needed for our test
    to pass.</st> <st c="16049">Well done!</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15937">有了这些，我们就</st> <st c="15954">进入了 TDD 的绿色阶段，并编写了通过测试所需的最少代码。</st>
    <st c="15997">做得好！</st>
- en: <st c="16059">Once the tests have passed, you can refactor the code to improve
    its design, readability, and maintainability.</st> <st c="16171">Refactoring is
    an essential step in the TDD process as it helps eliminate duplication and improves
    code structure and overall quality.</st> <st c="16306">It is essential to ensure
    that tests continue to run after refactoring.</st> <st c="16378">Regularly reviewing
    and updating tests as the code base evolves will help maintain the integrity and
    reliability of</st> <st c="16494">unit tests.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16059">一旦测试通过，你可以重构代码以改进其设计、可读性和可维护性。</st> <st c="16171">重构是 TDD 过程中的关键步骤，因为它有助于消除重复并改进代码结构和整体质量。</st>
    <st c="16306">确保重构后测试仍然运行是至关重要的。</st> <st c="16378">随着代码库的发展，定期审查和更新测试将有助于维护单元测试的完整性和可靠性。</st>
- en: <st c="16505">In our example, we don’t need to refactor the test.</st> <st c="16558">Don’t
    worry – we’ll have the opportunity to do so in</st> [*<st c="16611">Chapter 3</st>*](B21146_03.xhtml#_idTextAnchor065)<st
    c="16620">.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16505">在我们的例子中，我们不需要重构测试。</st> <st c="16558">别担心 – 我们将在</st> [*<st c="16611">第
    3 章</st>*](B21146_03.xhtml#_idTextAnchor065)<st c="16620">有机会这样做。</st>
- en: <st c="16621">In the next section, we’ll look at how to use code coverage and
    test result analysis</st> <st c="16707">with Karma.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16621">在下一节中，我们将探讨如何使用 Karma 的代码覆盖率和测试结果分析</st> <st c="16707">。</st>
- en: <st c="16718">Utilizing code coverage and test result analysis with Karma</st>
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="16718">利用 Karma 的代码覆盖率和测试结果分析</st>
- en: <st c="16778">Code coverage</st> <st c="16793">and test result analysis</st>
    <st c="16817">are essential aspects of the software development process.</st>
    <st c="16877">By measuring code coverage, developers can assess the effectiveness
    of their unit tests and identify areas that require additional testing.</st> <st
    c="17017">Karma, a popular testing framework in the JavaScript ecosystem, provides
    built-in support for code coverage and test result analysis.</st> <st c="17151">In
    this section, we’ll learn how to leverage Karma to measure code coverage, generate
    detailed reports, and analyze test results.</st> <st c="17281">By utilizing these
    features, developers can ensure comprehensive testing and improve the overall
    quality and reliability of</st> <st c="17405">their code.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16778">代码覆盖率</st> <st c="16793">和测试结果分析</st> <st c="16817">是软件开发过程中的关键方面。</st>
    <st c="16877">通过测量代码覆盖率，开发者可以评估单元测试的有效性，并识别需要额外测试的区域。</st> <st c="17017">Karma是JavaScript生态系统中的一个流行测试框架，它提供了内置的代码覆盖率和测试结果分析支持。</st>
    <st c="17151">在本节中，我们将学习如何利用Karma来测量代码覆盖率，生成详细报告，并分析测试结果。</st> <st c="17281">通过利用这些功能，开发者可以确保全面测试，并提高代码的整体质量和可靠性。</st>
- en: <st c="17416">Before going any further, it’s worth noting that all the configurations
    we’ll be looking at are already present in our Angular project.</st> <st c="17553">When
    we create our project, Angular takes care of all</st> <st c="17607">the configuration.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17416">在进一步操作之前，值得注意的一点是，我们将要查看的所有配置已经存在于我们的Angular项目中。</st> <st c="17553">当我们创建项目时，Angular会负责所有</st>
    <st c="17607">配置。</st>
- en: <st c="17625">Here</st> <st c="17630">are</st> <st c="17634">the different</st>
    <st c="17648">steps</st> <st c="17655">Angular performs</st> <st c="17672">for
    us:</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17625">以下是</st> <st c="17630">Angular为我们执行的</st> <st c="17634">不同步骤：</st>
- en: '**<st c="17679">Step 1 – setting up Karma with</st>** **<st c="17711">code
    coverage</st>**<st c="17724">:</st>'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17679">步骤1 – 使用</st>** **<st c="17711">代码覆盖率</st>**<st c="17724">设置Karma：</st>'
- en: <st c="17726">To</st> <st c="17729">utilize code coverage</st> <st c="17751">with
    Karma, start by</st> <st c="17771">installing</st> <st c="17782">the</st> <st
    c="17787">necessary dependencies:</st>
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="17726">为了</st> <st c="17729">使用Karma进行代码覆盖率分析，首先</st> <st c="17771">安装</st>
    <st c="17782">必要的依赖项：</st>
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: module.exports = function(config) {
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: module.exports = function(config) {
- en: config.set({
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: config.set({
- en: '// ... reporters: [''progress'', ''coverage''],'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '// ... reporters: [''progress'', ''coverage''],'
- en: 'coverageReporter: {'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'coverageReporter: {'
- en: 'dir: ''coverage/'','
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'dir: ''coverage/'','
- en: 'reporters: ['
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'reporters: ['
- en: '{ type: ''html'', subdir: ''report-html'' },'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{ type: ''html'', subdir: ''report-html'' },'
- en: '{ type: ''lcov'', subdir: ''report-lcov'' }'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{ type: ''lcov'', subdir: ''report-lcov'' }'
- en: ']'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '},'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: // ... });
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ... });
- en: '};'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE7]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`<st c="18860">coverage</st>` <st c="18868">directory to view the generated
    reports.</st> <st c="18910">Open the HTML report (</st>`<st c="18932">coverage/report-html/index.html</st>`<st
    c="18964">) in a web browser to visualize the code coverage details.</st> <st
    c="19024">The report highlights covered lines, uncovered lines, and overall coverage
    percentages.</st> <st c="19112">Additionally, the LCOV report (</st>`<st c="19143">coverage/report-lcov/lcov-report/index.html</st>`<st
    c="19187">) provides a more detailed breakdown of</st> <st c="19228">code coverage.</st>'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="18860">代码覆盖率</st>` <st c="18868">目录用于查看生成的报告。</st> <st c="18910">在网页浏览器中打开HTML报告（</st>`<st
    c="18932">coverage/report-html/index.html</st>`<st c="18964">）以可视化代码覆盖率细节。</st>
    <st c="19024">报告突出显示已覆盖行、未覆盖行和整体覆盖率百分比。</st> <st c="19112">此外，LCOV报告（</st>`<st
    c="19143">coverage/report-lcov/lcov-report/index.html</st>`<st c="19187">）提供了代码覆盖率的更详细分解。</st>'
- en: '`<st c="19682">mocha-reporter</st>` <st c="19696">displays</st> <st c="19705">detailed
    information about test failures, including stack traces and error messages, whereas</st>
    `<st c="19799">junit-reporter</st>` <st c="19813">generates JUnit-style XML reports
    that can be consumed by CI tools for</st> <st c="19885">further analysis.</st>'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="19682">mocha-reporter</st>` <st c="19696">显示</st> <st c="19705">关于测试失败的详细信息，包括堆栈跟踪和错误消息，而</st>
    `<st c="19799">junit-reporter</st>` <st c="19813">生成JUnit风格的XML报告，这些报告可以被CI工具用于</st>
    <st c="19885">进一步分析。</st>'
- en: <st c="19902">To integrate Karma with CI tools, configure the respective plugin
    or reporter in your Karma configuration file.</st> <st c="20015">For example,
    to generate JUnit reports for Jenkins, add the</st> `<st c="20075">karma-junit-reporter</st>`
    <st c="20095">plugin and configure</st> <st c="20117">it accordingly.</st>
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19902">要将 Karma 与 CI 工具集成，请在您的 Karma 配置文件中配置相应的插件或报告器。</st> <st c="20015">例如，要为
    Jenkins 生成 JUnit 报告，添加</st> `<st c="20075">karma-junit-reporter</st>` <st c="20095">插件并相应配置。</st>
- en: '**<st c="20132">Step 4 – utilizing thresholds and</st>** **<st c="20167">quality
    gates</st>**<st c="20180">:</st>'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="20132">步骤 4 – 利用阈值和</st>** **<st c="20167">质量门</st>**<st c="20180">：</st>'
- en: <st c="20182">Karma</st> <st c="20187">allows developers to define thresholds</st>
    <st c="20226">and quality gates for code coverage and</st> <st c="20267">test
    results.</st> <st c="20281">By setting these thresholds, developers</st> <st c="20321">can
    establish the minimum requirements for code coverage and test success rates.</st>
    <st c="20402">This ensures that the code base maintains a certain level of quality
    and reduces the risk of shipping untested or poorly</st> <st c="20523">covered
    code.</st>
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20182">Karma</st> <st c="20187">允许开发者定义代码覆盖率和测试结果</st> <st c="20226">的阈值和质量门。</st>
    <st c="20281">通过设置这些阈值，开发者</st> <st c="20321">可以建立代码覆盖率和测试成功率的最小要求。</st> <st c="20402">这确保了代码库保持一定的质量水平，并减少了发布未测试或测试覆盖率低代码的风险。</st>
- en: <st c="20536">To set thresholds for code coverage, update your Karma configuration
    file</st> <st c="20611">as follows:</st>
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20536">为了设置代码覆盖率阈值，请更新您的 Karma 配置文件</st> <st c="20611">如下：</st>
- en: '[PRE8]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="20800">In this</st> <st c="20809">example, the thresholds have been set</st>
    <st c="20847">to 80% for statements, branches, functions, and</st> <st c="20894">lines.</st>
    <st c="20902">If any of these thresholds are not</st> <st c="20936">met, Karma
    will report a failed</st> <st c="20969">test result.</st>
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22003">在这个</st> <st c="20809">示例中，阈值已设置为 80%，用于语句、分支、函数和</st> <st c="20894">行。</st>
    <st c="20902">如果这些阈值中的任何一个未</st> <st c="20936">达到，Karma 将报告失败的</st> <st c="20969">测试结果。</st>
- en: <st c="20981">Code coverage visualization</st>
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="20981">代码覆盖率可视化</st>
- en: <st c="21009">In our project, we started by writing</st> <st c="21047">tests
    on</st> `<st c="21057">CalculatorComponent</st>`<st c="21076">. Now, we can see
    the code coverage using Karma.</st> <st c="21125">Let’s run the following command
    in our</st> <st c="21164">project’s terminal:</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21009">在我们的项目中，我们首先在</st> <st c="21047">CalculatorComponent</st><st c="21076">上编写了测试。现在，我们可以使用
    Karma 查看代码覆盖率。</st> <st c="21125">在我们的</st> <st c="21164">项目终端中运行以下命令：</st>
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="21208">After executing the preceding command, we’ll observe the following</st>
    <st c="21276">three things:</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21208">执行前面的命令后，我们将观察到以下</st> <st c="21276">三个要点：</st>
- en: <st c="21289">In the terminal, we’ll have the following, if all</st> <st c="21340">goes
    well:</st>
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="21289">如果一切顺利，在终端中我们将看到以下内容：</st>
- en: '![Figure 2.4 – Test coverage in the terminal](img/B21146_02_4.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 终端中的测试覆盖率](img/B21146_02_4.jpg)'
- en: <st c="21893">Figure 2.4 – Test coverage in the terminal</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21893">图 2.4 – 终端中的测试覆盖率</st>
- en: <st c="21935">Karma launches our browser, showing us the various tests that
    were</st> <st c="22003">carried out:</st>
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="21935">Karma 启动我们的浏览器，显示我们执行的各种测试：</st>
- en: '![Figure 2.5 – A successful test](img/B21146_02_5.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 成功的测试](img/B21146_02_5.jpg)'
- en: <st c="22376">Figure 2.5 – A successful test</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22376">图 2.5 – 成功的测试</st>
- en: <st c="22406">A</st> `<st c="22409">coverage</st>` <st c="22417">folder</st>
    <st c="22424">is created in our</st> <st c="22443">project’s arborescence:</st>
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="22406">在我们的</st> <st c="22409">项目结构</st> <st c="22417">中创建了一个</st> <st
    c="22424">覆盖率</st> <st c="22443">文件夹：</st>
- en: '![Figure 2.6 – The test coverage folder](img/B21146_02_6.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 测试覆盖率文件夹](img/B21146_02_6.jpg)'
- en: <st c="22644">Figure 2.6 – The test coverage folder</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22644">图 2.6 – 测试覆盖率文件夹</st>
- en: <st c="22681">Inside is an</st> `<st c="22695">index.html</st>` <st c="22705">file.</st>
    <st c="22712">When we launch the file in the browser, we’ll see a table summarizing
    all the files tested, and in each file, we’re told how much of a given piece of
    code has</st> <st c="22871">been tested.</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22681">内部是一个</st> `<st c="22695">index.html</st>` <st c="22705">文件。</st>
    <st c="22712">当我们用浏览器打开这个文件时，我们会看到一个表格，总结所有测试过的文件，并且在每个文件中，我们会被告知给定代码片段的测试覆盖率。</st>
    <st c="22871">有多少已经被测试。</st>
- en: <st c="22883">The following</st> <st c="22898">screenshots show</st> <st c="22915">test
    coverage:</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22883">以下</st> <st c="22898">截图显示了</st> <st c="22915">测试覆盖率：</st>
- en: '![Figure 2.7 – Test coverage visualization on the web – part 1](img/B21146_02_7.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 网页上的测试覆盖率可视化 – 第1部分](img/B21146_02_7.jpg)'
- en: <st c="23233">Figure 2.7 – Test coverage visualization on the web – part 1</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23233">图2.7 – 网页上的测试覆盖率可视化 – 第1部分</st>
- en: '![Figure 2.8 – Test coverage visualization on the web – part 2](img/B21146_02_8.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 网页上的测试覆盖率可视化 – 第2部分](img/B21146_02_8.jpg)'
- en: <st c="23574">Figure 2.8 – Test coverage visualization on the web – part 2</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23574">图2.8 – 网页上的测试覆盖率可视化 – 第2部分</st>
- en: '![Figure 2.9 – Test coverage visualization on the web – part 3](img/B21146_02_9.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 网页上的测试覆盖率可视化 – 第3部分](img/B21146_02_9.jpg)'
- en: <st c="24073">Figure 2.9 – Test coverage visualization on the web – part 3</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24073">图2.9 – 网页上的测试覆盖率可视化 – 第3部分</st>
- en: '![Figure 2.10 – Test coverage visualization on the web – part 4](img/B21146_02_10.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 网页上的测试覆盖率可视化 – 第4部分](img/B21146_02_10.jpg)'
- en: <st c="24435">Figure 2.10 – Test coverage visualization on the web – part 4</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24435">图2.10 – 网页上的测试覆盖率可视化 – 第4部分</st>
- en: '![Figure 2.11 – Test coverage visualization on the web – part 5](img/B21146_02_11.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 网页上的测试覆盖率可视化 – 第5部分](img/B21146_02_11.jpg)'
- en: <st c="25038">Figure 2.11 – Test coverage visualization on the web – part 5</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25038">图2.11 – 网页上的测试覆盖率可视化 – 第5部分</st>
- en: <st c="25099">By utilizing code</st> <st c="25117">coverage and test result
    analysis with Karma, developers can enhance their testing practices and ensure
    comprehensive code coverage.</st> <st c="25251">Karma’s built-in support for code
    coverage enables developers to measure the effectiveness of their tests and identify
    areas that require additional attention.</st> <st c="25411">Additionally, Karma’s
    test reporting and integration capabilities allow for deeper analysis of test
    results, enabling developers to track the health of their test suite and identify
    patterns in test failures.</st> <st c="25620">By setting thresholds and quality
    gates, developers can establish minimum requirements for code coverage and test
    success rates, ensuring a higher level of code quality</st> <st c="25789">and
    reliability.</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用代码覆盖率以及Karma的测试结果分析，开发者可以提升他们的测试实践并确保全面的代码覆盖率。<st c="25251">Karma内置的代码覆盖率支持使得开发者能够衡量测试的有效性并识别需要额外关注的区域。</st>
    <st c="25411">此外，Karma的测试报告和集成能力允许对测试结果进行更深入的分析，使开发者能够跟踪测试套件的健康状况并识别测试失败的模式。</st>
    <st c="25620">通过设置阈值和质量门，开发者可以建立代码覆盖率和测试成功率的最小要求，确保更高的代码质量和可靠性。</st> <st c="25789">和可靠性。</st>
- en: <st c="25805">Summary</st>
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="25805">总结</st>
- en: <st c="25813">This chapter covered how to set up the testing environment, write
    unit tests with Jasmine, and configure Karma to run the tests in different browsers.</st>
    <st c="25965">Jasmine and Karma are powerful tools for testing Angular applications.</st>
    <st c="26036">Jasmine is a BDD framework that provides an intuitive syntax for
    writing test cases.</st> <st c="26121">Karma, on the other hand, is a test runner
    that allows you to execute tests in various environments and provides features
    such as code coverage and test</st> <st c="26274">result analysis.</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25813">本章介绍了如何设置测试环境，使用Jasmine编写单元测试，并配置Karma在不同的浏览器中运行测试。</st> <st c="25965">Jasmine和Karma是测试Angular应用程序的强大工具。</st>
    <st c="26036">Jasmine是一个BDD框架，它为编写测试用例提供了直观的语法。</st> <st c="26121">另一方面，Karma是一个测试运行器，允许你在各种环境中执行测试，并提供代码覆盖率和测试结果分析等功能。</st>
    <st c="26274">结果分析。</st>
- en: <st c="26290">To use Jasmine and Karma to test Angular applications, you need
    to set up the testing environment by installing the necessary dependencies and
    configuring Karma.</st> <st c="26453">Jasmine provides a rich set of matchers
    and assertions to validate the behavior of Angular components, services, and directives.</st>
    <st c="26582">You can create test suites and test cases to cover different scenarios</st>
    <st c="26653">and expectations.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26290">要使用Jasmine和Karma测试Angular应用程序，你需要通过安装必要的依赖项和配置Karma来设置测试环境。</st>
    <st c="26453">Jasmine提供了一套丰富的匹配器和断言，用于验证Angular组件、服务和指令的行为。</st> <st c="26582">你可以创建测试套件和测试用例来覆盖不同的场景</st>
    <st c="26653">和期望。</st>
- en: <st c="26670">Karma allows you to run tests in real browsers or headless environments,
    making it easy to simulate user interactions and test the application’s behavior
    across different platforms.</st> <st c="26853">It also provides support for code
    coverage, generating reports that help identify areas of the code base that require</st>
    <st c="26971">additional testing.</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26670">Karma 允许你在真实浏览器或无头环境中运行测试，这使得模拟用户交互并测试应用程序在不同平台上的行为变得容易。</st>
    <st c="26853">它还提供了代码覆盖率支持，生成报告以帮助识别代码库中需要</st> <st c="26971">额外测试的区域。</st>
- en: <st c="26990">By using Jasmine and Karma together, you can write complete unit
    tests for your Angular applications and practice the principles</st> <st c="27120">of
    TDD.</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26990">通过结合使用 Jasmine 和 Karma，你可以为你的 Angular 应用程序编写完整的单元测试，并实践 TDD 的原则。</st>
- en: <st c="27127">In the next chapter, we’ll learn how to write effective unit tests
    for Angular components, services,</st> <st c="27229">and directives.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27127">在下一章中，我们将学习如何为 Angular 组件、服务和指令编写有效的单元测试。</st>
- en: '<st c="0">Part 2: Writing Effective Unit Tests</st>'
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">第二部分：编写有效的单元测试</st>
- en: <st c="37">In this part, you’ll write unit tests for components, services, and
    directives, using pipes, forms, and reactive programming while respecting</st>
    <st c="180">TDD principles.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37">在本部分中，你将使用管道、表单和响应式编程编写组件、服务和指令的单元测试，同时遵循</st> <st c="180">TDD 原则。</st>
- en: <st c="195">This part has the</st> <st c="214">following chapters:</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="195">本部分包含以下章节：</st> <st c="214">以下章节：</st>
- en: '[*<st c="233">Chapter 3</st>*](B21146_03.xhtml#_idTextAnchor065)<st c="243">,</st>
    *<st c="245">Writing Effective Unit Tests for Angular Components, Services, and
    Directives</st>*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="233">第三章</st>*](B21146_03.xhtml#_idTextAnchor065)<st c="243">,</st>
    *<st c="245">为 Angular 组件、服务和指令编写有效的单元测试</st>*'
- en: '[*<st c="322">Chapter 4</st>*](B21146_04.xhtml#_idTextAnchor108)<st c="332">,</st>
    *<st c="334">Mocking and Stubbing Dependencies in Angular Tests</st>*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="322">第四章</st>*](B21146_04.xhtml#_idTextAnchor108)<st c="332">,</st>
    *<st c="334">在 Angular 测试中模拟和存根依赖</st>*'
- en: '[*<st c="384">Chapter 5</st>*](B21146_05.xhtml#_idTextAnchor200)<st c="394">,</st>
    *<st c="396">Testing Angular Pipes, Forms, and Reactive Programming</st>*'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="384">第五章</st>*](B21146_05.xhtml#_idTextAnchor200)<st c="394">,</st>
    *<st c="396">测试 Angular 管道、表单和响应式编程</st>*'
