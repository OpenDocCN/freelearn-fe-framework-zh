- en: Chapter 2. A Fixed Position Sidebar with Animated Scrolling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。固定位置侧边栏带有动画滚动
- en: The `position:fixed` CSS style adds an interesting effect that allows a targeted
    element to retain its position on the screen even when the page it is on is scrolled.
    However, its effectiveness is limited by the fact that no matter how deep the
    element is nested within other elements, it is always fixed relative to the document
    as a whole.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '`position:fixed` CSS样式添加了一个有趣的效果，允许一个目标元素在页面被滚动时保持其位置。然而，它的有效性受到一个限制，即无论这个元素被嵌套在其他元素中多深，它始终是相对于整个文档固定的。'
- en: Mission Briefing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: In this project we'll create a sidebar that emulates the `position:fixed` CSS
    style but doesn't suffer from the same limitations as a pure CSS solution. We
    can also add an attractive animation to the page so that when navigation items
    in the sidebar are clicked, different parts of the page are scrolled into view.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将创建一个侧边栏，模拟`position:fixed`的CSS样式，但不会受到纯CSS解决方案的相同限制。我们还可以在页面上添加一种吸引人的动画，以便当侧边栏中的导航项被点击时，页面的不同部分被滚动到视图中。
- en: 'The following is a screenshot that shows the final result of this project:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此项目的最终结果的截图：
- en: '![Mission Briefing](img/9106_02_01_preFinal.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![任务简报](img/9106_02_01_preFinal.jpg)'
- en: Why Is It Awesome?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么很棒？
- en: Being able to fix an element in place on the page is an incredibly popular UI
    design pattern used by many large and popular websites.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在页面上固定一个元素是一种非常流行的UI设计模式，被许多大型和受欢迎的网站使用。
- en: Keeping the visitor's main tools or calls-to-action within reach at all times
    improves the user experience of the site and can help keep your visitors happy.
    Making things convenient is important, so if a visitor has to scroll down a long
    page, then scroll all the way up just to click something, they will soon lose
    interest in the page.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将访问者的主要工具或行动呼吁保持在任何时候都可以接触到，提高了网站的用户体验，并可以帮助保持您的访问者满意。方便是重要的，所以如果访问者必须向下滚动一个长页面，然后再次向上滚动才能点击某些内容，他们很快就会对页面失去兴趣。
- en: This same principle is also an emerging trend on mobile devices. Actual `position:fixed`
    styling has pretty poor support on mobile devices in general, but the idea of
    keeping important tools in hand, so to speak, without requiring excessive scrolling
    or a change of screen is being picked up and implemented in some of today's most
    well-known apps.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原理在移动设备上也是一个新兴的趋势。实际的`position:fixed`样式在移动设备上普遍支持较差，但在某些当今最知名的应用程序中，将重要工具保持在手边，而不需要过多滚动或更改屏幕，这一想法正在被采用和实施。
- en: Your Hotshot Objectives
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的炫酷目标
- en: 'To complete this project we will need to work through the following tasks:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此项目，我们需要完成以下任务：
- en: Building a suitable demo page
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个合适的演示页面
- en: Storing the initial position of the fixed element
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储固定元素的初始位置
- en: Detecting when the page has scrolled
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测页面何时滚动
- en: Handling browser window resizes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理浏览器窗口的调整大小
- en: Automating scrolling
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动滚动
- en: Restoring the browser's back button
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复浏览器的返回按钮
- en: Handling the hash fragment on page load
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理页面加载时的哈希片段
- en: Building a suitable demo page
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个合适的演示页面
- en: In this task we'll prepare the demo page and the other files we'll need ready
    for the script.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将准备演示页面和其他我们需要的文件，以便为脚本做好准备。
- en: To make the benefits of this technique obvious, we'll need to use a number of
    extra elements that strictly speaking aren't part of the required elements for
    the sidebar that we'll be fixing in place.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明显展示这种技术的好处，我们将需要使用一些额外的元素，严格来说，这些元素不是侧边栏所需的元素的一部分，我们将固定在一个地方。
- en: The sidebar that we'll use as the focus of this example will need to sit within
    the structure of a complete page, and to see the fixed position effect, the page
    will also need to be quite long.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此示例中使用的侧边栏需要位于完整页面结构内，为了看到固定位置效果，页面也需要非常长。
- en: We'll be using a range of HTML5 elements when building our demo page and you
    should be aware that these are not supported in older versions of some browsers.
    If you find that you do need to support legacy browsers, you'll need to use the
    `html5shiv` script available at Google Code ([http://code.google.com/p/html5shiv/](http://code.google.com/p/html5shiv/)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的演示页面时，我们将使用一系列HTML5元素，你应该知道这些元素在某些浏览器的旧版本中不受支持。如果你发现你需要支持旧版本的浏览器，你将需要使用Google
    Code提供的`html5shiv`脚本（[http://code.google.com/p/html5shiv/](http://code.google.com/p/html5shiv/)）。
- en: Prepare for Lift Off
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为起飞做准备
- en: We should first save a new copy of the template file to the root folder of our
    project and call the new file `fixed-sidebar.html`. We can also create a new style
    sheet called `fixed-sidebar.css`, which we can save in the `css` folder, and a
    new JavaScript file called `fixed-sidebar.js`, which should be saved to the `js`
    folder.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应首先将模板文件的新副本保存到项目的根文件夹中，并将新文件命名为`fixed-sidebar.html`。我们还可以创建一个名为`fixed-sidebar.css`的新样式表，将其保存在`css`文件夹中，并创建一个名为`fixed-sidebar.js`的新JavaScript文件，应保存到`js`文件夹中。
- en: 'We can link to the new style sheet in the `<head>` part of the HTML page using
    the following new `<link>` element, which should be added directly after the link
    to `common.css`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下新的`<link>`元素将新样式表链接到HTML页面的`<head>`部分，该元素应直接添加到链接到`common.css`之后：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Remember that the `common.css` style sheet is used to provide useful things
    such as a reset, a simple typography framework, and some common layout styles
    in order to minimize the CSS each project requires.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`common.css`样式表用于提供诸如重置、简单的排版框架和一些常见的布局样式等有用内容，以尽量减少每个项目所需的CSS。
- en: 'We can link to the new JavaScript file using the following new `<script>` element,
    which should be directly after the jQuery `<script>` file in the `<body>` part
    of `fixed-sidebar.html`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下新的`<script>`元素将新的JavaScript文件链接到`fixed-sidebar.html`页面的`<body>`部分中的jQuery
    `<script>`文件之后：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The underlying page is now set up ready for us to add the elements that are
    required for this project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 底层页面现在已设置好，准备为这个项目添加所需的元素。
- en: Engage Thrusters
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'We''ll use a basic layout for our page consisting of the following elements,
    which should be added to `fixed-sidebar` `.html`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的页面使用基本布局，其中包括以下元素，这些元素应添加到`fixed-sidebar` `.html`中：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These elements should be added to the `<body>` of the page, directly before
    the `<script>` element that links to jQuery.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素应直接添加到页面的`<script>`元素之前，该元素链接到jQuery。
- en: 'We''ll also need some basic CSS for our example page in order to create the
    layout that this example requires. In the `fixed-sidebar.css` style sheet that
    we created for this example, add the following styles:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例页面还需要一些基本的CSS，以创建此示例所需的布局。在我们为此示例创建的`fixed-sidebar.css`样式表中，添加以下样式：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As before, none of this code is actually required, we're using it just to lay
    out the demo page as we need to for the purposes of this example.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，实际上并不需要任何这些代码，我们只是为了根据这个示例的需要布置演示页面。
- en: Objective Complete - Mini Debriefing
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小型简报
- en: We've added a very simple layout to create our demo page. The HTML5 `<article>`
    is filled with five different HTML5 `<section>` elements, each with their own
    `id` attributes. We'll use these a little later in the project to allow animated
    navigation between them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个非常简单的布局来创建我们的演示页面。HTML5`<article>`填充了五个不同的HTML5`<section>`元素，每个元素都有自己的`id`属性。稍后在项目中我们会使用这些来允许它们之间的动画导航。
- en: In the previous code sample each `<section>` element is empty. But if you're
    following along and writing the example code as you go, you should fill each of
    them with a variety of random elements in order to increase the length of the
    page.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，每个`<section>`元素都是空的。但是，如果你一边跟着进行并编写示例代码，你应该用各种随机元素填充每个元素，以增加页面的长度。
- en: None of the elements we're using in this example matter at all. The HTML5 `<aside>`
    is the element that we'll be fixing in place, but the fact that it's an `<aside>`
    element is not important – any element can be used with this technique.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用的元素都不重要。HTML5`<aside>`是我们将要固定的元素，但它是`<aside>`元素并不重要 - 任何元素都可以使用这种技术。
- en: Inside the `<aside>` element is an HTML5 `<nav>` element. As I mentioned, this
    will allow us to add another cool feature later on, but again, is not essential
    for the basic technique to be used. Any content can be used in the element that
    is to be fixed in place.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<aside>`元素内部是一个HTML5`<nav>`元素。正如我之前提到的，这将使我们能够稍后添加另一个很酷的功能，但同样，并不是基本技术的必需品。任何内容都可以在要固定在原位的元素中使用。
- en: Notice also that in the CSS we don't use `position:fixed` anywhere at all. The
    reason for this is simple. An element that has a fixed position is positioned
    relative to the document as a whole, not to its parent container.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在CSS中我们根本不使用`position:fixed`。其原因很简单。具有固定位置的元素相对于整个文档而言是定位的，而不是相对于其父容器。
- en: If no pixel coordinates are supplied, a fixed position element is rendered where
    the flow of elements on the page dictates depending on its DOM position (although
    it is still technically out of the normal flow of the page).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供像素坐标，则渲染一个固定位置元素，其元素在页面上的位置取决于其 DOM 位置（尽管从技术上讲它仍然不在页面的正常流中）。
- en: If we try to do this with our example layout, it ends up at the far-left of
    the outer `.wrapper` element, because the `float` specified on the `<article>`
    element also removes the `<article>` element from the normal document flow. This
    is not good.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用我们的示例布局来做这件事，它最终会出现在外部 `.wrapper` 元素的最左边，因为在 `<article>` 元素上指定的 `float`
    也会将 `<article>` 元素从正常文档流中移除。这不好。
- en: If pixel coordinates are supplied, these are interpreted by the rendering engine
    to be relative to the window, just like absolutely positioned elements. In some
    situations it may be acceptable to specify pixel coordinates, but when using a
    liquid layout such as in this example, the required coordinates to set the `left`
    and `top` style properties of the `<aside>` element will vary depending on the
    resolution of the screen used to view the page, hence the conundrum we face and
    hence the reason to use jQuery to achieve it instead of simple CSS.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了像素坐标，渲染引擎将解释这些坐标相对于窗口的位置，就像绝对定位元素一样。在某些情况下，指定像素坐标可能是可以接受的，但是在使用本示例中的流式布局时，设置
    `<aside>` 元素的 `left` 和 `top` 样式属性所需的坐标将取决于用于查看页面的屏幕分辨率，这就是我们面临的困境，因此我们使用 jQuery
    来实现它而不是简单的 CSS。
- en: Classified Intel
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: To save time when creating example layouts, like the one used in this project,
    we can use services such as Placehold It ([http://placehold.it/](http://placehold.it/))
    for placeholder images of any dimensions, and HTML Ipsum ([http://html-ipsum.com](http://html-ipsum.com))
    for a range of common HTML elements pre-filled with Lorem Ipsum placeholder text.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省创建示例布局（如本项目中使用的布局）的时间，我们可以使用诸如 Placehold It ([http://placehold.it/](http://placehold.it/))
    这样的服务，用任意尺寸的占位图像代替图像，以及 HTML Ipsum ([http://html-ipsum.com](http://html-ipsum.com))
    来填充常见 HTML 元素的 Lorem Ipsum 占位文本。
- en: Storing the initial position of the fixed element
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储固定元素的初始位置
- en: Before we can fix the element in place, we'll need to know where that place
    is. In this task we'll obtain the current starting position of the `<aside>` element
    that we're going to be fixing in place.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将元素固定在某个位置之前，我们需要知道那个位置在哪里。在这个任务中，我们将获取我们将要固定在某个位置的 `<aside>` 元素的当前起始位置。
- en: Engage Thrusters
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'In `fixed-sidebar.js` we should start with the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `fixed-sidebar.js` 中，我们应该从以下代码开始：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can cache a couple of jQuery-selected elements at the top of our function,
    and to store the initial position of the fixed element, we can then add the following
    code within the function we just added:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数顶部缓存一些 jQuery 选中的元素，并存储固定元素的初始位置，然后我们可以在刚刚添加的函数内添加以下代码：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Objective Complete - Mini Debriefing
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: We've used the same outer wrapper for our code that we used in the first project.
    As I mentioned then, it's a very common way to execute code once the page has
    finished loading. We'll probably use it in every project throughout the book.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了与第一个项目中相同的外部包装器。就像我之前提到的那样，这是在页面加载完成后执行代码的非常常见的方式。我们可能会在本书中的每个项目中都使用它。
- en: We then cache references to the elements that we're going to be referring to
    so that we don't have to keep selecting them from the DOM. We'll be querying these
    elements inside event handlers a little later so it's much better for performance
    to select them from the page once and then refer to the saved, or cached, version
    throughout our code, instead of repeatedly selecting elements from the page.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们缓存我们将要引用的元素的引用，这样我们就不必一直从 DOM 中选择它们。稍后我们将在事件处理程序中查询这些元素，为了性能考虑，最好是从页面中选择一次并在我们的代码中引用保存或缓存的版本，而不是反复从页面中选择元素。
- en: We store references to the `window` object as we'll be attaching several event
    handlers to it. We'll be scrolling the entire page a little later on and for full
    cross-browser compatibility we should select and store a reference to both the
    `<html>` and `<body>` elements, as different browsers use either the `<html>`
    or `<body>` element, so this covers all bases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引用 `window` 对象，因为我们将向其附加多个事件处理程序。稍后我们将滚动整个页面，为了实现全面的跨浏览器兼容性，我们应该选择并存储对 `<html>`
    和 `<body>` 元素的引用，因为不同的浏览器使用 `<html>` 或 `<body>` 元素，所以这样涵盖了所有情况。
- en: We'll need to select the element with the class name `wrapper`, the containing
    `<article>`, all of the different `<section>` elements, and of course the `<aside>`
    element, which we'll be working with frequently throughout the remaining code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要选择具有类名`wrapper`的元素，包含的`<article>`，所有不同的`<section>`元素，当然还有我们将在剩余代码中经常使用的`<aside>`元素。
- en: We also store the initial position of the fixed element so that we know the
    coordinates on the page to fix the element to. We use jQuery's `offset()` method,
    which returns an object containing `top` and `left` properties that show the current
    position relative to the document, exactly what we require.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还存储了固定元素的初始位置，以便我们知道要将元素固定到页面上的坐标。我们使用 jQuery 的`offset()`方法，该方法返回一个包含`top`和`left`属性的对象，显示相对于文档的当前位置，正是我们所需的。
- en: Depending on the styles applied to the surrounding elements, the `width` of
    the element being fixed may change. To alleviate this we also store the initial
    `width` of the element using jQuery's `width()` method, which returns an integer
    expressing the `width` in pixels.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 根据周围元素应用的样式，被固定元素的`width`可能会发生变化。为了缓解这种情况，我们还使用了 jQuery 的`width()`方法来存储元素的初始`width`，该方法返回以像素表示的整数。
- en: Lastly, we can also compute and store the `width` as a percentage. We'll need
    to know this later when we want to react to the browser window being resized.
    Working it out is easy by multiplying `100` by the `width` of the fixed element,
    then dividing this figure by the width of its container, which again we use jQuery's
    `width()` method to obtain. This also means that the `width` of the fixed sidebar
    can easily be changed in just the CSS file, and the script will continue to work.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以计算并将`width`存储为百分比。稍后当我们想要对浏览器窗口大小调整做出反应时，我们将需要知道这一点。通过将固定元素的`width`乘以`100`，然后将这个数字除以其容器的宽度，我们很容易就能计算出来，而我们再次使用
    jQuery 的`width()`方法来获取容器的宽度。这也意味着固定侧边栏的`width`可以很容易地在 CSS 文件中更改，并且脚本将继续工作。
- en: Detecting when the page has scrolled
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测页面滚动时
- en: Our next task is to detect when the page has been scrolled and fix the element
    in place when that occurs. Detecting the scroll event is made easy for us by jQuery,
    as is setting the `position` to `fixed`, because there are simple jQuery methods
    we can call to do these exact things.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个任务是在页面滚动时检测到，并在发生滚动时将元素固定在原位。对于我们来说，通过 jQuery，检测滚动事件变得很容易，将`position`设置为`fixed`也很容易，因为有简单的
    jQuery 方法可以调用来执行这些确切的操作。
- en: Engage Thrusters
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'Add the following code to the script file directly after the variables we initialized
    in the last task:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个任务中初始化变量之后，将以下代码直接添加到脚本文件中：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Objective Complete - Mini Debriefing
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你简报
- en: We can use jQuery's `one()` method to attach an event handler to the `window`
    object that we stored in a variable. The `one()` method will automatically unbind
    the event handler as soon as the event is detected for the first time, which is
    useful because we only need to set the element to `position:fixed` once. In this
    example we are looking for the `scroll` event.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 jQuery 的`one()`方法将事件处理程序附加到我们存储在变量中的`window`对象上。`one()`方法将在第一次检测到事件时自动解除绑定，这很有用，因为我们只需要一次将元素设置为`position:fixed`。在本示例中，我们正在寻找`scroll`事件。
- en: When the event is detected, the anonymous function we pass as the second argument
    to `one()` will be executed. When this occurs we use jQuery's `css()` method to
    set some `style` properties. We set the `width` of the element to counter situations
    where the `width` of our target element increases because of `float` and/or `margin`
    on surrounding elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到事件时，我们将作为`one()`的第二个参数传递的匿名函数将被执行。在发生这种情况时，我们使用 jQuery 的`css()`方法来设置一些`style`属性。我们将元素的`width`设置为对应情况的原因是，我们的目标元素的`width`因周围元素的`float`和/或`margin`而增加。
- en: We set the `position` to `fixed` and also set the `top` and `left` style properties
    using the initial position of the element that we stored in the `initialPos` variable
    at the start of the project. We use JavaScript's `Math.round()` method in order
    to round the `top` and `left` pixel positions to whole numbers, which helps to
    avoid any cross-browser issues with subpixel rounding.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`position`设置为`fixed`，并使用在项目开始时存储在`initialPos`变量中的元素的初始位置，设置`top`和`left`样式属性。我们使用
    JavaScript 的`Math.round()`方法来将`top`和`left`像素位置四舍五入为整数，这有助于避免任何与子像素舍入相关的跨浏览器问题。
- en: Handling browser window resizes
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理浏览器窗口调整
- en: At the moment, our `<aside>` element will be fixed in place as soon as the page
    scrolls, which suits our needs while the browser remains the same size.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的 `<aside>` 元素在页面滚动时会立即固定在原地，这符合我们的需求，只要浏览器保持相同的大小。
- en: However, if the window is resized for some reason, the `<aside>` element will
    fall out of its fixed position and could be lost outside of the boundaries of
    the viewport. In this task, we'll fix that by adding an event handler that listens
    for the window's resize event.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果由于某种原因调整了窗口大小，则 `<aside>` 元素将从其固定位置掉落，并且可能会丢失在视口的边界之外。在这个任务中，我们将通过添加一个事件处理程序来修复这个问题，该处理程序监听窗口的
    resize 事件。
- en: Engage Thrusters
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'To maintain the fixed element''s correct location relative to the rest of the
    page, we should add the following code directly after the `one()` method that
    we added in the last task:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持固定元素相对于页面其余部分的正确位置，我们应该在上一任务中添加的 `one()` 方法之后直接添加以下代码：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Objective Complete - Mini Debriefing
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你总结
- en: This time we use jQuery's `on()` method to attach our event handler. We pass
    two arguments to this method; the first is the event we are listening for, which
    in this task is the window's `resize` event, and the second is the function that
    we wish to execute when the event is detected.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用 jQuery 的 `on()` 方法来附加我们的事件处理程序。我们向这个方法传递两个参数；第一个是我们要监听的事件，在这个任务中是窗口的
    `resize` 事件，第二个是我们希望在检测到事件时执行的函数。
- en: We only want to reposition and resize the `<aside>` element if the page has
    already been scrolled and the element has had its `position` set to `fixed`, so
    before we do anything else we first check that this is the case.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只希望在页面已经滚动并且元素的 `position` 已经设置为 `fixed` 时重新定位和调整 `<aside>` 元素的大小，因此在我们做任何其他事情之前，我们首先检查这是否是这种情况。
- en: If the element's `position` is set to `fixed`, we first determine the current
    `left` style property of the wrapper element using the `left` property of the
    object returned by jQuery's `offset()` method. We also get the wrapper element's
    `width` using jQuery's `width()` method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素的 `position` 设置为 `fixed`，我们首先使用 jQuery 的 `offset()` 方法返回的对象的 `left` 属性确定包装器元素的当前
    `left` 样式属性。我们还使用 jQuery 的 `width()` 方法获取包装器元素的 `width`。
- en: Because our layout is liquid we also need to adjust the `width` of the fixed
    element. In the CSS we originally set the `width` to `20%`, so we can ensure that
    it stays at 20 percent of its container by dividing the container's current width
    by 100 and then multiplying it by the `percentWidth` variable we stored in the
    first task.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的布局是液体的，所以我们还需要调整固定元素的 `width`。在 CSS 中，我们最初将 `width` 设置为 `20%`，所以我们可以通过将容器的当前宽度除以
    100，然后乘以我们在第一个任务中存储的 `percentWidth` 变量来确保它保持在其容器的 20%。
- en: We then use jQuery's `css()` method to set the `width` of the fixed element
    and it's `top` and `left` style properties to make sure that it stays in the correct
    location when the `window` is resized.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 jQuery 的 `css()` 方法设置固定元素的 `width` 以及它的 `top` 和 `left` 样式属性，以确保在 `window`
    调整大小时它保持在正确的位置。
- en: Automating scrolling
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动滚动
- en: At this point, we should be able to click on any of the links in the navigation
    menu we added to the fixed element, and the page will jump to bring the corresponding
    section into view. The fixed element will still be fixed into place.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该能够单击固定元素中添加的导航菜单中的任何链接，页面将跳转以将相应的部分带入视图。固定元素仍然固定在原地。
- en: The jump to the section is quite jarring however, so in this task we'll scroll
    each section into place manually so that the jump to each section is not so sudden.
    We can also animate the scroll for maximum aesthetic effect.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到部分的方式相当突兀，因此在这个任务中，我们将手动将每个部分滚动到位，以便每个部分的跳转不那么突然。我们还可以对滚动进行动画处理，以获得最大的美观效果。
- en: Engage Thrusters
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: For this task we should add another event handler, this time for `click` events
    on the links in the navigation list, and then animate the page scroll to bring
    the selected `<section>` into view.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们应该再添加另一个事件处理程序，这次是为导航列表中的链接的 `click` 事件，然后动画滚动页面以将所选的 `<section>` 带入视野。
- en: 'First, we can add a general function for scrolling the page which accepts some
    arguments and then performs the scroll animation using those arguments. We should
    define the function using the following code directly after the `one()` method
    that we added in the last task:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以添加一个用于滚动页面的通用函数，该函数接受一些参数，然后使用这些参数执行滚动动画。我们应该在上一任务中添加的 `one()` 方法之后直接定义该函数，使用以下代码：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we can add a handler for click events on the navigation in our fixed
    element. This should be added directly after the `scrollPage()` function that
    we just added:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在我们的固定元素上为点击事件添加一个处理程序。这应该直接添加在我们刚刚添加的`scrollPage()`函数之后：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Objective Complete - Mini Debriefing
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: First we defined the `scrollPage()` function which accepts three arguments.
    The first is `href`, the second is an integer that represents the figure that
    the `scrollTop` property of the page will need to be animated to, and the third
    is a Boolean that will tell the function whether or not to update the hash fragment
    in the location bar of the browser.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义了`scrollPage()`函数，它接受三个参数。第一个是`href`，第二个是一个整数，代表页面的`scrollTop`属性需要动画到的数值，第三个是一个布尔值，将告诉函数是否更新浏览器地址栏中的哈希片段。
- en: The first thing we do in this function is check whether the page actually needs
    to be scrolled. To ensure it does, we just check that the current scroll of the
    page, obtained using jQuery's `scrollTop()` method, is different from the amount
    that we wish to scroll to.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先检查页面是否确实需要滚动。为了确保它需要，我们只需检查当前页面的滚动，使用jQuery的`scrollTop()`方法获取，是否与我们希望滚动到的数量不同。
- en: The jQuery `animate()` method also accepts three arguments. The first is an
    object where each key is a property to animate, and each value is the value to
    animate it to. In this case we want to animate the `scrollTop` property using
    the `scrollAmount` argument which is passed to our function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的`animate()`方法还接受三个参数。第一个是一个对象，其中每个键都是要动画的属性，每个值都是要将其动画到的值。在这种情况下，我们要使用传递给我们的函数的`scrollAmount`参数来动画化`scrollTop`属性。
- en: The second argument to the `animate()` method is the duration that the animation
    should run for. It accepts an integer that represents the duration in milliseconds.
    We specify `500` so the animation will take half a second to complete.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`animate()`方法的第二个参数是动画应该运行的持续时间。它接受一个代表以毫秒为单位的持续时间的整数。我们指定为`500`，这样动画将需要半秒钟来完成。'
- en: The third argument is a callback function that we would like executed as soon
    as the animation ends. If the `updateHash` argument passed to our function is
    set to `true`, we can update the location bar of the browser to show the `id`
    of the desired `<section>` element.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是一个回调函数，我们希望在动画结束后立即执行。如果我们函数中传递的`updateHash`参数设置为`true`，我们可以更新浏览器的地址栏，显示所需的`<section>`元素的`id`。
- en: We can do this by updating the `hash` property of the `document.location` object
    with the `href` argument passed to our `scrollPage()` function. This updates the
    location bar but because it is just a hash fragment, it doesn't cause the page
    to reload.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用传递给我们的`scrollPage()`函数的`href`参数更新`document.location`对象的`hash`属性来实现这一点。这会更新地址栏，但因为它只是一个哈希片段，所以不会导致页面重新加载。
- en: After adding the `scrollPage()` function, we then added a handler for `click`
    events on the navigation inside the fixed element. We use jQuery's `on()` method
    once again to attach this event, but this time we pass three arguments to the
    method, which enables event delegation. The handler is attached to the `<body>`
    of the page that we have already stored in a variable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了`scrollPage()`函数后，我们随后添加了对固定元素内导航的`click`事件处理程序。我们再次使用jQuery的`on()`方法附加此事件，但这次我们向该方法传递了三个参数，这样可以启用事件委派。处理程序附加到我们已经存储在变量中的页面的`<body>`上。
- en: The first argument is the event that we want to bind the handler to, which in
    this case is the `click` event. The second argument is a selector; the `on()`
    method will filter all click events so that only those originating from elements
    that match the selector will invoke the bound handler function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们要绑定处理程序的事件，在这种情况下是`click`事件。第二个参数是选择器；`on()`方法将过滤所有点击事件，以便只有那些来自与选择器匹配的元素的事件才会调用绑定的处理程序函数。
- en: In this case we are only interested in clicks on the `<a>` elements in our fixed
    element – `<aside>`. The third argument is the function to bind as the handler,
    which is automatically passed the original event object by jQuery.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只对我们的固定元素 - `<aside>`中的`<a>`元素的点击感兴趣。第三个参数是要绑定为处理程序的函数，jQuery会自动将原始事件对象传递给它。
- en: Within this function we first stop the browser navigating to the corresponding
    `<section>` element, using the `preventDefault()` method of the event object that
    is passed to our handler function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们首先使用事件对象的`preventDefault()`方法停止浏览器导航到相应的`<section>`元素。
- en: Next, we set a variable that tells us which `<section>` the user would like
    to navigate to. Inside our event handler function the `$(this)` object is scoped
    to the link that was clicked, so we can easily get the required section `id` by
    getting the `href` attribute of the clicked link using jQuery's `attr()` method.
    We store this in a variable called `href`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置一个变量，告诉我们用户想要导航到哪个`<section>`。 在我们的事件处理程序函数中，`$(this)`对象的作用域限定为被点击的链接，因此我们可以通过使用jQuery的`attr()`方法获取所需的部分`id`来轻松地获取点击链接的`href`属性。
    我们将其存储在名为`href`的变量中。
- en: We need to know where on the page the required `<section>` element is, which
    we obtain by using JavaScript's `split()` method to split the string stored in
    the `href` variable that we just set.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道所需的`<section>`元素在页面上的位置，我们通过使用JavaScript的`split()`方法来分割刚刚设置的`href`变量中存储的字符串来获取它。
- en: If we specify `#part` as the string to split on, the `split()` method will return
    an array consisting of two items, where the second item is a string version of
    the section number that was clicked. By wrapping this statement in JavaScript's
    `parseInt()`, we end up with an integer. We store this integer in the `target`
    variable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`#part`指定为要拆分的字符串，则`split()`方法将返回一个包含两个项目的数组，其中第二个项目是被点击的部分号的字符串版本。 通过将此语句包装在JavaScript的`parseInt()`中，我们得到一个整数。
    我们将此整数存储在`target`变量中。
- en: The last variable we set is the offset of the desired `<section>` element. To
    select the correct `<section>` element, we can use the `sections` array that we
    stored at the start of the project.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的最后一个变量是所需`<section>`元素的偏移量。 要选择正确的`<section>`元素，我们可以使用我们在项目开始时存储的`sections`数组。
- en: To pull the correct element from this array, we use jQuery's `eq()` method and
    pass it the value that we just saved in the `target` variable minus `1`. We need
    to subtract `1` because arrays in JavaScript start at `0`, but our `<section>`
    `id` attributes start at `1`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要从此数组中提取正确的元素，我们使用jQuery的`eq()`方法，并将其设置为刚刚保存在`target`变量中的值减去`1`。 我们需要减去`1`，因为JavaScript中的数组从`0`开始，但是我们的`<section>`
    `id`属性从`1`开始。
- en: Once we have this information we can then call our `scrollPage()` function,
    passing in the values we have just computed to animate the page scroll in order
    to bring the desired `<section>` element into view.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了这些信息，我们就可以调用我们的`scrollPage()`函数，将我们刚刚计算的值传递给它，以动画形式滚动页面，以将所需的`<section>`元素带入视图。
- en: Restoring the browser's back button
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复浏览器的后退按钮
- en: At this point, we can click any of the links in the `<aside>` element and the
    page will be smoothly scrolled to the desired location on the page. The address
    bar of the browser will also be updated.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以点击`<aside>`元素中的任何链接，页面将平滑滚动到页面上所需的位置。 浏览器的地址栏也将被更新。
- en: However, if the user tries to go back to a previous `<section>` using the back
    button of his/her browser, nothing will happen. In this task we'll fix that so
    that the back button works as expected, and can even use smooth scrolling when
    the back button is used to go back to the previous `<section>`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果用户尝试使用其浏览器的返回按钮返回到先前的`<section>`，则什么也不会发生。 在此任务中，我们将修复此问题，以使返回按钮按预期工作，并且甚至可以在使用返回按钮返回到先前的`<section>`时使用平滑滚动。
- en: Engage Thrusters
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'We can enable the back button very easily by adding another event handler directly
    after the one for click events that we just added:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在刚刚添加的点击事件之后直接添加另一个事件处理程序来非常容易地启用返回按钮：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Objective Complete - Mini Debriefing
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小型总结
- en: We use jQuery's `on()` method to attach our event once again, and this time
    we don't need to make use of event delegation, so we revert to the two-argument
    form of the method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用jQuery的`on()`方法附加我们的事件，这次我们不需要使用事件委托，因此我们恢复到该方法的两个参数形式。
- en: This time we are listening for the `hashchange` event, which as before is passed
    as the first argument and occurs whenever the `hash` property of the `document.location`
    object is changed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们正在监听`hashchange`事件，与之前一样，它作为第一个参数传递，并且每当`document.location`对象的`hash`属性更改时就会发生。
- en: In our handler function, which is passed as the second argument, we set the
    variables for the different values that we need to pass to the `scrollPage()`
    function in order to perform the scroll. We don't need to prevent the default
    behavior of the browser this time, and the `href` variable is set using the `document.location.hash`
    property as it will be the back button that will trigger the event, not one of
    the links in the `<aside>`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的处理程序函数中，作为第二个参数传递，我们设置各种变量的不同值，以便传递给`scrollPage()`函数，以执行滚动。这次我们不需要阻止浏览器的默认行为，`href`变量是使用`document.location.hash`属性设置的，因为触发事件的是返回按钮，而不是`<aside>`中的链接之一。
- en: Actually, this handler will also be triggered when one of the links is clicked,
    because the links also update the hash, but the conditional check inside the `scrollPage()`
    function will prevent unnecessary calls to jQuery's `animate()` method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当点击链接时，这个处理程序也会被触发，因为链接也会更新哈希值，但在`scrollPage()`函数内的条件检查将阻止不必要地调用jQuery的`animate()`方法。
- en: The `target` variable is computed in exactly the same way as it was in the last
    event handler, but this time, the `targetOffset` variable needs to handle cases
    where there is no hash fragment in the address bar of the browser. To handle this,
    we use a JavaScript ternary construct that checks whether the `target` variable
    that we just defined has a falsey value, which would indicate an empty string.
    If it does, we want to just animate the scroll back to zero. If it doesn't, we
    determine the required scroll amount in the same way as we did before.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`target`变量的计算方式与上一个事件处理程序中的计算方式完全相同，但这次，`targetOffset`变量需要处理浏览器地址栏中没有哈希片段的情况。为了处理这一点，我们使用JavaScript的三元条件结构来检查刚刚定义的`target`变量是否具有假值，这将指示空字符串。如果是，我们希望只是将滚动平滑返回到零。如果不是，我们确定所需的滚动量的方式与之前一样。'
- en: We should now be able to load the page, scroll to a part of the page by clicking
    on one of the links in the `<aside>` element, and then scroll back to the top
    of the page using the browser's back button.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够加载页面，在`<aside>`元素中点击链接后滚动到页面的某个部分，然后使用浏览器的返回按钮滚动回页面顶部。
- en: Handling the hash fragment on page load
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理页面加载时的哈希片段
- en: At the moment the functionality of the browser's back button has been restored,
    and the visitor can see the bookmarkable URL in the address bar.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 目前浏览器返回按钮的功能已经恢复，访问者可以看到地址栏中的可书签的网址。
- en: If the page is requested with a hash fragment in it, the page will automatically
    jump to the specified `<section>` when the page loads. In this part we'll add
    some code that checks the hash property of the `document.location` object and
    if a hash is detected, it will scroll to the corresponding part of the page smoothly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果页面在其中包含哈希片段的情况下被请求，页面将在加载时自动跳转到指定的`<section>`。在这部分我们将添加一些代码，检查`document.location`对象的哈希属性，如果检测到哈希，则将平滑滚动到页面对应部分。
- en: Engage Thrusters
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'To enable this, we should add the following code directly after where we define
    our starting variables near the top of the script file, and directly before where
    we listen for the scroll event:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们应该在脚本文件顶部定义起始变量后直接添加以下代码，并在监听滚动事件之前直接添加：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Objective Complete - Mini Debriefing
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小型总结
- en: In this bit of code, which will be executed as soon as the page has loaded,
    we first check whether the `document.location` object contains a `hash` (or at
    least, contains a `hash` that is not an empty string).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，页面加载后将立即执行，我们首先检查`document.location`对象是否包含`hash`（或至少包含一个非空字符串的`hash`）。
- en: If it does, we obtain the `hash`, get the number of the `<section>`, and calculate
    the offset from the top of the page in the same way that we have done in previous
    tasks. We then set the `scrollTop` of the page to `0` to force the browser to
    the top of the page. We also remove the hash at this point.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，我们获得`hash`，获取`<section>`的编号，并以与之前任务相同的方式计算距页面顶部的偏移量。然后我们将页面的`scrollTop`设置为`0`，强制浏览器滚动到页面顶部。此时我们还会移除哈希值。
- en: Finally we can call our `scrollPage()` function, passing in the new `href` fragment,
    the amount of scroll required, and set the final argument to `true` so that the
    correct hash fragment is added back to the browser's location bar. It should all
    happen so quickly that the user does not notice that the page load has been intercepted
    and the behavior modified.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以调用我们的`scrollPage()`函数，传入新的`href`片段，所需的滚动量，并将最后一个参数设置为`true`，以便将正确的哈希片段添加回浏览器的位置栏。所有这些都应该发生得非常快，用户不会注意到页面加载已被拦截并修改了行为。
- en: Mission Accomplished
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: In this project we looked at a very simple way of mimicking CSS's `position:fixed`
    styling to fix an important element into place. The technique to only apply the
    fixed positioning when the page starts to scroll is simple but effective, and
    is an excellent way to circumvent the shortcomings of actual `position:fixed`
    when working with complex or liquid layouts.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们看了一种非常简单的方法来模仿CSS的`position:fixed`样式，以固定一个重要的元素。只在页面开始滚动时应用固定定位的技巧简单而有效，并且是解决实际`position:fixed`在处理复杂或流动布局时的缺陷的绝佳方式。
- en: We saw how to handle window resizes and added a smooth scrolling facility that
    scrolled the page between different named sections of the page.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何处理窗口大小调整，并添加了一个平滑滚动功能，以在页面的不同命名部分之间滚动页面。
- en: We also looked at how we can read and write to the `document.location.hash`
    property of the `window` object, and how to manually scroll to the requested section
    when the page is loaded. We also fixed the browser's back button to work with
    our smooth-scrolling animations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了如何读取和写入`window`对象的`document.location.hash`属性，以及在页面加载时如何手动滚动到请求的部分。我们还修复了浏览器的后退按钮，使其与我们的平滑滚动动画配合工作。
- en: You Ready To Go Gung HO? A Hotshot Challenge
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你准备好全力以赴了吗？一个高手的挑战
- en: Very often, with the kind of in-page navigation we've used in this project,
    it is useful to show an on-state on the navigation links when a section is scrolled
    to, either manually, or by clicking on one of the links. Have a go at adding this
    simple but effective addition to the code that we've looked at over the course
    of this project.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，在我们在这个项目中使用的页面内导航中，当手动滚动到一个部分时，或者点击其中一个链接时，将导航链接显示为当前状态是很有用的。试着将这个简单但有效的补充添加到我们在本项目过程中看到的代码中。
