- en: Supporting Server Data Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持服务器数据持久性
- en: It's now time to talk to the server! There is no fun in creating a workout,
    adding exercises, and saving it to later realize that all our efforts are lost
    because the data did not persist anywhere. We need to fix this.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候与服务器通信了！创建锻炼、添加练习并将其保存，然后意识到所有努力都白费，因为数据没有在任何地方持久化，这毫无乐趣。我们需要解决这个问题。
- en: Seldom are applications self-contained. Any consumer app, irrespective of its
    size, has parts that interact with elements outside its boundary. With web-based
    applications, the interaction is mostly with a server. Apps interact with the
    server to authenticate, authorize, store/retrieve data, validate data, and perform
    other such operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序很少是自包含的。任何消费者应用程序，无论其大小如何，都有与边界之外的元素交互的部分。对于基于Web的应用程序，交互主要是与服务器。应用程序通过服务器进行身份验证、授权、存储/检索数据、验证数据以及执行其他此类操作。
- en: This chapter explores the constructs that Angular provides for client-server
    interaction. In the process, we add a persistence layer to *Personal Trainer*
    that loads and saves data to a backend server.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了Angular提供的客户端-服务器交互的构造。在这个过程中，我们在*个人教练*中添加了一个持久层，用于从后端服务器加载数据和保存数据。
- en: 'The topics we cover in this chapter include the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: '**Provisioning a backend to persist workout data**: We set up a MongoLab account
    and use its Data API to access and store workout data.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供后端以持久化锻炼数据**：我们设置了一个MongoLab账户，并使用其数据API访问和存储锻炼数据。'
- en: '**Understanding the Angular HttpClient**: The `HttpClient` allows us to interact
    with a server over HTTP. You''ll learn how to make all types of `GET`, `POST`,
    `PUT`, and `DELETE` requests with the `HttpClient`.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解Angular HttpClient**：`HttpClient`允许我们通过HTTP与服务器交互。你将学习如何使用`HttpClient`进行所有类型的`GET`、`POST`、`PUT`和`DELETE`请求。'
- en: '**Implementing the loading and saving of workout data**: We use the `HTTPClient`
    to load and store workout data in the MongoLab databases.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现锻炼数据的加载和保存**：我们使用`HTTPClient`从MongoLab数据库中加载数据和存储锻炼数据。'
- en: '**Two ways in which we can use the HttpClient''s XMLHttpRequest**: Either Observables
    or with promises.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们可以使用HttpClient的XMLHttpRequest的两种方式**：要么是可观察对象，要么是承诺。'
- en: '**Using RxJS and Observables**: To subscribe to and query streams of data.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用RxJS和可观察对象**：用于订阅和查询数据流。'
- en: '**Using promises**: In this chapter, we will see how to use promises as part
    of HTTP invocation and response.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用承诺**：在本章中，我们将了解如何将承诺作为HTTP调用和响应的一部分来使用。'
- en: '**Working with cross-domain access**: As we are interacting with a MongoLab
    server in a different domain, you will learn about browser restrictions on cross-domain
    access. You will also learn how JSONP and CORS help us make cross-domain access
    easy and about Angular JSONP support.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理跨域访问**：由于我们正在与不同域的MongoLab服务器交互，你将了解浏览器对跨域访问的限制。你还将了解JSONP和CORS如何帮助我们轻松实现跨域访问，以及Angular对JSONP的支持。'
- en: Let's set the ball rolling.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Angular and server interactions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular和服务器交互
- en: Any client-server interaction typically boils down to sending HTTP requests
    to a server and receiving responses from a server. For heavy JavaScript apps,
    we depend on the AJAX request/response mechanism to communicate with the server.
    To support AJAX-based communication, Angular provides the Angular `HttpClient` module.
    Before we delve into the `HttpClient` module, we need to set up our server platform
    that stores the data and allows us to manage it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 任何客户端-服务器交互通常都归结为向服务器发送HTTP请求并从服务器接收响应。对于重型JavaScript应用程序，我们依赖于AJAX请求/响应机制与服务器通信。为了支持基于AJAX的通信，Angular提供了Angular
    `HttpClient`模块。在我们深入研究`HttpClient`模块之前，我们需要设置我们的服务器平台，该平台存储数据并允许我们管理它。
- en: Setting up the persistence store
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置持久存储
- en: For data persistence, we use a document database called MongoDB ([https://www.mongodb.com/](https://www.mongodb.com/)),
    hosted over MongoLab ([https://www.mlab.com/](https://www.mlab.com/)), as our
    data store. The reason we zeroed in on MongoLab is that it provides an interface
    to interact with the database directly. This saves us the effort of setting up
    server middleware to support MongoDB interaction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据持久性，我们使用一个名为MongoDB的文档数据库（[https://www.mongodb.com/](https://www.mongodb.com/)），它托管在MongoLab（[https://www.mlab.com/](https://www.mlab.com/)）上，作为我们的数据存储。我们之所以选择MongoLab，是因为它提供了一个直接与数据库交互的接口。这节省了我们设置支持MongoDB交互的服务器中间件的精力。
- en: It is never a good idea to expose the data store/database directly to the client.
    But in this case, since our primary aim is to learn about Angular and client-server
    interaction, we take this liberty and directly access the MongoDB instance hosted
    in MongoLab. There is also a new breed of apps that are built over **noBackend**
    solutions. In such a setup, frontend developers build apps without the knowledge
    of the exact backend involved. Server interaction is limited to making API calls
    to the backend. If you are interested in knowing more about these noBackend solutions,
    do check out [http://nobackend.org/](http://nobackend.org/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将数据存储/数据库暴露给客户端从来不是一个好主意。但在这种情况下，由于我们的主要目标是学习Angular和客户端-服务器交互，我们采取了这个自由，并直接访问MongoLab上托管的MongoDB实例。还有一种新的应用类型，它们是基于**无后端**解决方案构建的。在这种配置中，前端开发者构建应用时不需要了解确切的后端。服务器交互仅限于向后端发出API调用。如果您想了解更多关于这些无后端解决方案的信息，请查看[http://nobackend.org/](http://nobackend.org/)。
- en: 'Our first task is to provision an account on MongoLab and create a database:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是配置MongoLab上的账户并创建一个数据库：
- en: Go to [https://mlab.com](https://mlab.com) and sign up for an mLab account by
    following the instructions on the website
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://mlab.com](https://mlab.com)，按照网站上的说明注册一个mLab账户
- en: Once the account is provisioned, log in and create a new Mongo database by clicking
    on the Create New button on the home page
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦账户配置完成，登录并点击主页上的“创建新数据库”按钮来创建一个新的Mongo数据库
- en: 'On the database creation screen, you need to make some selections to provision
    the database. See the following screenshot to select the free database tier and
    other options:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库创建屏幕上，您需要做一些选择以配置数据库。请参阅以下截图以选择免费数据库层和其他选项：
- en: '![](img/00052.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00052.jpeg)'
- en: Create the database and make a note of the database name that you create
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库并记下您创建的数据库名称
- en: 'Once the database is provisioned, open the database and add two collections
    to it from the Collection tab:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库配置完成后，打开数据库，并从“集合”标签页添加两个集合：
- en: '`exercises`: This stores all *Personal Trainer* exercises'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises`：这个存储所有**个人训练师**的锻炼内容'
- en: '`workouts`: This stores all *Personal Trainer* workouts'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workouts`：这个存储所有**个人训练师**的锻炼内容'
- en: Collections in the MongoDB world equate to a database table.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB世界中，集合等同于数据库表。
- en: MongoDB belongs to a breed of databases called **document databases**. The central
    concepts here are documents, attributes, and their linkages. And unlike traditional
    databases, the schema is not rigid. We will not be covering what document databases
    are and how to perform data modeling for document-based stores in this book. *Personal
    Trainer* has a limited storage requirement and we manage it using the two previously
    mentioned document collections. We may not even be using the document database
    in its true sense.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB属于一种称为**文档数据库**的数据库类型。这里的核心概念是文档、属性及其链接。与传统数据库不同，模式不是刚性的。我们不会在本书中介绍文档数据库是什么以及如何为基于文档的存储执行数据建模。**个人训练师**有有限的存储需求，我们使用前面提到的两个文档集合来管理它。我们甚至可能没有真正使用文档数据库。
- en: Once the collections are added, add yourself as a user to the database from
    the Users tab.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 集合添加后，从“用户”标签页将您自己添加到数据库中。
- en: 'The next step is to determine the API key for the MongoLab account. The provisioned
    API key has to be appended to every request made to MongoLab. To get the API key,
    perform the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确定MongoLab账户的API密钥。配置的API密钥必须附加到对MongoLab发出的每个请求中。要获取API密钥，请执行以下步骤：
- en: Click on the username (not the account name) in the top-right corner to open
    the user profile.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的用户名（而不是账户名称）以打开用户资料。
- en: In the section titled API Key, the current API key is displayed; copy it. At
    the same time, click on the button below the API key to Enable Data API access.
    This is disabled by default.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标题为“API密钥”的部分，显示了当前的API密钥；复制它。同时，点击API密钥下方的按钮以启用数据API访问。默认情况下，这是禁用的。
- en: The data store schema is complete. We now need to seed these collections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储模式已完整。我们现在需要为这些集合进行初始化。
- en: Seeding the database
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库初始化
- en: The *Personal Trainer* app already has a predefined workout and a list of 12
    exercises. We need to seed the collections with this data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**个人训练师**应用已经预定义了一个锻炼计划和12个锻炼的列表。我们需要用这些数据初始化集合。'
- en: Open `seed.js` in the `trainer/db` folder for checkpoint 5.1 from the companion
    code base. It contains the seed JSON script and detailed instructions on how to
    seed data into the MongoLab database instance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `seed.js` 文件，位于 `trainer/db` 文件夹中，这是从配套代码库中 5.1 检查点的文件。它包含种子 JSON 脚本以及如何将数据种子到
    MongoLab 数据库实例的详细说明。
- en: 'Once seeded, the database will have one workout in the workouts collection
    and 12 exercises in the exercises collection. Verify this on the MongoLab site;
    the collections should show the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化，数据库将在 workouts 集合中有一个锻炼项目，在 exercises 集合中有 12 个练习项目。请在 MongoLab 网站上验证这一点；集合应显示以下内容：
- en: '![](img/00053.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: Everything has been set up now, so let's start our discussion of the `HttpClient` module
    and implement workout/exercise persistence for the *Personal Trainer* app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经设置好了，让我们开始讨论 `HttpClient` 模块，并为 *Personal Trainer* 应用程序实现锻炼/练习的持久化。
- en: The basics of the HTTPClient module
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPClient 模块的基础知识
- en: At the core of the `HTTPClient` module is the `HttpClient`. It performs HTTP
    requests using `XMLHttpRequest` as the default backend (JSONP is also available,
    as we will see later in this chapter). It supports requests such as `GET`, `POST`,
    `PUT`, and `DELETE`. In this chapter, we will use the `HttpClient` to make all
    of these types of requests. As we will see, the `HttpClient` makes it easy to
    make these calls with a minimal amount of setup and complexity. None of this terminology
    will come as a surprise to anyone who has previously worked with Angular or built
    JavaScript applications that communicate with a backend data store.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPClient` 模块的核心是 `HttpClient`。它使用 `XMLHttpRequest` 作为默认的后端（JSONP 也可用，我们将在本章后面看到）。它支持
    `GET`、`POST`、`PUT` 和 `DELETE` 等请求。在本章中，我们将使用 `HttpClient` 来执行所有这些类型的请求。正如我们将看到的，`HttpClient`
    使得以最小的设置和复杂性进行这些调用变得容易。对于之前使用过 Angular 或构建与后端数据存储通信的 JavaScript 应用程序的人来说，这些术语都不会感到惊讶。'
- en: However, there is a substantial change in the way Angular handles HTTP requests.
    Calling a request now returns an Observable of HTTP responses. It does so by using
    the RxJS library, which is a well-known open source implementation of the asynchronous
    Observable pattern.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Angular 处理 HTTP 请求的方式发生了重大变化。现在调用请求会返回一个 HTTP 响应的 Observable。它是通过使用 RxJS
    库来实现的，RxJS 是一个众所周知的异步 Observable 模式的开源实现。
- en: You can find the RxJS project on GitHub at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS).
    The site indicates that the project is being actively developed by Microsoft in
    collaboration with a community of open source developers. We will not be covering
    the asynchronous Observable pattern in great detail here, and we encourage you
    to visit that site to learn more about the pattern and how RxJS implements it.
    The version of RxJS that Angular is using is beta 5.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到 RxJS 项目，网址为 [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)。网站表明，该项目正在由微软与一群开源开发者合作积极开发。我们在此不会详细介绍异步
    Observable 模式，并鼓励您访问该网站以了解更多关于该模式以及 RxJS 如何实现它的信息。Angular 使用的 RxJS 版本是 beta 5。
- en: In the simplest of terms, using Observables allows a developer to think about
    the data that flows through an application as streams of information that the
    application can dip into and use whenever it wants. These streams change over
    time, which allows the application to react to these changes. This quality of
    Observables provides a foundation for **functional reactive programming** (**FRP**),
    which fundamentally shifts the paradigm for building web applications from imperative
    to reactive.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用 Observables 允许开发者将应用程序中流动的数据视为信息流，应用程序可以随时从中抽取和使用。这些流随时间变化，这使得应用程序能够对这些变化做出反应。Observables
    的这种特性为 **函数式响应式编程**（**FRP**）提供了基础，这从根本上改变了构建 Web 应用程序的模式，从命令式转变为响应式。
- en: The `RxJS` library provides operators that allow you to subscribe to and query
    these data streams. Moreover, you can easily mix and combine them, as we will
    see in this chapter. Another advantage of Observables is that it is easy to cancel
    or unsubscribe from them, making it possible to seamlessly handle errors inline.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxJS` 库提供了允许您订阅和查询这些数据流的操作符。此外，您可以轻松混合和组合它们，正如我们将在本章中看到的。Observables 的另一个优点是取消或取消订阅它们很容易，这使得可以无缝地在线处理错误。'
- en: While it is still possible to use promises, the default method in Angular uses
    Observables. We will also cover promises in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Angular 中仍然可以使用 Promise，但默认的方法是使用 Observables。我们也将在本章中介绍 Promise。
- en: Personal Trainer and server integration
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人训练师和服务器集成
- en: As described in the previous section, client-server interaction is all about
    asynchronicity. As we alter our *Personal Trainer* app to load data from the server,
    this pattern becomes self-evident.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，客户端-服务器交互完全是关于异步的。当我们修改我们的*个人训练师*应用程序以从服务器加载数据时，这种模式变得显而易见。
- en: In the previous chapter, the initial set of workouts and exercises was hardcoded
    in the `WorkoutService` implementation. Let's see how to load this data from the
    server first.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，初始的锻炼和练习集合被硬编码在`WorkoutService`实现中。让我们看看如何首先从服务器加载数据。
- en: Loading exercise and workout data
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载锻炼和训练数据
- en: Earlier in this chapter, we seeded our database with a data form, the `seed.js`
    file. We now need to render this data in our views. The MongoLab Data API is going
    to help us here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，我们使用数据表单，即`seed.js`文件，对数据库进行了初始化。我们现在需要在我们的视图中呈现这些数据。MongoLab数据API将帮助我们在这里。
- en: The MongoLab Data API uses an API key to authenticate access requests. Every
    request made to the MongoLab endpoints needs to have a query string parameter,
    `apikey=<key>`, where `key` is the API key that we provisioned earlier in the
    chapter. Remember that the key is always provided to a user and associated with
    their account. Avoid sharing your API keys with others.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: MongoLab数据API使用API密钥来验证访问请求。对MongoLab端点发出的每个请求都需要有一个查询字符串参数，`apikey=<key>`，其中`key`是我们在本章早期提供的API密钥。请记住，密钥始终提供给用户并与他们的账户相关联。避免与他人共享您的API密钥。
- en: 'The API follows a predictable pattern to query and update data. For any MongoDB
    collection, the typical endpoint access pattern is one of the following (given
    here is the base URL: [https://api.mongolab.com/api/1/databases](https://api.mongolab.com/api/1/databases)):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该API遵循可预测的模式来查询和更新数据。对于任何MongoDB集合，典型的端点访问模式如下（以下给出的是基本URL：[https://api.mongolab.com/api/1/databases](https://api.mongolab.com/api/1/databases)）：
- en: '`/<dbname>/collections/<name>?apiKey=<key>`: This has the following requests:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/<dbname>/collections/<name>?apiKey=<key>`：以下请求如下：'
- en: '`GET`: This action gets all objects in the given collection name.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：此操作获取给定集合名称中的所有对象。'
- en: '`POST`: This action adds a new object to the collection name. MongoLab has
    an `_id` property that uniquely identifies the document (object). If not provided
    in the posted data, it is auto-generated.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：此操作向集合名称添加一个新的对象。MongoLab有一个`_id`属性，该属性唯一标识文档（对象）。如果未在提交的数据中提供，则自动生成。'
- en: '`/<dbname>/collections/<name>/<id>?apiKey=<key>`: This has the following requests:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/<dbname>/collections/<name>/<id>?apiKey=<key>`：以下请求如下：'
- en: '`GET`: This gets a specific document/collection item with a specific ID (a
    match done on the `_id` property) from the collection name.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：此操作从集合中获取具有特定ID（在`_id`属性上执行匹配）的特定文档/集合项。'
- en: '`PUT`: This updates the specific item (`id`) in the collection name.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：此操作更新集合名称中的特定项（`id`）。'
- en: '`DELETE`: This deletes the item with a specific ID from the collection name.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：此操作从集合名称中删除具有特定ID的项目。'
- en: For more details on the Data API interface, visit the MongoLab Data API documentation
    at [http://docs.mlab.com/data-api](http://docs.mlab.com/data-api).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据API接口的更多详细信息，请访问MongoLab数据API文档，网址为[http://docs.mlab.com/data-api](http://docs.mlab.com/data-api)。
- en: Now we are in a position to start implementing exercise/workout list pages.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始实现锻炼/训练列表页面。
- en: 'The code that we are starting with in this chapter is `checkpoint 4.6` (folder:
    `trainer`) in the GitHub repository for this book. It is available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)).
    Checkpoints are implemented as branches in GitHub. If you are not using Git, download
    the snapshot of checkpoint 4.6 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint4.6](https://github.com/chandermani/angular6byexample/tree/checkpoint4.6).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时使用的代码是GitHub上本书的`checkpoint 4.6`（文件夹：`trainer`）。它在GitHub上可用（[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)）。检查点作为GitHub上的分支实现。如果您不使用Git，请从以下GitHub位置下载`checkpoint
    4.6`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint4.6](https://github.com/chandermani/angular6byexample/tree/checkpoint4.6)。在第一次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Loading exercise and workout lists from a server
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器加载锻炼和训练列表
- en: 'To pull exercise and workout lists from the MongoLab database, we have to rewrite
    our `WorkoutService` service methods: `getExercises` and `getWorkouts`. But before
    we can do that, we have to set up our service to work with Angular''s HTTPClient
    module.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要从MongoLab数据库中拉取锻炼和训练列表，我们必须重写我们的`WorkoutService`服务方法：`getExercises`和`getWorkouts`。但在我们能够这样做之前，我们必须设置我们的服务以使用Angular的HTTPClient模块。
- en: Adding the HTTPClient module and RxJS to our project
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将HTTPClient模块和RxJS添加到我们的项目中
- en: 'The Angular HTTPClient module is included in the Angular bundles that you have
    already installed. To use it, we need to import it into `app.module.ts,` like
    so (make sure that the import follows `BrowserModule`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Angular HTTPClient模块包含在你已经安装的Angular包中。为了使用它，我们需要将其导入到`app.module.ts`中，如下所示（确保导入遵循`BrowserModule`）：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We also need an external third-party library: **Reactive Extensions for JavaScript**
    (**RxJS**). RxJS implements the Observable pattern and it is used by Angular with
    the HTTPClient module. It is included in the Angular bundles that are already
    part of our project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个外部第三方库：**JavaScript的响应式扩展（RxJS**）。RxJS实现了可观察模式，并且与HTTPClient模块一起由Angular使用。它包含在我们项目中的Angular包中。
- en: Updating workout-service to use the HTTPClient module and RxJS
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新workout-service以使用HTTPClient模块和RxJS
- en: 'Open  `workout.service.ts` from `trainer/src/app/core`. In order to use the
    HTTPClient and RxJS within the `WorkoutService`, we need to add the following
    imports to that file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从`trainer/src/app/core`打开`workout.service.ts`。为了在`WorkoutService`中使用HTTPClient和RxJS，我们需要将该文件中添加以下导入：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are importing the `HTTPClient` module along with `Observable` from RxJS and
    one additional RxJS operator: `catchError`. We'll see how this operator is used
    as we work through the code in this section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导入`HTTPClient`模块以及来自RxJS的`Observable`和一个额外的RxJS操作符：`catchError`。我们将看到这个操作符是如何在本节中使用的。
- en: 'In the class definition, add the following properties, which include a workout
    property and ones that set the URL for the collections in our Mongo database and
    the key to that database as well as another property: `params`, which sets up
    the API key as a query string for API access:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义中，添加以下属性，包括一个锻炼属性以及设置我们Mongo数据库中集合的URL和数据库的键的属性，以及另一个属性：`params`，它设置API密钥作为API访问的查询字符串：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Replace the `<dbname>` and `<key>` tokens with the database name and API key
    of the database that we provisioned earlier in the chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将`<dbname>`和`<key>`令牌替换为我们在本章前面配置的数据库的名称和API密钥。
- en: 'Next, inject the HTTPClient module into the `WorkoutServiceconstructor` using
    the following line of code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下代码行将HTTPClient模块注入到`WorkoutService`构造函数中：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then change the `getExercises()` method to the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`getExercises()`方法更改为以下内容：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you are used to working with promises for asynchronous data operations, what
    you see here will look different. Instead of a promise that has a call to `then()`
    chained to it, what happens here is that the `http.get` method returns an Observable from
    the RxJS library. Notice that we are also setting the response to be of type `<ExercisePlan>` to
    make explicit to our upstream callers what type of Observable is being returned
    from our HTTP GET call.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于使用承诺（promises）进行异步数据操作，这里看到的内容将看起来不同。这里发生的情况不是将一个调用`then()`的承诺链在一起，而是`http.get`方法返回一个来自RxJS库的可观察对象。注意，我们还在将响应设置为`<ExercisePlan>`类型，以便明确告诉我们的上游调用者从我们的HTTP
    GET调用返回的是哪种类型的可观察对象。
- en: Returning an Observable is the default response when using the `HTTPClient`
    module's `get` method. The Observable can, however, be converted to a promise.
    And, as we will see later in this chapter, the option to return JSONP also exists.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HTTPClient`模块的`get`方法时，返回一个可观察对象（Observable）是默认响应。然而，可观察对象可以被转换为一个承诺（promise）。而且，正如我们将在本章后面看到的那样，返回JSONP的选项也存在。
- en: 'Before we move on, there is one more thing to touch upon in this code. Notice
    that we are using a pipe method to add a `catchError` operator. This operator
    accepts a method, `handleError`, for handling a failed response. The `handleError`
    method takes the failed response as a parameter. We log the error to the console
    and use `Observable.throw` to return the error to the consumer:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，还有一件事情需要提及。注意，我们正在使用一个管道方法来添加一个`catchError`操作符。这个操作符接受一个方法`handleError`来处理失败的响应。`handleError`方法接受失败的响应作为参数。我们将错误记录到控制台，并使用`Observable.throw`将错误返回给消费者：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To be clear, this is not production code, but it will give us the opportunity
    to show how to write code upstream to handle errors that are generated as part
    of data access.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 明确一点，这并不是生产代码，但它将给我们机会展示如何在上游编写代码来处理数据访问过程中生成的错误。
- en: It is important to understand that at this stage no data is flowing through
    the Observable until there is a subscription to it. This can bring about a gotcha
    moment for things such as adds and updates if you are not careful to add subscriptions
    to your Observables.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的是，在这个阶段，如果没有对 Observable 进行订阅，那么 Observable 中不会有数据流动。如果你没有仔细添加订阅到你的 Observables，这可能会导致添加和更新等操作出现意外情况。
- en: Modifying getWorkouts() to use the HTTPClient module
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 `getWorkouts()` 方法修改为使用 HTTPClient 模块
- en: 'The change in the code for retrieving workouts is almost identical to that
    for the exercises:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 获取锻炼数据的代码更改几乎与获取练习数据的代码相同：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again we are specifying the type of Observable—in this case `<WorkoutPlan[]>`—that
    will be returned by our HTTP GET call and using `pipe` to add a `catchError` operator.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次明确，我们指定了 Observable 的类型——在这个例子中是 `<WorkoutPlan[]>`——它将由我们的 HTTP GET 调用返回，并使用
    `pipe` 添加一个 `catchError` 操作符。
- en: Now that the `getExercises` and `getWorkouts` methods are updated, we need to
    make sure that they work with the upstream callers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`getExercises` 和 `getWorkouts` 方法已经更新，我们需要确保它们与上游调用者兼容。
- en: Updating the workout/exercise list pages
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新锻炼/练习列表页面
- en: 'The exercise and workout list pages (as well as `LeftNavExercises`) call either
    the `getExercises` or `getWorkouts` method in `model.ts`. In order to get these
    working with the remote calls that are now being made using the `HTTPClient` module,
    we need to modify those calls to subscribe to the Observable that is being returned
    by the `HTTPClient` module. So, update the code in the `ngOnInit` method in `exercises.component.ts`
    to the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 练习和锻炼列表页面（以及 `LeftNavExercises`）在 `model.ts` 中调用 `getExercises` 或 `getWorkouts`
    方法。为了使这些调用与现在使用 `HTTPClient` 模块进行的远程调用兼容，我们需要修改这些调用以订阅由 `HTTPClient` 模块返回的 Observable。因此，将
    `exercises.component.ts` 中的 `ngOnInit` 方法代码更新如下：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our method now subscribes to the Observable that is being returned by the `getExercises`
    method; at the point when the response arrives, it assigns the results to `exerciseList`.
    If there is an error, it assigns it to a `console.error` call that displays the
    error in the console. All of this is now being handled asynchronously using the
    `HTTPClient` module with RxJS.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法现在订阅了由 `getExercises` 方法返回的 Observable；当响应到达时，它将结果分配给 `exerciseList`。如果有错误，它将错误分配给一个
    `console.error` 调用，在控制台中显示错误。所有这些现在都是使用 `HTTPClient` 模块和 RxJS 异步处理的。
- en: Go ahead and make similar changes to the `ngOnInit` methods in `workouts.component.ts`
    and `left-nav-exercises.component.ts`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对 `workouts.component.ts` 和 `left-nav-exercises.component.ts` 中的 `ngOnInit`
    方法进行类似的修改。
- en: Refresh the workout/exercise list page and the workout and exercise data will
    be loaded from the database server.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新锻炼/练习列表页面，锻炼和练习数据将从数据库服务器加载。
- en: Look at the complete implementation in checkpoint 5.1 in the GitHub repository
    if you are having difficulty in retrieving/showing data. Note that in this checkpoint,
    we have disabled navigation links to the workout and exercise screens because
    we still have to add the Observable implementation to them. We'll do that in the
    next section. Also remember to replace the database name and API key before you
    run the code from `Checkpoint 5.1`. If you are not using Git, download the snapshot
    of `Checkpoint 5.1` (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.1](https://github.com/chandermani/angular6byexample/tree/checkpoint5.1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 GitHub 仓库中难以检索/显示数据，请查看第 5.1 个检查点的完整实现。注意，在这个检查点中，我们已禁用导航链接到锻炼和练习屏幕，因为我们还需要向它们添加
    Observable 实现。我们将在下一节中完成这项工作。此外，记得在运行 `Checkpoint 5.1` 中的代码之前替换数据库名称和 API 密钥。如果你不使用
    Git，可以从以下 GitHub 位置下载 `Checkpoint 5.1` 的快照（ZIP 文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.1](https://github.com/chandermani/angular6byexample/tree/checkpoint5.1)。在设置快照时，请参考
    `trainer` 文件夹中的 `README.md` 文件。
- en: 'This looks good and the lists are loading fine. Well, almost! There is a small
    glitch in the workout list page. We can easily spot it if we look carefully at
    any list item (in fact, there is only one item):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错，列表加载也正常。嗯，几乎是这样！在锻炼列表页面上有一个小故障。如果我们仔细查看任何列表项（实际上只有一个项），就可以轻松地发现它：
- en: '![](img/00054.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: The workout duration calculations are not working anymore! What could be the
    reason? We need to look back at how these calculations were implemented. The `WorkoutPlan`
    service (in `model.ts`) defines a `totalWorkoutDuration` method that does the
    math for this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼时长计算不再起作用了！可能的原因是什么？我们需要回顾一下这些计算是如何实现的。`WorkoutPlan`服务（在`model.ts`中）定义了一个`totalWorkoutDuration`方法来完成这个计算。
- en: The difference is in the workout array that is bound to the view. In the previous
    chapter, we created the array with model objects that were created using the `WorkoutPlan`
    service. But now, since we are retrieving data from the server, we bind a simple
    array of JavaScript objects to the view, which for obvious reasons has no calculation
    logic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 差异在于绑定到视图的锻炼数组。在前一章中，我们使用`WorkoutPlan`服务创建了一个包含模型对象的数组。但现在，由于我们从服务器检索数据，我们绑定了一个简单的JavaScript对象数组到视图，这显然没有计算逻辑。
- en: We can fix this problem by mapping a server response to our model class objects
    and returning them to any upstream caller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将服务器响应映射到我们的模型类对象并将它们返回给任何上游调用者来解决这个问题。
- en: Mapping server data to application models
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务器数据映射到应用程序模型
- en: Mapping server data to our model and vice versa may be unnecessary if the model
    and server storage definition match. If we look at the `Exercise` model class
    and the seed data that we have added for the exercise in MongoLab, we will see
    that they do match and hence mapping becomes unnecessary.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型和服务器存储定义匹配，则将服务器数据映射到我们的模型以及反之亦然可能是不必要的。如果我们查看`Exercise`模型类和我们在MongoLab中为锻炼添加的种子数据，我们会看到它们是匹配的，因此映射变得不必要。
- en: 'Mapping a server response to the model data becomes imperative if:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务器响应映射到模型数据变得至关重要，如果：
- en: Our model defines any methods
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们模型定义了任何方法
- en: A stored model is different from its representation in code
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储的模型与其代码表示不同
- en: The same model class is used to represent data from different sources (this
    can happen for mashups, where we pull data from disparate sources)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的模型类来表示来自不同来源的数据（这可能在混合应用中发生，我们从不同的来源获取数据）
- en: 'The `WorkoutPlan` service is a prime example of an impedance mismatch between
    a model representation and its storage. Look at the following screenshot to understand
    these differences:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutPlan`服务是一个模型表示与其存储之间阻抗不匹配的典型例子。查看以下截图以了解这些差异：'
- en: '![](img/00055.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: 'The two major differences between the model and server data are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 模型和服务器数据之间的两个主要差异如下：
- en: The model defines the `totalWorkoutDuration` method.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型定义了`totalWorkoutDuration`方法。
- en: The `exercises` array representation also differs. The `exercises` array of
    the model contains the full `Exercise` object, while the server data stores just
    the exercise identifier or name.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises`数组表示也各不相同。模型的`exercises`数组包含完整的`Exercise`对象，而服务器数据只存储锻炼标识符或名称。'
- en: This clearly means that loading and saving a workout requires model mapping.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然意味着加载和保存锻炼需要模型映射。
- en: The way we will do this is by adding another operator to transform the Observable
    response object. So far, we have only returned a plain JavaScript object as the
    response. The nice thing is that the pipe method that we used to add error handling
    also allows us to add additional operators that we can use to transform the JavaScript
    object into the `WorkoutPlan` type in our model.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加另一个操作符来转换Observable响应对象来实现这一点。到目前为止，我们只返回了一个普通的JavaScript对象作为响应。好事是，我们用来添加错误处理的pipe方法还允许我们添加额外的操作符，我们可以使用这些操作符将JavaScript对象转换为我们模型中的`WorkoutPlan`类型。
- en: 'Let''s rewrite the `getWorkouts` method in the `workout-service.ts` file to
    the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`workout-service.ts`文件中重写`getWorkouts`方法如下：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have added a  `map` operator that transforms this Observable into one made
    up of `WorkoutPlan` objects. Each `WorkoutPlan` object (we have only one at the
    moment) will then have the `totalWorkoutDuration` method that we need.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`map`操作符，将这个Observable转换成一个由`WorkoutPlan`对象组成的Observable。然后，每个`WorkoutPlan`对象（目前我们只有一个）都将拥有我们需要的`totalWorkoutDuration`方法。
- en: Looking at the code you can see that we operate on the JSON results HTTPClient
    response, which is why we are using the `<any>` type. And then we create a typed
    array of `WorkoutPlans` and iterate through the first array using a fat arrow
    `forEach` function, assigning each JavaScript object to a `WorkoutPlan` object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码，你可以看到我们操作的是HTTPClient响应的JSON结果，这就是为什么我们使用`<any>`类型。然后我们创建一个`WorkoutPlans`的类型化数组，并使用箭头函数`forEach`遍历第一个数组，将每个JavaScript对象分配给一个`WorkoutPlan`对象。
- en: We return the results of these mappings to the callers that subscribe to them,
    `workouts.component.ts` in this case. We have also updated the `catchError` operator
    with a new `handleError` method which you can find in `Checkpoint 5.2`. The callers
    do not need to make any changes to the code they use to subscribe to our workouts
    Observable. Instead, the model mapping can take place at one spot in the application
    and then be used throughout it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些映射的结果返回给订阅它们的调用者，在这种情况下是`workouts.component.ts`。我们还更新了`catchError`操作符，使用了一个新的`handleError`方法，你可以在`Checkpoint
    5.2`中找到它。调用者不需要对其用于订阅我们的锻炼Observable的代码进行任何更改。相反，模型映射可以在应用程序的一个位置进行，然后在整个应用程序中使用。
- en: 'If you rerun the application, you will see that the total number of seconds
    now displays properly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新运行应用程序，你会看到现在总秒数显示正确：
- en: '![](img/00056.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00056.jpeg)'
- en: 'Checkpoint 5.2 in the GitHub repository contains the working implementation
    for what we have covered so far. The GitHub branch is `checkpoint5.2` (folder:
    `trainer`).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub仓库中的Checkpoint 5.2包含了我们到目前为止所涵盖的完整实现。GitHub分支是`checkpoint5.2`（文件夹：`trainer`）。
- en: Loading exercise and workout data from the server
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器加载锻炼和锻炼数据
- en: Just as we fixed the `getWorkouts` implementation in `WorkoutService` earlier,
    we can implement other get operations for exercise- and workout-related stuff.
    Copy the service implementation for the `getExercise` and `getWorkout` methods
    of `WorkoutService` from `workout.service.ts` in the `trainer/src/app/core` folder
    in checkpoint 5.2.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的`WorkoutService`中修复了`getWorkouts`实现一样，我们可以为与锻炼和锻炼相关的其他get操作实现。从`checkpoint
    5.2`中的`trainer/src/app/core`文件夹中的`workout.service.ts`复制`getExercise`和`getWorkout`方法的实现。
- en: The `getWorkout` and `getExercise` methods use the name of the workout/exercise
    to retrieve results. Every MongoLab collection item has an `_id` property that
    uniquely identifies the item/entity. In the case of our `Exercise` and `WorkoutPlan`
    objects, we use the name of the exercise for unique identification. Hence, the
    `name` and `_id` property of each object always match.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWorkout`和`getExercise`方法使用锻炼/锻炼的名称来检索结果。每个MongoLab集合项都有一个`_id`属性，该属性唯一标识了项/实体。在我们的`Exercise`和`WorkoutPlan`对象的情况下，我们使用锻炼的名称进行唯一标识。因此，每个对象的`name`和`_id`属性总是匹配的。'
- en: 'At this point, we will need to add one more import to `workout.service.ts`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要在`workout.service.ts`中添加一个额外的导入：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This import brings in the `forkJoin` operator, which we will be discussing shortly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入引入了`forkJoin`操作符，我们将在稍后讨论。
- en: 'Pay special attention to the implementation for the `getWorkout` method because
    there is a decent amount of data transformation happening due to the model and
    data storage format mismatch. This is how the `getWorkout` method now looks:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意`getWorkout`方法的实现，因为由于模型和数据存储格式不匹配，这里会发生相当数量的数据转换。这就是`getWorkout`方法现在的样子：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is a lot happening inside `getWorkout` that we need to understand.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWorkout`方法内部发生了很多事情，我们需要理解。'
- en: 'The `getWorkout` method uses Observable and its `forkJoin` operator to return
    two Observable objects: one that retrieves the `Workout` and another that retrieves
    a list of all the `Exercises`. What is interesting about the `forkJoin` operator
    is that not only does it allow us to return multiple Observable streams, but it
    also waits until both Observable streams have retrieved their data before further
    processing the results. In other words, it enables us to stream the responses
    from multiple concurrent HTTP requests and then operate on the combined results.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWorkout`方法使用Observable及其`forkJoin`操作符来返回两个Observable对象：一个用于检索`Workout`，另一个用于检索所有`Exercises`的列表。`forkJoin`操作符有趣的地方在于，它不仅允许我们返回多个Observable流，而且在进一步处理结果之前，它还会等待两个Observable流都检索到它们的数据。换句话说，它使我们能够从多个并发HTTP请求中流式传输响应，然后对组合结果进行操作。'
- en: Once we have the `Workout` details and the complete list of exercises, we then
    `pipe` the results to the `map` operator (which we saw previously with the code
    for the `Workouts` list), which we use to change the `exercises` array of the
    workout to the correct `Exercise` class object. We do this by searching the `allExercises`
    Observable for the name of the exercise in the `workout.exercises` array returned
    from the server, and then assigning the matching exercise to the workout services
    array. The end result is that we have a complete `WorkoutPlan` object with the
    `exercises` array set up correctly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `Workout` 详细信息和完整的锻炼列表，我们就将结果通过 `pipe` 传输到 `map` 操作符（我们之前在 `Workouts`
    列表代码中看到过），我们使用它来将锻炼的 `exercises` 数组转换为正确的 `Exercise` 类对象。我们通过在 `allExercises`
    Observable 中搜索从服务器返回的 `workout.exercises` 数组中的锻炼名称来实现这一点，然后将匹配的锻炼分配给锻炼服务数组。最终结果是，我们有一个完整的
    `WorkoutPlan` 对象，其 `exercises` 数组已正确设置。
- en: These `WorkoutService` changes warrant fixes in upstream callers too. We have
    already fixed the lists of exercises in the `LeftNavExercises` and `Exercises`
    components and the workouts in the `Workouts` component. Now let's fix the `Workout`
    and `Exercise` components along similar lines. The `getWorkout` and `getExercise`
    methods in the workout services are not directly called by these components, but
    by builder services. So we'll have to fix the builder services together with the
    `Workout` and `Exercise` components and the two resolvers—`WorkoutResolver` and
    `ExerciseResolver`—that we have added to the routes for these components.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对 `WorkoutService` 的更改也要求上游调用者进行修复。我们已经修复了 `LeftNavExercises` 和 `Exercises`
    组件中的锻炼列表以及 `Workouts` 组件中的锻炼。现在让我们按照类似的方式修复 `Workout` 和 `Exercise` 组件。锻炼服务中的 `getWorkout`
    和 `getExercise` 方法不是直接由这些组件调用，而是由构建服务调用。因此，我们将不得不与 `Workout` 和 `Exercise` 组件以及两个解析器——`WorkoutResolver`
    和 `ExerciseResolver`——一起修复，我们将这些解析器添加到这些组件的路由中。
- en: Fixing the builder services
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复构建服务
- en: 'Now that we have `WorkoutService` set up to retrieve a workout from our remote
    data store, we have to modify `WorkoutBuilderService` to be able to retrieve that
    workout as an Observable. The method that pulls the `Workout` details is `startBuilding`.
    In order to do that, we will break the current `startBuilding` method into two
    methods, one for new workouts and one for existing workouts that we have retrieved
    from the server. Here is the code for new workouts:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 `WorkoutService` 来从我们的远程数据存储中检索锻炼，我们必须修改 `WorkoutBuilderService` 以能够将那个锻炼作为一个
    Observable 检索。提取 `Workout` 详细信息的方法是 `startBuilding`。为了做到这一点，我们将当前的 `startBuilding`
    方法拆分为两个方法，一个用于新的锻炼，另一个用于我们从服务器检索到的现有锻炼。以下是新锻炼的代码：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For existing workouts, we add the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现有锻炼，我们添加以下代码：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We'll let you make the same fixes in `ExerciseBuilderService`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让您在 `ExerciseBuilderService` 中进行相同的修复。
- en: Updating the resolvers
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新解析器
- en: As we move on to using Observable types with our data access, we are going to
    have to make some adjustments to the resolvers that we have created for the routes
    leading to workout and exercise screens. We start with the `WorkoutResolver` in
    `workout-resolver.ts` that can be found in the `workout` folder.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用 Observable 类型与我们的数据访问一起使用时，我们将不得不对我们为通往锻炼和锻炼屏幕的路由创建的解析器进行一些调整。我们从 `workout-resolver.ts`
    中的 `WorkoutResolver` 开始，该文件位于 `workout` 文件夹中。
- en: 'First add the following imports from RxJs:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加以下来自 RxJs 的导入：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next update the `resolve` method as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来更新 `resolve` 方法如下：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we have split out the behavior for a new workout (one where
    there is no workout name being passed as a parameter in the URL) and that for
    an existing workout. In the former case, we call `workoutBuilderService.startBuildingExisting`,
    which will return a new `WorkoutPlan`. In the latter case, we call `workoutBuilderService.startBuildingExisting` and pipe
    the results and then map them to return the `workout` unless it is not found,
    in which case we route the user back to the `Workouts` screen.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经将新锻炼的行为（在 URL 参数中没有传递锻炼名称的情况）和现有锻炼的行为分开。在前一种情况下，我们调用 `workoutBuilderService.startBuildingExisting`，这将返回一个新的
    `WorkoutPlan`。在后一种情况下，我们调用 `workoutBuilderService.startBuildingExisting` 并将结果通过管道传输，然后映射以返回
    `workout`，除非找不到，在这种情况下，我们将用户路由回 `Workouts` 屏幕。
- en: Fixing the Workout and Exercise components
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复 `Workout` 和 `Exercise` 组件
- en: 'Once we have fixed the `WorkoutBuilderService` and the `WorkoutResolver`, there
    are actually no further fixes needed in the `WorkoutComponent`. All the work to
    handle the Observables has been done further downstream and all we need to do
    at this stage is subscribe to the route data and retrieve the workout as we have
    already been doing:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们修复了`WorkoutBuilderService`和`WorkoutResolver`，实际上在`WorkoutComponent`中就不再需要进一步的修复。处理Observables的所有工作已经在更下游完成，我们现在需要做的只是订阅路由数据并检索锻炼项目，就像我们之前所做的那样：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To test the implementation, uncomment the following highlighted code contained
    in the `onSelect` method within `workouts.component.ts`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试实现，取消注释以下在`workouts.component.ts`中的`onSelect`方法内高亮的代码：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then click on any existing workout, such as *7 Minute Workout*, from the list
    of workouts displayed at `/builder/workouts/`. The workout data should load successfully.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击列表中显示在`/builder/workouts/`的任何现有锻炼项目，例如*7分钟锻炼*。锻炼数据应该能够成功加载。
- en: The `ExerciseBuilderService` and `ExerciseResolver` also need fixing. `Checkpoint
    5.2` contains those fixes. You can copy those files or do it yourself and compare
    the implementation. And don't forget to uncomment the code in the `onSelect` method
    in `exercises.component.ts`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExerciseBuilderService`和`ExerciseResolver`也需要修复。`Checkpoint 5.2`包含了这些修复。你可以复制这些文件或自己进行修复，并比较实现。别忘了取消注释`exercises.component.ts`中的`onSelect`方法中的代码。'
- en: '`Checkpoint 5.2` in the GitHub repository contains the working implementation
    for what we have covered thus far. If you are not using Git, download the snapshot
    of Checkpoint 5.2 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.2](https://github.com/chandermani/angular6byexample/tree/checkpoint5.2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub仓库中的`Checkpoint 5.2`包含了到目前为止我们所涵盖的完整实现。如果你不使用Git，可以从以下GitHub位置下载Checkpoint
    5.2的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.2](https://github.com/chandermani/angular6byexample/tree/checkpoint5.2)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: It is now time to fix, create, and update scenarios for the exercises and workouts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候修复、创建和更新锻炼项目的场景了。
- en: Performing CRUD on exercises/workouts
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对锻炼/项目执行CRUD操作
- en: When it comes to create, read, update, and delete (CRUD) operations, all save,
    update, and delete methods need to be converted to the Observable pattern.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到创建、读取、更新和删除（CRUD）操作时，所有保存、更新和删除方法都需要转换为Observable模式。
- en: Earlier in the chapter, we detailed the endpoint access pattern for CRUD operations
    in a MongoLab collection. Head back to the *Loading exercise and workout data* section
    and revisit the access patterns. We need this now as we plan to create/update
    workouts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们详细介绍了在MongoLab集合中CRUD操作的端点访问模式。回到*加载锻炼和锻炼数据*部分，重新审视访问模式。我们现在需要这些信息，因为我们计划创建/更新锻炼项目。
- en: Before we start the implementation, it is important to understand how MongoLab
    identifies a collection item and what our ID generation strategy is. Each collection
    item in MongoDB is uniquely identified in the collection using the `_id` property.
    While creating a new item, either we supply an ID or the server generates one
    itself. Once `_id` is set, it cannot be changed. For our model, we will use the
    `name` property of the exercise/workout as the unique ID and copy the name into
    the `_id` field (hence, there is no autogeneration of `_id`). Also remember that
    our model classes do not contain this `_id` field; it has to be created before
    saving the record for the first time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现之前，了解MongoLab如何识别集合项以及我们的ID生成策略非常重要。在MongoDB中，每个集合项都通过`_id`属性在集合中唯一标识。在创建新项时，我们提供ID或服务器自动生成一个。一旦`_id`被设置，就不能更改。对于我们的模型，我们将使用锻炼/项目的`name`属性作为唯一ID，并将名称复制到`_id`字段（因此，没有自动生成`_id`）。还要记住，我们的模型类不包含这个`_id`字段；它必须在第一次保存记录之前创建。
- en: Let's fix the workout creation scenario first.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先修复锻炼创建场景。
- en: Creating a new workout
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的锻炼项目
- en: 'Taking the bottom-up approach, the first thing that needs to be fixed is `WorkoutService`.
    Update the `addWorkout` method as shown in the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 采用自下而上的方法，首先需要修复的是`WorkoutService`。按照以下代码更新`addWorkout`方法：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `getWorkout`, we had to map data from the server model to our client model;
    the reverse has to be done here. First, we create a new array for the exercises,
    `workoutExercises`, and then add to that array a version of the exercises that
    is more compact for server storage. We only want to store the exercise name and
    duration in the exercises array on the server (this array is of type `any` because
    in its compact format it does not conform to the `ExercisePlan` type).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getWorkout` 中，我们必须将服务器模型中的数据映射到我们的客户端模型中；这里需要做的是反向操作。首先，我们为锻炼创建一个新的数组 `workoutExercises`，然后向该数组添加一个更紧凑的版本，以便在服务器上存储。我们只想在服务器上的锻炼数组中存储锻炼名称和持续时间（此数组为
    `any` 类型，因为在其紧凑格式中它不符合 `ExercisePlan` 类型）。
- en: Next, we set up the body of our post by mapping these changes into a JSON object.
    Note that as part of constructing this object, we set the `_id` property as the
    name of the workout to uniquely identify it in the database of the workouts collection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将这些更改映射到一个 JSON 对象中，以此设置我们帖子的主体。请注意，在构建此对象的过程中，我们将 `_id` 属性设置为锻炼的名称，以便在锻炼集合的数据库中唯一标识它。
- en: The simplistic approach of using the *name* of the workout/exercise as a record
    identifier (or `id`) in MongoDB will break for any decent-sized app. Remember
    that we are creating a web-based application that can be accessed simultaneously
    by many users. Since there is always the possibility of two users coming up with
    the same name for a workout/exercise, we need a strong mechanism to make sure
    that names are not duplicated. Another problem with the MongoLab REST API is that
    if there is a duplicate `POST` request with the same `id` field, one will create
    a new document and the second will update it, instead of the second failing. This
    implies that any duplicate checks on the `id` field on the client side still cannot
    safeguard against data loss. In such a scenario, assigning auto generation of
    the `id` value is preferable. In standard cases where we are creating entities,
    unique ID generation is done on the server (mostly by the database). The response
    to when an entity is created then contains the generated ID. In such a case, we
    need to update the model object before we return data to the calling code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用锻炼/练习的 *名称* 作为记录标识符（或 `id`）在 MongoDB 中的简单方法对于任何中等规模的应用程序都会失效。请记住，我们正在创建一个可以由许多用户同时访问的基于
    Web 的应用程序。由于总有可能有两个用户为锻炼/练习想出相同的名称，我们需要一个强大的机制来确保名称不会重复。MongoLab REST API 的另一个问题是，如果有重复的
    `POST` 请求具有相同的 `id` 字段，第一个将创建一个新的文档，第二个将更新它，而不是第二个失败。这意味着在客户端对 `id` 字段的任何重复检查都无法防止数据丢失。在这种情况下，分配自动生成
    `id` 值是更好的选择。在标准情况下，当我们创建实体时，唯一 ID 的生成是在服务器上完成的（通常由数据库完成）。当实体创建时，响应将包含生成的 ID。在这种情况下，在将数据返回给调用代码之前，我们需要更新模型对象。
- en: Lastly, we call the `post` method of the `HTTPClient` module, passing the URL
    to connect to, an extra query string parameter (`apiKey`), and the data we are
    sending.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `HTTPClient` 模块的 `post` 方法，传递要连接的 URL、额外的查询字符串参数（`apiKey`）以及我们正在发送的数据。
- en: The last return statement should look familiar, as we use Observables to return
    the workout object as part of the Observable resolution. You need to be sure you add
    `.subscribe` to the Observable chain in order to make it work. We'll do that shortly
    by adding a subscription to the `save` method to `WorkoutComponent`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个返回语句应该看起来很熟悉，因为我们使用 Observables 将锻炼对象作为 Observable 解析的一部分返回。您需要确保在 Observable
    链中添加 `.subscribe` 以使其工作。我们将通过向 `WorkoutComponent` 的 `save` 方法添加订阅来实现这一点。我们将在稍后这样做。
- en: Updating a workout
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新锻炼
- en: 'Why not try to implement the update operation? The `updateWorkout` method can
    be fixed in the same manner, the only difference being that the `HTTPClient` module''s
    `put` method is required:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不尝试实现更新操作呢？`updateWorkout` 方法可以以相同的方式修复，唯一的区别是需要 `HTTPClient` 模块的 `put` 方法：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding request URL now contains an extra fragment (`workout.name`) that
    denotes the identifier of the collection item that needs to be updated.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的请求 URL 现在包含一个额外的片段（`workout.name`），表示需要更新的集合项的标识符。
- en: The MongoLab `PUT` API request creates the document passed in as the request
    body if the document is not found in the collection. While making the `PUT` request,
    make sure that the original record exists. We can do this by making a `GET` request
    for the same document first and confirming that we get a document before we update
    it. We'll leave that for you to implement.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: MongoLab的`PUT` API请求在集合中找不到文档时，会创建作为请求体传递的文档。在执行`PUT`请求时，请确保原始记录存在。我们可以通过首先对该文档执行`GET`请求并确认在更新之前我们得到了一个文档来实现这一点。我们将把这个留给你来实现。
- en: Deleting a workout
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除锻炼
- en: 'The last operation that needs to be fixed is deleting the workout. Here is
    a simple implementation where we call the `HTTPClient` module''s `delete` method
    to delete the workout referenced by a specific URL:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 需要修复的最后一个操作是删除锻炼。这里有一个简单的实现，我们调用`HTTPClient`模块的`delete`方法来删除由特定URL引用的锻炼：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Fixing the upstream code
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复上游代码
- en: 'With that, it''s now time to fix the `WorkoutBuilderService` and `Workout`
    components. The `save` method of `WorkoutBuilderService` now looks as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候修复`WorkoutBuilderService`和`Workout`组件了。`WorkoutBuilderService`的`save`方法现在看起来如下：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most of it looks the same as it was earlier because it is the same! We did not
    have to update this code because we effectively isolated the interaction with
    the external server in our `WorkoutService` component.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分看起来和之前一样，因为它们确实是相同的！我们不需要更新这段代码，因为我们有效地在`WorkoutService`组件中隔离了与外部服务器的交互。
- en: 'Finally, the save code for the `Workout` component is shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里展示了`Workout`组件的保存代码：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we have made a change so that we now subscribe to the save. As you may
    recall from our previous discussions, `subscribe` makes an Observable live so
    that we can complete the save.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做出了一些更改，现在我们订阅了保存。如您从我们之前的讨论中回忆起来，`subscribe`使Observable变得活跃，这样我们就可以完成保存。
- en: And that's it! We can now create new workouts and update existing workouts (we'll
    leave completion of deleting workouts to you). That was not too difficult!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在可以创建新的锻炼并更新现有的锻炼（我们将删除锻炼的完成留给你）。这并不太难！
- en: Let's try it out. Open the new `Workout Builder` page, create a workout, and
    save it. Also try to edit an existing workout. Both scenarios should work seamlessly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看。打开新的`Workout Builder`页面，创建一个锻炼并保存它。也尝试编辑一个现有的锻炼。这两种情况都应该无缝工作。
- en: Check out `checkpoint 5.3` for an up-to-date implementation if you are having
    issues running your local copy. If you are not using Git, download the snapshot
    of Checkpoint 5.3 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular2byexample/tree/checkpoint5.3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行本地副本时遇到问题，请查看`checkpoint 5.3`的最新实现。如果你不使用Git，请从以下GitHub位置下载Checkpoint
    5.3的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular2byexample/tree/checkpoint5.3)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Something interesting happens on the network side while we make `POST` or `PUT`
    requests save data. Open the browser''s network log console (*F12*) and see the
    requests being made. The log looks something like the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行`POST`或`PUT`请求保存数据时，网络端会发生一些有趣的事情。打开浏览器的网络日志控制台（*F12*）查看正在进行的请求。日志看起来可能如下所示：
- en: '![](img/00057.gif)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.gif)'
- en: The network log
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 网络日志
- en: An `OPTIONS` request is made to the same endpoint before the actual `POST` or `PUT` is
    done. The behavior that we witness here is termed as a **prefight request**. This
    happens because we are making a cross-domain request to `api.mongolab.com`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际执行`POST`或`PUT`之前，会向同一端点发出一个`OPTIONS`请求。我们在这里观察到的行为被称为**预战斗请求**。这是因为我们正在向`api.mongolab.com`发起跨域请求。
- en: Using promises for HTTP requests
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺进行HTTP请求
- en: The bulk of this chapter has focused on how the Angular `HTTPClient` uses Observables
    as the default for `XMLHttpRequests`. This represents a significant change from
    the way things used to work. Many developers are familiar with using promises
    for asynchronous HTTP requests. With that being the case, Angular continues to
    support promises, but just not as the default choice. A developer has to opt for
    promises in an `XMLHttpRequest` in order to be able to use them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容都集中在 Angular `HTTPClient` 如何使用观察者（Observables）作为 `XMLHttpRequests` 的默认值。这代表了一个重大的变化，与过去的工作方式相比。许多开发者熟悉使用承诺进行异步
    HTTP 请求。在这种情况下，Angular 继续支持承诺，但不是作为默认选择。开发者必须选择在 `XMLHttpRequest` 中使用承诺才能使用它们。
- en: 'For example, if we want to use promises with the `getExercises` method in `WorkoutService`,
    we will have to restructure the command as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在 `WorkoutService` 中的 `getExercises` 方法中使用承诺，我们必须将命令重构如下：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In order to convert this method to use promises, all we have to do is add `.toPromise()`
    to the method chain, a success parameter, `then`, for the promise, and  `catch`
    with a `Promise.reject` pointing to the existing `handleError` method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此方法转换为使用承诺（promises），我们只需在方法链中添加 `.toPromise()`，为承诺添加一个成功参数 `then`，以及一个使用指向现有
    `handleError` 方法的 `Promise.reject` 的 `catch`。
- en: 'For upstream components, we just have to switch to handling the return value
    as a promise rather than an Observable. So, to use promises in this case, we would
    have to change the code in `Exercises.component.ts` and `LeftNavExercises.component.ts`
    to first add a new property for the error message (we''ll leave it to you as to
    how the error message is displayed on the screen):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上游组件，我们只需将处理返回值从观察者（Observable）更改为承诺。因此，在这种情况下使用承诺，我们需要在 `Exercises.component.ts`
    和 `LeftNavExercises.component.ts` 中的代码中首先添加一个新的错误消息属性（我们将如何显示屏幕上的错误消息留给你）：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then change the `ngOnInit` method that is calling `WorkoutService` to the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将调用 `WorkoutService` 的 `ngOnInit` 方法更改为以下内容：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Of course, the ease with which we can substitute promises for Observables in
    this simple example does not indicate that they are essentially the same. A `then`
    promise returns another promise, which means that you can create successively
    chained promises. In the case of an Observable, a subscription is essentially
    the end of the line and cannot be mapped or subscribed to beyond that point.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在这个简单示例中用承诺替换观察者（Observables）的便捷性并不意味着它们本质上相同。一个 `then` 承诺返回另一个承诺，这意味着你可以创建连续链式的承诺。而在观察者（Observable）的情况下，订阅基本上是终点，并且在该点之后不能映射或订阅。
- en: If you're familiar with promises, it may be tempting at this stage to stick
    with them and not give Observables a try. After all, much of what we have done
    with Observables in this chapter can be done with promises as well. For example,
    the mapping of two streams of Observables that we did with `getWorkouts` using
    the Observable's `forkJoin` operator can also be done with the promise's `q,all`
    function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉承诺（promises），在这个阶段可能会倾向于继续使用它们而不尝试观察者（Observables）。毕竟，我们在本章中使用观察者（Observables）所做的许多事情也可以用承诺来完成。例如，我们使用
    `Observable` 的 `forkJoin` 操作符通过 `getWorkouts` 实现的两个观察者流映射也可以使用承诺的 `q,all` 函数来完成。
- en: However, you would be selling yourself short if you took that approach. Observables
    open up an exciting new way of doing web development using what is called functional
    reactive programming. They involve a fundamental shift in thinking that treats
    an application's data as a constant stream of information to which the application
    reacts and responds. This shift allows applications to be built with a different
    architecture that makes them faster and more resilient. Observables are at the
    core of Angular in such things as event emitters and the new version of `NgModel`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你采取那种方法，你就是在贬低自己。观察者（Observables）为使用所谓的函数式响应式编程（functional reactive programming）进行网页开发开辟了令人兴奋的新途径。它们涉及一种基本思维方式的转变，将应用程序的数据视为一个持续的信息流，应用程序对其做出反应和响应。这种转变允许以不同的架构构建应用程序，使它们更快、更健壮。观察者（Observables）是
    Angular 的核心，例如事件发射器和 `NgModel` 的新版本。
- en: While promises are a useful tool to have in your toolkit, we encourage you to
    investigate Observables as you get into developing with Angular. They are part
    of the forward-looking philosophy of Angular and will be useful in future-proofing
    both your applications and your skill set.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然承诺是工具箱中的一个有用工具，但我们鼓励你在使用 Angular 进行开发时调查观察者（Observables）。它们是 Angular 向前看哲学的一部分，并将有助于确保你的应用程序和技能集在未来具有前瞻性。
- en: 'Check out the `checkpoint 5.3` file for an up-to-date implementation that includes
    the promises-related code that we covered previously. If you are not using Git,
    download the snapshot of Checkpoint 5.3 (a ZIP file) from the following GitHub
    location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular6byexample/tree/checkpoint5.3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Be aware that in the next section, we will be reverting to
    the use of Observables for this code. This code can be found in the `checkpoint
    5.4` file.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `checkpoint 5.3` 文件以获取包含我们之前涵盖的与承诺相关的代码的最新实现。如果您不使用 Git，请从以下 GitHub 位置下载
    Checkpoint 5.3 的快照（ZIP 文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular6byexample/tree/checkpoint5.3)。在首次设置快照时，请参考
    `trainer` 文件夹中的 `README.md` 文件。请注意，在下一节中，我们将恢复使用 Observables 来处理此代码。此代码可在 `checkpoint
    5.4` 文件中找到。
- en: The async pipe
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async pipe
- en: As we have seen with many of the data operations covered in this chapter, there
    is a fairly common pattern being repeated over and over again. When an Observable
    is returned from an HTTP request, we convert the response to JSON and subscribe
    to it. The subscription then binds the Observable output to a UI element. Wouldn't
    it be nice if we could eliminate this repetitive coding and replace it with a
    simpler way to accomplish what we are wanting to do?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中涵盖的许多数据操作中看到的那样，有一个相当常见的模式被反复重复。当一个 Observable 从 HTTP 请求返回时，我们将响应转换为
    JSON 并订阅它。然后订阅将 Observable 输出绑定到 UI 元素。如果我们能够消除这种重复的编码并替换为一种更简单的方式来完成我们想要做的事情，那岂不是很好？
- en: Not surprisingly, Angular provides us with just the right way to do that. It's
    called the **async pipe**, and it can be used like any other pipe for binding
    to an element on the screen. However, the async pipe is a much more powerful mechanism
    than other pipes. It takes an Observable or a promise as an input and subscribes
    to it automatically. It also handles the teardown of the subscription for an Observable
    without necessitating any further lines of code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，Angular 为我们提供了正确的方式来做到这一点。它被称为 **async pipe**，它可以像任何其他管道一样用于绑定到屏幕上的元素。然而，async
    pipe 是比其他管道更强大的机制。它接受一个 Observable 或承诺作为输入并自动订阅它。它还处理 Observable 订阅的拆卸，而无需任何额外的代码行。
- en: Let's look at an example of this in our application. Let's go back to the `LeftNavExercises`
    component that we were just looking at in the previous section in connection with
    promises. Note that we have converted this component and the `Exercises` component
    from promises back to using Observables.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们应用中的一个例子。让我们回到上一节中与承诺相关的 `LeftNavExercises` 组件。请注意，我们已经将此组件和 `Exercises`
    组件从承诺转换回使用 Observables。
- en: 'Check out the `checkpoint 5.4` file for an up-to-date implementation that includes
    the conversion of this code to use Observables once again. If you are not using
    Git, download the snapshot of Checkpoint 5.4 (a ZIP file) from the following GitHub
    location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.4](https://github.com/chandermani/angular6byexample/tree/checkpoint5.4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `checkpoint 5.4` 文件以获取最新的实现，该实现包括将此代码转换为使用 Observables。如果您不使用 Git，请从以下 GitHub
    位置下载 Checkpoint 5.4 的快照（ZIP 文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.4](https://github.com/chandermani/angular6byexample/tree/checkpoint5.4)。在首次设置快照时，请参考
    `trainer` 文件夹中的 `README.md` 文件。
- en: 'Then make the following changes in `LeftNavExercises`. First, import Observable
    from RxJs:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `LeftNavExercises` 中进行以下更改。首先，从 RxJs 导入 Observable：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then change `exerciseList` from an array of exercises to an Observable of the
    same type:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将 `exerciseList` 从练习数组更改为相同类型的 Observable：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next modify the call to `WorkoutService` that gets the exercises to eliminate
    the subscription:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来修改调用 `WorkoutService` 获取练习的代码，以消除订阅：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, open `left-nav-exercises.component.html` and add the `async` pipe
    to the `*ngFor` loop, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开 `left-nav-exercises.component.html` 并将 `async` 管道添加到 `*ngFor` 循环中，如下所示：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Refresh the page and you will still see the Exercise list displaying. But this
    time, we have used the `async` pipe to eliminate the need to set up the subscription
    to the Observable. Pretty cool! This is a nice convenience that Angular has added,
    and since we have been spending time in this chapter understanding how Observables
    work with subscriptions, we have a clear idea of what the `async` pipe is now
    handling for us under the hood.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面后，你仍然会看到显示的练习列表。但这次，我们使用了 `async` 管道来消除设置对 Observable 订阅的需要。非常酷！这是 Angular
    添加的一个很好的便利功能，因为我们已经在这个章节中花费时间理解 Observables 与订阅的工作方式，所以我们现在对 `async` 管道在幕后为我们处理什么有了清晰的认识。
- en: We'll leave it to you to implement the same change in the `Exercises` component.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个相同的更改在 `Exercises` 组件中的实现留给你。
- en: It is important to understand the cross-domain behavior of the HTTP request
    and the constructs that Angular provides to make cross-domain requests.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 HTTP 请求的跨域行为以及 Angular 提供用于进行跨域请求的结构非常重要。
- en: Cross-domain access and Angular
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨域访问和 Angular
- en: Cross-domain requests are requests made for resources in a different domain.
    Such requests, when originated from JavaScript, have some restrictions imposed
    by the browser; these are called *same-origin policy* restrictions. Such a restriction
    stops the browser from making AJAX requests to domains that are different from
    the script's original source. The source match is done strictly based on a combination
    of protocol, host, and port.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 跨域请求是对不同域中资源的请求。当从 JavaScript 发起时，这些请求会受到浏览器的一些限制；这些限制被称为 *同源策略* 限制。这种限制阻止浏览器向与脚本原始源不同的域发送
    AJAX 请求。源匹配是严格基于协议、主机和端口的组合进行的。
- en: For our own app, the calls to `https://api.mongolab.com` are cross-domain invocations
    as our source code hosting is in a different domain (most probably, something
    like `http://localhost/....`).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们自己的应用，对 `https://api.mongolab.com` 的调用是跨域调用，因为我们的源代码托管在不同的域中（最可能是类似 `http://localhost/....`
    的东西）。
- en: 'There are some workarounds and some standards that help relax/control cross-domain
    access. We will be exploring two of these techniques as they are the most commonly
    used ones. They are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些解决方案和一些标准有助于放宽/控制跨域访问。我们将探讨这两种技术，因为它们是最常用的。它们如下：
- en: '**JSON with Padding** (**JSONP**)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充 JSON**（**JSONP**）'
- en: '**Cross-Origin Resource Sharing** (**CORS**)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨源资源共享**（**CORS**）'
- en: A common way to circumvent this same-origin policy is to use the JSONP technique.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一种绕过相同源策略的常见方法是使用 JSONP 技术。
- en: Using JSONP to make cross-domain requests
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSONP 进行跨域请求
- en: The JSONP mechanism of remote invocation relies on the fact that browsers can
    execute JavaScript files from any domain irrespective of the source of origin
    as long as the script is included via the `<script>` tag.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 远程调用的 JSONP 机制依赖于浏览器可以从任何域执行 JavaScript 文件的事实，无论其来源如何，只要脚本是通过 `<script>` 标签包含的。
- en: In JSONP, instead of making a direct request to a server, a dynamic `<script>`
    tag is generated, with the `src` attribute set to the server endpoint that needs
    to be invoked. This `<script>` tag, when appended to the browser's DOM, causes
    a request to be made to the target server.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSONP 中，不是直接向服务器发送请求，而是生成一个动态的 `<script>` 标签，其 `src` 属性设置为需要调用的服务器端点。当这个 `<script>`
    标签附加到浏览器的 DOM 上时，会导致向目标服务器发送请求。
- en: The server then needs to send a response in a specific format, wrapping the
    response content inside a function invocation code (this extra padding around
    the response data gives this technique the name JSONP).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器随后需要以特定格式发送响应，将响应内容包裹在函数调用代码中（这额外的填充围绕响应数据使得这项技术被称为 JSONP）。
- en: The Angular JSONP service hides this complexity and provides an easy API to
    make JSONP requests. The StackBlitz link, [https://stackblitz.com/edit/angular-nxeuxo](https://stackblitz.com/edit/angular-nxeuxo),
    highlights how JSONP requests are made. It uses the *IEX Free Stock API* ([https://iextrading.com/developer/](https://iextrading.com/developer/))
    to get quotes for any stock symbol.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Angular JSONP 服务隐藏了这种复杂性，并提供了一个简单的 API 来进行 JSONP 请求。StackBlitz 链接 [https://stackblitz.com/edit/angular-nxeuxo](https://stackblitz.com/edit/angular-nxeuxo)
    突出了如何进行 JSONP 请求。它使用 *IEX Free Stock API*（[https://iextrading.com/developer/](https://iextrading.com/developer/））来获取任何股票代码的报价。
- en: The Angular JSONP service only supports HTTP `GET` requests. Using any other
    HTTP request, such as `POST` or `PUT`, will generate an error.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Angular JSONP 服务仅支持 HTTP `GET` 请求。使用任何其他 HTTP 请求，例如 `POST` 或 `PUT`，将生成错误。
- en: If you look at the StackBlitz project, you will see the familiar pattern for
    component creation that we have followed throughout this book. We will not go
    over this pattern again, but will highlight a few details that are relevant to
    using the Angular JSONP service.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 StackBlitz 项目，你会看到我们在这本书中一直遵循的组件创建的熟悉模式。我们不会再次介绍这个模式，但会突出一些与使用 Angular
    JSONP 服务相关的细节。
- en: 'First, along with the imports for `FormsModule` and `HttpClientModule`, you
    will need to import `HttpClientJsonpModule` into `app.module.ts` as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，除了导入 `FormsModule` 和 `HttpClientModule`，你还需要将 `HttpClientJsonpModule` 导入到
    `app.module.ts` 中，如下所示：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need to add the following imports to `get-quote.component.ts`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将以下导入添加到 `get-quote.component.ts`：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are importing `HttpClient`, which contains the `JSONP` methods we will be
    using, as well as the RxJS `Observable` and the `map ` operator. These imports
    will look familiar to you from what we have been building in this chapter.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导入 `HttpClient`，它包含我们将要使用的 `JSONP` 方法，以及 RxJS 的 `Observable` 和 `map` 操作符。这些导入对你来说应该很熟悉，因为我们已经在本章中构建过。
- en: As you work with Angular JSONP, it is important to understand that by default,
    it returns Observables using RxJS. This means that we will have to follow the
    pattern for subscribing to those Observables and use the RxJS operators to manipulate
    the results. We can also use the async pipe to streamline these operations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Angular JSONP 时，重要的是要理解默认情况下，它使用 RxJS 返回 Observables。这意味着我们将必须遵循订阅这些 Observables
    的模式，并使用 RxJS 操作符来操作结果。我们还可以使用异步管道来简化这些操作。
- en: 'Then we inject `HttpClient` into the constructor:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将 `HttpClient` 注入到构造函数中：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next we add several variables that we will be using in our JSONP call:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加几个将在我们的 JSONP 调用中使用的变量：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `symbol` variable will hold the search string provided by the user. The
    `quote` variable will be used in our template to display the returned value from
    the JSONP call. And the `url` variable is the base URL for the call we will be
    making to the service.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbol` 变量将保存用户提供的搜索字符串。`quote` 变量将用于在我们的模板中显示从 JSONP 调用返回的值。而 `url` 变量是我们将要调用服务的基准
    URL。'
- en: 'Now we have everything in place for our `getQuote` method. Let''s take a look
    at it:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的 `getQuote` 方法准备好了所有东西。让我们来看看它：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first construct our `searchUrl` by concatenating the `url` with the `symbol`
    and adding `/quote`. The last part `quote` is what we need to pass to the quote
    service to return a stock quote.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过连接 `url` 和 `symbol` 并添加 `/quote` 来构造我们的 `searchUrl`。最后一部分 `quote` 是我们需要传递给报价服务以返回股票报价的内容。
- en: We then use the HTTPClient's `jsonp` method to execute the remote call to the
    quote service. We pass the `searchUrl` as the first parameter of that method and
    a string `'callback'` as our second parameter. The latter parameter is used by
    Angular to augment the `searchUrl` with an extra query string parameter, `callback`.
    Internally, the Angular JSONP service then generates a dynamic `script` tag and
    a callback function and makes the remote request.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 HTTPClient 的 `jsonp` 方法执行对报价服务的远程调用。我们将 `searchUrl` 作为该方法的第一个参数传递，并将字符串
    `'callback'` 作为我们的第二个参数。后一个参数由 Angular 用于在 `searchUrl` 中添加一个额外的查询字符串参数 `callback`。内部，Angular
    JSONP 服务生成一个动态的 `script` 标签和一个回调函数，并执行远程请求。
- en: 'Open StackBlitz and enter symbols such as `GOOG`, `MSFT`, or `FB` to see the
    stock quote service in action. The browser network log for requests looks as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 StackBlitz 并输入符号，如 `GOOG`、`MSFT` 或 `FB`，以查看股票报价服务的作用。浏览器网络日志中的请求看起来如下：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, `ng_jsonp_callback_0` is the dynamically generated function. And the
    response looks as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ng_jsonp_callback_0` 是动态生成的函数。响应看起来如下：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The response is wrapped in the callback function. Angular parses and evaluates
    this response, which results in the invocation of the `__ng_jsonp__.__req1` callback
    function. Then, this function internally routes the data to our function callback.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 响应被包裹在回调函数中。Angular 解析并评估这个响应，这导致调用 `__ng_jsonp__.__req1` 回调函数。然后，这个函数内部将数据路由到我们的函数回调。
- en: 'We hope this explains how JSONP works and what the underlying mechanism of
    a JSONP request is. However, JSONP has its limitations:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这解释了 JSONP 的工作原理以及 JSONP 请求的底层机制。然而，JSONP 有其局限性：
- en: First, we can make only `GET` requests (which is obvious as these requests originate
    due to script tags)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们只能进行 `GET` 请求（这是显而易见的，因为这些请求是由于脚本标签而发起的）
- en: Second, the server also needs to implement the part of the solution that involves
    wrapping the response in a function callback
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, there is always a security risk involved, as JSONP depends on dynamic
    script generation and injection
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fourth, error handling is not reliable too because it is not easy to determine
    why a script load failed
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, we must recognize that JSONP is more of a workaround than a solution.
    As we move towards Web 2.0, where mashups become commonplace and more and more
    service providers decide to expose their API over the web, a far better solution/standard
    has emerged: CORS.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Cross-origin resource sharing
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-origin Resource Sharing** (**CORS**) provides a mechanism for the web
    server to support cross-site access control, allowing browsers to make cross-domain
    requests from scripts. With this standard, a consumer application (such as *Personal
    Trainer*) is allowed to make some types of requests, termed **simple requests**,
    without any special setup requirements. These simple requests are limited to `GET`,
    `POST` (with specific MIME types), and `HEAD`. All other types of requests are
    termed **complex requests**.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: For complex requests, CORS mandates that the request should be preceded by an
    HTTP `OPTIONS` request (also called a preflight request) that queries the server
    for HTTP methods allowed for cross-domain requests. And only on successful probing
    is the actual request made.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about CORS from the MDN documentation available at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The best part about CORS is that the client does not have to make any adjustment
    as in the case of JSONP. The complete handshake mechanism is transparent to the
    calling code and our Angular `HTTPClient` calls work without a hitch.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: CORS requires configurations to be made on the server, and the MongoLab servers
    have already been configured to allow cross-domain requests. So the preceding
    `POST` and `PUT` requests that we made to the MongoLab to add and update `Exercise`
    and `Workout` documents all caused the preflight `OPTIONS` request.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Handling workouts not found
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might recall that in [Chapter 4](part0180.html#5BL580-7edc9b1e1ea341adae33006323903887),
    *Personal Trainer*, we created the `WorkoutResolver` to not only retrieve a workout
    prior to navigation to the `WorkoutComponent`, but also prevent navigation to
    that component if a non-existent workout was in the route parameters. Now we would
    like to augment this functionality by displaying an error message on the workouts
    screen, indicating that the workout was not found.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we are going to modify `WorkoutResolver` so that it reroutes
    to the workouts screen if a workout is not found. To start, add the following
    child route to `WorkoutBuilderRoutingModule` (making sure it precedes the existing
    workouts route):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, modify the `resolve` method in the `WorkoutResolver` to redirect to this
    route in the event that a workout is not found:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then add a `notFound` boolean set to `false` to the variables in the `Workouts`
    component:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And, in the `ngOnInit` method of that component, add the following code to
    check for the `workout-not-found` path and set the `notFound` value to `true`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally in the `Workouts.component.html` template, add the following `div`
    tag above the workout list that will display if the `notFound` is set to `true`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we find `workout-not-found` in the path when a user is returned to the `Workouts`
    page, then this displays the following message on the screen:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: We have fixed routing failure for the Workout Builder page, but the exercise
    builder page is still pending. Again, we will leave it to you to fix it yourself.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Another major (and pending) implementation is fixing *7 Minute Workout*, as
    it currently caters to only one workout routine.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the 7 Minute Workout app
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it stands now, the *7 Minute Workout* (or *Workout Runner*) app can play
    only one specific workout. It needs to be fixed to support the execution of any
    workout plan built using *Personal Trainer*. There is an obvious need to integrate
    these two solutions. We already have the groundwork done to commence this integration.
    We've got the shared model services and `WorkoutService` to load data, enough
    to get us started.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixing *7 Minute Workout* and converting it into a generic *Workout Runner*
    roughly involves the following steps:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Removing the hardcoded workout and exercises used in *7 Minute Workout*.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing the start page to show all available workouts and allowing users to select
    a workout to run.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing the workout route configuration to pass the selected workout name as
    the route parameter to the workout page.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading the selected workout data using `WorkoutService` and starting the workout.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, of course, we need to rename the *7 Minute Workout* part of the app; the
    name is now a misnomer. I think the complete app can be called *Personal Trainer*.
    We can remove all references to *7 Minute Workout* from the view as well.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An excellent exercise to try out yourself! And that is why we are not going
    to walk you through the solution. Instead, go ahead and implement the solution.
    Compare your implementation with the one available at `checkpoint 5.4`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: It's time to end the chapter and summarize your learning.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have an app that can do a lot of stuff. It can run workouts, load workouts,
    save and update them, and track history. And if we look back, we have achieved
    this with minimal code. We bet that if we were to try this in standard jQuery
    or some other framework, it would require substantially more effort as compared
    to Angular.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by providing a *MongoDB* database on *MongoLab* servers.
    Since MongoLab provided a RESTful API to access the database, we saved some time
    by not setting up our own server infrastructure.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The first Angular construct that we touched upon was the `HTTPClient`, which
    is the primary service for connecting to any HTTP backend.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先接触到的Angular结构是`HTTPClient`，这是连接到任何HTTP后端的主要服务。
- en: You also learned how the `HTTPClient` module uses Observables. For the first
    time, in this chapter, we created our own Observable and explained how to create
    subscriptions to those Observables.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了`HTTPClient`模块如何使用Observables。在本章中，我们第一次创建了自己的Observable，并解释了如何为这些Observable创建订阅。
- en: We fixed our *Personal Trainer* app so that it uses the `HTTPClient` module
    to load and save workout data (note that data persistence for exercises is left
    for you to complete). In the process, you also learned about issues surrounding
    cross-domain resource access. You learned about JSONP, a workaround to circumvent
    a browser's *same-origin* restrictions, and how to issue JSONP requests using
    Angular. We also touched upon CORS, which has emerged as a standard when it comes
    to cross-domain communication.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修复了我们的*个人训练师*应用程序，使其使用`HTTPClient`模块来加载和保存锻炼数据（请注意，锻炼数据持久化留给你来完成）。在这个过程中，你也了解了关于跨域资源访问的问题。你学习了JSONP，这是一种绕过浏览器*同源*限制的解决方案，以及如何使用Angular发起JSONP请求。我们还提到了CORS，当涉及到跨域通信时，它已成为一种标准。
- en: 'We have now covered most of the building blocks of Angular, except the big
    one: Angular directives. We have used directives everywhere, but have not created
    one. The next chapter is exclusively dedicated to Angular directives. We will
    be creating a number of small directives, such as a remote validator, AJAX button,
    and a validation cues directive for the *Workout Builder* app.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了Angular的大部分构建块，除了最大的一个：Angular指令。我们在各个地方都使用了指令，但还没有创建一个。下一章将专门介绍Angular指令。我们将创建一些小的指令，例如远程验证器、AJAX按钮以及为*锻炼构建器*应用程序的验证提示指令。
