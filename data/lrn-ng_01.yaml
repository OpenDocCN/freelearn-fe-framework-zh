- en: Creating Our First Component in Angular
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中创建我们的第一个组件
- en: When it comes to Angular development, there are some things that are good to
    know and some things that we need to know to embark on our great journey. One
    of the things that is good to know is **semantic versioning**. This is good to
    know because it is the way the Angular team has chosen to deal with changes. This
    will hopefully make it easier to find the right solutions to future app development
    challenges when you go to [https://angular.io/](https://angular.io/) or Stack
    Overflow and other sites to search for solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行Angular开发时，有一些事情是好知道的，还有一些事情是我们需要知道的，以便开始我们伟大的旅程。其中一件好知道的事情是**语义化版本控制**。这是好知道的，因为这是Angular团队选择处理更改的方式。当您前往[https://angular.io/](https://angular.io/)或Stack
    Overflow等网站搜索解决方案时，这将有望使您更容易找到未来应用程序开发挑战的正确解决方案。
- en: Another important, but sometimes painful, topic is that of project setup. It
    is a necessary evil that needs to be done in the beginning of a project, but getting
    this right early on can reduce a lot of friction as your application grows with
    you. Therefore, a large part of this chapter is dedicated to demystifying and
    enabling you as a developer to save you from future frustrations and migraines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要但有时令人痛苦的话题是项目设置。这是一个必要的恶，需要在项目开始时完成，但在早期正确处理这个问题可以减少随着应用程序的增长而产生的许多摩擦。因此，本章的很大一部分致力于揭开谜团，并使您作为开发人员能够避免未来的挫折和偏头痛。
- en: We will also be able to create our first application at the end of this chapter
    and get a feel for the anatomy of an Angular application. To sum up, here are
    the main themes that we will explore in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们还将能够创建我们的第一个应用程序，并了解Angular应用程序的结构。总之，以下是本章将探讨的主要主题。
- en: 'In this chapter, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将：
- en: Learn about semantic versioning, why it matters, and Angular's take on it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解语义化版本控制的重要性，以及Angular对其的看法
- en: Discover how we set up our project using Angular CLI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解我们如何使用Angular CLI设置项目
- en: Create our first application and begin to understand the core concepts in Angular
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个应用程序，并开始了解Angular中的核心概念
- en: It's just Angular – introducing semantic versioning
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这只是Angular-介绍语义化版本控制
- en: Using semantic versioning is about managing expectations. It's about managing
    how the user of your application, or library, will react when a change happens
    to it. Changes will happen for various reasons, either to fix something broken
    in the code or add/alter/remove a feature. The way authors of frameworks or libraries
    use to convey what impact a certain change has is by incrementing the version
    number of the software.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语义化版本控制是关于管理期望。这是关于管理您的应用程序或库的用户在发生更改时会做出何种反应。更改会因各种原因而发生，无论是修复代码中的错误还是添加/更改/删除功能。框架或库的作者用来传达某个更改的影响的方式是通过增加软件的版本号。
- en: A production-ready software usually has version 1.0 or 1.0.0 if you want to
    be more specific.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可供生产使用的软件通常具有版本1.0或1.0.0（如果您想更具体）。
- en: There are three different levels of change that can happen when updating your
    software. Either you patch it and effectively correct something. Or you make a
    minor change, which essentially means you add functionality. Or lastly you make
    a major change, which might completely change how your software works. Let's describe
    these changes in more detail in the following sections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新软件时可能会发生三种不同级别的更改。要么您对其进行修补并有效地纠正某些问题。要么您进行次要更改，这基本上意味着您添加功能。或者最后您进行主要更改，这可能会完全改变软件的工作方式。让我们在接下来的章节中更详细地描述这些变化。
- en: Patch change
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本更改
- en: A patch change means we increment the right most digit by one. Changing the
    said software from 1.0.0 to 1.0.1 is a small change, usually a bug fix. As a user
    of that software you don't really have to worry; if anything, you should be happy
    that something is suddenly working better. The point is, you can safely start
    using 1.0.1.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁变更意味着我们将最右边的数字增加一。将软件从1.0.0更改为1.0.1是一个小改变，通常是一个错误修复。作为软件的用户，你不需要担心；如果有什么变化，你应该高兴地发现某些东西突然工作得更好了。关键是，你可以放心地开始使用1.0.1。
- en: Minor change
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小改变
- en: This means the software is increased from 1.0.0 to 1.1.0\. We are dealing with
    a more severe change as we increase the middle digit by one. This number should
    be increased when functionality is added to the software and it should still be
    backwards compatible. Also in this case it should be safe adapting the 1.1.0 version
    of the software.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着软件从1.0.0增加到1.1.0。当我们增加中间数字时，我们正在处理更严重的变化。当软件功能被添加时，这个数字应该增加，而且它仍然应该向后兼容。在这种情况下，采用1.1.0版本的软件也是安全的。
- en: Major change
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要变更
- en: At this stage, the version number increases from 1.0.0 to 2.0.0\. Now this is
    where you need to look out. At this stage, things might have changed so much that
    constructs have been renamed or removed. It might not be compatible to earlier
    versions. I'm saying *it might* because a lot of software authors still ensure
    that there is a decent backwards compatibility, but the main point here is that
    there is no warranty, no contract, guaranteeing that it will still work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，版本号从1.0.0增加到2.0.0。现在你需要留意了。在这个阶段，事情可能已经发生了很大的变化，构造可能已经被重命名或删除。它可能不兼容早期版本。我说“可能”是因为很多软件作者仍然确保有相当的向后兼容性，但这里的主要观点是没有保证，没有合同，保证它仍然可以工作。
- en: What about Angular?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那Angular呢？
- en: The first version of Angular was known by most people as Angular 1; it later
    became known as AngularJS. It did not use semantic versioning. Most people actually
    still refer to it as Angular 1.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的第一个版本大多数人都称为Angular 1；后来它被称为AngularJS。它没有使用语义化版本。大多数人实际上仍然将其称为Angular
    1。
- en: Then Angular came along and in 2016 it reached production readiness. Angular decided
    to adopt semantic versioning and this caused a bit of confusion in the developer
    community, especially when it was announced that there would be an Angular 4 and
    5, and so on. Google, as well as the Google Developer Experts, started to explain
    to people that it wanted people to call the latest version of the framework Angular
    - just Angular. You can always argue on the wisdom of that decision, but the fact
    remains, the new Angular is using semantic versioning. This means Angular is the
    same platform as Angular 4, as well as Angular 11, and so on, if that ever comes
    out. Adopting semantic versioning means that you as a user of Angular can rely
    on things working the same way until Google decides to increase the major version.
    Even then it's up to you if you want to remain on the latest major version or
    want to upgrade your existing apps.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后Angular出现了，在2016年它达到了生产就绪状态。Angular决定采用语义化版本，这在开发者社区引起了一些混乱，特别是当宣布将会有Angular
    4和5等版本时。谷歌以及谷歌开发者专家开始向人们解释，他们希望人们称最新版本的框架为Angular - 只是Angular。你可以对这个决定的智慧进行争论，但事实仍然是，新的Angular正在使用语义化版本。这意味着Angular与Angular
    4以及Angular 11等版本是相同的平台，如果有的话。采用语义化版本意味着作为Angular用户，你可以依赖事物一直以相同的方式工作，直到谷歌决定增加主要版本。即使在那时，你可以选择是保持在最新的主要版本上，还是想要升级你现有的应用程序。
- en: A fresh start
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个全新的开始
- en: As mentioned before, Angular represents a full rewrite of the AngularJS framework,
    introducing a brand new application architecture completely built from scratch
    in TypeScript, a strict superset of JavaScript that adds optional static typing
    and support for interfaces and decorators.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Angular 是 AngularJS 框架的全面重写，引入了全新的应用程序架构，完全使用 TypeScript 从头开始构建，TypeScript
    是 JavaScript 的严格超集，它增加了可选的静态类型和对接口和装饰器的支持。
- en: In a nutshell, Angular applications are based on an architecture design that
    comprises of trees of web components interconnected by their own particular I/O
    interface. Each component takes advantage under the covers of a completely revamped
    dependency injection mechanism.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Angular 应用程序基于一种架构设计，由 Web 组件树组成，它们通过各自特定的 I/O 接口相互连接。每个组件在底层利用了完全改进的依赖注入机制。
- en: To be fair, this is a simplistic description of what Angular really is. However,
    the simplest project ever made in Angular is cut out by these definition traits.
    We will focus on learning how to build interoperable components and manage dependency
    injection in the next chapters, before moving on to routing, web forms, and HTTP
    communication. This also explains why we will not make explicit references to
    AngularJS throughout the book. Obviously, it makes no sense to waste time and
    pages referring to something that will not provide any useful insights on the
    topic, besides the fact we assume that you might not know about Angular 1.x, so
    such knowledge does not have any value here.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，这是对 Angular 真正含义的简单描述。然而，即使是 Angular 中最简单的项目也符合这些定义特征。在接下来的章节中，我们将专注于学习如何构建可互操作的组件和管理依赖注入，然后再转向路由、Web
    表单和 HTTP 通信。这也解释了为什么我们在本书中不会明确提及 AngularJS。显然，浪费时间和页面提及对主题没有任何有用见解的东西是没有意义的，而且我们假设你可能不了解
    Angular 1.x，因此这种知识在这里没有任何价值。
- en: Web components
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 组件
- en: 'Web components is a concept that encompasses four technologies designed to
    be used together to build feature elements with a higher level of visual expressivity
    and reusability, thereby leading to a more modular, consistent, and maintainable
    web. These four technologies are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Web 组件是一个概念，它包括四种技术，旨在一起使用以构建具有更高视觉表现力和可重用性的功能元素，从而实现更模块化、一致和可维护的 Web。这四种技术如下：
- en: '**Templates**: These are pieces of HTML that structure the content we aim'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：这些是用于构造我们的内容的 HTML 片段'
- en: to render
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染
- en: '**Custom elements**: These templates not only contain traditional HTML elements,
    but also the custom wrapper items that provide further presentation elements or
    API functionalities'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义元素**：这些模板不仅包含传统的 HTML 元素，还包括提供更多呈现元素或 API 功能的自定义包装项'
- en: '**Shadow DOM**: This provides a sandbox to encapsulate the CSS layout rules
    and JavaScript behaviors of each custom element'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**影子 DOM**：这提供了一个沙盒，用于封装每个自定义元素的 CSS 布局规则和 JavaScript 行为'
- en: '**HTML imports**: HTML is no longer constrained to host HTML elements, but
    to other HTML documents as well'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML 导入**：HTML 不再仅限于承载 HTML 元素，还可以承载其他 HTML 文档'
- en: 'In theory, an Angular component is indeed a custom element that contains a
    template to host the HTML structure of its layout, the latter being governed by
    a scoped CSS style sheet encapsulated within a shadow DOM container. Let''s try
    to rephrase this in plain English. Think of the range input control type in HTML5\.
    It is a handy way to give our users a convenient input control for entering a
    value ranging between two predefined boundaries. If you have not used it before,
    insert the following piece of markup in a blank HTML template and load it in your
    browser:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，Angular组件确实是一个包含模板的自定义元素，用于承载其布局的HTML结构，后者由一个封装在影子DOM容器中的作用域CSS样式表控制。让我们用简单的英语来重新表达一下。想象一下HTML5中的range输入控件类型。这是一种方便的方式，可以为用户提供一个方便的输入控件，用于输入两个预定义边界之间的值。如果您以前没有使用过它，请在空白的HTML模板中插入以下标记，并在浏览器中加载它：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will see a nice input control featuring a horizontal slider in your browser.
    Inspecting such control with the browser developer tools will unveil a concealed
    set of HTML tags that were not present at the time you edited your HTML template.
    There you have an example of shadow DOM in action, with an actual HTML template
    governed by its own encapsulated CSS with advanced dragging functionality. You
    will probably agree that it would be cool to do that yourself. Well, the good
    news is that Angular gives you the toolset required for delivering this very same
    functionality, so we can build our own custom elements (input controls, personalized
    tags, and self-contained widgets) featuring the inner HTML markup of our choice
    and our very own style sheet that does not affect (nor is impacted) by the CSS
    of the page hosting our component.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，您将看到一个漂亮的输入控件，其中包含一个水平滑块。使用浏览器开发者工具检查这样的控件将揭示一组隐藏的HTML标记，这些标记在您编辑HTML模板时并不存在。这就是影子DOM在起作用，具有由其自己封装的CSS控制的实际HTML模板，具有高级的拖动功能。您可能会同意，自己做这件事将是很酷的。好消息是，Angular为您提供了交付这个功能所需的工具集，因此我们可以构建我们自己的自定义元素（输入控件、个性化标记和自包含小部件），其中包含我们选择的内部HTML标记和我们自己的样式表，不会受到页面托管我们组件的CSS的影响。
- en: Why TypeScript over other syntaxes?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择TypeScript而不是其他语法？
- en: 'Angular applications can be coded in a wide variety of languages and syntaxes:
    ECMAScript 5, Dart, ECMAScript 6, TypeScript, or ECMAScript 7.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用程序可以使用多种语言和语法进行编码：ECMAScript 5、Dart、ECMAScript 6、TypeScript或ECMAScript
    7。
- en: TypeScript is a typed superset of ECMAScript 6 (also known as ECMAScript 2015)
    that compiles to plain JavaScript and is widely supported by modern OSes. It features
    a sound object-oriented design and supports annotations, decorators, and type
    checking.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是ECMAScript 6（也称为ECMAScript 2015）的类型超集，可以编译成普通的JavaScript，并得到现代操作系统的广泛支持。它具有健全的面向对象设计，支持注解、装饰器和类型检查。
- en: The reason why we picked (and obviously recommend) TypeScript as the syntax
    of choice for instructing how to develop Angular applications in this book is
    based on the fact that Angular itself is written in this language. Being proficient
    in TypeScript will give the developer an enormous advantage when it comes to understanding
    the guts of the framework.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择（并显然推荐）TypeScript作为本书中指导如何开发Angular应用程序的首选语法的原因是Angular本身就是用这种语言编写的。精通TypeScript将使开发人员在理解框架的内部机制时具有巨大优势。
- en: On the other hand, it is worth remarking that TypeScript's support for annotations
    and type introspection turns out to be paramount when it comes to managing dependency
    injection and type binding between components with a minimum code footprint, as
    we will see further down the line in this book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，值得注意的是，当涉及管理依赖注入和组件之间的类型绑定时，TypeScript对注解和类型内省的支持变得至关重要，因为它可以以最小的代码占用量实现，我们将在本书的后面看到。
- en: Ultimately, you can carry out your Angular projects in plain ECMAScript 6 syntax
    if that is your preference. Even the examples provided in this book can be easily
    ported to ES6 by removing type annotations and interfaces, or replacing the way
    dependency injection is handled in TypeScript with the most verbose ES6 way.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，如果这是您的偏好，您可以使用纯ECMAScript 6语法执行您的Angular项目。甚至本书提供的示例也可以通过删除类型注解和接口，或者用最冗长的ES6方式替换TypeScript中处理依赖注入的方式，轻松地转换为ES6。
- en: For the sake of brevity, we will only cover examples written in TypeScript and
    actually recommend its use because of its higher expressivity thanks to type annotations,
    and its neat way of approaching dependency injection based on type introspection
    out of such type annotations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们只会涵盖使用TypeScript编写的示例，并实际推荐其使用，因为由于类型注解，它具有更高的表达能力，并且通过基于类型内省的依赖注入的整洁方式。
- en: Setting up our workspace with Angular CLI
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular CLI设置我们的工作空间
- en: There are different ways to get started, either using the Angular quickstart repository
    on the [https://angular.io/](https://angular.io/) site, or installing the scaffolding
    tool Angular CLI, or lastly, you could use Webpack to set up your project. It
    is worth pointing out that the standard way of creating a new Angular project
    is through using *Angular CLI* and scaffold your project. Systemjs, used by the
    quickstart repository, is something that used to be the default way of building
    Angular projects. It is now rapidly diminishing, but it is still a valid way of
    setting up an Angular project. The interested reader is therefore recommended
    to check the Appendix A, *SystemJS* for more information on it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法可以开始，可以使用[https://angular.io/](https://angular.io/)网站上的Angular快速入门存储库，或安装脚手架工具Angular
    CLI，或者最后，您可以使用Webpack来设置您的项目。值得指出的是，创建新的Angular项目的标准方式是使用*Angular CLI*并搭建您的项目。快速入门存储库使用的Systemjs曾经是构建Angular项目的默认方式。它现在正在迅速减少，但仍然是设置Angular项目的有效方式。因此，建议感兴趣的读者查看附录A，*SystemJS*以获取更多信息。
- en: Setting up a frontend project today is more cumbersome than ever. We used to
    just include the necessary script with our JavaScript code and a `link` tag for
    our CSS and `img` tag for our assets and so on. Life used to be simple. Then frontend
    development became more ambitious and we started splitting up our code in modules,
    we started using preprocessors for both our code and CSS. All in all, our projects
    became more complicated and we started to rely on build systems such as Grunt,
    Gulp, Webpack, and so on. Most developers out there are not huge fans of configuration,
    they just want to focus on building apps. Modern browsers, however, do more to
    support the latest ECMAScript standard and some browsers have even started to
    support modules, which are resolved at runtime. This is far from being widely
    supported though. In the meantime, we still have to rely on tools for bundling
    and module support.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，设置前端项目比以往任何时候都更加繁琐。我们过去只需在我们的JavaScript代码中包含必要的脚本，以及用于我们的CSS的`link`标签和用于我们的资产的`img`标签等。生活过去很简单。然后前端开发变得更加雄心勃勃，我们开始将我们的代码拆分成模块，我们开始使用预处理器来处理我们的代码和CSS。总的来说，我们的项目变得更加复杂，我们开始依赖构建系统，如Grunt、Gulp、Webpack等。大多数开发人员并不是配置的铁杆粉丝，他们只想专注于构建应用程序。然而，现代浏览器更多地支持最新的ECMAScript标准，一些浏览器甚至开始支持在运行时解析的模块。尽管如此，这远非得到广泛支持。与此同时，我们仍然必须依赖工具进行捆绑和模块支持。
- en: Setting up a project with leading frameworks such as React or Angular can be
    quite difficult. You need to know what libraries to import and ensure that files
    are processed in the correct order, which leads us into the topic of scaffolding
    tools. For AngularJS, it was quite popular to use Yeoman to scaffold up a new
    application quickly and get a lot of nice things preconfigured. React has a scaffolder
    tool called *create-react-app*, which you probably have saved and it saves countless
    hours for React developers. Scaffolder tools becomes almost a necessity as complexity
    grows, but also where every hour counts towards producing business value rather
    than fighting configuration problems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用领先的框架（如React或Angular）设置项目可能会非常困难。您需要知道要导入哪些库，并确保文件按正确的顺序处理，这将引入我们的脚手架工具主题。对于AngularJS，使用Yeoman快速搭建新应用程序并预先配置许多好东西是非常流行的。React有一个名为*create-react-app*的脚手架工具，您可能已经保存了它，它为React开发人员节省了无数小时。随着复杂性的增加，脚手架工具几乎成为必需品，但也是每个小时都用于产生业务价值而不是解决配置问题的地方。
- en: The main motivation behind creating the Angular CLI tool was to help developers
    focus on app building and not so much on configuration. Essentially, with a simple
    command, you should be able to scaffold an application, add a new construct to
    it, run tests, or create a production grade bundle. Angular CLI supports all that.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Angular CLI工具的主要动机是帮助开发人员专注于应用程序构建，而不是太多地关注配置。基本上，通过一个简单的命令，您应该能够快速搭建一个应用程序，向其添加新构造，运行测试，或创建一个生产级捆绑包。Angular
    CLI支持所有这些。
- en: Prerequisites
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: What you need to get started is to have Git and Node.js installed. Node.js will
    also install something called NPM, a node package manager that you will use later
    to install files you need for your project. After this is done, you are ready
    to set up your Angular application. You can find installation files to Node.js
    at [https://nodejs.org](https://nodejs.org).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要开始的是安装Git和Node.js。Node.js还将安装一个称为NPM的东西，这是一个您以后将用来安装项目所需文件的节点包管理器。完成后，您就可以设置您的Angular应用程序了。您可以在[https://nodejs.org](https://nodejs.org)找到Node.js的安装文件。
- en: 'The easiest way to have it installed is to go to the site:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 安装它的最简单方法是访问该网站：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Installing Node.js will also install something called NPM, Node Package Manager,
    which you will need to install dependencies and more. The Angular CLI requires Node
    6.9.0 and NPM 3 or higher. Currently on the site, you can choose between an LTS
    version and the current version. The LTS version should be enough.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node.js也将安装一个称为NPM的东西，即Node包管理器，您将需要它来安装依赖项等。Angular CLI需要Node 6.9.0和NPM 3或更高版本。目前在该网站上，您可以选择长期支持版本和当前版本。长期支持版本应该足够了。
- en: Installation
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'Installing the Angular CLI is as easy as running the following command in your
    Terminal:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Angular CLI就像在您的终端中运行以下命令一样简单：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On some systems, you may need to have elevated permissions to do so; in that
    case, run your Terminal window as an administrator and on Linux/macOS instead
    run the command like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统上，您可能需要提升权限才能这样做；在这种情况下，以管理员身份运行您的终端窗口，在Linux/macOS上运行以下命令：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First app
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个应用
- en: 'Once the Angular CLI is in place the time has come to create your first project.
    To do so place yourself in a directory of your choice and type the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Angular CLI，就到了创建第一个项目的时候。为此，请进入您选择的目录并输入以下内容：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Type the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下内容：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will create a directory called `TodoApp`. After you have run the preceding
    command, there are two things you need to do to see your app in a browser:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`TodoApp`的目录。在运行了上述命令之后，您需要做两件事才能在浏览器中看到您的应用程序：
- en: Navigate to the just created directory
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到刚创建的目录
- en: Serve up the application
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供应用程序
- en: 'This will be accomplished by the following commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过以下命令完成：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this point, open up your browser on `http://localhost:4200` and you should
    see the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，在`http://localhost:4200`上打开你的浏览器，你应该会看到以下内容：
- en: '![](assets/cc3798ac-f306-4687-a4a5-4186198885c3.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cc3798ac-f306-4687-a4a5-4186198885c3.png)'
- en: Testing
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'The Angular CLI doesn''t just come with code that makes your app work. It also
    comes with code that sets up testing and includes a test. Running the said test
    is as easy as typing the following in the Terminal:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI不仅提供使您的应用程序工作的代码，还提供设置测试和包含测试的代码。运行所说的测试就像在终端中输入以下内容一样简单：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下内容：
- en: '![](assets/11371fd2-d676-4ca5-b1e1-78a4c89fd915.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/11371fd2-d676-4ca5-b1e1-78a4c89fd915.png)'
- en: 'How come this works? Let''s have a look at the `package.json` file that was
    just created and the `scripts` tag. Everything specified here can be run using
    the following syntax:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样会起作用？让我们看一下刚刚创建的`package.json`文件和`scripts`标签。这里指定的所有内容都可以使用以下语法运行：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In some cases, it is not necessary to type `run` and it will be enough to just
    type:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，不需要输入`run`，只需输入以下内容即可：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the case with the `start` and `test` commands.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于`start`和`test`命令。
- en: 'The following listing makes it clear that it is possible to run more commands
    than `start` and `test` that we just learned about:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单清楚地表明，可以运行的命令不仅仅是我们刚刚学到的`start`和`test`：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So far we have learned how to install the Angular CLI. Using the Angular CLI
    we have learned to:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何安装Angular CLI。使用Angular CLI，我们已经学会了：
- en: Scaffold a new project.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搭建一个新项目。
- en: Serve up the project and see it displayed in a browser.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动项目，看看它在浏览器中显示出来。
- en: Run tests.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: That is quite an accomplishment. We will revisit the Angular CLI in a later
    chapter as it is a very competent tool, capable of a lot more.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当了不起的成就。我们将在后面的章节中重新讨论Angular CLI，因为它是一个非常有能力的工具，能够做更多的事情。
- en: Hello Angular
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，Angular
- en: We are about to take the first trembling steps into building our first component.
    The Angular CLI has already scaffolded our project and thereby carried out a lot
    of heavy lifting. All we need to do is to create new file and starting filling
    it with content. The million dollar question is what to type?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将迈出建立我们的第一个组件的第一步。Angular CLI已经为我们搭建了项目，并且已经完成了大量的繁重工作。我们所需要做的就是创建一个新文件，并开始填充它的内容。百万美元的问题是要输入什么？
- en: 'So let''s venture into building our first component. There are three steps
    you need to take in creating a component. Those are:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们开始构建我们的第一个组件。创建一个组件需要三个步骤。那就是：
- en: Import the component decorator construct.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入组件装饰器构造。
- en: Decorate a class with a component decorator.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用组件装饰器装饰一个类。
- en: Add a component to its module ( this might be in two different places).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件添加到它的模块中（这可能在两个不同的地方）。
- en: Creating the component
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件
- en: 'First off, let''s import the component decorator:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入组件装饰器：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then create the class for your component:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为你的组件创建类：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then decorate your class using the `Component` decorator:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`Component`装饰器装饰你的类：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We give the `Component` decorator, which is function, an object literal as an
    input parameter. The object literal consists at this point of the `selector` and `template` keys, so
    let's explain what those are.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给`Component`装饰器，也就是函数，传入一个对象字面量作为输入参数。这个对象字面量目前包括`selector`和`template`键，所以让我们解释一下它们是什么。
- en: Selector
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择器
- en: 'A `selector` is what it should be referred to if used in a template somewhere
    else. As we call it `app`, we would refer to it as:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`selector`是在模板中引用时应该使用的名称。我们称之为`app`，我们会这样引用它：'
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Template/templateUrl
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板/templateUrl
- en: The `template` or `templateUrl` is your view. Here you can write HTML markup.
    Using the   `template`keyword, in our object literal, means we get to define the
    HTML markup in the same file as the component class. Were we to use `templateUrl`,
    we would then place our HTML markup in a separate file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`或`templateUrl`是您的视图。在这里，您可以编写HTML标记。在我们的对象字面量中使用`template`关键字意味着我们可以在与组件类相同的文件中定义HTML标记。如果我们使用`templateUrl`，那么我们将在一个单独的文件中放置我们的HTML标记。'
- en: 'The preceding  example also lists the following double curly braces, in the
    markup:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例还列出了标记中的双大括号：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will be treated as an interpolation and the expression will be replaced
    with the value of `AppComponent`''s `title`field. The component, when rendered,
    will therefore look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被视为插值，表达式将被替换为`AppComponent`的`title`字段的值。因此，渲染时，组件将如下所示：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Telling the module
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告诉模块
- en: Now we need to introduce a completely new concept, an Angular module. All types
    of constructs that you create in Angular should be registered with a module. An
    Angular module serves as a facade to the outside world and it  is nothing more
    than a class that is decorated by the decorate `@NgModule`. Just like the `@Component` decorator,
    the `@NgModule`decorator takes an object literal as an input parameter. To register
    our component with our Angular module, we need to give the object literal the
    property `declarations`. The `declarations` property is of a type array and by
    adding our component to that array we are registering it with the Angular module.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要引入一个全新的概念，一个Angular模块。在Angular中创建的所有类型的构造都应该在模块中注册。Angular模块充当对外界的门面，它只是一个由`@NgModule`装饰的类。就像`@Component`装饰器一样，`@NgModule`装饰器以对象字面量作为输入参数。为了将我们的组件注册到Angular模块中，我们需要给对象字面量添加`declarations`属性。`declarations`属性是一个数组类型，通过将我们的组件添加到该数组中，我们就将其注册到了Angular模块。
- en: 'The following code shows the creation of an Angular module and the component
    being registered with it by being added to `declarations` keyword array:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了创建一个Angular模块以及将组件注册到其中的过程，通过将其添加到`declarations`关键字数组中：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, our Angular module knows about the component. We need to add
    one more property to our module, `bootstrap`. The `bootstrap`keyword states that
    whatever is placed in here serves as the entry component for the entire application.
    Because we only have one component, so far, it makes sense to register our component
    with this `bootstrap` keyword:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的Angular模块已经知道了这个组件。我们需要在我们的模块中添加一个属性`bootstrap`。`bootstrap`关键字表示这里放置的任何内容都作为整个应用程序的入口组件。因为目前我们只有一个组件，所以将我们的组件注册到这个`bootstrap`关键字是有意义的：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It's definitely possible to have more than one entry component, but the usual
    scenario is that there is only one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 确实可以有多个入口组件，但通常情况下只有一个。
- en: For any future components, however, we will only need to add them to the `declarations` property,
    to ensure the module knows about them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于任何未来的组件，我们只需要将它们添加到`declarations`属性中，以确保模块知道它们。
- en: So far we have created a component and an Angular module and registered the
    component with said the module. We don't really have a working application yet,
    as there is one more step we need to take. We need to set up the bootstrapping.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个组件和一个Angular模块，并将组件注册到了该模块。但我们还没有一个可工作的应用程序，因为我们还需要采取一步。我们需要设置引导。
- en: Setting up a bootstrap file
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个引导文件
- en: 'The `main.ts` file is your bootstrap file and it should have the following
    content:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.ts`文件是您的引导文件，它应该具有以下内容：'
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What we do in the preceding code snippet is to provide the recently created
    module as an input parameter to the method call `bootstrapModule()`. This will
    effectively make the said module, the entry module of the application. This is
    all we need to create a working application. Let''s summarize the steps we took
    to accomplish that:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们所做的是将最近创建的模块作为输入参数传递给方法调用`bootstrapModule()`。这将有效地使该模块成为应用程序的入口模块。这就是我们创建一个工作应用程序所需的全部。让我们总结一下我们所采取的步骤：
- en: Create a component.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个组件。
- en: Create a module and register our created component in its declaration property.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模块，并在其声明属性中注册我们创建的组件。
- en: Also register our component in the modules bootstrap property to make it serve
    as an application entry point. Future components we create just need to be added
    to the `declarations` property.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要在模块的bootstrap属性中注册我们的组件，以使其成为应用程序的入口点。我们将来创建的其他组件只需要添加到`declarations`属性中即可。
- en: Bootstrap our created module by using the said module as an input parameter
    to the `bootstrapModule()` method.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将所创建的模块作为输入参数传递给`bootstrapModule()`方法来引导我们创建的模块。
- en: You as a reader have had to swallow a lot of information at this point and take
    our word for it. Don't worry, you will get a chance to get more acquainted with
    components in this chapter as well as Angular modules in upcoming chapters. For
    now, the focus was just to get you up and running by giving you a powerful tool
    in the form of the Angular CLI and show you how few steps are actually needed
    to have an app rendered to the screen.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，作为读者的你已经不得不吞下大量的信息，并相信我们的话。别担心，你将有机会在本章以及接下来的章节中更加熟悉组件和Angular模块。目前，重点只是让你快速上手，通过提供Angular
    CLI这个强大的工具，向你展示实际上只需要几个步骤就可以将应用程序渲染到屏幕上。
- en: Diving deeper into Angular components
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解Angular组件
- en: We have come a long way now, from tapping on TypeScript for the first time to
    learning how to code the basic scripting schema of an Angular component. However,
    before jumping into more abstract topics, let's try to build another component
    so we really get the hang of how creating it really works.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走了很长的路，从第一次接触TypeScript到学习如何编写Angular组件的基本脚本结构。然而，在跳入更抽象的主题之前，让我们尝试构建另一个组件，这样我们就真正掌握了创建组件的工作原理。
- en: Component methods and data updates
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件方法和数据更新
- en: 'Create a new `timer.component.ts` file in the same folder and populate it with
    the following basic implementation of a very simple component. Don''t worry about
    the added complexity, as we will review each and every change made after the code
    block:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的文件夹中创建一个新的`timer.component.ts`文件，并用以下非常简单的组件基本实现填充它。不要担心增加的复杂性，因为我们将在代码块之后审查每一次更改：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At this point, we have created a whole new component by creating the `TimerComponent`class
    and decorated it with `@Component`, just as we learned how to do in a previous
    section. We learned in the previous section that there is more to be done, namely
    to tell an Angular module that this new component exists. The Angular module is
    already created so you just need to add our fresh new component to its `declarations` property,
    like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过创建`TimerComponent`类并用`@Component`装饰它，创建了一个全新的组件，就像我们在之前的部分学到的那样。我们在之前的部分学到，还有更多要做的，即告诉Angular模块这个新组件存在。Angular模块已经创建好了，所以你只需要将我们的新组件添加到它的`declarations`属性中，就像这样：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As long as we only had the `AppComponent`we didn't really see the point of having
    an Angular module. With two components registered with our module, this changes. 
    When a component is registered with an Angular module it becomes available to
    other constructs in the module. It becomes available to their `template/templateUrl`.
    This means that we can have `TimerComponent` rendered inside of our `AppComponent`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们只有`AppComponent`，我们并没有真正看到拥有一个Angular模块的意义。有了两个组件在我们的模块中注册，这一点就改变了。当一个组件与Angular模块注册时，它就可以被模块中的其他构造使用。它可以被它们的`template/templateUrl`使用。这意味着我们可以在`AppComponent`中渲染`TimerComponent`。
- en: 'Let''s therefore go back to our `AppComponent` file and update its template
    to show just that:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回到我们的`AppComponent`文件，并更新其模板以显示这一点：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, we highlight in bold how we add the `TimerComponent` to
    the `AppComponents`template. Or rather we refer to the `TimerComponent` by its `selector` property
    name, which is `timer`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们用粗体突出显示了如何将`TimerComponent`添加到`AppComponents`模板中。或者我们通过其`selector`属性名称`timer`来引用`TimerComponent`。
- en: 'Let''s show the `TimerComponent` again, in it''s entirety, and highlight the `selector` property
    because this is a really important thing to understand; that is, how to place
    a component in another component:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次展示`TimerComponent`，并且突出显示`selector`属性，因为这是一个非常重要的事情要理解；也就是说，如何将一个组件放置在另一个组件中：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We want to do more than just display a handful of numbers, right? We actually
    want them to represent a time countdown, and we can achieve that by introducing
    these changes. Let''s first introduce a function we can iterate on in order to
    update the countdown. Add this function after the constructor function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的不仅仅是显示一些数字，对吧？我们实际上希望它们代表一个倒计时，我们可以通过引入这些更改来实现这一点。让我们首先引入一个我们可以迭代的函数，以便更新倒计时。在构造函数之后添加这个函数：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Selectors in Angular are case sensitive. As we will see later in this book,
    components are a subset of directives that can support a wide range of selectors.
    When creating components, we are supposed to set a custom tag name in the `selector`
    property by enforcing a dash-casing naming convention. When rendering that tag
    in our view, we should always close the tag as a non-void element. So `<custom-element></custom-element>` is
    correct, while `<custom-element />`will trigger an exception. Last but not least,
    certain common camel case names might conflict with the Angular implementation,
    so avoid them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的选择器是区分大小写的。正如我们将在本书的后面看到的那样，组件是指令的一个子集，可以支持各种选择器。在创建组件时，我们应该通过强制使用破折号命名约定在`selector`属性中设置一个自定义标签名称。在视图中呈现该标记时，我们应该始终将标记关闭为非void元素。因此，`<custom-element></custom-element>`是正确的，而`<custom-element
    />`将触发异常。最后但同样重要的是，某些常见的驼峰命名可能会与Angular实现发生冲突，因此应避免使用它们。
- en: Going from static to actual data
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从静态到实际数据
- en: 'As you can see here, functions in TypeScript need to be annotated with the
    type of the value they return, or just void if none. Our function assesses the
    current value of both minutes and seconds, and then either decreases their value
    or just resets it to the initial value. Then this function is called every second
    by triggering a time interval from the class constructor:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，TypeScript中的函数需要用它们返回的值的类型进行注释，或者如果没有值，则只需使用void。我们的函数评估了分钟和秒钟的当前值，然后要么减少它们的值，要么将其重置为初始值。然后通过从类构造函数触发时间间隔来每秒调用此函数：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we spot for the first time in our code an arrow function (also known as
    a lambda function, fat arrow, and so on), a new syntax for functions brought by
    ECMAScript 6, which we will cover in more detail in [Chapter 3](9b3ddd80-6ddf-43e5-92d7-a9260c11ff6d.xhtml),
    *Introducing TypeScript*. The `tick` function is also marked as private, so it
    cannot be inspected or executed outside a `PomodoroTimerComponent` object instance.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在我们的代码中第一次发现了箭头函数（也称为lambda函数，fat arrow等），这是ECMAScript 6带来的新的函数语法，我们将在[第3章](9b3ddd80-6ddf-43e5-92d7-a9260c11ff6d.xhtml)中更详细地介绍它，*介绍TypeScript*。`tick`函数也被标记为私有，因此它不能在`PomodoroTimerComponent`对象实例之外被检查或执行。
- en: 'So far so good! We have a working Pomodoro timer that countdowns from 25 minutes
    to 0, and then starts all over again. The problem is that we are replicating code
    here and there. So, let''s refactor everything a little bit to prevent code duplication:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利！我们有一个工作中的番茄工作计时器，从25分钟倒数到0，然后重新开始。问题是我们在这里和那里复制了代码。因此，让我们稍微重构一下，以防止代码重复：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have wrapped the initialization (and reset) of minutes and seconds inside
    our function `resetPomodoro`, which is called upon instantiating the component
    or reaching the end of the countdown. Wait a moment though! According to the Pomodoro
    technique, Pomodoro practitioners are allowed to rest in between Pomodoros or
    even pause them should an unexpected circumstance get in the way. We need to provide
    some sort of interactivity so the user can start, pause, and resume the current
    Pomodoro timer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将分钟和秒的初始化（和重置）包装在我们的`resetPomodoro`函数中，该函数在实例化组件或倒计时结束时被调用。不过等一下！根据番茄工作法，番茄工作者可以在番茄工作时间之间休息，甚至在意外情况发生时暂停。我们需要提供某种交互性，以便用户可以启动、暂停和恢复当前的番茄工作计时器。
- en: Adding interactivity to the component
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向组件添加交互性
- en: Angular provides top-notch support for events through a declarative interface.This
    means it is easy to hook up events and have the point to method. It's also easy
    to bind data to different HTML attributes, as you are about to learn.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Angular通过声明式接口提供了一流的事件支持。这意味着很容易连接事件并将其指向方法。将数据绑定到不同的HTML属性也很容易，你即将学到。
- en: 'Let''s first modify our template definition:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先修改我们的模板定义：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We used a multiline text string! ECMAScript 6 introduced the concept of
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了多行文本字符串！ECMAScript 6引入了这个概念。
- en: template strings, which are string literals with support for embedded expressions,
    interpolated text bindings, and multiline content. We will look into them in more
    detail in [Chapter 3](9b3ddd80-6ddf-43e5-92d7-a9260c11ff6d.xhtml), *Introducing
    TypeScript*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串，它是支持嵌入表达式、插入文本绑定和多行内容的字符串文字。我们将在[第3章](9b3ddd80-6ddf-43e5-92d7-a9260c11ff6d.xhtml)中更详细地了解它们，*介绍TypeScript*。
- en: 'In the meantime, just focus on the fact that we introduced a new chunk of HTML
    that contains a button with an event handler that listens to click events and
    executes the `togglePause()` method upon clicking. This `(click)` attribute is
    something you might not have seen before, even though it is fully compliant with
    the W3C standards. Again, we will cover this in more detail in [Chapter 4](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml),
    *Implementing Properties and Events in Our Components*. Let''s focus on the `togglePause()`
    method and the new `buttonLabel` binding. First, let''s modify our class properties
    so that they look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，只需专注于我们引入了一个新的HTML块，其中包含一个带有事件处理程序的按钮，该处理程序监听点击事件并在点击时执行`togglePause()`方法。这个`(click)`属性可能是你以前没有见过的，尽管它完全符合W3C标准。再次强调，我们将在[第4章](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml)中更详细地介绍这个内容，*在我们的组件中实现属性和事件*。让我们专注于`togglePause()`方法和新的`buttonLabel`绑定。首先，让我们修改我们的类属性，使其看起来像这样：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We introduced two new fields. The first is `buttonLabel`, which contains the
    text that will later on be displayed on our newly-created button. `isPaused` is
    a newly-created variable that will assume a`true`/`false`value, depending on the
    state of our timer. So, we might need a place to toggle the value of such a field.
    Let''s create the `togglePause()` method we mentioned earlier:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了两个新字段。第一个是`buttonLabel`，其中包含稍后将显示在我们新创建的按钮上的文本。`isPaused`是一个新创建的变量，将根据计时器的状态而假设一个`true`/`false`值。因此，我们可能需要一个地方来切换这个字段的值。让我们创建我们之前提到的`togglePause()`方法：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In a nutshell, the `togglePause()` method just switches the value of `isPaused`
    to its opposite and then, depending on such a new value and whether the timer
    has started (which would entail that any of the time variables has a value lower
    than the initialisation value) or not, we assign a different label to our button.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`togglePause()`方法只是将`isPaused`的值切换到相反的状态，然后根据这样一个新值以及计时器是否已启动（这将意味着任何时间变量的值低于初始化值）或者没有，我们为按钮分配不同的标签。
- en: 'Now, we need to initialize these values, and it seems there is no better place
    for it. So, the `reset()` function is the place where variables affecting the
    state of our class are initialized:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要初始化这些值，似乎没有比这更好的地方。因此，`reset()`函数是初始化影响我们类状态的变量的地方：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'By executing `togglePause()` every time, we reset it the to make sure that
    whenever it reaches a state where it requires to be reset, the countdown behavior
    will switch to the opposite state it had previously. There is only one tweak left
    in the controller method that handles the countdown:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行`togglePause()`时，我们都会重置它，以确保每当它达到需要重置的状态时，倒计时行为将切换到先前的相反状态。控制倒计时的控制器方法中只剩下一个调整：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Obviously, we do not want the countdown to continue when the timer is supposed
    to be paused, so we wrap the whole script in a conditional. In addition to this,
    we will want to display a different text on our button whenever the countdown
    is not paused and once again when the countdown reaches its end; stopping and
    then resetting the Pomodoro to its initial values will be the expected behavior.
    This reinforces the need of invoking the `togglePause` function within `resetPomodoro`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当计时器应该暂停时，我们不希望倒计时继续，因此我们将整个脚本包装在一个条件中。除此之外，当倒计时没有暂停时，我们将希望在按钮上显示不同的文本，并且当倒计时达到结束时再次显示；停止然后重置Pomodoro到其初始值将是预期的行为。这加强了在`resetPomodoro`中调用`togglePause`函数的必要性。
- en: Improving the data output
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进数据输出
- en: 'So far, we have reloaded the browser and played around with the newly created
    toggle feature. However, there is apparently something that still requires some
    polishing: when the seconds counter is less than 10, it displays a single-digit
    number instead of the usual two-digit numbers we are used to seeing in digital
    clocks and watches. Luckily, Angular implements a set of declarative helpers that
    format the data output in our templates. We call them pipes, and we will cover
    them in detail later in [Chapter 4](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml),
    *Implementing Properties and Events in Our Components*. For the time being, let''s
    just introduce the number pipe in our component template and configure it to format
    the seconds output to display two digits all the time. Update our template so
    that it looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经重新加载了浏览器，并尝试了新创建的切换功能。然而，显然还有一些需要一些润色的地方：当秒表显示的秒数小于10时，它显示的是一个单个数字，而不是我们在数字时钟和手表中习惯看到的两位数。幸运的是，Angular实现了一组声明性辅助工具，可以格式化我们模板中的数据输出。我们称它们为管道，我们将在[第4章](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml)中详细介绍它们，*在我们的组件中实现属性和事件*。目前，让我们在我们的组件模板中引入数字管道，并将其配置为始终显示两位数的秒数输出。更新我们的模板，使其看起来像这样：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Basically, we appended the pipe name to the interpolated binding in our template
    separated by a pipe (`|`) symbol, hence the name. Reload the template and you
    will see how the seconds figure always displays two digits, regardless of the
    value it assumes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们在模板中的插值绑定后面加上了管道名称，用管道（`|`）符号分隔，因此得名。重新加载模板，您将看到秒数始终显示两位数，而不管它所代表的值如何。
- en: We have created a fully functional Pomodoro timer widget that we can reuse or
    embed in more complex applications. [Chapter 6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml),
    *Building an Application with Angular Components*, will guide us through the process
    of embedding and nesting our components in the context of larger component trees.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个完全功能的番茄工作法定时器小部件，我们可以重复使用或嵌入到更复杂的应用程序中。[第6章](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml)，*使用Angular组件构建应用程序*，将指导我们在更大的组件树的上下文中嵌入和嵌套我们的组件的过程。
- en: 'In the meantime, let''s add some UI beautification to make our component more
    appealing. We already introduced a class attribute in our button tag as an anticipation
    of the implementation of the Bootstrap CSS framework in our project. Let''s import
    the actual style sheet we downloaded through npm when installing the project dependencies.
    Open `timer.html` and add this snippet at the end of the `<head>` element:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，让我们添加一些UI美化，使我们的组件更具吸引力。我们已经在按钮标签中引入了一个class属性，以期待在项目中实现Bootstrap CSS框架。让我们导入通过npm安装项目依赖时下载的实际样式表。打开`timer.html`，并在`<head>`元素的末尾添加以下片段：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s beautify our UI by inserting a nice page header right before our
    component:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在我们的组件之前插入一个漂亮的页面标题来美化我们的UI：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Tweaking the component button with a Bootstrap button class will give it more
    personality and wrapping the whole template in a centering container will definitely
    compound up the UI. So let''s update the template in our template to look like
    this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 调整组件按钮的Bootstrap按钮类将赋予它更多个性，将整个模板包裹在一个居中容器中将确实增强UI。所以让我们更新我们的模板，使其看起来像这样：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We looked at web components according to modern web standards and how Angular
    components provide an easy and straightforward API to build our own components.
    We covered TypeScript and some basic traits of its syntax as a preparation for
    [Chapter 3](9b3ddd80-6ddf-43e5-92d7-a9260c11ff6d.xhtml), *Introducing TypeScript*.
    We saw how to set up our working space and where to go to find the dependencies
    we need to bring TypeScript into the game and use the Angular library in our projects,
    going through the role of each dependency in our application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 根据现代网络标准，我们研究了Web组件以及Angular组件如何提供简单直接的API来构建我们自己的组件。我们介绍了TypeScript及其语法的一些基本特性，作为[第三章](9b3ddd80-6ddf-43e5-92d7-a9260c11ff6d.xhtml)《介绍TypeScript》的准备工作。我们看到了如何设置我们的工作空间，以及在哪里找到我们需要的依赖项，将TypeScript引入项目并在项目中使用Angular库，了解了每个依赖项在我们应用程序中的作用。
- en: Our first component taught us the basics of creating a component and also allowed
    us to get more familiar with another important concept, Angular modules, and also
    how to bootstrap the application. Our second component gave us the opportunity
    to discuss the form of a controller class containing property fields, constructors,
    and utility functions, and why metadata annotations are so important in the context
    of Angular applications to define how our component will integrate itself in the
    HTML environment where it will live. Our first web component features its own
    template and such templates host property bindings declaratively in the form of
    variable interpolations, conveniently formatted by pipes. Binding event listeners
    is now easier than ever and its syntax is standards-compliant.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个组件教会了我们创建组件的基础知识，也让我们更加熟悉另一个重要概念，Angular模块，以及如何引导应用程序。我们的第二个组件让我们有机会讨论控制器类的形式，其中包含属性字段、构造函数和实用函数，以及为什么元数据注解在Angular应用程序的上下文中如此重要，以定义我们的组件将如何在其所在的HTML环境中集成。我们的第一个Web组件具有自己的模板，这些模板以变量插值的形式声明性地托管属性绑定，通过管道方便地格式化。绑定事件监听器现在比以往任何时候都更容易，其语法符合标准。
- en: The next chapter will cover, in detail, all the TypeScript features we need
    to know to get up to speed with Angular in no time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将详细介绍我们需要了解的所有TypeScript特性，以便迅速掌握Angular。
