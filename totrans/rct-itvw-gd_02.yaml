- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding ReactJS Fundamentals and Its Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web development is a critical requirement for today’s modern businesses to generate
    long-term customer relationships because it provides a platform to interact with
    your customers. However, it is challenging to build scalable and optimized web
    applications for large enterprises that have heavy user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a popular programming language for web development. It has become
    more popular over the past few years, and it is used to create a wide variety
    of applications, including web-based apps, mobile apps, desktop apps, and games.
    As part of JavaScript’s evolution, a few libraries were created while keeping
    its reusable **user interface** (**UI**) in mind to speed up development, but
    they failed to improve its performance by re-rendering the whole UI even for any
    small change. This situation has been overcome by the introduction of the ReactJS
    library, which is based on composable components and it only re-renders specific
    parts of the application wherever the screen updates are required. Before we deep
    dive into ReactJS’s features, it is important to understand the fundamentals of
    React so that you can face interviews with confidence and have a strong foundation
    for the React developer role.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will give you complete knowledge of React fundamentals such as
    class components, functional components, state, props, and JSX as a starting point.
    You must understand important features such as virtual DOM unidirectional data
    flow, refs, the context API, and **server-side rendering** (**SSR**) to be able
    to answer most questions asked by interviewers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites to ReactJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to ReactJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building views with elements and components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the component data using props and state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the importance of key prop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about event handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the virtual DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difference between unidirectional data flow and bidirectional data flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing DOM elements in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing state globally using the context API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding server-side rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites to ReactJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you need to know about the following web technologies and
    topics before you can learn about ReactJS’s fundamentals and its features. These
    technologies will act as a strong foundation for learning ReactJS:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic knowledge of HTML, CSS, and JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fundamentals of ES6 features such as `let`, `const`, arrow functions, classes,
    imports and exports, the spread operator, promises and destructing, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic understanding of package managers such as npm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By understanding these prerequisites, you will have a clear understanding of
    the core building blocks of web development and commonly used ECMAScript features
    in the React ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ReactJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ReactJS’s popularity in the JavaScript community stems from its ability to build
    large-scale applications where the data changes repeatedly over time. At the beginning
    of the interview process, an interviewer expects you to discuss an introduction
    to ReactJS, its features, your reason for choosing it for programming, JSX and
    its purpose in React development, and more. So, let’s answer some introductory
    questions.
  prefs: []
  type: TYPE_NORMAL
- en: What is React?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React (also known as **React.js** or **ReactJS**) is an open source frontend
    JavaScript library that is used for building UIs, especially for single-page and
    mobile apps. It is used for handling the view layer of web and mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: React was created by Jordan Walke, a software engineer working for Facebook,
    and later maintained by the Facebook team. React was first deployed on Facebook’s
    newsfeed in 2011 and on Instagram in 2012.
  prefs: []
  type: TYPE_NORMAL
- en: What are the reasons for choosing React for programming?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React is a popular choice among frontend libraries nowadays for web development
    and there are multiple reasons for that. Here are some of the most notable reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast**: React can handle complex updates while maintaining a fast and responsive
    UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative**: It follows a declarative approach in which you write all the
    code you need. Thereafter, React is going to be in charge of taking your declared
    code and performing all the JavaScript/DOM steps for the desired output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High performance**: React has better performance compared to other JavaScript
    languages due to its less expensive DOM manipulation calls by using the virtual
    DOM strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SEO-friendly**: React allows you to create web applications that are **search
    engine optimization** (**SEO**)-friendly via SSR features. This feature makes
    apps faster with lower page load times and quicker rendering times, which, in
    turn, leads to better search engine ranking compared to **client-side** **rendering**
    (**CSR**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform**: The library supports building web applications, cross-platform
    desktop apps, and even mobile apps using React Native.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to test**: The library provides a comprehensive set of testing utilities
    to test the components easily by simulating user behavior in tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strong community support**: It has very strong community support with millions
    of developers across the globe who can access or share resources such as tutorials,
    articles, blogs, and YouTube videos and discuss them in various forums and communities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceeding reasons justify why ReactJS is a popular library compared to
    other frameworks or libraries. ReactJS also has some notable features that bring
    several benefits to businesses.
  prefs: []
  type: TYPE_NORMAL
- en: What are the major features of React?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React has some outstanding features that make it a superior choice among modern
    frontend technologies. Some of its major features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses the **JavaScript XML** (**JSX**) syntax, a syntax extension of JavaScript
    that allows developers to write HTML in their JavaScript code, which makes the
    code easy and understandable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses a virtual DOM instead of Real DOM since Real DOM manipulations are expensive.
    The legacy JavaScript frameworks update the whole DOM at once, which makes web
    applications quite slow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports SSR, which offers quick initial page load times and SEO-friendly
    applications compared to CSR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It follows a **unidirectional data flow** or one-way data binding in which the
    data flows from parent to child but not vice versa. This helps make the application
    less error-prone and easier to debug and provides more control over the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses reusable or composable UI components to develop the view at a fast pace
    and follows the **Don’t Repeat Yourself** (**DRY**) principle, which states that
    duplication in logic should be eliminated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React can be written either in **JSX** or JavaScript code, but most developers
    use JSX in their code since the benefits are worth the learning curve. The next
    section will provide answers to the most common questions you’ll be asked at the
    beginning of the interview.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is recommended that you use JSX with React to describe what the UI should
    look like in a web application. Even though JSX is not mandatory to use in React,
    it comes with several advantages, all of which we’ll cover here.
  prefs: []
  type: TYPE_NORMAL
- en: What is JSX?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSX is an XML-like syntax extension of the JavaScript language that’s based
    on ES6, which means you can structure component rendering using syntax such as
    HTML. This means it is just syntactic sugar that allows you to write HTML inside
    JavaScript and place it in the DOM without using any `createElement()` or `appendChild()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of a simple JSX code snippet to better understand
    how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After rendering the code, React outputs the content inside the `<h1>` tag to
    your DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plain JavaScript code snippet without the preceding JSX code would look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: JSX is stricter than HTML, so all the elements should have a closing tag.
  prefs: []
  type: TYPE_NORMAL
- en: Why can’t browsers understand JSX?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Web browsers can only read JavaScript objects but not JSX because there is
    no inherent implementation for the browser engines to read and understand the
    syntax. To use JSX, you need to use transpilers or compilers such as Babel to
    convert JSX code into its respective plain JavaScript code at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: JSX transpilation](img/Figure_02.01_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: JSX transpilation'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram explains how the transpilation works in JSX code.
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages of JSX?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSX is not mandatory for writing React applications, but it offers many benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: JSX makes it easier to read and understand the structure of a component just
    by seeing its layout in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most developers find it helpful as a visual aid while writing the template code
    for the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to create reusable components that can be reused throughout your
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can show useful errors and warning messages in React applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSX makes optimizations while translating the code into regular JavaScript,
    so it improves performance compared to writing normal JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you are familiar with JSX code, it is easy to build views with elements
    and components.
  prefs: []
  type: TYPE_NORMAL
- en: Building views with elements and components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both elements and components are basic building blocks for creating React views
    or apps. It is easy to build a UI with isolated, customizable, and reusable components.
    The following questions and the content they cover will help you answer the basics
    of ReactJS and will act as a foundation for the next set of questions in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: What are components?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A component is an independent, reusable code block that divides the UI into
    smaller pieces. For example, while building the UI part of a web application using
    the React library, you can break its UI into small pieces for reusability purposes,
    highlighted with blue boxes in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: React components](img/Figure_02.02_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: React components'
  prefs: []
  type: TYPE_NORMAL
- en: Each piece can be considered a component and is represented in a separate file
    instead of the UI being built in a single file. These components can be reused
    across the application wherever they are applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Each component returns some HTML code, but you can only return a single HTML
    element. Otherwise, JSX will throw an error saying *JSX expressions must have
    one* *parent element.*
  prefs: []
  type: TYPE_NORMAL
- en: What are the different ways to create components?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two possible ways to create a component in ReactJS. Let’s look at
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`props` object as the first parameter and return React elements to render the
    output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to use local state in function components after the introduction
    of the React Hooks feature.
  prefs: []
  type: TYPE_NORMAL
- en: '`React.Component`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding function component can be written as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `render()` method in the preceding code is the only mandatory method that
    needs to be implemented in every class component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is the difference between an element and a component?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An element is a plain object that describes a component instance or DOM node
    with its desired properties to represent the UI at a certain point in time. It
    contains information such as the component’s type, its properties, and any child
    elements under it. It is cheaper to create React elements compared to DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntactical representation of any React element is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of creating a simple `SignOut` React element where an element
    contains another element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `React.createElement` method returns an object, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it is rendered to the DOM using `ReactDOM.render()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same React element can be simplified and represented in JSX in a short
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: React elements are immutable – that is, once you create an element, you can’t
    modify its children or attributes further.
  prefs: []
  type: TYPE_NORMAL
- en: A component, on the other hand, is composed of React elements. In other words,
    a component is a factory for creating elements. This component can be one of two
    types – a class or a function type that optionally takes input and returns an
    element tree as output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand this concept by looking at an example that uses the preceding
    `SignOut` React element to create a React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure represents how elements and components are structured
    inside the React view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Components versus elements](img/Figure_02.03_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Components versus elements'
  prefs: []
  type: TYPE_NORMAL
- en: These components can be further categorized into pure components, **higher-order
    components** (**HOCs**), and more, alongside their specific functionality. You
    will learn more about them in the upcoming questions.
  prefs: []
  type: TYPE_NORMAL
- en: What are pure components?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pure components are components that render the same output for the same state
    and props. It is possible to achieve pure functionality within function components
    with the help of the Memoize API (that is, `React.memo()`), which you can wrap
    around the component. This API is mainly useful for performance optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: The Memoize API prevents unnecessary updates from being rendered using shallow
    comparisons of props. This means it doesn’t compare the previous state with the
    new state. This is because the function component itself prevents re-rendering
    by default when you set (that is, using the setter function) the same state again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand this memoization concept using an example. First, create a
    parent `UserEnquiryForm` component to enter the user input and then create another
    component to display the same information called `UserProfile`; this is the child
    component. The child component has been wrapped with the Memoize API to prevent
    the same prop details from being passed down from the parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `email` property has not been passed down to the
    child component. So, there won’t be any re-rendering for the changes on email
    input.
  prefs: []
  type: TYPE_NORMAL
- en: However, in class components, the component will become a pure component since
    we extended it with `PureComponent` instead of `Component`. Internally, a pure
    component implements the `shouldComponentUpdate()` life cycle method with shallow
    comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that all React components act like pure functions concerning
    their props. This guideline helps improve performance as it prevents unnecessary
    re-renders and avoids unexpected bugs in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from pure components, another special type of component is also created
    as a pattern in the React ecosystem. It works as a pure function with zero side
    effects, similar to a pure component’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: What is a higher-order component?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An HOC is a function that takes a component and returns a new component. HOCs
    are not part of the React API but they are an advanced technique for reusing component
    logic. You can share props and states between components using HOCs.
  prefs: []
  type: TYPE_NORMAL
- en: 'An HOC can be represented with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Third-party libraries such as Redux’s `connect` and Relay’s `createFragmentContainer`
    have been created based on the HOC concept.
  prefs: []
  type: TYPE_NORMAL
- en: What are fragments and where do you use them?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A React fragment is a syntax that allows you to wrap or group a list of child
    elements to a React component without the need to add an extra node to the DOM.
    You can use either `<Fragment>` or a shorter syntax with an empty tag (`<></>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s take an `Author` component to represent an author who has
    posted several blog posts. This component loops through the author’s blog posts
    and displays them without adding an extra DOM node such as `<div>` or `<span>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `<Fragment>` tag is used to support the `key`
    prop while iterating the list items. The alternative `<></>` syntax doesn’t support
    key attributes. Hence, it is preferred to use `<Fragment>` over `<></>` if you’re
    iterating the list items.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few more benefits of using fragments:'
  prefs: []
  type: TYPE_NORMAL
- en: Fragments are faster and use less memory on very large or deep DOM trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS frameworks or libraries such as `<div>` element will disturb the desired
    layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DOM inspector is less clustered since it doesn’t contain any additional
    DOM nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you understand the various building blocks of a component, you can
    easily learn how to control the data in a component or between components. Data
    management is crucial for any web application.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling component data using props and state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data inside a component is controlled by props and state. All kinds of React
    applications are based on these two concepts, and they are important core topics
    that help with creating efficient and robust applications. These topics are not
    only useful in interviews, as you will also encounter their usage in everyday
    jobs.
  prefs: []
  type: TYPE_NORMAL
- en: What are props in React?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Props, which stands for properties, are arguments that appear in the form of
    either individual values or an object holding a set of values that are passed
    into components. Their naming convention is similar to that of HTML attributes.
    They help pass data from the parent component to the child component and are used
    to render the child component dynamically on the screen. This means that props
    act as a channel for components to communicate inside the component tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main purpose of props in React is to achieve the following component functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Pass the custom data to your component based on business needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trigger state changes in a component based on the prop’s value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access props via `props.propName` for a function component or `this.props.reactProp`
    for a class component inside the component’s rendering code. This data is helpful
    for conditionally rendering the UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of how props are passed from a parent component
    to a child component (in this case, `Employee`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `defaultProps` property has been used to assign the
    default values of props. These will be used if no explicit props are passed.
  prefs: []
  type: TYPE_NORMAL
- en: The better alternative to access the properties of a props object is by using
    destructuring from ES6 (ECMAScript 2015).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of destructuring, the preceding child component can be rewritten
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Props are immutable (read-only) in nature and trying to modify these values
    will throw an error. If you still need to modify the data in a component, then
    state is the right choice for managing your data.
  prefs: []
  type: TYPE_NORMAL
- en: Can you describe state in React?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: State is an in-built JavaScript object where you store property values that
    belong to the component. In other words, state is private and fully controlled
    by the component. The crucial part of state is that whenever the state object
    changes, the component re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scope of state is always inside the component, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Scope of state inside a component](img/Figure_02.04_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Scope of state inside a component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `User` functional component with a welcome message
    as the state to explain more about its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `useState` Hook was used to add state to the `User`
    component. It returns an array which contains the current state and the setter
    function to update the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to the functional component, the class component holds the state properties
    inside a built-in state object and accesses it through `this.state.message` inside
    the `User` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The built-in `setState` function is used to update the state of the preceding
    class component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to make the state variable as simple as possible for readability
    purposes and minimize the stateful components to achieve a single source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: What are the main differences between props and state?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both props and state are plain JavaScript objects that are used to manage the
    data of a component, but they are used in different ways and have different characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Props** | **State** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Read-only and immutable | Mutable and changes asynchronously |'
  prefs: []
  type: TYPE_TB
- en: '| Props are passed from the parent component to the child component | Managed
    by the component itself |'
  prefs: []
  type: TYPE_TB
- en: '| Accessed by child components | Cannot be accessed by child components |'
  prefs: []
  type: TYPE_TB
- en: '| Props make components reusable | State cannot make components reusable |'
  prefs: []
  type: TYPE_TB
- en: '| Used for communication between components | Used for rendering dynamic changes
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.1: Props versus state'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike props, state can be updated in different ways. Let’s learn more about
    batching multiple state updates.
  prefs: []
  type: TYPE_NORMAL
- en: How does React batch multiple state updates?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React prevents components from re-rendering for each state update. React makes
    this possible by optimizing application performance using group updates within
    event handlers with the help of built-in Hooks. This entire process is known as
    **batching**. React version 17 only supports batching for browser events, whereas
    React version 18 supports an improved version of batching known as **automatic
    batching**.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic batching supports state updates that are invoked from any location
    instead of just browser events. In other words, it supports native event handlers,
    asynchronous operations, timeouts, and intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example demonstrating automatic batching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Even though the preceding code updates two state variables using an event handler,
    React will batch them automatically by default and the component will only re-render
    once.
  prefs: []
  type: TYPE_NORMAL
- en: Can you prevent automatic batching?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automatic batching is a great feature of the React library that optimizes rendering
    performance. However, there are situations where you need to re-render your component
    for each state update or update one state depending on another updated state value.
    React introduced the `flushSync` API function from ReactDOM to stop automatic
    batching whenever necessary. This function is also useful for use cases where
    you need to flush updates immediately to the DOM in case you’re integrating with
    third-party code such as browser APIs and UI libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say you want to update the scroll position on a web page
    after adding a new to do or task to a simple to do list app. This behavior is
    helpful if you wish to have a direct focus on the new to do content. In this scenario,
    the latest to do state needs to be updated immediately for you to get the correct
    scroll position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The usage of this function is not common and using it can often impact application
    performance badly.
  prefs: []
  type: TYPE_NORMAL
- en: How do you update objects inside the state?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You shouldn’t update React’s state object directly. Instead, you need to create
    a new object or make a copy of the existing object and then set the state with
    the newly created object. So, while updating the state object, you always need
    to treat objects inside the state as read-only, even though JavaScript objects
    are mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this comparison in action and show the results of these two updating
    processes. As an example, the `WeatherReport` component has been created, along
    with its properties, including `temperature` and `city`. After that, component
    properties are mutated directly inside the event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once the preceding code has been deployed, try to enter the new weather details
    in the UI. You will see that the input fields won’t get updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can fix this by creating a new copy of the `weather` object and then setting
    the state. To do that, let’s update the preceding event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code updates the weather details in the UI as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, only one field needs to be modified in the state object. In this
    case, it is recommended to use object spread syntax to get the benefit of reusing
    the previous state object property values instead of setting each field in the
    state.
  prefs: []
  type: TYPE_NORMAL
- en: How do you update nested state objects?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is quite easy to update top-level state objects with the spread syntax. But
    when it comes to nested state objects, you cannot update the required nested property
    directly like you can in regular JavaScript objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be explained further with an example: we’ll take a nested state object
    and modify the nested property inside it. To demonstrate this behavior, let’s
    consider the `User` state object with nested address details as a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can try to update the `postalCodeproperty` using an expression like
    `user.address.postalCode = 75015` in your React components, similar to how you
    do in plain JavaScript. The screen won’t be updated with the latest value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is not possible to flatten the nested `User` object as a workaround,
    then there are two possible approaches to update the state properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`updatedAddress`) using the spread syntax. After that, create a new top-level
    object (`updatedUser`) that points to the newly created nested object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Update nested object with a single** **function call**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also possible to update the nested object together with a top-level object
    by using the spread syntax within a single state setter function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you would like to go beyond the traditional approach, third-party libraries
    such as **Immer** provide a convenient way to update the deeply nested state objects.
    This library enables direct nested object updates just like regular JavaScript
    updates the properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mutating nested objects using Immer looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The component’s state can be an array of items as well, not just a primitive
    value or an object type. However, you need to supply the additional key prop,
    as detailed in the upcoming questions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the importance of key props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keys help you control component or element instances. They play a major role
    in deciding whether the element needs to be re-rendered or not in a list of elements.
    Hence, every developer should have an idea about the importance of a key prop.
  prefs: []
  type: TYPE_NORMAL
- en: What is a key prop and what is the purpose of it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **key** is a special attribute that you need to include when creating a list
    of elements in a component. This key prop helps React identify which elements
    have changed and been added or removed. In other words, it helps you retain a
    unique identity of the elements or among the siblings in the list even after the
    elements have been modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you don’t supply a key prop, the list can render the content to the
    browser successfully, but with a warning message logged in the console, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended to use a unique ID value from the data as a key prop. This
    value can be a string or number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand this key prop concept in a better way by implementing the
    to do list of a programmer. Here, you are assigning a key to the `TodoItem` component
    while iterating from the list and not to the extracted `<``li>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is discouraged to assign indexes (received from iterating the list of elements)
    as keys because if the elements of the list get reordered in the future, then
    the keys of the elements will also change.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about event handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event handling is essential for interacting with a web page in an application.
    React has its own event handling ecosystem. The event handler determines what
    action has to be taken whenever a particular event is fired. This section will
    give you a good understanding of event handling in the React library.
  prefs: []
  type: TYPE_NORMAL
- en: What are synthetic events?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A synthetic event is a cross-browser wrapper around a browser’s actual native
    event object. It provides a unified API that prevents browser inconsistencies
    and ensures that the event works across multiple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some similarities between synthetic events and native events if you
    use the same `preventDefault` and `stopPropogation` methods in those two events.
    It is also possible to access native events directly by using the `nativeEvent`
    attribute on the `syntheticEvent` instance. As an example, the following search
    component is still able to access the native input event and other properties
    or methods inside the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The event handling in React has a few differences compared to HTML event handling,
    which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How do you differentiate between React event handling and HTML event handling?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React event handling is similar to event handling DOM elements in HTML. However,
    there are some notable differences between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Naming convention**: In HTML, the name of the event is represented in lowercase
    as a convention:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`false` inside the event handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, let’s take a simple login form that contains a username and
    a password field to input the data. After submitting the form, you need to restrict
    the default behavior of an `onsubmit` event, and the enclosing form must not be
    refreshed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, in React, the default behavior can be prevented by calling the `event.preventDefault()`
    method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`()`) after the function name or use `addEventListener()` to attach events
    and listeners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following example shows a button `onclick` event and invoking the respective
    handler. This can be done in two ways.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the first approach, you can insert parentheses for the `handleSiginUp`
    function’s name:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How do you bind event handlers in class components?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways to bind event handlers in React class components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`this` keyword in a constructor function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, let’s add a `handleUserDetails()` binding inside the constructor:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you forget to bind the handler, the `this` keyword will be undefined when
    the function is invoked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Public class** **fields syntax**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are not interested in binding handlers in the constructor, the public
    class fields approach is much better for readability and ease of use. This syntax
    is enabled by default in the **Create React App** (**CRA**) tool.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The previous binding approach can be rewritten and simplified using public
    class fields syntax, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`this` keyword explicitly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The arrow function is passed in the `User` component callback, like so:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The main problem with this arrow function approach is that a different callback
    is created every time the component renders, and the child component might do
    extra re-rendering if the callbacks are passed as props to child components. Hence,
    it is recommended to use either a binding in a constructor or the public class
    fields syntax approach.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The magic behind the React library, including syncing the component data with
    the UI, DOM updates, and more, is taken care of by the virtual DOM. In the next
    section, you will learn about virtual DOM, its importance, and its processes behind
    the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**DOM** stands for **Document Object Model** and it represents the entire UI
    of a web page (HTML) in a tree data format. virtual DOM was not invented by React,
    but it uses it as its core feature. Its main purpose is to minimize the number
    of DOM operations when re-rendering the UI. React uses this feature to enhance
    its performance. There’s a high chance you’ll get questions related to this topic
    in an interview.'
  prefs: []
  type: TYPE_NORMAL
- en: What is virtual DOM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: virtual DOM is an in-memory, lightweight virtual representation of Real DOM
    that’s generated by React components. The virtual representation of a UI is stored
    in memory and synced with Real DOM to align with the latest state updates. This
    is possible through a library known as **ReactDOM**, and this step happens in
    between the render function being called and elements being displayed on the screen.
    This entire process is known as **reconciliation**.
  prefs: []
  type: TYPE_NORMAL
- en: How does virtual DOM work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React and Vue.js technologies use virtual DOM under the hood to abstract the
    manual DOM operations away from developers. This programming mechanism works in
    four major steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s take a simple search form with an inputfield inside the
    `CitySearch component` and see how the virtual DOM works. We’ll provide diagrams
    for ease of understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceeding city search works internally with the following steps of virtual
    DOM mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application is rendered for the first time, React creates a virtual
    DOM representing the UI and stores the same in memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 2.5: Initial \uFEFFvrtual DOM](img/Figure_02.05_B18603.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Initial vrtual DOM'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever the underlying state changes, it will automatically create a new virtual
    DOM for the update. Since virtual DOM is just an object representing the UI, there
    won’t be any changes (such as repainting) in the UI at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 2.6: Updated \uFEFFvirtual DOM](img/Figure_02.06_B18603.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Updated virtual DOM'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the new virtual DOM has been created, React compares it to a pre-updated
    version or snapshot of virtual DOM. React uses the **diffing** algorithm to compare
    the changes; this process is known as **reconciliation**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![  Figure 2.7: Comparing \uFEFFvirtual DOM snapshots](img/Figure_02.07_B18603.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Comparing virtual DOM snapshots'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the reconciliation process, React uses a render library such as ReactDOM,
    which takes the changes and updates that in Real DOM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.8: Updated Real DOM](img/Figure_02.08_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Updated Real DOM'
  prefs: []
  type: TYPE_NORMAL
- en: What is Shadow DOM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shadow DOM is a web component technology that’s designed primarily for scoping
    variables and CSS. This is useful when CSS styles defined in a parent component
    don’t affect or apply to a child component.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between Real DOM, virtual DOM, and Shadow DOM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In modern web development, virtual DOM and shadow DOM have been introduced to
    improve performance and encapsulation as add-ons to real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the notable differences among these three DOMs are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Real DOM** | **Virtual DOM** | **Shadow DOM** |'
  prefs: []
  type: TYPE_TB
- en: '| It creates a single DOM for the entire screen | It creates a copy of the
    entire real DOM in memory and keeps track of changes | It creates small copies
    of Real DOM with its isolated scope (that is, scoped CSS styles and JavaScript)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Any change will involve re-rendering the whole screen | The state change
    will involve re-rendering the specific part of the page | The changes apply to
    its own web component |'
  prefs: []
  type: TYPE_TB
- en: '| Implemented in web browsers, such as via the Solid.js library | Implemented
    in JavaScript libraries such as React, Vue, and others | Implemented in web components,
    such as Lit and Vaadin libraries |'
  prefs: []
  type: TYPE_TB
- en: '| Suitable for small to medium scale applications without complex interactivity
    | Suitable for large-scale applications with complex interactivity | Suitable
    for small to medium scale applications with less complex interactivity |'
  prefs: []
  type: TYPE_TB
- en: '| Uses less CPU and memory compared to virtual DOM | Uses more CPU and memory
    compared to Real DOM | Uses less CPU and memory compared to virtual DOM |'
  prefs: []
  type: TYPE_TB
- en: '| Doesn’t support encapsulation because components can be modified outside
    | Supports encapsulation because components cannot be modified outside | Supports
    encapsulation because components cannot be modified outside |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.2: Real DOM versus irtual DOM versus Shadow DOM'
  prefs: []
  type: TYPE_NORMAL
- en: What is React Fiber?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fiber is a new reconciliation engine that was introduced in React version 16
    to enable in-built scheduling and incremental rendering of virtual DOM. Incremental
    rendering means having the ability to split rendering work into chunks and spread
    it out over multiple frames. So, with the help of incremental rendering, Fiber
    improves application performance in areas such as animation, layout, and gestures.
  prefs: []
  type: TYPE_NORMAL
- en: This reconciler is a complete rewrite of an old reconciliation algorithm called
    **stack reconciler**.
  prefs: []
  type: TYPE_NORMAL
- en: Data flow and communication in React applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unidirectional data flow feature of React makes the UI simple and predictable
    for data changes in small to large-scale applications. It is quite important to
    know the benefits of data flow and communication between components to better
    understand the relevant React concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Can you describe unidirectional data flow in React?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unidirectional data flow is also known as one-way data binding and is where
    the data flows one way only while being transferred between different parts of
    an application. This technique or feature already exists in functional reactive
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: React follows unidirectional data flow, where the data is transferred from parent
    to child using props but not vice versa. Moreover, the child components can’t
    update data that comes from the parent component. React doesn’t encourage bidirectional
    or two-way binding to make sure you are following a clean data flow architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure gives a clearer idea of the data flow in React:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.9: Unidirectional versus \uFEFFbidirectional data flow](img/Figure_02.09_B18603.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Unidirectional versus bidirectional data flow'
  prefs: []
  type: TYPE_NORMAL
- en: The only way to update the data in the parent component is by triggering the
    events from the child component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to React, Vue.js follows two-way data binding or bidirectional data
    flow between the components.
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages of unidirectional data flow?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main advantage of unidirectional data flow is having a single source of
    truth for your data. There are many other advantages of the unidirectional data
    flow feature. Some of the key benefits are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugging**: Since the developers know where the data comes from and where
    it goes, it is much easier to debug problems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less error-prone**: The data flows in one direction, which makes the programs
    less error-prone and gives the developers better control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: No extra resources are wasted with the known boundaries of
    unidirectional data flow in the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot always depend on the state, props, and data flow concepts to control
    the view layer. Irrespective of the JavaScript library, you may need access to
    DOM elements, and accessing elements through conventional approaches such as `document.getElementById`
    becomes cumbersome. In the next section, you will find a better alternative to
    access DOM.
  prefs: []
  type: TYPE_NORMAL
- en: How do you access DOM?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DOM manipulation is taken care of by the React library under the hood, without
    the need for any manual DOM updates. But sometimes, you might encounter use cases
    (focusing, scrolling to specific elements, and so on) to have DOM element access
    managed by React. As a solution to these use cases, refs have been introduced
    to access the DOM nodes.
  prefs: []
  type: TYPE_NORMAL
- en: A React interviewer might expect a good knowledge of DOM access and possible
    use cases, both of which cannot be handled through a traditional declarative approach.
  prefs: []
  type: TYPE_NORMAL
- en: What are refs? How do you create refs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`current` attribute of the ref. In other words, refs are plain JavaScript objects
    with additional  current property. To understand this ref concept in a better
    way, let’s look at an example of implementing auto-focus behavior for an input
    element using a ref. To do that, we''ll follow the following instructions::'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `useRef` Hook from the React library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare `inputRef` inside the `SignUpForm` component with the return value of
    the Hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass `inputRef` to the `<input>` element, which connects the input’s DOM node
    to the `inputRef.current` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While loading the component instance, apply focus to an input element programmatically
    by calling `focus()` on the DOM node within the `useEffect` Hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After following all the preceding steps, the final component that’s using refs
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Similar to how the `useRef` Hook is used in function components, `createRef`
    is typically used when creating a ref in a class component.
  prefs: []
  type: TYPE_NORMAL
- en: What is the main purpose of refs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main purpose of refs is to imperatively modify a child outside of the typical
    one-way data flow. A few common use cases that can be handled through refs as
    an escape hatch are discussed here:'
  prefs: []
  type: TYPE_NORMAL
- en: For the first use case, let’s talk about how UI elements are modified through
    certain events or actions. This use case category includes scenarios such as managing
    input field focus, text selection, and media control (or playback).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, let’s look at the aforementioned text selection and audio scenarios
    controlled through external button clicks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the second use case, let’s talk about triggering imperative animations in
    the UI without writing any explicit animations either through CSS or JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of accessing the `div` element and finding its position
    based on the scroll event to perform certain actions in the layout:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the third use case, let’s discuss integrating with third-party DOM libraries
    in a React application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to integrate an existing application with some of the JavaScript
    plugins or libraries using refs. For example, third-party plugins such as `DataTable.js`
    and `select2` can easily be accessed inside React applications without recreating
    them from scratch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to avoid refs if you can implement the task declaratively.
  prefs: []
  type: TYPE_NORMAL
- en: How do you compare refs with state?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both refs and state are used to persist the component data between renders.
    However, there are many differences between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Ref** | **State** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Created by the `useRef(initialValue)` Hook, which returns the `{current:
    initialValue}` JavaScript object | Created by the `useState(initialValue)` Hook,
    which returns the current state value and the setter function to update the state–
    that is, `[``value, setValue]` |'
  prefs: []
  type: TYPE_TB
- en: '| Doesn’t trigger a re-render for any changes that are made to it | Triggers
    a re-render for any change in state |'
  prefs: []
  type: TYPE_TB
- en: '| It is often used to communicate with external APIs | It is frequently used
    within a component to change its appearance |'
  prefs: []
  type: TYPE_TB
- en: '| It is possible to update the `current` attribute value outside the rendering
    process – that is, ref is mutable | You should not update the state variables
    directly; a setter function should be used to modify the value – that is, state
    is immutable |'
  prefs: []
  type: TYPE_TB
- en: '| React cannot track ref changes | React can track state changes |'
  prefs: []
  type: TYPE_TB
- en: '| You shouldn’t read or write refs during the rendering process | You can read
    state at any time |'
  prefs: []
  type: TYPE_TB
- en: '| Avoid using refs unless declarative views based on state can’t be implemented,
    since changes to the DOM structure may conflict with React’s `diff` and `update`
    approach | It’s always recommended to use state for UI updates |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.3: Ref versus state'
  prefs: []
  type: TYPE_NORMAL
- en: Even though refs are less strict (in terms of mutation) than state, most of
    the time, you will be using state over refs because refs are an escape hatch for
    accessing the DOM, which you don’t need that often.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are storing the information across the re-renders without rendering on
    the screen, then you should use refs. Otherwise, you always need to use state
    to store data.
  prefs: []
  type: TYPE_NORMAL
- en: What are forward refs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nowadays, components are more complex and barely use plain HTML elements directly.
    This leads to a parent and child component hierarchy with composable views. If
    you just try to pass down the ref to the child component as a prop, the child
    component won’t receive the actual DOM element that needs to be accessed. Instead,
    it returns `{` `current:` `null}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'React’s `forwardRef` is a method that allows a parent component to pass down
    refs to its children. In the following example, the child component receivesa
    ref from its parent component by wrapping it with the `forwardRef` method. This,
    in turn, forwards it to the `<button/>` DOM element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding child component receives a `ref` as a second argument, whereas
    the first argument refers to `props`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can limit the information you expose about your DOM node instead of passing
    the entire DOM node using the `userImperativeHandle` Hook. You will learn more
    about this Hook in [*Chapter 3*](B18603_03.xhtml#_idTextAnchor110).
  prefs: []
  type: TYPE_NORMAL
- en: Managing state globally using the context API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Context helps you share global data with the child components, even though those
    components exist at a deeper level in the component tree. You can perform state
    management for large-scale applications by using the context API and Hooks. There’s
    a high chance you’ll get interview questions related to context implementation
    to solve common use cases regarding maintaining data globally in React applications.
  prefs: []
  type: TYPE_NORMAL
- en: What is prop drilling?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prop drilling refers to the process of sending props from a higher-level component
    to a lower-level component in a component tree by going through several other
    components in the middle that don’t need the data but only help in passing it
    around. This prop drilling term doesn’t exist in ReactJS officially, but it is
    frequently used to represent the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Can you describe context?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Context is used to solve the prop drilling issue. It provides a way to pass
    data from parent-level components to child components by storing the data in a
    central location without the need to pass the data manually at each level of the
    component tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use context in React by following three simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createContext(defaultValue)` factory function from the React library is used
    to create the context object. It only accepts one argument to provide the default
    value. Let’s create a user context with the default username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Context.Provider` component needs to be applied to the parent component with
    the context changes that were supplied to its child components. The `value` prop
    on this component is used to set the context value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this step, the `username` field is going to be updated with current user
    details as context for the provider component:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The child components that need to consume the context should be wrapped inside
    the provider component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`useContext` Hook. This Hook returns the value of the context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will learn more about the `useContext` Hook in [*Chapter 3*](B18603_03.xhtml#_idTextAnchor110).
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps have been represented with a diagram to help you understand context
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: Context in action](img/Figure_02.10_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Context in action'
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of context?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main purpose of context is to allow your components to access global data
    without you facing any prop drilling problems and re-render the components when
    the global data has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the common use cases of context:'
  prefs: []
  type: TYPE_NORMAL
- en: Theme information for applying branding to the entire application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticated user profile information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preferred language settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we’ve learned how to render the React application on the client side.
    In the next section, you will learn how to render web content on the server side
    to improve page loading speed, along with a few other benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the server-side rendering technique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SSR** is rapidly becoming a more prominent feature in JavaScript libraries
    and frameworks. React-based frameworks such as Next.js, Gatsby, and others make
    creating SSR much easier. Nowadays, interviewers expect a good knowledge of SSR,
    along with regular **CSR**.'
  prefs: []
  type: TYPE_NORMAL
- en: What is server-side rendering?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSR is a popular alternative rendering method for **single-page applications**
    (**SPAs**). This technique renders a client-side SPA on the server and then sends
    a fully rendered HTML page to the client. This is helpful for SEO purposes because
    search engines can easily find the content first before they send the page to
    the users.
  prefs: []
  type: TYPE_NORMAL
- en: What is the main difference between server-side rendering and client-side rendering?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSR is the rendering mode in which the browser downloads a minimal HTML page
    and it renders using JavaScript. The data fetching, templating, and routing processes
    are handled on the client side – that is, by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: SSR, on the other hand, converts HTML files on the server into a fully rendered
    HTML page that includes the data for the client.
  prefs: []
  type: TYPE_NORMAL
- en: When do you need to use server-side rendering?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Which rendering method is used depends on the requirements of the business.
    But here, we have mentioned a few situations where you can consider using SSR:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are prioritizing SEO and building a blog site, it is recommended to use
    SSR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your website needs a faster initial page load time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the application has a simple UI with less interactivity with a smaller number
    of features and pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the application contains less dynamic data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user traffic on the website is less
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few other pre-rendering techniques are also available, such as **static site
    generation** (**SSG**) and **incremental static regeneration** (**ISR**), both
    of which will be discussed in [*Chapter 9*](B18603_09.xhtml#_idTextAnchor276).
  prefs: []
  type: TYPE_NORMAL
- en: We have now answered a lot of fundamental questions about React. This knowledge
    also acts as a foundation for answering the next stage of questions in the upcoming
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed a lot of fundamental concepts that are frequently
    asked about in React interviews. We started by introducing ReactJS and JSX and
    discussing their advantages in building robust web applications. Then, we went
    on to talk about the core building blocks of ReactJS, such as elements, components,
    props, and state, and how the virtual DOM and one-way data flow work behind the
    scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we covered questions related to an application’s interaction through
    event handling and how to share data globally using context and SSR in the React
    ecosystem. In the next chapter, we will consider questions related to Hooks, their
    importance, and how Hooks make React so much better by implementing functionalities
    faster and more effectively.
  prefs: []
  type: TYPE_NORMAL
