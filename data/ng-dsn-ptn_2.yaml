- en: Angular Bootstrapping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular引导
- en: After [Chapter 1](9e3f2df1-9ef2-4c24-9c47-ceabcb13fdb8.xhtml), *Typescript Best
    Practices*, we can dive into Angular itself. One of the focuses of Angular was
    to drastically improve the performance and loading time of Angular applications
    compared to AngularJS. The performance improvements are outstanding. According
    to the Angular team and various benchmarks, Angular 2 is between five and eight
    times faster than Angular 1.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](9e3f2df1-9ef2-4c24-9c47-ceabcb13fdb8.xhtml)之后，*Typescript最佳实践*，我们可以深入了解Angular本身。Angular的一个重点是大幅提高Angular应用程序的性能和加载时间，与AngularJS相比。性能改进是非常显著的。根据Angular团队和各种基准测试，Angular
    2比Angular 1快5到8倍。
- en: Now, to achieve this kind of improvement, Google engineers did not build upon
    AngularJS; instead, they created Angular from scratch. Consequently, having worked
    with Angular 1 for some time, this will not give you a sizable edge over newcomers
    to the Angular world when it comes to developing Angular applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种改进，谷歌工程师并没有在AngularJS的基础上进行开发；相反，他们从头开始创建了Angular。因此，如果你已经使用Angular 1一段时间，这并不会在开发Angular应用程序时给你带来很大的优势。
- en: 'In this chapter, we will do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将做以下事情：
- en: I will first present the major architectural concepts behind Angular.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将首先介绍Angular背后的主要架构概念。
- en: Then, we will bootstrap an Angular application using the newly introduced Angular
    CLI tool that takes away most of the getting started pain. There are hundreds
    of Angular boilerplates on the web, and choosing one can be time-consuming, to
    say the least. You can enjoy any flavors on GitHub with tests, with libraries,
    for mobiles, with build and deployment scripts, and so on.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将使用新引入的Angular CLI工具引导一个Angular应用程序，这将消除大部分入门的痛苦。网上有数百种Angular样板，选择一个可能会耗费大量时间。你可以在GitHub上找到各种风格的样板，带有测试、带有库、用于移动设备、带有构建和部署脚本等等。
- en: While this diversity and enthusiasm from the community is a good thing, it means
    that no two Angular projects look the same. Indeed, the chances are that both
    projects were created with a different boilerplate or without any. To fix this
    problem, the Angular team is now proposing angular CLI. Angular CLI is a command-line
    node package that allows developers to create new applications based on an official
    boilerplate. This tool also provides some useful features, such as the creation
    of the different building blocks of an Angular application, building, testing,
    and minifying your application. It even supports the deployment of your application
    to GitHub pages with one short command.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管社区的多样性和热情是一件好事，但这意味着没有两个Angular项目看起来一样。事实上，这两个项目很可能是用不同的样板创建的，或者根本没有使用样板。为了解决这个问题，Angular团队现在提出了angular
    CLI。Angular CLI是一个命令行node包，允许开发人员基于官方样板创建新的应用程序。这个工具还提供了一些有用的功能，比如创建Angular应用程序的不同构建模块，构建、测试和压缩你的应用程序。它甚至支持用一个简短的命令将你的应用程序部署到GitHub页面上。
- en: It's still a new tool, and it has numerous drawbacks and unpolished behaviors.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是一个新工具，它有许多缺点和未完善的行为。
- en: Architectural overview
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构概述
- en: 'In this section, I will present the main building blocks of Angular applications:
    Service, Component, Template, and Directive. We will also learn what problems
    are solved by dependency injection, decorators, and zones.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将介绍Angular应用程序的主要构建模块：服务、组件、模板和指令。我们还将学习依赖注入、装饰器和区域解决了哪些问题。
- en: Now, if you picked this book off the (virtual) shelf, you likely have some experience
    with Angular and want to improve your applications with good practices and design
    patterns. Therefore, you should have some knowledge about the general architecture
    of Angular building blocks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你从（虚拟）书架上拿起这本书，你很可能有一些关于Angular的经验，并希望通过良好的实践和设计模式来改进你的应用程序。因此，你应该对Angular构建块的一般架构有一些了解。
- en: Nevertheless, a quick and pragmatic reminder should not hurt much, and we can
    be sure that we have a solid architectural basis to build our patterns upon.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个快速而务实的提醒不会有太大的伤害，我们可以确信我们有一个坚实的架构基础来构建我们的模式。
- en: 'Here is an overview of how the main Angular 2 building blocks interact with
    each other:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是主要的Angular 2构建块如何相互交互的概述：
- en: '![](assets/dbbe6f43-adec-4ebb-a6cf-590c1c876429.png)High-level architecture
    of an Angular 2 application'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dbbe6f43-adec-4ebb-a6cf-590c1c876429.png)Angular 2应用程序的高级架构'
- en: 'In what follows, I will present an example of each Angular 2 building block
    by creating an application that manipulates the Floyd array. Here is an example
    of a letter-based Floyd array:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将通过创建一个操作Floyd数组的应用程序来介绍每个Angular 2构建块的示例。以下是一个基于字母的Floyd数组的示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I agree that you are not very likely to build an application dealing with Floyd
    arrays in the near future. Nevertheless, Floyd arrays are a good programming exercise
    when learning a new language or framework, as it involves user input, displaying
    results, loops, and string manipulation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意你不太可能在不久的将来构建处理Floyd数组的应用程序。然而，当学习新语言或框架时，Floyd数组是一个很好的编程练习，因为它涉及用户输入、显示结果、循环和字符串操作。
- en: Component
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: 'Components are the views of our Angular application in the sense that they
    control what, when, and how things should be displayed on the screen. They take
    the form of a simple class that defines the logic required by your views. Here''s
    an example of a simple component:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是我们Angular应用程序的视图，它们控制屏幕上的内容、时间和方式。它们采用一个简单的类的形式，定义了视图所需的逻辑。以下是一个简单组件的示例：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the component class has a suffix: `Component`. I will discuss the
    reasons in the next chapter.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，组件类有一个后缀：`Component`。我将在下一章讨论原因。
- en: 'This component named `FloydComponent` has two private members: `floydString`
    and `startOfAlphabet`. The `floydString` will contain the string representing
    an n^(th) Floyd triangle, while`startOfAlphabet` is constantly marking the position
    of the letter in the ASCII table.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为`FloydComponent`的组件有两个私有成员：`floydString`和`startOfAlphabet`。`floydString`将包含表示第n个Floyd三角形的字符串，而`startOfAlphabet`则不断标记ASCII表中字母的位置。
- en: The `FloydComponent` also defines a constructor, which will be invoked when
    the user requests the patch of screen our component manages. For now, the constructor
    is empty.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`FloydComponent`还定义了一个构造函数，当用户请求我们组件管理的屏幕补丁时将被调用。目前，构造函数是空的。'
- en: Finally, the `onClick` method accepting a number argument called `rows` will
    generate a Floyd triangle of `rows`. To sum up, we have a class managing the behavior
    of a view showcasing a Floyd triangle. Yes? Well, the view part is kind of missing!
    Where is my HTML for client-side rendering?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，接受一个名为`rows`的数字参数的`onClick`方法将生成一个由`rows`行组成的Floyd三角形。总之，我们有一个管理展示Floyd三角形行为的视图的类。是的？嗯，视图部分有点缺失！我的用于客户端渲染的HTML在哪里？
- en: 'In Angular, the piece of HTML our component will have control over is known
    as a template, and we can link the template on the component using metadata:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们的组件将控制的HTML部分被称为模板，我们可以使用元数据将模板链接到组件上：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, what's all that fuss about? If we look back at the original definition of
    the `FloydComponent`, there's nothing specifying that `FloydComponent` is a component.
    We don't have anything like `FloydComponent` extending/implementing components,
    so it's just a plain typescript class and nothing else. Even more surprisingly,
    there are no Angular references at all; this `FloydComponent` could totally be
    a typescript class outside of the Angular framework.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这一切到底是怎么回事？如果我们回顾一下`FloydComponent`的原始定义，没有任何地方指定`FloydComponent`是一个组件。我们没有像`FloydComponent`扩展/实现组件的任何东西，所以它只是一个普通的typescript类，什么都不是。更令人惊讶的是，根本没有Angular的引用；这个`FloydComponent`完全可以是Angular框架之外的一个typescript类。
- en: The metadata is decorating the `FloydComponent` class using the decorator pattern,
    so Angular knows how to interpret and process the `FloydComponent` class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据使用装饰器模式装饰`FloydComponent`类，因此Angular知道如何解释和处理`FloydComponent`类。
- en: In any object-oriented languages, it is easy to extend the responsibilities
    of an object statically by using inheritance, however, doing so dynamically, at
    runtime, is a completely different matter. The purpose of the decorator pattern
    is to add additional responsibilities dynamically to an object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何面向对象的语言中，通过继承静态地扩展对象的责任是很容易的，但是在运行时动态地这样做是完全不同的。装饰器模式的目的是在对象上动态地添加额外的责任。
- en: We will implement our very own decorator in [Chapter 3](fac4936a-292a-4b12-ac60-394bacad0f16.xhtml), *Classical
    Patterns*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《第3章》《经典模式》中实现我们自己的装饰器。
- en: The annotation itself is `@Component`, and makes our class an Angular component
    with some arguments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注解本身是`@Component`，并使用一些参数使我们的类成为Angular组件。
- en: Note the `import { Component } from '@angular/core';` which imports the `Component`
    module from the `'@angular/core'` library.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`import { Component } from '@angular/core';`导入了`@angular/core`库中的`Component`模块。
- en: 'The first argument is a `selector` that describes which part of the view our
    `FloydComponent` should bind itself to. In the following HTML snippet, we have
    the `<floyd></floyd>` selector markup that the `FloydComponent` will bind to.
    The second argument is the template string. The template string defines what will
    be added to the DOM, at runtime, inside the `<floyd>` markup:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个`selector`，描述了我们的`FloydComponent`应该绑定到视图的哪个部分。在下面的HTML片段中，我们有`<floyd></floyd>`选择器标记，`FloydComponent`将绑定到它。第二个参数是模板字符串。模板字符串定义了在运行时将添加到DOM中的内容，位于`<floyd>`标记内部：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The backtick ` allows us to define multiline strings in JavaScript.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号`允许我们在JavaScript中定义多行字符串。
- en: 'First, we have the `<input>` markup, which looks almost like pure HTML. The
    only particularity is the `#rows` attribute in the markup. This attribute is used
    to reference the markup as a variable named `rows`. Hence, we can access its value
    in the following markup: `<button (click)="onClick(rows.value)">CLICK</button>`.
    Here, we have an event binding between the template and the component. When the
    button is clicked, the `onClick` method of the component will be invoked, and
    the value of the input will be fed to the method.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有`<input>`标记，看起来几乎像纯HTML。唯一的特殊之处在于标记中的`#rows`属性。这个属性用于将标记引用为名为`rows`的变量。因此，我们可以在下面的标记中访问它的值：`<button
    (click)="onClick(rows.value)">CLICK</button>`。在这里，我们在模板和组件之间进行了事件绑定。当按钮被点击时，组件的`onClick`方法将被调用，并且输入的值将被传递给该方法。
- en: Further down the code, we have `{{floydString}}`, which is a property binding
    from the component to the template. In this particular case, we bind the `floydString`
    component property to the template. In other words, we display the content of
    the `floydString` component property in the DOM.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的下方，我们有`{{floydString}}`，这是从组件到模板的属性绑定。在这种情况下，我们将`floydString`组件属性绑定到模板上。换句话说，我们在DOM中显示`floydString`组件属性的内容。
- en: I have to use the pre markup, so the `\n\r` are preserved in the output.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须使用预先标记，以便`\n\r`在输出中得到保留。
- en: 'To sum this up, the component binds its property to the template and the template
    binds its events to the component. Here''s a screenshot of what to expect when
    running this application:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，组件将其属性绑定到模板，而模板将其事件绑定到组件。运行此应用程序时可以期待以下截图：
- en: '![](assets/8f8cd7fc-91c8-4425-9003-c9d1123708e6.png)Floyd array with Angular
    2Is it not working on your side? Want to fork the code on GitHub? You can see
    the whole application, as of now, at [http://bit.ly/angular2-patterns-chap2](http://bit.ly/angular2-patterns-chap2).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/8f8cd7fc-91c8-4425-9003-c9d1123708e6.png)Angular 2中的Floyd数组在你这边不起作用吗？想要在GitHub上fork这段代码吗？你现在可以在[http://bit.ly/angular2-patterns-chap2](http://bit.ly/angular2-patterns-chap2)看到整个应用程序。'
- en: Services
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: For now, we have reviewed two out of four of the building blocks of Angular
    2\. The remaining two are services and directives. The next block we are going
    to review services. Services are classes with a unique purpose that shall be,
    as much as possible, cohesive in the sense that they provide a narrow and well-defined
    service to other parts of the application. From a design point of view, what could
    be nice for our Floyd triangle application is to have the content of the `FloydComponent.onClick`
    method inside a service. Indeed, the computation of the `floydString` string does
    not have its place in a component managing the view.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经审查了Angular 2的四个构建块中的两个。剩下的两个是服务和指令。接下来我们将审查服务。服务是具有独特目的的类，它们应尽可能地具有内聚性，以便为应用程序的其他部分提供狭窄而明确定义的服务。从设计的角度来看，对于我们的Floyd三角形应用程序来说，将`FloydComponent.onClick`方法的内容放在一个服务中可能会更好。实际上，`floydString`字符串的计算不应该出现在管理视图的组件中。
- en: 'A component should only be in charge of the user experience—binding properties
    to a template—and nothing else. Every other one should be delegated to services.
    What we can do is create a triangle service that will be in charge of *drum rolls*
    creating weird triangles such as Floyd triangle. We can also make this service
    in charge of generating Floyd triangles where the output would be looking like
    a tree:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 组件应该只负责用户体验——将属性绑定到模板——其他所有事情都应该委托给服务。我们可以创建一个三角形服务，负责*鼓掌*创建像Floyd三角形这样的奇怪三角形。我们还可以让这个服务负责生成Floyd三角形，输出看起来像一棵树：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Such a service would look like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的服务看起来会像下面这样：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `TriangleService` is a simple class that offers two methods: `floydTriangle`
    and `evenFloydTriangle`. The `evenFloydTriangle` has an additional for loop to
    add the leading spaces at the different rows of the triangle. The business application
    now sits on a dedicated service that we can use on our `FloydComponent`. The right
    way to use our service in the `FloydComponent` is through dependency injection.
    Dependency injection is a process by which a requesting class gets a fully formed
    instance of a requested class dynamically. To apply this rather technical definition
    to our context, upon instantiation, the `FloydComponent` will be served an instance
    of the `TriangleService`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`TriangleService`是一个简单的类，提供两种方法：`floydTriangle`和`evenFloydTriangle`。`evenFloydTriangle`有一个额外的for循环，用于在三角形的不同行添加前导空格。业务应用现在位于一个专用的服务上，我们可以在`FloydComponent`上使用它。在`FloydComponent`中使用我们的服务的正确方法是通过依赖注入。依赖注入是一个过程，通过该过程，请求类会动态地获得所请求类的一个完整形式的实例。将这个相当技术性的定义应用到我们的上下文中，`FloydComponent`在实例化时将获得`TriangleService`的一个实例。'
- en: 'To use dependency injection with Angular, we need to define a provider for
    the `TriangleService`. We can do this at the application level:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Angular中使用依赖注入，我们需要为`TriangleService`定义一个提供者。我们可以在应用程序级别这样做：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, we can do this at the component level by defining providers
    in the component annotations:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在组件注解中定义提供者，以在组件级别进行此操作：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the provider is created at the application level, then the same instance
    of the `TriangleService` will be served to anyone requesting it. At the component
    level, however, a new instance of the `TriangleService` will be created and served
    to the component each time said component is instantiated. Both cases can make
    sense. It depends on what your components and your services are doing. For example,
    the logging service we will implement in [Chapter 7](c337464a-e6d1-42f0-9a07-8ece3bcf7ae1.xhtml),
    *Operations Patterns*, does not have a state of its own and is used by every module
    of the application. Consequently, we can use an application-based provider. The
    counterexample would be the *Circuit breaker* pattern from [Chapter 5](d7f0be25-e37c-40f7-944c-d888d23c43eb.xhtml),
    *Stability Patterns*, which does have an inner state, and hence, a component level.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用程序级别创建提供者，那么`TriangleService`的相同实例将提供给任何请求它的人。然而，在组件级别，每次实例化该组件时都会创建一个新的`TriangleService`实例并提供给该组件。这两种情况都是有道理的。这取决于你的组件和你的服务在做什么。例如，我们将在[第7章](c337464a-e6d1-42f0-9a07-8ece3bcf7ae1.xhtml)中实现的日志服务没有自己的状态，并且被应用程序的每个模块使用。因此，我们可以使用基于应用程序的提供者。反例是来自[第5章](d7f0be25-e37c-40f7-944c-d888d23c43eb.xhtml)的*Circuit
    breaker*模式，*稳定性模式*，它具有内部状态，因此是组件级别的。
- en: 'The final touch is to modify our `FloydComponent` constructor so that it looks
    like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是修改我们的`FloydComponent`构造函数，使其看起来像这样：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we define a private member named `triangleService` for our `FloydComponent`,
    which will be used as a placeholder for the injected dependency.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为我们的`FloydComponent`定义了一个名为`triangleService`的私有成员，它将被用作注入的依赖项的占位符。
- en: 'In addition, we add a checkbox in the template, which will be used to determine
    if we want an even or a normal Floyd array:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在模板中添加一个复选框，用于确定我们是要一个偶数还是一个普通的Floyd数组：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also modify the `onClick` method to use our `TriangleService`. The final
    component looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以修改`onClick`方法以使用我们的`TriangleService`。最终组件看起来像这样：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The current state of the application can be seen here: [http://bit.ly/angular2-patterns-chap2-part2](http://bit.ly/angular2-patterns-chap2-part2).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的当前状态可以在这里看到：[http://bit.ly/angular2-patterns-chap2-part2](http://bit.ly/angular2-patterns-chap2-part2)。
- en: Directives
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令
- en: To conclude our quick architectural overview, we will create a directive to
    enhance our rather fade pre-markup. Directives are interacting with a template
    and with their parent component regarding property and event bindings. We will
    create a directive that adds style to our pre-markup. The style involves a 1 px
    border and changes the background color to red or yellow for an even or odd Floyd
    array, respectively.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 结束我们快速的架构概述，我们将创建一个指令来增强我们相当单调的预标记。指令与模板以及它们的父组件进行属性和事件绑定交互。我们将创建一个指令，为我们的预标记添加样式。样式包括1像素边框，并将背景颜色更改为红色或黄色，分别用于偶数或奇数的Floyd数组。
- en: 'First, we need a way to ask the user which kind of array he/she wants. Let''s
    add another input in the template of the `FloydComponent` and modify the `onClick`
    method so it accepts a second argument:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一种方法来询问用户希望使用哪种类型的数组。让我们在`FloydComponent`的模板中添加另一个输入，并修改`onClick`方法，使其接受第二个参数：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we can create the directive. It will look like the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建指令。它将如下所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A lot happens here. First, we have the directive annotation with a selector.
    The selector will be used to signify that a given HTML markup depends on the directive.
    In our case, I chose to name the directive `AngularPre` and to have the same name
    for the selector. They can be different; it is up to you. However, it does make
    sense to have the same name for the selector and the class so you know which file
    to open when your directive is going sideways.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情。首先，我们有带有选择器的指令注释。选择器将用于表示给定的HTML标记取决于指令。在我们的例子中，我选择将指令命名为`AngularPre`，并为选择器使用相同的名称。它们可以不同；这取决于你。但是，选择器和类具有相同的名称是有意义的，这样你就知道当你的指令出现问题时应该打开哪个文件。
- en: Then, we have the very interesting `@Input()` annotating the `highlightColor:string;`member.
    Here, we specify that the value of the `highlightColor` string is, in fact, bound
    to the variable from the parent component. In other words, the parent will have
    to specify the color in which it wants the pre-markup to be highlighted. In the
    constructor, the directive received an `ElementRef` object by injection. This
    `ElementRef` represents the DOM on which your directive acts. Finally, we define
    two `HostListener` on `mouseenter` and `mouseleave` that will start and stop the
    highlighting of the pre-markup, respectively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有非常有趣的`@Input()`注释`highlightColor:string;`成员。在这里，我们指定`highlightColor`字符串的值实际上绑定到父组件的变量。换句话说，父组件将不得不指定它希望预标记突出显示的颜色。在构造函数中，指令通过注入接收了一个`ElementRef`对象。这个`ElementRef`代表了您的指令作用的DOM。最后，我们在`mouseenter`和`mouseleave`上定义了两个`HostListener`，它们将分别开始和停止预标记的突出显示。
- en: 'To use this directive, we have to insert its selector in the pre-markup of
    the `FloydComponent` template as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个指令，我们必须在`FloydComponent`模板的预标记中插入其选择器，如下所示：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we specify that we want our pre-markup to be affected by the directive
    with the `AngularPre` selector, and we bind the `highlightColor` variable of the
    invoked directive with the color variable of the `FloydComponent`. Here''s the
    `FloydComponent` with the color variable and a slight modification of the `onClick`
    method, so it changes the value of the color variable:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定我们希望我们的预标记受到`AngularPre`选择器的影响，并将调用指令的`highlightColor`变量与`FloydComponent`的颜色变量绑定。这是带有颜色变量和`onClick`方法的`FloydComponent`，所以它改变颜色变量的值：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is what the application looks like with an odd array:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序使用奇数数组的样子：
- en: '![](assets/0cde42b3-4ba2-43e8-a027-5569c720fc65.png)Odd Floyd array result'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/0cde42b3-4ba2-43e8-a027-5569c720fc65.png)奇数Floyd数组结果'
- en: 'This is what it looks like with an even array:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是偶数数组的样子：
- en: '![](assets/ad758f35-adca-4c72-80ce-70c536f880c6.png)Even Floyd array resultThe
    application is downloadable here: [http://bit.ly/angular2-patterns-chap2-part3](http://bit.ly/angular2-patterns-chap2-part3).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ad758f35-adca-4c72-80ce-70c536f880c6.png)甚至弗洛伊德数组结果该应用程序可在此处下载：[http://bit.ly/angular2-patterns-chap2-part3](http://bit.ly/angular2-patterns-chap2-part3)。'
- en: Pipes
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: 'The last two building blocks that I want to explain here are pipes and routes.
    pipes are wonderful. They allow us to create a specialized class that will take
    and transform any input into the desired output. In Angular, pipes follow the
    Unix pipes programming paradigm, where information can be passed from one process
    to another. What we can do with our Floyd triangle-based application creates a
    Pipe that will transform any given Floyd string to include the ASCII character
    for a paragraph `¶` (`244, &para;`) every time it encounters the newline sequences
    (such as `\n\r`):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里解释的最后两个构建块是管道和路由。管道很棒。它们允许我们创建一个专门的类，将任何输入转换为所需的输出。在Angular中，管道遵循Unix管道编程范式，其中信息可以从一个进程传递到另一个进程。我们可以在基于弗洛伊德三角形的应用程序中创建一个管道，该管道将在每次遇到换行序列（如`\n\r`）时将任何给定的弗洛伊德字符串转换为包含段落`¶`（`244，&para;`）的ASCII字符：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Pipes are decorated using the `@Pipe` annotation very much like component and
    directive. Now, the difference with pipes, compared to component and directive,
    is that, as well as decorating the annotation, we have to implement an interface
    provided by the Angular framework. This interface is named `PipeTransform` and
    defines a single method that every class implementing it must have:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 管道使用`@Pipe`注解进行装饰，非常类似于组件和指令。现在，与管道相比，与组件和指令相比的区别在于，除了装饰注解之外，我们还必须实现Angular框架提供的一个接口。这个接口被命名为`PipeTransform`，并定义了每个实现它的类必须具有的单个方法：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The actual signature of this method is composed of any types, as pipes can
    be used for everything, not only strings. In our case, we want to manipulate a
    string input and have a string output. We can refine the signature of the transform
    method without breaking the interface contract, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的实际签名由任何类型组成，因为管道可以用于一切，不仅仅是字符串。在我们的情况下，我们想要操作一个字符串输入并获得一个字符串输出。我们可以在不违反接口合同的情况下，细化`transform`方法的签名，如下所示：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we expect only one string argument and produce a string output. The body
    of this method contains a global regex matching all the `\n\r` sequence and adds
    `¶`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只期望一个字符串参数并产生一个字符串输出。该方法的主体包含一个全局正则表达式，匹配所有的`\n\r`序列并添加`¶`。
- en: 'To use the `ParagraphPipe` in the `FloydComponent`, we have to modify the template
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`FloydComponent`中使用`ParagraphPipe`，我们必须修改模板如下：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `floydString` is piped to the `ParagraphPipe` using the `|` operator. Here''s
    what''s it looks like:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`floydString`通过`|`运算符传递给`ParagraphPipe`。这是它的样子：'
- en: '![](assets/b4b0a918-007d-4c73-a98f-f0821f5042cc.png)Piping the floydString
    to have a paragraph marker'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b4b0a918-007d-4c73-a98f-f0821f5042cc.png)将floydString管道化以获得段落标记'
- en: 'The fact that the paragraph pipe hardcodes the paragraph symbol bugs me a little.
    What if I want to change it on a per-usage basis? Well, Angular is handling many
    additional parameters for your pipes. We can modify the `transform` method to
    the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 段落管道硬编码段落符号让我有点烦。如果我想要根据每次使用来更改它怎么办？嗯，Angular正在处理许多额外的管道参数。我们可以修改`transform`方法如下：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Moreover, we can do so with the pipe call like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以这样调用管道：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the first argument of the `transform`method will be the `floydString`,
    while the second will be the paragraph symbol.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`transform`方法的第一个参数将是`floydString`，而第二个参数将是段落符号。
- en: 'If we think about it, we are currently implementing the `replaceAll` function
    for Typescript except for the target (`\n\r` is hardcoded). Let''s create a Pipe
    named `replaceAll` that has both the target to replace and its replacement as
    a parameter. The only problem is that the `PipeTransform` interface defines a
    transform method with two parameters, the second one being optional. Here, we
    need three parameters: the string to transform, the target to replace inside the
    string, and the replacement for the target. If you do try to have a transform
    method with three parameters, then you will break the `PipeTransform` contract,
    and your Typescript will not compile anymore. To circumvent this minor setback,
    we can define an inline type named `replace` that will contain two members, `from`
    and `to`, that are both strings:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑一下，我们目前正在为Typescript实现`replaceAll`函数，除了目标（`\n\r`是硬编码的）。让我们创建一个名为`replaceAll`的管道，它将目标替换和替换作为参数。唯一的问题是`PipeTransform`接口定义了一个带有两个参数的transform方法，第二个参数是可选的。在这里，我们需要三个参数：要转换的字符串，要在字符串中替换的目标，以及目标的替换。如果你尝试使用三个参数来定义一个transform方法，那么你将违反`PipeTransform`的约定，你的Typescript将不再编译。为了克服这个小问题，我们可以定义一个名为`replace`的内联类型，它将包含两个成员，`from`和`to`，它们都是字符串：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are using `\\n\\r` for the strings pattern as we are not building a
    `RegExp` just yet. Consequently, the `\` of `\n` and `\r` need to be escaped.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`\\n\\r`作为字符串模式，因为我们还没有构建`RegExp`。因此，`\`需要转义`\n`和`\r`。
- en: 'Here''s the code of the `replaceAll` pipe:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`replaceAll`管道的代码：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Not so bad, huh? We have filled one of the shortcomings of JavaScript, the
    `replaceAll` functionality, in a modular and efficient way. This `replaceAll`
    pipe will be usable everywhere in your application:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，对吧？我们已经填补了JavaScript的一个缺点，即`replaceAll`功能，以一种模块化和高效的方式。这个`replaceAll`管道将在你的应用程序中随处可用：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last thing to know about the pipes is that you can combine them just like
    in the Unix console. For example, we could totally do the following, where the
    paragraph pipe kicks in first and adds the `¶` to the end of all lines. Then,
    the `replaceAll` pipe intervenes and replaces all the `¶` by `¶` piped:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关于管道的最后一件事是，你可以像在Unix控制台中一样组合它们。例如，我们完全可以做以下事情，其中段落管道首先添加`¶`到所有行的末尾。然后，`replaceAll`管道介入并替换所有的`¶`为`¶`管道：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The current state of the application is downloadable here: [http://bit.ly/angular2-patterns-chap2-part5](http://bit.ly/angular2-patterns-chap2-part5).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的当前状态可以在这里下载：[http://bit.ly/angular2-patterns-chap2-part5](http://bit.ly/angular2-patterns-chap2-part5)。
- en: Routes
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: Routes enable navigation between Angular views. In this recipe, we'll learn
    about them and see them in action within the framework of a small application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 路由使得在Angular视图之间进行导航成为可能。在这个教程中，我们将了解它们，并在一个小应用程序的框架内看到它们的运作。
- en: Angular CLI
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular CLI
- en: The **Angular CLI** is a very simple, yet extremely useful, node package that
    takes the form of a command-line tool. The purpose of this tool is to take away
    most of the pain of getting started with Angular 2\. The problem with any application
    based on a framework is to know how to bootstrap things for your code to communicate
    smoothly with the framework's features and libraries.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular CLI**是一个非常简单但非常有用的node包，它采用命令行工具的形式。这个工具的目的是消除大部分与Angular 2开始的痛苦。基于框架的任何应用程序的问题是如何为你的代码引导事物，以便与框架的特性和库进行顺畅的通信。'
- en: This tool, provided directly by the Angular team, provides working blueprints
    for ready-to-go applications. Indeed, by using one simple command we can generate
    a complete boilerplate for Angular that can be transpiled, run locally, tested,
    and even deployed to GitHub pages.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具是由 Angular 团队直接提供的，它为即将启动的应用程序提供了可用的蓝图。实际上，通过使用一个简单的命令，我们可以生成一个完整的 Angular
    样板，可以进行转译、本地运行、测试，甚至部署到 GitHub 页面。
- en: Installation
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'Installing the Angular CLI is dead simple as it''s a `node` package. The following
    command will work, regardless of your operating system:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Angular CLI 非常简单，因为它是一个 `node` 包。无论您使用什么操作系统，以下命令都可以工作：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you are using a Unix-based system, a `sudo` might be required for global
    installations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是基于 Unix 的系统，全局安装可能需要 `sudo`。
- en: Creating a new application
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的应用程序
- en: 'Once the Angular CLI is installed, we can begin by generating a new Angular
    application with the `ng new` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Angular CLI，我们就可以通过使用 `ng new` 命令来生成一个新的 Angular 应用程序。
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command will create an empty boilerplate for your application and fetch
    every required node module.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将为您的应用程序创建一个空的样板，并获取每个所需的节点模块。
- en: Note that, depending on your internet connection, this command can take a while
    to complete. Indeed, the node packages to fetch are many, which further justifies
    such a tool.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据您的互联网连接，这个命令可能需要一段时间才能完成。实际上，需要获取的节点包很多，这进一步证明了这样一个工具的必要性。
- en: 'At the root level of the newly created folder, you can find the following files
    and folders:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的文件夹的根目录，您可以找到以下文件和文件夹：
- en: '`Angular-cli-build.js`: A config file to build your application.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Angular-cli-build.js`：用于构建应用程序的配置文件。'
- en: '`config`: A config folder for the test environment.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`：测试环境的配置文件夹。'
- en: '`Node_modules`: The different node modules required. As I am writing these
    lines, the current version of the Angular CLI already has 60,886 files and folders
    in the node-modules directory.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node_modules`：所需的不同的节点模块。当我写下这些文字时，Angular CLI 的当前版本已经在 node-modules 目录中有
    60,886 个文件和文件夹。'
- en: '`Public`: Contains what''s public for your app.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Public`：包含应用程序公共部分。'
- en: '`tslint.json`: Configuration for your linter. We will configure it in the next
    chapter.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tslint.json`：您的 linter 的配置。我们将在下一章中对其进行配置。'
- en: '`typings.json`: Typings dependencies.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typings.json`：Typings 依赖。'
- en: '`angular-cli.json`: Some configuration for your app.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angular-cli.json`：应用程序的一些配置。'
- en: '`e2e`: e2e configuration.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e2e`：e2e 配置。'
- en: '`package.json`: Dependencies for your app.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`：应用程序的依赖项。'
- en: '`src`**:** Your source code.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`**:** 您的源代码。'
- en: '`typings`: Required typings.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typings`：所需的 typings。'
- en: 'Indisputably, the folder in which we will spend the most time is the `src`
    folder, as it contains the TypeScript source code. Here''s what''s inside it after
    creation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，我们将花费最多时间的文件夹是 `src` 文件夹，因为它包含了 TypeScript 源代码。创建后，它里面包含以下内容：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, there is an `app` folder that already contains a component
    named `my-app`and a shared folder that can be used to share resources between
    different apps. Then, we have the `index.html` containing the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这里有一个 `app` 文件夹，里面已经包含了一个名为 `my-app` 的组件，还有一个共享文件夹，可以用来在不同的应用程序之间共享资源。然后，我们有包含以下内容的
    `index.html`：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this `index.html`, the `<app-root></app-root>` markup is inserted and the
    required files are loaded into the script.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `index.html` 中，插入了 `<app-root></app-root>` 标记，并将所需的文件加载到脚本中。
- en: 'Another important point is the `main.ts` file, which contains the bootstrapping
    lines for your application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的地方是 `main.ts` 文件，它包含了应用程序的引导行：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, the `MyAppAppComponent` component is imported and used as the top-level
    or root component for our application. This is the component that will be instantiated
    first.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MyAppAppComponent` 组件被导入并用作我们应用程序的顶层或根组件。这是将首先实例化的组件。
- en: Generating
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成
- en: For now, our application is not exactly exciting; it will only display `my-app
    works!`in an `h1` markup.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序并不是特别令人兴奋；它只会在`h1`标记中显示`my-app works!`。
- en: 'If we want to add components, directives, services, and pipes to this boilerplate,
    we have to use the `generate` command. Here''s an example to generate a new component
    named `Floyd`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要向这个样板添加组件、指令、服务和管道，我们必须使用`generate`命令。以下是一个生成名为`Floyd`的新组件的示例：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In response, the Angular CLI created a new folder named `Floyd` and the required
    files for our component:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，Angular CLI 创建了一个名为`Floyd`的新文件夹和我们组件所需的文件：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can do the same operation using directive, service, or pipe instead of component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用指令、服务或管道来执行相同的操作，而不是组件。
- en: Every keyword in the Angular CLI can be abbreviated by using only the first
    letter of the word. So, generating another component named `Pascal` would read
    `ng g c Pascal`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 中的每个关键字都可以通过仅使用单词的第一个字母来缩写。因此，生成另一个名为`Pascal`的组件将会是`ng g c Pascal`。
- en: Serving
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: We have a bunch of components, services, directives, and pipes in our application,
    and we are ready to see the result. Thankfully, Angular CLI can build your application
    and start up a web server using the command `ng serve`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中有许多组件、服务、指令和管道，我们已经准备好看到结果了。幸运的是，Angular CLI 可以构建您的应用程序，并使用命令`ng serve`启动
    Web 服务器。
- en: Then, you can see your application at `localhost:4200`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在`localhost:4200`上查看您的应用程序。
- en: Your files are watched by the Angular CLI. Every time you make a change to a
    file, the Angular CLI will recompile it and refresh your browser.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您的文件正在被 Angular CLI 监视。每当您对文件进行更改时，Angular CLI 将重新编译它并刷新您的浏览器。
- en: Deploying
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: Ready to make your application live? `ng build` is what you are looking for.
    This command will create a `dist` directory that you can push onto any server
    capable of serving HTML pages. It can even be on GitHub pages, which will not
    cost you a single cent.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 准备让您的应用程序上线了吗？`ng build`就是您要找的。这个命令将创建一个`dist`目录，您可以将其推送到任何能够提供 HTML 页面的服务器上。甚至可以放在
    GitHub 页面上，这不会花费您一分钱。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have completed an overview of the Angular building blocks
    and seen how they interact with each other. We have also created a relatively
    simple application manipulating Floyd arrays. Finally, we learned how to use the
    Angular CLI to create new applications, components, services, directives, and
    pipes using the command line.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经完成了对 Angular 构建模块的概述，并看到它们是如何相互交互的。我们还创建了一个相对简单的应用程序来操作 Floyd 数组。最后，我们学会了如何使用
    Angular CLI 来使用命令行创建新应用程序、组件、服务、指令和管道。
- en: In the next chapter, we will focus on Angular good practices. We will discover
    the "do's and don'ts" recommended by Google engineers in a practical way.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于 Angular 的最佳实践。我们将以实际的方式了解谷歌工程师推荐的“做”和“不做”。
