- en: '*Chapter 4*: Sharing Module State with Subscription'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：通过订阅共享模块状态'
- en: In the previous chapter, we learned how to use Context for a global state. As
    discussed, Context is not designed for the singleton pattern; it's a mechanism
    for avoiding the singleton pattern and providing different values for different
    subtrees. For a singleton-like a global state, using a module state makes more
    sense because it's a singleton value in memory. The goal of this chapter is to
    learn to use a module state with React. It's a less well-known pattern than Context,
    but is often used to integrate the existing module state.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 Context 实现全局状态。正如讨论的那样，Context 并非为单例模式而设计；它是一个避免单例模式并提供不同子树不同值的机制。对于类似全局状态的单例，使用模块状态更有意义，因为它在内存中是一个单例值。本章的目标是学习如何使用
    React 中的模块状态。它比 Context 少为人知，但经常用于集成现有的模块状态。
- en: What Is a Module State?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是模块状态？
- en: A strict definition of a module state would be some constants or variables defined
    in **ECMAScript** (**ES**) module scopes. In this book, we aren't following the
    strict definition. You can simply assume that a module state is a variable defined
    globally or within the scope of a file.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 模块状态的严格定义是一些在 **ECMAScript** （**ES**） 模块作用域中定义的常量或变量。在这本书中，我们并不遵循严格的定义。你可以简单地假设模块状态是一个在全局范围内或在文件作用域内定义的变量。
- en: We'll explore how to use a module state as a global state in React. In order
    to use a module state in React components, we use a subscription mechanism.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何在 React 中将模块状态用作全局状态。为了在 React 组件中使用模块状态，我们使用订阅机制。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring the module state
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索模块状态
- en: Using a module state as a global state in React
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 中使用模块状态作为全局状态
- en: Adding a basic Subscription
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加基本订阅
- en: Working with a selector and `useSubscription`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选择器和 `useSubscription`
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You are expected to have a moderate knowledge of React, including React Hooks.
    Refer to the official site at [https://reactjs.org](https://reactjs.org) to learn
    more.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 预期你具备一定的 React 知识，包括 React Hooks。请参考官方网站 [https://reactjs.org](https://reactjs.org)
    了解更多信息。
- en: In some code, we use TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org))
    and you should have a basic knowledge of this.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些代码中，我们使用 TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org))，你应该对此有基本的了解。
- en: 'The code in this chapter is available on GitHub:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_04](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_04)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_04](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_04)'
- en: To run code snippets, you need a React environment, for example, Create React
    App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码片段，你需要一个 React 环境，例如，Create React App ([https://create-react-app.dev](https://create-react-app.dev))
    或 CodeSandbox ([https://codesandbox.io](https://codesandbox.io))。
- en: Exploring the module state
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索模块状态
- en: The module state is a variable defined at the module level. *Module* here means
    an ES module or just a file. For simplicity, we assume that a variable defined
    outside a function is a module state.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模块状态是在模块级别定义的变量。这里的 **Module** 指的是 ES 模块或只是一个文件。为了简化，我们假设在函数外部定义的变量是模块状态。
- en: 'For example, let''s define the `count` state:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们定义 `count` 状态：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assuming this is defined in a module, this is a module state.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这是在模块中定义的，这是一个模块状态。
- en: 'Typically, with React, we want to have an object state. The following defines
    an object state with `count`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用 React，我们希望有一个对象状态。以下定义了一个包含 `count` 的对象状态：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: More properties can be added to the object. Nesting objects are also possible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向对象添加更多属性。嵌套对象也是可能的。
- en: 'Now, let''s define functions to access this module state. `getState` is a function
    to read `state`, and `setState` is a function to write `state`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义函数来访问这个模块状态。`getState` 是一个读取 `state` 的函数，而 `setState` 是一个写入 `state`
    的函数：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that we added `export` to these functions to express that they are expected
    to be used outside the module.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为这些函数添加了 `export`，以表达它们预期将在模块外部使用。
- en: 'In React, we often update a state with functions. Let''s modify `setState`
    to allow a `function` update:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，我们经常使用函数更新状态。让我们修改 `setState` 以允许使用 `function` 更新：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can use a function update as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方式使用函数更新：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Instead of defining a module state directly, we can create a function for creating
    a container that includes `state` and some access functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接定义模块状态，而不是创建一个用于创建包含 `state` 和一些访问函数的容器的函数。
- en: 'The following is the concrete implementation of such a function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这样函数的具体实现：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can use this as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样使用它：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So far, a module state has nothing to do with React. In the next section, we'll
    learn how to use a module state with React.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，模块状态与 React 没有任何关系。在下一节中，我们将学习如何使用模块状态与 React 一起使用。
- en: Using a module state as a global state in React
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React 中使用模块状态作为全局状态
- en: As we discussed in [*Chapter 3*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049),
    *Sharing Component State with Context*, React Context is designed to provide different
    values for different subtrees. Using React Context for a singleton global state
    is a valid operation, but it doesn't use the full capability of Context.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 3 章*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049) 中讨论的，*使用 Context
    共享组件状态*，React Context 被设计为为不同的子树提供不同的值。使用 React Context 来实现单例全局状态是一个有效的操作，但它没有使用
    Context 的全部功能。
- en: If what you need is a global state for an entire tree, a module state might
    fit better. However, to use a module state in a React component, we need to handle
    re-rendering ourselves.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个整个树的全球状态，模块状态可能更适合。然而，要在 React 组件中使用模块状态，我们需要自己处理重新渲染。
- en: 'Let''s start with a simple example. Unfortunately, this is a non-working example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始。不幸的是，这是一个无效的例子：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will see `count` `0` at the beginning. Clicking `button` increases the `count`
    variable, but it doesn't trigger the component to re-render.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在开始时看到 `count` 为 `0`。点击 `button` 会增加 `count` 变量，但它不会触发组件重新渲染。
- en: At the time of writing this book, React has only two hooks, `useState` and `useReducer`,
    to trigger re-renders. We need to use either of those to make a component reactive
    with a module state.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这本书的时候，React 只有 `useState` 和 `useReducer` 两个 hooks 来触发重新渲染。我们需要使用这两个中的一个来使组件具有模块状态的反应性。
- en: 'The previous example can work with the following modification:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前一个示例的修改：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, if you click `button`, it will increase the `count` variable, as well as
    trigger the component.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你点击 `button`，它将增加 `count` 变量，并触发组件。
- en: 'Let''s see what happens if we have another component like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们有另一个如下所示的组件会发生什么：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Even if you click `button` in `Component1`, it won't trigger `Component2` to
    re-render. Only when you click `button` in `Component2` will it re-render and
    show the latest module state. This is the inconsistency between `Component1` and
    `Component2`, and our expectation is that both components should show the same
    value. The inconsistency also happens with two `Component1` components.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在 `Component1` 中点击 `button`，它也不会触发 `Component2` 重新渲染。只有当你点击 `Component2`
    中的 `button` 时，它才会重新渲染并显示最新的模块状态。这是 `Component1` 和 `Component2` 之间的不一致，我们的期望是两个组件都应该显示相同的值。两个
    `Component1` 组件之间也会发生这种不一致。
- en: One naive approach to this problem is to invoke `setState` functions in `Component1`
    and `Component2` at the same time. This requires having `setState` functions at
    the module level. We should also consider the component life cycle and use the
    `useEffect` hook to modify a set that holds `setState` functions outside React.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的天真方法是同时在 `Component1` 和 `Component2` 中调用 `setState` 函数。这需要在模块级别拥有 `setState`
    函数。我们还应该考虑组件的生命周期，并使用 `useEffect` hook 来修改一个包含 `setState` 函数的集合，这些函数位于 React 之外。
- en: 'The following example is one possible solution. This is to illustrate the idea
    and is not very practical:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个可能的解决方案示例。这是为了说明这个想法，并不非常实用：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice we return a function in `useEffect` to clean up the effect. In the `inc`
    function, we invoke all `setState` functions in the `setStateFunctions` set.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在 `useEffect` 中返回一个函数来清理效果。在 `inc` 函数中，我们调用 `setStateFunctions` 集合中的所有 `setState`
    函数。
- en: 'Now, `Component2` will also be modified like `Component1`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Component2` 也会像 `Component1` 一样被修改：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As noted, this is not a very practical solution. We have some repetitive code
    in `Component1` and `Component2`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所提到的，这不是一个非常实用的解决方案。我们在 `Component1` 和 `Component2` 中有一些重复的代码。
- en: In the next section, we will introduce a Subscription mechanism and reduce the
    repetitive code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一个订阅机制并减少重复的代码。
- en: Adding a basic Subscription
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加基本订阅
- en: Here, we'll learn about the Subscription mechanism and how to connect a module
    state to the React state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将了解订阅机制以及如何将模块状态连接到 React 状态。
- en: 'Subscription is a way to get notified of things such as updates. A typical
    use of a Subscription would look like the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅是一种获取通知的方式，例如更新。一个典型的订阅使用情况如下：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we assume a `store` variable to have a `subscribe` method that takes a
    `callback` function and returns an `unsubscribe` function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设一个`store`变量有一个`subscribe`方法，它接受一个`callback`函数并返回一个`unsubscribe`函数。
- en: In this case, the expected behavior is that whenever `store` is updated, the
    callback function is invoked and it shows the console log.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，预期的行为是每当`store`更新时，回调函数就会被调用，并显示控制台日志。
- en: 'Now, let''s implement a module state with a Subscription. We''ll call it `store`,
    which holds the `state` value and the `subscribe` method, in addition to the `getState`
    and `setState` methods that we described in the *Exploring the module state* section.
    A `createStore` is a function to create `store` with an initial state value:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个带有订阅的模块状态。我们将它称为`store`，它除了包含`state`值和`subscribe`方法外，还包括我们在*探索模块状态*部分中描述的`getState`和`setState`方法。`createStore`是一个函数，用于使用初始状态值创建`store`：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compared with the `createContainer` function that we implemented in the *Exploring
    the module state* section, `createStore` has the `subscribe` method and the `setState`
    method, which invokes callbacks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在*探索模块状态*部分中实现的`createContainer`函数相比，`createStore`有`subscribe`方法和`setState`方法，它调用回调。
- en: 'We use `createStore` as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下使用`createStore`：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `store` variable holds `state` in it, and the entire `store` variable can
    be seen as a module state.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`store`变量在其内部持有`state`，整个`store`变量可以看作是一个模块状态。'
- en: Next up is the use of the `store` variable in React.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`store`变量在React中的使用。
- en: 'We define a new hook, `useStore`, which will return a tuple of the `store`
    state value and its update function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个新的钩子`useStore`，它将返回一个包含`store`状态值及其更新函数的元组：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You may notice `setState()` function once in `useEffect`. This is due to the
    fact that `useEffect` is delayed and there's a chance that `store` already has
    a new state.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在`useEffect`中看到一次`setState()`函数。这是因为`useEffect`是延迟的，并且有可能`store`已经有了新的状态。
- en: 'The following is a component with `useStore`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的是一个带有`useStore`的组件：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It''s important to update a module state immutably, the same as the React state,
    because a module state is eventually set in the React state:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要不可变地更新模块状态，就像React状态一样，因为模块状态最终会设置在React状态中：
- en: 'Like `Component1`, we define another one, `Component2`, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Component1`类似，我们定义另一个，`Component2`，如下所示：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Both buttons in the two components will update the module state in `store` and
    the states in both components are shared.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 两个组件中的两个按钮都会更新`store`中的模块状态和两个组件中的状态是共享的。
- en: 'Finally, we define the `App` component:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义`App`组件：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you run this app, you will see something like *Figure 4.1*. If you click
    either the **+1** or **+2** buttons, you will see that both counts (shown as **3**)
    are updated together:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个应用程序时，你会看到类似*图4.1*的内容。如果你点击**+1**或**+2**按钮，你会看到两个计数（显示为**3**）一起更新：
- en: '![Figure 4.1 – Screenshot of the running app ](img/Figure_4.1_B17780.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 运行中的应用程序截图](img/Figure_4.1_B17780.jpg)'
- en: Figure 4.1 – Screenshot of the running app
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 运行中的应用程序截图
- en: In this section, we used a Subscription to connect the module state to a React
    component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用订阅将模块状态连接到React组件。
- en: In the next section, we will use a selector function to use only part of the
    state, as well as learn how to use `useSubscription`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用选择器函数仅使用状态的一部分，以及学习如何使用`useSubscription`。
- en: Working with a selector and useSubscription
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用选择器和useSubscription一起工作
- en: The `useStore` hook we created in the previous section returns a whole state
    object. This means that any small part of the state object change will notify
    all `useStore` hooks and it can cause extra re-renders.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中创建的`useStore`钩子返回一个整个状态对象。这意味着状态对象的任何小部分变化都会通知所有`useStore`钩子，这可能导致额外的重新渲染。
- en: To avoid extra re-renders, we can introduce a selector to return the only part
    of the state that a component is interested in.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免额外的重新渲染，我们可以引入一个选择器来返回组件感兴趣的状态的一部分。
- en: Let's first develop `useStoreSelector`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先开发`useStoreSelector`。
- en: 'We use the same `createStore` function defined in the previous section and
    create a `store` variable as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与上一节中定义的相同的`createStore`函数，并创建一个`store`变量，如下所示：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The state in `store` has two counts – `count1` and `count2`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`store`中的状态有两个计数器 – `count1`和`count2`。'
- en: 'The `useStoreSelector` hook is similar to `useStore`, but it receives an additional
    selector function. It uses the selector function to scope the state:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`useStoreSelector` 钩子类似于 `useStore`，但它接收一个额外的选择器函数。它使用选择器函数来限定状态：'
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compared to `useStore`, the `useState` hook in `useStoreSelector` holds the
    return value of `selector` instead of the entire state.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `useStore` 相比，`useStoreSelector` 中的 `useState` 钩子持有 `selector` 的返回值而不是整个状态。
- en: 'Now we define a component to use `useStoreSelector`. The return value of `useStoreSelector`
    is a count number. To update the state, we invoke `store.setState()` directly
    in this case. `Component1` is a component for displaying `count1` in the state:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义一个组件来使用 `useStoreSelector`。`useStoreSelector` 的返回值是一个计数器。为了更新状态，在这种情况下我们直接调用
    `store.setState()`。`Component1` 是一个用于在状态中显示 `count1` 的组件：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice we need to use `useCallback` to get a stable selector function. Otherwise,
    as the selector is specified in the second argument of `useEffect`, `Component1`
    will subscribe to the `store` variable every time `Component1` renders.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们需要使用 `useCallback` 来获取一个稳定的选择器函数。否则，由于选择器指定在 `useEffect` 的第二个参数中，每次 `Component1`
    渲染时，`Component1` 将会订阅 `store` 变量。
- en: 'We define `Component2`, which is to display `count2` instead of `count1`. We
    define a selector function outside the component to avoid `useCallback` this time:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义 `Component2`，用于显示 `count2` 而不是 `count1`。我们定义一个选择器函数在组件外部以避免这次使用 `useCallback`：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, the `App` component renders two components for each `Component1` component
    and `Component2` component for demonstration:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`App` 组件为每个 `Component1` 组件和 `Component2` 组件渲染两个组件以进行演示：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Figure 4.2* is a screenshot of the running app:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.2* 是运行中的应用程序截图：'
- en: '![Figure 4.2 – Screenshot of the running app ](img/Figure_4.2_B17780.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 运行中的应用程序截图](img/Figure_4.2_B17780.jpg)'
- en: Figure 4.2 – Screenshot of the running app
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 运行中的应用程序截图
- en: The first two lines in the preceding figure are rendered by `Component1`. If
    you click either of the first two `count1`, which will trigger `Component1` to
    re-render. However, `Component2` (the last two lines in *Figure 4.2*) won't re-render
    because `count2` isn't changed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前图中的前两行是由 `Component1` 渲染的。如果你点击前两个 `count1` 中的任何一个，这将触发 `Component1` 重新渲染。然而，`Component2`（图
    4.2 中的最后两行）不会重新渲染，因为 `count2` 没有改变。
- en: While the `useStoreSelector` hook works well and is usable in production, there's
    a caveat when `store` or `selector` is changed. Because `useEffect` fires a little
    later, it will return a stale state value until re-subscribing is done. We could
    fix it by ourselves, but it's a little technical.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `useStoreSelector` 钩子工作良好且在生产环境中可用，但当 `store` 或 `selector` 发生变化时，有一个需要注意的问题。因为
    `useEffect` 会在稍后触发，它将返回一个过时的状态值，直到重新订阅完成。我们可以自己修复它，但这需要一点技术知识。
- en: Fortunately, the React team provides an official hook for this use case. It's
    called `use-subscription` ([https://www.npmjs.com/package/use-subscription](https://www.npmjs.com/package/use-subscription)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，React 团队为这种情况提供了一个官方的钩子。它被称为 `use-subscription` ([https://www.npmjs.com/package/use-subscription](https://www.npmjs.com/package/use-subscription)
    )。
- en: 'Let''s re-define `useStoreSelector` using `useSubscription`. The code is as
    simple as the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `useSubscription` 重新定义 `useStoreSelector`。代码如下简单：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The app still works with this change.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序仍然可以使用这个更改运行。
- en: 'We could avoid using the `useStoreSelector` hook and use `useSubscription`
    directly in `Component1`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以避免在 `Component1` 中使用 `useStoreSelector` 钩子，并直接使用 `useSubscription`：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, as `useMemo` is already used, `useCallback` is not necessary.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，因为已经使用了 `useMemo`，所以不需要 `useCallback`。
- en: useSubscription and useSyncExternalStore
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: useSubscription 和 useSyncExternalStore
- en: In future versions of React, a hook called `useSyncExternalStore` will be included.
    This is a successor of `useSubscription`. Hence, using the module state will become
    more accessible ([https://github.com/reactwg/react-18/discussions/86](https://github.com/reactwg/react-18/discussions/86
    ) ).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 的未来版本中，将包含一个名为 `useSyncExternalStore` 的钩子。这是 `useSubscription` 的继任者。因此，使用模块状态将变得更加容易访问
    ([https://github.com/reactwg/react-18/discussions/86](https://github.com/reactwg/react-18/discussions/86)
    )。
- en: In this section, we learned about using selectors to scope state and also the
    official `useSubscription` hook to have a more concrete solution.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用选择器来限定状态，以及官方的 `useSubscription` 钩子以获得更具体的解决方案。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create a module state and integrate it in
    React. Using what we learned, you can use the module state as a global state in
    React. Subscription plays an important role in integration because it allows the
    re-rendering of components to be triggered when the module state is changed. In
    addition to the basic Subscription implementation to use the module state in React,
    there is an official package. Both the basic Subscription and the official package
    work for the production use case.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建模块状态并将其集成到React中。利用我们所学的内容，你可以将模块状态用作React中的全局状态。订阅在集成中扮演着重要的角色，因为它允许在模块状态改变时触发组件的重新渲染。除了在React中使用模块状态的基本订阅实现外，还有一个官方包。基本订阅和官方包都适用于生产环境的使用案例。
- en: In the next chapter, we will learn about the third pattern of implementing a
    global state, which is a combination of the first pattern and the second pattern.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习实现全局状态的第三种模式，它是由第一种模式和第二种模式相结合而成的。
