- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Multipage Apps with React Router
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Router 的多页应用程序
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下事情：
- en: Build multipage single-page applications (and understand why this is not an
    oxymoron)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建多页单页应用程序（以及理解这并不是一个矛盾的说法）
- en: Use the React Router package to load different React components for different
    URL paths
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Router 包为不同的 URL 路径加载不同的 React 组件
- en: Create static and dynamic routes (and understand what routes are in the first
    place)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建静态和动态路由（以及首先了解什么是路由）
- en: Navigate the website via both links and programmatic commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过链接和程序性命令导航网站
- en: Build nested page layouts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建嵌套页面布局
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Having worked through the first twelve chapters of this book, you should now
    know how to build React components and web apps, as well as how to manage components
    and app-wide state, and how to share data between components (via props or context).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本书的前十二章后，你现在应该知道如何构建 React 组件和 Web 应用程序，以及如何管理组件和全局状态，以及如何在组件之间共享数据（通过 props
    或 context）。
- en: But even though you know how to compose a React website from multiple components,
    all these components are on the same single website page. Sure, you can display
    components and content conditionally, but users will never switch to a different
    page. This means that the URL path will never change; users will always stay on
    `your-domain.com` . Also, at this point in time, your React apps don’t support
    any paths such as `your-domain.com/products` or `your-domain.com/blog/latest`
    .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你知道如何从多个组件中组合 React 网站，但所有这些组件都在同一个单页网站上。当然，你可以有条件地显示组件和内容，但用户永远不会切换到不同的页面。这意味着
    URL 路径永远不会改变；用户将始终停留在 `your-domain.com`。此外，到目前为止，你的 React 应用程序不支持任何路径，如 `your-domain.com/products`
    或 `your-domain.com/blog/latest`。
- en: '**Note**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**Uniform Resource Locators** ( **URLs** ) are references to web resources.
    For example, [https://academind.com/courses](https://academind.com/courses) is
    a URL that points to a specific page of the author’s website. In this example,
    `academind.com` is the **domain name** of the website and `/courses` is the **path**
    to a specific website page.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一资源定位符**（ **URLs**）是网络资源的引用。例如，[https://academind.com/courses](https://academind.com/courses)
    是一个指向作者网站特定页面的 URL。在这个例子中，`academind.com` 是网站的 **域名**，`/courses` 是指向特定网站页面的 **路径**。'
- en: For React apps, it might make sense that the path of the loaded website never
    changes. After all, in *Chapter 1* , *React – What and Why* , you learned that
    you build **single-page applications** ( **SPAs** ) with React.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 React 应用程序来说，加载的网站路径从不改变可能是有意义的。毕竟，在 *第一章* 中，*React – 什么是以及为什么*，你学习了使用 React
    构建 **单页应用程序**（ **SPAs**）。
- en: But even though it might make sense, it’s also quite a serious limitation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但尽管这可能是有意义的，但它也是一个相当严重的限制。
- en: One Page Is Not Enough
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一页不够
- en: Having just a single page means that complex websites that would typically consist
    of multiple pages (e.g., an online shop with pages for products, orders, and more)
    become quite difficult to build with React. Without multiple pages, you have to
    fall back to state and conditional values to display different content on the
    screen.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个页面意味着那些通常由多个页面组成（例如，包含产品、订单等页面的在线商店）的复杂网站很难用 React 构建。没有多个页面，你不得不退而求其次，使用状态和条件值在屏幕上显示不同的内容。
- en: But without changing URL paths, your website visitors can’t share links to anything
    but the starting page of your website. Also, any conditionally loaded content
    will be lost when a new visitor visits that starting page. That will also be the
    case if users simply reload the page they’re currently on. A reload fetches a
    new version of the page, and so any state (and therefore user interface) changes
    are lost.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果没有改变 URL 路径，你的网站访客只能分享指向网站起始页的链接。此外，当新访客访问该起始页时，任何有条件加载的内容都会丢失。如果用户简单地重新加载他们当前所在的页面，情况也是如此。重新加载会获取页面的新版本，因此任何状态（以及因此用户界面）的变化都会丢失。
- en: For these reasons, you absolutely need a way of including multiple pages (with
    different URL paths) in a single React app for most React websites. Thanks to
    modern browser features and a highly popular third-party package, that is indeed
    possible (and the default for most React apps).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，对于大多数 React 网站，你绝对需要在单个 React 应用程序中包含多个页面（具有不同的 URL 路径）。多亏了现代浏览器功能和高度流行的第三方包，这确实可能实现（并且对于大多数
    React 应用程序来说是默认的）。
- en: 'Via the **React Router** package, your React app can listen to URL path changes
    and display different components for different paths. For example, you could define
    the following path-component mappings:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 **React Router** 包，你的 React 应用可以监听 URL 路径的变化，并为不同的路径显示不同的组件。例如，你可以定义以下路径-组件映射：
- en: '`<domain>/` => `<Home />` component is loaded.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<domain>/` => 加载 `<Home />` 组件。'
- en: '`<domain>/products` => `<ProductList />` component is loaded.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<domain>/products` => 加载 `<ProductList />` 组件。'
- en: '`<domain>/products/p1` => `<ProductDetail />` component is loaded.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<domain>/products/p1` => 加载 `<ProductDetail />` 组件。'
- en: '`<domain>/about` => `<AboutUs />` component is loaded.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<domain>/about` => 加载 `<AboutUs />` 组件。'
- en: Technically, it will still be a SPA because there’s still only one HTML page
    being sent to website users. But in that single-page React app, different components
    are rendered conditionally by the React Router package based on the specific URL
    paths that are being visited. As the developer of the app, you don’t have to manually
    manage this kind of state or render content conditionally—React Router will do
    it for you. In addition, your website is able to handle different URL paths, and
    therefore, individual pages can be shared or reloaded.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，它仍然是一个单页应用（SPA），因为仍然只向网站用户发送了一个 HTML 页面。但在那个单页 React 应用中，不同的组件是由 React
    Router 包根据访问的具体 URL 路径条件性地渲染的。作为应用的开发者，你不需要手动管理这种状态或条件性地渲染内容——React Router 会为你处理。此外，你的网站能够处理不同的
    URL 路径，因此，单个页面可以被共享或重新加载。
- en: Getting Started with React Router and Defining Routes
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Router 入门与定义路由
- en: React Router is a third-party React library that can be installed in any React
    project. Once installed, you can use various components in your code to enable
    the aforementioned features.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 是一个可以在任何 React 项目中安装的第三方 React 库。一旦安装，你就可以在你的代码中使用各种组件来启用上述功能。
- en: 'Inside your React project, the package is installed via this command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 React 项目内部，通过以下命令安装该包：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once installed, you can import and use various components (and Hooks) from that
    library.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以导入并使用该库中的各种组件（和 Hooks）。
- en: 'To start supporting multiple pages in your React app, you need to set up **routing**
    by going through the following steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在你的 React 应用中支持多页，你需要通过以下步骤设置 **路由**：
- en: Create different components for your different pages (e.g., `Dashboard` and
    `Orders` components).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的不同页面创建不同的组件（例如，`Dashboard` 和 `Orders` 组件）。
- en: Use the `createBrowserRouter()` function and the `RouterProvider` component
    from the React Router library to enable routing and define the **routes** that
    should be supported by the React app.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 React Router 库中的 `createBrowserRouter()` 函数和 `RouterProvider` 组件来启用路由并定义
    React 应用应支持的 **路由**。
- en: In this context, the term **routing** refers to the React app being able to
    load different components for different URL paths (e.g., different components
    for the `/` and `/orders` paths). A route is a definition that’s added to the
    React app that defines the URL path for which a predefined JSX snippet should
    be rendered (e.g., the `Orders` component should be loaded for the `/orders` path).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，术语 **路由** 指的是 React 应用能够为不同的 URL 路径加载不同的组件（例如，为 `/` 和 `/orders` 路径加载不同的组件）。路由是一个添加到
    React 应用的定义，它定义了应该渲染预定义 JSX 片段的 URL 路径（例如，对于 `/orders` 路径，应该加载 `Orders` 组件）。
- en: 'In an example React app that contains `Dashboard` and `Orders` components,
    and wherein the React Router library was installed via `npm install` , you can
    enable routing and navigation between these two components by editing the root
    component (in `src/App.jsx` ) like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个包含 `Dashboard` 和 `Orders` 组件的示例 React 应用中，并且通过 `npm install` 安装了 React Router
    库，你可以通过编辑根组件（在 `src/App.jsx` 中）来启用这两个组件之间的路由和导航，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Note**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the complete example code on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/01-getting-started-with-routing](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/01-getting-started-with-routing)
    .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到完整的示例代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/01-getting-started-with-routing](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/01-getting-started-with-routing)。
- en: In the preceding code snippet, React Router’s `createBrowserRouter()` function
    is called to create a `router` object that contains the application’s route configuration
    (a list of available routes). The array passed to `createBrowserRouter()` contains
    route definition objects, where every object defines a `path` for which the route
    should be matched and an `element` that should be rendered.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，React Router 的 `createBrowserRouter()` 函数被调用以创建一个包含应用程序的路由配置（可用路由列表）的
    `router` 对象。传递给 `createBrowserRouter()` 的数组包含路由定义对象，其中每个对象定义了一个应匹配的 `path` 以及应渲染的
    `element`。
- en: React Router’s `RouterProvider` component is then used to set the `router` configuration
    and define a place for the active route elements to be rendered.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 React Router 的 `RouterProvider` 组件来设置 `router` 配置并定义一个用于渲染活动路由元素的位置。
- en: You can think of the `<RouterProvider />` element being replaced with the content
    defined via the `element` property once a route becomes active. Therefore, the
    positioning of the `RouterProvider` component matters. In this case (and probably
    in most React apps), it’s the root application component—i.e., React Router, that
    should control the entire application component tree.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 `<RouterProvider />` 元素视为一旦路由变为活动状态，就被通过 `element` 属性定义的内容所替换。因此，`RouterProvider`
    组件的位置很重要。在这种情况下（以及可能的大多数 React 应用程序），它应该是根应用程序组件——即 React Router，它应该控制整个应用程序组件树。
- en: 'If you run the provided example React app (via `npm run dev` ), you’ll see
    the following output on the screen:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行提供的示例 React 应用程序（通过 `npm run dev`），您将在屏幕上看到以下输出：
- en: '![img](img/B31339_13_01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_13_01.png)'
- en: 'Figure 13.1: The Dashboard component content is loaded'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：仪表板组件内容已加载
- en: 'The content of the `Dashboard` component is displayed on the screen if you
    visit `localhost:5173` . Please note that the visible page content is not defined
    in the `App` component (in the code snippet shared previously). Instead, only
    two route definitions were added: one for the `/` path (i.e., for `localhost:5173/`
    or just `localhost:5173` , without the trailing forward slash—it’s handled in
    the same way) and one for the `/orders` path ( `localhost:5173/orders` ).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问 `localhost:5173`，屏幕上会显示 `Dashboard` 组件的内容。请注意，可见的页面内容并未在 `App` 组件（在之前共享的代码片段中）中定义。相反，只添加了两个路由定义：一个用于
    `/` 路径（即 `localhost:5173/` 或仅 `localhost:5173`，不带尾随正斜杠——它以相同的方式处理）和一个用于 `/orders`
    路径（`localhost:5173/orders`）。
- en: '**Note**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '`localhost` is a local address that’s typically used for development. When
    you deploy your React app (i.e., you upload it to a web server), you will receive
    a different domain—or assign a custom domain. Either way, it will not be `localhost`
    after deployment.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`localhost` 是一个通常用于开发的本地地址。当您部署您的 React 应用程序（即，您将其上传到 Web 服务器）时，您将收到不同的域名——或者分配一个自定义域名。无论如何，部署后它将不再是
    `localhost`。'
- en: The part after `localhost` ( `:5173` ) defines the network port to which the
    request will be sent. Without the additional port information, ports `80` or `443`
    (as the default HTTP(S) ports) are used automatically. During development, however,
    these are not the ports you want. Instead, you would typically use ports such
    as `5173` , `8000` , or `8080` as these are normally unoccupied by any other system
    processes and hence can be used safely. Projects created via Vite typically use
    port `5173` .
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`localhost` 之后的部分（`:5173`）定义了请求将被发送到的网络端口。如果没有额外的端口信息，将自动使用端口 `80` 或 `443`（作为默认的
    HTTP(S) 端口）。然而，在开发期间，这些并不是您想要的端口。相反，您通常会使用 `5173`、`8000` 或 `8080` 这样的端口，因为这些端口通常不会被任何其他系统进程占用，因此可以安全使用。通过
    Vite 创建的项目通常使用端口 `5173`。'
- en: 'Since `localhost:5173` is loaded by default (when running `npm run dev` ),
    the first route definition ( `{ path: ''/'', element: <Dashboard /> }` ) becomes
    active. This route is active because its path ( `''/''` ) matches the path of
    `localhost:5173` (since this is the same as `localhost:5173/` ).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '由于 `localhost:5173` 默认加载（当运行 `npm run dev` 时），第一个路由定义（`{ path: ''/'', element:
    <Dashboard /> }`）变为活动状态。此路由处于活动状态是因为其路径（`''/''`）与 `localhost:5173` 的路径匹配（因为这与
    `localhost:5173/` 相同）。'
- en: As a result, the JSX code defined via `element` is rendered in place of the
    `<RouterProvider>` component by React Router. In this case, this means that the
    content of the `Dashboard` component is displayed because the `element` property
    value of this route definition is `<Dashboard />` . It is quite common to use
    single components (such as `<Dashboard />` , in this example), but you could set
    any JSX content as a value for the `element` property.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过 `element` 定义的 JSX 代码替换了 `<RouterProvider>` 组件。在这种情况下，这意味着 `Dashboard`
    组件的内容被显示，因为此路由定义的 `element` 属性值是 `<Dashboard />`。在示例中，使用单个组件（如 `<Dashboard />`）是很常见的，但你也可以将任何
    JSX 内容设置为 `element` 属性的值。
- en: In the preceding example, no complex page is displayed. Instead, only some text
    shows up on the screen. This will change later in this chapter, though.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，没有显示复杂的页面。相反，屏幕上只显示了一些文本。不过，在本章的后面部分，这将会改变。
- en: 'But it gets interesting if you manually change the URL from just `localhost:5173`
    to `localhost:5173/orders` in the browser address bar. In any of the previous
    chapters, this would not have changed the page content. But now, with routing
    enabled and the appropriate routes being defined, the page content does change,
    as shown:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你在浏览器地址栏中将URL从 `localhost:5173` 手动更改为 `localhost:5173/orders`，这会变得有趣。在任何前面的章节中，这都不会改变页面内容。但现在，由于启用了路由并且定义了适当的路由，页面内容确实发生了变化，如下所示：
- en: '![img](img/B31339_13_02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_13_02.png)'
- en: 'Figure 13.2: For /orders, the content of the Orders component is displayed'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：对于 /orders，显示 Orders 组件的内容
- en: Once the URL changes, the content of the `Orders` component is displayed on
    the screen. It’s again just some basic text in this first example, but it shows
    that different code is rendered for different URL paths.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦URL发生变化，`Orders` 组件的内容就会显示在屏幕上。在这个第一个例子中，它仍然是基本的文本，但它表明对于不同的URL路径，会渲染不同的代码。
- en: However, this basic example has a major flaw (besides the quite boring page
    content). Right now, users must enter URLs manually. But, of course, that’s not
    how you typically use websites.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个基本例子有一个主要的缺陷（除了相当无聊的页面内容）。目前，用户必须手动输入URL。但当然，这不是通常使用网站的方式。
- en: Adding Page Navigation
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加页面导航
- en: 'To allow users to switch between different website pages without editing the
    browser address bar manually, websites normally contain links, typically added
    via the `<a>` HTML element (the anchor element), like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户在不手动编辑浏览器地址栏的情况下在网站的不同页面之间切换，网站通常包含链接，通常通过 `<a>` HTML 元素（锚元素）添加，如下所示：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For this example, on-page navigation could therefore be added by modifying
    the `Dashboard` component code like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，可以通过修改 `Dashboard` 组件代码来添加页面导航，如下所示：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this code snippet, a link to the `/orders` route has been added. Website
    visitors therefore see this page now:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，已添加了对 `/orders` 路由的链接。因此，网站访客现在看到的是这个页面：
- en: '![img](img/B31339_13_03.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_13_03.png)'
- en: 'Figure 13.3: A navigation link was added'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：添加了导航链接
- en: When website users click this link, they are therefore taken to the `/orders`
    route and the content of the `Orders` component is displayed on the screen.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当网站用户点击这个链接时，他们会进入 `/orders` 路由，并且 `Orders` 组件的内容会显示在屏幕上。
- en: 'This approach works but has a major flaw: the website is reloaded every time
    a user clicks the link. You can tell that it’s reloaded because the browser’s
    refresh icon changes to a cross (briefly) whenever you click a link.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可行，但有一个主要的缺陷：每次用户点击链接时，网站都会重新加载。你可以通过点击链接时浏览器刷新图标变为一个叉号（短暂地）来判断页面正在重新加载。
- en: This happens because the browser sends a new HTTP request to the server whenever
    a link is clicked. Even though the server always returns the same single HTML
    page, the page is reloaded during that process (because of the new HTTP request
    that was sent).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为每当点击链接时，浏览器都会向服务器发送一个新的HTTP请求。尽管服务器总是返回相同的单个HTML页面，但在那个过程中页面会重新加载（因为发送了新的HTTP请求）。
- en: While that’s not a problem on this simple demo page, it would be an issue if
    you had some shared state (e.g., app-wide state managed via context) that should
    not be reset during a page change. In addition, every new request takes time and
    forces the browser to download all website assets (e.g., script files) again.
    Even though those files might be cached, this is an unnecessary step that may
    impact website performance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个简单的演示页面上这并不是问题，但如果你有某些共享状态（例如，通过上下文管理的全局状态）不应该在页面更改时重置，那么这就会成为一个问题。此外，每次新的请求都会花费时间，并迫使浏览器重新下载所有网站资源（例如，脚本文件）。即使这些文件可能被缓存，这也是一个不必要的步骤，可能会影响网站性能。
- en: 'The following, slightly adjusted, example `App` component illustrates the state-resetting
    problem:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的略微调整后的 `App` 组件示例说明了状态重置问题：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Note**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The code for this example can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/03-naive-navigation-problem](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/03-naive-navigation-problem)
    .
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的代码可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/03-naive-navigation-problem](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/03-naive-navigation-problem)
    找到。
- en: In this example, a simple counter was added to the `App` component. Since `<RouterProvider>`
    is rendered in that same component, below the counter, the `App` component should
    not be replaced when a user visits a different page (instead, it’s `<RouterProvider>`
    that should be replaced—not the entire `App` component JSX code).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，一个简单的计数器被添加到了 `App` 组件中。由于 `<RouterProvider>` 在同一个组件中被渲染，在计数器下方，当用户访问不同的页面时，不应替换
    `App` 组件（相反，应该替换 `<RouterProvider>` 而不是整个 `App` 组件的 JSX 代码）。
- en: 'At least, that’s the theory. But, as you can see in the following screenshot,
    the `counter` state is lost whenever any link is clicked:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，这是理论上的情况。但是，正如你在下面的屏幕截图中所看到的，每次点击任何链接时，`counter` 状态都会丢失：
- en: '![img](img/B31339_13_04.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_13_04.png)'
- en: 'Figure 13.4: The counter state is reset when switching the page'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：切换页面时计数器状态被重置
- en: In the screenshot, you can see that the counter is initially set to `3` (because
    the button was clicked thrice). After navigating from `Dashboard` to the `Orders`
    page (via clicking the `Orders page` link), the counter changes to `0` .
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕截图中，你可以看到计数器最初被设置为 `3`（因为按钮被点击了三次）。在从 `Dashboard` 页面导航到 `Orders` 页面（通过点击
    `Orders page` 链接）后，计数器变为 `0`。
- en: That happens because the page is reloaded due to the HTTP request that’s sent
    by the browser.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为页面因浏览器发送的 HTTP 请求而重新加载。
- en: To work around this issue and avoid this unintended page reload, you must prevent
    the browser’s default behavior. Instead of sending a new HTTP request, the browser
    URL address should just be updated (from `localhost:5173` to `localhost:5173/orders`
    ) and the target component ( `Orders` ) should be loaded. Therefore, to the website
    user, it would seem as if a different page was loaded. But behind the scenes,
    it’s just the page document (the DOM) that was updated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题并避免这种意外的页面重新加载，你必须阻止浏览器默认行为。而不是发送新的 HTTP 请求，浏览器 URL 地址应该只更新（从 `localhost:5173`
    更新到 `localhost:5173/orders`），并且应该加载目标组件（`Orders`）。因此，对于网站用户来说，这看起来就像加载了不同的页面。但在幕后，只是页面文档（DOM）被更新了。
- en: Thankfully, you don’t have to implement the logic for this on your own. Instead,
    the React Router library exposes a special `Link` component that should be used
    instead of the anchor `<a>` element.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不必自己实现这个逻辑。相反，React Router 库公开了一个特殊的 `Link` 组件，应该用它来代替锚 `<a>` 元素。
- en: 'To use this new component, the code in `src/routes/Dashboard.jsx` must be adjusted
    like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个新组件，`src/routes/Dashboard.jsx` 中的代码必须进行调整如下：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Note**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The code for this example can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/04-react-router-navigation](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/04-react-router-navigation)
    .
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的代码可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/04-react-router-navigation](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/04-react-router-navigation)
    找到。
- en: Inside this updated example, the new `Link` component is used. That component
    requires a `to` prop, which is used to define the URL path that should be loaded.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新后的示例中，使用了新的 `Link` 组件。该组件需要一个 `to` 属性，用于定义应该加载的 URL 路径。
- en: By using this component in place of the `<a>` anchor element, the counter state
    is no longer reset. This is because React Router now prevents the browser’s default
    behavior (i.e., the unintended page reload described above) and displays the correct
    page content.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用此组件代替 `<a>` 锚点元素，计数器状态不再重置。这是因为 React Router 现在阻止了浏览器的默认行为（即上述描述的不希望的页面重新加载）并显示了正确的页面内容。
- en: Under the hood, the `Link` component still renders the built-in `<a>` element.
    But React Router controls it and implements the behavior described above.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`Link` 组件仍然渲染内置的 `<a>` 元素。但 React Router 控制它并实现了上述描述的行为。
- en: The `Link` component is therefore the default component that should be used
    for internal links. For external links, the standard `<a>` element should be used
    instead since the link leads away from the website, hence there is no state to
    preserve or page reload to prevent.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Link` 组件是用于内部链接的默认组件。对于外部链接，应使用标准的 `<a>` 元素，因为链接会离开网站，因此没有需要保留的状态或页面重新加载来防止。
- en: Working with Layouts & Nested Routes
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用布局和嵌套路由
- en: Most websites require some form of page-wide navigation (and hence navigation
    links) or other page sections that should be shared across some or all routes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网站都需要某种形式的页面宽范围导航（以及相应的导航链接）或其他应在某些或所有路由之间共享的页面部分。
- en: Consider the previous example website with the routes `/` and `/orders` . The
    example website would also benefit from having a top navigation bar that allows
    users to switch between the starting page (i.e., the `Dashboard` route) and the
    `Orders` page.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到之前的示例网站，它有 `/` 和 `/orders` 路由。该示例网站也将从有一个允许用户在起始页面（即 `Dashboard` 路由）和 `Orders`
    页面之间切换的顶部导航栏中受益。
- en: 'Therefore, `App.jsx` could be adjusted to have a top navigation bar inside
    a `<header>` above `<RouterProvider>` :'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以将 `App.jsx` 调整为在 `<RouterProvider>` 上方的 `<header>` 中包含一个顶部导航栏：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But if you try to run this application, you’ll see a blank page and encounter
    an error message in the JavaScript console in the browser developer tools.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你尝试运行此应用程序，你将看到一个空白页面，并在浏览器开发者工具的 JavaScript 控制台中遇到错误信息。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_13_05.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_13_05.png)'
- en: 'Figure 13.5: React Router seems to complain about something'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：React Router 好像在抱怨某些事情
- en: The error message is a bit cryptic, but the problem is that the above code tries
    to use `<Link>` outside of a component controlled by React Router.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息有点晦涩难懂，但问题在于上述代码试图在由 React Router 控制的组件之外使用 `<Link>`。
- en: Only components loaded via `<RouterProvider>` are controlled by React Router,
    hence React Router features like its `Link` component can only be used in route
    components (or their descendent components).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 只有通过 `<RouterProvider>` 加载的组件才受 React Router 控制，因此 React Router 的功能，如其 `Link`
    组件，只能在路由组件（或其子组件）中使用。
- en: Therefore, setting up the main navigation inside of the `App` component (which
    is **not** loaded by React Router) does not work.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `App` 组件（**不是**由 React Router 加载）内部设置主要导航不起作用。
- en: To wrap or enhance multiple route components with some shared component and
    JSX markup, you must define a new route that wraps the existing routes. Such a
    route is also sometimes called a **layout route** since it can be used to provide
    some shared layout. The routes wrapped by this route would be called **nested
    routes** .
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用某个共享组件和 JSX 标记来包装或增强多个路由组件，必须定义一个新的路由来包装现有路由。这样的路由有时也被称为 **布局路由**，因为它可以用来提供一些共享布局。被此路由包装的路由将被称为
    **嵌套路由**。
- en: A layout route is defined like any other route inside the route definitions
    array. It then becomes a layout route by wrapping other routes via a special `children`
    property that’s accepted by React Router. That `children` property receives an
    array of nested routes—child routes to the wrapping parent route.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 布局路由的定义方式与路由定义数组内的任何其他路由相同。然后，通过使用 React Router 接受的特殊 `children` 属性来包装其他路由，它就变成了一个布局路由。这个
    `children` 属性接收一个嵌套路由的数组——包装父路由的子路由。
- en: 'Here’s the adjusted route definition code for this example app:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此示例应用程序调整后的路由定义代码：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this updated code snippet, a new root layout route is defined—a route that
    registers the existing routes (the `Dashboard` and `Orders` components) as child
    routes. This setup therefore allows the `Root` component to be active simultaneously
    to the `Dashboard` or `Orders` route component.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新的代码片段中，定义了一个新的根布局路由——一个注册现有路由（`Dashboard`和`Orders`组件）为子路由的路由。因此，这种设置允许`Root`组件与`Dashboard`或`Orders`路由组件同时激活。
- en: You might also note that the `Dashboard` route no longer has a `path` . Instead,
    it now has an `index` property, which is set to `true` . That `index` property
    is a property that can be used when working with nested routes. It tells React
    Router which nested route to activate (and therefore which component to load)
    if the parent route path is matched exactly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到，`Dashboard`路由不再有`path`。相反，它现在有一个`index`属性，设置为`true`。这个`index`属性是在处理嵌套路由时可以使用的属性。它告诉React
    Router在父路由路径完全匹配时激活哪个嵌套路由（因此加载哪个组件）。
- en: In this example, when the `/` path is active (i.e., if a user visits `<domain>/`
    ), the `Root` and `Dashboard` components will be rendered. For `<domain>/orders`
    , `Root` and `Orders` would become visible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当`/`路径处于活动状态（即，如果用户访问`<domain>/`），`Root`和`Dashboard`组件将被渲染。对于`<domain>/orders`，`Root`和`Orders`将变得可见。
- en: 'The `Root` component is a newly added component in this example. It’s a standard
    component (like `Dashboard` or `Orders` ) with one special feature: it defines
    the place where the child route components should be inserted via a special `Outlet`
    component that’s provided by React Router:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Root`组件是这个例子中新增的组件。它是一个标准组件（如`Dashboard`或`Orders`），具有一个特殊功能：它通过React Router提供的特殊`Outlet`组件定义了子路由组件应该插入的位置：'
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `<Outlet />` placeholder is needed since React Router must know where to
    render the route components of the routes passed to the `children` property.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Outlet />`占位符是必需的，因为React Router必须知道在哪里渲染传递给`children`属性的路由组件的路由组件。'
- en: '**Note**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the complete example code on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/05-layouts-nested-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/05-layouts-nested-routes)
    .
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到完整的示例代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/05-layouts-nested-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/05-layouts-nested-routes)。
- en: Since the `Root` component itself is also rendered by React Router, it now is
    a component that has access to the `<Link>` tag. Therefore, this `Root` component
    can be used to share common markup (like the navigation `<header>` ) across all
    nested routes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Root`组件本身也是由React Router渲染的，它现在是一个可以访问`<Link>`标签的组件。因此，这个`Root`组件可以用来在所有嵌套路由之间共享通用标记（如导航`<header>`）。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_13_06.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图  自动生成的描述](img/B31339_13_06.png)'
- en: 'Figure 13.6: A shared navigation bar is displayed at the top (for all routes)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：顶部显示了一个共享的导航栏（适用于所有路由）
- en: Hence, nested routes and layout routes (or wrapper routes) are crucial features
    offered by React Router.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，嵌套路由和布局路由（或包装路由）是React Router提供的关键特性。
- en: It’s also worth noting that you can add as many levels of route nesting as needed
    by your application—you’re **not** restricted to having just one layout route
    that wraps child routes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，你可以根据应用程序的需要添加任意级别的路由嵌套——你**不**仅限于只有一个包裹子路由的布局路由。
- en: From Link to NavLink
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Link到NavLink
- en: In a shared navigation, as set up in the previous chapter, you often want to
    highlight the link that led to the currently active page. For example, if a user
    clicked the `Past Orders` link (and hence navigates to `/orders` ), that link
    should change its appearance (e.g., its color).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中设置的共享导航中，你通常希望突出显示导致当前活动页面的链接。例如，如果用户点击了`Past Orders`链接（因此导航到`/orders`），该链接应该改变其外观（例如，其颜色）。
- en: Consider the example from previously ( *Figure 13.6* )—there, in the top navigation
    bar, it’s not immediately obvious whether the user is on the `Dashboard` page
    or the `Orders` page. Of course, the URL address and the main page content do
    change, but the navigation items don’t adjust visually.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑之前的例子（*图13.6*）——在那里，在顶部导航栏中，用户是否在`Dashboard`页面或`Orders`页面并不立即明显。当然，URL地址和主页内容确实会改变，但导航项在视觉上并没有调整。
- en: 'To prove this point, compare the previous screenshot to the following one:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，比较之前的截图和下面的截图：
- en: '![img](img/B31339_13_07.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_13_07.png)'
- en: 'Figure 13.7: The highlighted “Past Orders” navigation link is underlined and
    changes its color'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7：高亮的“历史订单”导航链接被下划线并改变颜色
- en: In this version of the website, it’s immediately clear that the user is on the
    `"Orders"` page since the `Past Orders` navigation link is highlighted. It’s subtle
    things such as this that make websites more usable and can ultimately lead to
    higher user engagement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的网站上，用户立即就能清楚地看到他们位于“订单”页面，因为“历史订单”导航链接被突出显示。正是这样的细微之处使得网站更加易用，并最终可能导致更高的用户参与度。
- en: But how can this be achieved?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是如何实现的呢？
- en: 'To do this, you would not use the `Link` component, but instead, a special
    alternative component offered by `react-router-dom` : the `NavLink` component:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你不会使用 `Link` 组件，而是使用 `react-router-dom` 提供的特别替代组件：`NavLink` 组件：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `NavLink` component is used pretty much like the `Link` component. You wrap
    it around some text (the link’s caption), and you define the target path via the
    `to` prop. However, the `NavLink` component has some extra styling-related features
    the regular `Link` component does not have.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavLink` 组件的使用方式与 `Link` 组件非常相似。你将其包裹在一段文本（链接的标题）周围，并通过 `to` 属性定义目标路径。然而，`NavLink`
    组件有一些额外的与样式相关的功能，这是常规 `Link` 组件所不具备的。'
- en: To be precise, the `NavLink` component by default applies a CSS class called
    `active` to the rendered anchor element when the link is active.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，当链接处于活动状态时，`NavLink` 组件默认将一个名为 `active` 的 CSS 类应用到渲染的锚点元素上。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_13_08.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B31339_13_08.png)'
- en: 'Figure 13.8: The rendered <a> element received an “active” CSS class'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8：渲染的 `<a>` 元素接收了一个“active” CSS 类
- en: 'In case you want to apply a different CSS class name or inline styles when
    a link becomes active, `NavLink` also allows you to do that. Because `NavLink`
    ''s `className` and `style` props behave slightly differently than they do on
    other elements. Besides accepting string values ( `className` ) or style objects
    ( `style` ), both props also accept functions that will automatically be called
    by React Router upon every navigation action. For example, the following code
    could be used to ensure that a certain CSS class or style is applied:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在链接变为活动状态时应用不同的 CSS 类名或内联样式，`NavLink` 也允许你这样做。因为 `NavLink` 的 `className`
    和 `style` 属性在行为上与其他元素略有不同。除了接受字符串值（`className`）或样式对象（`style`）之外，这两个属性还接受函数，这些函数将由
    React Router 在每次导航操作时自动调用。例如，以下代码可以用来确保应用特定的 CSS 类或样式：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the above code snippet, both `className` and `style` take advantage of the
    function that will be executed by React Router. This function automatically receives
    an object as an input argument—an object that’s created and provided by React
    Router, and that contains an `isActive` property. React Router sets `isActive`
    to `true` if the link leads to the currently active route, and to `false` otherwise.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`className` 和 `style` 都利用了 React Router 将要执行的功能。这个函数自动接收一个对象作为输入参数——这个对象是由
    React Router 创建并提供的，它包含一个 `isActive` 属性。当链接指向当前活动路由时，React Router 将 `isActive`
    设置为 `true`，否则设置为 `false`。
- en: You can therefore return any CSS class names or style objects of your choosing
    in those functions. React Router will then apply them to the rendered `<a>` element.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以在这些函数中返回任何你选择的 CSS 类名或样式对象。然后 React Router 将它们应用到渲染的 `<a>` 元素上。
- en: '**Note**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the finished code for this example on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/06-navlinks](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/06-navlinks)
    .
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到这个示例的完整代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/06-navlinks](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/06-navlinks)。
- en: 'One important note is that `NavLink` will consider a route to be active if
    its path matches the current URL path *or* if its path starts with the current
    URL path. For example, if you had a `/blog/all-posts` route, a `NavLink` component
    that points at just `/blog` would be considered active if the current route is
    `/blog/all-posts` (because that route path starts with `/blog` ). If you don’t
    want this behavior, you can add the special `end` prop to the `NavLink` component,
    as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的注意事项是，`NavLink`会将路径与当前URL路径匹配或以当前URL路径开头的情况视为活动路由。例如，如果你有一个`/blog/all-posts`路由，一个指向`/blog`的`NavLink`组件如果当前路由是`/blog/all-posts`，则会被视为活动状态（因为该路由路径以`/blog`开头）。如果你不希望这种行为，你可以在`NavLink`组件中添加特殊的`end`属性，如下所示：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this special prop added, this `NavLink` would only be considered active
    if the current route is exactly `/blog` —for `/blog/all-posts` , the link would
    not be active.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这个特殊属性后，这个`NavLink`只有在当前路由正好是`/blog`时才会被视为活动状态——对于`/blog/all-posts`，链接则不会是活动状态。
- en: An exception from that rule would be links to just `/` . Since all routes technically
    start with this “empty path,” React Router by default only considers `<NavLink
    to="/">` as active if the user is currently on `<domain>/` . For other paths (e.g.,
    `/orders` ), `<NavLink to="/">` would not be marked as active.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例外情况是链接到`/`。由于所有路由在技术上都是以这个“空路径”开始的，React Router默认情况下只将`<NavLink to="/">`视为活动状态，如果用户当前位于`<domain>/`。对于其他路径（例如，`/orders`），`<NavLink
    to="/">`则不会被标记为活动状态。
- en: '`NavLink` is always the preferred choice when the styling of a link depends
    on the currently active route. For all other internal links, use `Link` . For
    external links, `<a>` is the element of choice.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当链接的样式依赖于当前活动路由时，`NavLink`始终是首选的选择。对于所有其他内部链接，使用`Link`。对于外部链接，`<a>`是首选元素。
- en: Route Components versus “Normal” Components
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由组件与“常规”组件的比较
- en: It’s worth mentioning and noting that, in the previous examples, the `Dashboard`
    and `Orders` components were regular React components. You could use these components
    anywhere in your React app—not just as values for the `element` property of a
    route definition.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在之前的示例中，`Dashboard`和`Orders`组件是常规的React组件。你可以在你的React应用的任何地方使用这些组件——而不仅仅是作为路由定义的`element`属性的值。
- en: However, the two components are special in that both are stored in the `src/routes`
    folder in the project directory. They are not stored in the `src/components` folder,
    which was used for components throughout this book.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两个组件是特殊的，因为它们都存储在项目目录下的`src/routes`文件夹中。它们没有存储在`src/components`文件夹中，而这本书中使用的组件都是存储在这个文件夹中的。
- en: That’s not something you have to do, though. Indeed, the folder names are entirely
    up to you. These two components could be stored in `src/components` . You could
    also store them in an `src/elements` folder. But using `src/routes` is quite common
    for components that are exclusively used for routing. Popular alternatives are
    `src/screens` , `src/views` , and `src/pages` (again, it is up to you).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是你必须做的事情。实际上，文件夹名称完全由你决定。这两个组件可以存储在`src/components`中。你也可以将它们存储在`src/elements`文件夹中。但使用`src/routes`对于仅用于路由的组件来说是非常常见的。流行的替代方案有`src/screens`、`src/views`和`src/pages`（同样，这取决于你）。
- en: If your app includes any other components that are not used as routing elements,
    you would still store those in `src/components` (i.e., in a different path). This
    is not a hard rule or a technical requirement, but it does help with keeping your
    React projects manageable. Splitting your components across multiple folders makes
    it easier to quickly understand which components fulfill which purposes in the
    project.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用包含任何其他不是作为路由元素的组件，你仍然会将这些组件存储在`src/components`（即，在不同的路径下）。这并不是一个硬性规则或技术要求，但它确实有助于保持你的React项目可管理。将你的组件分散存储在多个文件夹中，可以更容易地快速理解项目中的哪些组件实现了哪些功能。
- en: 'In the example project mentioned previously, you can, for example, refactor
    the code such that the navigation code is stored in a separate component (e.g.,
    a `MainNavigation` component, stored in `src/components/shared/MainNavigation.jsx`
    ). The component file code looks like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的示例项目中，例如，你可以重构代码，使得导航代码存储在一个单独的组件中（例如，一个`MainNavigation`组件，存储在`src/components/shared/MainNavigation.jsx`）。组件文件代码如下：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code snippet, the `NavLink` component is adjusted to assign a CSS class
    named `active` to any link that belongs to the currently active route. This is
    required when using CSS Modules since the class names are changed during the build
    process, as discussed in *Chapter 6* , *Styling React Apps* . Besides that, it’s
    essentially the same navigation menu code as that used earlier in this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`NavLink`组件被调整以将名为`active`的CSS类分配给属于当前活动路由的任何链接。这是在使用CSS Modules时必需的，因为类名在构建过程中会发生变化，正如在第6章*为React应用添加样式*中讨论的那样。除此之外，它基本上与本章早期使用的相同导航菜单代码。
- en: 'This `MainNavigation` component can then be imported and used in the `Root.jsx`
    file like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个`MainNavigation`组件可以被导入并像这样在`Root.jsx`文件中使用：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Importing and using the `MainNavigation` component leads to a leaner `Root`
    component and yet preserves the same functionality as before.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 导入和使用`MainNavigation`组件会导致`Root`组件更加精简，同时仍然保留之前的功能。
- en: These changes show how you can combine routing components that are only used
    for routing ( `Dashboard` and `Orders` ) and components that are used outside
    of routing ( `MainNavigation` ).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改显示了你可以如何组合仅用于路由的组件（`Dashboard`和`Orders`）以及用于路由外部的组件（`MainNavigation`）。
- en: '**Note**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the finished code for this example on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/07-routing-and-normal-cmp](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/07-routing-and-normal-cmp)
    .
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到这个示例的完成代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/07-routing-and-normal-cmp](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/07-routing-and-normal-cmp)。
- en: 'But even with those markup and style improvements, the demo application still
    suffers from an important problem: it only supports static, predefined routes.
    But, for most websites, those kinds of routes are not enough.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了那些标记和样式的改进，演示应用程序仍然存在一个重要问题：它只支持静态、预定义的路由。但对于大多数网站来说，这类路由是不够的。
- en: From Static to Dynamic Routes
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从静态路由到动态路由
- en: 'Thus far, all examples have had two routes: `/` for the `Dashboard` component
    and `/orders` for the `Orders` component. But you can, of course, add as many
    routes as needed. If your website consists of 20 different pages, you can (and
    should) add 20 route definitions (i.e., 20 `Route` components) to your `App` component.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有示例都有两个路由：`/`用于`Dashboard`组件，`/orders`用于`Orders`组件。但你可以，当然，添加所需的路由数量。如果你的网站有20个不同的页面，你（应该）为`App`组件添加20个路由定义（即20个`Route`组件）。
- en: On most websites, however, you will also have some routes that can’t be defined
    manually—because not all routes and their exact paths are known in advance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数网站上，你也会有一些无法手动定义的路由——因为并非所有路由及其确切路径都是预先知道的。
- en: 'Consider the example from before, enriched with additional components and some
    dummy data:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑之前的示例，增加了额外的组件和一些模拟数据：
- en: '![img](img/B31339_13_09.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_13_09.png)'
- en: 'Figure 13.9: A list of order items'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：订单项列表
- en: '**Note**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the code for this example on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/08-dynamic-routes-problem](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/08-dynamic-routes-problem)
    . In the code, you’ll notice that many new components and style files were added.
    The code does not use any new features, though. It’s just used to display a more
    realistic user interface and output some dummy data.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到这个示例的代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/08-dynamic-routes-problem](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/08-dynamic-routes-problem)。在代码中，你会注意到添加了许多新的组件和样式文件。尽管如此，代码并没有使用任何新特性。它只是用来显示一个更真实的用户界面并输出一些模拟数据。
- en: In the preceding screenshot, *Figure 13.9* , you can see a list of order items
    being output on the `Past Orders` page (i.e., by the `Orders` component).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图*图13.9*中，你可以看到订单项列表在`Past Orders`页面（即由`Orders`组件）上输出。
- en: 'In the underlying code, every order item is wrapped with a `Link` component
    so that a separate page with more details can be loaded for each item:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层代码中，每个订单项都被一个`Link`组件包裹，以便为每个项目加载一个包含更多详细信息的单独页面：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this code snippet, the path for the `Link` component is set to `/orders`
    . However, that’s not the final value that should be assigned. Instead, this example
    highlights an important problem: while it’s the same route and component that
    should be loaded for every order item (i.e., some component that displays detailed
    data about the selected order), the exact content output by that component depends
    on which order item was selected. It’s the same route and component with different
    data.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`Link`组件的路径被设置为`/orders`。然而，这并不是应该分配的最终值。相反，这个例子突出了一个重要问题：虽然对于每个订单项都应该加载相同的路由和组件（即显示所选订单详细数据的组件），但该组件输出的确切内容取决于选择了哪个订单项。这是相同的路由和组件，但数据不同。
- en: Outside of routing, you would use props to reuse the same component with different
    data. But with routing, it’s not just about the component. You also must support
    different paths—because the detailed data for different orders should be loaded
    via different paths (e.g., `/orders/o1` , `/orders/o2` , etc.). Otherwise, you
    would again end up with URLs that are not shareable or reloadable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了路由之外，你会使用props来重复使用具有不同数据的相同组件。但是，在路由的情况下，这不仅仅关乎组件。你还必须支持不同的路径——因为不同订单的详细信息应该通过不同的路径（例如，`/orders/o1`、`/orders/o2`等）来加载。否则，你又会得到不可共享或重新加载的URL。
- en: Therefore, the path must include not only some static identifier (such as `/orders`
    ) but also a dynamic value that’s different for every order item. For three order
    items with `id` values `o1` , `o2` , and `o3` , the goal could be to support the
    `/orders/o1` , `/orders/o2` , and `/order/o3` paths.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，路径必须包含不仅是一些静态标识符（例如`/orders`），而且对于每个订单项都是不同的动态值。对于具有`id`值`o1`、`o2`和`o3`的三个订单项，目标可能是支持`/orders/o1`、`/orders/o2`和`/order/o3`路径。
- en: 'For this reason, the following three route definitions could be added:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下三个路由定义可以添加：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: But this solution has a major flaw. Adding all these routes manually is a huge
    amount of work. And that’s not even the biggest problem. You typically don’t even
    know all values in advance. In this example, when a new order is placed, a new
    route would have to be added. But you can’t adjust the source code of your website
    every time a visitor places an order.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个解决方案有一个主要的缺陷。手动添加所有这些路由是一项巨大的工作量。而且这还不是最大的问题。你通常甚至不知道所有值。在这个例子中，当放置一个新订单时，必须添加一个新的路由。但你不能每次访客下单时都调整你网站的源代码。
- en: Clearly, then, a better solution is needed. React Router offers that better
    solution as it supports **dynamic routes** .
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，因此需要一个更好的解决方案。React Router提供了这个更好的解决方案，因为它支持**动态路由**。
- en: Dynamic routes are defined just like other routes, except that, when defining
    their `path` values, you will need to include one or more **dynamic path segments**
    with identifiers of your choice.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 动态路由的定义方式与其他路由相同，只是在定义它们的`path`值时，你需要包含一个或多个你选择的**动态路径段**。
- en: 'The `OrderDetail` route definition therefore looks like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`OrderDetail`路由定义看起来是这样的：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following three key things have changed:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个关键事物已经改变：
- en: It’s just one route definition instead of a (possibly) infinite list of definitions.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这只是一个路由定义，而不是一个（可能）无限的路由定义列表。
- en: '`path` contains a dynamic path segment ( `:id` ).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`包含一个动态路径段（`:id`）。'
- en: '`OrderDetail` no longer receives an `id` prop.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderDetail`不再接收`id`prop。'
- en: The `:id` syntax is a special syntax supported by React Router. Whenever a segment
    of a path starts with a colon, React Router treats it as a **dynamic segment**
    . That means that it will be replaced with a different value in the actual URL
    path. For the `/orders/:id` route path, the `/orders/o1` , `/orders/o2` , and
    `/orders/abc` paths would all match and therefore activate the route.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`:id`语法是React Router支持的特殊语法。每当路径的一个部分以冒号开头时，React Router将其视为**动态段**。这意味着它将在实际的URL路径中被不同的值替换。对于`/orders/:id`路由路径，`/orders/o1`、`/orders/o2`和`/orders/abc`路径都会匹配，因此激活路由。'
- en: Of course, you don’t have to use `:id` . You can use any identifier of your
    choice. For the preceding example, `:orderId` , `:order` , or `:oid` would also
    make sense.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必使用`:id`。你可以使用任何你选择的标识符。对于前面的例子，`:orderId`、`:order`或`:oid`也是有意义的。
- en: The identifier will help your app access the correct data inside the page component
    that should be loaded for the dynamic route (i.e., the `OrderDetail` route component
    in the example code snippets above). That’s why the `id` prop was removed from
    `OrderDetail` in the last code snippet. Since only one route is defined, only
    one specific `id` value could be passed via props. That won’t help. Therefore,
    a different way of loading order-specific data must be used.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符将帮助你的应用程序访问页面组件中应加载的动态路由的正确数据（即上面代码片段中的`OrderDetail`路由组件）。这就是为什么在上一个代码片段中从`OrderDetail`中移除了`id`属性。由于只定义了一个路由，因此只能通过属性传递一个特定的`id`值。这不会有所帮助。因此，必须使用不同的方式来加载特定订单的数据。
- en: Extracting Route Parameters
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取路由参数
- en: In the previous example, when a website user visits `/orders/o1` or `/orders/o2`
    (or the same path for any other order ID), the `OrderDetail` component is loaded.
    This component should then output more information about the specific order that
    was selected (i.e., the order whose ID is encoded in the URL path).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当网站用户访问`/orders/o1`或`/orders/o2`（或任何其他订单ID的相同路径）时，会加载`OrderDetail`组件。然后，该组件应该输出有关所选特定订单的更多信息（即ID编码在URL路径中的订单）。
- en: By the way, that’s not just the case for this example; you can think of many
    other types of websites as well. You could also have, for example, an online shop
    with routes for products ( `/products/p1` , `/products/p2` , etc.), or a travel
    blog where users can visit individual blog posts ( `/blog/post1` , `/blog/post2`
    , etc.).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这不仅仅适用于这个例子；你也可以考虑许多其他类型的网站。例如，你也可以有一个在线商店，其中包含产品路由（`/products/p1`、`/products/p2`等），或者一个旅游博客，用户可以访问单个博客文章（`/blog/post1`、`/blog/post2`等）。
- en: In all these cases, the question is how do you get access to the data that should
    be loaded for the specific identifier (e.g., the ID) that’s included in the URL
    path? Since it’s always the same component that’s loaded, you need a way of dynamically
    identifying the order, product, or blog post for which the detail data should
    be fetched.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，问题是如何获取应加载到特定标识符（例如，ID）中的数据，该标识符包含在URL路径中？由于总是加载相同的组件，你需要一种动态识别顺序、产品或博客文章的方法，以便获取相应的详细数据。
- en: One possible solution would be the usage of props. Whenever you build a component
    that should be reusable yet configurable and dynamic, you can use props to accept
    different values. For example, the `OrderDetail` component could accept an `id`
    prop and then, inside the component function body, load the data for that specific
    order ID.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是使用属性。每当构建一个应该可重用且可配置和动态的组件时，可以使用属性来接受不同的值。例如，`OrderDetail`组件可以接受一个`id`属性，然后在组件函数体内加载该特定订单ID的数据。
- en: 'However, as mentioned in the previous section, this is not a possible solution
    when loading the component via routing. Keep in mind that the `OrderDetail` component
    is created when defining the route:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如前所述，当通过路由加载组件时，这不是一个可行的解决方案。记住，`OrderDetail`组件是在定义路由时创建的：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since the component is created when defining the route in the `App` component,
    you can’t pass in any dynamic, ID-specific prop values.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组件是在`App`组件中定义路由时创建的，因此无法传递任何动态的、ID特定的属性值。
- en: 'Fortunately, though, that’s not necessary. React Router gives you a solution
    that allows you to extract the data encoded in the URL path from inside the component
    that’s displayed on the screen (when the route becomes active): the `useParams()`
    Hook.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这并不是必要的。React Router为你提供了一个解决方案，允许你从屏幕上显示的组件内部（当路由变为活动状态时）提取编码在URL路径中的数据：`useParams()`钩子。
- en: This Hook can be used to get access to the route parameters of the currently
    active route. Route parameters are simply the dynamic values encoded in the URL
    path— `id` , in the case of this `OrderDetail` example.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子可以用来获取当前活动路由的路由参数。路由参数仅仅是编码在URL路径中的动态值——在本例的`OrderDetail`中是`id`。
- en: 'Inside the `OrderDetail` component, `useParams()` can therefore be used to
    extract the specific order ID and load the appropriate order data, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`OrderDetail`组件内部，可以使用`useParams()`来提取特定的订单ID并加载相应的订单数据，如下所示：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see in this snippet, `useParams()` returns an object that contains
    all route parameters of the currently active route as properties. Since the route
    path was defined as `/orders/:id` , the `params` object contains an `id` property.
    The value of that property is then the actual value encoded in the URL path (e.g.,
    `o1` ). If you choose a different identifier name in the route definition (e.g.,
    `/orders/:orderId` instead of `/orders/:id` ), that property name must be used
    to access the value in the `params` object (i.e., access `params.orderId` ).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在这段代码片段中所见，`useParams()` 返回一个对象，该对象包含当前活动路由的所有路由参数作为属性。由于路由路径被定义为 `/orders/:id`，因此
    `params` 对象包含一个 `id` 属性。该属性的值是实际编码在 URL 路径中的值（例如，`o1`）。如果您在路由定义中选择不同的标识符名称（例如，`/orders/:orderId`
    而不是 `/orders/:id`），则必须使用该属性名称来访问 `params` 对象中的值（即访问 `params.orderId`）。
- en: '**Note**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the complete code on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/09-dynamic-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/09-dynamic-routes)
    .
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到完整的代码，地址为 [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/09-dynamic-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/09-dynamic-routes)。
- en: By using route parameters, you can thus easily create dynamic routes that lead
    to different data being loaded. But, of course, defining routes and handling route
    activation are not that helpful if you do not have links leading to dynamic routes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用路由参数，您可以轻松创建动态路由，这些路由可以加载不同的数据。但是，当然，如果您没有指向动态路由的链接，那么定义路由和处理路由激活并没有那么有用。
- en: Creating Dynamic Links
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动态链接
- en: As mentioned earlier in this chapter (in the *Adding Page Navigation* section),
    website visitors should be able to click on links that should then take them to
    the different pages that make up the overall website—meaning, those links should
    activate the various routes defined with the help of React Router.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如在本章前面（在 *添加页面导航* 部分中）所述，网站访客应该能够点击链接，然后这些链接应该将他们带到构成整个网站的各个页面——这意味着，这些链接应该激活使用
    React Router 定义的各个路由。
- en: As explained in the *Adding Page Navigation* and *From Link to NavLink* sections,
    for internal links (i.e., links leading to routes defined inside the React app),
    the `Link` or `NavLink` components are used.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 *添加页面导航* 和 *从链接到 NavLink* 部分中所述，对于内部链接（即指向 React 应用内部定义的路由的链接），使用 `Link`
    或 `NavLink` 组件。
- en: 'So, for static routes such as `/orders` , links are created like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于像 `/orders` 这样的静态路由，链接是这样创建的：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When building a link to a dynamic route such as `/orders/:id` , you can therefore
    simply create a link like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当构建指向如 `/orders/:id` 这样的动态路由的链接时，您可以简单地创建一个如下所示的链接：
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This specific link loads the `OrderDetails` component for the order with the
    ID `o1` .
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此特定链接加载了 ID 为 `o1` 的 `OrderDetails` 组件。
- en: 'Building the link as follows would be incorrect:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式构建链接是不正确的：
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The dynamic path segment syntax ( `:id` ) is only used when defining the route—not
    when creating a link. The link has to lead to a specific resource (a specific
    order, in this case).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 动态路径段语法（`:id`）仅在定义路由时使用——在创建链接时不使用。链接必须指向特定的资源（在这种情况下是特定的订单）。
- en: However, creating links to specific orders, as shown previously, is not very
    practical. Just as it wouldn’t make sense to define all dynamic routes individually
    (see the *From Static to Dynamic Routes* section), it doesn’t make sense to create
    the respective links manually.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如之前所示，创建指向特定订单的链接并不太实用。正如在 *从静态路由到动态路由* 部分中定义所有动态路由单独来说没有意义一样，手动创建相应的链接也没有意义。
- en: Sticking to the orders example, there is also no need to create links like that
    as you already have a list of orders that’s output on one page (the `Orders` component,
    in this case). Similarly, you could have a list of products in an online shop.
    In all these cases, the individual items (orders, products, etc.) should be clickable
    and lead to details pages with more information.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以订单为例，由于您已经在单页（在这种情况下是 `Orders` 组件）上输出了订单列表，因此无需创建此类链接。同样，您可以在在线商店中有一个产品列表。在这些所有情况下，单个项目（订单、产品等）应该是可点击的，并链接到包含更多信息的详细信息页面。
- en: '![img](img/B31339_13_10.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_13_10.png)'
- en: 'Figure 13.10: A list of clickable order items'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10：可点击的订单项列表
- en: 'Therefore, the links can be generated dynamically when rendering the list of
    JSX elements. In the case of the orders example, the code looks like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在渲染JSX元素列表时可以动态生成链接。在订单示例的情况下，代码看起来是这样的：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code example, the value of the `to` prop is set dynamically equal to
    a string that includes the `order.id` value. Therefore, every list item receives
    a unique link that leads to a different details page. Or, to be precise, the link
    always leads to the same component but with a different order `id` value, hence
    loading different order data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，`to`属性的值被动态设置为包含`order.id`值的字符串。因此，每个列表项都接收一个独特的链接，该链接指向不同的详情页面。或者，更准确地说，链接始终指向同一个组件，但具有不同的`order
    id`值，因此加载不同的订单数据。
- en: '**Note**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In this code snippet (which can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/10-dynamic-links](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/10-dynamic-links)
    ), the string is created as a **template literal** . That’s a default JavaScript
    feature that simplifies the creation of strings that include dynamic values.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段（可在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/10-dynamic-links](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/10-dynamic-links)
    )中，字符串被创建为**模板字面量**。这是一个默认的JavaScript功能，它简化了包含动态值的字符串的创建。
- en: You can learn more about template literals on MDN at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
    .
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在MDN上了解更多关于模板字面量的信息，网址为[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
    。
- en: Navigating Programmatically
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序化导航
- en: In the previous section, as well as earlier in this chapter, user navigation
    was enabled by adding links to the website. Indeed, links are the default way
    of adding navigation to a website. But there are scenarios where programmatic
    navigation is required instead.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节以及本章前面的内容中，用户导航是通过向网站添加链接来实现的。确实，链接是向网站添加导航的默认方式。但有些情况下需要使用程序化导航。
- en: Programmatic navigation means that a new page should be loaded via JavaScript
    code (rather than using a link). This kind of navigation is typically required
    if the active page changes in response to some action—e.g., upon form submission.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化导航意味着新页面应通过JavaScript代码加载（而不是使用链接）。这种导航通常在活动页面因某些操作而改变时需要——例如，在表单提交时。
- en: If you take the example of form submission, you will normally want to extract
    and save the submitted data. But thereafter, the user will sometimes need to be
    redirected to a different page. For example, it makes no sense to keep the user
    on a `Checkout` page after processing the entered credit card details. You might
    want to redirect the user to a `Success` page instead.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以表单提交为例，您通常希望提取并保存提交的数据。但在此之后，有时需要将用户重定向到不同的页面。例如，在处理输入的信用卡详情后，让用户留在`结账`页面是没有意义的。您可能希望将用户重定向到`成功`页面。
- en: In the example discussed throughout this chapter, the `Past Orders` page could
    include an input field that allows users to directly enter an order ID and load
    the respective order data after clicking the `Find` button.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章讨论的示例中，`历史订单`页面可以包括一个输入字段，允许用户直接输入订单ID，并在点击`查找`按钮后加载相应的订单数据。
- en: '![img](img/B31339_13_11.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_13_11.png)'
- en: 'Figure 13.11: An input field that can be used to quickly load a specific order'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11：一个可以快速加载特定订单的输入字段
- en: 'In this example, the entered order ID is first processed and validated before
    the user is sent to the respective details page. If the provided ID is invalid,
    an error message is shown instead. The code looks like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，首先处理并验证输入的订单ID，然后用户被发送到相应的详情页面。如果提供的ID无效，则显示错误消息。代码如下：
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code snippet does not yet include the code that will actually trigger the
    page change, but it does show how the user input is read and validated.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段尚未包括实际触发页面更改的代码，但它显示了如何读取和验证用户输入。
- en: Therefore, this is a perfect scenario for the use of programmatic navigation.
    A link can’t be used here since it would immediately trigger a page change—without
    allowing you to validate the user input first (at least not after the link was
    clicked).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个使用程序化导航的完美场景。在这里不能使用链接，因为它会立即触发页面更改——在允许您首先验证用户输入之前（至少在点击链接之后不会）。
- en: 'The React Router library also supports programmatic navigation for cases like
    this. You can import and use the special `useNavigate()` Hook to gain access to
    a navigation function that can be used to trigger a navigation action (i.e., a
    page change):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 库还支持此类情况下的程序化导航。你可以导入并使用特殊的 `useNavigate()` 钩子来获取一个可以用来触发导航操作（即页面更改）的导航函数：
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Hence, the `OrdersSummary` component from previously can be adjusted like this
    to use this new Hook:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，之前提到的 `OrdersSummary` 组件可以调整如下以使用这个新的钩子：
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It’s worth noting that the value passed to `navigate()` is a dynamically constructed
    string. Programmatic navigation supports both static and dynamic paths.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，传递给 `navigate()` 的值是一个动态构造的字符串。程序化导航支持静态和动态路径。
- en: '**Note**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The code for this example can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/11-programmatic-navigation](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/11-programmatic-navigation)
    .
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码可以在 [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/11-programmatic-navigation](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/11-programmatic-navigation)
    找到。
- en: Redirecting
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向
- en: Thus far, all the explored navigation options (links and programmatic navigation)
    forward a user to a specific page.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有探索过的导航选项（链接和程序化导航）都将用户转发到特定页面。
- en: In most cases, that’s the intended behavior. But in some cases, the goal is
    to redirect a user instead of forwarding them.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这是预期的行为。但在某些情况下，目标是重定向用户而不是转发他们。
- en: The difference is subtle but important. When a user is forwarded, they can use
    the browser’s navigation buttons ( `Back` and `Forward` ) to go back to the previous
    page or forward to the page they came from. For redirects, that’s not possible.
    Whenever a user is redirected to a specific page (rather than forwarded), they
    can’t use the `Back` button to return to the previous page.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别细微但很重要。当用户被转发时，他们可以使用浏览器的导航按钮（`后退` 和 `前进`）返回到上一页或跳转到他们来的页面。对于重定向，这是不可能的。无论何时用户被重定向到特定页面（而不是被转发），他们都不能使用
    `后退` 按钮返回到上一页。
- en: Redirecting users can, for example, be useful for ensuring that users can’t
    go back to a login page after authenticating successfully.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向用户，例如，可以确保用户在成功认证后无法返回登录页面。
- en: 'When using React Router, the default behavior is to forward users. But you
    can easily switch to redirecting by adding the special `replace` prop to the `Link`
    (or `NavLink` ) components, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React Router 时，默认行为是转发用户。但你可以通过向 `Link`（或 `NavLink`）组件添加特殊的 `replace` 属性来轻松切换到重定向，如下所示：
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When using programmatic navigation, you can pass a second, optional argument
    to the `navigate()` function. That second parameter value must be an object that
    can contain a `replace` property that should be set to `true` if you want to redirect
    users:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用程序化导航时，你可以向 `navigate()` 函数传递第二个可选参数。该第二个参数值必须是一个对象，该对象可以包含一个 `replace` 属性，如果你想重定向用户，则应将其设置为
    `true`：
- en: '[PRE27]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Being able to redirect or forward users allows you to build highly user-friendly
    web applications that offer the best possible user experience for different scenarios.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 能够重定向或转发用户，让你能够构建高度用户友好的网络应用程序，为不同场景提供最佳的用户体验。
- en: Handling Undefined Routes
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理未定义的路由
- en: Previous sections in this chapter have all assumed that you have predefined
    routes that should be reachable by website visitors. But what if a visitor enters
    a URL that’s simply not supported?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面的部分都假设你已经有预定义的路由，这些路由应该可以被网站访客访问。但如果是访客输入了一个根本不支持 URL 呢？
- en: For example, the demo website used throughout this chapter supports the `/`
    , `/orders` , and `/orders/<some-id>` paths. But it does not support `/home` ,
    `/products/p1` , `/abc` , or any other path that’s not one of the defined route
    paths.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，本章中使用的演示网站支持 `/`、`/orders` 和 `/orders/<some-id>` 路径。但它不支持 `/home`、`/products/p1`、`/abc`
    或任何不是定义的路由路径的其他路径。
- en: 'To show a custom *Not Found* page, you can define a “catch all” route with
    a special path—the `*` path:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示自定义的 *未找到* 页面，你可以定义一个具有特殊路径的“捕获所有”路由——`*` 路径：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When adding this route to the list of route definitions in the `App` component,
    the `NotFound` component will be displayed on the screen when no other route matches
    the entered or generated URL path.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当将此路由添加到 `App` 组件的路由定义列表中时，如果没有其他路由与输入或生成的 URL 路径匹配，屏幕上将显示 `NotFound` 组件。
- en: Lazy Loading
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载
- en: In *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    , you learned about lazy loading—a technique that can be used to load certain
    pieces of the React application code only when needed.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 10 章 *React 和优化机会背后的场景* 中，你学习了懒加载——一种仅在需要时加载 React 应用程序代码片段的技术。
- en: Code splitting makes a lot of sense if some components will be loaded conditionally
    and may not be needed at all. Hence, routing is a perfect scenario for lazy loading.
    When applications have multiple routes, some routes may never be visited by a
    user. Even if all routes are visited, not all the code for all app routes (i.e.,
    for their components) must be downloaded right at the start when the application
    loads. Instead, it makes sense to only download code for individual routes when
    they actually become active.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些组件将条件性加载并且可能根本不需要，代码拆分就非常有意义。因此，路由是懒加载的完美场景。当应用程序有多个路由时，一些路由可能永远不会被用户访问。即使所有路由都被访问，也不必在应用程序加载时立即下载所有应用路由（即它们的组件）的代码。相反，当它们实际变为活动状态时，只下载单个路由的代码是有意义的。
- en: 'Thankfully, React Router has built-in support for lazy loading and route-based
    code splitting. It provides a `lazy` property that can be added to a route definition.
    That property expects a function that dynamically imports the lazily loaded file
    (which contains the component that should be rendered). React Router then takes
    care of the rest—for example, you don’t need to wrap `Suspense` around any components:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，React Router 内置了对懒加载和基于路由的代码拆分的支持。它提供了一个可以添加到路由定义中的 `lazy` 属性。该属性期望一个函数，该函数动态导入要懒加载的文件（其中包含应渲染的组件）。然后
    React Router 负责其余工作——例如，你不需要将 `Suspense` 包装在任何组件周围：
- en: '[PRE29]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, both the `/orders` and `/orders/:id` routes are set up to load
    their respective components lazily.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`/orders` 和 `/orders/:id` 路由都设置为懒加载它们各自组件。
- en: 'For the above code to work, there’s one important adjustment you must apply
    to your route component files when using this built-in lazy-loading support: you
    must replace the default component function export ( `export default SomeComponent`
    ) with a named export where the component function is named `Component` .'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使上述代码正常工作，当使用此内置懒加载支持时，你必须对你的路由组件文件进行一项重要调整：你必须将默认组件函数导出（`export default SomeComponent`）替换为命名导出，其中组件函数被命名为
    `Component`。
- en: 'For example, the `Orders` component code needs to be changed to look like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Orders` 组件代码需要修改为如下所示：
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this code snippet, the `Orders` component function is exported as `Component`
    . This name is required since React Router looks for a component function named
    `Component` when activating a lazy-loaded route.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，`Orders` 组件函数被导出为 `Component`。由于 React Router 在激活懒加载路由时会寻找名为 `Component`
    的组件函数，因此这个名称是必需的。
- en: '**Note**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The code for this example can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/12-lazy-loading](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/12-lazy-loading)
    .
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例的代码可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/12-lazy-loading](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/12-lazy-loading)
    找到。
- en: As explained in *Chapter 10* , *Behind the Scenes of React and Optimization
    Opportunities* , adding lazy loading can improve your React application’s performance
    considerably. You should always consider using lazy loading, but you should not
    use it for every route. It would be especially illogical for routes that are guaranteed
    to be loaded early, for instance. In the previous example, it would not make too
    much sense to lazy load the `Dashboard` component since that’s the default route
    (with a path of `/` ).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第 10 章 *React 和优化机会背后的场景* 中所述，添加懒加载可以显著提高 React 应用程序的性能。你应该始终考虑使用懒加载，但不应为每个路由都使用它。对于那些保证会早期加载的路由，例如，这样做尤其没有逻辑。在前面的例子中，由于这是默认路由（路径为
    `/`），对 `Dashboard` 组件进行懒加载并没有太多意义。
- en: But routes that are not guaranteed to be visited at all (or at least not immediately
    after the website is loaded) are great candidates for lazy loading.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于那些根本不会被访问的路由（或者至少不是在网站加载后立即访问）是懒加载的理想候选者。
- en: Summary and Key Takeaways
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: Routing is a key feature for many React apps.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由是许多 React 应用程序的关键特性。
- en: With routing, users can visit multiple pages despite being on an **SPA** .
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由，用户可以在单页应用（SPA）中访问多个页面。
- en: The most common package that helps with routing is the React Router library
    ( `react-router-dom` ).
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常用的帮助路由的包是React Router库（`react-router-dom`）。
- en: Routes are defined with the help of the `createBrowserRouter()` function and
    the `RouterProvider` component (typically in the `App` component or the `main.jsx`
    file, but you can do it anywhere).
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由是通过`createBrowserRouter()`函数和`RouterProvider`组件定义的（通常在`App`组件或`main.jsx`文件中，但你可以在任何地方做这件事）。
- en: Route definition objects are typically set up with a `path` (for which the route
    should become active) and an `element` (the content that should be displayed)
    property.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由定义对象通常通过一个`path`（路由应该变得活跃的路径）和一个`element`（应该显示的内容）属性来设置。
- en: Content and markup can be shared across multiple routes by setting up layout
    routes—i.e., routes wrapping other nested routes.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容和标记可以通过设置布局路由来在多个路由之间共享——即包裹其他嵌套路由的路由。
- en: Users can navigate between routes by manually changing the URL path, by clicking
    links, or because of programmatic navigation.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以通过手动更改URL路径、点击链接或程序性导航在路由之间导航。
- en: Internal links (i.e., links leading to application routes defined by you) should
    be created via the `Link` or `NavLink` components, while links to external resources
    use the standard `<a>` element.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部链接（即指向你定义的应用程序路由的链接）应通过`Link`或`NavLink`组件创建，而指向外部资源的链接则使用标准的`<a>`元素。
- en: Programmatic navigation is triggered via the `navigate()` function, which is
    yielded by the `useNavigate()` Hook.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序性导航是通过由`useNavigate()`钩子提供的`navigate()`函数触发的。
- en: 'You can define static and dynamic routes: static routes are the default, while
    dynamic routes are routes where the path (in the route definition) contains a
    dynamic segment (denoted by a colon, e.g., `:id` ).'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以定义静态和动态路由：静态路由是默认的，而动态路由是路径（在路由定义中）包含动态段的路由（由冒号表示，例如`:id`）。
- en: The actual values for dynamic path segments can be extracted via the `useParams()`
    Hook.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态路径段的实际值可以通过`useParams()`钩子提取。
- en: You can use lazy loading to load route-specific code only when the route is
    actually visited by the user.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用懒加载来仅在用户实际访问路由时加载特定路由的代码。
- en: What’s Next?
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: Routing is a feature that’s not supported by React out of the box but still
    matters for most React applications. That’s why it’s included in this book and
    why the React Router library exists. Routing is a crucial concept that completes
    your knowledge about the most essential React ideas and concepts, allowing you
    to build both simple and complex React applications.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是React默认不支持的功能，但对于大多数React应用来说仍然很重要。这就是为什么它包含在这本书中，以及为什么存在React Router库。路由是一个关键概念，它完善了你关于最基本React想法和概念的知识，使你能够构建简单和复杂的React应用。
- en: The next chapter builds upon this chapter and dives even deeper into React Router,
    exploring its data fetching and manipulation capabilities.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章基于本章内容，并更深入地探讨React Router，探索其数据获取和处理能力。
- en: Test Your Knowledge!
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to the examples that can
    be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/exercises/questions-answers.md)
    :'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章涵盖的概念的了解。然后，你可以将你的答案与可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/exercises/questions-answers.md)找到的示例进行比较。：
- en: How is routing different from loading content conditionally?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由与条件性加载内容有何不同？
- en: How are routes defined?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由是如何定义的？
- en: How should you add links to different routes to your pages?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该如何将链接添加到你的页面上的不同路由？
- en: How can dynamic routes (e.g., details for one of many products) be added to
    your app?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将动态路由（例如，许多产品之一的产品详情）添加到你的应用中？
- en: How can dynamic route parameter values be extracted (e.g., to load product data)?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何提取动态路由参数值（例如，加载产品数据）？
- en: What’s the purpose of nested routes?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嵌套路由的目的是什么？
- en: Apply What You Learned
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用所学知识
- en: Apply your knowledge about routing to the following activities.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 将你对路由的知识应用到以下活动中。
- en: 'Activity 13.1: Creating a Basic Three-Page Website'
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第13.1节：创建一个基本的三个页面网站
- en: 'In this activity, your task is to create a very basic first draft for a brand-new
    online shop website. The website must support three main pages:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，你的任务是创建一个全新的在线商店网站的基本初稿。该网站必须支持三个主要页面：
- en: A welcome page
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欢迎页面
- en: A products overview page that shows a list of available products
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显示可用产品列表的产品概览页面
- en: A product details page, which allows users to explore product details
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个产品详情页面，允许用户探索产品详情
- en: Final website styling, content, and data will be added by other teams, but you
    should provide some dummy data and default styling. You must also add a shared
    main navigation bar at the top and implement route-based lazy loading.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最终网站的风格、内容和数据将由其他团队添加，但你应提供一些占位符数据和默认样式。你还必须在顶部添加一个共享的主导航栏并实现基于路由的懒加载。
- en: 'The finished pages should look like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的页面应如下所示：
- en: '![img](img/B31339_13_12.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_13_12.png)'
- en: 'Figure 13.12: The welcome page.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12：欢迎页面。
- en: '![img](img/B31339_13_13.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_13_13.png)'
- en: 'Figure 13.13: A page showing some dummy product placeholders'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13：显示一些占位符产品占位符的页面。
- en: '![img](img/B31339_13_14.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_13_14.png)'
- en: 'Figure 13.14: The final product details page with some placeholder data and
    styles'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.14：带有一些占位符数据和样式的最终产品详情页面。
- en: '**Note**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: For this activity, you can, of course, write all CSS styles on your own. But
    if you want to focus on the React and JavaScript logic, you can also use the finished
    CSS file from the solution at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/13-routing/activities/practice-1/src/index.css](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/13-routing/activities/practice-1/src/index.css)
    .
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此活动，你当然可以自己编写所有 CSS 样式。但如果你想要专注于 React 和 JavaScript 逻辑，你也可以使用解决方案中的完成 CSS
    文件，位置在 [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/13-routing/activities/practice-1/src/index.css](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/13-routing/activities/practice-1/src/index.css)。
- en: If you use that file, explore it carefully to ensure you understand which IDs
    or CSS classes might need to be added to certain JSX elements of your solution.
    You can also use the solution’s dummy data instead of creating your own dummy
    product data. You will find the data for this at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/13-routing/activities/practice-1/src/data/products.js](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/13-routing/activities/practice-1/src/data/products.js)
    .
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用那个文件，请仔细探索以确保你理解可能需要添加到解决方案中某些 JSX 元素的哪些 ID 或 CSS 类。你也可以使用解决方案的占位符数据而不是创建自己的占位符产品数据。你可以在这个位置找到这些数据：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/13-routing/activities/practice-1/src/data/products.js](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/13-routing/activities/practice-1/src/data/products.js)。
- en: 'To complete the activity, the solution steps are as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此活动，解决方案步骤如下：
- en: Create a new React project and install the React Router package.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 React 项目并安装 React Router 包。
- en: Create components (with the content shown in the preceding screenshot) that
    will be loaded for the three required pages.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建组件（如前一个屏幕截图所示），这些组件将被加载到三个必需的页面中。
- en: Enable routing and add the route definitions for the three pages.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用路由并添加三个页面的路由定义。
- en: Add a main navigation bar that’s visible for all pages.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个对所有页面都可见的主导航栏。
- en: Add all required links and ensure that the navigation bar links reflect whether
    or not a page is active.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所有必要的链接并确保导航栏链接反映页面是否处于活动状态。
- en: Implement lazy loading (for routes where it makes sense).
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现懒加载（对于有意义的路由）。
- en: '**Note**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'The full code, and solution, for this activity can be found here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1)
    .'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的完整代码和解决方案可以在以下位置找到：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1)。
