<html><head></head><body>
  <div id="_idContainer118" class="Basic-Text-Frame">
    <h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-178" class="chapterTitle">Server-Side Rendering</h1>
    <p class="normal">As we discussed in <em class="chapterRef">Chapter 1</em>, <em class="italic">Why React?</em>, the React library is remarkably flexible in terms of how our components can be transformed into various target formats. One such target format, as you might have guessed, is standard HTML markup, presented as a string and generated on the server. In this chapter, we will delve into how <strong class="keyWord">server-side rendering</strong> (<strong class="keyWord">SSR</strong>) works <a id="_idIndexMarker449"/>in React and the advantages it offers both users and developers. You will learn why this approach can be valuable for your application and how it enhances the overall user experience and performance.</p>
    <p class="normal">The following topics are covered in this chapter:</p>
    <ul>
      <li class="bulletList">Working on the server</li>
      <li class="bulletList">Using Next.js</li>
      <li class="bulletList">React Server Components</li>
    </ul>
    <h1 id="_idParaDest-179" class="heading-1">Technical requirements</h1>
    <p class="normal">You can find the code files of this chapter on GitHub at <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter13"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter13</span></a>.</p>
    <h1 id="_idParaDest-180" class="heading-1">Working on the server</h1>
    <p class="normal">Web technologies have come a long way or, more precisely, have come full circle. It all started with static web pages prepared by a server. Servers<a id="_idIndexMarker450"/> were the foundation of all website and application logic, as they were entirely responsible for their functioning. Then, we tried to move away from <strong class="keyWord">SSR</strong> in<a id="_idIndexMarker451"/> favor of rendering pages in the browser, which led to a significant leap in the development of web pages as fully fledged applications, now comparable to desktop ones. As a result, browsers became the core of application logic, while servers merely provided data for applications.</p>
    <p class="normal">Currently, the development cycle has brought us back to SSR and server components, but now we have a unified logic and code for both the server and the client. Why this happened and what conclusions and experiences we have gained with the evolution of technologies are what we will try to understand in this section, and we will simultaneously learn about the types of work our applications do on the server.</p>
    <h2 id="_idParaDest-181" class="heading-2">Server-side rendering</h2>
    <p class="normal">In a <a id="_idIndexMarker452"/>traditional <strong class="keyWord">single-page application</strong> (<strong class="keyWord">SPA</strong>) approach, we rely solely on local browser <a id="_idIndexMarker453"/>rendering. We write all the code, styles, and markup specifically for a browser, and during the application build, we get static HTML, CSS, and JavaScript files, which are then loaded into the browser.</p>
    <p class="normal">In most cases, the initial HTML file remains empty, without any content. The only important thing to have in this file is the connected JavaScript file, which will render everything we need.</p>
    <p class="normal">Below is a schematic illustration of how an SPA application is loaded and rendered:</p>
    <figure class="mediaobject"><img src="../Images/B19636_13_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.1: SPA application</p>
    <p class="normal">This approach brought interactivity, making applications feel and function like real desktop applications. There’s no longer a need to reload a page every time to update the content and receive notifications, new emails, or messages, as the entire application logic is directly in the browser. Over time, browser applications have almost entirely replaced desktop ones. Now, we can write emails, work with documents, watch movies, and do much more, all within a single browser. Many companies, instead of developing desktop applications, started creating their projects as web applications. The browser’s ability to operate across any architecture and operating system significantly reduced development costs.</p>
    <p class="normal">At the same time, servers also underwent changes, moving away from page templating, caching, etc. Backend developers no longer need to focus on page layout and can devote more time to more complex logic and architecture.</p>
    <p class="normal">However, SPA applications <a id="_idIndexMarker454"/>do have drawbacks, including the long initial load time due to the need to download and process the script. During this process, the user sees a white screen or a loading spinner. Additionally, the empty initial HTML file is not suitable for search engine optimization, as search engines perceive it as a blank page.</p>
    <p class="normal">In the context of creating, for example, an online store, a regular React SPA might not be suitable because it’s important for users and search engines to immediately see the page content. Before the advent of SPAs, such tasks were solved by tools that worked only on the server side, which always prepared the content. In React, solving this problem is more complex because, as we know, React works on the browser side.</p>
    <p class="normal">The first step in the solution will obviously be the idea of rendering the page content on the server by React. And this won’t be a problem. Since its release, React has had the <code class="inlineCode">renderToString</code> function for this purpose, which can be <a id="_idIndexMarker455"/>called in a <strong class="keyWord">Node.js server</strong> environment. This function returns an HTML string that, when sent to the browser, allows the content to be rendered on the user’s screen.</p>
    <p class="normal">Let’s see how <a id="_idIndexMarker456"/>SSR with the <code class="inlineCode">renderToString</code> function would work:</p>
    <figure class="mediaobject"><img src="../Images/B19636_13_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.2: Server rendering using renderToString</p>
    <p class="normal">In this <a id="_idIndexMarker457"/>example, when a page is requested in the browser, the server, by calling the function <code class="inlineCode">renderToString</code> and passing it to the React component tree, outputs HTML. By sending this HTML string in response to the browser’s request, the browser renders the result.</p>
    <p class="normal">However, in such an example, the HTML generated on the server and rendered in the browser lacks interactivity and the capabilities of a client application. For functionalities like buttons, navigation, and everything we are accustomed to in SPAs, JavaScript is required. Therefore, the next step in implementing an interactive site or application rendered on the server is to transmit not only HTML but also JavaScript, which will provide all the interactivity we need.</p>
    <p class="normal">To solve this problem, the approach<a id="_idIndexMarker458"/> of <strong class="keyWord">isomorphic JavaScript</strong> was introduced. Code written in this style can be executed first on the server and then on the client. This allows you to prepare the initial render on the server and send the ready HTML along with the JavaScript bundle to the client, allowing the browser to then provide interactivity. This approach speeds up the initial load of the application, while maintaining its functionality and allowing search engines to index the page in search results.</p>
    <p class="normal">When a user opens a page, they immediately see the rendering result performed on the server even before the JavaScript is loaded. This quick initial response significantly improves the user experience. After the page and JS bundle are loaded, it’s crucial for the browser to <strong class="keyWord">hydrate</strong> the page, as we know from the <code class="inlineCode">renderToString</code> example that all our elements lack interactivity. For this, the script needs to attach all necessary event listeners to the elements. This process is called <strong class="keyWord">hydration</strong> and is a lighter and faster process compared to a full-page render <a id="_idIndexMarker459"/>from scratch.</p>
    <p class="normal">Another <a id="_idIndexMarker460"/>important feature of interactivity is the ability to navigate through an application instantly or smoothly without reloading a browser page. With isomorphic JavaScript, this became possible, as it is enough to load the JavaScript code of the next page, and the application can then render the next page locally.</p>
    <figure class="mediaobject"><img src="../Images/B19636_13_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.3: SSR</p>
    <p class="normal">The figure above schematically represents the SSR approach, where the application is fully interactive. Initially, when a page is requested, the server renders the content and returns HTML with an attached JavaScript bundle. Then, the browser loads the JS file and hydrates all the content previously displayed on the page. This approach is what has come to be known as SSR. It has become widely used among React developers and has found its place in the arsenal of modern web technologies. SSR combines the fast loading of page content and the high performance of server rendering with the flexibility and interactivity of a client application.</p>
    <h2 id="_idParaDest-182" class="heading-2">Static site and incremental static generation</h2>
    <p class="normal">Although SSR represents a significant improvement, it is not a universal solution and has its drawbacks, including the need to generate a page from scratch for each request. For example, pages that do not have dynamic content must be generated on a server each time, which can cause display delays for the user. Additionally, even for the simplest applications or sites, SSR requires a Node.js server for rendering, unlike SPAs where it was sufficient to use<a id="_idIndexMarker461"/> a <strong class="keyWord">content delivery network</strong> (<strong class="keyWord">CDN</strong>) to position application files closer to the user, thereby speeding up loading.</p>
    <p class="normal">The solution to these problems was found in<a id="_idIndexMarker462"/> the <strong class="keyWord">static site generation</strong> (<strong class="keyWord">SSG</strong>) approach. The logic of SSG is to render all static pages on a server during the project build process. As a result, we get many HTML pages ready for immediate delivery upon request. As with SSR, in SSG, the JavaScript bundle hydrates the page after it has loaded, making it interactive. In the end, we get the same experience as with SPAs but not with an empty HTML file: rather, one full of content for quick rendering. SSG projects can be hosted on fast web servers or CDNs, which also allows for additional caching and speeding up the loading time of such applications.</p>
    <p class="normal">SSG became an ideal solution for websites, blogs, and simple online stores, ensuring fast page load times without blocking requests, SEO support, and the same interactivity as SPAs. Moreover, it became possible to combine SSR for dynamic data and SSG for static pages. This hybrid approach opens up new possibilities to implement more complex projects, combining the advantages of both methods. It allows developers to optimize performance and user experience by choosing the best rendering method, depending on the specific requirements of each page of the site or application.</p>
    <p class="normal">Another issue faced by developers and companies is updating statically generated pages. For example, traditionally, adding a new blog post or updating an online store’s inventory required a complete rebuild of a project, which can be time-consuming and inconvenient, especially in large projects. Imagine a blog with 1,000 posts having to be completely rebuilt and re-rendered just because a new post being added.</p>
    <p class="normal">This problem is solved by an approach known<a id="_idIndexMarker463"/> as <strong class="keyWord">incremental static generation</strong> (<strong class="keyWord">ISR</strong>). ISR combines the principles of SSG and SSR with caching functionality. To understand this approach, imagine all our generated HTML and JS files at the build stage simply as a <strong class="keyWord">cache</strong>, representing the current result of the project build. As with any <a id="_idIndexMarker464"/>cache, we now need to introduce a logic for its revalidation. As long as our cache is valid, all page requests work as before using the SSG approach. But when the revalidation time expires, the next request to the page initiates its re-rendering on the server in SSR mode. The resulting output is sent to the client and simultaneously replaces the old HTML file with a new one, i.e., updates the cache. The application then continues to operate in SSG mode.</p>
    <p class="normal">Thanks to <a id="_idIndexMarker465"/>ISR, it became possible to implement large-scale projects with millions of pages, which do not need to be constantly rebuilt for minor updates. It also became possible to altogether skip the generation of pages at the build stage, as the required pages would be rendered and saved upon request. For huge projects, this provided a significant increase in project build speeds.</p>
    <p class="normal">Currently, SSG <a id="_idIndexMarker466"/>with ISR, combined with traditional SSR, is one of the most popular approaches for implementing both simple websites and blogs, as well as complex applications. However, traditional SPAs remain a very popular solution. But if we know how to create and assemble SPAs, what about everything else we just discussed? In response to this question, it’s important to note that you don’t need to develop all these approaches manually. There are several frameworks based on React that provide all the functionalities described above:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Next.js</strong>: This framework is known for its flexibility and powerful features. Next.js<a id="_idIndexMarker467"/> started with SSR but now supports both SSR and SSG, including ISR support. Recently, Next.js has been working extensively on a new concept for implementing applications using server components, which we will discuss at the end of the chapter.</li>
      <li class="bulletList"><strong class="keyWord">Gatsby</strong>: Gatsby’s main<a id="_idIndexMarker468"/> distinction is its strong focus on generating static sites using data from<a id="_idIndexMarker469"/> various sources (such <a id="_idIndexMarker470"/>as <strong class="keyWord">CMS</strong> or <strong class="keyWord">Markdown</strong>). While there are not as many differences from Next.js as there used to be, it remains a fairly popular solution.</li>
      <li class="bulletList"><strong class="keyWord">Remix</strong>: This is a relatively new framework that focuses on closer integration with web standards and improving the user experience. Remix<a id="_idIndexMarker471"/> offers unique approaches to data handling and routing, where we can work not page by page but by sections of a page, implementing nested navigation by changing and caching only the part of the page that requires dynamics.</li>
    </ul>
    <p class="normal">All these frameworks collectively provide a similar experience and implementation of the approaches we’ve discussed. Next, we’ll explore how to implement SSR and static generation using Next.js.</p>
    <h1 id="_idParaDest-183" class="heading-1">Using Next.js</h1>
    <p class="normal">After familiarizing ourselves <a id="_idIndexMarker472"/>with the theory of SSR, let’s see how we can implement all this in practice using the <strong class="keyWord">Next.js</strong> framework.</p>
    <p class="normal"><strong class="keyWord">Next.js</strong> is a popular React-based framework specifically designed to simplify the process of SSR and static site generation. It offers powerful and flexible capabilities for creating high-performance web applications.</p>
    <p class="normal">The features<a id="_idIndexMarker473"/> of Next.js:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">An easy-to-use API that automates SSR and static generation</strong>: You just need to write code using the provided methods and functions, and the framework will automatically determine which pages should be rendered server-side and which can be rendered during the project build process.</li>
      <li class="bulletList"><strong class="keyWord">File-based routing</strong>: Next.js uses a simple and intuitive routing system based on the folder and file structure in the project. This greatly simplifies the creation and management of routes in the application.</li>
      <li class="bulletList">The ability to create comprehensive full-stack applications, thanks to API routes that allow you to implement server-side REST API endpoints.</li>
      <li class="bulletList">The optimization of images, fonts, and scripts, enhancing the performance of projects.</li>
    </ul>
    <p class="normal">Another important feature of the framework is its close collaboration with the React Core team on implementing new React features. As a result, Next.js currently supports two types of application implementations, known as <a id="_idIndexMarker474"/>the <strong class="keyWord">Pages Router</strong> and <a id="_idIndexMarker475"/>the <strong class="keyWord">App Router</strong>. The former implements the main functionality we discussed earlier, while the latter is a newer approach designed for working with React Server Components. We will examine the new approach later in this chapter, but for now, let’s start with the Pages Router.</p>
    <p class="normal">To start working with <a id="_idIndexMarker476"/>Next.js, you only need to execute a single command that will set everything up for you:</p>
    <pre class="programlisting con"><code class="hljs-con">npx create-next-app@latest
</code></pre>
    <p class="normal">This CLI command will ask you a few questions:</p>
    <pre class="programlisting con"><code class="hljs-con">✔ What is your project named? … using-nextjs
✔ Would you like to use TypeScript? … No / Yes
✔ Would you like to use ESLint? … No / Yes
✔ Would you like to use Tailwind CSS? … No / Yes
✔ Would you like to use `src/` directory? … No / Yes
✔ Would you like to use App Router? (recommended) … No / Yes
✔ Would you like to customize the default import alias (@/*)? … No / Yes
✔ What import alias would you like configured? … @/* No / Yes
</code></pre>
    <p class="normal">For our current example, you should answer <code class="inlineCode">Yes</code> to all questions except for the one about using the App Router. Also, you can access the ready-made example that we’ll discuss further at the provided link: <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter13/using-nextjs"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter13/using-nextjs</span></a>.</p>
    <p class="normal">In the example, we will create a small website with multiple pages, each using different server rendering approaches. In <a id="_idIndexMarker477"/>Next.js, each page of the website should be placed in separate files with names that correspond to the URL path. In our project example:</p>
    <ul>
      <li class="bulletList">The main page of the website, accessible at the root path <code class="inlineCode">domain.com/</code>, will be located in the <code class="inlineCode">index.tsx</code> file in the <code class="inlineCode">pages</code> folder. For the understanding of the following examples, the path to this file, in the case of the main page, will be <code class="inlineCode">pages/index.tsx</code>.</li>
      <li class="bulletList">The <code class="inlineCode">/about</code> page will be located in the <code class="inlineCode">pages/about.tsx</code> file.</li>
      <li class="bulletList">Next, we will create a <code class="inlineCode">/posts</code> page at the path <code class="inlineCode">pages/posts/index.tsx</code>.</li>
      <li class="bulletList">Each individual post page will be located in a file using the path <code class="inlineCode">pages/posts/[post].tsx</code>. Files with names in square brackets indicate to Next.js that this will be a dynamic page, with the post variable as a parameter. This means that pages like <code class="inlineCode">/posts/1</code> and <code class="inlineCode">/posts/2</code> will use this file as the page component.</li>
      <li class="bulletList">This is how the file routing works. The main directory of the project is the <code class="inlineCode">pages</code> folder, where we can nest files that will be used to generate website pages based on the structure and names of files and folders.</li>
    </ul>
    <p class="normal">In the <code class="inlineCode">pages</code> folder, there are also two service files that are not actual pages but are used by the framework to prepare pages:</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">_document.tsx</code> file is necessary for preparing the HTML markup. In this file, we have access to the <code class="inlineCode">&lt;html&gt;</code> and <code class="inlineCode">&lt;body&gt;</code> tags. This file is always rendered on the server.</li>
      <li class="bulletList">The <code class="inlineCode">_app.tsx</code> file is used to initialize the page. You can use this component to connect scripts or for the root layout of pages that will be reused between routes.</li>
    </ul>
    <p class="normal">Let’s add a header to our website in the <code class="inlineCode">App</code> component. Here’s how the <code class="inlineCode">_app.tsx</code> file looks:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> inter = <span class="hljs-title">Inter</span>({ <span class="hljs-attr">subsets</span>: [<span class="hljs-string">"latin"</span>] });
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params">{ Component, pageProps }: AppProps</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">className</span><span class="hljs-tag">=</span><span class="hljs-string">{inter.className}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">header</span><span class="hljs-tag"> </span><span class="hljs-attr">className</span><span class="hljs-tag">=</span><span class="hljs-string">"p-4 flex items-center gap-4"</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Link</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">"/"</span><span class="hljs-tag">&gt;</span>Home<span class="hljs-tag">&lt;/</span><span class="hljs-name">Link</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Link</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">"/posts"</span><span class="hljs-tag">&gt;</span>Posts<span class="hljs-tag">&lt;/</span><span class="hljs-name">Link</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Link</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">"/about"</span><span class="hljs-tag">&gt;</span>About<span class="hljs-tag">&lt;/</span><span class="hljs-name">Link</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">header</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">className</span><span class="hljs-tag">=</span><span class="hljs-string">"p-4"</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Component</span><span class="hljs-tag"> {</span><span class="hljs-attr">...pageProps</span><span class="hljs-tag">} /&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">The <code class="inlineCode">App</code> component returns<a id="_idIndexMarker478"/> markup that will be used on every page of our project, which means we will see this header on any of our pages. Additionally, we can use the component control where the rest of the dynamic part of the project will be located.</p>
    <p class="normal">Now, let’s take a look at how the main page of our project will look:</p>
    <figure class="mediaobject"><img src="../Images/B19636_13_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.4: Home Page</p>
    <p class="normal">On this page, we can see the website header with links and the title, which was taken from the <code class="inlineCode">pages/index.tsx</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">Home</span>() {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Home Page<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">The <code class="inlineCode">pages/index.tsx</code> file exports only one component with a title inside. It’s important to note that this page doesn’t have any additional functions or parameters and will be automatically rendered during the project build process. This means that when we visit this page, we get ready-made HTML that the browser can render immediately.</p>
    <p class="normal">We can confirm that by<a id="_idIndexMarker479"/> visiting <code class="inlineCode">localhost:3000/</code>, we receive the prepared markup. To do this, we just need to open the browser’s developer tools and inspect what is returned for this request.</p>
    <figure class="mediaobject"><img src="../Images/B19636_13_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.5: Home page response in Chrome DevTools</p>
    <p class="normal">We can see how Next.js has taken content from the <code class="inlineCode">App</code> and <code class="inlineCode">Home</code> components and assembled HTML from it. All of this was done on the server side, not in the browser.</p>
    <p class="normal">Next, let’s take a look at the <code class="inlineCode">/about</code> page. On this page, we will implement SSR, which means that instead of generating HTML during the build, the page will be rendered on every request. For this purpose, Next.js provides the <code class="inlineCode">getServerSideProps</code> function, which runs at the time of the page request and returns props used by the component for rendering.</p>
    <p class="normal">For our example, I’ve taken<a id="_idIndexMarker480"/> some logic from <em class="chapterRef">Chapter 11</em>, <em class="italic">Fetching Data from a Server</em>, where we fetched user data from GitHub. Let’s see what the <code class="inlineCode">about.tsx</code> file will look like:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getServerSideProps = (<span class="hljs-title">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title">fetch</span>(<span class="hljs-string">"https://api.github.com/users/sakhnyuk"</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-attr">user</span>: <span class="hljs-title">GitHubUser</span> = <span class="hljs-keyword">await</span> res.<span class="hljs-title">json</span>();
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">props</span>: { user } };
}) satisfies <span class="hljs-title">GetServerSideProps</span>&lt;{ <span class="hljs-attr">user</span>: <span class="hljs-title">GitHubUser</span> }&gt;;
</code></pre>
    <p class="normal">In the <code class="inlineCode">getServerSideProps</code> function, we request user data <a id="_idIndexMarker481"/>using the <strong class="keyWord">Fetch API</strong>. The data we receive is stored in the <code class="inlineCode">user</code> variable, which is then returned in the <code class="inlineCode">props</code> object.</p>
    <p class="normal">It’s important to understand that this function is part of the Node.js environment, where we can use server-side APIs. This means we can read files, access databases, and more. This provides significant capabilities for implementing complex full-stack projects.</p>
    <p class="normal">Next, in the same <code class="inlineCode">about.tsx</code> file, we have the <code class="inlineCode">About</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">About</span>(<span class="hljs-params">{</span>
<span class="hljs-params">  user,</span>
<span class="hljs-params">}: InferGetServerSidePropsType&lt;</span><span class="hljs-keyword">typeof</span><span class="hljs-params"> getServerSideProps&gt;</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Image</span><span class="hljs-tag"> </span><span class="hljs-attr">src</span><span class="hljs-tag">=</span><span class="hljs-string">{user.avatar_url}</span><span class="hljs-tag"> </span><span class="hljs-attr">alt</span><span class="hljs-tag">=</span><span class="hljs-string">{user.login}</span><span class="hljs-tag"> </span><span class="hljs-attr">width</span><span class="hljs-tag">=</span><span class="hljs-string">"100"</span><span class="hljs-tag"> </span><span class="hljs-attr">height</span><span class="hljs-tag">=</span><span class="hljs-string">"</span><span class="hljs-string">100"</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>{user.name || user.login}<span class="hljs-tag">&lt;/</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>{user.bio}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Location: {user.location || "Not specified"}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Company: {user.company || "Not specified"}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Followers: {user.followers}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Following: {user.following}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Public Repos: {user.public_repos}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">In the <code class="inlineCode">About</code> component, we use the <code class="inlineCode">user</code> variable that we returned from the <code class="inlineCode">getServerSideProps</code> function to create the page’s markup. With just this one function, we’ve implemented SSR.</p>
    <p class="normal">Next, let’s <a id="_idIndexMarker482"/>create the <code class="inlineCode">/posts</code> and <code class="inlineCode">/posts/[post]</code> pages where we will implement SSG and ISR. For this, Next.js provides two functions: <code class="inlineCode">getStaticProps</code> and <code class="inlineCode">getStaticPaths</code>:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">getStaticProps</code>: This function serves a similar purpose as <code class="inlineCode">getServerSideProps</code> but is called during the project build process.</li>
      <li class="bulletList"><code class="inlineCode">getStaticPaths</code>: This is used on dynamic pages where the path contains parameters (such as <code class="inlineCode">[post].tsx</code>). This function determines which paths should be pre-generated during the build.</li>
    </ul>
    <p class="normal">Let’s take a look at how the <code class="inlineCode">Posts</code> page component is implemented:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title">getStaticProps</span>() {
  <span class="hljs-keyword">const</span> posts = [<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>];
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">props</span>: {
      posts,
    },
  };
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">Posts</span>(<span class="hljs-params">{ posts }: { posts: string[] }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Posts<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
        {posts.map((post) =&gt; (
          <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{post}</span><span class="hljs-tag">&gt;</span>
            <span class="hljs-tag">&lt;</span><span class="hljs-name">Link</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">{</span><span class="hljs-tag">`/</span><span class="hljs-attr">posts</span><span class="hljs-tag">/${</span><span class="hljs-attr">post</span><span class="hljs-tag">}`}&gt;</span>Post {post}<span class="hljs-tag">&lt;/</span><span class="hljs-name">Link</span><span class="hljs-tag">&gt;</span>
          <span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">The <code class="inlineCode">getStaticProps</code> function in this example doesn’t request any data but simply returns three pages. However, just like in <code class="inlineCode">getServerSideProps</code>, you can use <code class="inlineCode">getStaticProps</code> to fetch data or work with the filesystem. The <code class="inlineCode">Posts</code> component then receives posts as <code class="inlineCode">props</code> and uses them to display a list of links to posts.</p>
    <p class="normal">Here’s what the <strong class="screenText">Posts</strong> page will look like:</p>
    <figure class="mediaobject"><img src="../Images/B19636_13_06.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.6: Posts page</p>
    <p class="normal">When opening any<a id="_idIndexMarker483"/> post, the component from the <code class="inlineCode">[post].tsx</code> file will be loaded. Here’s how it looks:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getStaticPaths = (<span class="hljs-title">async</span> () =&gt; {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">paths</span>: [
      {
        <span class="hljs-attr">params</span>: {
          <span class="hljs-attr">post</span>: <span class="hljs-string">"1"</span>,
        },
      },
      {
        <span class="hljs-attr">params</span>: {
          <span class="hljs-attr">post</span>: <span class="hljs-string">"2"</span>,
        },
      },
      {
        <span class="hljs-attr">params</span>: {
          <span class="hljs-attr">post</span>: <span class="hljs-string">"3"</span>,
        },
      },
    ],
    <span class="hljs-attr">fallback</span>: <span class="hljs-literal">true</span>,
  };
}) satisfies <span class="hljs-title">GetStaticPaths</span>;
</code></pre>
    <p class="normal">This function<a id="_idIndexMarker484"/> informs the builder that only three pages need to be rendered during the build process. In this function, we can also make network requests. The <code class="inlineCode">"fallback"</code> parameter we<a id="_idIndexMarker485"/> returned indicates that, theoretically, there may be more post pages than the ones we returned. For example, if we access the <code class="inlineCode">/posts/4</code> <code class="inlineCode">page</code>, it will be rendered in SSR mode and saved as the build result:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">Export</span> <span class="hljs-keyword">const</span> getStaticProps = (<span class="hljs-title">async</span> (context) =&gt; {
  <span class="hljs-keyword">const</span> content = <span class="hljs-string">`This is a dynamic route example. The value of the post parameter is </span><span class="hljs-subst">${context.params?.post}</span><span class="hljs-string">.`</span>;
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">props</span>: { content }, <span class="hljs-attr">revalidate</span>: <span class="hljs-number">3600</span> };
}) satisfies <span class="hljs-title">GetStaticProps</span>&lt;{
  <span class="hljs-attr">content</span>: string;
}&gt;;
</code></pre>
    <p class="normal">In the <code class="inlineCode">getStaticProps</code> function, we can now read the page parameter from the <code class="inlineCode">context</code> argument. The value of <code class="inlineCode">revalidate</code> that we returned from the function enables ISR and tells the server to rebuild this page on the next request, after <code class="inlineCode">3600</code> from the previous build. Here’s how the <code class="inlineCode">Post</code> page will look:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">Post</span>(<span class="hljs-params">{</span>
<span class="hljs-params">  content,</span>
<span class="hljs-params">}: InferGetStaticPropsType&lt;</span><span class="hljs-keyword">typeof</span><span class="hljs-params"> getStaticProps&gt;</span>) {
  <span class="hljs-keyword">const</span> router = <span class="hljs-title">useRouter</span>();
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Post – {router.query.post}<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>{content}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
  );
} 
</code></pre>
    <p class="normal">When we open any post using the link, we will see the following:</p>
    <figure class="mediaobject"><img src="../Images/B19636_13_07.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.7: Post page</p>
    <p class="normal">In this example, we’ve <a id="_idIndexMarker486"/>created a website where pages use different server rendering approaches, which is useful and convenient for building large and complex projects. However, Next.js has more capabilities beyond this. Next, we will explore a new approach to building websites using the App Router.</p>
    <h1 id="_idParaDest-184" class="heading-1">React Server Components</h1>
    <p class="normal">React Server Components<a id="_idIndexMarker487"/> represent a new paradigm for working with components in Next.js that eliminates isomorphic JavaScript. The code of such components runs only on a server and can be cached as a result. In this concept, you can directly read the server’s filesystem or access the database from the components.</p>
    <p class="normal">In Next.js, React Server <a id="_idIndexMarker488"/>Components allow you to categorize components into two types: <strong class="keyWord">server-side</strong> and <strong class="keyWord">client-side</strong>. Server-side components are <a id="_idIndexMarker489"/>processed on a server and sent to the client as static HTML, reducing the load on the browser. Client-side components still have all the capabilities of browser JavaScript but with one requirement: you need to use the <code class="inlineCode">use client</code> directive at the beginning of the file.</p>
    <p class="normal">To use server-side components in Next.js, you will need to create a new project. For routing, you still use files, but now, the main folder for the project is the <code class="inlineCode">app</code> folder, and route names are based solely on folder names. Inside each route (folder), there should be files with names specified by the framework. Here are some of the key files:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">page.tsx</code>: This file and its component will be used to display the page.</li>
      <li class="bulletList"><code class="inlineCode">loading.tsx</code>: The component of this file will be sent to the client as a loading state while the component from the <code class="inlineCode">page.tsx</code> file is executed and loaded.</li>
      <li class="bulletList"><code class="inlineCode">layout.tsx</code>: This is equivalent to the <code class="inlineCode">_app.tsx</code> file, but in this case, we can have multiple layouts that can be nested within each other in nested routes.</li>
      <li class="bulletList"><code class="inlineCode">route.tsx</code>: This file is used to implement an API endpoint.</li>
    </ul>
    <p class="normal">Now, let’s <a id="_idIndexMarker490"/>refactor our website with posts using the new architecture based on the <strong class="keyWord">App Router</strong>. Let’s start <a id="_idIndexMarker491"/>with the home page. Since our website didn’t have any interactive elements, I suggest adding one. Let’s create the simplest button with a counter and place it on the home page. Here’s the code for such a button:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"use client"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"</span><span class="hljs-string">react"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title">Counter</span> = () =&gt; {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span> setCount(count + 1)}&gt;{count}<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>;
};
</code></pre>
    <p class="normal">This component renders a button with a counter inside. By clicking the button, we update the counter. To make this component work with App Router, we need to add the “<code class="inlineCode">use client</code>" directive, which tells Next.js to include this component’s code in the bundle and send it to the browser upon request.</p>
    <p class="normal">Now, let’s add this button to the home page, and here’s what its code will look like:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">Home</span>() {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Home Page<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Counter</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">Since the page is <a id="_idIndexMarker492"/>simple, it doesn’t differ from what we saw in the Pages Router, except for the new button. Although, by default, the App Router considers all components as server ones, in this case, the page will be rendered during the build process and saved as a static page.</p>
    <p class="normal">Now, let’s move on to the <code class="inlineCode">About</code> page. To create this page, we need to create a folder named <code class="inlineCode">about</code> and create a file inside it named <code class="inlineCode">page.tsx</code>, where we’ll place the component. Here’s the code for it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> dynamic = <span class="hljs-string">"force-dynamic"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title">About</span>() {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title">fetch</span>(<span class="hljs-string">"https://api.github.com/users/sakhnyuk"</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-attr">user</span>: <span class="hljs-title">GitHubUser</span> = <span class="hljs-keyword">await</span> res.<span class="hljs-title">json</span>();
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Image</span><span class="hljs-tag"> </span><span class="hljs-attr">src</span><span class="hljs-tag">=</span><span class="hljs-string">{user.avatar_url}</span><span class="hljs-tag"> </span><span class="hljs-attr">alt</span><span class="hljs-tag">=</span><span class="hljs-string">{user.login}</span><span class="hljs-tag"> </span><span class="hljs-attr">width</span><span class="hljs-tag">=</span><span class="hljs-string">"100"</span><span class="hljs-tag"> </span><span class="hljs-attr">height</span><span class="hljs-tag">=</span><span class="hljs-string">"100"</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>{user.name || user.login}<span class="hljs-tag">&lt;/</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>{user.bio}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Location: {user.location || "Not specified"}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Company: {user.company || "Not specified"}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Followers: {user.followers}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Following: {user.following}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Public Repos: {user.public_repos}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">As you can see, the code for this page has become simpler compared to using the Pages Router. The <code class="inlineCode">About</code> component has become asynchronous, allowing us to make a network request and wait for the result. Since, in our example, we wanted to use SSR and render the page on the server for each request, we needed to export the “dynamic” variable from the file with the <code class="inlineCode">force-dynamic</code> value. This parameter explicitly tells Next.js that we want to generate a new page for each request. Otherwise, Next.js would have generated the page during the project build and saved the result as a static page (by using SSG).</p>
    <p class="normal">However, it would be<a id="_idIndexMarker493"/> strange if the App Router simply repeated the previous functionality without offering anything new. If we create a <code class="inlineCode">loading.tsx</code> file inside the <code class="inlineCode">about</code> folder, when opening the <code class="inlineCode">About</code> page, instead of waiting for the server to request information from GitHub and prepare the page, it will instantly serve the page with content from the <code class="inlineCode">loading</code> file as a fallback. And as soon as the component from the <code class="inlineCode">page.tsx</code> file is ready, the server will send it to the client to replace the <code class="inlineCode">loading</code> component. This provides a significant performance advantage and improves the user experience.</p>
    <p class="normal">Now, let’s move on to the <code class="inlineCode">Posts</code> page. Create a <code class="inlineCode">posts</code> folder and a <code class="inlineCode">page.tsx</code> file inside it. Here’s how the updated code for the <code class="inlineCode">/posts</code> page will look:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title">Posts</span>() {
  <span class="hljs-keyword">const</span> posts = [<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>];
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Posts<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
        {posts.map((post) =&gt; (
          <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{post}</span><span class="hljs-tag">&gt;</span>
            <span class="hljs-tag">&lt;</span><span class="hljs-name">Link</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">{</span><span class="hljs-tag">`/</span><span class="hljs-attr">posts</span><span class="hljs-tag">/${</span><span class="hljs-attr">post</span><span class="hljs-tag">}`}&gt;</span>Post {post}<span class="hljs-tag">&lt;/</span><span class="hljs-name">Link</span><span class="hljs-tag">&gt;</span>
          <span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">Once again, the code has become very clean. Everything we needed to fetch before rendering the page can be obtained and created directly inside the component. In our example, we have hardcoded three pages that will be rendered as links.</p>
    <p class="normal">To implement a <code class="inlineCode">Post</code> page, inside the <code class="inlineCode">posts</code> folder, you need to create a folder with the name <code class="inlineCode">[post]</code> and create the <code class="inlineCode">page.tsx</code> file inside it. Here’s the code, which is now much cleaner and more readable:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title">generateStaticParams</span>() {
  <span class="hljs-keyword">return</span> [{ <span class="hljs-attr">post</span>: <span class="hljs-string">"1"</span> }, { <span class="hljs-attr">post</span>: <span class="hljs-string">"2"</span> }, { <span class="hljs-attr">post</span>: <span class="hljs-string">"</span><span class="hljs-string">3"</span> }];
}
</code></pre>
    <p class="normal">Instead of <a id="_idIndexMarker494"/>using <code class="inlineCode">getStaticPaths</code>, we provide Next.js with information about the list of static pages to generate during the project build using the <code class="inlineCode">generateStaticParams</code> function. Then, we use props inside the component to display the page’s content:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> revalidate = <span class="hljs-number">3600</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title">Post</span>(<span class="hljs-params">{ params }: { params: { post: string } }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Post - {params.post}<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
        This is a dynamic route example. The value of the post parameter is
        {params.post}.
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">The content remains mostly unchanged. To activate ISR, all we need to do is export the <code class="inlineCode">revalidate</code> variable from the file with the revalidation value in seconds.</p>
    <p class="normal">In this example, we covered the fundamental approaches to building an application using React Server Components and the App Router in Next.js. The Page Router and App Router examples provided in this chapter do not cover all the possibilities of Next.js. For a deeper understanding of this framework, I recommend checking out the excellent documentation on its website: <a href="https://nextjs.org/docs"><span class="url">https://nextjs.org/docs</span></a>.</p>
    <h1 id="_idParaDest-185" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we explored SSR in the context of React applications. We discussed approaches such as SSR, SSG, and ISR, learning the advantages and disadvantages of each approach.</p>
    <p class="normal">Then, we learned how to apply these approaches in an application using Next.js and the Pages Router. Finally, we introduced a new technology called React Server Components and the updated Next.js architecture called the App Router.</p>
    <p class="normal">In the next chapter, we will learn how to test our components and applications.</p>
  </div>
</body></html>