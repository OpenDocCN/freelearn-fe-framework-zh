- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Performance Optimization in Angular
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 中的性能优化
- en: 'Performance is always a concern in any product that you build for end users.
    It is a critical element in increasing the chances of someone using your app for
    the first time becoming a customer. Now, we can’t really improve an app’s performance
    until we identify potential possibilities for improvement and the methods to achieve
    this. In this chapter, you’ll learn some methods to deploy when it comes to improving
    Angular applications. You’ll learn how to analyze, optimize, and improve your
    Angular app’s performance using several techniques. Here are the recipes we’re
    going to cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 性能在您为最终用户构建的任何产品中始终是一个关注点。它是增加某人首次使用您的应用成为客户机会的关键元素。现在，我们真的无法提高应用性能，除非我们确定潜在的改进可能性以及实现这些方法。在本章中，您将学习一些在提高
    Angular 应用程序时可以部署的方法。您将学习如何使用几种技术来分析、优化和改进您的 Angular 应用性能。以下是本章将要涵盖的食谱：
- en: Using `OnPush` change detection to prune component subtrees
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `OnPush` 变更检测修剪组件子树
- en: Detaching the change detector from components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从组件中分离变更检测器
- en: Running `async` events outside Angular with `runOutsideAngular`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `runOutsideAngular` 在 Angular 外部运行 `async` 事件
- en: Using `trackBy` for lists with `*ngFor`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `trackBy` 为 `*ngFor` 列表
- en: Moving heavy computation to pure pipes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将繁重计算移动到纯管道
- en: Using web workers for heavy computation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Web Workers 进行繁重计算
- en: Using performance budgets for auditing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用性能预算进行审计
- en: Analyzing bundles with `webpack-bundle-analyzer`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `webpack-bundle-analyzer` 分析包
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter12](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter12).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的食谱，请确保您的设置已按照 'Angular-Cookbook-2E' GitHub 仓库中的 '技术要求' 完成。有关设置详细信息，请访问：[https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md)。本章的起始代码位于
    [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter12](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter12)。
- en: Using OnPush change detection to prune component subtrees
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OnPush 变更检测修剪组件子树
- en: In today’s world of modern web applications, performance is one of the key factors
    for a great **User Experience** (**UX**) and, ultimately, conversions for a business.
    In this recipe, the first recipe of this chapter, we’re going to discuss the fundamental
    or the most basic optimization you can do with your components wherever it seems
    appropriate, which is by using the `OnPush` change detection strategy. The app
    we’re working with has some performance issues, particularly with the `UserCardComponent`
    class. This is because it uses a getter function, `randomColor`, to generate a
    random color for its background. Behind the scenes, that function uses a `factorial`
    function to add more processing time. But that is just to demonstrate a component
    that can cause the UI to hang if there is some complex calculation happening,
    along with multiple change detections being triggered.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今现代网络应用的世界中，性能是优秀 **用户体验** （**UX**） 和最终企业转化率的关键因素之一。在本章的第一个食谱中，我们将讨论您可以在组件的任何适当位置进行的根本性或最基础的优化，即通过使用
    `OnPush` 变更检测策略。我们正在工作的应用有一些性能问题，特别是 `UserCardComponent` 类。这是因为它使用一个获取器函数 `randomColor`
    来为其背景生成随机颜色。在幕后，该函数使用 `factorial` 函数来增加更多处理时间。但这只是为了演示一个组件，如果发生一些复杂计算，并且触发了多个变更检测，它可能会导致
    UI 挂起。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-on-push-strategy`
    inside the cloned repository:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter12/ng-on-push-strategy`：
- en: Open the code repository in your code editor.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，您应该看到以下内容：
- en: '![](img/B18469_12_01.png)'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_12_01.png)'
- en: 'Figure 12.1: The ng-on-push-strategy app running at http://localhost:4200'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.1：运行在http://localhost:4200的ng-on-push-strategy应用程序
- en: Click the button that says **Click Me** or try to search for some user. You’ll
    see that the app is too slow and often hangs. Now that we have the project served
    on the browser, let’s see the steps of the recipe in the next section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 点击标有**点击我**的按钮或尝试搜索某个用户。你会看到应用程序运行得太慢，并且经常挂起。现在我们已经将项目在浏览器上运行，让我们看看下一节中的食谱步骤。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We’re going to add some code to monitor how many times the `randomColor` getter
    gets called. This will show the number of times the change detection in Angular
    gets triggered by default. We will also fix the issue and make it more performant
    (as much as we can) using the `OnPush` change detection strategy. Let’s get started:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一些代码来监控`randomColor`获取器被调用的次数。这将显示Angular默认情况下触发的更改检测的次数。我们还将修复这个问题，并使用`OnPush`更改检测策略使其更高效（尽可能多）。让我们开始吧：
- en: First, let’s make sure that the app is not too slow for your machine so that
    it makes your laptop/PC hang. Open the `src/app/app.config.ts` file and adjust
    the value of the `RANDOMIZATION_COUNT` token from `9` to whatever suits you best.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们确保应用程序不会因为你的机器而运行得太慢，以至于让你的笔记本电脑/PC挂起。打开`src/app/app.config.ts`文件，并将`RANDOMIZATION_COUNT`令牌的值从`9`调整为最适合你的值。
- en: Then try to search for a user named `Irineu` by entering their name in the search
    box. You’ll notice that the app still hangs and that it takes a few seconds to
    show the user. You’ll also notice that you don’t even see the typed letters in
    the search box as you type them. That is, there is a delay in rendering.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，尝试通过在搜索框中输入他们的名字来搜索名为`Irineu`的用户。你会注意到应用程序仍然挂起，并且需要几秒钟才能显示用户。你还会注意到，当你输入时，你甚至看不到搜索框中的输入字母。也就是说，渲染有延迟。
- en: Let’s add some logic to the code. We’ll check how many times Angular calls the
    `idUsingFactorial` method when the page loads.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们在代码中添加一些逻辑。我们将检查页面加载时Angular调用`idUsingFactorial`方法的次数。
- en: 'Let’s create a service that we will use to track the number of times a particular
    user card for a particular person is called. Run the following command from the
    workspace’s root folder to create a service:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个服务，我们将使用它来跟踪特定用户的特定卡片被调用的次数。从工作区根目录运行以下命令以创建服务：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Choose `@schematics/angular:service` when asked.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当被询问时，选择`@schematics/angular:service`。
- en: 'Update the content of the `src/app/services/logs.service.ts` file as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新`src/app/services/logs.service.ts`文件的内容：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, inject the `LogService` in the `src/app/component/user-card/user-card.component.ts`
    file. We will also create a getter (`log`) function to get the count for the user,
    and we will update the count whenever the `randomColor` getter is called. Update
    the mentioned file as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`src/app/component/user-card/user-card.component.ts`文件中注入`LogService`。我们还将创建一个获取器（`log`）函数来获取用户的计数，并且每当调用`randomColor`获取器时，我们将更新计数。按照以下方式更新提到的文件：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we will use the log in the template of the user card component to show
    the count. Update the `src/app/component/user-card/user-card.component.html` file
    as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用用户卡片组件模板中的日志来显示计数。按照以下方式更新`src/app/component/user-card/user-card.component.html`文件：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you look at the application now, you should see the **Color Generation Count**
    as follows:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在查看应用程序，你应该会看到以下**颜色生成计数**：
- en: '![](img/B18469_12_02.png)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_12_02.png)'
- en: 'Figure 12.2: Color Generation Count being shown on page load'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.2：页面加载时显示的颜色生成计数
- en: Now, click the **Click Me** button. Then, focus (click) the **Quick Search**
    input and then click outside. Repeat this a few times and you should see that
    the colors are regenerated even though the cards are not supposed to be re-rendered.
    *Figure 12.3* shows how it should look:![](img/B18469_12_03.png)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**点击我**按钮。然后，聚焦（点击）**快速搜索**输入框，然后点击外部。重复几次，你应该会看到即使卡片不应该重新渲染，颜色也会被重新生成。*图12.3*显示了它应该看起来是什么样子：![图片](img/B18469_12_03.png)
- en: 'Figure 12.3: Logs after interacting with the app without searching for anything'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.3：未搜索任何内容与应用程序交互后的日志
- en: Notice that if you start searching for something, you’ll get even more re-renders.
    That’s because each key up and/or key down event will trigger more re-renders.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果你开始搜索某些内容，你会得到更多的重新渲染。这是因为每个keyup和/或keydown事件都会触发更多的重新渲染。
- en: 'To fix the issue, we will use the `OnPush` strategy and see how it changes
    the behavior of the user card component with respect to Angular’s change detection
    strategy. Update the `user-card.component.ts` file as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将使用`OnPush`策略，并观察它如何改变用户卡片组件相对于Angular的变更检测策略的行为。按照以下方式更新`user-card.component.ts`文件：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, if you try clicking the **Click Me** button, focus in the search input
    and click outside, or do whatever else (apart from searching for users), you will
    see no change in the **Color Generation Count** for the cards, as shown in *Figure
    12.4*:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你尝试点击**点击我**按钮，在搜索输入框中聚焦并点击外部，或者做任何其他的事情（除了搜索用户），你将不会在卡片上的**颜色生成计数**中看到任何变化，如图*图12.4*所示：
- en: '![](img/B18469_12_04.png)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_12_04.png)'
- en: 'Figure 12.4: The OnPush strategy preventing unnecessary renders'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.4：OnPush策略防止不必要的渲染
- en: Great! By using the `OnPush` strategy, we were able to improve the overall performance
    of our `UserCardComponent`. The rest was just for fun. Now you know how to use
    this strategy, see the next section to understand how it works.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！通过使用`OnPush`策略，我们能够提高`UserCardComponent`的整体性能。其余的只是为了好玩。现在你知道如何使用这个策略了，请看下一节了解它是如何工作的。
- en: How it works…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Angular by default uses the `Default` change detection strategy—or technically,
    it is the `ChangeDetectionStrategy.Default` enum from the `@angular/core` package.
    Since Angular doesn’t know about every component we create, it uses the default
    strategy to not encounter any surprises. This means that the framework will check
    for changes in the whole component tree whenever something might have changed.
    This might include user events, timers, XHRs, promises, etc. In a complex UI with
    lots of bindings, this can lead to performance degradation, especially when most
    of these components don’t change frequently or depend only on specific inputs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular使用`Default`变更检测策略——或者技术上讲，它是来自`@angular/core`包的`ChangeDetectionStrategy.Default`枚举。由于Angular不知道我们创建的每个组件，它使用默认策略以避免任何意外。这意味着当可能发生变化时，框架将检查整个组件树中的更改。这可能包括用户事件、定时器、XHRs、promises等。在一个具有大量绑定的复杂UI中，这可能导致性能下降，尤其是在大多数这些组件不经常更改或仅依赖于特定输入的情况下。
- en: But as developers, if we know that a component will not change unless one of
    its `@Input()` variables changes, we can—and we should—use the `OnPush` change
    detection strategy for that component. Why? Because it tells Angular to not run
    change detection until an `@Input()` variable for the component changes. This
    strategy is an absolute winner for presentational components (sometimes called
    `dumb` components), which are just supposed to show data using `@Input()` variables/attributes
    and emit `@Output()` events on interactions. These presentational components usually
    do not hold any business logic such as heavy computation, using services to make
    **HTTP** calls, and so on. Therefore, it is easier for us to use the `OnPush`
    strategy in these components because they would only show different data when
    any of the `@Input()` attributes from the parent component change, that is, their
    reference should change. For example, if we had an array of users, there should
    be a completely new array now in order to run the change detection. If it is the
    same array but we have only added or removed an item, change detection with `OnPush`
    will not be triggered.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，作为开发者，如果我们知道一个组件除非其`@Input()`变量之一发生变化，否则不会改变，我们就可以——并且应该——为该组件使用`OnPush`变更检测策略。为什么？因为这个策略告诉Angular只有在组件的`@Input()`变量发生变化时才运行变更检测。这种策略对于表示组件（有时称为“哑”组件）来说是一个绝对的赢家，这些组件只是应该使用`@Input()`变量/属性显示数据，并在交互时发出`@Output()`事件。这些表示组件通常不包含任何业务逻辑，如复杂的计算、使用服务进行**HTTP**调用等。因此，我们更容易在这些组件中使用`OnPush`策略，因为它们只有在父组件的`@Input()`属性之一发生变化时才会显示不同的数据，即它们的引用应该发生变化。例如，如果我们有一个用户数组，现在应该有一个全新的数组来运行变更检测。如果它是同一个数组，但我们只是添加或删除了一个项目，使用`OnPush`的变更检测将不会被触发。
- en: Since we are now using the `OnPush` strategy on our `UserCardComponent`, it
    only triggers change detection when we replace the entire `users` array upon searching.
    This happens after the `500ms` debounce (*line 31* in the `users.component.ts`
    file), so we only do it when the user stops typing. So, essentially, before the
    optimization, the default change detection was triggering on each keypress being
    a browser event, and now, it doesn’t.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在在`UserCardComponent`上使用`OnPush`策略，它只有在搜索时替换整个`users`数组时才会触发变更检测。这发生在`500ms`的防抖之后（`users.component.ts`文件中的第31行），所以只有在用户停止输入时才执行。因此，在优化之前，默认的变更检测会在每个按键敲击（浏览器事件）时触发，而现在则不会。
- en: IMPORTANT NOTE
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As you now know, the `OnPush` strategy only triggers the Angular change detection
    mechanism when one or more of the `@Input()` bindings changes. This means that
    if we change a property within the component (`UserCardComponent`), it will not
    be reflected in the view because the change detection mechanism won’t run in this
    case, since that property isn’t an `@Input()` binding. You would have to mark
    the component as dirty so that Angular could check the component and run change
    detection. You’ll do this using the `ChangeDetectorRef` service—specifically,
    with the `markForCheck` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，`OnPush`策略仅在`@Input()`绑定中的一个或多个发生变化时触发Angular变更检测机制。这意味着如果我们更改组件（`UserCardComponent`）内的属性，它将不会在视图中反映出来，因为在这种情况下变更检测机制不会运行，因为这个属性不是`@Input()`绑定。你必须将组件标记为脏的，这样Angular才能检查组件并运行变更检测。你将使用`ChangeDetectorRef`服务来完成此操作——具体来说，使用`markForCheck`方法。
- en: See also
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular `ChangeDetectionStrategy` official documentation: [https://angular.io/api/core/ChangeDetectionStrategy](https://angular.io/api/core/ChangeDetectionStrategy)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular `ChangeDetectionStrategy`官方文档：[https://angular.io/api/core/ChangeDetectionStrategy](https://angular.io/api/core/ChangeDetectionStrategy)
- en: 'The `markForCheck` method official documentation: [https://angular.io/api/core/ChangeDetectorRef#markforcheck](https://angular.io/api/core/ChangeDetectorRef#markforcheck
    )'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`markForCheck`方法的官方文档：[https://angular.io/api/core/ChangeDetectorRef#markforcheck](https://angular.io/api/core/ChangeDetectorRef#markforcheck)'
- en: Detaching the change detector from components
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从组件中移除变更检测器
- en: In the previous recipe, we learned how to use the `OnPush` strategy in our components
    to avoid Angular change detection running unless one of the `@Input()` bindings
    has changed. There is, however, another way to tell Angular to not run change
    detection at all for a particular component and its subtree. This cuts the component
    and its subtree from the change detection cycle completely, as shown in *Figure
    12.5*, which can result in an increase in the overall performance. This is also
    handy when you want full control of when to run change detection. In this recipe,
    you’ll learn how to completely detach the change detector from an Angular component
    to gain performance improvements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的食谱中，我们学习了如何在组件中使用`OnPush`策略来避免Angular变更检测在没有`@Input()`绑定发生变化的情况下运行。然而，还有一种方法可以告诉Angular不要为特定的组件及其子树运行变更检测。这将完全从变更检测周期中移除组件及其子树，如图12.5所示，这可能会导致整体性能的提升。当你想要完全控制何时运行变更检测时，这也很有用。在本食谱中，你将学习如何完全从Angular组件中移除变更检测器以获得性能提升。
- en: '![](img/B18469_12_05.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18469_12_05.png)'
- en: 'Figure 12.5: Change detector detached from component tree'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：变更检测器从组件树中移除
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-cd-ref`
    inside the cloned repository:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的`start/apps/chapter12/ng-cd-ref`：
- en: Open the code repository in your code editor.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该看到以下内容：
- en: '![](img/B18469_12_06.png)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_12_06.png)'
- en: 'Figure 12.6: The ng-cd-ref app running at http://localhost:4200'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.6：ng-cd-ref应用在http://localhost:4200运行
- en: Click the button that says **Click Me** Or try to search for some user. You’ll
    see that the app is too slow and often hangs. Now that we have the project served
    on the browser, let’s see the steps of the recipe in the next section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 点击写着**点击我**的按钮，或者尝试搜索某个用户。你会看到应用运行得太慢，经常卡住。现在我们已经将项目在浏览器上启动，让我们看看下一节中食谱的步骤。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The app we’re working with has some performance issues, particularly with the
    `UserCardComponent` class. This is because it uses a getter function, `randomColor`,
    to generate a random color for its background. Behind the scenes, that function
    uses a `factorial` function to add more processing time. But that is just to demonstrate
    a component that can cause the UI to hang if there is some complex calculation
    happening along with multiple change detections being triggered. We’re going to
    add some code to monitor how many times the `randomColor` getter gets called.
    This will show the number of times the change detection in Angular gets triggered
    by default. We will also fix the issue and make it more performant (as much as
    we can) by detaching the change detector completely from a particular component.
    Let’s get started:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在工作的应用程序有一些性能问题，特别是与 `UserCardComponent` 类有关。这是因为它使用一个获取器函数 `randomColor`
    来为其背景生成随机颜色。在幕后，该函数使用 `factorial` 函数来增加处理时间。但这只是为了演示一个组件，如果同时发生一些复杂计算和多个变更检测被触发，它可能会导致
    UI 挂起。我们将添加一些代码来监控 `randomColor` 获取器被调用的次数。这将显示 Angular 默认触发的变更检测次数。我们还将修复问题，并使其更高效（尽可能做到），通过完全从特定组件中分离变更检测器。让我们开始吧：
- en: First, let’s make sure that the app is not too slow for your machine so that
    it makes your laptop/PC hang. Open the `src/app/app.config.ts` file and adjust
    the value of the `RANDOMIZATION_COUNT` token from `9` to whatever suits you best.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们确保应用程序对于您的机器来说不会太慢，这样它就不会使您的笔记本电脑/PC 挂起。打开 `src/app/app.config.ts` 文件，并将
    `RANDOMIZATION_COUNT` 令牌的值从 `9` 调整为您认为最合适的值。
- en: Then try to search for a user named `Irineu` by entering their name in the search
    box. You’ll notice that the app still hangs and that it takes a few seconds to
    show the user. You’ll also notice that you don’t even see the letters in the search
    box as you type them. That is, there is a delay in rendering.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，尝试通过在搜索框中输入他们的名字来搜索一个名为 `Irineu` 的用户。你会注意到应用程序仍然处于挂起状态，并且显示用户需要几秒钟。你还会注意到，当你输入字母时，甚至看不到搜索框中的字母。也就是说，渲染存在延迟。
- en: Let’s add some logic to the code. We’ll check how many times Angular calls the
    `idUsingFactorial` method when the page loads.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们在代码中添加一些逻辑。我们将检查当页面加载时，Angular 调用 `idUsingFactorial` 方法的次数。
- en: 'Let’s create a service that we will use to track the number of times a particular
    user card for a particular person is called. Run the following command from the
    workspace’s root folder to create a service:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个我们将用于跟踪特定用户的特定用户卡片被调用的次数的服务。从工作区根目录运行以下命令以创建服务：
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Choose `@schematics/angular:service` when asked.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当被询问时，请选择 `@schematics/angular:service`。
- en: 'Update the content of the `src/app/services/logs.service.ts` file as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新 `src/app/services/logs.service.ts` 文件的内容：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, inject the `LogService` in the `src/app/component/user-card/user-card.component.ts`
    file. We will also create a getter (`log`) function to get the count for the user,
    and we will update the count whenever the `randomColor` getter is called. Update
    the mentioned file as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `src/app/component/user-card/user-card.component.ts` 文件中注入 `LogService`。我们还将创建一个获取器（`log`）函数来获取用户的计数，并且每次调用
    `randomColor` 获取器时，我们将更新计数。按照以下方式更新提到的文件：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we will use the log in the template of the user card component to show
    the count. Update the `src/app/component/user-card/user-card.component.html` file
    as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用用户卡片组件的模板中的日志来显示计数。按照以下方式更新 `src/app/component/user-card/user-card.component.html`
    文件：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you look at the application now, you should see the **Color Generation Count**
    as follows:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在查看应用程序，你应该会看到以下 **颜色生成计数**：
- en: '![](img/B18469_12_07.png)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片 B18469_12_07](img/B18469_12_07.png)'
- en: 'Figure 12.7: Color Generation Count being shown on page load'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.7：页面加载时显示的颜色生成计数
- en: Now, click the **Click Me** button. Then focus (click) the **Quick Search**
    input and then click outside. Repeat this a few times and you should see that
    the colors are regenerated even though the cards are not supposed to be re-rendered.
    *Figure 12.8* shows how it should look:![](img/B18469_12_08.png)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击 **Click Me** 按钮。然后（点击）将焦点放在 **Quick Search** 输入上，然后点击外部。重复几次，你应该会看到即使卡片不应该重新渲染，颜色也会被重新生成。*图
    12.8* 显示了它应该看起来是什么样子！:![图片 B18469_12_08](img/B18469_12_08.png)
- en: 'Figure 12.8: Logs after interacting with the app without searching for anything'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.8：与应用程序交互后（未搜索任何内容）的日志
- en: Notice that if you start searching for something, you’ll get even more re-renders.
    That’s because each key up and/or key down event will trigger more re-renders.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果你开始搜索某些内容，你会得到更多的重新渲染。那是因为每个keyup和/或keydown事件都会触发更多的重新渲染。
- en: 'To fix the issue, we will detach the change detector reference from the `user-card`
    components when the component loads so there is no re-render afterward. This is
    assuming that the content of the card never changes. Update the `user-card.component.ts`
    file as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，当组件加载时，我们将从`user-card`组件中分离出更改检测器的引用，这样就不会在之后重新渲染。这是假设卡片的内容永远不会改变。按照以下方式更新`user-card.component.ts`文件：
- en: '[PRE11]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, if you try clicking the **Click Me** button, focus on the search input
    and click outside, or do whatever else (apart from searching for users), you will
    see no change in the **Color Generation Count** for the cards, as shown in *Figure
    12.9*:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你尝试点击**点击我**按钮，关注搜索输入并点击外部，或者做任何其他（除了搜索用户）的事情，你将看不到卡片上的**颜色生成计数**发生变化，如图*图12.9*所示：
- en: '![](img/B18469_12_09.png)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_12_09.png)'
- en: 'Figure 12.9: Detached change detector preventing unnecessary renders'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.9：分离的更改检测器防止不必要的渲染
- en: But what if something had to change in the components later? How do we get full
    control over the change detection?
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但如果组件后来需要更改怎么办？我们如何完全控制更改检测？
- en: 'Let’s assume that the app has a feature that changes the user’s name. We’ll
    hardcode the logic to change the last name of the first user. In this case, we
    would have to tell Angular to run the change detection. Let’s update the `users.component.html`
    file to update the **Click Me** button in the `src/app/users/users.component.html`
    file as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设应用程序有一个更改用户名字的功能。我们将硬编码逻辑来更改第一个用户的姓氏。在这种情况下，我们必须告诉Angular运行更改检测。让我们更新`users.component.html`文件，以更新`src/app/users/users.component.html`文件中的**点击我**按钮，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s update the TypeScript file to add the function that updates the user’s
    name. Update the `src/app/users/users.component.ts` file as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新TypeScript文件，添加更新用户名字的功能。按照以下方式更新`src/app/users/users.component.ts`文件：
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you click the **Update Irineu’s Name** button, you’ll see no change in the
    UI. That is because the change detector is still detached from each user card
    component. So, the name changes, but you can’t see the change on the UI. See *Figure
    12.10*, in which the Angular (Chrome) DevTools show the value being updated in
    the component, but the UI doesn’t reflect it.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你点击**更新Irineu的名字**按钮，你将看不到UI上的任何变化。那是因为更改检测器仍然与每个用户卡片组件分离。所以名字改变了，但你无法在UI上看到变化。参见*图12.10*，其中Angular
    (Chrome) DevTools显示了组件中正在更新的值，但UI没有反映出来。
- en: '![](img/B18469_12_10.png)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_12_10.png)'
- en: 'Figure 12.10: User card not re-rendering due to detached change detector'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.10：由于更改检测器分离，用户卡片未重新渲染
- en: 'To fix the issue, we will query the `UserCard` components on the users page
    and will manually run the `ChangeDetectorRef.detectChanges` method on the desired
    component. Update the `src/app/users/users.component.ts` file as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将查询用户页面上的`UserCard`组件，并将手动在所需组件上运行`ChangeDetectorRef.detectChanges`方法。按照以下方式更新`src/app/users/users.component.ts`文件：
- en: '[PRE14]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, if you click the **Update Irineu’s Name** button four times, you should
    see the count of the first user card to be `5`, while the rest of the cards still
    render `1` time, as shown in *Figure 12.11*.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你点击**更新Irineu的名字**按钮四次，你应该会看到第一个用户卡的计数为`5`，而其余的卡片仍然渲染`1`次，如图*图12.11*所示。
- en: '![](img/B18469_12_11.png)'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_12_11.png)'
- en: 'Figure 12.11: Fully controlled change detection'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.11：完全控制的更改检测
- en: Great! Within a few steps, by using the `ChangeDetectorRef` service from Angular,
    we were able to improve the overall performance of our `UserCardComponent`. Not
    only did we improve it, but we also fully controlled it from the parent component
    (`UsersComponent`) according to our use case. Now you know how to use the `ChangeDetectorRef`
    service, see the next section to understand how it works.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！通过几个步骤，我们使用Angular的`ChangeDetectorRef`服务提高了`UserCardComponent`的整体性能。我们不仅提高了性能，而且还根据我们的用例从父组件（`UsersComponent`）完全控制了它。现在你知道如何使用`ChangeDetectorRef`服务，请参见下一节了解它是如何工作的。
- en: How it works…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `ChangeDetectorRef` service provides a range of important methods to control
    change detection in Angular. In the recipe, we use the `detach` method in our
    component’s (`UserCardComponent` class’s) `ngAfterViewInit` method to detach the
    Angular change detection mechanism from the component as soon as it is rendered
    for the first time. As a result, no change detection is triggered on the `UserCardComponent`
    class. This is because Angular has a change detection tree in which each component
    is a node. When we detach a component from the change detection tree, that component
    (as a tree node) is detached, and so are its child components (or nodes). By doing
    this, we end up with absolutely no change detection happening for the `UserCardComponent`
    class. If there were any other components being used in the `UserCardComponent`,
    they would not have the change detection run for them either. As a result, when
    we click the button or focus and blur the input on the users page, nothing is
    rendered, even after we update the first user’s name as we did in the recipe.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChangeDetectorRef` 服务提供了一系列重要的方法来控制 Angular 中的变更检测。在配方中，我们使用组件的 `ngAfterViewInit`
    方法中的 `detach` 方法来在组件首次渲染后立即将 Angular 变更检测机制从组件中断开。结果，`UserCardComponent` 类上不会触发任何变更检测。这是因为
    Angular 有一个变更检测树，其中每个组件都是一个节点。当我们从变更检测树中断开一个组件时，该组件（作为一个树节点）被断开，其子组件（或节点）也是如此。通过这样做，我们最终确保
    `UserCardComponent` 类上不会发生任何变更检测。如果 `UserCardComponent` 中使用了其他组件，它们也不会为它们运行变更检测。结果，当我们点击按钮或聚焦和失去焦点在用户页面的输入上时，即使我们像配方中那样更新了第一个用户的名称，也不会有任何渲染。'
- en: Furthermore, when we need to show the changed name of the first user on the
    view, which requires the Angular change detection mechanism to be triggered, we
    use the `detectChanges` method from the `ChangeDetectorRef` instance, right after
    we’ve assigned the updated users array to the `users` property in the `UsersComponent`
    class. As a result, Angular runs the change detection mechanism, and we see the
    updated name on the first user card. This gives us the ultimate power to decide
    whether we want to detach the change detection completely, reattach it, or manually
    run it for the only cases that require change detection.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们需要在视图中显示第一个用户名称的更改时，这需要触发 Angular 的变更检测机制，我们使用来自 `ChangeDetectorRef` 实例的
    `detectChanges` 方法，在我们将更新后的用户数组分配给 `UsersComponent` 类中的 `users` 属性之后立即使用。结果，Angular
    运行变更检测机制，我们在第一个用户卡片上看到更新的名称。这赋予我们完全决定是否完全断开变更检测、重新连接它或仅对需要变更检测的特定情况手动运行它的权力。
- en: Now that you understand how the recipe works, see the next section for some
    useful links.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了配方的工作原理，请参阅下一节以获取一些有用的链接。
- en: See also
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The `ChangeDetectorRef` official documentation: [https://angular.io/api/core/ChangeDetectorRef](https://angular.io/api/core/ChangeDetectorRef
    )'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChangeDetectorRef` 官方文档：[https://angular.io/api/core/ChangeDetectorRef](https://angular.io/api/core/ChangeDetectorRef)'
- en: Running async events outside Angular with runOutsideAngular
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `runOutsideAngular` 在 Angular 外部运行异步事件
- en: 'Angular runs its change detection mechanism on a couple of things, including—but
    not limited to—all browser events, such as `keyup`, `keydown`, `click`, and so
    on. It also runs change detection on `setTimeout`, `setInterval`, and Ajax HTTP
    calls. If we had to avoid running change detection on any of these events, we’d
    have to tell Angular not to trigger change detection on them—for example, if you
    use the `setInterval` method in your Angular component, it will trigger an Angular
    change detection cycle each time its callback method is called. This can lead
    to a huge amount of change detection cycles and your app might even hang. An ideal
    situation would be to be able to still use the `setInterval` method and so on
    without triggering the change detection. In this recipe, you’ll learn how to do
    exactly that. You will learn how to execute code blocks outside of `zone.js` using
    the `NgZone` service, particularly using the `runOutsideAngular` method. See *Figure
    12.12* to understand the structure of the application:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在其几个方面运行变更检测机制，包括但不限于所有浏览器事件，如`keyup`、`keydown`、`click`等。它还在`setTimeout`、`setInterval`和Ajax
    HTTP调用上运行变更检测。如果我们必须避免在这些事件上运行变更检测，我们必须告诉Angular不要在这些事件上触发变更检测——例如，如果您在Angular组件中使用`setInterval`方法，每次其回调方法被调用时，它将触发一个Angular变更检测周期。这可能导致大量的变更检测周期，甚至可能导致您的应用挂起。理想的情况是能够继续使用`setInterval`方法等，而不触发变更检测。在这个菜谱中，您将学习如何做到这一点。您将学习如何使用`NgZone`服务在`zone.js`之外执行代码块，特别是使用`runOutsideAngular`方法。参见*图12.12*以了解应用程序的结构：
- en: '![](img/B18469_12_12.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18469_12_12.png)'
- en: 'Figure 12.12: Component hierarchy for the ng-run-outside-angular app'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：ng-run-outside-angular应用的组件层次结构
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-run-outside-angular`
    inside the cloned repository:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的`start/apps/chapter12/ng-run-outside-angular`：
- en: Open the code repository in your code editor.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE15]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，您应该看到以下内容：
- en: '![](img/B18469_12_13.png)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_12_13.png)'
- en: 'Figure 12.13: The ng-run-outside-angular app running on http://localhost:4200'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.13：在http://localhost:4200上运行的ng-run-outside-angular应用
- en: Now that we have the app running, let’s see the steps of the recipe in the next
    section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了应用，让我们在下一节中查看菜谱的步骤。
- en: How to do it…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We have an app that shows a watch. However, the change detection right now
    in the app is not optimal, and we have plenty of room for improvement. We’ll try
    to remove any unnecessary change detection using the `runOutsideAngular` method
    from `ngZone`. Let us get started:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个显示手表的应用。然而，目前应用中的变更检测并不优化，我们有很大的改进空间。我们将尝试使用`ngZone`中的`runOutsideAngular`方法移除任何不必要的变更检测。让我们开始吧：
- en: The clock values are constantly updating. Thus, we have change detection running
    for each update cycle. Open the Chrome DevTools and switch to the **Console**
    tab. Type **appLogs** and press *Enter* to see how many times the change detection
    has run for `WatchComponent` and for the components rendering hours, minutes,
    seconds, and milliseconds. It should look like this:![](img/B18469_12_14.png)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 时钟值正在不断更新。因此，我们为每个更新周期运行变更检测。打开Chrome开发者工具并切换到**控制台**标签。输入**appLogs**并按*Enter*键，以查看变更检测为`WatchComponent`以及渲染小时、分钟、秒和毫秒的组件运行了多少次。它应该看起来像这样：![](img/B18469_12_14.png)
- en: 'Figure 12.14: The appLogs object reflecting the number of change detection
    runs'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.14：反映变更检测运行次数的appLogs对象
- en: 'To measure performance, let’s reduce our observation span in terms of time.
    Let us add some code to turn off the interval timer in 4 seconds from the app’s
    start for the clock. Modify the `watch-box.component.ts` file, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了衡量性能，让我们在时间上减少我们的观察范围。让我们添加一些代码，在应用启动4秒后关闭时钟的间隔计时器。修改`watch-box.component.ts`文件，如下所示：
- en: '[PRE16]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Refresh the app and wait for 4 seconds for the clock to stop. Then, type `appLogs`
    multiple times in the **Console** tab, press *Enter*, and see the results. The
    clock stops but the animation is still running. You should see that change detection
    for the **watchComponentRender** key still increases, as follows:![](img/B18469_12_15.png)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新应用并等待4秒，直到时钟停止。然后，在**控制台**标签页中多次输入`appLogs`，按*Enter*键，查看结果。时钟停止了，但动画仍在运行。你应该会看到对**watchComponentRender**键的变更检测仍然增加，如下所示：![](img/B18469_12_15.png)
- en: 'Figure 12.15: Change detection still running for the watch component'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.15：监视组件的变更检测仍在运行
- en: 'Let’s also stop the animation inside the watch after 4 seconds. Update the
    `watch.component.ts` file, as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在4秒后也在监视内部停止动画。更新`watch.component.ts`文件，如下所示：
- en: '[PRE17]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Refresh the app and wait for the animation to stop. Have a look at the `appLogs`
    object in the Chrome DevTools. You should see that change detection stops for
    the `watch` key, as follows:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 刷新应用并等待动画停止。查看Chrome DevTools中的`appLogs`对象。你应该会看到变更检测对`watch`键停止，如下所示：
- en: '![](img/B18469_12_16.png)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_12_16.png)'
- en: 'Figure 12.16: Change detection stops after we stop the animation interval'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.16：停止动画间隔后，变更检测停止
- en: 'The desired outcome is to keep running the animation and the clock and not
    have additional change detection cycles running. For this, let’s just stop the
    watch for now. To do that, update the `watch-box.component.ts` file, as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望的结果是继续运行动画和时钟，并且没有额外的变更检测周期运行。为此，现在我们只需停止监视即可。要做到这一点，更新`watch-box.component.ts`文件，如下所示：
- en: '[PRE18]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since we have now stopped the clock, the values for `appLogs` for the `watchComponentRender`
    key are now only based on the animation for these 4 seconds. Refresh the app and
    wait for the animation to stop. Type `appLogs` in the Chrome DevTools (in the
    **Console** tab). You should now see a value between `250` and `270` for the `watchComponentRender`
    key.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们现在已经停止了时钟，`appLogs`中`watchComponentRender`键的值现在仅基于这4秒的动画。刷新应用并等待动画停止。在Chrome
    DevTools中输入`appLogs`（在**控制台**标签页）。你现在应该会看到`watchComponentRender`键的值在`250`到`270`之间。
- en: 'Let us avoid running change detection on the animation by running the interval
    outside the `ngZone` service. We will use the `runOutsideAngular` method for this.
    Update the `watch.component.ts` file, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在`ngZone`服务外部运行间隔来避免在动画上运行变更检测。我们将为此使用`runOutsideAngular`方法。更新`watch.component.ts`文件，如下所示：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Refresh the app and wait for about 5 seconds. If you check the `appLogs` object
    now, you should see a decrease in the overall number of change detection runs
    for each of the properties, as follows:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 刷新应用并等待大约5秒。如果你现在检查`appLogs`对象，你应该会看到每个属性的变更检测运行总数有所减少，如下所示：
- en: '![](img/B18469_12_17.png)'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_12_17.png)'
- en: 'Figure 12.17: The appLogs object after using runOutsideAngular() in WatchComponent'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.17：使用`runOutsideAngular()`后的`WatchComponent`中的`appLogs`对象
- en: Yay! Notice that the value for the `watch` key in the `appLogs` object has decreased
    from about `260` to `4` now. This means that our animation now does not contribute
    to change detection at all, and the `watch` component only renders 4 times in
    4 seconds.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哈哈！注意，`appLogs`对象中`watch`键的值已经从大约`260`下降到`4`。这意味着我们的动画现在根本不会对变更检测做出贡献，并且`watch`组件在4秒内只渲染4次。
- en: 'Remove the usage of `clearInterval` from the animation for the `WatchComponent`
    class. Thus, the background circle (blue circle) animation should start again.
    Modify the `watch.component.ts` file, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`WatchComponent`类的动画中移除`clearInterval`的使用。因此，背景圆圈（蓝色圆圈）动画应该再次开始。修改`watch.component.ts`文件，如下所示：
- en: '[PRE20]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, remove the usage of `clearInterval` from the `WatchBoxComponent` class
    and uncomment `setInterval` to run the clock. Update the `watch-box.component.ts`
    file, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从`WatchBoxComponent`类中移除`clearInterval`的使用，并取消注释`setInterval`以运行时钟。更新`watch-box.component.ts`文件，如下所示：
- en: '[PRE21]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Refresh the app and check the value of the `appLogs` object after a few seconds,
    multiple times. You should see something like this:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 刷新应用并在几秒钟后多次检查`appLogs`对象的价值。你应该会看到类似以下的内容：
- en: '![](img/B18469_12_18.png)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_12_18.png)'
- en: 'Figure 12.18: The appLogs object after performance optimization with runOutsideAngular()'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.18：使用`runOutsideAngular()`进行性能优化后的`appLogs`对象
- en: Looking at the preceding screenshot, you might ask, “*Ahsan! What is this? We
    still have an enormous number for the change detection runs for the* `watchComponentRender`
    *key compared to the milliseconds passed. How is this performant exactly?*” Glad
    you asked! I will tell you why in the *How it works…* section.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 观察前面的截图，你可能会问，“*Ahsan！这是什么？与经过的毫秒数相比，`watchComponentRender` 键的变化检测运行次数仍然非常巨大。这到底是如何提高性能的呢？*”
    很高兴你问了！我将在 *它是如何工作的…* 部分告诉你原因。
- en: 'As a last step, stop the Angular server and run the following command to start
    the server in production mode:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，停止 Angular 服务器并运行以下命令以在生产模式下启动服务器：
- en: '[PRE22]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Navigate to `https://localhost:4200` again. Wait for a few seconds and then
    check the `appLogs` object in the **Console** tab multiple times. You should see
    the object, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次导航到 `https://localhost:4200`。等待几秒钟，然后在 **控制台** 选项卡中多次检查 `appLogs` 对象。你应该会看到如下对象：
- en: '![](img/B18469_12_19.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18469_12_19.png)'
- en: 'Figure 12.19: The appLogs object using the production build'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19：使用生产构建的 appLogs 对象
- en: Boom! If you look at the preceding screenshot, you should see that the change
    detection run count for the `watchComponentRender` key is always just a few cycles
    more than the `milliseconds` key. This means that the `WatchComponent` class is
    (almost) only re-rendered whenever we have the value of the `@Input()` `milliseconds`
    binding updated. But why a few cycles more? See the next section to understand
    how it works!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 嘣！如果你看前面的截图，你应该会看到 `watchComponentRender` 键的变化检测运行次数总是比 `milliseconds` 键多几个周期。这意味着
    `WatchComponent` 类只有在 `@Input()` 的 `milliseconds` 绑定值更新时才会（几乎）重新渲染。但为什么多几个周期呢？请看下一节了解它是如何工作的！
- en: How it works…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we begin by looking at the `appLogs` object, which contains
    some key-value pairs. The value for each key-value pair represents the number
    of times Angular ran change detection for a particular component. The `hours`,
    `milliseconds`, `minutes`, and `seconds` keys represent the `WatchTimeComponent`
    instance for each of the values shown on the clock. The `watchComponentRender`
    key represents the `WatchComponent` instance’s change detection cycles.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先查看包含一些键值对的 `appLogs` 对象。每个键值对的值表示 Angular 为特定组件运行变化检测的次数。`hours`、`milliseconds`、`minutes`
    和 `seconds` 键代表时钟上显示的每个值的 `WatchTimeComponent` 实例。`watchComponentRender` 键代表 `WatchComponent`
    实例的变化检测周期。
- en: 'At the beginning of the recipe, we see that the value of the `watch` key is
    more than twice the value of the `milliseconds` key. Why do we care about the
    `milliseconds` key at all? Because the `@Input()` attribute binding `milliseconds`
    changes most frequently in our application—that is, it changes every 1 **Millisecond**
    (**ms**). The second most frequently changed values are the `xCoordinate` and
    `yCoordinate` properties within the `WatchComponent` class, which change every
    30 ms. The `xCoordinate` and `yCoordinate` values are not bound directly to the
    template (the HTML) because they change the **CSS** variables of the `stopWatch`
    view child. This happens inside the `animate` method, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜谱的开始部分，我们看到 `watch` 键的值是 `milliseconds` 键值的两倍多。我们为什么要在乎 `milliseconds` 键呢？因为我们的应用程序中
    `@Input()` 属性绑定 `milliseconds` 的变化最为频繁——也就是说，它每 1 **毫秒**（**ms**）就会变化一次。其次是 `WatchComponent`
    类中的 `xCoordinate` 和 `yCoordinate` 属性，它们每 30 毫秒变化一次。`xCoordinate` 和 `yCoordinate`
    值并没有直接绑定到模板（HTML）上，因为它们会改变 `stopWatch` 视图子组件的 **CSS** 变量。这发生在 `animate` 方法内部，如下所示：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Thus, changing these values should not trigger change detection. We begin by
    limiting the testing time to run the clock, using the `clearInterval` method in
    the `WatchBoxComponent` class so that the clock stops within 4 seconds, and we
    can evaluate the numbers. In *Figure 12.15*, we see that even after the clock
    stops, the change detection mechanism keeps triggering for the `WatchComponent`
    class. This increases the count for the `watch` key in the `appLogs` object as
    time passes. We then stop the animation by using `clearInterval` in the `WatchComponent`
    class. This stops the background (blue circle) animation after 4 seconds as well.
    In *Figure 12.16*, we see that the count for the `watch` key stops increasing
    after the animation stops.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更改这些值不应触发变更检测。我们首先通过将测试时间限制在运行时钟，使用`WatchBoxComponent`类中的`clearInterval`方法来停止时钟，使其在4秒内停止，以便我们可以评估这些数值。在*图12.15*中，我们看到即使时钟停止后，变更检测机制仍然会为`WatchComponent`类触发。随着时间的推移，这会增加`appLogs`对象中`watch`键的计数。然后我们通过在`WatchComponent`类中使用`clearInterval`来停止动画。这也使得背景（蓝色圆形）动画在4秒后停止。在*图12.16*中，我们看到动画停止后，`watch`键的计数不再增加。
- en: We then try to see the count of change detection only based on the animation.
    In *step 6*, we stop the clock. Therefore, we only get a count based on the animation
    in the `appLogs` object for the `watch` key, which is a value between `250` and
    `270`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们尝试仅基于动画来查看变更检测的计数。在*步骤6*中，我们停止了时钟。因此，我们只得到了`appLogs`对象中`watch`键基于动画的计数，这个值在`250`和`270`之间。
- en: We then introduce the magic `runOutsideAngular` method into our code. This method
    is part of the `NgZone` service. The `NgZone` service is packaged with the `@angular/core`
    package. The `runOutsideAngular` method accepts a method as a parameter. This
    method is executed outside the Angular zone. This means that the `setTimeout`
    and `setInterval` methods used inside the `runOutsideAngular` method do not trigger
    the Angular change detection cycle. But technically, why are we running this `setInterval`
    outside the zone? Because our interval calls the `animate` method, which updates
    the CSS variables `--x` and `--y`. And since they automatically trigger the animation
    and no other property of the `WatchComponent` class must be shown in the UI (requiring
    a re-render), we can move this code to the `runOutsideAngular` method. You can
    see in *Figure 12.17* that the count drops to `4` after using the `runOutsideAngular`
    method.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将神奇的`runOutsideAngular`方法引入到我们的代码中。这个方法是`NgZone`服务的一部分。`NgZone`服务包含在`@angular/core`包中。`runOutsideAngular`方法接受一个方法作为参数。这个方法在Angular区域外执行。这意味着在`runOutsideAngular`方法内部使用的`setTimeout`和`setInterval`方法不会触发Angular变更检测周期。但技术上，我们为什么在区域外运行这个`setInterval`呢？因为我们的间隔调用`animate`方法，它更新CSS变量`--x`和`--y`。由于它们会自动触发动画，并且`WatchComponent`类的其他属性不需要在UI中显示（需要重新渲染），我们可以将此代码移动到`runOutsideAngular`方法中。您可以在*图12.17*中看到，使用`runOutsideAngular`方法后，计数降至`4`。
- en: We then remove the `clearInterval` usage from both the `WatchBoxComponent` and
    the `WatchComponent` classes—that is, to run the clock and the background (blue
    circle) animation again, as we did in the beginning. In *Figure 12.18*, we see
    that the count for the `watch` key is around twice the value of the `milliseconds`
    key. Now, why exactly is it that it’s around double? This is because, in development
    mode, Angular runs the change detection mechanism *twice* to ensure there are
    no *side effects*. For example, an update to a `state` property initiating a change
    detection in another (child) component, and so on. Therefore, in *step 9* and
    *step 10*, we run the application in production mode, and in *Figure 12.19*, we
    see that the value for the `watch` key is just a few cycles greater than the value
    for the `milliseconds` key, which means that the animation does not trigger any
    change detection for our application anymore.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从`WatchBoxComponent`和`WatchComponent`类中移除了`clearInterval`的使用——也就是说，再次运行时钟和背景（蓝色圆形）动画，就像我们一开始做的那样。在*图12.18*中，我们看到`watch`键的计数大约是`milliseconds`键的两倍。那么，为什么它大约是两倍呢？这是因为，在开发模式下，Angular运行变更检测机制*两次*以确保没有*副作用*。例如，一个`state`属性的更新可能在一个（子）组件中引发变更检测，等等。因此，在*步骤9*和*步骤10*中，我们在生产模式下运行应用程序，在*图12.19*中，我们看到`watch`键的值仅比`milliseconds`键的值多几个周期，这意味着动画不再触发我们应用程序的任何变更检测。
- en: But why does the `watchComponentRender` key have a few more cycles compared
    to the `milliseconds` key? That is because the `WatchComponent` is the parent
    component of the component displaying milliseconds (`WatchTimeComponent`). There
    could be a few change detection cycles based on browser interactions, but if you
    refresh the app and have no interaction at all with the app, the difference between
    `watchComponentRender` to the milliseconds count would be as low as one change
    detection cycle in production mode.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么`watchComponentRender`键与`milliseconds`键相比有更多的周期？这是因为`WatchComponent`是显示毫秒的组件（`WatchTimeComponent`）的父组件。可能会有一些基于浏览器交互的变更检测周期，但如果你在刷新应用且与应用没有任何交互时，`watchComponentRender`与毫秒计数之间的差异在生产模式下可能低至一个变更检测周期。
- en: Brilliant, isn’t it? If you find this recipe useful, do let me know on my socials.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，不是吗？如果你觉得这个食谱很有用，请通过我的社交媒体告诉我。
- en: Now that you understand how it works, see the next section for further reading.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了它是如何工作的，请查看下一节以获取更多阅读材料。
- en: See also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The `NgZone` official documentation: [https://angular.io/api/core/NgZone](https://angular.io/api/core/NgZone)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgZone`官方文档：[https://angular.io/api/core/NgZone](https://angular.io/api/core/NgZone)'
- en: 'Angular `ChangeDetectorRef` official documentation: [https://angular.io/api/core/ChangeDetectorRef](https://angular.io/api/core/ChangeDetectorRef)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular `ChangeDetectorRef`官方文档：[https://angular.io/api/core/ChangeDetectorRef](https://angular.io/api/core/ChangeDetectorRef)
- en: Using trackBy for lists with *ngFor
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`trackBy`为`*ngFor`列表
- en: Lists are an essential part of most of the apps we build today. If you’re building
    an Angular app, there’s a great chance you will use the `*ngFor` directive at
    some point for rendering lists. The `*ngFor` directive allows us to loop over
    arrays or objects generating HTML for each item. However, if we are rendering
    large lists, using `*ngFor` without caution may cause performance issues, especially
    when the source for `*ngFor` is changed completely (the entire array is replaced).
    In this recipe, we’ll learn how we can improve the performance of lists using
    the `*ngFor` directive with the `trackBy` function. Let’s get started.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是我们今天构建的大多数应用的一个基本部分。如果你正在构建一个Angular应用，有很大可能性你会在某个时候使用`*ngFor`指令来渲染列表。`*ngFor`指令允许我们遍历数组或对象，为每个项目生成HTML。然而，如果我们正在渲染大型列表，不谨慎地使用`*ngFor`可能会导致性能问题，尤其是在`*ngFor`的源被完全更改（整个数组被替换）时。在这个示例中，我们将学习如何使用带有`trackBy`函数的`*ngFor`指令来提高列表的性能。让我们开始吧。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-for-trackby`
    inside the cloned repository:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的`start/apps/chapter12/ng-for-trackby`：
- en: Open the code repository in your code editor.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以运行项目：
- en: '[PRE24]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该看到以下内容：
- en: '![](img/B18469_12_20.png)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_12_20.png)'
- en: 'Figure 12.20: The ng-for-trackby app running on http://localhost:4200'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.20：ng-for-trackby应用在http://localhost:4200上运行
- en: Now that we have the app running, let’s see the steps of the recipe in the next
    section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了应用，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We have an app that has a list of 10,000 users displayed on the view. Since
    we’re not using a virtual scroll (from `@angular/material`, for example), and
    are using a standard `*ngFor` list, we do face some performance issues now. Notice
    that when you refresh the app, even after the loader is hidden, you see a blank
    white box for about 2–3 seconds before the list appears. If your machine is stuck
    for too long, you can modify the value of the `USERS_LIMIT` variable in the `data.service.ts`
    file. Let us start the recipe to reproduce the performance issues, and we will
    fix them afterward:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个应用，在视图中显示了10,000个用户的列表。由于我们没有使用虚拟滚动（例如来自`@angular/material`），而是使用标准的`*ngFor`列表，所以我们现在确实面临一些性能问题。请注意，当你刷新应用时，即使在加载器隐藏后，你也会在列表出现前看到大约2-3秒的空白白色框。如果你的机器卡住了很长时间，你可以在`data.service.ts`文件中修改`USERS_LIMIT`变量的值。让我们开始重现性能问题的步骤，之后我们将修复这些问题：
- en: First, open the Chrome DevTools and look at the **Console** tab. You should
    see the **User card created** message logged 10,000 times. This message will be
    logged any time a user card component (instance of the `UserCardComponent` class)
    is created/initiated.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 Chrome 开发者工具并查看 **控制台** 选项卡。你应该会看到“**用户卡片创建**”消息记录了10,000次。每次创建/初始化用户卡片组件（`UserCardComponent`类的实例）时，都会记录此消息。
- en: Now, delete the first item by using the *delete* button on the card. You should
    see the same message (**User card created**) logged again 9,999 times now, as
    shown in the following screenshot. This means we recreate the `list-item` component
    for the remaining 9,999 items:![](img/B18469_12_21.png)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过卡片上的*删除*按钮删除第一个项目。现在你应该会看到相同的消息（**用户卡片创建**）再次记录了9,999次，如以下截图所示。这意味着我们为剩余的9,999个项目重新创建了`list-item`组件！![图片
    B18469_12_21](img/B18469_12_21.png)
- en: 'Figure 12.21: Logs shown again after deleting an item'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.21：删除项目后再次显示的日志
- en: Now, click the first item (this updates the first item according to the existing
    code). You should again see the **User card created** logs, as shown in *Figure
    12.22*. This means we recreate all the 9,999 list items when updating any item
    from the list. You will notice that the update to the first item’s name in the
    **User Interface** (**UI**) is reflected in about 2–3 seconds:![](img/B18469_12_22.png)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击第一个项目（这会根据现有代码更新第一个项目）。你应该再次看到**用户卡片创建**日志，如*图12.22*所示。这意味着我们在更新列表中的任何项目时都会重新创建所有9,999个列表项。你会注意到**用户界面**（**UI**）中第一个项目的名称更新大约在2-3秒内反映出来：![图片
    B18469_12_22](img/B18469_12_22.png)
- en: 'Figure 12.22: Logs shown again after updating an item'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.22：更新项目后再次显示的日志
- en: 'Now, let’s fix the performance issue by using the `trackBy` function. Open
    the `users-list.component.ts` file and update it, as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用`trackBy`函数来修复性能问题。打开`users-list.component.ts`文件并按照以下方式更新它：
- en: '[PRE25]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, update the `users-list.component.html` file to use the `trackByFn` method
    we just created, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`users-list.component.html`文件以使用我们刚刚创建的`trackByFn`方法，如下所示：
- en: '[PRE26]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, refresh the app, delete the first item, and then click the (new) first
    list item to update it. You will notice that the item is updated immediately,
    and we do not log the **User card created** message again anymore, as shown in
    *Figure 12.23*:![](img/B18469_12_23.png)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，刷新应用程序，删除第一个项目，然后点击（新的）第一个列表项来更新它。你会注意到项目立即更新，并且不再记录**用户卡片创建**消息，如*图12.23*所示：![图片
    B18469_12_23](img/B18469_12_23.png)
- en: 'Figure 12.23: No further logs after updating an item using the trackBy function'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.23：使用trackBy函数更新项目后不再有进一步的日志记录
- en: Great! You now know how to use the `trackBy` function with the `*ngFor` directive
    to optimize the performance of lists in Angular. To understand all the magic behind
    the recipe, see the next section.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你现在知道如何使用`trackBy`函数与`*ngFor`指令来优化Angular中列表的性能。要了解食谱背后的所有魔法，请参阅下一节。
- en: How it works…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `*ngFor` directive allows us to loop over **iterables** and render multiple
    HTML elements or components. When working with an array of primitives (Boolean,
    string, or number values), Angular tracks each item by its value to identify elements.
    However, when dealing with objects, Angular tracks them by memory location, like
    how JavaScript handles object equality checks. This means that if you just change
    a property in an object of the array, it will not re-render the template for that
    object. However, if you provide a new object in its place (different reference
    in memory), the content for the item will be re-rendered. This is what we do in
    this recipe to reproduce the performance issue. Since we replace the entire array
    when we update or delete an item, Angular treats the array as a new resource to
    iterate over. In the `data.service.ts` file, we have the following code for the
    `updateUser` method inside the service named `DataService`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`*ngFor`指令允许我们遍历**可迭代对象**并渲染多个HTML元素或组件。当处理原始数组（布尔值、字符串或数字值）时，Angular通过其值跟踪每个项目以识别元素。然而，当处理对象时，Angular通过内存位置跟踪它们，就像JavaScript处理对象相等性检查一样。这意味着如果你只是更改数组中对象的属性，它不会重新渲染该对象的模板。但是，如果你提供一个新对象来替换它（内存中的不同引用），则将重新渲染该项的内容。这就是我们在本食谱中重现性能问题的方法。由于我们在更新或删除项目时替换整个数组，Angular将数组视为一个新资源来迭代。在`data.service.ts`文件中，我们在名为`DataService`的服务中为`updateUser`方法有以下代码：'
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice that we use the object spread operator ( `{ … }` ) to return a new object
    for each item in the array. This ends up telling the `*ngFor` directive to re-render
    the UI for each item in the `listItems` array in the `UserListComponent` class.
    Suppose you are already rendering 1,000 users. If you search for a term that returns
    100 users from the server, ideally, Angular should not re-render those 100 users
    as they were already rendered in the view. Angular, however, would re-render the
    UI for all the list items because of the following potential reasons (but not
    limited to these):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用对象展开运算符（`{ … }`）为数组中的每个项目返回一个新的对象。这最终告诉`*ngFor`指令重新渲染`UserListComponent`类中`listItems`数组中的每个项目的UI。假设你已经渲染了1,000个用户。如果你搜索一个返回100个用户的术语，理想情况下，Angular不应该重新渲染这100个用户，因为它们已经在视图中渲染过了。然而，Angular会重新渲染所有列表项的UI，原因如下（但不仅限于这些）：
- en: The sorting/placement of the users could have changed.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的排序/放置可能已更改。
- en: The length of the users could have changed.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的长度可能已更改。
- en: Now, we want to avoid using the object reference as the unique identifier for
    each list item. For our use case, we know that each user’s ID is unique; therefore,
    we use the `trackBy` function to tell Angular to use the user’s ID as the unique
    identifier. Now, even if we return a new object for each user after a user update
    from the `updateUser` method (as previously shown), Angular does not re-render
    all the list items. This is because the new objects (users) have the same ID and
    Angular uses it to track them. Pretty cool, right?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要避免使用对象引用作为每个列表项的唯一标识符。对于我们的用例，我们知道每个用户的ID是唯一的；因此，我们使用`trackBy`函数告诉Angular使用用户的ID作为唯一标识符。现在，即使我们在`updateUser`方法（如前所述）更新用户后为每个用户返回一个新的对象，Angular也不会重新渲染所有列表项。这是因为新的对象（用户）具有相同的ID，Angular使用它来跟踪它们。很酷，对吧？
- en: Now that you have learned how the recipe works, see the next section to view
    a link for further reading.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了食谱的工作原理，请查看下一节以查看进一步阅读的链接。
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'The `NgForOf` official documentation: [https://angular.io/api/common/NgForOf](https://angular.io/api/common/NgForOf)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgForOf`官方文档：[https://angular.io/api/common/NgForOf](https://angular.io/api/common/NgForOf)'
- en: Moving heavy computation to pure pipes
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将重计算移动到纯管道
- en: In Angular, we have a particular way of writing components. Since Angular is
    heavily opinionated, we already have a lot of guidelines from the community and
    the Angular team on what to consider when writing components—for example, making
    HTTP calls directly from a component is considered a *not-so-good* practice. Similarly,
    if we have heavy computation in a component that triggers with each change detection
    cycle, this is also not considered a good practice. Imagine that the view depends
    upon a transformed version of the data using a computation constantly. This would
    cause a lot of computation and processing for each render cycle. One good technique
    can be to move the heavy computation using Angular (pure) pipes (especially if
    the computation happens with each change detection cycle).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们有一种特定的编写组件的方式。由于Angular具有强烈的意见导向，我们已经有来自社区和Angular团队的大量指南，关于编写组件时需要考虑的事项——例如，直接从组件中发起HTTP调用被认为是一种**不太好的**做法。同样，如果组件中有重计算且每次变更检测周期都会触发，这也不被认为是一种好的做法。想象一下，视图依赖于使用不断计算的数据的转换版本。这将在每个渲染周期中引起大量的计算和处理。一个很好的技术是将重计算移动到Angular（纯）管道中（特别是如果计算发生在每次变更检测周期时）。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-pipes-perf`
    inside the cloned repository:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的`start/apps/chapter12/ng-pipes-perf`：
- en: Open the code repository in your code editor.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE28]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该会看到以下内容：
- en: '![](img/B18469_12_24.png)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_12_24.png)'
- en: 'Figure 12.24: The ng-pipes-perf app running at http://localhost:4200'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.24：ng-pipes-perf应用在http://localhost:4200运行
- en: Click the button that says **Click Me** Or try to search for some user. You’ll
    see that the app is too slow and gets hung often. Now that we have the project
    served on the browser, let’s see the steps of the recipe in the next section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 点击标有**点击我**的按钮，或者尝试搜索一些用户。你会看到应用太慢，经常卡住。现在，我们已经将项目在浏览器上启动，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The app we’re working with has some performance issues, particularly with the
    `UserCardComponent` class. This is because it uses a getter function, `randomColor`,
    to generate a random color for its background. Behind the scenes, that function
    uses a `factorial` function to add more processing time. But that is just to demonstrate
    a component that can cause the UI to hang if there is some complex calculation
    happening along with multiple change detections being triggered. We’re going to
    add some code to monitor how many times the `randomColor` getter gets called.
    This will show the number of times the change detection in Angular gets triggered
    by default. We will also fix the issue and make it more performant (as much as
    we can) by detaching the change detector completely from a particular component.
    Let’s get started:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在工作的应用程序有一些性能问题，特别是与`UserCardComponent`类有关。这是因为它使用一个getter函数`randomColor`为其背景生成随机颜色。在幕后，该函数使用`factorial`函数来增加处理时间。但这只是为了演示一个组件，如果同时发生一些复杂计算和多个变更检测被触发，它可能会导致UI卡住。我们将添加一些代码来监控`randomColor`
    getter被调用的次数。这将显示Angular默认触发的变更检测次数。我们还将通过完全从特定组件中分离变更检测来修复问题，并使其更高效（尽可能多）。让我们开始吧：
- en: First, let’s make sure that the app is just slow enough for your machine that
    it makes your laptop/PC hang. Open the `src/app/app.config.ts` file and adjust
    the value of the `RANDOMIZATION_COUNT` token from `9` to whatever suits you best.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们确保应用程序对您的机器来说足够慢，以至于它使您的笔记本电脑/PC卡住。打开`src/app/app.config.ts`文件，并将`RANDOMIZATION_COUNT`令牌的值从`9`调整为最适合您的值。
- en: Then, try to search for a user named `Irineu` by entering their name in the
    search box. You’ll notice that the app still hangs and that it takes a few seconds
    to show the user. You’ll also notice that you don’t even see the letters in the
    search box as you type them. That is, there is a delay in rendering.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，尝试通过在搜索框中输入他们的名字来搜索名为`Irineu`的用户。你会注意到应用程序仍然卡住，并且显示用户需要几秒钟。你还会注意到，当你输入字母时甚至看不到搜索框中的字母。也就是说，渲染存在延迟。
- en: Let’s add some logic to the code. We’ll check how many times Angular calls the
    `idUsingFactorial` method when the page loads.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们在代码中添加一些逻辑。我们将检查Angular在页面加载时调用`idUsingFactorial`方法的次数。
- en: 'Let’s create a service that we will use to track the number of times a particular
    user card for a particular person is called. Run the following command from the
    workspace’s root folder to create a service:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个服务，我们将使用它来跟踪特定用户的特定用户卡片被调用的次数。从工作区的根目录运行以下命令来创建一个服务：
- en: '[PRE29]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Choose `@schematics/angular:service` when asked.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当被询问时，请选择`@schematics/angular:service`。
- en: 'Update the content of the `src/app/services/logs.service.ts` file as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新`src/app/services/logs.service.ts`文件的内容：
- en: '[PRE30]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, inject the `LogService` in the `src/app/component/user-card/user-card.component.ts`
    file. We will also create a getter (`log`) function to get the count for the user,
    and we will update the count whenever the `randomColor` getter is called. Update
    the mentioned file as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`src/app/component/user-card/user-card.component.ts`文件中注入`LogService`。我们还将创建一个getter（`log`）函数来获取用户的计数，并且每当`randomColor`
    getter被调用时，我们将更新计数。按照以下方式更新提到的文件：
- en: '[PRE31]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we will use the log in the template of the user card component to show
    the count. Update the `src/app/component/user-card/user-card.component.html` file
    as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用用户卡片组件的模板中的日志来显示计数。按照以下方式更新`src/app/component/user-card/user-card.component.html`文件：
- en: '[PRE32]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you look at the application now, you should see the **Color Generation Count**
    as follows:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在查看应用程序，你应该会看到以下**颜色生成计数**：
- en: '![](img/B18469_12_25.png)'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图12.25](img/B18469_12_25.png)'
- en: 'Figure 12.25: Color Generation Count being shown on page load'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.25：页面加载时显示的颜色生成计数
- en: Now, click the **Update Irineu’s Name** button. Then focus (click) the **Quick
    Search** input and then click outside. Repeat this a few times and you should
    see that the colors are regenerated, even though the cards are not supposed to
    be re-rendered. *Figure 12.26* shows how it should look:![](img/B18469_12_26.png)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**更新Irineu的名字**按钮。然后（点击）聚焦于**快速搜索**输入框，然后点击外部。重复几次，你应该会看到颜色被重新生成，尽管卡片不应该被重新渲染。*图12.26*显示了它应该看起来是什么样子！![图12.26](img/B18469_12_26.png)
- en: 'Figure 12.26: Logs after interacting with the app without searching for anything'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.26：与应用程序交互后未搜索任何内容的日志
- en: Notice that if you start searching for something, you’ll get even more re-renders.
    That’s because each key up and/or key down event will trigger more re-renders.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果你开始搜索某些内容，你会得到更多的重新渲染。这是因为每个keyup和/或keydown事件都会触发更多的重新渲染。
- en: 'To fix the issue, we will create an Angular pipe. We’ll move the computation
    to generate the random colors for this user card to this Angular pipe. In the
    project root, run the following command in the terminal:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将创建一个Angular管道。我们将把生成随机颜色的计算移动到这个Angular管道中。在项目根目录中，在终端中运行以下命令：
- en: '[PRE33]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Use the `@schematics/angular:pipe` schematic when asked.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当被要求时，使用`@schematics/angular:pipe`脚图。
- en: 'Now, move the `randomColor` getter function and the `factorial` function from
    the `user-card.component.ts` file to the Angular pipe’s file, `pipes/random-color.pipe.ts`,
    as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`randomColor`获取器函数和`factorial`函数从`user-card.component.ts`文件移动到Angular管道的文件`pipes/random-color.pipe.ts`中，如下所示：
- en: '[PRE34]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Make sure to delete those functions (the `randomColor` getter and `factorial`)
    from the `src/app/component/user-card/user-card.component.ts` file. Remove any
    unused imports as well.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保从`src/app/component/user-card/user-card.component.ts`文件中删除那些函数（`randomColor`获取器和`factorial`）。同时删除任何未使用的导入。
- en: 'Now, add the `randomColor` pipe to the user card component in the `user-card.component.ts`
    file as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`randomColor`管道添加到`user-card.component.ts`文件中的用户卡片组件中，如下所示：
- en: '[PRE35]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, update the `user-card.component.html` file to use the `randomColor` pipe
    instead of the getter we were using before. The code should look like this:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`user-card.component.html`文件以使用`randomColor`管道代替我们之前使用的获取器。代码应该看起来像这样：
- en: '[PRE36]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, refresh the app and repeat *step 7*. You will see that the color is only
    generated for the first card and the other cards do not re-render, as shown in
    *Figure 12.27*:![](img/B18469_12_27.png)
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，刷新应用并重复*步骤7*。你会看到颜色只为第一张卡片生成，其他卡片不会重新渲染，如图*12.27*所示：![](img/B18469_12_27.png)
- en: 'Figure 12.27: Colors regenerating only for the first card'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.27：只有第一张卡片重新生成颜色
- en: Boom! Now that you know how to optimize performance by moving heavy computation
    to pure Angular pipes, see the next section to understand how this works.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 嘣！现在你知道了如何通过将重计算移动到纯Angular管道来优化性能，请看下一节了解它是如何工作的。
- en: How it works…
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As we know, Angular by default runs change detection on each browser event triggered
    in the app. And since we’re using a `randomColor` getter in the component template
    (UI), this function runs each time Angular runs the change detection cycle. This
    causes more computation and performance issues. This would also hold true if we
    used a function call instead of a getter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Angular默认在应用中每个由浏览器事件触发的变化检测上运行。由于我们在组件模板（UI）中使用了一个`randomColor`获取器，这个函数每次Angular运行变化检测周期时都会运行。这会导致更多的计算和性能问题。如果我们使用函数调用而不是获取器，这也会成立。
- en: We can take a step back from the initial implementation and think about what
    the `randomColor` getter does. It works with a `for` loop based on the factorial
    of the `randomizationCount` property. This is just to add a lot of processing
    time for this example, but you can imagine any heavy computation involved in the
    change detection cycle causing the performance issue. And in these cases, we either
    use pure functions or perhaps memoization.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以退一步，从最初的实现中思考一下`randomColor`获取器的作用。它是基于`randomizationCount`属性的阶乘使用`for`循环工作的。这只是为了给这个例子增加很多处理时间，但你可以想象任何在变化检测周期中涉及的重计算都会导致性能问题。在这些情况下，我们可能会使用纯函数或者可能使用记忆化。
- en: A pure function is a function that always returns the same output, given the
    same input. Memoization is a technique in which, if the inputs are not changed
    (that is, the function is called with the same inputs as the previous time), a
    cached output is returned, and the heavy computation is skipped. Luckily, Angular
    pure pipes are pure functions and memorized, as they are only called when the
    inputs change. If that’s not the case, the pipe’s transform function will not
    be called, and the component won’t be re-rendered.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是一个函数，给定相同的输入，总是返回相同的输出。记忆化是一种技术，其中，如果输入没有改变（即，函数使用与上次相同的输入调用），则返回缓存的输出，并跳过重计算。幸运的是，Angular纯管道是纯函数和记忆化的，因为它们只有在输入改变时才会被调用。如果不是这种情况，管道的转换函数将不会被调用，组件也不会重新渲染。
- en: In the recipe, we move the computation to a newly created Angular pipe. The
    pipe’s `transform` method receives `randomizationCount` as the first value, and
    the `user` (of type `IUser`) as the second input. The pipe then uses the `randomColor`
    method and, ultimately, the `factorial` method to calculate a random color. When
    we start typing in the search box, the values for the user cards do not change.
    This results in the pipe not being triggered until we get back a new set of users
    based on the search query. Once we get the result, the user cards are re-rendered
    and hence we get new colors for them. As a result, there is no unnecessary computation
    running due to browser events, thus optimizing performance and unblocking the
    UI thread.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将计算移动到一个新创建的 Angular 管道。管道的 `transform` 方法接收 `randomizationCount` 作为第一个值，以及
    `user`（类型为 `IUser`）作为第二个输入。管道随后使用 `randomColor` 方法，最终使用 `factorial` 方法来计算一个随机颜色。当我们开始在搜索框中输入时，用户卡片的值不会改变。这导致管道直到我们根据搜索查询得到一组新的用户时才会被触发。一旦我们得到结果，用户卡片将被重新渲染，因此我们为它们得到新的颜色。结果，由于浏览器事件，没有不必要的计算运行，从而优化性能并解除
    UI 线程的阻塞。
- en: See also
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Angular pure and impure pipes official documentation: [https://angular.io/guide/pipes#pure-and-impure-pipes](https://angular.io/guide/pipes#pure-and-impure-pipes)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 纯管道和不纯管道官方文档：[https://angular.io/guide/pipes#pure-and-impure-pipes](https://angular.io/guide/pipes#pure-and-impure-pipes)
- en: Using web workers for heavy computation
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Web workers 进行重量级计算
- en: If your Angular application does a lot of computation during an action, there’s
    a high chance that it will block the UI thread. This will cause a lag in rendering
    the UI because it blocks the main JavaScript thread. Web workers allow us to run
    heavy computation in the background thread, thus freeing the UI thread as it is
    not blocked. In this recipe, we’re going to use an application that does a heavy
    computation in the `UserService` class. It creates a unique ID for each user card
    and saves it into `localStorage`. However, it loops a couple of thousand times
    before doing so, which causes our application to hang for a while. In this recipe,
    we’ll move the heavy computation from the components to a web worker and will
    also add a fallback in case web workers aren’t available.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Angular 应用在执行动作时进行大量计算，那么它有很大可能会阻塞 UI 线程。这会导致渲染 UI 时出现延迟，因为它阻塞了主 JavaScript
    线程。Web workers 允许我们在后台线程中运行重量级计算，从而释放 UI 线程，使其不被阻塞。在这个菜谱中，我们将使用一个在 `UserService`
    类中进行重量级计算的应用程序。它为每个用户卡片创建一个唯一的 ID 并将其保存到 `localStorage` 中。然而，在这样做之前，它会循环几千次，这会导致我们的应用程序挂起一段时间。在这个菜谱中，我们将把重量级计算从组件移动到
    Web worker，并且还会添加一个回退方案，以防 Web workers 不可用。
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-ww-perf`
    inside the cloned repository:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的 `start/apps/chapter12/ng-ww-perf` 目录内：
- en: Open the code repository in your code editor.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE37]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该会看到以下内容：
- en: '![](img/B18469_12_28.png)'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_12_28.png)'
- en: 'Figure 12.28: The ng-ww-perf app running at http://localhost:4200'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.28：ng-ww-perf 应用程序在 http://localhost:4200 运行
- en: Now that we have the app running, let’s see the steps of the recipe in the next
    section.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了应用程序，让我们在下一节中查看菜谱的步骤。
- en: How to do it…
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Once you open the app, you’ll notice that it takes some time before the user
    cards are rendered. We can also see the number of times the random color for the
    user card background is generated. If you type something, or click the **Update
    Irineu’s Name** button, you will see that the UI thread is blocked until we have
    some computation finished. The culprit is the `randomColor` getter method in the
    `UserCardComponent` class. This ultimately generates a random color after running
    a `for` loop based on the `RANDOMIZATION_COUNT` token’s value before rendering
    the color. This happens inside the `generateRandomColor` method inside the `src/app/utils.ts`
    file. Let’s start the recipe to improve the performance of the app. We’ll start
    by implementing a web worker:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你打开应用，你会注意到用户卡片渲染需要一些时间。我们还可以看到用户卡片背景随机颜色生成的次数。如果你输入某些内容，或者点击**更新Irineu的名字**按钮，你会看到UI线程在计算完成之前被阻塞。罪魁祸首是`UserCardComponent`类中的`randomColor`获取器方法。这最终在渲染颜色之前，基于`RANDOMIZATION_COUNT`令牌的值运行一个`for`循环来生成一个随机颜色。这发生在`src/app/utils.ts`文件中的`generateRandomColor`方法内部。让我们开始配方来提高应用性能。我们将从实现一个web
    worker开始：
- en: 'We’ll first create a web worker. Run the following command in the workspace’s
    root:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个web worker。在工作区根目录中运行以下命令：
- en: '[PRE38]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Choose `@nx/angular:web-worker` when asked.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当被询问时，选择`@nx/angular:web-worker`。
- en: 'Now, update the code inside the `workers/random-color.worker.ts` file as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`workers/random-color.worker.ts`文件中的代码如下：
- en: '[PRE39]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let’s replace the `randomColor` getter in the `UserCardComponent` class with
    a regular property. Update the `user-card.component.ts` file as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`UserCardComponent`类中的`randomColor`获取器替换为一个普通属性。按照以下方式更新`user-card.component.ts`文件：
- en: '[PRE40]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Make sure to remove the `randomColor` getter function. Otherwise, TypeScript
    will throw errors since we can’t have a property and a getter method having the
    same name.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保删除`randomColor`获取器函数。否则，TypeScript会抛出错误，因为我们不能有一个属性和一个具有相同名称的获取器方法。
- en: 'Now, we’ll use the worker in the `user-card.component.ts` file. Update it,
    as follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`user-card.component.ts`文件中的worker。按照以下方式更新它：
- en: '[PRE41]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'So far, we have just added a listener for when we’ll receive the generated
    color from the worker. But first, we must send a message from the component to
    the worker, so it generates a random color. Update the `user-card.component.ts`
    file to use the `OnChanges` life cycle hook. We’ll use it to send a message to
    the worker:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是添加了一个监听器，用于接收从worker生成的颜色。但首先，我们必须从组件向worker发送一条消息，以便它生成一个随机颜色。将`user-card.component.ts`文件更新为使用`OnChanges`生命周期钩子。我们将使用它向worker发送消息：
- en: '[PRE42]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, let’s ensure that the worker is destroyed (terminated) when the respective
    user card is destroyed. Update the `user-card.component.ts` file as follows:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们确保在相应的用户卡片被销毁（终止）时，worker也被销毁。按照以下方式更新`user-card.component.ts`文件：
- en: '[PRE43]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Refresh the app and notice how long it takes for the user cards to render. They
    should appear much faster than before. Also, you should be able to see the following
    logs reflecting the communication from the app to the web worker, and vice versa:![](img/B18469_12_29.png)
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新应用并注意用户卡片渲染所需的时间。它们应该比之前快得多。此外，你应该能够看到以下日志反映了从应用到web worker以及相反的通信：![img/B18469_12_29.png](img/B18469_12_29.png)
- en: 'Figure 12.29: Logs showing messages to and from the app to web workers'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.29：显示从应用向web worker发送消息的日志
- en: Woohoo! The power of web workers! And now you know how to use web workers in
    an Angular app to move heavy computation to them. Since you’ve finished the recipe,
    see the next section on how this works.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！web worker的力量！现在你知道如何在Angular应用中使用web worker将繁重的计算移到它们那里。由于你已经完成了配方，请查看下一节了解它是如何工作的。
- en: How it works…
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As we discussed in the recipe’s description, web workers allow us to run and
    execute code in a separate thread from the main JavaScript (or UI thread). At
    the beginning of the recipe, whenever we refresh the app or search for a user,
    it blocks the UI thread. We sometimes see the loader being hung, or a white screen.
    This is until a random color is generated for each card. We begin the recipe by
    creating a web worker using the NX **Command-line Interface** (**CLI**). This
    creates a `random-color.worker.ts` file, which contains some boilerplate code
    to receive messages from the UI thread and send a message back to it as a response.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在食谱描述中讨论的那样，Web工作者允许我们在主JavaScript（或UI线程）之外的一个单独的线程中运行和执行代码。在食谱的开始部分，无论何时我们刷新应用程序或搜索用户，它都会阻塞UI线程。我们有时会看到加载器被挂起，或者出现一个空白屏幕。直到为每个卡片生成一个随机颜色。我们通过使用NX
    **命令行界面**（**CLI**）开始食谱，创建一个Web工作者。这会创建一个 `random-color.worker.ts` 文件，其中包含一些模板代码，用于接收来自UI线程的消息并将其作为响应发送回它。
- en: 'The CLI command also updates the `project.json` file by adding a `webWorkerTsConfig`
    property. The value against the `webWorkerTsConfig` property is the path to the
    `tsconfig.worker.json` file, and the CLI command also creates this `tsconfig.worker.json`
    file. If you open the `tsconfig.worker.json` file, you should see the following
    code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: CLI命令还会通过添加 `webWorkerTsConfig` 属性来更新 `project.json` 文件。`webWorkerTsConfig`
    属性的值是对 `tsconfig.worker.json` 文件的路径，CLI命令还会创建这个 `tsconfig.worker.json` 文件。如果您打开
    `tsconfig.worker.json` 文件，您应该看到以下代码：
- en: '[PRE44]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: However, in our NX workspace, we have a `tsconfig.base.json` file instead of
    `tsconfig.json`. So, we fixed it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的NX工作区中，我们有一个 `tsconfig.base.json` 文件而不是 `tsconfig.json`。因此，我们进行了修复。
- en: In the web worker file, we have the `addEventListener` method call, which receives
    messages from the UI thread to the worker. Notice that we expect to receive the
    `randomizationCount` property from the UI thread so we can use it in the `generateRandomColor`
    method from the `utils.ts` file.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web工作者文件中，我们有 `addEventListener` 方法的调用，它从UI线程接收消息到工作者。请注意，我们期望从UI线程接收 `randomizationCount`
    属性，这样我们就可以在 `utils.ts` 文件中的 `generateRandomColor` 方法中使用它。
- en: The worker file also has a method named `getRandomColorWorker`. This returns
    a new instance of the worker every time it is called. Since we call it from our
    user card components, each card gets a new instance of the worker.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者文件还有一个名为 `getRandomColorWorker` 的方法。每次调用它时，都会返回一个新的工作者实例。由于我们从用户卡片组件中调用它，每个卡片都会得到一个新的工作者实例。
- en: Then, in our `UserCardComponent` class, we get a new instance of the worker
    for each component and use the `ngOnInit` life cycle hook to add an event listener
    to the worker. This way, whenever the worker sends a message, the user card component
    can read it—that is, it will get the generated color and assign it to the `randomColor`
    property. This, in turn, will set the `backgroundColor` of the user card. Notice
    that the `ngOnInit` life cycle hook only registers a listener for the messages
    sent by the worker. But first, we have to tell the worker to generate random colors.
    For this, we use the `ngOnChanges` life cycle hook. In the hook, we observe the
    value of the user input. If it changes, we send a message to the worker to generate
    a random color for the specific user card. If you click on the **Update Irineu’s
    Name** button, you will see consecutive logs from and to the user card. Note that
    moving the color generation to the worker in this way also results in other components
    not being re-rendered again when we have any of the browser events (click, key
    up, etc.) triggering. Finally, we use the `ngOnDestroy` life cycle hook to terminate
    the worker to avoid memory leaks.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的 `UserCardComponent` 类中，我们为每个组件获取一个新的工作者实例，并使用 `ngOnInit` 生命周期钩子向工作者添加一个事件监听器。这样，每当工作者发送消息时，用户卡片组件都可以读取它——也就是说，它会获取生成的颜色并将其分配给
    `randomColor` 属性。这反过来会设置用户卡片的 `backgroundColor`。请注意，`ngOnInit` 生命周期钩子只为工作者发送的消息注册监听器。但首先，我们必须告诉工作者生成随机颜色。为此，我们使用
    `ngOnChanges` 生命周期钩子。在钩子中，我们观察用户输入的值。如果它发生变化，我们就向工作者发送消息，为特定的用户卡片生成一个随机颜色。如果您点击
    **更新Irineu的姓名** 按钮，您将看到从用户卡片发送和接收的连续日志。请注意，以这种方式将颜色生成移动到工作者，也会导致在浏览器事件（点击、按键等）触发时，其他组件不再重新渲染。最后，我们使用
    `ngOnDestroy` 生命周期钩子来终止工作者，以避免内存泄漏。
- en: Note that in the `ngOnChanges` hook, we are also falling back to the regular
    usage of the methods in the `utils.ts` file if the browser does not support workers.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `ngOnChanges` 钩子中，如果浏览器不支持工作者，我们也会回退到 `utils.ts` 文件中方法的常规使用。
- en: See also
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular official documentation on web workers: [https://angular.io/guide/web-worker](https://angular.io/guide/web-worker)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MDN web worker documentation: [https://developer.mozilla.org/en-US/docs/Web/API/Worker](https://developer.mozilla.org/en-US/docs/Web/API/Worker)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using performance budgets for auditing
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s world, most of the population has a good internet connection to use
    everyday applications, be it a mobile app or a web app, and it is fascinating
    how much data we ship to our end users as a business. The amount of JavaScript
    shipped to users has an ever-increasing trend now, and if you’re working on a
    web app, you might want to use performance budgets to make sure the bundle size
    doesn’t exceed a certain limit. With Angular apps, setting the budget sizes is
    a breeze. In this recipe, you’re going to learn how to use the performance budgets
    to ensure small bundle sizes for our Angular apps.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-perf-budgets`
    inside the cloned repository:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to build the project:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This should build the app, and you should see the following in the terminal:'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_30.png)'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.30: Build output for production mode, without performance budgets'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice that the bundle size for the `main.*.js` file is about 294 **Kilobytes**
    (**KB**) now. And now that we have built the app, let’s see the steps of the recipe
    in the next section.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an app that is small in terms of bundle size at the moment. However,
    this could grow into a huge app with upcoming business requirements. For the sake
    of this recipe, we’ll increase the bundle size deliberately and will then use
    performance budgets to stop the Angular build from being generated for production
    if the bundle size exceeds the budget. Let’s begin the recipe:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.ts` file and update it, as follows:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, build the app again by running the following command from the workspace’s
    root folder:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You should see that the bundle size for the `main.*.js` file is now somewhat
    around 1.10 **megabytes** (**MB**). This is a huge increase in size compared to
    the original ~294 KB, as you can see in the following screenshot:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_31.png)'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.31: The bundle size for main.*.js increased to 1.10 MB'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we’re using NX for our recipes, we already have the budgets set by NX.
    However, if you had a regular Angular application (without NX), you would update
    the `angular.json` file to add the budgets.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `project.json` file within the `start/apps/chapter12/ng-perf-budgets`
    folder and update it. The property that we’re targeting is `targets.build.configurations.production.budgets`.
    The updated code should look like this:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that we have only changed `maximumWarning` from `500kb` to `800kb` for
    the `initial` bundle.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s improve our application by not importing the entire libraries in the
    `app.component.ts` file, and by using the `date-fns` package instead of `moment.js`.
    Run the following command from the workspace’s root folder to install the `date-fns`
    package:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, update the `app.component.ts` file, as follows:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Run the `npm run build ng-perf-budgets` command again. You should see a decreased
    bundle size and the build being generated successfully, as follows:![](img/B18469_12_32.png)
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.32: Reduced bundle size after using date-fns and optimized imports'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Boom! You just learned how to use performance budgets in Angular. These budgets
    can be used to throw warnings and errors based on your configuration. Note that
    the budgets can be modified based on changing business requirements. However,
    as engineers, we have to be cautious about what we set as performance budgets
    to not ship JavaScript over a certain limit to the end users.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Since you’ve finished the recipe, see the next section on how this works.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular performance budgets are guidelines set for the acceptable limits of
    various performance metrics in Angular applications. These budgets help ensure
    that the application’s performance remains within acceptable bounds and does not
    degrade significantly as the code base grows or changes. The most critical performance
    metric you can work with is the initial bundle size. This is what the user’s device
    will load first as the main set of JavaScript files, and they are eagerly loaded.
    In this recipe, we have two issues. First, we use `moment.js`, which is a library
    that is not *tree-shakable*. This means if we import the library, the whole library
    is included in the final bundle, whereas tree-shakable libraries have *the code
    not being used* in the application removed by the build tools when you build them.
    The second problem we introduced is that we included the entire library, `three`,
    in our component, which is tree-shakable, but our import is inaccurate. We introduced
    these problems to see the bundle size increase. But as we saw, in NX, we can use
    any Angular app’s `project.json` file to manage the performance budgets. If you
    were working on an Angular CLI-based application, you would do the same in the
    `angular.json` file. In practice, you will be using a warning threshold and an
    error threshold, which ensures you’re not shipping huge JavaScript bundles to
    the end users.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Performance budgets with the Angular CLI official documentation: [https://web.dev/performance-budgets-with-the-angular-cli/](https://web.dev/performance-budgets-with-the-angular-cli/)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Boosting Angular App Performance* *with Performance Budgets*: [https://www.codewithahsan.dev/blog/angular-performance-budgets](https://www.codewithahsan.dev/blog/angular-performance-budgets)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing bundles with webpack-bundle-analyzer
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at configuring budgets for our Angular app,
    and this is useful because you get to know when the overall bundle size exceeds
    a certain threshold, although you don’t get to know how much each part of the
    code contributes to the final bundles. This is what we call *analyzing* the bundles,
    and in this recipe, you will learn how to use `webpack-bundle-analyzer` to audit
    the bundle sizes and the factors contributing to them.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-perf-wba`
    inside the cloned repository:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to build the project:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This should build the app, and you should see the following in the terminal:'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_33.png)'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.33: The ng-perf-wba app running at http://localhost:4200'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have built the app, let’s see the steps of the recipe in the next
    section.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an app that is small in terms of bundle size at the moment. However,
    this could grow into a huge app with upcoming business requirements. For the sake
    of this recipe, we’ll increase the bundle size deliberately and will then use
    `webpack-bundle-analyzer` to observe the packages contributing to the large bundle
    sizes. Let’s begin the recipe:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.ts` file and update it, as follows:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, build the app again by running the following command from the workspace
    root:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should see that the bundle size for the `main.*.js` file is now somewhat
    around 1.10 MB. This is a huge increase in size compared to the original ~294
    KB. As a result, the **Initial Total** size became 1.15 MB and the build failed,
    as you can see in the following screenshot:'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_34.png)'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.34: The build failing due to an increased bundle size'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll first create a build with the `stats.json` file, which contains the bundle
    information in the JSON format. To do that, run the following command from the
    workspace root:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, run the following command from the workspace root to have the `stats.json`
    file read by the `webpack-bundle-analyzer`, as follows:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This will spin up a server with the bundle analysis. You should see a new tab
    opened in your default browser, and it should look like this:'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_35.png)'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.35: Bundle analysis using webpack-bundle-analyzer'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Notice that the `lib` folder takes a huge portion of the bundle size— around
    562 KB, which you can check by just doing a mouseover on the **lib** box. The
    overall bundle size is 1.16 MB. Let’s try to optimize the bundle size. Let’s install
    the `date-fns` package so that we can use it instead of `moment.js`. Run the following
    command from your project root:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, update the `app.component.ts` file to use the `date-fns` package’s `format`
    method instead of using the `moment().format` method. We’ll also just import the
    `Scene` class from the `Three.js` package instead of importing the whole library.
    The code should look like this:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`app.component.ts`文件以使用`date-fns`包的`format`方法，而不是使用`moment().format`方法。我们还将只从`Three.js`包中导入`Scene`类，而不是导入整个库。代码应该看起来像这样：
- en: '[PRE57]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Repeat *step 3* and *step 4* to build the app again and to analyze via `webpack-bundle-analyzer`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤 3*和*步骤 4*以重新构建应用程序并通过`webpack-bundle-analyzer`进行分析。
- en: 'Once `webpack-bundle-analyzer` runs, you should see the analysis, as shown
    in the following screenshot. Notice that we don’t have the `moment.js` file or
    the `lib` block anymore, and the overall bundle size has reduced from 1.16 MB
    to about 835 KB:'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦`webpack-bundle-analyzer`运行，你应该会看到分析结果，如下面的屏幕截图所示。注意，我们不再有`moment.js`文件或`lib`块，整体包大小已从1.16
    MB减少到大约835 KB：
- en: '![](img/B18469_12_36.png)'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_12_36.png)'
- en: 'Figure 12.36: Bundle analysis after optimization'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.36：优化后的包分析
- en: Woohoo! You now know how to use the `webpack-bundle-analyzer` package to audit
    bundle sizes in Angular applications. This is a great way of improving overall
    performance because you can identify the chunks causing the increase in the bundle
    size and then optimize the bundles. If you run `npm run serve ng-perf-wba` from
    the workspace root before and after the optimization, you will see the same console
    logs, which show that we kept the existing functionality and optimized the bundles
    anyway.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！你现在已经知道如何使用`webpack-bundle-analyzer`包来审计Angular应用程序的包大小了。这是一个提高整体性能的好方法，因为你可以识别出导致包大小增加的块，然后优化这些包。如果你在优化前后从工作区根目录运行`npm
    run serve ng-perf-wba`，你会看到相同的控制台日志，这表明我们保留了现有功能并优化了包。
- en: See also
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关链接
- en: 'Getting started with webpack: [https://webpack.js.org/guides/getting-started/](https://webpack.js.org/guides/getting-started/)'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用webpack：[https://webpack.js.org/guides/getting-started/](https://webpack.js.org/guides/getting-started/)
- en: 'The `webpack-bundle-analyzer` GitHub repository: [https://github.com/webpack-contrib/webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webpack-bundle-analyzer`的GitHub仓库：[https://github.com/webpack-contrib/webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)'
- en: Learn more on Discord
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的Discord社区——在那里你可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/AngularCookbook2e](Chapter_12.xhtml)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/AngularCookbook2e](Chapter_12.xhtml)'
- en: '![](img/QR_Code1388317275422265.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1388317275422265.png)'
