- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Session Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Session management describes the process of preserving data across different
    user interactions and request-response roundtrips. Session management is crucial
    to provide personalized experiences on the web. In this chapter, we will work
    with Remix’s primitives to manage application state and user session data. This
    chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with search parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating user sessions with cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating access to user data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will work with Remix's primitives to tie application states to URL
    search parameters. Then, we will utilize HTTP cookies to persist user session
    data. Finally, we will use the session cookie to authenticate users in `loader`
    and `action` functions.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will understand how to work with search parameters
    to control application states in Remix. You will also know how to submit forms
    programmatically using Remix’s `useSubmit` hook. You will further practice working
    with Remix’s session cookie helpers and learn how to implement login, signup,
    and logout functionalities in Remix. Finally, you will understand how to authenticate
    users on the server and how to access loader data globally across your application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/08-session-management/](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/08-session-management/).'
  prefs: []
  type: TYPE_NORMAL
- en: Before starting this chapter, follow the instructions in the `README.md` file
    in this chapter’s `bee-rich` folder on GitHub. This `README` file guides you through
    adding a `User` model to the database schema of the BeeRich application. It further
    helps you initiate a `session.server.ts` file with some useful helper functions.
    Note that following the `README` guide will temporarily break the create and edit
    expense and income form actions. We will update the code in this chapter. Until
    then, use the seed data to populate the database for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Working with search parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The URL stores information about the user’s current location. We already utilize
    dynamic route parameters for expense and invoice identifiers. Similarly, we can
    use URL search parameters to store additional application states.
  prefs: []
  type: TYPE_NORMAL
- en: A URL is the perfect place to persist state that concerns only one or a few
    pages. In this section, we will use URL search parameters to create a search filter
    on the expense overview page in BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you know that Google uses a search parameter to implement search queries?
    Open [google.com](http://google.com) and use the search input field to start a
    new Google search. After pressing *Enter*, Google navigates you to the search
    results page. If you inspect the URL, you will see that Google uses a search parameter
    called `q` (short for query probably) to store your search query: [https://www.google.com/search?q=Using+search+params+in+Remix.run](https://www.google.com/search?q=Using+search+params+in+Remix.run).'
  prefs: []
  type: TYPE_NORMAL
- en: Search parameters are key-value pairs that are added to the URL after the pathname
    following a question mark (`?`) and appended via ampersands (`&`). Search parameters
    allow us to store additional optional application states outside of the URL path.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build an experience similar to Google Search in BeeRich to filter the
    expense list through a search filter.
  prefs: []
  type: TYPE_NORMAL
- en: Reading search parameters in loader functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The expenses list is fetched and rendered in the `dashboard.expenses.tsx` route
    module. Now, we want to allow users to filter the list by using a search input
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can divide the work into two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the database query so that it filters by a search query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the user with the UI so that they can enter search queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let’s update the `loader` function. The goal is to update the `loader`
    function so that it only fetches expenses that match the query string provided
    through the request URL:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `dashboard.expenses.tsx` route module in your editor and inspect the
    module’s `loader` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, add the `request` parameter to the `loader` function arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'export async function loader({ request }: LoaderFunctionArgs) {  q - short
    for query. You can find more information about the URL interface in the MDN Web
    Docs: https://developer.mozilla.org/en-US/docs/Web/API/URL.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the database query so that it only returns the expenses where the title
    contains the search string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the URL does not contain a query string, we search against an empty string,
    which matches all expenses. In this case, the `loader` function behaves as before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run BeeRich in development mode by executing `npm run dev` in a terminal and
    navigate to the expenses overview page ([http://localhost:3000/dashboard/expenses](http://localhost:3000/dashboard/expenses)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we didn’t include a query string in the URL, we still return the full
    list of expenses.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, update the URL in the URL bar by adding a query string such as [http://localhost:3000/dashboard/expenses?q=Groceries](http://localhost:3000/dashboard/expenses?q=Groceries)
    and refresh the page. It should now display a filtered list of expenses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! The `loader` function now handles the `q` search parameters when present
    and returns a filtered list of expenses. Next, let’s add a search input field
    to let the user search for specific expenses.
  prefs: []
  type: TYPE_NORMAL
- en: Updating search parameters with form submissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we’ll provide the user with a search input field:'
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, disable JavaScript to ensure the base implementation works without
    client-side JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can disable JavaScript in your browser’s developer tools or by removing
    the `Script` component in `root.tsx`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import Remix’s `Form` component from `@remix-run/react`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import { Input } from '~/components/forms';
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, use the `Form` and `Input` components to implement a search input field
    between the **All expenses** screenreader heading and the unordered list of expenses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `useLocation` hook from Remix to access the current URL path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the location in the function body of the route component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the path of the current location to set the form’s action dynamically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A submission now creates a GET request to the current page with an updated search
    parameter to filter the list of expenses.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try out the new search input field by typing a search query and hitting *Enter*
    to submit the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the search input field is empty after every full-page reload, even
    when a `q` search parameter is set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `useSearchParams` hook from Remix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: const [searchParams] = useSearchParams();const searchQuery = searchParams.get('q')
    || '';
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `searchQuery` value as the `defaultValue` property for the input field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.1 – Screenshot of the filtered expenses list](img/Figure_8.01_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Screenshot of the filtered expenses list
  prefs: []
  type: TYPE_NORMAL
- en: Great! Hitting *Enter* after typing a search query submits the form and updates
    the URL so that it includes the search query. The `loader` function then returns
    an updated filtered list of expenses. Note that we didn’t use any React state
    to implement this feature, and as always, the search feature also works without
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping UIs to URLs
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of search parameters over React state is that they can be accessed
    on the server by reading from the request URL. Search parameters persist on full-page
    reloads and work with the browser’s back and forward buttons. Additionally, search
    parameters create URL variants that CDNs and browsers can cache.
  prefs: []
  type: TYPE_NORMAL
- en: Implement the same behavior for the income overview route. Update the `dashboard.income.tsx`
    route module’s `loader` function and implement the search form to query invoices.
    Once the income route has been updated, we can enhance the experience with custom
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatically submitting forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, the user needs to press *Enter* to trigger a new search. Let’s add
    a debounced search that submits the form automatically whenever the user changes
    the value in the input field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import `useSubmit` from Remix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the route module’s component body, create a new submit function by calling
    `useSubmit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following change event handler to the search input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On change, we programmatically submit the form using the `submit` function.
    We pass `submit` the HTML form element, accessing it from the event's target object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try out the current implementation and type something into the search input
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may notice that we are currently submitting a new form for every change
    event. This is not very efficient. Instead, we should delay the submission until
    the user finishes typing. This method of delaying a function call is called debouncing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace `Input` with `SearchInput`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update the JSX so that it renders `SearchInput` instead of the `Input`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the submission is now handled inside the `SearchInput` component, remove
    the `useSubmit` hook from the `dashboard.expenses.tsx` route module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You now know three ways of submitting data in Remix: the `Form` component,
    the `useFetcher` hook, and the `useSubmit` hook. This raises the question of when
    to best use which utility.'
  prefs: []
  type: TYPE_NORMAL
- en: When to use Remix data fetching primitives
  prefs: []
  type: TYPE_NORMAL
- en: Use the `Form` component for the main interactions on the page. The `Form` component
    is the most straightforward way to implement a form interaction in Remix. Stick
    with the `Form` component for all simple use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `useSubmit` hook when you want to programmatically submit a `Form` component
    (for example, on change). You can add `useSubmit` to `Form` implementations to
    enhance the experience progressively.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that there can only ever be one active navigation at a time. Use the
    `useFetcher` hook to implement a list of forms, or aside user interactions, that
    should support concurrent submissions. Aside interactions are usually not meant
    to trigger page navigations and should have access to isolated navigation states
    and action data. Whenever you want to trigger a `useFetcher` hook’s `Form` component
    programmatically, you can use `useFetcher.load` and `useFetcher.submit`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to handle application state with the URL. You
    also learned that forms can execute GET requests by setting the form method to
    `"GET"`. Finally, you practiced how to programmatically submit a form with `useSubmit`.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you update the income route to practice what you’ve learned in this section.
    Once you’ve done that, we can start investigating how to handle user sessions
    with cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Creating user sessions with cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A session maintains the state of a user’s interactions with a web application
    across multiple requests. Sessions track information such as user authentication
    credentials, shopping cart contents, color scheme preferences, and other user-specific
    data. In this section, we will use Remix’s session cookie helpers to create a
    login and signup flow in BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: One way to manage sessions is via cookies. Cookies contain small pieces of data
    and are appended to both document and fetch requests, making them a great way
    to handle user sessions, personalization, and tracking. Additionally, cookies
    can be encrypted to securely carry user credentials without client access.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies are part of the HTTP protocol and enable persisting information in the
    otherwise stateless HTTP protocol. Where URL search parameters are visible to
    the user and can be bookmarked and shared, cookie data can be encrypted and are
    then only accessible on the server. Search parameters are handy for storing application
    states that are not tied to specific users. Cookies are ideal for authenticating
    users and storing small chunks of private session data.
  prefs: []
  type: TYPE_NORMAL
- en: A web server can append a cookie to the current session by setting the **Set-Cookie**
    header on the HTTP response. Once a cookie has been set, the browser attaches
    the cookie using the **Cookie** header to all subsequent requests based on the
    lifetime specified during cookie setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remix provides two different abstractions to work with cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createCookie` to read and write cookies'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`createCookieSessionStorage` to implement a session storage using a cookie'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we will use Remix’s `createCookieSessionStorage` function since
    our goal is to implement user sessions for authentication and authorization. We
    will have a look at the `createCookie` helper function in [*Chapter 15*](B17399_15.xhtml#_idTextAnchor214),
    *Advanced Session Management,* to persist visitor tracking data.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Remix’s session helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s implement the register and login pages in BeeRich:'
  prefs: []
  type: TYPE_NORMAL
- en: First, follow the `README.md` file in this chapter’s folder on GitHub to prepare
    BeeRich for this section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you’ve followed the setup guide in the `README.md` file, open the `modules/session/session.server.ts`
    file in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, import the `createCookieSessionStorage` and `redirect` helper functions
    from Remix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following code below the already existing `registerUser` and `loginUser`
    functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `.env` file in your project’s root folder and add a `SESSION_SECRET`
    environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: HTTP cookie signing involves adding a cryptographic signature to a cookie using
    a secret key known only to the server. When the client sends this signed cookie
    back in future requests, the server uses the secret key to verify that the cookie
    has not been tampered with. This adds an extra layer of security.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We read the environment variables when first starting our server environment.
    Make sure you restart your development server in case it is currently running
    to ensure the new environment variable is picked up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, add the following helper function to the `session.server.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we can create new user sessions, let’s implement a signup flow to register
    new users.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a user registration flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will apply what we have learned thus far to implemnet a
    registration form and associated `action` function. Before reading through the
    solution, I encourage you to try it yourself. Start by updating the signup route
    module component. Then, add an `action` function and parse the form data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go through the implementation step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `_layout.signup.tsx` route module and update the route module component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we use some reusable components to add our custom styles. Also, note
    that we set the form method to POST. A signup flow mutates data and must not be
    a GET request. Finally, we again utilize the `useNavigation` hook to add pending
    indicators when the form is submitting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, add an `action` function to handle registration form submissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `useActionData` from Remix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the error message action data in the route component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import our styled inline error component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Render the `InlineError` component below the submit button to display any error
    messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the developer tools in your browser window and navigate to the **Application**
    tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The Application tab of the developer tools](img/Figure_8.02_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The Application tab of the developer tools
  prefs: []
  type: TYPE_NORMAL
- en: Under `httpOnly` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the cookie and select **Delete**.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to play around with the registration form a bit more before we
    implement our logout flow.
  prefs: []
  type: TYPE_NORMAL
- en: Try to register the same email address again. You should now see an inline error.
    Awesome!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feel free to spend more time on this section and investigate the code flow through
    the `action` function and the `session.server.ts` file. Use the `debugger` or
    `console.log` statements to review what happens during signup.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you feel comfortable with the added code, delete the cookie using the developer
    tools. This will let us implement and test the login flow.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a user login flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copy and paste the route module component from the registration flow and see
    whether you can update it to make it work for the login page. Maybe try the same
    for the `action` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have tried it out, let’s go through the implementation together:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to update the `_layout.login.tsx` route component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The login and signup forms are nearly identical; only the number of input fields
    differs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, add the `action` function to handle the login form submissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try out the login flow using the email address you used during the registration
    flow. You should now be able to register and log in to BeeRich.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far, we have utilized session helper functions to create a user session after
    successful registration or login. By inspecting the developer tools, we ensured
    that the browser registered the cookie. Next, we’ll add a logout flow that removes
    the session cookie.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a session during logout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Removing a session cookie is straightforward. In `session.server.ts`, we have
    access to three session life cycle methods: `getSession`, `commitSession`, and
    `destroySession`. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a helper function to `session.server.ts` to get the current user
    session from an incoming request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a logout function to `session.server.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'import type { ActionFunctionArgs } from ''@remix-run/node'';import { redirect
    } from ''@remix-run/node'';import { logout } from ''~/modules/session/session.server'';export
    function action({ request }: ActionFunctionArgs) {  action function that executes
    the logout function. This removes the session cookie and redirects the user to
    login. The logout route module also has a loader function to redirect all traffic
    to login. This is convenient if a user accidentally navigates to the logout page.Remember
    that Remix refetches all loader data from all active `loader` functions after
    an `action` function executes. Since `logout` mutates the server state (the user
    session), we use an `action` function and not a `loader` function to implement
    `logout`. After logging out, we want to remove all user-specific data from the
    page by revalidating all loader data.Note that the logout route module does not
    export a route component. Thus, it is not a document but a resource route.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `dashboard.tsx` route module and locate the current logout link in
    the navigation bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Currently, the logout button is a placeholder linking to a non-existent page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import `Form` from Remix and replace the code to create a form that submits
    a POST request to the logout route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Clicking the **Log out** link submits a form to the logout action function,
    redirecting the user to log in and removing the current user session cookie. And
    with that, we have successfully implemented a logout flow in BeeRich.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we practiced creating and deleting session cookies using Remix’s
    session cookie helpers. Next, we will read from the session cookie to authenticate
    the user and return user-specific data from our `loader` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating access to user data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can access cookies in our `loader` and `action` functions as cookies are
    appended to every HTTP request to the web server. This makes cookies a great tool
    for managing sessions. In this section, we will read from the session cookie to
    authenticate users and query user-specific data.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing cookie data on the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we append a cookie to a response, we can access the cookie data on every
    following request to the server. This lets us build personalized and session-based
    user experiences. Let’s add some helper functions to make this task easier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `session.server.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `loader` functions to the login and signup route modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this section, we implemented the `getUserId` and `getUser` helper functions.
    We use `getUserId` to check whether a user is logged in. Next, we will use `getUser`
    to get the user object of the currently logged-in user, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Working with user data on the client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will use `getUser` to work with the user object of the
    currently logged-in user:'
  prefs: []
  type: TYPE_NORMAL
- en: First, import `LoaderFunctionArgs` and `getUser` in root.tsx.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'export async function loader({ request }: LoaderFunctionArgs) {  getUser returns
    a user object without the password property. This is important as we forward the
    user object to the client. We must not leak user or app secrets to the client
    application.We can now access the user object with `useLoaderData` in `root.tsx`.
    However, we likely want to have access to the user object throughout our application.
    Let’s see how we can do this with Remix.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `session.ts` file in `app/modules/session`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We plan to create a small React hook to access the root loader user data across
    our React app. Since we also want to access the hook in our React app on the client,
    we must not put the hook in the `session.server.ts` file as it is only included
    in the server bundle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following `useUser` hook to `session.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `useUser` hook in the `_layout.tsx` route component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the unordered list of the navigation, replace the current **Log in** and
    **Sign in** list items with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now conditionally render the **Log in** and **Sign up** links if no user
    is logged in or a link to **Dashboard** if a user is already logged in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the user object returned by `useUser` can also be `null`. We try to
    query a user object if a session exists or return `null` otherwise. However, sometimes,
    we must ensure that a user is logged in. We’ll look at enforcing authentication
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing authentication on the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dashboard routes of BeeRich are for logged-in users only. Can you think
    of a way to enforce that a session cookie is present?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement some authentication logic that redirects the user to the login
    page if no user session exists:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another helper function in `session.server.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following line to the top of all `loader` and `action` functions
    in the dashboard route modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `requireUserId` call ensures that the user is redirected to the login page
    in case they are not authenticated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since `loader` functions run in parallel and `action` functions expose API endpoints
    over the internet, we must add the authentication check to every single `loader`
    and `action` function that requires authentication.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We must also ensure that we only retrieve data associated with the current `userId`.
    A user should not be able to view the expenses and invoices of other users. Let’s
    update our `loader` and `action` functions further.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `dashboard.tsx` route module and update the `loader` function to require
    a user session and use `userId` to query user-specific expense and income objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `dashboard.expenses.tsx` route module and update the `loader` function
    so that it checks for an existing user session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `dashboard.expenses._index.tsx` route module and update the `action`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `dashboard.expenses.$id.tsx` route module and update the `loader`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `deleteExpense` handler function in `dashboard.expenses.$id.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `updateExpense` handler function in `dashboard.expenses.$id.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'export async function action({ params, request }: ActionFunctionArgs) {  requireUserId
    to enforce an existing user session. Then, we pass userId to the deleteExpense
    and updateExpense handler functions.That was quite a bit of code to go through,
    but by making some minor changes here and there, we have fully authenticated our
    application’s HTTP endpoints and ensured that only authenticated users can visit
    our dashboard pages.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now is a good time to play around with BeeRich. See whether you can still access
    any of the dashboard routes without logging in first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See whether you can hack into BeeRich by playing around with several tabs. Open
    the expense creation form in the first tab and log yourself out in the second
    tab. Can you still successfully create a new expense? Notice how cookies are appended
    and updated across different tabs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Securing loader and action functions
  prefs: []
  type: TYPE_NORMAL
- en: Remix’s `loader` functions run in parallel for faster execution. However, their
    concurrent nature also dictates that we must secure each loader function. Both
    `loader` and `action` functions are accessible over the internet and must be treated
    and secured like API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: We still need to update the income routes. This will be good practice to ensure
    you understand how to authenticate `loader` and `action` functions. Take your
    time and go over each `loader` and `action` function in the income routes to practice
    what you’ve learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to access state from session cookies in Remix
    and how to use session cookies to authenticate users in `loader` and `action`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about session and state management in Remix. First,
    you learned how to use URL search parameters to persist application state using
    Remix’s `Form` component and the `useSearchParams` hook. The URL is often all
    we need to handle application state.
  prefs: []
  type: TYPE_NORMAL
- en: You also practiced using `useSubmit` to submit a form programmatically and learned
    more about Remix’s different mutation utilities. We concluded that we use the
    `Form` component and the `useSubmit` hook for the primary actions on the page;
    `useFetcher` is used to support concurrent submissions with isolated submission
    states.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you learned that cookies are part of the HTTP protocol and can be used
    to persist state across page transitions. Cookies are a great tool for session
    management. Remix provides helper functions for working with cookies and sessions.
    Remix’s session primitives allow us to manage sessions using different strategies,
    such as storing session data in memory, files, databases, or cookies.
  prefs: []
  type: TYPE_NORMAL
- en: We utilized Remix’s primitives to implement an authentication flow with login,
    signup, and logout functionalities in BeeRich. You learned how to authenticate
    users and use session cookies to query for user-specific content.
  prefs: []
  type: TYPE_NORMAL
- en: On register and login, we create and fetch a user object and write `userId`
    to Remix’s session object. The object is then serialized to a string and added
    as a cookie to the HTTP response using the `loader` and `action` functions to
    authenticate user sessions and query user-specific data.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to access loader data globally throughout your application
    using Remix’s `useRouteLoaderData` hook. You practiced creating a small custom
    hook to abstract accessing the user object from the root `loader`.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you understand that `action` functions are standalone
    endpoints and `loader` functions run in parallel. Conclusively, we must authenticate
    the user in every restricted `loader` and `action` function to prevent unauthorized
    access.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn more about working with static assets and
    files in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Review the MDN Web Docs for more information about URL search parameters and
    the `URLSearchParams` interface: [https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also refer to the MDN Web Docs if you want to learn more about HTTP cookies:
    [https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
    or the `Headers` interface: [https://developer.mozilla.org/en-US/docs/Web/API/Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refresh your knowledge about HTML forms by reading through the MDN Web Docs:
    [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remix provides several primitives for working with sessions. You can find more
    information in the Remix documentation: [https://remix.run/docs/en/2/utils/sessions](https://remix.run/docs/en/2/utils/sessions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remix also provides lower-level primitives for working with cookies: [https://remix.run/docs/en/2/utils/cookies](https://remix.run/docs/en/2/utils/cookies).'
  prefs: []
  type: TYPE_NORMAL
