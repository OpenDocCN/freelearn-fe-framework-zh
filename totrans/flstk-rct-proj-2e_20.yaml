- en: Following Best Practices and Developing MERN Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will elaborate on some of the best practices to apply when
    building the six MERN applications in this book. Additionally, we will explore
    other practices that we have not applied in this book but that should be considered
    for real-world applications to ensure reliability and scalability as complexity
    grows. We will review the decisions behind organizing the project code in modules,
    the approaches to applying frontend styling, server-side rendering with data only
    for selective views, and how React interfaces may be composed to manage state
    across components. We will also look at ways to improve security, add testing
    to the projects, and optimize bundling with webpack. Finally, we will wrap up
    with suggestions for enhancing, and steps for extending, the applications built.
    With these insights, you will be better equipped to prepare your full-stack MERN
    projects for the real world.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns with modularity in the application structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering the options for CSS styling solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side rendering with data for selected views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ES6 classes for stateful versus purely functional components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding on whether to use Redux or Flux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security enhancements for storing user credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing test code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing bundle sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add new features to existing applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of concerns with modularity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building the MERN stack applications in this book, we followed a common
    folder structure across each application. We employed a modular approach by dividing
    and grouping the code based on relevance and common functionality. The idea behind
    creating these smaller and distinct sections in the code is to make sure each
    section addresses a separate concern, so individual sections can be reused, as
    well as developed and updated independently. In the following section, we will
    review this structure and its benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the application folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the application folder structure, we kept the client-side and server-side
    code separate with further subdivisions within these two sections. This gave us
    some freedom to design and build the frontend and backend of the application independently.
    At the project root level, the `client` and `server` folders were the main divisions,
    as shown in the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In these `client` and `server` folders, we divided the code further into subfolders
    that mapped to unique functionalities. We did this by dividing models, controllers,
    and routes in the server for specific features, and grouping all components related
    to a feature in one place on the client side. In the following sections, we will
    review the divisions within the `server` and `client` folders.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the server side, we divided the code according to functionality, by separating
    code that defines business models from code implementing routing logic, and controller
    code that responds to client requests at these routes. Within the `server` folder,
    we maintained three main sections, as shown in the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this structure, each folder contains code with a specific purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`models`: This folder is meant to contain all of the Mongoose schema model
    definitions in separate files, with each file representing a single model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`routes`: This folder contains all routes that allow the client to interact
    with the server, with routes placed in separate files that may be associated with
    a model in the `models` folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controllers`: This folder contains all of the controller functions that define
    logic to respond to incoming requests at the defined routes. These controllers
    are divided into separate files corresponding to the relevant model and route
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As demonstrated throughout the book, these specific separations of concerns
    for the code on the server side allowed us to extend the server developed for
    the skeleton application by just adding the required model, route, and controller
    files. In the next section, we will go over the divisions in the client-side code
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client-side code for the MERN applications consists primarily of React
    components. In order to organize the component code and related helper code in
    a reasonable and understandable manner, we separated the code into folders related
    to a feature entity or unique functionality, as shown in the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding structure, we placed all of the auth-related components and
    helper code in the `auth` folder; common and basic components, such as the `Home` and `Menu`
    components, in the `core` folder; and then we made `post` and `user` folders for
    all of the post-related or user-related components in the respective folders.
  prefs: []
  type: TYPE_NORMAL
- en: This separation and grouping of components based on features allowed us to extend
    the frontend views in the skeleton application for each application that followed,
    by adding a new feature-related component code folder, as required, to the `client`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the client and server code, and also modularizing the code within
    these divisions, made it easier to extend the different applications we developed
    throughout the book. In the final section of this chapter, we will further demonstrate the
    advantages of this modularized approach of separating the application code, as
    we outline the general workflow that can be followed to add a new feature to any
    of the existing applications developed in this book. In the next section, we will
    explore the different options available for defining and applying styling to the
    frontend React components, which will be a necessary decision for every full-stack
    MERN project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CSS styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When discussing **user interface** (**UI**) implementations for the applications
    in this book, we chose not to focus on the details of the CSS styling code applied
    and instead relied mostly on the default Material-UI stylings. However, given
    that implementing any UI requires us to consider styling solutions, we will briefly
    look at some of the options that are available.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to adding CSS styles to the frontend, there are a number of options,
    each with pros and cons. In the following sections, we will discuss the two most
    common options, which are external style sheets and inline styles, along with
    the relatively newer approach of writing CSS in JavaScript, or, more specifically,
    JSS, which is used in Material-UI components and hence also for the applications
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: External style sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: External style sheets allow us to define CSS rules in separate files, which
    can be injected into the necessary view. Placing CSS styles in external style
    sheets this way was once considered the best practice because it enforced the
    separation of style and content, allowing reusability and also maintaining modularity
    if a separate CSS file was created for each component.
  prefs: []
  type: TYPE_NORMAL
- en: However, as web development technologies continue evolving, the demands of better
    CSS organization and performance are no longer met by this approach. For example,
    using external style sheets while developing frontend views with React components
    limits our control over updating styles based on the component state. Moreover,
    loading external CSS for React applications requires additional webpack configurations
    with `css-loader` and `style-loader`.
  prefs: []
  type: TYPE_NORMAL
- en: When applications grow and share multiple style sheets, it also becomes impossible
    to avoid selector conflicts because CSS has a single global namespace. Hence,
    though external style sheets may be enough for simple and trivial applications,
    as an application grows, other options for using CSS become more relevant. In
    the next section, we will look at the option of adding styles directly inline.
  prefs: []
  type: TYPE_NORMAL
- en: Inline styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inline CSS is a style defined and applied directly to individual elements in
    the view. Although this takes care of some of the problems faced when using external
    style sheets, such as eliminating the issue of selector conflicts and allowing
    state-dependent styles, it takes away reusability and introduces a few problems
    of its own, such as limiting the CSS features that can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Using only inline CSS for a React-based frontend has important limitations for
    growing applications, such as poor performance because all of the inline styles
    are recomputed at each render, and inline styles are slower than class names,
    to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: Inline CSS may seem like an easy fix in some cases, but it does not serve as
    a good option for overall usage. In the next section, we will explore the option
    to add CSS styles using JavaScript, which addresses some of the issues of using
    inline and external styles.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Style Sheets (JSS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSS allows us to write CSS styles using JavaScript in a declarative way. This
    also means that all the features of JavaScript are now available for writing CSS,
    making it possible to write reusable and maintainable styling code.
  prefs: []
  type: TYPE_NORMAL
- en: JSS works as a JS to CSS compiler that takes JS objects, where keys represent
    class names and values represent corresponding CSS rules, and then generates the
    CSS along with scoped class names.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, JSS generates unique class names by default when it compiles JSON
    representations to CSS, eliminating the chances of selector conflicts that could
    be faced with external style sheets. Moreover, unlike inline styles, the CSS rules
    that are defined with JSS can be shared across multiple elements and all CSS features
    can be used in the definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Material-UI uses JSS to style its components, and, as a result, we used JSS
    to apply Material-UI themes and also custom CSS to the components developed for
    the frontend views in all of the applications. Based on the utility of each approach,
    you can choose to use one or a combination of external style sheets, inline styles,
    or JSS for styling the frontend of your full-stack application. In the next section,
    we will review the approaches to and relevance of incorporating server-side rendering
    of the React frontend in a full-stack MERN application.
  prefs: []
  type: TYPE_NORMAL
- en: Selective server-side rendering with data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we developed the frontend of the base skeleton application in [Chapter
    4](6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml), *Adding a React Frontend to Complete
    MERN*, we integrated basic server-side rendering in order to load client-side
    routes directly from the browser address bar when the request went to the server.
    In this server-side rendering implementation, while rendering the React component's
    server-side, we did not consider loading the data from the database for the components
    that displayed data. The data only loads in these components when the client-side
    JavaScript takes over after the initial load of the server side-rendered markup.
  prefs: []
  type: TYPE_NORMAL
- en: We did update this implementation to add server-side rendering with data for
    the individual media detail pages in the MERN Mediastream application, which was
    discussed in [Chapter 12](d10817c4-6f74-4ef2-90f4-182466e95b33.xhtml), *Customizing
    the Media Player and Improving the SEO*. In this case, we decided to render this
    specific view with data by injecting data into the server side-generated markup
    of the React frontend. The reasoning behind this selective server-side rendering
    with data only for specific views can be based on certain desired behaviors for
    the view in question, as discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: When is server-side rendering with data relevant?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing server-side rendering with data for all of the React views in
    an application can get complicated, and will be additional work if we need to
    consider views with client-side authentication or views consisting of multiple
    data sources. In many cases, it may be unnecessary to tackle these complexities
    if the view does not require server-side rendering with data. In order to judge
    whether a view needs to be server-rendered with data, answer the following questions
    for the specific view to make your decision:'
  prefs: []
  type: TYPE_NORMAL
- en: Is it important for the data to be displayed in the initial load of the view
    when JavaScript may not be available in the browser?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the view and its data need to be SEO-friendly?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading data in the initial load of the page may be relevant from a usability
    perspective, so it really depends on the use case for the specific view. For SEO,
    server-side rendering with data will give search engines easier access to the
    data content in the view; so, if this is crucial for the view in question, then
    adding server-side rendering with data is a good idea. In the next section, we
    will go over the varied approaches of composing the React frontend in a full-stack
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Using stateful versus pure functional components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building a UI with React components, composing the views with more stateless
    functional components can make the frontend code manageable, clean, and easier
    to test. However, some components will require the state or life cycle Hooks to
    be more than pure presentational components. In the following sections, we will
    look at what it takes to build stateful and stateless functional React components,
    when to use one or the other, and how often.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful React components with ES6 classes or Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can define stateful React components with ES6 classes or by using Hooks without
    writing a class. React components defined using ES6 classes have access to life
    cycle methods, the `this` keyword, and can manage state with `setState` when building
    stateful components. Similarly, React components defined with a function can also
    access some of these features using Hooks, such as managing state with the `useState` Hook,
    in order to build stateful components.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful components allow us to build interactive components that can manage
    to change data in the state, and propagate any business logic that needs to be
    applied across the UI. Generally, for complex UIs, stateful components should
    be higher-level container components that manage the state of the smaller, stateless
    functional components they are composed of. In comparison, these simpler stateless
    components can be defined as pure functions, as discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless React components as pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React components can be defined as stateless functional components using the
    ES6 class syntax or as pure functions. The main idea is that a stateless component
    does not modify state and only receives props.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code defines a stateless component using the ES6 class syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This component, although defined with a class, does not use state. The same
    component can also be defined using JavaScript pure functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A pure function always gives the same output when given the same input without
    any side effects. Modeling React components as pure functions enforces the creation
    of smaller, more defined, and self-contained components that emphasize UI over
    business logic as there is no state manipulation in these components. These kinds
    of components are composable, reusable, and easy to debug and test. In the next
    section, we will discuss how to combine stateful and stateless components when
    designing the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the UI with stateful components and stateless functional components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When thinking about the component composition for a UI, you can design the root
    or a parent component as a stateful component that will contain child components
    or as the composable components that only receive props and cannot manipulate
    state. All the state-changing actions and life cycle issues will be handled by
    the root or parent component, and the changes will be propagated to the child
    components.
  prefs: []
  type: TYPE_NORMAL
- en: In the applications developed for this book, there is a mixture of stateful
    higher-level components and smaller stateless components. For example, in the
    MERN Social application, the `Profile` component modifies the state for stateless
    child components, such as the `FollowProfileButton` and `FollowGrid` components.
    There is scope for refactoring some of the larger components that were developed
    in this book into smaller, more self-contained components, and this should be
    considered before extending the applications to incorporate more features.
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaway that can be applied to new component designs, or when refactoring
    existing components, is that as the React application grows and gets more complex,
    it is better to have more stateless functional components added to higher-level
    stateful components that are in charge of managing state for the inner components.
    In the next section, we will briefly discuss popular libraries and patterns that
    can be utilized on top of React to handle state management across growing React
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redux or Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When React applications begin to grow and become more complex, managing communication
    between components can become problematic. When using regular React, the way to
    communicate is to pass down values and callback functions as props to the child
    components. However, this can be tedious if there are a lot of intermediary components
    that the callback must pass through. To address these state communication and
    management-related issues as the React application grows, people turn to use React
    with libraries and architecture patterns such as Redux and Flux.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is outside the scope of this book to delve into the details of integrating
    React with the Redux library or the Flux architecture, but you can consider these
    options for their growing MERN applications while keeping the following in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Redux and Flux utilize patterns that enforce changing states in a React application
    from a central location. A trick to avoid using Redux or Flux in React applications
    of manageable sizes is to move all state changes up the component tree to the
    parent components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smaller applications work just as well without Flux or Redux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more about using React with Redux at [https://redux.js.org/](https://redux.js.org/),
    and about using React with Flux at [facebook.github.io/flux/](http://facebook.github.io/flux/).
  prefs: []
  type: TYPE_NORMAL
- en: You can choose to integrate Flux or Redux based on your application size and
    complexity. In the next section, we will discuss the security implementations
    applied to the MERN applications developed in this book and the possible enhancements
    that could be made.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the MERN applications developed for this book, we kept the auth-related security
    implementations simple by using **JSON web tokens** (**JWTs**) as an authentication
    mechanism and by storing hashed passwords in the user collection. The approaches
    followed in these implementations are standard practices for adding authentication
    to a web application. However, there are advanced options available for adding
    more layers of security, if that is required for certain applications. In the
    following sections, we will go over the security choices made for building the
    applications in this book and point to possible enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: JSON web tokens – client-side or server-side storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the JWT authentication mechanism, the client side becomes responsible for
    maintaining the user state. Once the user signs in, the token sent by the server
    is stored and maintained by the client-side code on browser storage, such as `sessionStorage`.
    Hence, it is also up to the client-side code to invalidate the token by removing
    it when a user signs out or needs to be signed out. This mechanism works out well
    for most applications that require minimal authentication to protect access to
    resources. However, for instances where it may be necessary to track user sign-ins,
    sign-outs, and to let the server know that a specific token is no longer valid
    for signing in, just the client-side handling of the tokens is not enough.
  prefs: []
  type: TYPE_NORMAL
- en: For these cases, the implementation discussed for handling JWT tokens on the
    client side can be extended to storage on the server side as well. In the specific
    case of keeping track of invalidated tokens, a MongoDB collection can be maintained
    by the server to store these invalidated tokens as a reference, which is moderately
    similar to how it is done for storing session data on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: The thing to be cautious about and to keep in mind is that storing and maintaining
    auth-related information on both the client and server side may be overkill in
    most cases. Therefore, it is entirely up to the specific use case and the related
    trade-offs to be considered. In the next section, we will review our options for
    storing user passwords securely.
  prefs: []
  type: TYPE_NORMAL
- en: Securing password storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While storing user credentials for authentication in the user collection, we
    made sure that the original password string provided by the user was never stored
    directly in the database. Instead, we generated a hash of the password along with
    a salt value using the `crypto` module in Node.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `user.model.js` from our applications, we defined the following functions
    to generate the hashed `password` and `salt` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this implementation, every time a user enters a password to sign in, a
    hash is generated with the salt. If the generated hash matches the stored hash,
    then the password is correct; otherwise, the password is wrong. So, in order to
    check whether a password is correct, the salt is required, and therefore it is
    stored with the user details in the database along with the hash.
  prefs: []
  type: TYPE_NORMAL
- en: This is the standard practice for securing passwords stored for user authentication,
    but there are other advanced approaches that may be explored if a specific application's
    security requirements demand it. Some options that can be considered include multi-iteration
    hashing approaches, other secure hashing algorithms, limiting the number of login
    attempts per user account, and multi-level authentication with additional steps,
    such as answering security questions or entering security codes. These options
    can add more layers of security as needed. In the next section, we will discuss
    options for adding test code in full-stack React applications, which is essential
    for building sturdy production-ready applications.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though discussing and writing test code is outside the scope of this book, it
    is a crucial part of developing reliable software. As full-stack JavaScript applications
    become more mainstream over time, the need for better testing capabilities is
    producing a good number of testing tools in this ecosystem. In the following sections,
    we will first look at some of the popular testing tools that are available for
    testing the different parts of a MERN-based application. Then, to help you get
    started with writing test code for the MERN applications developed in this book,
    we will also discuss an example of adding a client-side test to the MERN Social
    application from [Chapter 5](27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml), *Growing
    the Skeleton into a Social Media Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Testing tools for full-stack JavaScript projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A whole range of testing tools is available for incorporating testing and maintaining
    code quality in full-stack JavaScript projects. These include tools that can help
    with performing static analysis on the code to maintain readability, and with
    integrating unit testing, integration testing, and end-to-end testing in MERN-based
    applications. In the following sections, we will highlight a few of these popular
    testing tools that can be used with the projects in this book, such as ESLint
    for static analysis, Cypress for frontend testing, and Jest for comprehensive
    testing in JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis with ESLint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good practice for improving and maintaining code quality is to use a linting
    tool with your project. Linting tools perform static analysis on the code to find
    problematic patterns or behaviors that violate specified rules and guidelines.
    Linting code in a JavaScript project can improve overall code readability and
    also help you to find syntax errors before the code is executed. For linting in
    MERN-based projects, you can explore ESLint, which is a JavaScript linting utility
    that allows developers to create their own lint rules.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about using and customizing ESLint at [eslint.org](http://esling.org).
    You can choose to use the Airbnb JavaScript Style Guide ([github.com/airbnb/javascript](https://github.com/airbnb/javascript))
    to define your lint rules with `eslint-config-airbnb`**.**
  prefs: []
  type: TYPE_NORMAL
- en: You can configure ESLint in your preferred editor and make it a seamless part
    of your development workflow. This will help you to maintain standards in your
    code while you are writing it. In the next section, we will take a look at Cypress,
    which can help to test any code that runs in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing with Cypress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cypress provides a complete set of tools for testing the frontend of modern
    web applications. Using Cypress, we can write end-to-end tests, unit tests, and
    integration tests for the frontend of our MERN-based applications. Cypress also
    provides its own locally installed test runner, allowing us to write and run tests,
    and debug in real time in the browser as we build the application.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about using Cypress at [cypress.io](https://www.cypress.io/) to
    get started with setting up end-to-end testing for JavaScript applications in
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Performing UI testing with Cypress will allow you to ship out your projects
    more confidently, as you will be able to catch more bugs early on before they
    are encountered by the end users of the application. In the next section, we will
    discuss Jest, which can be used to add tests to any JavaScript code base.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensive testing with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest is a comprehensive testing framework for JavaScript. Although it has been
    more commonly known for testing React components, it can be used for general-purpose
    testing with any JavaScript library or framework. Among the many JavaScript testing
    solutions in Jest, it provides support for mocking and snapshot testing, comes
    with an assertion library, and tests in Jest are written in the **Behavior-Driven
    Development** (**BDD**) style.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Jest, read the documentation at [https://facebook.github.io/jest/docs/en/getting-started.html](https://facebook.github.io/jest/docs/en/getting-started.html).
  prefs: []
  type: TYPE_NORMAL
- en: Besides testing the React components, Jest can be also be adapted to write test
    code for the Node-Express-Mongoose-based backend as required. Hence, it is a solid
    testing option to add test code for MERN applications. In the next section, we
    will explore how you can use Jest to add a test to the MERN Social application,
    which was developed in  [Chapter 5](27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml),
    *Growing the Skeleton into a Social Media Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test to the MERN Social application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to demonstrate how to get started with adding tests to MERN applications,
    we will set up Jest and use it to add a client-side test to the MERN Social application.
    Before defining a test case, followed by writing and running the corresponding
    test code, first, we will set up for testing by installing the necessary packages,
    defining the test run script, and creating a folder for the test code, as discussed
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to set up Jest and integrate the test code with our projects, we first
    need to install the relevant Node packages. The following packages will be required
    in order to write the test code and run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jest`: To include the Jest testing framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`babel-jest`: To compile JS code for Jest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-test-renderer`: To create a snapshot of the DOM tree rendered by a React
    DOM without using a browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install these packages as `devDependencies`, run the following `yarn` command
    from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once these packages are installed, we can start adding tests after configuring
    the test runner script, as discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the script to run tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to run any test code that we write using Jest, we will define a script
    command to run the tests. We will update the run scripts defined in `package.json` in
    order to add a script for running tests with the `jest` command, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this script defined, if we run `yarn test` from the command line, it will
    prompt Jest to find the test code in the application folders and run the tests.
    In the next section, we will add the folder that will contain the test code files
    for the project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a tests folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add the client-side test in the MERN Social application, we will create a
    folder, called `tests`, in the client folder, which will contain test files relevant
    to testing the React components. When the test command is run, Jest will look
    for the test code in these files.
  prefs: []
  type: TYPE_NORMAL
- en: The test case for this example will be a test on the `Post` component in the
    frontend of the MERN Social application, and we will add tests for the `Post`
    component in a file called `post.test.js`. This file will be placed in the `tests`
    folder. Now that we have a file ready for adding the test code, in the next section,
    we will demonstrate how to add an example test case.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the MERN Social application, we will write a test to check whether the delete
    button on a post is only visible when the signed-in user is also the creator of
    the post. This means that the delete button will only be a part of the rendered
    Post view if the `_id` of the authenticated user is the same as the `postedby`
    value of the post data being rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement this test case, we will add code that takes care of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defines dummy data for a post and an `auth` object containing authenticated
    user details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocks the methods in `auth-helper.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Defines the test, and, within the test definition, does the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declares the `post` and `auth` variables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the return value of the mocked `isAuthenticated` method to the dummy `auth`
    object
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses `renderer.create` to create the `Post` component with the required dummy
    props passed and wrapped in `MemoryRouter` to provide the props related to `react-router`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generates and matches snapshots
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code in `post.test.js` to incorporate the steps described for this specific
    test will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we first defined dummy posts and `auth` objects, and then added
    the test case for checking the visibility of the delete option. In this test case,
    we mocked the `isAuthenticated` method and rendered the `Post` component using
    the dummy post data. Then, we generated a snapshot with this rendered component,
    which will be matched with the expected snapshot. In the next section, we will
    discuss how generated snapshots are compared in this test.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a snapshot of the correct Post view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time this test is run, we will provide it with the values required
    to generate the correct snapshot of the Post view. The correct snapshot for this
    test case will contain the delete button when the `user._id` of the `auth` object
    is equal to the `postedBy` value of the `post` object. This snapshot is generated
    when the test is run for the first time, and it will be used for comparison in
    future test executions.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of snapshot testing in Jest basically records snapshots of rendered
    component structures to compare them to future renderings. When the recorded snapshot
    and the current rendering don't match, the test fails, indicating that something
    has changed. In the next section, we will go over the steps of running the test
    and checking the test output.
  prefs: []
  type: TYPE_NORMAL
- en: Running and checking the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the code that we added to the `post.test.js` file, the dummy `auth` object
    and the `post` object refer to the same user; therefore, running this test in
    the command line will prompt Jest to generate a snapshot that will contain the
    delete option and also pass the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the test, go into the project folder from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The test output generated when this command runs will show that the test passed,
    as portrayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a50bd38-3fca-4012-abb8-168378bc6265.png)'
  prefs: []
  type: TYPE_IMG
- en: The recorded snapshot that is generated, when this test runs successfully for
    the first time, is added automatically to a `_snapshots_` folder in the `tests`
    folder. This snapshot represents the state where the delete button is rendered
    in the view since the authenticated user is also the creator of the post.
  prefs: []
  type: TYPE_NORMAL
- en: We can now check whether the test actually fails when the component is rendered
    with an authenticated user that is not the creator of the post. To perform this
    check, we will update the dummy data objects by changing the `user._id`, so it
    does not match the `postedBy` value, and then run the test again. This will give
    us a failed test, as the current rendering will no longer have a delete button
    that is present in the recorded snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following test log, the test fails and indicates that the rendered
    tree does not match the recorded snapshot since the elements representing the
    delete button are missing in the received value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/255aafac-37de-4e30-a94b-99ccd2fa2fa7.png)'
  prefs: []
  type: TYPE_IMG
- en: We have a client-side test for checking whether a signed-in user can view the
    delete button on their posts. Using this setup, more tests can be added for the
    MERN application utilizing the capabilities of Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test code will make the application you develop reliable and also help
    ensure code quality. Using tools such as ESLint, Cypress, and Jest, we can incorporate
    different ways of ensuring the overall quality of MERN-based applications. In
    the next section, we will move on to discussing ways to optimize the bundling
    of the application code.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the bundle size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you develop and grow a MERN application, chances are the size of the bundles
    produced with webpack will also grow, especially if large third-party libraries
    are used. Larger bundle sizes will affect performance and increase the initial
    load time of the application. We can make changes in the code to ensure we don't
    end up with large bundles and also utilize features packed in webpack to help
    optimize bundling.
  prefs: []
  type: TYPE_NORMAL
- en: Before going into the code to update it for bundle size optimization, you can
    also get familiar with the default optimization options that are part of webpack.
    In the MERN applications, we used the `mode` config to utilize the default settings
    for both development and production mode. To view an overview of the options that
    are available, please refer to the article at [https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a](https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a).
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will highlight concepts such as code splitting
    and dynamic imports, which can give us control over producing smaller bundles
    and decreasing load time.
  prefs: []
  type: TYPE_NORMAL
- en: Code splitting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of loading all the code at once in one bundle, we can use the code splitting
    feature supported by webpack to lazy-load parts of the application code as currently
    needed by the user. After we modify the application code to introduce code-splitting,
    webpack can create multiple bundles rather than one large bundle. These bundles
    can be loaded dynamically at runtime, allowing us to improve the performance of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about code splitting support in webpack and how to make necessary
    changes to the setup and configuration, take a look at the guidelines in the documentation
    at [https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/).
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to introduce code splitting for the application code,
    but the most important syntax you will come across for this purpose is the dynamic
    `import()`. In the next section, we will look at how to use `import()` with our
    MERN applications.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic import()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dynamic `import()` is a function-like version of the regular import, and it
    enables the dynamic loading of JS modules. Using `import(moduleSpecifier)` will
    return a promise for the module namespace object of the requested module. When
    using regular static imports, we import a module at the top of the code and then
    use it in the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, if we were to use dynamic `import()` instead of adding the static
    import at the beginning, the code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to import and load the module when the code requires it. While
    bundling the application code, webpack will treat calls to `import()` as split
    points and automatically start code splitting by placing the requested module
    and its children into a separate chunk from the main bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to optimize the bundling of the frontend React code by applying code
    splitting at a given component, we need to pair dynamic `import()` with React
    Loadable – a higher-order component for loading components with promises. As an
    example, we will look at the shopping cart developed in Chapter 8, *Extending
    the Marketplace for Orders and Payments*. While building the interface of the
    cart, we composed the `Cart` component by importing and adding the `Checkout`
    component to the view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To introduce code splitting here and import the `Checkout` component dynamically,
    we can replace the static import at the beginning with a `Loadable` Checkout,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Making this change and using webpack to build the code again will produce a
    `bundle.js` file of reduced size, and generate another smaller bundle file representing
    the split code, which will now only load when the `Cart` component is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Route-based code splitting is also another option besides using dynamic imports.
    It can be an effective approach for introducing code splitting in React apps that
    use routes to load components in the view. To learn more about implementing code
    splitting, specifically with React Router, view the article at [https://tylermcginnis.com/react-router-code-splitting/](https://tylermcginnis.com/react-router-code-splitting/).
  prefs: []
  type: TYPE_NORMAL
- en: We can apply code-splitting mechanisms across our application code as required.
    The thing to keep in mind is that effective code splitting will depend on using
    it correctly and applying it at the right places in the code – places that will
    benefit in optimization from resource-load prioritization. In the next section,
    we will outline the steps that can be repeated to add new features to the MERN
    applications developed in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the chapters of this book, as we developed each application, we added
    features by extending the existing code in a common and repeatable number of steps.
    In this final section, we will review those steps, setting a guideline for adding
    more features to the current versions of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the server code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a specific feature that will require data persistence and APIs to allow
    the views to manipulate the data, we can start by extending the server code and
    adding the necessary models, routes, and controller functions, as outlined in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the data persistence aspect of the feature, design the data model considering
    the fields and values that need to be stored. Then, define and export a Mongoose
    schema for this data model in a separate file, and place it in the `server/models`
    folder. With the data structure defined and ready for the database, you can move
    on to adding the API endpoints for manipulating this data, as discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to manipulate and access the data that will be stored in the database
    based on the model, you need to design the APIs relevant for the desired feature.
    To start implementing the APIs, you have to add the corresponding controller methods
    and route declarations, as discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Adding controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the APIs decided, add the corresponding controller functions that will
    respond to the requests to these APIs in a separate file in the `server/controllers`
    folder. The controller functions in this file should access and manipulate the
    data for the model defined for this feature. Next, we will look at how to declare
    the routes that will invoke these controller methods when the requests come in.
  prefs: []
  type: TYPE_NORMAL
- en: Adding routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the implementation of the backend APIs, corresponding routes need
    to be declared and mounted on the Express app. In a separate file in the `server/routes`
    folder, first, declare and export the routes for these APIs, assigning the relevant
    controller functions that should be executed when a specific route is requested.
    Then, load these new routes on the Express app in the `server/express.js` file,
    just like the other existing routes in the application.
  prefs: []
  type: TYPE_NORMAL
- en: This will produce a working version of the new backend APIs that can be run
    and checked from a REST API client application. Then, these APIs can be used in
    the frontend views for the feature being developed, which you will add by extending
    the client code, as discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the client code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the client side, first, design the views required for the feature, and determine
    how these views will incorporate user interaction with the data relevant to the
    feature. Then, add the fetch API code to integrate with the new backend APIs,
    define the new components that represent these new views, and update the existing
    code to include these new components in the frontend of the application, as outlined
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the API fetch methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before adding the fetch methods that will make calls to the backend APIs, you
    will determine a location for placing the new frontend code. In the client folder,
    create a new folder to house the components and helper code relevant to the feature
    module being developed. Then, to integrate the new backend APIs with the frontend
    of the application, define and export the corresponding fetch methods in a separate
    file in this new components folder. Finally, you can populate this folder with
    the React components that will be the frontend of this feature, as discussed in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start adding the UI for the feature, you can create and export new React
    components that represent views for the desired feature in separate files in the
    new folder. If authentication is required, you can integrate it into these new
    components using the existing auth-helper methods. Once the React components are
    implemented, they need to be loaded into the main application view, as discussed
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Loading new components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to incorporate these new components into the frontend, the components
    either need to be added into existing components or rendered at their own client-side
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: If these new components need to be rendered at individual routes, update the
    `MainRouter.js` code to add new routes that load these components at given URL
    paths. Then, these URLs can be used as links to load the components from other
    views in the application, or directly by visiting the URL from the browser address
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the new components need to become part of existing views, then import
    the components into the existing components to add them to the view as desired.
  prefs: []
  type: TYPE_NORMAL
- en: The new components can also be linked with existing components, such as in the
    `Menu` component, by linking to new components that were added with individual
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: With the components integrated and connected to the backend, the new feature
    implementation is complete. These steps can be repeated to add on even more new
    features to the existing MERN-based applications built throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we reviewed and elaborated on some of the best practices
    that we used while building the MERN applications in this book, highlighted areas
    of improvement, gave pointers to address issues that may crop up when applications
    grow, and, finally, set down steps to continue developing more features into the
    existing applications.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that modularizing the application's code structure helped to extend the
    application easily, choosing to use JSS over inline CSS and external style sheets
    kept the styling code contained and easy to work with, and only implementing server-side
    rendering for specific views as required kept unnecessary complications out of
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the benefits of creating fewer stateful components that are composed
    of smaller and more defined stateless functional components, and how this can
    be applied while refactoring existing components or designing new components to
    extend the applications. For growing applications that may run into issues with
    managing and communicating state across hundreds of components, we pointed to
    options such as Redux and Flux, which may be considered to address these issues.
  prefs: []
  type: TYPE_NORMAL
- en: For applications that may have higher demands for stricter security enforcement,
    we looked back at our existing implementation of user authentication with JWT
    and password encryption and discussed possible extensions for improved security.
  prefs: []
  type: TYPE_NORMAL
- en: We highlighted testing tools such as ESLint, Cypress, and Jest. Then, we used
    Jest to demonstrate how test code can be added to the MERN applications and discussed
    how good practices, such as writing test code and using a linting tool, can improve
    code quality besides ensuring reliability in an application.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at bundle optimization features, such as code splitting, that
    can help to improve performance by reducing the initial bundle size, and by lazy-loading
    parts of the application as required.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we reviewed and set down the repeatable steps that were used throughout
    the book, which you can use as a guideline moving forward to extend the MERN applications
    by adding more features as desired.
  prefs: []
  type: TYPE_NORMAL
