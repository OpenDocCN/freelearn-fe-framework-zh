- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Combining Streams
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并流
- en: So far, we have learned about the reactive pattern to fetch data as streams
    and have covered error-handling patterns. However, we have only explored the asynchronous
    data emitted from only one stream. What if we want to work with the asynchronous
    data emitted from different streams? Do you know how we can proceed?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了关于反应式模式以流的形式获取数据以及错误处理模式。然而，我们只探索了来自单个流的异步数据。如果我们想处理来自不同流的异步数据呢？你知道我们该如何进行吗？
- en: 'Luckily, RxJS ships with one of the most powerful concepts: combining streams.
    Combining streams is the process of bringing together the emissions of multiple
    Observables in one stream. This allows you to explore multiple sources of asynchronous
    data as if they were a single stream. The main idea behind combining streams is
    manipulating asynchronous data in a more structured way.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，RxJS附带了一个最强大的概念之一：合并流。合并流是将多个Observables的排放汇集到一个流中的过程。这允许你将多个异步数据源视为单个流来探索。合并流背后的主要思想是以更结构化的方式处理异步数据。
- en: This chapter revolves around a common use case, which is filtering data; we
    will resolve this by combining streams. We will start by explaining the filtering
    requirement, and then we will explore the imperative, classic pattern that can
    be used to implement this requirement, followed by a declarative, reactive implementation.
    Finally, we will highlight the common pitfalls to avoid when combining streams
    and discuss best practices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章围绕一个常见用例展开，即过滤数据；我们将通过合并流来解决它。我们首先将解释过滤需求，然后我们将探索可以用来实现此需求的命令式、经典模式，接着是一个声明式、反应式实现。最后，我们将突出合并流时需要避免的常见陷阱，并讨论最佳实践。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Defining the filtering requirement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义过滤需求
- en: Exploring the imperative pattern for filtering data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索用于过滤数据的命令式模式
- en: Exploring the declarative pattern for filtering data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索用于过滤数据的声明式模式
- en: Highlighting common pitfalls and best practices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突出常见陷阱和最佳实践
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code of this chapter (except the samples) is available at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap05](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap05).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码（除示例外）可在[https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap05](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap05)找到。
- en: Defining the filtering requirement
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义过滤需求
- en: 'In our recipe application, we want to filter the displayed recipes according
    to certain criteria to refine the results. The following figure shows the implementation
    of the mockup described in the *View 1 – The landing page* section of [*Chapter
    2*](B21180_02.xhtml#_idTextAnchor031), *Walking Through* *our Application*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的食谱应用中，我们希望根据某些标准过滤显示的食谱以细化结果。以下图显示了在[*第2章*](B21180_02.xhtml#_idTextAnchor031)的*视图1
    – 登录页面*部分中描述的模拟实现，*浏览我们的应用*：
- en: '![Figure 5.1 – The filtering requirement](img/B21180_05_1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 过滤需求](img/B21180_05_1.jpg)'
- en: Figure 5.1 – The filtering requirement
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 过滤需求
- en: From a user’s perspective, the user will fill out some criteria in the **Filters**
    area and click on the **See results** button to see the results that match the
    filled criteria. The user can filter by using the keywords in the recipe title,
    recipe category, ingredients, tags, preparation, and cooking time. A filtering
    functionality is a must in the majority of applications that display data collections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，用户将在**过滤器**区域填写一些标准，并点击**查看结果**按钮来查看符合填写标准的成果。用户可以通过食谱标题、食谱类别、成分、标签、准备时间和烹饪时间中的关键词进行过滤。过滤功能是大多数显示数据集合的应用程序所必需的。
- en: 'When it comes to filtering, there are a lot of strategies you can adopt, and
    the choice depends highly on the size of your data:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到过滤时，你可以采用很多策略，选择取决于你的数据量大小：
- en: If you have a small volume of data that you can fetch entirely on the client
    side, then it is unnecessary to perform server-side filtering; instead, it is
    faster to perform client-side filtering, which will not harm your application’s
    performance.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你可以完全在客户端获取少量数据，那么执行服务器端过滤是不必要的；相反，执行客户端过滤更快，而且不会损害应用程序的性能。
- en: If you have a large amount of data, then you should be lazy when loading your
    data through pagination or virtual scroll in order to enhance the performance
    and the user experience as well. Therefore, in this case, conducting server-side
    filtering is unavoidable since you don’t have all the data on the client side.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有很多数据，那么在通过分页或虚拟滚动加载数据时应该谨慎，以提高性能和用户体验。因此，在这种情况下，进行服务器端过滤是不可避免的，因为你没有在客户端拥有所有数据。
- en: For demonstration purposes, we will filter only 11 recipes in total. So we’re
    going to use client-side filtering (however, note that the reactive pattern we’re
    going to discuss does not need a specific type of filtering – it can be used with
    both client and server-side filtering).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将只过滤总共 11 道食谱。因此，我们将使用客户端过滤（然而，请注意，我们将讨论的响应式模式不需要特定的过滤类型——它可以与客户端和服务器端过滤一起使用）。
- en: Exploring the imperative pattern for filtering data
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索过滤数据的命令式模式
- en: In this section, we will explore the imperative way to approach filtering data
    from the UI to the logic of filtering.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨从 UI 到过滤逻辑的命令式方法来处理数据过滤。
- en: 'Let’s start by setting up the UI code by creating a new standalone component,
    `RecipesFilterComponent`, under `src/app`. It is responsible for displaying the
    different filters to refine the initial results. The HTML template code of the
    filter component looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置 UI 代码开始，创建一个新的独立组件 `RecipesFilterComponent`，位于 `src/app` 目录下。它负责显示不同的过滤器以细化初始结果。过滤器组件的
    HTML 模板代码如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the previous code, we used Angular reactive forms to display the search
    criteria inside a form. Then, we included two buttons: the `filterResults()` in
    the `OnClick` callback. This method will replace the displayed recipes with those
    that match the filled criteria. Then, the UI will be updated automatically, thanks
    to the Angular change detection mechanism.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 Angular 响应式表单在表单内显示搜索条件。然后，我们包含了两个按钮：在 `OnClick` 回调中的 `filterResults()`。此方法将替换显示的食谱与填充的准则相匹配的食谱。然后，由于
    Angular 的变更检测机制，UI 将自动更新。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about Reactive forms, please refer to [https://angular.dev/guide/forms/reactive-forms](https://angular.dev/guide/forms/reactive-forms).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有关响应式表单的更多详细信息，请参阅 [https://angular.dev/guide/forms/reactive-forms](https://angular.dev/guide/forms/reactive-forms)。
- en: 'Now, let’s move to `RecipesListComponent`, where we should consider a small
    change in the template. We should bind the `[value]` input of the `p-dataView`
    component to a new property, the `filteredRecipes` property, that holds the filtered
    results. The `filteredRecipes` property initially holds all the recipes requested
    from the server. This is what the template looks like:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到 `RecipesListComponent`，在那里我们应该考虑对模板进行的小幅修改。我们应该将 `p-dataView` 组件的 `[value]`
    输入绑定到一个新的属性，即 `filteredRecipes` 属性，该属性包含过滤后的结果。`filteredRecipes` 属性最初包含从服务器请求的所有食谱。模板如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The focus is not the HTML template, of course, but the process of filtering;
    however, it is important to point out when providing a complete workflow.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重点当然不是 HTML 模板，而是过滤过程；然而，在提供完整的工作流程时指出这一点很重要。
- en: 'Now let’s look at the logic of the classic pattern in `RecipesListComponent`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `RecipesListComponent` 中的经典模式逻辑：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s break down what is happening. Here, we declared three variables:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析正在发生的事情。在这里，我们声明了三个变量：
- en: '`filteredRecipes`: The array that contains the filtered recipes. It is the
    property binded in the HTML template to the `[value]` input of the `p-dataview`
    component.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filteredRecipes`：包含过滤后食谱的数组。它是 HTML 模板中绑定到 `p-dataview` 组件 `[value]` 输入的属性。'
- en: '`recipes`: The initial array of recipes.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recipes`：初始的食谱数组。'
- en: '`destroy$`: A subject to clean up the subscription.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroy$`：一个用于清理订阅的主题。'
- en: Then, in the `ngOninit()` method, we called the recipes (`recipes$`) that represent
    our Observable recipes. After that, we subscribe to it and initialize the recipes
    and `filteredRecipes` arrays with the emitted array from `recipes$`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `ngOninit()` 方法中，我们调用了代表我们的可观察食谱的 `recipes`（`recipes$`）。之后，我们订阅它，并用从 `recipes$`
    发射的数组初始化食谱和 `filteredRecipes` 数组。
- en: As we don’t use the async pipe in this example, we should clean up the subscription
    manually using the `takeUntil()` pattern or `takeUntilDestroyed()`, as explained
    in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047), *Fetching Data* *as Streams*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这个例子中我们没有使用异步管道，我们应该手动使用 `takeUntil()` 模式或 `takeUntilDestroyed()` 来清理订阅，正如在
    [*第 3 章*](B21180_03.xhtml#_idTextAnchor047) 中解释的，*作为流获取数据*。
- en: The `filterResults(recipe:Recipe)` method called when clicking on the `recipe.title;`,
    containing the value the user filled out in the title input.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击`recipe.title;`时，会调用`filterResults(recipe:Recipe)`方法，该方法包含用户在标题输入框中填写的值。
- en: Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For demonstration purposes, in this imperative implementation example, we’ve
    chosen to display `RecipesFilterComponent` within `RecipesListComponent`. This
    approach involves sending an output event, which encapsulates the filter form’s
    value available in `RecipesFilterComponent`, to `RecipesListComponent`. Subsequently,
    `RecipesListComponent` executes the `filterResult` method based on this input
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，在这个命令式实现示例中，我们选择在`RecipesListComponent`中显示`RecipesFilterComponent`。这种方法涉及发送一个输出事件，该事件封装了在`RecipesFilterComponent`中可用的过滤器表单的值，然后`RecipesListComponent`根据这个输入执行`filterResult`方法
- en: 'If you use server-side filtering, in other words, if you have a service that
    handles filtering data according to a given criteria, then `filterResults()` should
    call a backend service and will look like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用服务器端过滤，换句话说，如果你有一个根据给定标准处理过滤数据的服务的，那么`filterResults()`应该调用后端服务，其形式如下：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That’s it! It works fine, and I would say this is probably how most people would
    approach implementing filtering in an Angular application. The imperative way
    is kind of the obvious way to do it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！它运行得很好，我会说这可能是大多数人实现Angular应用程序中过滤功能的方法。命令式方法几乎是显而易见的方法。
- en: However, you may have noticed that we are no longer able to take advantage of
    `recipes$` as a stream in the template, as explained in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047),
    *Fetching Data as Streams*. Plus, what if your recipes service emits new recipes?
    This will overwrite the active filter until the user clicks on **See results**
    again to update the list with the current filter. This can be handled imperatively,
    of course, but it is a shame to use Observables and not take advantage of the
    power of reactivity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能已经注意到，我们不能再像在模板中那样利用`recipes$`作为流了，正如在[*第3章*](B21180_03.xhtml#_idTextAnchor047)中解释的，*以流的形式获取数据*。此外，如果你的食谱服务发出新的食谱呢？这将覆盖活动过滤器，直到用户再次点击**查看结果**来更新带有当前过滤器的列表。这当然可以通过命令式处理，但使用Observables而不利用响应式能力的力量是件遗憾的事。
- en: So, without further ado, let’s explore a better way to implement the filtering
    requirement by using a declarative and reactive way using the fundamentals of
    combining streams.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，无需多言，让我们探索一种更好的方法来实现过滤需求，即使用组合流的基本原理以声明式和响应式的方式。
- en: Remember, I always really want to highlight the classic way and the reactive
    way straight after to enable a smooth transition from imperative to declarative.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我总是想立即突出经典方法和响应式方法，以便从命令式到声明式的平稳过渡。
- en: Exploring the declarative pattern for filtering data
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索过滤数据的声明式模式
- en: You should think of everything as a stream; this is the golden rule!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该把所有事情都想象成一条流；这是黄金法则！
- en: We have `recipes$`, which is already our **data stream**, but what if we consider
    the click on the **See results** button as a stream as well? We will call it the
    **action stream** and consider it an asynchronous data flow; we don’t know when
    it happens, but every time the user clicks on **See results**, the action stream
    should emit the value of the filter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了`recipes$`，它已经是我们的**数据流**了，但如果我们把点击**查看结果**按钮也视为一条流呢？我们将称之为**动作流**，并认为它是一个异步的数据流；我们不知道它何时发生，但每次用户点击**查看结果**时，动作流都应该发出过滤器的值。
- en: 'So, in total, we need two streams:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总共我们需要两个流：
- en: '*The data stream*: In our case, it is `recipes$`, which is defined in `RecipesListComponent`,
    which we created in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047), *Fetching
    Data* *as Streams*:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据流*：在我们的案例中，它是`recipes$`，它在`RecipesListComponent`中定义，我们是在[*第3章*](B21180_03.xhtml#_idTextAnchor047)中创建的，*以流的形式获取数据*：'
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*The action stream*: In our case, it’s named `filterRecipesSubject`; it is
    responsible for emitting the latest value of the filter every time the user clicks
    on the `RecipesService` service (which we also created in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047),
    *Fetching Data as Streams* as follows:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动作流*：在我们的案例中，它被命名为`filterRecipesSubject`；它负责在用户每次点击`RecipesService`服务（我们也在[*第3章*](B21180_03.xhtml#_idTextAnchor047)中创建了，*以流的形式获取数据*）时发出最新的过滤器值：'
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s explain the previous code block. Here, we created two attributes:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们解释前面的代码块。在这里，我们创建了两个属性：
- en: 'A `BehaviorSubject` named `filterRecipeSubject` to prevent the external parts
    of the code from emitting values in the stream, erroring out, or completing the
    stream. We initialized `filterRecipeSubject` with a default value—an empty object—defined
    in the constructor argument. We can use either `Subject` or `BehaviorSubject`
    to create our action stream:'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `filterRecipeSubject` 的 `BehaviorSubject`，以防止代码的外部部分在流中发出值、出错或完成流。我们在构造函数参数中初始化
    `filterRecipeSubject` 为一个默认值——一个空对象。我们可以使用 `Subject` 或 `BehaviorSubject` 来创建我们的动作流：
- en: '`Subject` is a special type of Observable in that it enables multicasting.
    We will explore multicasting in detail in [*Chapter 9*](B21180_09.xhtml#_idTextAnchor146),
    *Demystifying Multicasting*. For now, keep in mind that a subject is an observer
    and an Observable at the same time, so you can use it to share values among observers.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subject` 是一种特殊的可观察对象，它使得多播成为可能。我们将在 [*第9章*](B21180_09.xhtml#_idTextAnchor146)
    *揭秘多播* 中详细探讨多播。现在，请记住，主题既是观察者又是可观察对象，因此你可以用它来在观察者之间共享值。'
- en: '`BehaviourSubject` is a special type of subject that requires an initial value
    and always retains the last value to emit it to new subscribers. In other words,
    if you have any subscribers coming late to the game, they will get the last value
    emitted by the stream. This will always give you a value when you subscribe. We
    will discuss why we used `BehaviourSubject` instead of `Subject` at the end of
    the chapter.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BehaviourSubject` 是一种特殊的主题，它需要一个初始值，并且总是保留最后一个值以将其发送给新的订阅者。换句话说，如果你有任何后来加入游戏的订阅者，他们将获得流中发出的最后一个值。当你订阅时，这总会给你一个值。我们将在本章末尾讨论为什么我们使用
    `BehaviourSubject` 而不是 `Subject`。'
- en: A `filterRecipeAction$` (created from `filterRecipeSubject` through the method
    `asObservable()`) so that the other parts of the app can subscribe to and get
    the data.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `filterRecipeSubject` 的 `asObservable()` 方法创建一个 `filterRecipeAction$`（用于防止代码的外部部分在流中发出值、出错或完成流）。我们使用构造函数参数中的默认值——一个空对象——初始化
    `filterRecipeSubject`。我们可以使用 `Subject` 或 `BehaviorSubject` 来创建我们的动作流：
- en: 'So, just to recap, the `RecipesService` service will now look like this after
    adding the previous code block:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了总结，在添加之前的代码块后，`RecipesService` 服务将看起来像这样：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, it is time to combine the streams. Both of the streams rely on each other;
    when `recipes$` emits a new value, the filter should stay active, and when the
    filter emits a new value, the recipes list should be updated accordingly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候合并流了。这两个流都相互依赖；当 `recipes$` 发出一个新值时，过滤器应该保持活跃，而当过滤器发出一个新值时，食谱列表应该相应地更新。
- en: What we are really trying to do is get information from both streams. Whenever
    you want to join information from multiple Observables, you should think of the
    RxJS combination strategy. Instead of getting the data from both streams separately,
    we can combine it to form a single new stream. RxJS has a set of combination operators
    to use in that matter. In the next section, we will explore one of the most used
    combination operators, which is the `combineLatest` operator.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正试图做的是从两个流中获取信息。每次你想从多个可观察对象中合并信息时，你应该考虑 RxJS 的组合策略。我们不是分别从两个流中获取数据，而是可以将其组合成一个单一的新流。RxJS
    有一个用于此目的的组合操作符集。在下一节中，我们将探讨最常用的组合操作符之一，即 `combineLatest` 操作符。
- en: The combineLatest operator
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: combineLatest操作符
- en: 'The `combineLatest` operator will combine the latest values emitted by the
    input Observables. So, every time one of the Observables emits, `combineLatest`
    will emit the last emitted value from each. Does that make sense? If not, don’t
    worry; we will detail it further by using a marble diagram as usual:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineLatest` 操作符将组合输入可观察对象发出的最新值。所以，每当其中一个可观察对象发出时，`combineLatest` 将发出每个可观察对象发出的最后一个值。这说得通吗？如果不通，别担心；我们将像往常一样使用宝石图进一步详细说明：'
- en: '![Figure 5.2 – The combineLatest marble diagram](img/B21180_05_2.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – combineLatest的宝石图](img/B21180_05_2.jpg)'
- en: Figure 5.2 – The combineLatest marble diagram
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – combineLatest的宝石图
- en: 'Let’s break this down:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: The first line in the marble diagram represents the timeline of the first input
    Observable.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 晶石图的第一行表示第一个输入可观察对象的时序。
- en: The second line represents the timeline of the second input Observable. So,
    `combineLatest` has two inputs.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行表示第二个输入可观察对象的时序。因此，`combineLatest` 有两个输入。
- en: The last line represents the timeline of the output Observable returned from
    the `combineLatest` operator.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一行表示从 `combineLatest` 操作符返回的输出可观察对象的时序。
- en: Now, let’s dig deeper into the execution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入执行过程。
- en: The first Observable emitted the value `combineLatest`. Why? Because `combineLatest`
    will not emit until all the input Observables emit one value each. So, when the
    second Observable emits `combineLatest` will emit **a1**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个Observable发出了`combineLatest`的值。为什么？因为`combineLatest`不会发出，直到所有输入Observables各自发出一个值。所以，当第二个Observable发出时，`combineLatest`将发出**a1**。
- en: Bear in mind that `combineLatest` will not emit an initial value until each
    Observable emits at least one value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`combineLatest`将不会发出初始值，直到每个Observable至少发出一个值。
- en: Then, the first Observable emitted another value, `combineLatest` will emit
    the last value emitted by each input stream, which is `combineLatest` will emit
    **b2**, and so on and so forth.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第一个Observable发出了另一个值，`combineLatest`将发出每个输入流发出的最后一个值，即`combineLatest`将发出**b2**，以此类推。
- en: Let’s come back to our example and see how we can combine the data stream and
    the action stream that we have just created in order to filter results reactively
    using the `combineLatest` operator.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子，看看我们如何结合我们刚刚创建的数据流和动作流，以便使用`combineLatest`操作符反应性地过滤结果。
- en: 'In `RecipesListComponent`, we will create a new stream named `filteredRecipes$`,
    which represents the result of combining the data and the action stream:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RecipesListComponent`中，我们将创建一个新的流名为`filteredRecipes$`，它代表数据和动作流的组合结果：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, here, we used the `combineLatest` operator and passed to it (as a parameter)
    an array of two values: the first one is the `recipes$` data stream, and the second
    one is the `filterRecipeAction$` action stream. `combineLatest` will then return
    an array of two values (as the number of input Observables): the first element
    of the array is the last emitted value from the first stream, and the second element
    of the array is the last emitted value from the second stream. It respects the
    order.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，我们使用了`combineLatest`操作符，并将其传递给一个包含两个值的数组（作为参数）：第一个值是`recipes$`数据流，第二个值是`filterRecipeAction$`动作流。`combineLatest`将返回一个包含两个值的数组（作为输入Observables的数量）：数组的第一个元素是第一个流发出的最后一个值，数组的第二个元素是第二个流发出的最后一个值。它尊重顺序。
- en: 'Now, we will use `filteredRecipes$` from the `RecipesListComponent` template,
    where we will bind it to the `[value]` input of `p-dataview` so that the following
    occurs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`RecipesListComponent`模板中的`filteredRecipes$`，我们将将其绑定到`p-dataview`的`[value]`输入，以便发生以下情况：
- en: '`filteredRecipes$` should return all the recipes when loading the page'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filteredRecipes$`应在加载页面时返回所有食谱'
- en: '`filteredRecipes$` should return only the recipes that match the selected criteria
    when filtering'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filteredRecipes$`应在过滤时仅返回符合选定标准的食谱'
- en: 'Then, the HTML code of the `RecipesListComponent` template will look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`RecipesListComponent`模板的HTML代码将看起来像这样：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the template, we have included both the `RecipesList` and `RecipesFilter`
    components. This separation of components enhances the maintainability and readability
    of the codebase, promoting a modular and scalable architecture for the application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们包含了`RecipesList`和`RecipesFilter`组件。这种组件的分离增强了代码库的可维护性和可读性，促进了应用的模块化和可扩展架构。
- en: Still, there is one change that we need to make in `RecipesListComponent`. In
    our UI, we want to display all the recipes when loading the page and the filtered
    recipes when refining the results; because of this, we need to edit `filteredRecipes$`
    so it should not return the result of the combination directly (and in most cases,
    that won’t happen anyway). Instead, we will process the result of the combination
    (the returned array), take the information that we need from the combined streams,
    and transform it into whatever we need.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还需要在`RecipesListComponent`中做出一个更改。在我们的UI中，我们希望在加载页面时显示所有食谱，在细化结果时显示过滤后的食谱；因此，我们需要编辑`filteredRecipes$`，使其不直接返回组合的结果（而且在大多数情况下，这种情况根本不会发生）。相反，我们将处理组合的结果（返回的数组），从组合的流中获取所需的信息，并将其转换为所需的任何形式。
- en: 'In this case, we want to modify the result stream so that rather than just
    giving us the latest recipes and criteria values, it will give us an array of
    recipes filtered by the received criteria as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望修改结果流，使其不仅提供最新的食谱和标准值，而且还提供一个按接收到的标准过滤的食谱数组，如下所示：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result of the combination is the `resultAsArray` parameter. The first element,
    `resultAsArray [0]`, represents the last emitted recipes from `recipes$`, and
    the second element, `resultAsArray [1]`, represents the last emitted criteria
    from `filterRecipesAction$`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的结果是`resultAsArray`参数。第一个元素，`resultAsArray [0]`，代表来自`recipes$`的最后发出的菜谱，第二个元素，`resultAsArray
    [1]`，代表来自`filterRecipesAction$`的最后发出的标准。
- en: 'However, we can do even better! We can enhance the code using the array destructuring
    technique like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以做得更好！我们可以使用数组解构技术来增强代码，如下所示：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the `recipes` parameter represents the first element of the returned array,
    and the `filter` parameter represents the second element of the returned array.
    After `:`, we have the parameter types, and that’s it. So, instead of obtaining
    the elements by using the index directly, the array destructuring technique provides
    you with a way to name the array elements and get the values directly from those
    variables. Finally, we used the `filter` method to filter the list of recipes
    that match the criteria.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`recipes`参数代表返回数组的第一元素，`filter`参数代表返回数组的第二元素。在`:`之后，我们有参数类型，就是这样。所以，我们不是直接使用索引来获取元素，数组解构技术提供了一种命名数组元素并直接从这些变量中获取值的方法。最后，我们使用了`filter`方法来过滤符合标准的菜谱列表。
- en: At this point, we put in place all the mechanisms to filter the values reactively.
    The last thing left to do is update the filter value every time it changes, and
    this is what we’re going to explore in the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实施了一切机制来反应性地过滤值。剩下要做的就是每次过滤器值改变时更新过滤器值，这就是我们将在下一节中要探讨的内容。
- en: Updating the filter value
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新过滤器值
- en: 'As we said, every time the user clicks on the `filterRecipesAction$` should
    emit the criteria so that our `combineLatest` re-executes and returns the filtered
    recipes. To achieve this, we created a new method called `updateFilter` in the
    `RecipesService` that takes the filter value as input and simply emits it using
    the next method over the `filterRecipesSubject` subject:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，每次用户点击`filterRecipesAction$`都应该发出标准，以便我们的`combineLatest`重新执行并返回过滤后的菜谱。为了实现这一点，我们在`RecipesService`中创建了一个名为`updateFilter`的新方法，它接受过滤器值作为输入，并简单地使用`filterRecipesSubject`主题的下一个方法发出它：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we will call this method in `RecipesFilterComponent` when the user clicks
    on the **See results** button to update the filter value:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当用户点击**查看结果**按钮时，我们将在`RecipesFilterComponent`中调用此方法来更新过滤器值：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We passed the value of the “Filters” form created in the `RecipesFilterComponent`
    to the `updateFilter` method. That’s it; now, on every emission of criteria, it
    will re-execute the `combineLatest` operator and will consequently filter the
    values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`RecipesFilterComponent`中创建的“过滤器”表单的值传递给`updateFilter`方法。就是这样；现在，每当标准发出时，它将重新执行`combineLatest`运算符，并相应地过滤值。
- en: 'To summarize, this is what the complete code looks like in `RecipesListComponent`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，这是`RecipesListComponent`中的完整代码看起来是这样的：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `RecipesFilterComponent` component looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecipesFilterComponent`组件看起来是这样的：'
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, `RecipesService` looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`RecipesService`看起来是这样的：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code is available in the GitHub repository.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可在GitHub仓库中找到。
- en: Now, let’s answer the question, Why did we choose `BehaviorSubject` instead
    of `Subject`?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回答这个问题，为什么我们选择`BehaviorSubject`而不是`Subject`？
- en: Between loading the page and clicking on `filteredRecipes$` to hold all the
    recipes, as explained in the *Combine streams* section. If we use a plain `Subject`,
    the criteria will only get emitted when we click on the button. That means that
    when loading the page, only `recipes$` is emitted, and `combineLatest` will wait
    for all the streams to emit one value before emitting more. In our UI, we would
    then get an empty list.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载页面和点击`filteredRecipes$`以保留所有菜谱之间，如*组合流*部分所述。如果我们使用普通的`Subject`，标准只有在点击按钮时才会发出。这意味着在加载页面时，只有`recipes$`会发出，`combineLatest`会在所有流发出一个值之前等待，然后才会发出更多的值。在我们的UI中，我们将会得到一个空列表。
- en: However, when we use `BehaviorSubject`, it will emit the default value for all
    the subscribers immediately, so `combineLatest` will emit a first value, and everything
    will work fine and that’s it. Seems like magic, right?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用`BehaviorSubject`时，它将立即为所有订阅者发出默认值，因此`combineLatest`将发出第一个值，然后一切都会正常工作，就是这样。看起来像是魔法，对吧？
- en: 'Here’s an example of the filtered recipes when searching for `Lemon` in the
    keyword:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是搜索关键字`Lemon`时过滤后的菜谱示例：
- en: '![Figure 5.3 – Filtered recipes](img/B21180_05_3.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 过滤后的食谱](img/B21180_05_3.jpg)'
- en: Figure 5.3 – Filtered recipes
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 过滤后的食谱
- en: To sum up, in order to resolve the use case we’ve looked at in this chapter,
    we started with defining the data stream responsible for getting the data; then,
    we created the action stream. Afterwards, we combined the streams, did some manipulation
    on the combined stream, binded it in our template, and, finally, updated the filter
    value in the filter event.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，为了解决本章中我们查看的使用案例，我们首先定义了负责获取数据的 数据流；然后，我们创建了动作流。之后，我们将流合并，对合并的流进行了一些操作，将其绑定到我们的模板中，并最终在过滤事件中更新了过滤值。
- en: Now, let’s highlight some of the common pitfalls when using `combineLatest`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们突出一些在使用 `combineLatest` 时常见的陷阱。
- en: Highlighting common pitfalls and best practices
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突出常见的陷阱和最佳实践
- en: 'Here are some common pitfalls or scenarios to avoid when using `combineLatest`
    in RxJS:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些在使用 RxJS 中的 `combineLatest` 时应避免的常见陷阱或场景：
- en: Unnecessary subscriptions
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不必要的订阅
- en: '`combineLatest` subscribes to all provided Observables automatically. Make
    sure you unsubscribe from the returned subscription when you no longer need the
    combined values, especially for long-running or infinite Observables. This prevents
    memory leaks and unnecessary processing.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineLatest` 会自动订阅所有提供的 Observables。确保当你不再需要合并的值时，从返回的订阅中取消订阅，特别是对于长时间运行或无限的
    Observables。这可以防止内存泄漏和不必要的处理。'
- en: Missing or incomplete values
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺失或不完整的数据
- en: '`combineLatest` only emits a value when all its source Observables have emitted
    at least one value. If any Observable completes or throws an error before all
    have emitted, `combineLatest` will also complete or error out, respectively. Consider
    using the `withLatestFrom` operator if you only need the latest value from one
    Observable combined with the entire emission history from another.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineLatest` 仅在其所有源 Observables 至少发射了一个值时才发射一个值。如果任何 Observables 在所有 Observables
    发射之前完成或抛出错误，`combineLatest` 也会相应地完成或出错。如果你只需要一个 Observables 的最新值与另一个 Observables
    的整个发射历史相结合，考虑使用 `withLatestFrom` 操作符。'
- en: Performance overhead
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能开销
- en: Combining a large number of Observables with `combineLatest` can introduce performance
    overhead. Evaluate the need for combining so many streams and consider using simpler
    operators, such as `forkJoin`, if you only need all emissions as a single array
    once all the Observables complete. We will delve into the `forkJoin` operator
    in [*Chapter 11*](B21180_11.xhtml#_idTextAnchor170), *Performing* *Bulk Operations*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `combineLatest` 组合大量 Observables 可能会引入性能开销。评估组合这么多流的需求，并考虑如果只需要所有 Observables
    完成后作为一个单一数组，使用更简单的操作符，如 `forkJoin`。我们将在[*第 11 章*](B21180_11.xhtml#_idTextAnchor170)中深入探讨
    `forkJoin` 操作符，*执行批量操作*。
- en: Confusing error handling
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混乱的错误处理
- en: '`combineLatest` propagates errors from any of its source Observables. If error
    handling is complex, consider using custom operators to handle errors for each
    Observable individually before combining them. Implement proper error handling
    by using the `catchError` operator on individual Observables or using a custom
    operator that combines the emissions and errors from each source.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineLatest` 会从其任何源 Observables 中传播错误。如果错误处理复杂，考虑使用自定义操作符来分别处理每个 Observables
    的错误，然后再将它们组合。通过在单个 Observables 上使用 `catchError` 操作符或使用一个结合每个源发射和错误的自定义操作符来实现适当的错误处理。'
- en: As you can see, `combineLatest` is a powerful operator for combining multiple
    Observables, but it’s important to understand its behavior and potential pitfalls
    in order to use it effectively in your RxJS applications. Choose the right operator
    based on your specific use case and prioritize clear and maintainable code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`combineLatest` 是一个强大的操作符，用于组合多个 Observables，但了解其行为和潜在陷阱对于在 RxJS 应用程序中有效地使用它非常重要。根据您的特定用例选择正确的操作符，并优先考虑清晰和可维护的代码。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we embarked on a journey through filtering data, beginning
    with an exploration of the imperative pattern. We then transitioned to one of
    the most commonly used RxJS patterns for data filtering, which can be used in
    many use cases where data updates are triggered by actions. By delving deeper,
    we outlined the different steps needed to implement the reactive pattern, from
    creating the streams to their combination, using the `combineLatest` operator.
    We learned how this operator works and how we can use it in a practical implementation.
    We used the combined stream in our template and handled data updates reactively.
    Finally, we explored some of the common pitfalls to avoid when using `combineLatest`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了通过过滤数据的学习之旅，从对命令式模式的探索开始。然后，我们过渡到了RxJS中最常用的数据过滤模式之一，该模式可以在许多由动作触发数据更新的用例中使用。通过深入研究，我们概述了实现响应式模式所需的不同步骤，从创建流到使用`combineLatest`操作符进行组合。我们学习了该操作符的工作原理以及如何在实际应用中使用它。我们在模板中使用了组合流，并响应式地处理数据更新。最后，我们探讨了在使用`combineLatest`时需要避免的一些常见陷阱。
- en: Combining streams is a fundamental concept in RxJS that enables you to build
    more complex and powerful asynchronous data processing. It allows you to join
    data from various sources and apply operators and transformations to create new
    streams that meet your specific application requirements.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 组合流是RxJS中的一个基本概念，它使您能够构建更复杂和强大的异步数据处理。它允许您从各种来源合并数据，并应用操作符和转换来创建满足您特定应用需求的新流。
- en: Now that we know about this useful pattern, let’s move on to the next reactive
    pattern, transforming streams.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这个有用的模式，让我们继续学习下一个响应式模式，即转换流。
