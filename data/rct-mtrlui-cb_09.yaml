- en: Snackbars - Temporary Messages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Snackbars - 临时消息
- en: 'In this chapter, you''ll learn about the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下内容：
- en: Snackbar content
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Snackbar内容
- en: Controlling visibility with state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态控制可见性
- en: Snackbar transitions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Snackbars过渡
- en: Positioning Snackbars
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Snackbars的位置
- en: Error boundaries and error Snackbars
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误边界和错误Snackbars
- en: Snackbars with actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有操作的Snackbars
- en: Queuing Snackbars
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Snackbars排队
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Material-UI comes with a `Snackbar` component that's used to display messages
    for users. These messages are brief, short-lived, and don't interfere with the
    main application components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI附带一个用于向用户显示消息的`Snackbar`组件。这些消息简短、短暂，不会干扰主要应用程序组件。
- en: Snackbar content
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Snackbar内容
- en: Text is the most common form of `Snackbar` message content that you'll display
    for your users. Because of this, the `Snackbar` component makes it straightforward
    to set message content and display the snackbar.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 文本是你在为用户显示的`Snackbar`消息内容中最常见的形式。因此，`Snackbar`组件使得设置消息内容和显示snackbar变得简单直接。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The `message` property of the `Snackbar` component accepts a string value,
    or any other valid `React` element. Here''s the code that shows you how to set
    the content of the `Snackbar` component and display it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Snackbar`组件的`message`属性接受一个字符串值或任何其他有效的`React`元素。以下代码展示了如何设置`Snackbar`组件的内容并显示它：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the page first loads, you''ll see a snackbar that looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面首次加载时，你会看到一个看起来像这样的snackbar：
- en: '![](img/bc06a237-9745-43d4-a248-8c6f9981fffa.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc06a237-9745-43d4-a248-8c6f9981fffa.png)'
- en: How it works...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By default, a snackbar is nothing fancy, but it renders your text content as
    specified in the `message` property. The `open` property is set to true because
    any other value hides the snackbar.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，snackbar并不复杂，但它将你的文本内容渲染为`message`属性中指定的内容。`open`属性设置为true，因为任何其他值都会隐藏snackbar。
- en: There's more...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `Snackbar` components use `SnackbackContent` components to render the actual
    content that's displayed. In turn, `SnackbarContent` uses `Paper`, which uses
    `Typography`. It's kind of tricky to navigate through all of this indirection,
    but, thankfully, you don't have to. Instead, you can pass properties all the way
    to the `Typography` component from `Snackbar` via the `ContentProps` property.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Snackbar`组件使用`SnackbackContent`组件来渲染实际显示的内容。反过来，`SnackbarContent`使用`Paper`，而`Paper`使用`Typography`。在这个所有间接层中导航可能有点棘手，但幸运的是，你不必这样做。相反，你可以通过`ContentProps`属性将属性一路传递到`Typography`组件。'
- en: 'Let''s say that you wanted to use the `h6` typography variant. Here''s how
    you could do this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要使用`h6`排版变体。以下是你可以这样做的方法：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Any properties that you want to pass to the component used by `Paper` can be
    set by `ContentProps`. Here, you''re passing the `variant` property—which results
    in the following visual change:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要传递给`Paper`组件的任何属性都可以通过`ContentProps`设置。在这里，你正在传递`variant`属性——这会导致以下视觉变化：
- en: '![](img/e10fdf00-cbab-41a8-a9b1-2de68451df9b.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e10fdf00-cbab-41a8-a9b1-2de68451df9b.png)'
- en: The end result is larger text and a wider margin. The aim of this example isn't
    this particular typography change, but rather the idea that you can customize
    `Snackbar` text in the exact same way as you would `Typography` components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是更大的文本和更宽的边距。这个例子不是为了这个特定的排版变化，而是为了说明你可以以与`Typography`组件相同的方式自定义`Snackbar`文本。
- en: You can put as many or as few components as you want into your snackbar content.
    For example, you can pass child components to `Snackbar` instead of in the `message`
    property. However, I would advise keeping your snackbar content as simple as possible.
    The last place where you want to go down a design rabbit hole is in a component
    that's already been designed to handle simple text.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在snackbar内容中放入你想要的任何数量的组件或尽可能少的组件。例如，你可以将子组件传递给`Snackbar`而不是在`message`属性中。然而，我建议尽可能保持你的snackbar内容简单。你不想在已经设计用来处理简单文本的组件中陷入设计陷阱。
- en: See also
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '`Snackbar` demos: [https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar`演示：[https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar` API文档：[https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
- en: Controlling visibility with state
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态控制可见性
- en: Snackbars are displayed in response to something. For example, if a new resource
    in your application is created, then using a `Snackbar` component to relay this
    information to the user is a good choice. If you need to control the state of
    your snackbars, then you need to add a state that controls the visibility of the
    snackbar.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Snackbar是在响应某些事件时显示的。例如，如果你的应用程序中创建了一个新的资源，那么使用 `Snackbar` 组件将此信息传达给用户是一个不错的选择。如果你需要控制Snackbar的状态，那么你需要添加一个控制Snackbar可见性的状态。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The `open` property is used to control the visibility of the snackbar. All
    you need in order to control this property value is a state value that''s passed
    to it. Then, when this state changes, so does the visibility of the snackbar.
    Here''s some code that illustrates the basic idea of state-controlling snackbars:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 属性用于控制Snackbar的可见性。为了控制这个属性的值，你需要传递一个状态值给它。然后，当这个状态改变时，Snackbar的可见性也会随之改变。以下是一些代码示例，说明了如何通过状态控制Snackbar的基本概念：'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you first load the screen, all you''ll see is a SHOW SNACKBAR button:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次加载屏幕时，你将看到的只是一个“显示 Snackbar”按钮：
- en: '![](img/c500fa7d-3e9b-4916-b2d4-8e23d05a8e02.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c500fa7d-3e9b-4916-b2d4-8e23d05a8e02.png)'
- en: 'Clicking on this button shows the snackbar:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此按钮将显示Snackbar：
- en: '![](img/5c17cca7-da80-40a3-a894-455b920c859b.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c17cca7-da80-40a3-a894-455b920c859b.png)'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The component has an `open` state that determines the visibility of the snackbar.
    The value of `open` is passed to the `open` property of `Snackbar`. When the user
    clicks on the SHOW SNACKBAR button, the `showSnackbar()` function sets the `open`
    state to true. As a result, the true value is passed to the `open` property of
    `Snackbar`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 组件有一个 `open` 状态，该状态决定了Snackbar的可见性。`open` 的值传递给了 `Snackbar` 的 `open` 属性。当用户点击“显示
    Snackbar”按钮时，`showSnackbar()` 函数将 `open` 状态设置为 true。结果，true 值被传递给了 `Snackbar`
    的 `open` 属性。
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Once you've displayed a snackbar, you're going to need to be able to close it
    somehow. Once again, the `open` state can hide the snackbar. But how do you change
    the open state back to false? The typical pattern with snackbar messages is to
    have them appear only briefly, after which they're automatically hidden.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦显示了一个Snackbar，你将需要某种方式来关闭它。同样，`open` 状态可以隐藏Snackbar。但如何将 `open` 状态改回 false
    呢？Snackbar消息的典型模式是它们只短暂出现，之后会自动隐藏。
- en: 'By passing two more properties to `Snackbar`, you can enhance this example
    so that the snackbar automatically hides itself after a certain time. Here''s
    the updated code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向 `Snackbar` 传递两个额外的属性，你可以增强这个例子，使得Snackbar在一段时间后自动隐藏。以下是更新后的代码：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A new function—`hideSnackbar()`—was added to the component. This is passed to
    the `onClose` property of `Snackbar`. The `autoHideDuration` component is the
    number of milliseconds that you want the snackbar to stay visible. In this example,
    after five seconds, the `Snackbar` component will call the function passed to
    its `onClose` property. This sets the `open` state to false, which is in turn
    passed to the `open` property of `Snackbar`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 组件中添加了一个新函数——`hideSnackbar()`。这个函数被传递给了 `Snackbar` 的 `onClose` 属性。`autoHideDuration`
    组件是你希望Snackbar保持可见的毫秒数。在这个例子中，五秒后，`Snackbar` 组件将调用传递给其 `onClose` 属性的函数。这会将 `open`
    状态设置为 false，然后这个值被传递给了 `Snackbar` 的 `open` 属性。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Snackbar` demos: [https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar` 演示：[https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar` API 文档：[https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
- en: '`Button` API documentation: [https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button` API 文档：[https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
- en: Snackbar transitions
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Snackbar过渡
- en: You can control the transitions used by `Snackbar` components when it is displayed
    and hidden. The `Snackbar` component directly supports transition customization
    through properties, so you don't have to spend too much time thinking about how
    to implement your snackbar transitions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以控制 `Snackbar` 组件在显示和隐藏时使用的过渡效果。`Snackbar` 组件直接通过属性支持过渡自定义，因此你不需要花费太多时间去思考如何实现你的
    `Snackbar` 过渡效果。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s say that you want to make it easier to change the transition used by
    snackbars throughout your application. You could create a thin wrapper component
    around `Snackbar` that takes care of setting the appropriate properties. Here''s
    what the code looks like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要使整个应用程序中 snackbars 所使用的过渡效果更容易更改。你可以在 `Snackbar` 组件周围创建一个薄的包装组件，负责设置适当的属性。以下是代码的样子：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code renders four buttons and four snackbars. When you first load the
    screen, you''ll only see buttons:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码渲染了四个按钮和四个 snackbars。当你首次加载屏幕时，你只会看到按钮：
- en: '![](img/dedee27e-04ff-445e-b341-67407a1e9064.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dedee27e-04ff-445e-b341-67407a1e9064.png)'
- en: 'Clicking on each of these buttons will display their corresponding `Snackbar`
    component at the bottom of the screen. If you pay attention to the transitions
    used when each of the snackbars is displayed, you''ll notice the difference depending
    on the buttons you press. For example, clicking on the Fade button will use the
    `fade` transition, resulting in the following snackbar:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 点击这些按钮中的每一个将在屏幕底部显示相应的 `Snackbar` 组件。如果你注意观察每个 snackbars 显示时使用的过渡效果，你会注意到根据你按的按钮的不同而有所差异。例如，点击
    Fade 按钮，将使用 `fade` 过渡，结果如下 snackbar：
- en: '![](img/b9daca37-2d08-4039-9988-b0cdd6defdb6.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9daca37-2d08-4039-9988-b0cdd6defdb6.png)'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by looking at the `MySnackbar` component that was created in this
    example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看这个例子中创建的 `MySnackbar` 组件开始：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are two properties of interest here. The first is the `transition` string.
    This is used to look up the transition component to use. For example, the string
    `slide` will use the `Slide` component. The resulting component is used by the
    `TransitionComponent` property. The `Snackbar` components will use this component
    internally to apply the desired transition to your snackbars. The `direction`
    property is used with the `Slide` transition, which is why this property is passed
    to `TransitionProps`. These property values are passed directly to the component
    that's passed to `TransitionComponent`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个有趣的属性。第一个是 `transition` 字符串。它用于查找要使用的过渡组件。例如，字符串 `slide` 将使用 `Slide` 组件。生成的组件由
    `TransitionComponent` 属性使用。`Snackbar` 组件将内部使用此组件来应用您 snackbars 所需要的过渡。`direction`
    属性与 `Slide` 过渡一起使用，这就是为什么这个属性被传递给 `TransitionProps`。这些属性值直接传递给传递给 `TransitionComponent`
    的组件。
- en: The alternative to using `TransitionProps` is to create a higher-order component
    that wraps its own property customization values. But since `Snackbar` is already
    set up to help you pass properties, there's no need to create yet another component
    if you want to avoid doing so.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `TransitionProps` 的替代方法是创建一个高阶组件，它包装自己的属性自定义值。但是，由于 `Snackbar` 已经设置好以帮助您传递属性，如果您想避免创建另一个组件，那么就没有必要再创建一个。
- en: 'Next, let''s look at the component state and the functions that change it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看组件状态及其改变它的函数：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `first`, `second`, `third`, and `fourth` states correspond to their own
    `Snackbar` components. These state values control the visibility of each function,
    and their corresponding setter functions show or hide the snackbars.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`first`、`second`、`third` 和 `fourth` 状态对应于它们自己的 `Snackbar` 组件。这些状态值控制每个函数的可见性，它们对应的设置函数显示或隐藏
    snackbars。'
- en: 'Finally, let''s look at two of the `MySnackbar` components being rendered:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看两个正在渲染的 `MySnackbar` 组件：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Both of these instances use the `slide` transition. However, the `direction`
    property is different for each. The `MySnackbar` abstraction makes it a little
    simpler for you to specify transitions and transition arguments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个实例都使用 `slide` 过渡。然而，每个的 `direction` 属性是不同的。`MySnackbar` 抽象使你指定过渡和过渡参数变得稍微简单一些。
- en: See also
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Snackbar` demos: [https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar` 演示：[https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar` API 文档：[https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
- en: '`Slide` API documentation: [https://material-ui.com/api/slide/](https://material-ui.com/api/slide/)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slide` API 文档：[https://material-ui.com/api/slide/](https://material-ui.com/api/slide/)'
- en: '`Grow` API documentation: [https://material-ui.com/api/grow/](https://material-ui.com/api/grow/)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grow` API 文档：[https://material-ui.com/api/grow/](https://material-ui.com/api/grow/)'
- en: '`Fade` API documentation: [https://material-ui.com/api/fade/](https://material-ui.com/api/fade/)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fade` API 文档：[https://material-ui.com/api/fade/](https://material-ui.com/api/fade/)'
- en: Positioning snackbars
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: snackbars 定位
- en: Material-UI Snackbar components have an `anchorOrigin` property that allows
    you to change the position of the snackbar when it's displayed. You might be fine
    using the default positioning of snackbars, but sometimes you'll need this level
    of customization to stay consistent with other parts of your application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI 的 `Snackbar` 组件有一个 `anchorOrigin` 属性，允许你在显示时更改 snackbars 的位置。你可能对
    snackbars 的默认定位很满意，但有时你需要这种程度的定制来保持与其他应用程序部分的统一。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'While you can''t arbitrarily position snackbars on the screen, there are a
    number of options that allow you to change the position of the snackbar. Here''s
    some code that allows you to play around with the `anchorOrigin` property values:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你无法随意在屏幕上定位 snackbars，但有一些选项允许你更改 snackbars 的位置。以下是一些代码，允许你玩转 `anchorOrigin`
    属性值：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When the screen first loads, you''ll see controls for changing the position
    of the snackbar, and the `Snackbar` component in its default position:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次加载时，你会看到用于更改 snackbar 位置的控件，以及默认位置的 `Snackbar` 组件：
- en: '![](img/29816333-2b70-4315-8640-ab8ea3bd3a35.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29816333-2b70-4315-8640-ab8ea3bd3a35.png)'
- en: 'If you change any of the position control values, the snackbar will move to
    the new position. For example, if you changed the vertical anchor to top and the
    horizontal anchor to the right, here''s what you''d see:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改了任何位置控制值，snackbar 将移动到新的位置。例如，如果你将垂直锚点更改为顶部，并将水平锚点更改为右侧，以下是你会看到的内容：
- en: '![](img/2e4851ae-c7fb-46d4-b028-9a224197965f.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e4851ae-c7fb-46d4-b028-9a224197965f.png)'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The two radio button groups in this example are only used to illustrate the
    different position value combinations that are available. In a real application
    where you show snackbars, you wouldn't have the configurable state to change the
    positioning of your snackbars. Instead, you should think of a value passed to
    the `anchorOrigin` property as a configuration value that is set once during startup.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中的两个单选按钮组仅用于说明可用的不同位置值组合。在实际应用中，当你显示 snackbars 时，你不会有可配置的状态来改变 snackbars
    的位置。相反，你应该将传递给 `anchorOrigin` 属性的值视为在启动时设置的一次性配置值。
- en: 'It isn''t good to rely on state values, as is the case in this example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于状态值并不好，就像本例中那样：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instead, you would set the `anchorOrigin` values statically:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你应该静态地设置 `anchorOrigin` 值：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There's more...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Once you know where you want to position your snackbars, you can create your
    own `Snackbar` component that has the `anchorOrigin` values defined. Here''s an
    example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道你想要将 snackbars 定位在哪里，你就可以创建一个具有定义好的 `anchorOrigin` 值的自己的 `Snackbar` 组件。以下是一个示例：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Anywhere in your app that `MySnackbar` is used, the snackbars will be displayed
    in the top-right corner of the screen. Otherwise, `MySnackbar` is just like a
    regular `Snackbar` component.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中任何使用 `MySnackbar` 的地方，snackbar 都将在屏幕的右上角显示。否则，`MySnackbar` 就像是一个普通的
    `Snackbar` 组件。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '`Snackbar` demos: [https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar` 示例：[https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar` API 文档：[https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
- en: Error boundaries and error snackbars
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误边界和错误 snackbars
- en: '**Error boundaries** in React enable you to capture errors that happen when
    your components attempt to render. You can use the `Snackbar` components in your
    error boundaries to display captured errors. Furthermore, you can style snackbars
    so that errors are visually distinctive from normal messages.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**React 中的错误边界**使你能够在组件尝试渲染时捕获错误。你可以在错误边界中使用 `Snackbar` 组件来显示捕获的错误。此外，你可以对
    snackbars 进行样式化，使错误与普通消息在视觉上有所区别。'
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s say that you have an error boundary at the top level of your application
    and you want to use the `Snackbar` component to display error messages to users.
    Here''s an example that shows how you can do this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在应用程序的最高级别有一个错误边界，并且你想使用 `Snackbar` 组件向用户显示错误信息。以下是一个示例，展示了你可以如何做到这一点：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When you load this screen, the `MyButton` component throws an error when it
    is rendered. Here''s what you''ll see:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你加载此屏幕时，`MyButton` 组件在渲染时抛出错误。以下是你会看到的内容：
- en: '![](img/bead05ef-fa91-4b44-bb5e-71077ede8232.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bead05ef-fa91-4b44-bb5e-71077ede8232.png)'
- en: It explicitly throws an error so that you can see the error boundary mechanism
    in action. In a real application, the error could be triggered by any function
    that's called during the rendering process.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它明确地抛出一个错误，这样你就可以看到错误边界机制在起作用。在实际应用中，错误可能是由渲染过程中调用的任何函数触发的。
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by taking a closer look at the `ErrorBoundary` component. It has
    an `error` state that is initially null. The `componentDidCatch()` life cycle
    method changes this state when an error happens:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先更仔细地看看`ErrorBoundary`组件。它有一个初始为null的`error`状态。`componentDidCatch()`生命周期方法在发生错误时改变这个状态：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, let''s take a closer look at the `render()` method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更仔细地看看`render()`方法：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It uses the `error` state to determine whether children should be rendered.
    When the `error` state is non-null, it doesn't make sense to render child components
    because you'll be stuck in an infinite loop of error being thrown and handled.
    The `error` state is also used as the `open` property to determine whether the
    snackbar should be displayed, and as the message text.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`error`状态来确定是否应该渲染子组件。当`error`状态非空时，渲染子组件没有意义，因为你将陷入错误被抛出和处理的无限循环。`error`状态还用作`open`属性，以确定snackbar是否应该显示，以及作为消息文本。
- en: 'The `ContentProps` property is used to style the snackbar so that it looks
    like an error. The `error` class uses `theme` values to change the background
    and text color:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentProps`属性用于样式化snackbar，使其看起来像错误。`error`类使用`theme`值来改变背景和文字颜色：'
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The error boundary used in this example covered the entire application. This
    is good in the sense that you can blanket the entire application with error handling
    in one shot. But this is also bad, because the entire user interface vanishes,
    as the error boundary has no idea which component failed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中使用的错误边界覆盖了整个应用程序。从一方面来说，你可以一次性在整个应用程序中应用错误处理，这是好的。但这也是不好的，因为整个用户界面都消失了，因为错误边界不知道哪个组件失败了。
- en: Because error boundaries are components, you can place as many of them as you
    like at any level of your component tree. This way, you can show Material-UI `error`
    snackbars while keeping the parts of the UI that haven't failed visible on the
    screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为错误边界是组件，你可以在组件树的任何级别放置尽可能多的它们。这样，你可以在屏幕上保持UI中未失败的部分可见的同时显示Material-UI `error`
    snackbars。
- en: 'Let''s change the scope of the error boundary used in the example. First, you
    can change the `MyButton` implementation so that it only throws an error when
    a Boolean property is `true`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改示例中使用的错误边界的范围。首先，你可以更改`MyButton`实现，使其仅在布尔属性为`true`时抛出错误：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now you can render a button with a given label. If `throwError` is `true`,
    then nothing is rendering due to the error. Next, let''s change the markup of
    the example to include multiple buttons and multiple `error` boundaries:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以渲染一个带有指定标签的按钮。如果`throwError`为`true`，则由于错误，没有任何内容渲染。接下来，让我们更改示例的标记，以包含多个按钮和多个`error`边界：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first button renders without any issues. However, if the error boundary
    were all-encompassing as was the case earlier, then this button wouldn''t be displayed.
    The second button throws an error because the `throwError` property is true. Because
    this button has its own error boundary, it doesn''t prevent other parts of the
    UI that are working fine from rendering. Here''s what you''ll see when you run
    the example now:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个按钮渲染时没有任何问题。然而，如果错误边界像之前那样是全包容性的，那么这个按钮就不会显示。第二个按钮抛出错误，因为`throwError`属性为真。因为这个按钮有自己的错误边界，所以它不会阻止其他工作正常的UI部分渲染。现在当你运行示例时，你会看到以下内容：
- en: '![](img/d99b7b87-8bdd-4a81-a7de-f75153243672.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d99b7b87-8bdd-4a81-a7de-f75153243672.png)'
- en: See also
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: React `error` boundaries: [https://reactjs.org/docs/error-boundaries.html](https://reactjs.org/docs/error-boundaries.html)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React `error`边界：[https://reactjs.org/docs/error-boundaries.html](https://reactjs.org/docs/error-boundaries.html)
- en: '`Snackbar` demos:[ https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar` 示例：[ https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar` API 文档：[https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
- en: Snackbars with actions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有操作的Snackbars
- en: The purpose of Material-UI snackbars is to display brief messages for the user.
    Additionally, you can embed the next course of action for the user in the snackbar.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI snackbars的目的是向用户显示简短的消息。此外，你还可以在snackbar中嵌入用户的下一步操作。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s say that you want a simple button in your snackbar that closes the snackbar.
    This could be useful for closing the snackbar before it automatically closes.
    Alternatively, you might want to require the user to explicitly acknowledge the
    message by having to close it manually. Here''s the code to add a close button
    to a `Snackbar` component:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想在Snackbar中添加一个简单的按钮来关闭Snackbar。这可以在Snackbar自动关闭之前关闭它很有用。或者，您可能希望用户通过手动关闭来明确确认消息。以下是向`Snackbar`组件添加关闭按钮的代码：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When the screen first loads, you''ll only see a button:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次加载时，您将只看到一个按钮：
- en: '![](img/a61bb63f-4c29-47b1-8335-33d0566a7e9d.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a61bb63f-4c29-47b1-8335-33d0566a7e9d.png)'
- en: 'Clicking on this button will display the snackbar:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此按钮将显示Snackbar：
- en: '![](img/8d5f0fca-e179-4564-a0cd-eb26271e5357.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d5f0fca-e179-4564-a0cd-eb26271e5357.png)'
- en: The close icon button on the right side of the snackbar, when clicked on, closes
    the snackbar.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Snackbar右侧的关闭图标按钮，当点击时，会关闭Snackbar。
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The close button is added to the `Snackbar` component via the `action` property,
    which accepts either a node or an array of nodes. The `SnackbarContent` component
    takes care of applying styles to align the actions within the snackbar.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭按钮是通过`action`属性添加到`Snackbar`组件中的，该属性接受节点或节点数组。`SnackbarContent`组件负责应用样式以在Snackbar内对齐操作。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When users create new resources in your application, you probably want to let
    them know when the resource is created successfully. Snackbars are a good tool
    for this because they don't force the user away from anything that they might
    be in the middle of. What would be nice is if you included an action button in
    the snackbar that linked to the newly created resource.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在您的应用程序中创建新资源时，您可能希望让他们知道资源是否成功创建。Snackbar是完成这个任务的理想工具，因为它不会强制用户离开他们可能正在进行的事情。如果Snackbar中包含一个链接到新创建资源的操作按钮，那就更好了。
- en: 'Let''s modify this example so that, when the user clicks on the CREATE button,
    they''ll see a snackbar with the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改这个示例，当用户点击CREATE按钮时，他们会看到一个包含以下内容的Snackbar：
- en: A brief message
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短的消息
- en: A close action
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭操作
- en: A link to the new resource
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新资源的链接
- en: 'Let''s add routes from `react-router-dom` and then add the link to the snackbar.
    Here''s the new markup:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加来自`react-router-dom`的路由，并将链接添加到Snackbar中。以下是新的标记：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first route is for the index page, so, when the screen first loads, the
    user will see the button that''s rendered by this route:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条路由是用于索引页面的，因此，当屏幕首次加载时，用户将看到由该路由渲染的按钮：
- en: '![](img/7991362c-463f-4c48-ad8e-66e363af3fac.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7991362c-463f-4c48-ad8e-66e363af3fac.png)'
- en: 'When you click on this button, you''ll see the snackbar that includes a link
    to the newly-created resource:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击此按钮时，您将看到一个包含指向新创建资源的链接的Snackbar：
- en: '![](img/99462ff9-de18-4dae-821e-da1340720b9e.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99462ff9-de18-4dae-821e-da1340720b9e.png)'
- en: Now you've given the user an easy way to navigate to the resource without disrupting
    what they're currently doing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经为用户提供了一个轻松导航到资源的途径，而不会打断他们当前正在做的事情。
- en: See also
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: React router guide: [https://reacttraining.com/react-router/web/guides/quick-start](https://reacttraining.com/react-router/web/guides/quick-start)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React路由指南：[https://reacttraining.com/react-router/web/guides/quick-start](https://reacttraining.com/react-router/web/guides/quick-start)
- en: '`Snackbar` demos: [https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar` 演示：[https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar` API 文档：[https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
- en: '`Button` API documentation: [https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按钮` API 文档：[https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
- en: '`IconButton` API documentation: [https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图标按钮` API 文档：[https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
- en: Queuing snackbars
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列Snackbar
- en: With larger Material-UI applications, you're likely to find yourself in a situation
    where more than one snackbar message is sent in a very short period of time. To
    deal with this, you can create a queue for all snackbar messages so that only
    the most recent notification is displayed, and so that the transitions are handled
    properly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的Material-UI应用程序中，您可能会发现自己在一个很短的时间内发送了多个Snackbar消息。为了处理这种情况，您可以创建一个队列来处理所有Snackbar消息，以确保只显示最新的通知，并且正确处理过渡。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's say that you have several components throughout your application that
    need to send snackbar messages to your users. Having to manually render `Snackbar`
    components everywhere would be cumbersome—especially if all you're trying to do
    is display simple text snackbars.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用程序中有几个组件需要向用户发送snackbar消息。在所有地方手动渲染`Snackbar`组件将会很繁琐——尤其是如果你只是想显示简单的文本snackbar。
- en: 'One alternative approach is to implement a higher-order component that wraps
    your components with the ability to display messages by calling a function and
    then passing the text as the argument. Then, you can wrap any components that
    need the snackbar capability. Here''s what the code looks like:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方法是实现一个高阶组件，它通过调用一个函数并将文本作为参数传递来包装你的组件，使其能够显示消息。然后，你可以包装任何需要snackbar功能的组件。以下是代码的样子：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the screen first loads, you''ll see a message button. Clicking on it will
    display a snackbar message that looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次加载时，你会看到一个消息按钮。点击它将显示一个类似这样的snackbar消息：
- en: '![](img/785de96d-5cee-4ab8-a83f-7c2c6f825242.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/785de96d-5cee-4ab8-a83f-7c2c6f825242.png)'
- en: 'Clicking on the message button again will clear the current snackbar by visually
    transitioning it off of the screen before transitioning the new snackbar onto
    the screen. Even if you click the button several times in rapid succession, everything
    works smoothly and you''ll always see the latest message:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 再次点击消息按钮将清除当前的snackbar，通过在屏幕上视觉上将其移除，然后再将新的snackbar转换到屏幕上。即使你连续快速点击按钮几次，一切都会顺利工作，你总是会看到最新的消息：
- en: '![](img/c7740450-84b3-44e7-9951-8ff3ab18688d.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7740450-84b3-44e7-9951-8ff3ab18688d.png)'
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by looking at the `QueuingSnackbars` component that renders the
    button that sends messages when clicked:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看`QueuingSnackbars`组件，它渲染了当点击时发送消息的按钮：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `withMessage()` wrapper provides the component with a `message()` function
    as a property. If you look at the `onClick()` handler, you can see the `message()`
    function in action.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`withMessage()`包装器为组件提供了一个作为属性的`message()`函数。如果你查看`onClick()`处理程序，你可以在其中看到`message()`函数的作用。'
- en: 'Next, let''s break down the `withMessage()` higher-order component. We''ll
    start with the markup and work our way downward:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们分解`withMessage()`高阶组件。我们将从标记开始，逐步向下：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Wrapped` component is the component that `withMessage()` was called on.
    It''s passed the normal props that it would be called with normally, plus the
    `message()` function. Adjacent to this is the `Snackbar` component. There are
    two interesting properties that are worth pointing out here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wrapped`组件是`withMessage()`被调用的组件。它传递了它通常会被传递的正常属性，加上`message()`函数。旁边是`Snackbar`组件。这里有两个值得注意的属性：'
- en: '`key`: This value is used internally by `Snackbar` to determine whether a new
    message is being displayed. It should be a unique value.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`：这个值由`Snackbar`内部使用，以确定是否正在显示新消息。它应该是一个唯一的值。'
- en: '`onExit`: This is called when the transition of a snackbar that is closing
    completes.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onExit`：当关闭的snackbar的转换完成时被调用。'
- en: 'Next, let''s look at the `sendMessage()` function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`sendMessage()`函数：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function is called whenever a component wants to display a snackbar message.
    It puts the `message` string into the queue. If the message is the only item in
    the queue, then the `open` and `message` states are updated right away.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组件想要显示snackbar消息时，这个函数会被调用。它将`message`字符串放入队列。如果消息是队列中唯一的项，那么`open`和`message`状态会立即更新。
- en: 'Next, let''s look at the `onClose()` function. This is called when the snackbar
    is closed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`onClose()`函数。当snackbar关闭时，这个函数会被调用：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The only job of this function is to make sure that the open state is false.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的唯一任务就是确保打开状态为false。
- en: 'Lastly, let''s look at the `onExit()` function that''s called when a snackbar
    has completed its exit transition:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看当snackbar完成其退出转换时被调用的`onExit()`函数：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The fist message in the queue is assigned to the `message` constant. If there's
    a message, it becomes the active message state and the next snackbar is opened.
    The item is also removed from the queue at this point.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中的第一条消息被分配给`message`常量。如果有消息，它将成为活动消息状态，并且下一个snackbar将被打开。此时，项目也将从队列中移除。
- en: See also
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Snackbar` demos: [https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar`演示：[https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snackbar` API 文档：[https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
- en: '`Button` API documentation: [https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button` API 文档：[https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
- en: '`IconButton` API documentation: [https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IconButton` API 文档：[https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
