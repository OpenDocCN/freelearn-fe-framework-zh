- en: Chapter 2. Details of JavaScript Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 JavaScript 测试的细节
- en: Practicing TDD is a great way to get good quality software with satisfactory
    accuracy, even with fewer people. For web applications, JavaScript has become
    the most popular scripting language and it has become a challenge to test JavaScript
    code. Browser-based testing is actually a time killer and is difficult to follow
    for TDD, but then the solution to this comes with some cool tools that support
    automated testing for JavaScript. Most web application projects were limited to
    unit tests only, and without automated test tools, end-to-end tests or functional
    tests were almost impossible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 TDD 是获得高质量软件并具有令人满意准确性的好方法，即使人数较少。对于网络应用程序，JavaScript 已经成为最受欢迎的脚本语言，测试 JavaScript
    代码已成为一项挑战。基于浏览器的测试实际上是一种时间杀手，对于 TDD 来说很难跟踪，但随后这个问题的解决方案伴随着一些支持 JavaScript 自动化测试的酷工具。大多数网络应用程序项目仅限于单元测试，而没有自动化测试工具，端到端测试或功能测试几乎是不可能的。
- en: A lot of tools and frameworks focusing on JavaScript testing are coming out,
    which serve different solutions, making developers' lives easy. Besides inventing
    new JavaScript frameworks, the developer's community invented some tool sets to
    make testing easy. Like the Angular team, they come with cool tools like **Karma**.
    We also have the duplication of testing frameworks or tools, where both solve
    similar problems but in different ways. Which tools or frameworks to choose is
    up to the developer; they have to choose the tool that suits their requirements
    best.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多专注于 JavaScript 测试的工具和框架正在出现，它们提供不同的解决方案，使开发者生活变得更轻松。除了发明新的 JavaScript 框架外，开发者社区还发明了一些工具集来简化测试。例如，Angular
    团队带来了像 **Karma** 这样的酷工具。我们还有测试框架或工具的重复，其中两者都解决了类似的问题，但以不同的方式。选择哪些工具或框架取决于开发者；他们必须选择最适合他们需求的工具。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: A brief about automated testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试的简要介绍
- en: Different types of testing focused on JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于 JavaScript 的不同类型的测试
- en: A brief idea about some testing tools and frameworks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些测试工具和框架的简要介绍
- en: The craft of JavaScript testing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 测试的技艺
- en: We all know that JavaScript is a dynamically typed, interpreted language. Therefore,
    there are no compilation steps that help you figure out errors, unlike other compiled
    languages similar to Java. So, a JavaScript developer should allocate more time
    to test code. However, life is easier now, as a developer can cover testing with
    minimal steps and time using the latest tool techniques. It's a part of an automated
    test, where the code will be automatically tested whenever it changes. In that
    process, a test could be a task running in the background, which could be integrated
    into the IDE or the CLI, and it will provide the test result during development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道 JavaScript 是一种动态类型、解释型语言。因此，与类似 Java 的其他编译语言不同，它没有编译步骤来帮助你找出错误。所以，JavaScript
    开发者应该分配更多的时间来测试代码。然而，现在生活变得更简单了，因为开发者可以使用最新的工具技术以最少的步骤和时间来覆盖测试。这是自动化测试的一部分，其中代码在更改时将自动进行测试。在这个过程中，测试可能是一个在后台运行的任务，它可以集成到
    IDE 或 CLI 中，并在开发过程中提供测试结果。
- en: In the subsequent sections, we will discuss how to automate the test process
    in multiple browsers with a test runner and a headless browser.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论如何使用测试运行器和无头浏览器在多个浏览器中自动化测试过程。
- en: Automated testing
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Testing is fun, and writing a test will make the code better; it's a good practice,
    but the procedural manual testing is a bit time consuming, error prone, and irreproducible.
    In this process, there is a need to write the test spec, change the code to pass
    the test, refresh the browser to get the result, and repeat this process several
    times. As a programmer, it's kind of boring to repeat the same things.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 测试很有趣，编写测试会使代码更好；这是一个好习惯，但程序化手动测试有点耗时，容易出错，且难以重现。在这个过程中，需要编写测试规范，更改代码以通过测试，刷新浏览器以获取结果，并重复这个过程几次。作为一个程序员，重复同样的事情有点无聊。
- en: Apart from being monotonous, it also slows down the development process a lot,
    which demotivates developers from practicing TDD. So, when the manual process
    slows down progress, we have to look for some automated process to do the job
    and save time for other tasks that could add more business value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单调之外，它还极大地减缓了开发过程，这会降低开发者练习 TDD 的积极性。所以，当手动过程减缓进度时，我们必须寻找一些自动化过程来完成这项工作，并为其他可能增加更多商业价值的工作节省时间。
- en: So, it would be great to have some tools or techniques that can help programmers
    get rid of these repetitive and boring manual steps that slow down the process
    and get things done automatically, faster, and save time to make them more valuable
    for the business. Fortunately, there are some tools to automate these tests. We
    will cover more about those tools and techniques, but not in this section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，拥有一些工具或技术来帮助程序员摆脱这些重复且无聊的手动步骤，从而加快流程、自动完成任务并节省时间，使他们能为业务创造更多价值，将会非常棒。幸运的是，有一些工具可以自动化这些测试。我们将详细介绍这些工具和技术，但不是在本节中。
- en: Besides the issue of slowing down the development process, another important
    point comes in view when we talk about the testing features, and that is the cross-browser
    compatibility issue. As web applications should run perfectly on modern platforms
    and browsers, and it's almost impossible to test them one-by-one manually, automated
    testing could be the solution with a web driver and headless browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了减缓开发进程的问题外，当我们谈论测试功能时，还有一个重要的问题浮出水面，那就是跨浏览器兼容性问题。由于Web应用程序应该在现代平台和浏览器上完美运行，而手动逐个测试几乎是不可能的，因此，使用WebDriver和无头浏览器的自动化测试可能是解决方案。
- en: Let's recap the basic test flow that we explained in the previous chapter--test
    it, make it run, and make it better. To make this process automatic, a developer
    can implement the tool set in the CLI or even in the development IDE, and these
    tests will run continuously in a separate process without any input from the developer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在前一章中解释的基本测试流程——测试它，让它运行，让它变得更好。为了使这个过程自动化，开发者可以在命令行界面（CLI）或开发IDE中实现工具集，并且这些测试将在一个独立进程中连续运行，无需开发者任何输入。
- en: Let's think of a registering or signing up feature for any application, where
    we have to manually fill up the form and click on the submit button every time
    we want to test the feature and repeat the process by changing the data. This
    is actually known as a functional test (which we will discuss at the end of this
    chapter). To perform these processes automatically, we will use the tool set (the
    test runner, web driver, and headless browser) in the CLI and complete the process
    with a single command with some parameters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下任何应用程序的注册或注册功能，其中我们必须手动填写表单并点击提交按钮，每次我们想要测试该功能并通过更改数据重复此过程。这实际上被称为功能测试（我们将在本章末尾讨论）。为了自动执行这些过程，我们将使用CLI中的工具集（测试运行器、WebDriver和无头浏览器）并通过带有一些参数的单个命令完成整个过程。
- en: Testing JavaScript in automated testing is not a new concept, indeed, it is
    the most commonly used automated browser. Selenium was invented for this in 2004,
    and after that, a lot of tools have emerged, including PhantomJS, Karma, Protractor,
    and CasperJS. In this chapter, we will discuss some of them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化测试中测试JavaScript并不是一个新概念，实际上，它是最常用的自动化浏览器。Selenium就是在2004年为此而发明的，此后，涌现出了许多工具，包括PhantomJS、Karma、Protractor和CasperJS。在本章中，我们将讨论其中的一些。
- en: Types of testing
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'In TDD, developers have to follow a flow to fulfill the goal of the test. On
    this flow, every step has an individual goal of testing. For example, some tests
    are written just to test the behavior of each function in several ways and some
    are for testing the flow of a module/feature. Based on that, we will discuss two
    major types of testing here. They are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD（测试驱动开发）中，开发者必须遵循一个流程来实现测试的目标。在这个流程中，每一步都有一个单独的测试目标。例如，一些测试仅用于以多种方式测试每个函数的行为，而另一些则是为了测试模块/功能的流程。基于此，我们将在这里讨论两种主要的测试类型。它们如下：
- en: '**Unit testing**: This is mostly used for behavior tests.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这主要用于行为测试。'
- en: '**End-to-end testing**: This is mostly known as e2e testing and is used for
    functional tests.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：这通常被称为e2e测试，用于功能测试。'
- en: Unit testing
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: '**Unit testing** is a software development process, where the smallest testable
    part of any application is individually called a unit, and the behavior of that
    small part should be testable in isolation, without any dependency on the other
    parts. If we think of a JavaScript application as software, then every individual
    method/function of that application which has a specific behavior will be a unit
    of code. The behavior of these methods or units of code should be testable in
    an isolated way.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是一种软件开发过程，其中任何应用程序的最小可测试部分被称为单元，该小部分的行为应该在隔离状态下可测试，而不依赖于其他部分。如果我们把JavaScript应用程序看作是软件，那么该应用程序的每个具有特定行为的独立方法/函数都将是一个代码单元。这些方法或代码单元的行为应该以隔离的方式进行测试。'
- en: An important point about unit testing is that any unit of code should run/be
    testable in isolation and should run in any order, which means that if unit testing
    runs successfully in any application, it represents the isolation of the components
    or modules of that application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的一个重要观点是，任何代码单元都应该在隔离状态下运行/可测试，并且可以按任何顺序运行，这意味着如果单元测试在任何应用程序中成功运行，它代表了该应用程序组件或模块的隔离性。
- en: For example, we had already shown a small test example in the previous chapter
    about how to get a method tested; though we showed that without using any test
    framework, the idea is the same. We called the method by passing some parameters,
    got a result of that method, and then we compared the result with the expected
    value.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在上一章中已经展示了一个小的测试示例，说明了如何对方法进行测试；尽管我们没有使用任何测试框架，但理念是相同的。我们通过传递一些参数来调用该方法，获取该方法的返回结果，然后将其与预期值进行比较。
- en: Typically, we will write such tests using a unit testing framework of our choice.
    There are many testing frameworks and tools now, and we have to decide and pick
    the best one based on our requirements. The most commonly used frameworks are
    Jasmine, Mocha, and QUnit. We will discuss these tools in depth in this chapter
    and real-life examples will be covered in the subsequent chapters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将使用我们选择的单元测试框架来编写这样的测试。现在有许多测试框架和工具，我们必须根据我们的需求进行选择和挑选最佳的框架。最常用的框架是Jasmine、Mocha和QUnit。我们将在本章深入讨论这些工具，并在后续章节中涵盖实际案例。
- en: Tests should run fast and be automated with a clear output. For example, you
    can verify that if a function is called with particular arguments, it should return
    an expected result.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该运行得快，并且具有清晰的输出，实现自动化。例如，你可以验证如果函数被调用时使用特定的参数，它应该返回预期的结果。
- en: 'Unit testing can run the test anytime, such as in the following instances:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以在任何时间运行测试，例如以下情况：
- en: From the very beginning of the development process, even with a failing test
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从开发过程的开始阶段，即使有失败的测试
- en: After completing the development of any feature to verify that the behavior
    is correct
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完成任何功能的开发后，为了验证行为是否正确
- en: After modifying any existing feature to verify that the behavior hasn't changed
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改任何现有功能后，为了验证行为没有改变
- en: After adding a new feature in the existing application, we need to verify that
    the new feature is isolated and it's not breaking any other feature
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有应用程序中添加新功能后，我们需要验证该新功能是隔离的，并且没有破坏其他功能
- en: End-to-end testing
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: End-to-end testing is a methodology used to test whether the flow of an application
    is performing as designed from start to finish. For example, if a user clicks
    on a product from a product list, it should prompt the modal to display detailed
    information of the selected product. In this case, the product/project owner will
    define the project requirements step by step in the specification. The project
    will be tested based on the specification's workflow after the development process.
    This is called the function/flow test and is another name for an end-to-end test.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是一种测试方法，用于测试应用程序的流程是否从开始到结束都按设计执行。例如，如果用户从产品列表中点击一个产品，应该会提示模态显示所选产品的详细信息。在这种情况下，产品/项目所有者将在规范中逐步定义项目需求。开发过程完成后，将根据规范的工作流程对项目进行测试。这被称为功能/流程测试，也是端到端测试的另一个名称。
- en: Besides unit testing, end-to-end testing is important for confirming that individual
    components are working together as an application, passing information, and communicating
    among them. The main difference with unit testing is that it does not test any
    components in isolation; instead, it is a combined test of the flow with all the
    dependent components together.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单元测试之外，端到端测试对于确认各个组件作为一个应用程序协同工作、传递信息和相互通信非常重要。与单元测试的主要区别在于它不测试任何单独的组件；相反，它是对所有相关组件一起的流程的联合测试。
- en: Consider a registration module where users should provide some valid information
    to complete the registration, and the function/flow test for that module/application
    should follow some steps to complete the testing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个注册模块，用户应提供一些有效信息以完成注册，该模块/应用程序的功能/流程测试应遵循一些步骤以完成测试。
- en: 'The steps are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Load/compile the form
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载/编译表单
- en: Get the DOM of the form's elements
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取表单元素的DOM
- en: Trigger the click event of the submit button
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发提交按钮的点击事件
- en: Collect the value from the input fields for validation
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入字段收集值以进行验证
- en: Validate the input fields
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证输入字段
- en: Call the fake API to store data
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用模拟API以存储数据
- en: In every step, there will be some result which will be compared to the expected
    result set.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个步骤中，都会有一些结果与预期的结果集进行比较。
- en: These kinds of functional/flow tests can be tested manually by a person filling
    out the forms by clicking on the buttons for the next steps, completing the application
    flow, and comparing the result with the specification that is defined earlier
    in the implementation process.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这类功能/流程测试可以通过人工填写表格，点击按钮进行下一步，完成应用程序流程，并将结果与在实现过程中定义的规范进行比较来手动测试。
- en: However, there are some techniques available to do this functional/flow testing
    in an automated way without getting input from any person, which is known as end-to-end
    testing. To make this test process easier, there are a few tools available; the
    ones used most commonly are Selenium, PhantomJS, and Protractor. These tools can
    easily integrate with any application test system. In this chapter, we will discuss
    these test tools in a bit more detail, and in the subsequent chapters, we will
    integrate these in an application's test suite.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些技术可以实现这种功能/流程测试的自动化，而不需要任何人的输入，这被称为端到端测试。为了使测试过程更容易，有一些工具可用；最常用的有Selenium、PhantomJS和Protractor。这些工具可以轻松地与任何应用程序测试系统集成。在本章中，我们将更详细地讨论这些测试工具，在随后的章节中，我们将将这些工具集成到应用程序的测试套件中。
- en: Testing tools and frameworks
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试工具和框架
- en: 'Knowing what the different testing tools are is half the battle. A few of them
    are very important to know in depth for Angular testing; we will learn them in
    detail throughout this book. However, in this section, we will learn about some
    well-known tools and frameworks that are used in different web applications for
    various kinds of testing and approaches. They are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 了解不同的测试工具是战斗的一半。其中一些对于Angular测试非常重要，需要深入了解；我们将在整本书中详细学习它们。然而，在本节中，我们将了解一些在不同Web应用程序中用于各种测试和方法的知名工具和框架。它们如下：
- en: '**Karma**: This is the test runner for JavaScript'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Karma**：这是JavaScript的测试运行器'
- en: '**Protractor**: This is the end-to-end testing framework'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Protractor**：这是一个端到端测试框架'
- en: '**Jasmine**: This refers to the behavior-driven JavaScript testing framework'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine**：指的是行为驱动的JavaScript测试框架'
- en: '**Mocha**: This is the JavaScript testing framework'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mocha**：这是一个JavaScript测试框架'
- en: '**QUnit**: This stands for the unit testing framework'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QUnit**：代表单元测试框架'
- en: '**Selenium**: This is the tool that automates the web browsers'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Selenium**：这是一个自动化Web浏览器的工具'
- en: '**PhantomJS**: This is the headless webkit browser'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PhantomJS**：这是一个无头webkit浏览器'
- en: Karma
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Karma
- en: 'Before discussing what Karma is, it is best to discuss what it isn''t. It isn''t
    a framework to write tests; it is a test runner. What this means is that Karma
    gives us the ability to run tests in several different browsers in an automated
    way. In the past, developers had to perform manual steps to do this, including
    the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论Karma是什么之前，最好先讨论它不是什么。它不是一个编写测试的框架；它是一个测试运行器。这意味着Karma能够以自动化的方式在多个不同的浏览器中运行测试。在过去，开发者必须执行手动步骤来完成这项工作，包括以下步骤：
- en: Opening up a browser
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开浏览器
- en: Pointing the browser to the project URL
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将浏览器指向项目URL
- en: Running the tests
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试
- en: Confirming that all the tests have passed
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认所有测试都已通过
- en: Making changes
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行更改
- en: Refreshing the page
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新页面
- en: With Karma, automation gives a developer the ability to run a single command
    and determine whether an entire test suite has passed or failed. From a TDD perspective,
    this gives us the ability to find and fix failing tests quickly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Karma，自动化使开发者能够运行单个命令，并确定整个测试套件是否通过或失败。从 TDD 的角度来看，这使我们能够快速找到并修复失败的测试。
- en: 'Some of the pros of using Karma as compared to a manual process are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动过程相比，使用 Karma 的优点如下：
- en: Ability to automate tests in multiple browsers and devices
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在多个浏览器和设备上自动化测试
- en: Ability to watch files
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够监视文件
- en: Online documentation and support
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线文档和支持
- en: Does one thing--running JavaScript tests--and does it well
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只做一件事——运行 JavaScript 测试——并且做得很好
- en: Makes it easy to integrate with a continuous integration server
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使其易于与持续集成服务器集成
- en: 'Disadvantage of using Karma:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Karma 的缺点：
- en: Requires an additional tool to learn, configure, and maintain
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要额外的工具来学习、配置和维护
- en: Automating the process of testing and using Karma is extremely advantageous.
    In the TDD journey through this book, Karma will be one of our primary tools.
    We will learn about Karma in detail in [Chapter 3](ch03.html "Chapter 3. The Karma
    Way"), *The Karma Way*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试过程和使用 Karma 非常有利。在本书的 TDD 之旅中，Karma 将是我们的主要工具之一。我们将在 [第 3 章](ch03.html
    "第 3 章。Karma 的方法") 中详细了解 Karma，*Karma 的方法*。
- en: Protractor
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Protractor
- en: Protractor is an end-to-end testing tool that allows developers to mimic user
    interactions. It automates the testing of functionality and features through the
    interaction of a web browser. Protractor has specific methods to assist in the
    testing of Angular, but they are not exclusive to Angular.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 是一个端到端测试工具，允许开发者模拟用户交互。它通过浏览器交互自动化测试功能和特性。Protractor 有特定的方法来协助测试
    Angular，但它们并不局限于 Angular。
- en: 'Some of the pros of using Protractor are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Protractor 的优点如下：
- en: Configurable to test multiple environments
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置以测试多个环境
- en: Easy integration with Angular
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Angular 容易集成
- en: Syntax and testing can be similar to the testing framework chosen for unit testing
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法和测试可以与为单元测试选择的测试框架相似
- en: 'Disadvantage of using Protractor:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Protractor 的缺点：
- en: Its documentation and examples are limited
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其文档和示例有限
- en: For end-to-end testing of the examples in this book, Protractor will be our
    main framework. Protractor will be further introduced in detail in [Chapter 4](ch04.html
    "Chapter 4. End-to-End Testing with Protractor"), *End-to-End Testing with Protractor*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试本书中的示例的端到端测试，Protractor 将是我们的主要框架。Protractor 将在 [第 4 章](ch04.html "第 4 章。使用
    Protractor 进行端到端测试") 中详细介绍，*使用 Protractor 进行端到端测试*。
- en: Jasmine
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jasmine
- en: Jasmine is a behavior-driven development framework for testing JavaScript code.
    It can be easily integrated and run for websites and is agnostic to Angular. It
    provides spies and other features. It can also be run on its own without Karma.
    In this chapter, we will learn details of the commonly used built-in global functions
    of Jasmine and will see how the Jasmine test suite serves the testing requirements
    for a web application. Also, throughout this book, we will use Jasmine as our
    testing framework.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 是一个用于测试 JavaScript 代码的行为驱动开发框架。它可以轻松集成并运行于网站，且对 Angular 无关。它提供了间谍和其他功能。它也可以在不使用
    Karma 的情况下独立运行。在本章中，我们将学习 Jasmine 常用内置全局函数的细节，并了解 Jasmine 测试套件如何满足 Web 应用程序的测试需求。此外，在本书中，我们将使用
    Jasmine 作为我们的测试框架。
- en: 'Some of the pros of using Jasmine are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jasmine 的优点如下：
- en: Default integration with Karma
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认与 Karma 集成
- en: Provides additional functions to assist with testing, such as test spies, fakes,
    and the pass-through functionality
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了额外的功能来协助测试，例如测试间谍、模拟和透传功能
- en: Cleans readable syntax that allows tests to be formatted in a way that relates
    to the behavior being tested
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰的语法，允许测试以与被测试行为相关的方式格式化
- en: Integration with several output reporters
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多个输出报告器的集成
- en: 'The following are some cons of using Jasmine:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jasmine 的缺点如下：
- en: No file-watching feature is available when running tests. This means that tests
    have to be rerun by the user as they change.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试时没有文件监视功能。这意味着当文件更改时，测试必须由用户重新运行。
- en: The learning curve can be steep for all the Protractor methods and features.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有 Protractor 方法和技术，学习曲线可能很陡峭。
- en: Mocha
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mocha
- en: Mocha is a testing framework originally written for Node.js applications, but
    it supports browser testing as well. It is very similar to Jasmine and mirrors
    much of its syntax. The main difference with Mocha is that it can't run standalone
    as a test framework--it needs some plugin and library to run as a test framework,
    while Jasmine is standalone. It's more configurable and flexible to use.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha最初是为Node.js应用程序编写的测试框架，但也支持浏览器测试。它与Jasmine非常相似，并且语法上有很多相似之处。Mocha与Jasmine的主要区别在于它不能作为独立的测试框架运行——它需要一些插件和库来作为测试框架运行，而Jasmine是独立的。它更易于配置和使用。
- en: 'Let''s discuss some of the pros of Mocha:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下Mocha的一些优点：
- en: Easy to install
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于安装
- en: Good documentation available
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有良好的文档
- en: Has several reporters
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有几个报告器
- en: Plugs in with several node projects
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多个Node.js项目兼容
- en: 'Here are a few cons:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些缺点：
- en: Separate plugins/modules are required for assertions, spies, and so on
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要单独的插件/模块来进行断言、间谍等操作
- en: Additional configuration required to use it with Karma
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Karma时需要额外的配置
- en: QUnit
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QUnit
- en: QUnit is a powerful, easy-to-use JavaScript unit test suite. It's used by jQuery
    and the jQuery UI and jQuery Mobile projects and is capable of testing any generic
    JavaScript code. QUnit focuses on testing JavaScript in the browser, while providing
    as much convenience to the developer as possible.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: QUnit是一个强大且易于使用的JavaScript单元测试套件。它被jQuery、jQuery UI和jQuery Mobile项目使用，并且能够测试任何通用的JavaScript代码。QUnit专注于在浏览器中测试JavaScript，同时尽可能为开发者提供便利。
- en: 'Some of the pros of QUnit:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: QUnit的一些优点：
- en: Easy to install
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于安装
- en: Good documentation available
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有良好的文档
- en: 'Here is a con of using QUnit:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用QUnit的一个缺点：
- en: Mostly developed for jQuery, not good for use with other frameworks
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要为jQuery开发，与其他框架使用不佳
- en: Selenium
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium
- en: 'Selenium ([http://www.seleniumhq.org/](http://www.seleniumhq.org/)) defines
    itself as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium ([http://www.seleniumhq.org/](http://www.seleniumhq.org/))将其自身定义为如下：
- en: '*"Selenium automates browsers. That''s it!"*'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Selenium自动化浏览器。仅此而已！”
- en: Automation of browsers means that developers can interact with browsers easily.
    They can click on buttons or links, enter data, and so on. Selenium is a powerful
    toolset that, when used and set up properly, has lots of benefits; however, it
    can be confusing and cumbersome to set it up.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器自动化意味着开发者可以轻松地与浏览器交互。他们可以点击按钮或链接，输入数据等。Selenium是一个强大的工具集，当正确使用和设置时，有很多好处；然而，设置起来可能会很复杂。
- en: 'Some of the pros of Selenium are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium的一些优点如下：
- en: Large feature set
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能集庞大
- en: Distributed testing
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式测试
- en: SaaS support through services such as **Sauce Labs** ([https://saucelabs.com/](https://saucelabs.com/))
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**Sauce Labs**等服务提供SaaS支持 ([https://saucelabs.com/](https://saucelabs.com/))
- en: Documentation and resources available
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有文档和资源
- en: 'Here are some cons of Selenium:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Selenium的一些缺点：
- en: Has to be run as a separate process
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须作为一个单独的进程运行
- en: Several steps to configure
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置需要几个步骤
- en: As Protractor is a wrapper around Selenium, it won't be discussed in detail.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Protractor是Selenium的包装器，所以不会详细讨论。
- en: PhantomJS
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PhantomJS
- en: PhantomJS is a headless WebKit scriptable with a JavaScript API. It has *fast*
    and *native* support for various web standards; DOM handling, CSS selector, JSON,
    Canvas, and SVG. PhantomJS is used in the test workflow.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS是一个可使用JavaScript API进行脚本化的无头WebKit。它对各种网络标准有*快速*和*原生*的支持；DOM处理、CSS选择器、JSON、Canvas和SVG。PhantomJS用于测试工作流程。
- en: Simply put, PhantomJS is a browser that runs headlessly (that is, doesn't draw
    out the screen). The benefits that it brings are speed--if you're controlling
    an actual program on your computer, you've a certain overhead in booting up the
    browser, configuring a profile, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，PhantomJS是一个无头浏览器（也就是说，不会绘制屏幕）。它带来的好处是速度——如果你正在控制你电脑上的实际程序，启动浏览器、配置配置文件等会有一定的开销。
- en: PhantomJS is not meant to replace a testing framework; it will work in conjunction
    with one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS不是用来替换测试框架的；它将与测试框架一起工作。
- en: The choice is ours
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择权在我们手中
- en: 'As we have seen, there are a lot of toolsets and frameworks for testing JavaScript
    projects:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，有很多工具集和框架用于测试JavaScript项目：
- en: For the assertion framework, we will go with Jasmine as Angular itself uses
    Jasmine as assertions; but in some cases, mostly for Node.js projects, Mocha is
    fun as well
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于断言框架，我们将选择Jasmine，因为Angular本身使用Jasmine作为断言；但在某些情况下，主要是对于Node.js项目，Mocha也很受欢迎
- en: As long as we focus on the automated test suite, the test runner is of most
    importance to us, and nothing can be compared to Karma when it's about an Angular
    project
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要我们专注于自动化测试套件，测试运行器对我们来说就非常重要，而且当涉及到 Angular 项目时，没有什么能比得上 Karma。
- en: For end-to-end testing, Protractor is the best framework, and we will use that
    in this chapter.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于端到端测试，Protractor 是最好的框架，我们将在本章中使用它。
- en: As long as it's end-to-end testing, it must be automated, and Selenium is here
    to automate the browser for us.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要进行的是端到端测试，它就必须是自动化的，Selenium 就在这里为我们自动化浏览器。
- en: It's important to run tests as cross-browser support, and PhantomJS is here
    for us to serve as a headless browser.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试时，重要的是要支持多浏览器，PhantomJS 就在这里为我们提供无头浏览器服务。
- en: Say hello to Jasmine test suite
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎使用 Jasmine 测试套件
- en: As long as we have to use a testing framework to build a test suite, there are
    some basic and common assertions on all frameworks. It's important to understand
    those assertions and spies and when to use them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们需要使用测试框架来构建测试套件，所有框架上都有一些基本的常见断言。理解这些断言和间谍以及何时使用它们是很重要的。
- en: In this section we will explain the assertions and spies from Jasmine, as Jasmine
    will be our testing framework throughout the book.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释 Jasmine 的断言和间谍，因为 Jasmine 将作为本书中的测试框架。
- en: Suites
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套件
- en: Any test suite begins with a global Jasmine `describe` function, which receives
    two parameters. The first one is a string and the second one is a function. The
    string is the suite name/title, and the function is for the code block that will
    be implemented in the suite.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 任何测试套件都以一个全局 Jasmine `describe` 函数开始，该函数接收两个参数。第一个参数是一个字符串，第二个参数是一个函数。这个字符串是套件名称/标题，而函数是将在套件中实现的代码块。
- en: 'Consider the following example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE0]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Spec
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spec
- en: 'Any spec defined with Jasmine''s global `it` function, similar to the suite''s
    that receives two params, involves the first one being a string and the second
    one being a function. The string is the spec name/title and the function is for
    the code block that will be implemented in the spec. Take a look at the following
    example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用 Jasmine 的全局 `it` 函数定义的 spec，类似于接收两个参数的 suite，都涉及第一个参数是一个字符串，第二个参数是一个函数。这个字符串是
    spec 名称/标题，而函数是将在 spec 中实现的代码块。看看以下示例：
- en: '[PRE1]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Expectation
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 期望
- en: Any expectation defined with an `expect` function, which receives one param
    value that is called actual. This function is a chain with the matcher function,
    which takes an expected value as a parameter to match with the actual value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用 `expect` 函数定义的期望，该函数接收一个名为实际值的参数。这个函数是一个与匹配函数链式调用的函数，它将期望值作为参数与实际值进行匹配。
- en: There are a few commonly used matchers; all of them implement a Boolean comparison
    between the actual value and the expected value. Any matcher can evaluate a negative
    value by chaining the `expect` method with a `not` keyword.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些常用的匹配器；它们都实现了实际值和期望值之间的布尔比较。任何匹配器都可以通过将 `expect` 方法与 `not` 关键字链式调用来评估负值。
- en: Some common matchers are `toBe`, `toEqual`, `toMatch`, `toBeNull`, `toBeDefined`,
    `toBeUndefined`, and `toContain`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的匹配器有 `toBe`、`toEqual`、`toMatch`、`toBeNull`、`toBeDefined`、`toBeUndefined`
    和 `toContain`。
- en: 'Consider the given example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE2]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Setup and teardown
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和清理
- en: To improve the test suite by DRY (Don't repeat yourself) up duplicated setup
    and teardown code, Jasmine provides some global functions for the setup and teardown.
    Those global functions (`beforeEach`, `afterEach`, and so on) are as follows and
    they run as the name implies.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过 DRY（不要重复自己）原则减少重复的设置和清理代码，Jasmine 提供了一些全局函数用于设置和清理。这些全局函数（`beforeEach`、`afterEach`
    等）如下，它们按名称运行。
- en: Every function runs against a test spec. Jasmine's global setup and the teardown
    functions are `beforeEach`, `afterEach`, `beforeAll`, and `afterAll`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都会与一个测试 spec 运行。Jasmine 的全局设置和清理函数是 `beforeEach`、`afterEach`、`beforeAll`
    和 `afterAll`。
- en: 'Consider the following example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE3]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Spies
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 间谍
- en: Spies are test double functions in Jasmine; they can stub any function and track
    calls on it and to all its arguments. There are a few matchers around to track
    if any spy has been called or not. These are `toHaveBeenCalled`, `toHaveBeenCalledTimes`,
    and so on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍是 Jasmine 中的测试双函数；它们可以模拟任何函数并跟踪对其及其所有参数的调用。有一些匹配器可以用来跟踪是否有任何间谍被调用。这些是 `toHaveBeenCalled`、`toHaveBeenCalledTimes`
    等。
- en: There are some useful chained methods used with spy, such as `returnValue`/
    `returnValues`, which will return one or more values when called by chaining with
    spy. There are a few more similar useful methods, such as `callThrough`, `call`,
    `stub`, `call.allArgs`, `call.first`, and `call.reset`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些与 spy 一起使用的有用链式方法，例如 `returnValue`/ `returnValues`，当通过 spy 链式调用时，将返回一个或多个值。还有一些类似的有用方法，例如
    `callThrough`、`call`、`stub`、`call.allArgs`、`call.first` 和 `call.reset`。
- en: 'Consider the following example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE4]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The test suite of Jasmine
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jasmine 的测试套件
- en: In the preceding section, we looked over some commonly used assertions that
    all test frameworks, including Jasmine, use in any kind of test suite.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们查看了一些在所有测试框架中，包括 Jasmine，在任意类型的测试套件中常用的断言。
- en: Though in this book, we will build an automated test suite for Angular testing,
    let's try some assertion in a Jasmine test suite and see how it works. This sample
    test suite will give us some hands on experience of how the assertions work on
    a test suite.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这本书中，我们将为 Angular 测试构建一个自动化测试套件，但让我们尝试在 Jasmine 测试套件中进行一些断言，看看它是如何工作的。这个示例测试套件将让我们亲身体验到断言在测试套件中的工作方式。
- en: 'For this test suite, we will use Jasmine''s sample spec runner project (which
    is available in the Jasmine downloaded bundle in the example), and the project''s
    folder structure will look as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试套件，我们将使用 Jasmine 的示例 spec 运行器项目（在示例中，它包含在下载的 Jasmine 包中），项目的文件夹结构将如下所示：
- en: '![The test suite of Jasmine](img/image_02_001.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine 的测试套件](img/image_02_001.jpg)'
- en: 'Let''s take a quick look at the files that we have to update in the Jasmine''s
    sample `SpecRunner` project:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看在 Jasmine 的示例 `SpecRunner` 项目中需要更新的文件：
- en: '[PRE5]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As long as it''s a browser-based test suite, we have to point `SpecRunner.html` to
    a web browser to get the test result. We will have all the tests passed and our
    test result will look as shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 只要是一个基于浏览器的测试套件，我们就必须将 `SpecRunner.html` 指向一个网络浏览器以获取测试结果。我们将所有测试通过，我们的测试结果将如图所示：
- en: '![The test suite of Jasmine](img/image_02_002-1.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine 的测试套件](img/image_02_002-1.jpg)'
- en: The Jasmine test suite for Angular
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 的 Jasmine 测试套件
- en: In the preceding example, we saw a Jasmine test suite for JavaScript testing,
    but what about for Angular, how should that look? Actually, there is no direct
    answer as, for the Angular project test suite, we will not use a browser-based
    test suite; we have a test runner with Karma for the test suite. But as we are
    familiar with the browser-based Jasmine test suite in the preceding example, let's
    see what that will look like if we make a similar one for the Angular project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了用于 JavaScript 测试的 Jasmine 测试套件，但对于 Angular 呢？它应该是什么样子？实际上，没有直接的答案，因为对于
    Angular 项目的测试套件，我们不会使用基于浏览器的测试套件；我们有一个带有 Karma 的测试运行器用于测试套件。但因为我们熟悉前面示例中的基于浏览器的
    Jasmine 测试套件，让我们看看如果为 Angular 项目创建一个类似的套件，它将是什么样子。
- en: 'We will have to add a subfolder as `src` in the Angular project for the test
    spec, and then the project''s folder structure will look like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 Angular 项目的 `src` 子文件夹中添加一个子文件夹，然后项目的文件夹结构将如下所示：
- en: '![The Jasmine test suite for Angular](img/image_02_003.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 的 Jasmine 测试套件](img/image_02_003.jpg)'
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the Angular project, we will use TypeScript rather than plain JavaScript
    as Angular officially suggests using TypeScript. So, we hope that we all know
    the TypeScript syntax and know how to compile to JS.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 项目中，我们将使用 TypeScript 而不是纯 JavaScript，因为 Angular 官方建议使用 TypeScript。因此，我们希望我们都了解
    TypeScript 语法，并知道如何编译成 JS。
- en: In this book, for the Angular test suite, we will use SystemJS as the module
    loader, as Angular officially suggests it; we will take a look at SystemJS.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，对于 Angular 测试套件，我们将使用 SystemJS 作为模块加载器，因为 Angular 官方建议这样做；我们将看看 SystemJS。
- en: This sample Angular test suite is just to show how easily we can make a test
    suite for an Angular project, though it's not following the best practices and
    the best way to load the modules.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例 Angular 测试套件只是为了展示我们如何轻松地为 Angular 项目创建测试套件，尽管它并不遵循最佳实践和加载模块的最佳方式。
- en: In [Chapter 3](ch03.html "Chapter 3. The Karma Way"), *The Karma Way*, we will
    update this test suite with real-life examples and use SystemJS as the module
    loader.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.html "第 3 章。Karma 方式")《Karma 方式》中，我们将使用真实世界的示例更新这个测试套件，并使用 SystemJS
    作为模块加载器。
- en: There is a seed project from the Angular team in GitHub called as `Angular2-seed`
    to bootstrap any Angular project with test suite; we will follow that one for
    our real Angular project.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub上，Angular团队有一个名为`Angular2-seed`的种子项目，用于启动任何带有测试套件的Angular项目；我们将遵循这个项目来构建我们的真实Angular项目。
- en: 'If we look at the folder structure, it''s almost the same as the previous one,
    and there are minimum changes in the spec file as well; the only change in spec
    is with TypeScript:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看文件夹结构，它与上一个版本几乎相同，spec文件中的更改也最小；spec文件中唯一的更改是与TypeScript相关的：
- en: '[PRE6]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As this is also a browser-based test suite, we have to point `unit-tests.html`
    in a web browser to get the test result. We will have all the tests passed, and
    our test result will look like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这也是一个基于浏览器的测试套件，我们必须在网页浏览器中指向`unit-tests.html`以获取测试结果。我们将通过所有测试，并且我们的测试结果将看起来像这样：
- en: '![The Jasmine test suite for Angular](img/image_02_004.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Angular的Jasmine测试套件](img/image_02_004.jpg)'
- en: Self-test questions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我测试题
- en: Self-test questions will help you further test your knowledge of using TDD for
    JavaScript application testing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 自我测试题将帮助你进一步测试使用TDD进行JavaScript应用程序测试的知识。
- en: Q1\. End-to-end testing means what kind of test?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 端到端测试意味着什么类型的测试？
- en: Functional test
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Behavior test
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为测试
- en: Q2\. Protractor is a Unit testing framework.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. Protractor是一个单元测试框架。
- en: 'True'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假的
- en: Q3\. PhantomJS is a type of browser.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. PhantomJS是一种浏览器类型。
- en: 'True'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假的
- en: Q4\. What is QUnit a test framework for?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. QUnit是一个测试框架用于什么？
- en: jQuery
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery
- en: Angular
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular
- en: NodeJS
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NodeJS
- en: Q5\. Setup and teardown is a feature of Jasmine.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Q5. 设置和清理是Jasmine的一个特性。
- en: 'True'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假的
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed different mechanisms of testing TDD and covered
    automated testing. We reviewed different kinds of JavaScript testing frameworks
    and tools and reviewed the uses of those frameworks with their pros and cons.
    We also reviewed some common assertions from Jasmine and tried, hands on, how
    they worked.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了TDD的不同测试机制，并涵盖了自动化测试。我们回顾了不同种类的JavaScript测试框架和工具，并回顾了这些框架的使用及其优缺点。我们还回顾了一些Jasmine的常见断言，并亲自动手尝试了它们的工作方式。
- en: In the next chapter, we will learn about Karma and see how that works with the
    Angular test suite.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Karma，并了解它是如何与Angular测试套件一起工作的。
