<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer021">
			<h1 id="_idParaDest-30"><em class="italic"><a id="_idTextAnchor029"/>Chapter 2</em>: Working with React Testing Library</h1>
			<p>By the end of this chapter, you will know how to add React Testing Library to React projects. React Testing Library is a modern tool for testing the UI output of React components from the perspective of end users. You will learn how to properly structure tests using the methods from the API. You will learn how to test presentational components. Finally, you will learn how to use the <strong class="source-inline">debug</strong> method to assist in building out your tests. </p>
			<p>In this chapter, we're going to cover the following topics:</p>
			<ul>
				<li>Adding React Testing Library to existing projects</li>
				<li>Structuring tests with React Testing Library</li>
				<li>Testing presentational components</li>
				<li>Using the <strong class="source-inline">debug</strong> method while writing tests</li>
			</ul>
			<p>The skills you will learn in this chapter will set the foundation for more complex component scenarios in later chapters.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Technical requirements</h1>
			<p>For the examples in this chapter, you will need to have Node.js installed on your machine. We will be using the <strong class="source-inline">create-react-app</strong> CLI tool for all code examples. Please familiarize yourself with the tool before starting the chapter if needed. You can find code examples for this chapter here: <a href="https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter02">https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter02</a>.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Adding React Testing Library to existing projects</h1>
			<p>To get started<a id="_idIndexMarker036"/> with React Testing Library, the first thing we need to do is install the tool into our React project. We can either install it manually or use <strong class="source-inline">create-react-app</strong>, a specific React tool that automatically has React Testing Library installed for you.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Manual installation</h2>
			<p>Add React Testing Library<a id="_idIndexMarker037"/> to your project using the following command:</p>
			<p class="source-code">npm install --save-dev @testing-library/react</p>
			<p>Once the tool is installed into your project, you can import the available API methods to use inside your test files.</p>
			<p>Next, we will see how to start a React project with React Testing Library when it is already installed for you.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Automatic installation with create-react-app</h2>
			<p>The <strong class="source-inline">create-react-app</strong> tool allows you to<a id="_idIndexMarker038"/> create a one-page React application quickly. The <strong class="source-inline">create-react-app</strong> tool provides a sample application and an associated test to get you started. React Testing Library has become so popular that as of version 3.3.0, the <strong class="source-inline">create-react-app</strong> team added React Testing Library as the default testing tool. The <strong class="source-inline">create-react-app</strong> tool also includes the <strong class="source-inline">user-event</strong> and <strong class="source-inline">jest-dom</strong> utilities. We previously went over <strong class="source-inline">jest-dom</strong> in <a href="B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Exploring React Testing Library</em>. We will cover the <strong class="source-inline">user-event</strong> utility in <a href="B16887_03_Final_PG_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a>, <em class="italic">Testing Complex Components with React Testing Library</em>.</p>
			<p>So, if you are using at least version 3.3.0 of <strong class="source-inline">create-react-app</strong>, you get a React application with React Testing Library, <strong class="source-inline">user-event</strong>, and <strong class="source-inline">jest-dom</strong> automatically installed and configured.</p>
			<p>There are two ways you can run the <strong class="source-inline">create-react-app</strong> tool to create a new React application. By default, both ways of running the <strong class="source-inline">create-react-app</strong> tool will automatically install the latest version of <strong class="source-inline">create-react-app</strong>. The first way is with <strong class="source-inline">npx</strong>, which allows you to create a React project without needing to have the <strong class="source-inline">create-react-app</strong> tool globally installed on your local machine:</p>
			<p class="source-code">npx create-react-app your-project-title-here --use-npm</p>
			<p>When using the preceding command, be sure to replace <strong class="source-inline">your-project-title-here</strong> with a title to describe your unique project. Also, notice the <strong class="source-inline">--use-npm</strong> flag at the end of the command. By default, when you create a project using <strong class="source-inline">create-react-app</strong>, it uses Yarn as the package manager for the project. We will use <strong class="source-inline">npm</strong> as the package manager<a id="_idIndexMarker039"/> throughout this book. We can tell <strong class="source-inline">create-react-app</strong> we want to use <strong class="source-inline">npm</strong> as the package manager instead of Yarn using the <strong class="source-inline">--use-npm</strong> flag.</p>
			<p>The second way to create a React application with <strong class="source-inline">create-react-app</strong> is by installing the tool globally to run on your local machine. Use the following command to install the tool globally:</p>
			<p class="source-code">npm install -g create-react-app</p>
			<p>In the previous command, we used the <strong class="source-inline">-g</strong> command to globally install the tool on our machine. Once the tool is installed on your machine, run the following command to create a project:</p>
			<p class="source-code">create-react-app your-project-title-here --use-npm</p>
			<p>Like the command we ran in the previous example to create a project using <strong class="source-inline">npx</strong>, we create a new project titled <strong class="source-inline">your-project-title-here</strong> using <strong class="source-inline">npm</strong> as the package manager.</p>
			<p>Now you know how to manually install React Testing Library or have it automatically installed using <strong class="source-inline">create-react-app</strong>. Next, we will learn about common React Testing Library API methods used to structure tests.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Structuring tests with React Testing Library</h1>
			<p>To structure and write<a id="_idIndexMarker040"/> our test code, we will use the <em class="italic">Arrange-Act-Assert</em> pattern that's<a id="_idIndexMarker041"/> typical in writing unit tests. There are<a id="_idIndexMarker042"/> a few ways to use React Testing Library API to structure tests, but we will be using React Testing Library team's recommended approach to render React elements into the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>), select resulting DOM elements, and make assertions on <a id="_idIndexMarker043"/>the expected resulting behavior.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Rendering elements</h2>
			<p>To test your React<a id="_idIndexMarker044"/> components' output, you need a way to render them into the DOM. The React Testing Library's <strong class="source-inline">render</strong> method takes a passed-in component, puts it inside a <strong class="source-inline">div</strong> element, and attaches it to the DOM, as we can see here:</p>
			<p class="source-code">import { render} from '@testing-library/react'</p>
			<p class="source-code">import Jumbotron from './Jumbotron'</p>
			<p class="source-code">it('displays the heading, () =&gt; {</p>
			<p class="source-code">  render(&lt;Jumbotron /&gt;)</p>
			<p class="source-code">}</p>
			<p>In the previous code, we have a test file. First, we import the <strong class="source-inline">render</strong> method from React Testing Library. Next, we import the Jumbotron component we want to test. Finally, we arrange our test code in the <strong class="source-inline">it</strong> method by using the <strong class="source-inline">render</strong> method to render the component to test.</p>
			<p>It is necessary to write additional code to clean up our test in many testing frameworks. For example, if a component is rendered into the DOM for one test, it needs to be removed before the next test is executed. Removing the component from the DOM allows the following test to start from a clean slate and not be affected by code from previous tests. React Testing Library's <strong class="source-inline">render</strong> method makes test cleanup easier by automatically taking care of removing components from the DOM, so there is no need to write additional code to clean up the state affected by previous tests.</p>
			<p>Now that you know how to arrange a test by rendering a component into the DOM for testing, we will learn how to interact with the component's resulting DOM output in the next section.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Selecting elements in the component DOM output</h2>
			<p>Once we have<a id="_idIndexMarker045"/> rendered our component to test into the DOM, the next step is to select elements. We will do this by querying the output as a user would. The DOM Testing Library API has a <strong class="source-inline">screen</strong> object that is included with React Testing Library, allowing you to query the DOM:</p>
			<p class="source-code">import { render, <strong class="bold">screen</strong> } from '@testing-library/react'</p>
			<p>In the previous code, we imported <strong class="source-inline">screen</strong> from React Testing Library just like we imported <strong class="source-inline">render</strong>. The <strong class="source-inline">screen</strong> object exposes many methods, such as <strong class="source-inline">getByText</strong> or <strong class="source-inline">getByRole</strong>, used to query the DOM for elements, similar to actual users that we can use in our tests. For example, we might have a component that renders the following DOM output:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="Images/B16887_02_01.jpg" alt="Figure 2.1 – Jumbotron component&#13;&#10;" width="1316" height="682"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Jumbotron component</p>
			<p>If we wanted to search the DOM for the element with the text <strong class="bold">Welcome to our site!</strong>, we could do so in two ways.</p>
			<p>One way would be using the <strong class="source-inline">getByText</strong> method:</p>
			<p class="source-code">it('displays the heading', () =&gt; {</p>
			<p class="source-code">  render(&lt;Jumbotron /&gt;)</p>
			<p class="source-code">  <strong class="bold">screen.getByText(/welcome to our site!/i)</strong></p>
			<p class="source-code">})</p>
			<p>The <strong class="source-inline">getByText</strong> method will query the DOM, looking for an element with text matching <strong class="bold">Welcome to our site!</strong>. Notice how we use a regular expression inside the <strong class="source-inline">getByText</strong> method. A user looking for <a id="_idIndexMarker046"/>the element wouldn't care if the text was in upper or lower case, so <strong class="source-inline">getByText</strong> and all other <strong class="source-inline">screen</strong> object methods follow the same approach.</p>
			<p>A second way we could query the DOM for the element with the text <strong class="bold">Welcome to our site!</strong> is by using the <strong class="source-inline">getByRole</strong> method: </p>
			<p class="source-code">it('displays the heading, () =&gt; {</p>
			<p class="source-code">  render(&lt;Jumbotron /&gt;)</p>
			<p class="source-code">  <strong class="bold">screen.getByRole('heading', { name: /welcome to our </strong></p>
			<p class="source-code"><strong class="bold">    site!/i })</strong></p>
			<p class="source-code">})</p>
			<p>The <strong class="source-inline">getByRole</strong> method allows you to query the DOM in ways similar to how anyone, including those using screen readers, would search. A screen reader would look for an element with the role <strong class="source-inline">heading</strong> and the text <strong class="source-inline">welcome to our site!</strong>. There are many other methods available on the <strong class="source-inline">screen</strong> object to query elements based on how you decide to find them. The DOM Testing Library team recommends using the <strong class="source-inline">getByRole</strong> method to select elements as much as possible in the documentation.</p>
			<p>Also, because our test code essentially says, <strong class="source-inline">search for a heading element with the text 'welcome to our site!'</strong>, it is more explicit than the previous example, where we used <strong class="source-inline">getByText</strong> to <strong class="source-inline">search for any element that has the text 'welcome to our site!'</strong>.</p>
			<p>In the <em class="italic">Enhancing jest assertions with jest-dom</em> section of <a href="B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Exploring React Testing Library</em>, we learned that the methods of <strong class="source-inline">jest-dom</strong> provide context-specific error messages.</p>
			<p>The methods on the <strong class="source-inline">screen</strong> object provide the same benefits. For example, if you attempt to use <strong class="source-inline">getByRole</strong> to select an element that is not present in the DOM, the method will stop test execution and provide the following error message:</p>
			<p class="source-code">Unable to find an accessible element with the role </p>
			<p class="source-code">  "heading" and name `/fake/i`</p>
			<p>In the previous code, the<a id="_idIndexMarker047"/> error message explicitly tells you that the query method did not find the element. Also, the error message helps by logging elements that are selectable based on the rendered DOM:</p>
			<p class="source-code">heading:</p>
			<p class="source-code">      Name "Logo":</p>
			<p class="source-code">      &lt;h3</p>
			<p class="source-code">        class="navbar-brand mb-0"</p>
			<p class="source-code">        style="font-size: 1.5rem;"</p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">      Name "Welcome to our site!":</p>
			<p class="source-code">      &lt;h1 /&gt;</p>
			<p>In the preceding code, the logged elements help by providing a visual representation of the DOM to understand better why the element you searched for was not found. Now you know how to select elements using React Testing Library.</p>
			<p>We will learn more advanced ways of interacting with components, such as clicking or entering text, in <a href="B16887_03_Final_PG_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a>, <em class="italic">Testing Complex Components with React Testing Library</em>.</p>
			<p>Next, we will learn how to assert the expected output of components.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Asserting expected behavior</h2>
			<p>The last step in the test <a id="_idIndexMarker048"/>structure is to make assertions on behavior. In the <em class="italic">Enhancing jest assertions with jest-dom</em> section of <a href="B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Exploring React Testing Library</em>, we learned how to install and use the <strong class="source-inline">jest-dom</strong> tool to make assertions. Building on our test where we searched for the heading element with the text <strong class="source-inline">welcome to our site!</strong>, we can use the <strong class="source-inline">toBeInTheDocument</strong> method from <strong class="source-inline">jest-dom</strong> to verify whether the element is in the DOM:</p>
			<p class="source-code">it('displays the heading', () =&gt; {</p>
			<p class="source-code">  render(&lt;Jumbotron /&gt;)</p>
			<p class="source-code">  <strong class="bold">expect(</strong></p>
			<p class="source-code"><strong class="bold">    screen.getByRole('heading', { name: /welcome to our </strong></p>
			<p class="source-code"><strong class="bold">      site!/i })</strong></p>
			<p class="source-code"><strong class="bold">  ).toBeInTheDocument()</strong></p>
			<p class="source-code">})</p>
			<p>If the element is not found, we will receive error messages and visual feedback to help determine the source of the problem logged to the console, similar to what we saw in the <em class="italic">Interacting with the component DOM output</em> section. If we get the expected behavior, then we will receive feedback in the console that our test passed, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="Images/B16887_02_02.jpg" alt="Figure 2.2 – Jumbotron component test results" width="811" height="359"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Jumbotron component test results</p>
			<p>In the previous <a id="_idIndexMarker049"/>screenshot, the results indicate that the <strong class="bold">displays the heading</strong> test passes. Now you know how to make assertions on the output of components with React Testing Library. The skills learned in this section have set the foundational skills needed in the next section, where we start testing presentational components.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Testing presentational components</h1>
			<p>In this section, we will use <a id="_idIndexMarker050"/>our knowledge of installing and structuring tests with React Testing Library to test presentational components. Presentational components are components that do not manage state. Typically, you use presentational components to display data passed down from parent components as props or to display hardcoded data directly in the component itself.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Creating snapshot tests</h2>
			<p>Snapshot tests are provided by Jest <a id="_idIndexMarker051"/>and are great to use when you simply want to make sure the HTML output of a component does not change unexpectedly. Suppose a developer does change the component's HTML structure, for example, by adding another paragraph element with static text. In that case, the snapshot test will fail and provide a visual of the changes so you can respond accordingly. The following is an example of a presentational component that renders hardcoded data related to travel services to the DOM:</p>
			<p class="source-code">const Travel = () =&gt; {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div className="card text-center m-1" style={{ width: </p>
			<p class="source-code">      '18rem' }}&gt;</p>
			<p class="source-code">      &lt;i className="material-icons" style={{ fontSize: </p>
			<p class="source-code">         '4rem' }}&gt;</p>
			<p class="source-code">        airplanemode_active</p>
			<p class="source-code">      &lt;/i&gt;</p>
			<p class="source-code">      &lt;h4&gt;Travel Anywhere&lt;/h4&gt;</p>
			<p class="source-code">      </p>
			<p>The component <a id="_idIndexMarker052"/>displays an airplane icon in the previous code snippet in an <strong class="source-inline">&lt;i&gt;</strong> element and a heading inside an <strong class="source-inline">&lt;h4&gt;</strong> element:</p>
			<p class="source-code">&lt;p className="p-1"&gt;</p>
			<p class="source-code">        Our premium package allows you to take exotic trips</p>
			<p class="source-code">          anywhere at the cheapest prices! </p>
			<p class="source-code">      &lt;/p&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Travel</p>
			<p>In the last piece of the component, the preceding code snippet displays text inside a paragraph element. The resulting DOM output looks like the following:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="Images/B16887_02_03.jpg" alt="Figure 2.3 – Travel component" width="602" height="424"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Travel component</p>
			<p>Since the component simply displays a few lines of static hardcoded text, it makes it a good candidate for a snapshot test. In the following example, we use snapshot testing to test the <strong class="source-inline">Travel</strong> component:</p>
			<p class="source-code">import { render } from '@testing-library/react'</p>
			<p class="source-code">import Travel from './Travel'</p>
			<p class="source-code">it('displays the header and paragraph text', () =&gt; {</p>
			<p class="source-code">  const { container } = render(&lt;Travel /&gt;)</p>
			<p>First, in our test file we<a id="_idIndexMarker053"/> import the <strong class="source-inline">render</strong> method from React Testing Library. Next, we import the <strong class="source-inline">Travel</strong> component. Then, we use object destructuring to get <strong class="source-inline">container</strong> off the rendered component. <strong class="source-inline">container</strong> represents the resulting HTML output of the component. Finally, we use the <strong class="source-inline">toMatchInlineSnapshot</strong> method from Jest to capture the resulting HTML output.</p>
			<p>The following is a portion of the snapshot for the <strong class="source-inline">Travel</strong> component output we saw at the beginning of this section:</p>
			<p class="source-code">  expect(container).<strong class="bold">toMatchInlineSnapshot(`</strong></p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      &lt;div</p>
			<p class="source-code">        class="card text-center m-1"</p>
			<p class="source-code">        style="width: 18rem;"</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">        &lt;i</p>
			<p class="source-code">          class="material-icons"</p>
			<p class="source-code">          style="font-size: 4rem;"</p>
			<p class="source-code">        &gt;</p>
			<p class="source-code">          airplanemode_active</p>
			<p class="source-code">        &lt;/i&gt;</p>
			<p>Now, if in the future a<a id="_idIndexMarker054"/> developer changes the output of the <strong class="source-inline">Travel</strong> component, the test will fail and inform us of the unexpected changes. For example, a developer may change the heading from <strong class="source-inline">Travel Anywhere</strong> to <strong class="source-inline">Go Anywhere</strong>:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="Images/B16887_02_04.jpg" alt="Figure 2.4 – Failed travel snapshot test&#13;&#10;" width="1268" height="1012"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Failed travel snapshot test</p>
			<p>The preceding screenshot shows that<a id="_idIndexMarker055"/> the test failed and shows us which lines changed. <strong class="source-inline">Travel Anywhere</strong> is the text the snapshot is expected to receive that differed from the received text, <strong class="bold">Go Anywhere</strong>. Also, the line number, <strong class="bold">8</strong>, and position in the line, <strong class="bold">11</strong>, where the difference was found are also pointed out. If the change was intentional, we can update our snapshot with the new change. Run the following command to update the snapshot:</p>
			<p class="source-code">npm test -- -u</p>
			<p>If your tests are currently running in watch mode, simply press the <em class="italic">U</em> key on your keyboard to update the snapshot. If the change was not intentional, we can simply change the text back to the original value inside the component file.</p>
			<p>Now that you know<a id="_idIndexMarker056"/> how to create snapshot tests for presentational components, we will now learn how to verify properties passed into presentational components.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Testing expected properties</h2>
			<p>Presentational <a id="_idIndexMarker057"/>components can have data passed into them as <strong class="source-inline">props</strong>, instead of hardcoded data directly in the component. The following is an example of a presentational component that expects an array of objects for employees to display in a table:</p>
			<p class="source-code">const Table = props =&gt; {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;table className="table table-striped"&gt;</p>
			<p class="source-code">      &lt;thead className="thead-dark"&gt;</p>
			<p class="source-code">        &lt;tr&gt;</p>
			<p class="source-code">          &lt;th scope="col"&gt;Name&lt;/th&gt;</p>
			<p class="source-code">          &lt;th scope="col"&gt;Department&lt;/th&gt;</p>
			<p class="source-code">          &lt;th scope="col"&gt;Title&lt;/th&gt;</p>
			<p class="source-code">        &lt;/tr&gt;</p>
			<p class="source-code">      &lt;/thead&gt;</p>
			<p>In the preceding code snippet, the component has a table with the headings <strong class="source-inline">Name</strong>, <strong class="source-inline">Department</strong>, and <strong class="source-inline">Title</strong> for each employee. The following is the table body:</p>
			<p class="source-code">      &lt;tbody&gt;</p>
			<p class="source-code">        {props.employees.map(employee =&gt; {</p>
			<p class="source-code">          return (</p>
			<p class="source-code">            &lt;tr key={employee.id}&gt;</p>
			<p class="source-code">              &lt;td&gt;{employee.name}&lt;/td&gt;</p>
			<p class="source-code">              &lt;td&gt;{employee.department}&lt;/td&gt;</p>
			<p class="source-code">              &lt;td&gt;{employee.title}&lt;/td&gt;</p>
			<p class="source-code">            &lt;/tr&gt;</p>
			<p class="source-code">          )</p>
			<p class="source-code">        })}</p>
			<p class="source-code">      &lt;/tbody&gt;</p>
			<p class="source-code">    &lt;/table&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Table</p>
			<p>In the preceding code snippet, we iterate over the <strong class="source-inline">employees</strong> array from the <strong class="source-inline">props</strong> object inside the table body. We<a id="_idIndexMarker058"/> create a table row for each employee, access the employee's name, department, and title, and render the data into a table cell element.</p>
			<p>The following is an example of the resulting DOM output:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="Images/B16887_02_05.jpg" alt="Figure 2.5 – Table component&#13;&#10;" width="749" height="265"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – Table component</p>
			<p>The <strong class="source-inline">Table</strong> component displays rows of employees that match the expected shape of an array of objects with <strong class="bold">Name</strong>, <strong class="bold">Department</strong>, and <strong class="bold">Title</strong> properties. We can test that the component properly accepts and displays the rows of employee data in the DOM:</p>
			<p class="source-code">import { render, screen } from '@testing-library/react'</p>
			<p class="source-code">import fakeEmployees from './mocks/employees'</p>
			<p class="source-code">import Table from './Table'</p>
			<p class="source-code">it('renders with expected values', () =&gt; {</p>
			<p class="source-code">  render(&lt;Table employees={fakeEmployees} /&gt;)</p>
			<p>First, we import the <strong class="source-inline">render</strong> method and <strong class="source-inline">screen</strong> object from React Testing Library. Next, we pass in a fake array of<a id="_idIndexMarker059"/> employee objects called <strong class="source-inline">fakeEmployees</strong>, created for testing purposes, and the <strong class="source-inline">Table</strong> component. The <strong class="source-inline">fakeEmployees</strong> data looks like the following:</p>
			<p class="source-code">const fakeEmployees = [</p>
			<p class="source-code">  {</p>
			<p class="source-code">    id: 1,</p>
			<p class="source-code">    name: 'John Smith',</p>
			<p class="source-code">    department: 'Sales',</p>
			<p class="source-code">    title: 'Senior Sales Agent'</p>
			<p class="source-code">  },</p>
			<p class="source-code">  {</p>
			<p class="source-code">    id: 2,</p>
			<p class="source-code">    name: 'Sarah Jenkins',</p>
			<p class="source-code">    department: 'Engineering',</p>
			<p class="source-code">    title: 'Senior Full-Stack Engineer'</p>
			<p class="source-code">  },</p>
			<p class="source-code">  { id: 3, name: 'Tim Reynolds', department: 'Design', </p>
			<p class="source-code">     title: 'Designer' }</p>
			<p class="source-code">]</p>
			<p>Finally, we create the main test code to verify the <strong class="source-inline">fakeEmployee</strong> data is present in the DOM:</p>
			<p class="source-code">it('renders with expected values', () =&gt; {</p>
			<p class="source-code">  render(&lt;Table employees={fakeEmployees} /&gt;)</p>
			<p class="source-code">  expect(screen.getByRole('cell', { name: /john smith/i </p>
			<p class="source-code">    })).toBeInTheDocument()</p>
			<p class="source-code">  expect(screen.getByRole('cell', { name: /engineering/i </p>
			<p class="source-code">    })).toBeInTheDocument()</p>
			<p class="source-code">  expect(screen.getByRole('cell', { name: /designer/i </p>
			<p class="source-code">    })).toBeInTheDocument()</p>
			<p class="source-code">})</p>
			<p>For the preceding code snippet's assertions, we verified that at least one piece of each object was present in the DOM. You could also verify that every piece of data is present in the DOM if that aligns with your testing objectives. Be sure to verify that your code tests what you expect it is testing. For example, try making the test fail by using the <strong class="source-inline">screen</strong> object to query the DOM for employee data that should not be present. If the test fails, you can be more confident that the code tests what you expect.</p>
			<p>Although most of the time<a id="_idIndexMarker060"/> we want to avoid implementation details and write our tests from the perspective of the user, there may be times where testing specific details is important to our testing goals. For example, if it might be important to you to verify that the striped color theme is present in the rendered version of the table component. The <strong class="source-inline">toHaveAttribute</strong> assertion method of <strong class="source-inline">Jest-dom</strong> can be used in this situation:</p>
			<p class="source-code">it('has the correct class', () =&gt; {</p>
			<p class="source-code">  render(&lt;Table employees={fakeEmployees} /&gt;)</p>
			<p class="source-code">  expect(screen.getByRole('table')).toHaveAttribute(</p>
			<p class="source-code">    'class',</p>
			<p class="source-code">    'table table-striped'</p>
			<p class="source-code">  )</p>
			<p class="source-code">})</p>
			<p>In the preceding code snippet, we created a test to verify that the table component has the correct class attribute. First, we render the <strong class="source-inline">Table</strong> component with employees. Next, we select the <strong class="source-inline">table</strong> element using the <strong class="source-inline">getByRole</strong> method off the <strong class="source-inline">screen</strong> object. Finally, we assert that the component has a <strong class="source-inline">class</strong> attribute with the value <strong class="source-inline">table table-striped</strong>. By using <strong class="source-inline">toHaveAttribute</strong>, we can assert the value of component attributes when needed.</p>
			<p>Now you know how to<a id="_idIndexMarker061"/> test presentational components that accept <strong class="source-inline">props</strong> as data.</p>
			<p>In the next section, we will learn how to use the <strong class="source-inline">debug</strong> method to analyze the current state of component output as we build out our tests.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Using the debug method</h1>
			<p>The <strong class="source-inline">debug</strong> method, accessible<a id="_idIndexMarker062"/> from the <strong class="source-inline">screen</strong> object, is a helpful tool in React Testing Library's API that allows you to see the current HTML output of components as you build out your tests. In this section, we will learn how to display the resulting DOM output of an entire component or specific elements.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Debugging the entire component DOM</h2>
			<p>You can<a id="_idIndexMarker063"/> use the <strong class="source-inline">debug</strong> method to log the entire DOM output of a component when you run your test:</p>
			<p class="source-code">it('displays the header and paragraph text', () =&gt; {</p>
			<p class="source-code">   render(&lt;Travel /&gt;)</p>
			<p class="source-code">   <strong class="bold">screen.debug()</strong></p>
			<p class="source-code">})</p>
			<p>In the preceding code, we first rendered the <strong class="source-inline">Travel</strong> component into the DOM. Next, we invoked the <strong class="source-inline">debug</strong> method. When we run our test, the following will be logged to the console:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="Images/B16887_02_6.jpg" alt="Figure 2.6 – Travel DOM debug&#13;&#10;" width="1290" height="769"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – Travel DOM debug</p>
			<p>In the previous<a id="_idIndexMarker064"/> screenshot, the entire DOM output of the <strong class="source-inline">Travel</strong> component is logged to the screen. Logging the whole output can help you build out your test, especially when interacting with one element in the DOM affects elements elsewhere in the current DOM. Now you know how to log the output of the entire component DOM to the screen. Next, we will learn how to log specific elements of the DOM to the screen.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Debugging specific component elements</h2>
			<p>You can use the <strong class="source-inline">debug</strong> method to<a id="_idIndexMarker065"/> log specific elements of the resulting component DOM to the screen:</p>
			<p class="source-code">it('displays the header and paragraph text', () =&gt; {</p>
			<p class="source-code">  render(&lt;Travel /&gt;)</p>
			<p class="source-code">  <strong class="bold">const header = screen.getByRole('heading', { name: </strong></p>
			<p class="source-code"><strong class="bold">    /travel anywhere/i })</strong></p>
			<p class="source-code">  <strong class="bold">screen.debug(header)</strong></p>
			<p class="source-code">})</p>
			<p>In the previous code, first, we rendered the <strong class="source-inline">Travel</strong> component into the DOM. Next, we used the <strong class="source-inline">getByRole</strong> method to query the DOM for a heading with the name <strong class="source-inline">travel anywhere</strong> and<a id="_idIndexMarker066"/> saved it to a variable named <strong class="source-inline">header</strong>. Next, we invoked the <strong class="source-inline">debug</strong> method and passed in the <strong class="source-inline">header</strong> variable to the method. When we run our test, the following will be logged to the console:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="Images/B16887_02_07.jpg" alt="Figure 2.7 – Travel element debug&#13;&#10;" width="657" height="209"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Travel element debug</p>
			<p>When you pass in a specific DOM node found by using one of the available query methods, the <strong class="source-inline">debug</strong> method only logs the HTML for the particular node. Logging the output for single elements can help you only focus on specific parts of the component. Be sure to remove any <strong class="source-inline">debug</strong> method code from your tests before making commits because you only need it while building out the test.</p>
			<p>Now you know how to use the <strong class="source-inline">debug</strong> method to render the resulting DOM output of your components. The <strong class="source-inline">debug</strong> method is a great visual tool to have while writing new tests and also when troubleshooting failing tests.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Summary</h1>
			<p>In this chapter, you have learned how to install React Testing Library into your React projects. You now understand how to use the API methods to structure your tests. You know how to test presentational components, which serves as foundational knowledge to build on in the following chapters. Finally, you learned how to debug the HTML output of components as you build out your tests.</p>
			<p>In the next chapter, we will learn how to test code with more complexity. We will also learn how to use the <strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) approach to drive test creation.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Questions</h1>
			<ol>
				<li>What method is used to place React components into the DOM?</li>
				<li>Name the object that has methods attached to query the DOM for elements.</li>
				<li>What types of components are good candidates for snapshot tests?</li>
				<li>What method is used for logging the DOM output of components?</li>
				<li>Create and test a presentational component that accepts an array of objects as props.</li>
			</ol>
		</div>
	</div></body></html>