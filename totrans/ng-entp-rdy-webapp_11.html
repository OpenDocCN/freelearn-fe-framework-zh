<html><head></head><body>
  <div id="_idContainer634">
    <h1 class="chapterNumber">11</h1>
    <h1 class="chapterTitle" id="_idParaDest-391">Recipes – Reusability, Routing, and Caching</h1>
    <p class="normal">In the next two chapters, we will complete the majority of the implementation of LemonMart and round out our coverage of the router-first approach. In this chapter, I will reinforce the idea of a decoupled component architecture through the creation of a reusable and routable component that also supports data binding. We use Angular directives to reduce boilerplate code and leverage classes, interfaces, enums, validators, and pipes to maximize code reuse with TypeScript and ES features.</p>
    <p class="normal">In addition, we will create a multi-step form that architecturally scales well and supports a responsive design. Then, we will differentiate between user controls and components by introducing a lemon rater and a reusable form part that encapsulates the name object. </p>
    <div class="note">
      <p class="Information-Box--PACKT-">Make sure to have your <strong class="bold">lemon-mart-server</strong> up and running as you implement the recipes mentioned in this chapter. Refer to <em class="italics">Chapter 10</em>, <em class="italics">RESTful APIs and Full-Stack Implementation</em>, for more information.</p>
    </div>
    <p class="normal">This chapter covers a lot of ground. It is organized in recipe format, so you can quickly refer to a particular implementation when you are working on your projects. I will cover the architecture, design, and major components of the implementations. I will highlight important pieces of code to explain how the solution comes together. Leveraging what you've learned so far, I expect the reader to fill in routine implementation and configuration details. However, you can always refer to the GitHub project if you get stuck.</p>
    <p class="normal">In this chapter, you will learn about the following topics: </p>
    <ul>
      <li class="list">HTTP PUT requests with caching service responses</li>
      <li class="list">Multi-step responsive forms</li>
      <li class="list">Reusing repeating template behavior with directives</li>
      <li class="list">Scalable form architecture with reusable form parts</li>
      <li class="list">Input masking</li>
      <li class="list">Custom controls with <code class="Code-In-Text--PACKT-">ControlValueAccessor</code></li>
      <li class="list">Layouts using grid list</li>
    </ul>
    <p class="normal">The most up-to-date versions of the sample code for the book are on GitHub at the repository linked shortly. The repository contains the final and completed state of the code. You can verify your progress at the end of this chapter by looking at the end-of-chapter snapshot of the code under the <code class="Code-In-Text--PACKT-">projects</code> folder.</p>
    <p class="normal">To get set up for this chapter, do the following:</p>
    <ol>
      <li class="list">Clone the repo at <a href="https://github.com/duluca/lemon-mart"><span class="url">https://github.com/duluca/lemon-mart</span></a>.</li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm install</code> on the root folder to install the dependencies.</li>
      <li class="list">The code sample for this chapter is available under the following subfolder:
        <pre class="programlisting"><code class="hljs">projects/ch11
</code></pre>
      </li>
      <li class="list">To run the Angular app for this chapter, execute the following command:
        <pre class="programlisting"><code class="hljs nginx"><span class="hljs-attribute">npx</span> ng serve ch11
</code></pre>
      </li>
      <li class="list">To run Angular unit tests for this chapter, execute the following command:
        <pre class="programlisting"><code class="hljs bash">npx ng <span class="hljs-built_in">test</span> ch11 --watch=<span class="hljs-literal">false</span>
</code></pre>
      </li>
      <li class="list">To run Angular e2e tests for this chapter, execute the following command:
        <pre class="programlisting"><code class="hljs nginx"><span class="hljs-attribute">npx</span> ng e2e ch11
</code></pre>
      </li>
      <li class="list" value="7">To build a production-ready Angular app for this chapter, execute the following command:
        <pre class="programlisting"><code class="hljs ada">npx ng build ch11 <span class="hljs-comment">--prod</span>
</code></pre>
        <div class="packt_tip">
          <p>Note that the <code class="Code-In-Text--PACKT-">dist/ch11</code> folder at the root of the repository will contain the compiled result.</p>
        </div>
      </li>
    </ol>
    <div class="note">
      <p class="Information-Box--PACKT-">Beware that the source code in the book or on GitHub may not always match the code generated by the Angular CLI. There may also be slight differences in implementation between the code in the book and what's on GitHub because the ecosystem is ever-evolving. It is natural for the sample code to change over time. Also on GitHub, expect to find corrections, fixes to support newer versions of libraries, or side-by-side implementations of multiple techniques for the reader to observe. The reader is only expected to implement the ideal solution recommended in the book. If you find errors or have questions, please create an issue or submit a pull request on GitHub for the benefit of all readers.</p>
    </div>
    <p class="normal"/>
    <div class="packt_tip">
      <p>You can read more about updating Angular in <em class="italics">Appendix C</em>, <em class="italics">Keeping Angular and Tools Evergreen</em>. You can find this appendix online from <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen."><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf</span></a> or at <a href="https://expertlysimple.io/stay-evergreen"><span class="url">https://expertlysimple.io/stay-evergreen</span></a>.</p>
    </div>
    <p class="normal">Let's start with implementing a user service to retrieve data, so we can build out a form to display and edit profile information. Later, we will refactor this form to abstract out its reusable parts.</p>
    <h1 class="title" id="_idParaDest-392">Implementing a user service with GET</h1>
    <p class="normal">In order to <a id="_idIndexMarker1271"/>implement a user profile, we need a service that can perform CRUD operations on <code class="Code-In-Text--PACKT-">IUser</code>. We will be creating a user service <a id="_idIndexMarker1272"/>that implements the following interface:</p>
    <pre class="programlisting"><code class="hljs routeros"><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> interface </span>IUserService {
  getUser(id: string): Observable&lt;IUser&gt;
  updateUser(id: string, user: IUser): Observable&lt;IUser&gt;
  getUsers(
    pageSize: number,
    searchText: string,
    pagesToSkip: number
  ): Observable&lt;IUsers&gt;
}
</code></pre>
    <div class="note">
      <p class="Information-Box--PACKT-">Before creating the service, make sure to start the <strong class="bold">lemon-mart-server</strong> and set your application's <code class="Code-In-Text--PACKT-">AuthMode</code> to <code class="Code-In-Text--PACKT-">CustomServer</code>.</p>
    </div>
    <p class="normal">In this section, we will implement the <code class="Code-In-Text--PACKT-">getUser</code> and <code class="Code-In-Text--PACKT-">updateUser</code> functions. We will implement <code class="Code-In-Text--PACKT-">getUsers</code> in <em class="italics">Chapter 12</em>, <em class="italics">Recipes – Master/Detail, Data Tables, and NgRx</em>, to support pagination with a data table.</p>
    <p class="normal">Start by creating the user service:</p>
    <ol>
      <li class="list" value="1">Create a <code class="Code-In-Text--PACKT-">UserService</code> under <code class="Code-In-Text--PACKT-">src/app/user/user</code></li>
      <li class="list">Declare the <code class="Code-In-Text--PACKT-">IUserService</code> interface from the preceding snippet, excluding the <code class="Code-In-Text--PACKT-">getUsers</code> function.</li>
      <li class="list">Extend the <code class="Code-In-Text--PACKT-">UserService</code> class with <code class="Code-In-Text--PACKT-">CacheService</code> and implement <code class="Code-In-Text--PACKT-">IUserService</code>.</li>
      <li class="list">Inject the <code class="Code-In-Text--PACKT-">HttpClient</code> in the constructor as shown:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>user<span class="hljs-regexp">/user/</span>user.service.ts</strong>
export <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserService</span> {</span>
  getUser(<span class="hljs-string">id:</span> string): Observable&lt;IUser&gt;
  updateUser(<span class="hljs-string">id:</span> string, <span class="hljs-string">user:</span> IUser): Observable&lt;IUser&gt;
}
<span class="hljs-meta">@Injectable</span>({
<span class="hljs-symbol">  providedIn:</span> <span class="hljs-string">'root'</span>,
})
export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CacheService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserService</span> {</span>
  constructor() {
    <span class="hljs-keyword">super</span>()
  }
  getUser(<span class="hljs-string">id:</span> string): Observable&lt;IUser&gt; {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">'Method not implemented.'</span>)
  }
  updateUser(<span class="hljs-string">id:</span> string, <span class="hljs-string">user:</span> IUser): Observable&lt;IUser&gt; {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">'Method not implemented.'</span>)
  }
}
</code></pre>
      </li>
      <li class="list">Implement the <code class="Code-In-Text--PACKT-">getUser</code> function as shown:
        <pre class="programlisting"><code class="hljs qml">src/app/user/user/user.service.ts
getUser(<span class="hljs-attribute">id:</span><span class="hljs-string"> string</span> | <span class="hljs-literal">null</span>): Observable&lt;IUser&gt; {
  <span class="hljs-keyword">if</span> (id === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> throwError(<span class="hljs-string">'User id is not set'</span>)
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.get&lt;IUser&gt;(
    <span class="hljs-string">`<span class="hljs-subst">${environment.baseUrl}</span>/v2/user/<span class="hljs-subst">${id}</span>`</span>
  )
}
</code></pre>
      </li>
    </ol>
    <p class="normal">We provide a <code class="Code-In-Text--PACKT-">getUser</code> function that can load any user's profile information. Note that the security <a id="_idIndexMarker1273"/>for this function is provided in the server <a id="_idIndexMarker1274"/>implementation with the authenticate middleware. The requestor can either get their own profile or they'll need to be a manager. We use <code class="Code-In-Text--PACKT-">getUser</code> with a resolve guard later in the chapter.</p>
    <h2 class="title" id="_idParaDest-393">Implementing PUT with caching</h2>
    <p class="normal">Implement <code class="Code-In-Text--PACKT-">updateUser</code>, which accepts an object that implements the <code class="Code-In-Text--PACKT-">IUser</code> interface, so the <a id="_idIndexMarker1275"/>data can be sent to a PUT endpoint:</p>
    <pre class="programlisting"><code class="hljs typescript"><strong>src/app/user/user/user.service.ts</strong>
  updateUser(id: <span class="hljs-built_in">string</span>, user: IUser): Observable&lt;IUser&gt; {
    <span class="hljs-keyword">if</span> (id === <span class="hljs-string">''</span>) {
      <span class="hljs-keyword">return</span> throwError(<span class="hljs-string">'User id is not set'</span>)
    }
    <span class="hljs-comment">// cache user data in case of errors</span>
    <span class="hljs-keyword">this</span>.setItem(<span class="hljs-string">'draft-user'</span>, <span class="hljs-built_in">Object</span>.assign(user, { _id: id }))
    <span class="hljs-keyword">const</span> updateResponse$ = <span class="hljs-keyword">this</span>.httpClient
      .put&lt;IUser&gt;(<span class="hljs-string">`<span class="hljs-subst">${environment.baseUrl}</span>/v2/user/<span class="hljs-subst">${id}</span>`</span>, user)
      .pipe(<strong>map(User.Build)</strong>, catchError(transformError))
    updateResponse$.subscribe(
      <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
        <span class="hljs-keyword">this</span>.authService.currentUser$.next(res)
        <span class="hljs-keyword">this</span>.removeItem(<span class="hljs-string">'draft-user'</span>)
      },
      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> throwError(err)
    )
    <span class="hljs-keyword">return</span> updateResponse$
  }
</code></pre>
    <p class="normal">Note the <a id="_idIndexMarker1276"/>use of the cache service with <code class="Code-In-Text--PACKT-">setItem</code> to save user-entered data in case the <code class="Code-In-Text--PACKT-">put</code> call fails. When the call succeeds, we remove the cached data using <code class="Code-In-Text--PACKT-">removeItem</code>. Also note how we hydrate a user coming from the server as a <code class="Code-In-Text--PACKT-">User</code> object with <code class="Code-In-Text--PACKT-">map(User.Build)</code>, which calls the constructor of <code class="Code-In-Text--PACKT-">class User</code>.</p>
    <p class="normal">Hydrate is a common term that refers to populating an object with data from a database or a network request. For example, the <code class="Code-In-Text--PACKT-">User</code> JSON object we pass between components or receive from the server fits the <code class="Code-In-Text--PACKT-">IUser</code> interface, but it is not of the <code class="Code-In-Text--PACKT-">class User</code> type. We serialize objects to JSON using the <code class="Code-In-Text--PACKT-">toJSON</code> method. When we hydrate and then instantiate a new object from JSON, we do the reverse and deserialize the data.</p>
    <div class="packt_tip">
      <p>It is important to highlight that you should always stick to interfaces, and not concrete implementations like <code class="Code-In-Text--PACKT-">User</code>, when passing data around. This is the <strong class="bold">D</strong> in <strong class="bold">SOLID</strong> – the Dependency Inversion Principle. Depending on concrete implementations creates a lot of risk, because they change a lot, whereas an abstraction such as <code class="Code-In-Text--PACKT-">IUser</code> will seldom change. After all, you wouldn't solder a lamp directly to the electrical wiring in the wall. Instead, you would first solder the lamp to a plug and then use the plug to get the electricity you need.</p>
    </div>
    <p class="normal">With this code completed, <code class="Code-In-Text--PACKT-">UserService</code> can now be used for basic CRUD operations.</p>
    <h1 class="title" id="_idParaDest-394">Multi-step responsive forms</h1>
    <p class="normal">Overall forms are a different beast than the rest of your application and they require special architectural considerations. I don't recommend over-engineering your form solution with <a id="_idIndexMarker1277"/>dynamic templates or route-enabled components. By definition, the different parts of a form are tightly coupled. From the perspectives of maintainability and ease of implementation, creating one giant component is a better strategy than using some of the aforementioned strategies and over-engineering.</p>
    <p class="normal">We will be implementing a multi-step input form to capture user profile information in a single component. I will be covering my recommended technique to split forms up into multiple components later in the chapter in the <em class="italics">Reusable form parts and scalability</em> section.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Since the implementation of the form changes dramatically between this section and later in the chapter, you can find the code for the initial version on GitHub at <code class="Code-In-Text--PACKT-">projects/ch11/src/app/user/profile/profile.initial.component.ts</code> and <code class="Code-In-Text--PACKT-">projects/ch11/src/app/user/profile/profile.initial.component.html</code>.</p>
    </div>
    <p class="normal">We will also make this multi-step form responsive for mobile devices using media queries:</p>
    <ol>
      <li class="list" value="1">Let's start by adding some helper data that will help us display an input form with options:
        <pre class="programlisting"><code class="hljs pf"><strong>src/app/<span class="hljs-keyword">user</span>/<span class="hljs-keyword">profile</span>/data.ts</strong>
export interface IUSState {
  code: string
  name: string
}
export function USStateFilter(value: string): IUSState[] {
  return USStates.filter((<span class="hljs-keyword">state</span>) =&gt; {
    return (
      (<span class="hljs-keyword">state</span>.code.length === <span class="hljs-number">2</span> &amp;&amp; 
       <span class="hljs-keyword">state</span>.code.<span class="hljs-keyword">to</span>LowerCase() === value.<span class="hljs-keyword">to</span>LowerCase()) ||
       <span class="hljs-keyword">state</span>.name.<span class="hljs-keyword">to</span>LowerCase().indexOf(value.<span class="hljs-keyword">to</span>LowerCase()) === <span class="hljs-number">0</span>
    )
  })
}
const USStates = [
  { code: 'AK', name: 'Alaska' },
  { code: 'AL', name: 'Alabama' },
  ...
  { code: 'WY', name: 'Wyoming' },
]
</code></pre>
      </li>
      <li class="list">Add new <a id="_idIndexMarker1278"/>validation rules to <code class="Code-In-Text--PACKT-">common/validations.ts</code>:
        <pre class="programlisting"><code class="hljs tex"><strong>src/app/common/validations.ts</strong>
...
export const OptionalTextValidation = [Validators.minLength(2), Validators.maxLength(50)]
export const RequiredTextValidation = OptionalTextValidation.concat([Validators.required])
export const OneCharValidation = [Validators.minLength(1), Validators.maxLength(1)]
export const USAZipCodeValidation = [
  Validators.required,
  Validators.pattern(/^<span class="hljs-tag">\<span class="hljs-name">d</span><span class="hljs-string">{5}</span></span>(?:[-<span class="hljs-tag">\<span class="hljs-name">s</span></span>]<span class="hljs-tag">\<span class="hljs-name">d</span><span class="hljs-string">{4}</span></span>)?<span class="hljs-formula">$/),
]
export const USAPhoneNumberValidation = [
  Validators.required,
  Validators.pattern(/^<span class="hljs-tag">\<span class="hljs-name">D</span></span>?(<span class="hljs-tag">\<span class="hljs-name">d</span><span class="hljs-string">{3}</span></span>)<span class="hljs-tag">\<span class="hljs-name">D</span></span>?<span class="hljs-tag">\<span class="hljs-name">D</span></span>?(<span class="hljs-tag">\<span class="hljs-name">d</span><span class="hljs-string">{3}</span></span>)<span class="hljs-tag">\<span class="hljs-name">D</span></span>?(<span class="hljs-tag">\<span class="hljs-name">d</span><span class="hljs-string">{4}</span></span>)$</span>/),
]
</code></pre>
      </li>
      <li class="list">Now, implement <code class="Code-In-Text--PACKT-">profile.component.ts</code> as follows:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/user/profile/profile.component.ts</strong>
<span class="hljs-keyword">import</span> { Role } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../auth/auth.enum'</span> 
<span class="hljs-keyword">import</span> { $<span class="hljs-keyword">enum</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'ts-enum-util'</span>
<span class="hljs-keyword">import</span> { IName, IPhone, IUser, PhoneType } 
  <span class="hljs-keyword">from</span> <span class="hljs-string">'../user/user'</span>
...
<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-profile'</span>,
  templateUrl: <span class="hljs-string">'./profile.component.html'</span>,
  styleUrls: [<span class="hljs-string">'./profile.component.css'</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ProfileComponent <span class="hljs-keyword">implements</span> OnInit {
  Role = Role
  PhoneType = PhoneType
  PhoneTypes = $<span class="hljs-keyword">enum</span>(PhoneType).getKeys()
  formGroup: FormGroup
  states$: Observable&lt;IUSState[]&gt; userError = <span class="hljs-string">''</span>
  currentUserId: <span class="hljs-built_in">string</span>
<span class="hljs-keyword">constructor</span>(<span class="hljs-params">
  <span class="hljs-keyword">private</span> formBuilder: FormBuilder,
  <span class="hljs-keyword">private</span> uiService: UiService,
  <span class="hljs-keyword">private</span> userService: UserService,
  <span class="hljs-keyword">private</span> authService: AuthService
</span>) {}
ngOnInit() { 
  <span class="hljs-keyword">this</span>.buildForm()
  <span class="hljs-keyword">this</span>.authService.currentUser$
          .pipe(
             filter(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user !== <span class="hljs-literal">null</span>),
             tap(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> { 
              <span class="hljs-keyword">this</span>.currentUserId = user._id
              <span class="hljs-keyword">this</span>.buildForm(user)
            })
           )
          .subscribe()
}
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">get</span> currentUserRole() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authService.authStatus$.value.userRole
  }
buildForm(user?: IUser) {}
...
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Upon load, we request <a id="_idIndexMarker1279"/>the current user from <code class="Code-In-Text--PACKT-">authService</code>, but this might take a while, so we first build an empty form with <code class="Code-In-Text--PACKT-">this.buildForm()</code> as the first statement. We also store the user's ID in the <code class="Code-In-Text--PACKT-">currentUserId</code> property, which we will need later when implementing the <code class="Code-In-Text--PACKT-">save</code> functionality. </p>
    <div class="packt_tip">
      <p>Note that we filter out users that are <code class="Code-In-Text--PACKT-">null</code> or <code class="Code-In-Text--PACKT-">undefined</code>.</p>
    </div>
    <p class="normal">Later in this chapter, we will implement a resolve guard to load a user based on their <code class="Code-In-Text--PACKT-">userId</code> provided on a route to increase the reusability of this component.</p>
    <h2 class="title" id="_idParaDest-395">Form controls and form groups</h2>
    <p class="normal">As you may recall, <code class="Code-In-Text--PACKT-">FormControl</code> objects are the most elemental parts of a form, usually representing <a id="_idIndexMarker1280"/>a single input field. We can use <code class="Code-In-Text--PACKT-">FormGroup</code> to group together a collection of related <code class="Code-In-Text--PACKT-">FormControl</code> objects, such as the <a id="_idIndexMarker1281"/>individual first, middle, and last parts of a person's name. <code class="Code-In-Text--PACKT-">FormGroup</code> objects can also group together a mix of <code class="Code-In-Text--PACKT-">FormControl</code>, <code class="Code-In-Text--PACKT-">FormGroup</code>, and <code class="Code-In-Text--PACKT-">FormArray</code> objects, the latter of which allows us to have dynamically repeating elements. <code class="Code-In-Text--PACKT-">FormArray</code> is covered later in the chapter in the <em class="italics">Dynamic form arrays</em> section.</p>
    <p class="normal">Our form has many input fields, so we will use a <code class="Code-In-Text--PACKT-">FormGroup</code> created by <code class="Code-In-Text--PACKT-">this.formBuilder.group</code> to house our various <code class="Code-In-Text--PACKT-">FormControl</code> objects. Additionally, children <code class="Code-In-Text--PACKT-">FormGroup</code> objects will allow us to maintain the correct shape of the data structure.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Since the implementation of the form changes dramatically between this section and later in the chapter, you can find the code for the initial version on GitHub at <code class="Code-In-Text--PACKT-">projects/ch11/src/app/user/profile/profile.initial.component.ts</code> and <code class="Code-In-Text--PACKT-">projects/ch11/src/app/user/profile/profile.initial.component.html</code>.</p>
    </div>
    <p class="normal">Start building the <code class="Code-In-Text--PACKT-">buildForm</code> function, as follows:</p>
    <pre class="programlisting"><code class="hljs pf"><strong>src/app/<span class="hljs-keyword">user</span>/<span class="hljs-keyword">profile</span>/<span class="hljs-keyword">profile</span>.component.ts</strong>
...
  buildForm(<span class="hljs-keyword">user</span>?: IUser) { 
    this.formGroup =
    this.formBuilder.<span class="hljs-keyword">group</span>({
      email: [
        {
          value: <span class="hljs-keyword">user</span>?.email || '',
          disabled: this.currentUserRole !== Role.Manager,
        },
        EmailValidation,
      ],
      name: this.formBuilder.<span class="hljs-keyword">group</span>({
        first: [<span class="hljs-keyword">user</span>?.name?.first || '', RequiredTextValidation],
        middle: [<span class="hljs-keyword">user</span>?.name?.middle || '', OneCharValidation],
        last: [<span class="hljs-keyword">user</span>?.name?.last || '', RequiredTextValidation],
      }),
      role: [
        {
          value: <span class="hljs-keyword">user</span>?.role || '',
          disabled: this.currentUserRole !== Role.Manager,
        },
        [Validators.required],
      ],
      dateOfBirth: [<span class="hljs-keyword">user</span>?.dateOfBirth || '', Validators.required], 
      address: this.formBuilder.<span class="hljs-keyword">group</span>({
        line1: [<span class="hljs-keyword">user</span>?.address?.line1 || '', RequiredTextValidation],
        line2: [<span class="hljs-keyword">user</span>?.address?.line2 || '', OptionalTextValidation],
        city: [<span class="hljs-keyword">user</span>?.address?.city || '', RequiredTextValidation],
        <span class="hljs-keyword">state</span>: [<span class="hljs-keyword">user</span>?.address?.<span class="hljs-keyword">state</span> || '', RequiredTextValidation],
        zip: [<span class="hljs-keyword">user</span>?.address?.zip || '', USAZipCodeValidation],
      }),
    })
  }
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">buildForm</code> optionally accepts an <code class="Code-In-Text--PACKT-">IUser</code> to prefill the form, otherwise, all fields are set to their default values. The <code class="Code-In-Text--PACKT-">formGroup</code> property itself is the top-level <code class="Code-In-Text--PACKT-">FormGroup</code>. Various <code class="Code-In-Text--PACKT-">FormControls</code> are added to it, such as <code class="Code-In-Text--PACKT-">email</code>, with validators attached to them as needed. Note how <code class="Code-In-Text--PACKT-">name</code> and <code class="Code-In-Text--PACKT-">address</code> are their own <code class="Code-In-Text--PACKT-">FormGroup</code> objects. This parent-child relationship <a id="_idIndexMarker1282"/>ensures the proper structure <a id="_idIndexMarker1283"/>of the form data, when serialized to JSON, which fits the structure of <code class="Code-In-Text--PACKT-">IUser</code> in a manner that the rest of our application and server-side code can utilize.</p>
    <p class="normal">You will be completing the implementation of the <code class="Code-In-Text--PACKT-">formGroup</code> independently by following the sample code provided for the chapter. I will be going over sections of the code piece by piece over the next few sections to explain certain key capabilities.</p>
    <h2 class="title" id="_idParaDest-396">Stepper and responsive layout</h2>
    <p class="normal">Angular Material's stepper ships with the <code class="Code-In-Text--PACKT-">MatStepperModule</code>. The stepper allows for form inputs <a id="_idIndexMarker1284"/>to be broken up into multiple steps so that the user is not overwhelmed with processing dozens of input fields all at once. The user <a id="_idIndexMarker1285"/>can still track their place in the process and, as a side effect, as the developer, we break up our <code class="Code-In-Text--PACKT-">&lt;form&gt;</code> implementation and enforce validation rules on a step-by-step basis or create optional workflows where certain steps can be skipped or required. As with all Material user controls, the stepper has been designed with a responsive UX in mind. In the next few sections, we will implement three steps covering different form-input techniques in the process:</p>
    <ol>
      <li class="list" value="1">Account <a id="_idIndexMarker1286"/>information<ul>
          <li class="Bullet-Within-Bullet--PACKT-">Input validation</li>
          <li class="Bullet-Within-Bullet--PACKT-">Responsive layout with media queries </li>
          <li class="Bullet-Within-Bullet--PACKT-">Calculated properties</li>
          <li class="Bullet-Within-Bullet-End--PACKT-">DatePicker</li>
        </ul>
      </li>
      <li class="list">Contact <a id="_idIndexMarker1287"/>information<ul>
          <li class="Bullet-Within-Bullet--PACKT-">Typeahead support</li>
          <li class="Bullet-Within-Bullet-End--PACKT-">Dynamic form arrays</li>
        </ul>
      </li>
      <li class="list" value="3">Review<ul>
          <li class="Bullet-Within-Bullet--PACKT-">Read-only views</li>
          <li class="Bullet-Within-Bullet-End--PACKT-">Saving and clearing data</li>
        </ul>
      </li>
    </ol>
    <p class="normal">Let's prep the <code class="Code-In-Text--PACKT-">UserModule</code> for some new Material modules:</p>
    <div class="note">
      <p class="Information-Box--PACKT-">As we start adding sub-Material modules, it makes sense to rename our root <code class="Code-In-Text--PACKT-">material.module.ts</code> file to <code class="Code-In-Text--PACKT-">app-material.modules.ts</code> in line with how <code class="Code-In-Text--PACKT-">app-routing.module.ts</code> is named. Going forward, I will be using the latter convention.</p>
    </div>
    <ol>
      <li class="list" value="1">Rename the <code class="Code-In-Text--PACKT-">src/app/material.modules.ts</code> file to <code class="Code-In-Text--PACKT-">app-material.module.ts</code>, and then rename the <code class="Code-In-Text--PACKT-">MaterialModule</code> class to <code class="Code-In-Text--PACKT-">AppMaterialModule</code>.</li>
      <li class="list">Create a <code class="Code-In-Text--PACKT-">user-material.module.ts</code> file containing the following Material modules:
        <pre class="programlisting"><code class="hljs autohotkey"><span class="hljs-built_in">MatAutocompleteModule,</span>
<span class="hljs-built_in">MatDatepickerModule,</span>
<span class="hljs-built_in">MatDividerModule,</span>
<span class="hljs-built_in">MatLineModule,</span>
<span class="hljs-built_in">MatNativeDateModule,</span>
<span class="hljs-built_in">MatRadioModule,</span>
<span class="hljs-built_in">MatSelectModule,</span>
<span class="hljs-built_in">MatStepperModule,</span>
</code></pre>
      </li>
      <li class="list">Ensure <code class="Code-In-Text--PACKT-">user.module.ts</code> correctly imports the following:<ul>
          <li class="Bullet-Within-Bullet--PACKT-">The new <code class="Code-In-Text--PACKT-">user-material.module</code></li>
          <li class="Bullet-Within-Bullet--PACKT-">The baseline <code class="Code-In-Text--PACKT-">app-material.module</code></li>
          <li class="Bullet-Within-Bullet-End--PACKT-">The required <code class="Code-In-Text--PACKT-">ReactiveFormsModule</code> and <code class="Code-In-Text--PACKT-">FlexLayoutModule</code></li>
        </ul>
      </li>
      <li class="list">Implement a <a id="_idIndexMarker1288"/>horizontal stepper with a form containing the first step:<div class="note">
          <p class="Information-Box--PACKT-">Since the implementation of the form changes dramatically between this section and later in the chapter, you can find the code for the initial version on GitHub at <code class="Code-In-Text--PACKT-">projects/ch11/src/app/user/profile/profile.initial.component.ts</code> and <code class="Code-In-Text--PACKT-">projects/ch11/src/app/user/profile/profile.initial.component.html</code>.</p>
        </div>
        <pre class="programlisting"><code class="hljs xml"><strong>src/app/user/profile/profile.component.html</strong>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-toolbar</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"accent"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>User Profile<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-toolbar</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-horizontal-stepper</span> #<span class="hljs-attr">stepper</span>=<span class="hljs-string">"matHorizontalStepper"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-step</span> [<span class="hljs-attr">stepControl</span>]=<span class="hljs-string">"formGroup"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"formGroup"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> <span class="hljs-attr">matStepLabel</span>&gt;</span>Account Information<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stepContent"</span>&gt;</span>
        ...
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">mat-step</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-horizontal-stepper</span>&gt;</span>
</code></pre>
      </li>
      <li class="list">Now, start <a id="_idIndexMarker1289"/>implementing the <code class="Code-In-Text--PACKT-">name</code> row of the <code class="Code-In-Text--PACKT-">Account Information</code> step in place of the ellipses in the preceding step:
        <pre class="programlisting"><code class="hljs stata"><strong>src/<span class="hljs-keyword">app</span>/user/profile/profile.component.html</strong>
&lt;div fxLayout=<span class="hljs-string">"row"</span> fxLayout.lt-sm=<span class="hljs-string">"column"</span> [formGroup]=<span class="hljs-string">"formGroup.get('name')"</span>
          fxLayoutGap=<span class="hljs-string">"10px"</span>&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field appearance=<span class="hljs-string">"outline"</span> fxFlex=<span class="hljs-string">"40%"</span>&gt;
    &lt;<span class="hljs-keyword">input</span> matInput placeholder=<span class="hljs-string">"First Name"</span>
      aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"First Name"</span> formControlName=<span class="hljs-string">"first"</span>&gt;
    &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> 
<span class="hljs-comment">      *ngIf="formGroup.get('name.first')?.hasError('required')"&gt;</span>
      First Name is required
    &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
    &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> 
<span class="hljs-comment">      *ngIf="formGroup.get('name.first')?.hasError('minLength')"&gt;</span>
      Must be at least 2 characters
    &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
    &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> 
<span class="hljs-comment">      *ngIf="formGroup.get('name.first')?.hasError('maxLength')"&gt;</span>
      Can't exceed 50 characters
    &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
  &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field appearance=<span class="hljs-string">"outline"</span> fxFlex=<span class="hljs-string">"20%"</span>&gt;
    &lt;<span class="hljs-keyword">input</span> matInput placeholder=<span class="hljs-string">"MI"</span> aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"Middle Initial"</span>
           formControlName=<span class="hljs-string">"middle"</span>&gt;
    &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> *ngIf=<span class="hljs-string">"formGroup.get('name.middle')?.invalid"</span>&gt;
      Only initial
    &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
  &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field appearance=<span class="hljs-string">"outline"</span> fxFlex=<span class="hljs-string">"40%"</span>&gt;
    &lt;<span class="hljs-keyword">input</span> matInput placeholder=<span class="hljs-string">"Last Name"</span> aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"Last Name"</span>
           formControlName=<span class="hljs-string">"last"</span>&gt;
    &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>   
<span class="hljs-comment">       *ngIf="formGroup.get('name.last')?.hasError('required')"&gt;</span>
       Last Name is required
    &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
    &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> 
<span class="hljs-comment">       *ngIf="formGroup.get('name.last')?.hasError('minLength')"&gt;</span>
       Must be at least 2 characters
    &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
    &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> 
<span class="hljs-comment">      *ngIf="formGroup.get('name.last')?.hasError('maxLength')"&gt;</span>
      Can't exceed 50 characters
    &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
  &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field&gt;
&lt;/div&gt;
</code></pre>
      </li>
      <li class="list" value="6">Take care <a id="_idIndexMarker1290"/>to understand how the stepper <a id="_idIndexMarker1291"/>and the form configuration work so far. You should see the first row render, pulling in data <a id="_idIndexMarker1292"/>from <strong class="bold">lemon-mart-server</strong>:<figure class="mediaobject"><img alt="" src="../Images/B14094_11_01.png"/></figure>
        <p class="packt_figref">Figure 11.1: Multi-step form – Step 1</p>
      </li>
    </ol>
    <p class="normal">Note <a id="_idIndexMarker1293"/>that adding <code class="Code-In-Text--PACKT-">fxLayout.lt-sm="column"</code> to a <a id="_idIndexMarker1294"/>row with <code class="Code-In-Text--PACKT-">fxLayout="row"</code> enables a responsive layout of the form, as shown:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_02.png"/></figure>
    <p class="packt_figref">Figure 11.2: Multi-step form on mobile</p>
    <p class="normal">Before <a id="_idIndexMarker1295"/>we move on to how to implement the <strong class="bold">Date of Birth</strong> ﬁeld, let's reevaluate <a id="_idIndexMarker1296"/>our strategy by implementing error messages.</p>
    <h2 class="title" id="_idParaDest-397">Reusing repeating template behavior with directives</h2>
    <p class="normal">In the previous section, we implemented a <code class="Code-In-Text--PACKT-">mat-error</code> element for every validation error for <a id="_idIndexMarker1297"/>every field part of the <code class="Code-In-Text--PACKT-">name</code> object. This quickly adds up to seven elements for three fields. In <em class="italics">Chapter 8</em>, <em class="italics">Designing Authentication and Authorization</em>, we implemented <code class="Code-In-Text--PACKT-">common/validations.ts</code> to reuse validation rules. We can reuse the behavior we implement within <code class="Code-In-Text--PACKT-">mat-error</code>, or any other <code class="Code-In-Text--PACKT-">div</code> for that matter, using an attribute directive.</p>
    <h3 class="title" id="_idParaDest-398">Attribute directives</h3>
    <p class="normal">In <em class="italics">Chapter 1</em>, <em class="italics">Introduction to Angular and Its Concepts</em>, I mentioned that Angular components represent the most basic unit of an Angular app. With components, we define our own HTML elements that can reuse features and functionality represented by a template and some TypeScript code. On the other hand, a directive augments the capabilities of an existing element or <a id="_idIndexMarker1298"/>component. In a sense, a component is a super directive that augments basic HTML capabilities.</p>
    <p class="normal">With this view in mind, we can define three kinds of directives:</p>
    <ul>
      <li class="list">Components</li>
      <li class="list">Structural directives</li>
      <li class="list">Attribute directives</li>
    </ul>
    <p class="normal">Basically, components are directives with templates, and this is the most common type of directive you will use. Structural directives modify the DOM by adding or removing elements, <code class="Code-In-Text--PACKT-">*ngIf</code> and <code class="Code-In-Text--PACKT-">*ngFor</code> being the canonical examples. Finally, attribute directives allow you to define new attributes that you can add to HTML elements or components to add new behavior to them.</p>
    <p class="normal">Let's implement an attribute directive that can encapsulate field-level error behavior.</p>
    <h3 class="title" id="_idParaDest-399">Field error attribute directive</h3>
    <p class="normal">Imagine how <a id="_idIndexMarker1299"/>we could use a directive to reduce repetitive elements to display field errors. Consider the following example using the first name field as an example:</p>
    <pre class="programlisting"><code class="hljs stata"><strong>example</strong>
&lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field appearance=<span class="hljs-string">"outline"</span> fxFlex=<span class="hljs-string">"40%"</span>&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;First Name&lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;
  &lt;<span class="hljs-keyword">input</span> matInput aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"First Name"</span>
         formControlName=<span class="hljs-string">"first"</span> #name /&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> <strong>[<span class="hljs-keyword">input</span>]=<span class="hljs-string">"name"</span> [group]=<span class="hljs-string">"formGroup.get('name')"</span></strong>
<strong>    [appFieldError]=<span class="hljs-string">"ErrorSets.RequiredText"</span>&gt;</strong>
  &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
&lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field&gt;
</code></pre>
    <p class="normal">We have the standard layout structure for a material form field, but there's only a single <code class="Code-In-Text--PACKT-">mat-error</code> element. There are three new properties on <code class="Code-In-Text--PACKT-">mat-error</code>:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">input</code> binds to the HTML <a id="_idIndexMarker1300"/>input element that was tagged with <code class="Code-In-Text--PACKT-">#name</code> using a template reference variable, so that we can tap into the blur event of the input element and be able to read the <code class="Code-In-Text--PACKT-">placeholder</code>, <code class="Code-In-Text--PACKT-">aria-label</code>, and <code class="Code-In-Text--PACKT-">formControlName</code> properties.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">group</code> binds to the <a id="_idIndexMarker1301"/>parent form group object that contains the form control, so using the <code class="Code-In-Text--PACKT-">formControlName</code> property from input, we can retrieve the <code class="Code-In-Text--PACKT-">formControl</code> object, while avoiding extra code.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">appFieldError</code> binds <a id="_idIndexMarker1302"/>to an array of validation errors that need to be checked against the <code class="Code-In-Text--PACKT-">formControl</code> object, such as <code class="Code-In-Text--PACKT-">required</code>, <code class="Code-In-Text--PACKT-">minlength</code>, <code class="Code-In-Text--PACKT-">maxlength</code>, and <code class="Code-In-Text--PACKT-">invalid</code>.</li>
    </ul>
    <p class="normal">Using the preceding information, we can craft a directive that can render one or more lines of error messages inside the <code class="Code-In-Text--PACKT-">mat-error</code> element, effectively replicating the verbose <a id="_idIndexMarker1303"/>method we used in the previous section.</p>
    <p class="normal">Let's go ahead and create an attribute directive named <code class="Code-In-Text--PACKT-">FieldErrorDirective</code>:</p>
    <ol>
      <li class="list" value="1">Create <code class="Code-In-Text--PACKT-">FieldErrorDirective</code> under <code class="Code-In-Text--PACKT-">src/app/user-controls</code>.</li>
      <li class="list">Define the directive's selector as a bindable attribute named <code class="Code-In-Text--PACKT-">appFieldError</code>:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>user-controls<span class="hljs-regexp">/field-error/</span>field-error.directive.ts</strong>
<span class="hljs-meta">@Directive</span>({
<span class="hljs-symbol">  selector:</span> <span class="hljs-string">'</span><strong><span class="hljs-string">[appFieldError]</span></strong><span class="hljs-string">'</span>,
})
</code></pre>
      </li>
      <li class="list">Outside of the directive, define a new type named <code class="Code-In-Text--PACKT-">ValidationError</code>, which defines the kinds of error conditions we will deal with:
        <pre class="programlisting"><code class="hljs routeros"><strong>src/app/user-controls/field-error/field-error.directive.ts</strong>
<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> type </span>ValidationError = 
   <span class="hljs-string">'required'</span> | <span class="hljs-string">'minlength'</span> | <span class="hljs-string">'maxlength'</span> | <span class="hljs-string">'invalid'</span>
</code></pre>
      </li>
      <li class="list">Similar to the way we grouped validations, let's define two sets of commonly occurring error conditions, so we don't have to type them out over and over again:
        <pre class="programlisting"><code class="hljs vim"><strong>src/app/user-controls/field-error/field-error.directive.<span class="hljs-keyword">ts</span></strong>
export const ErrorSet<span class="hljs-variable">s:</span> { [key: <span class="hljs-built_in">string</span>]: ValidationError[] } = {
  OptionalTex<span class="hljs-variable">t:</span> [<span class="hljs-string">'minlength'</span>, <span class="hljs-string">'maxlength'</span>],
  RequiredTex<span class="hljs-variable">t:</span> [<span class="hljs-string">'minlength'</span>, <span class="hljs-string">'maxlength'</span>, <span class="hljs-string">'required'</span>],
}
</code></pre>
      </li>
      <li class="list">Next, let's define the <code class="Code-In-Text--PACKT-">@Input</code> targets for the directive:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>user-controls<span class="hljs-regexp">/field-error/</span>field-error.directive.ts</strong>
export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldErrorDirective</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OnDestroy</span>, <span class="hljs-title">OnChanges</span> {</span>
  <span class="hljs-meta">@Input</span>() <span class="hljs-string">appFieldError:</span>
    | ValidationError
    | ValidationError[]
    | { <span class="hljs-string">error:</span> ValidationError; <span class="hljs-string">message:</span> string }
    | { <span class="hljs-string">error:</span> ValidationError; <span class="hljs-string">message:</span> string }[]
  <span class="hljs-meta">@Input</span>() <span class="hljs-string">input:</span> HTMLInputElement | undefined
  <span class="hljs-meta">@Input</span>() <span class="hljs-string">group:</span> FormGroup
  <span class="hljs-meta">@Input</span>() <span class="hljs-string">fieldControl:</span> AbstractControl | <span class="hljs-literal">null</span>
  <span class="hljs-meta">@Input</span>() <span class="hljs-string">fieldLabel:</span> string | undefined
</code></pre>
        <div class="packt_tip">
          <p>Note that we already went over the purpose of the top three attributes. <code class="Code-In-Text--PACKT-">fieldControl</code> and <code class="Code-In-Text--PACKT-">fieldLabel</code> are optional attributes. If <code class="Code-In-Text--PACKT-">input</code> and <code class="Code-In-Text--PACKT-">group</code> are specified, the optional attributes can be auto-populated. Since they are class-wide variables, it made sense to expose them, in case the user wants to override the default behavior of the directive. This is an easy win for creating flexible and reusable controls.</p>
        </div>
      </li>
      <li class="list">Import the <a id="_idIndexMarker1304"/>element reference in the <code class="Code-In-Text--PACKT-">constructor</code>, which can be later used by a <code class="Code-In-Text--PACKT-">renderErrors</code> function display error in the inner HTML of the <code class="Code-In-Text--PACKT-">mat-error</code> element:
        <pre class="programlisting"><code class="hljs delphi"><strong>src/app/user-controls/field-error/field-error.directive.ts</strong>
  <span class="hljs-keyword">private</span> readonly nativeElement: HTMLElement
  <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(<span class="hljs-keyword">private</span> el: ElementRef)</span> <span class="hljs-comment">{
    this.nativeElement = this.el.nativeElement
  }</span>
  <span class="hljs-title">renderErrors</span><span class="hljs-params">(errors: <span class="hljs-keyword">string</span>)</span> <span class="hljs-comment">{
    this.nativeElement.innerHTML = errors
  }</span>
</span></code></pre>
      </li>
      <li class="list">Implement a function that can return canned error messages depending on the error type:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/user-controls/field-error/field-error.directive.ts</strong>
  getStandardErrorMessage(error: ValidationError): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">const</span> label = <span class="hljs-keyword">this</span>.fieldLabel || <span class="hljs-string">'Input'</span>
    <span class="hljs-keyword">switch</span> (error) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'required'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${label}</span> is required`</span>
      <span class="hljs-keyword">case</span> <span class="hljs-string">'minlength'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${label}</span> must be at least <span class="hljs-subst">${
          <span class="hljs-keyword">this</span>.fieldControl?.getError(error)?.requiredLength ?? <span class="hljs-number">2</span>
        }</span> characters`</span>
      <span class="hljs-keyword">case</span> <span class="hljs-string">'maxlength'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${label}</span> can\'t exceed <span class="hljs-subst">${
          <span class="hljs-keyword">this</span>.fieldControl?.getError(error)?.requiredLength ?? <span class="hljs-number">50</span>
        }</span> characters`</span>
      <span class="hljs-keyword">case</span> <span class="hljs-string">'invalid'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">`A valid <span class="hljs-subst">${label}</span> is required`</span>
    }
  }
</code></pre>
        <div class="packt_tip">
          <p>Note that we can extract the required <code class="Code-In-Text--PACKT-">minlength</code> or <code class="Code-In-Text--PACKT-">maxlength</code> amount dynamically from the <code class="Code-In-Text--PACKT-">fieldControl</code>, greatly reducing the number of custom messages we need to generate.</p>
        </div>
      </li>
      <li class="list">Implement the <a id="_idIndexMarker1305"/>algorithm that can loop through all the elements in <code class="Code-In-Text--PACKT-">appFieldError</code> and the errors that need to be displayed in an array using the <code class="Code-In-Text--PACKT-">getStandardErrorMessage</code> method:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/user-controls/field-error/field-error.directive.ts</strong>
updateErrorMessage() {
    <span class="hljs-keyword">const</span> errorsToDisplay: <span class="hljs-built_in">string</span>[] = []
    <span class="hljs-keyword">const</span> errors = <span class="hljs-built_in">Array</span>.isArray(<span class="hljs-keyword">this</span>.appFieldError)
      ? <span class="hljs-keyword">this</span>.appFieldError
      : [<span class="hljs-keyword">this</span>.appFieldError]
    errors.forEach(
      (error: ValidationError 
            | { error: ValidationError; message: <span class="hljs-built_in">string</span> }) =&gt; {
        <span class="hljs-keyword">const</span> errorCode = 
          <span class="hljs-keyword">typeof</span> error === <span class="hljs-string">'object'</span> ? error.error : error 
        <span class="hljs-keyword">const</span> message =
          <span class="hljs-keyword">typeof</span> error === <span class="hljs-string">'object'</span>
            ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> error.message
            : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.getStandardErrorMessage(errorCode)
        <span class="hljs-keyword">const</span> errorChecker =
          errorCode === <span class="hljs-string">'invalid'</span>
            ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.fieldControl?.invalid
            : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.fieldControl?.hasError(errorCode)
        <span class="hljs-keyword">if</span> (errorChecker()) {
          errorsToDisplay.push(message())
        }
      }
    )
    <span class="hljs-keyword">this</span>.renderErrors(errorsToDisplay.join(<span class="hljs-string">'&lt;br&gt;'</span>))
  }
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">At the end, we can display the error messages using the <code class="Code-In-Text--PACKT-">renderErrors</code> method.</p>
        <div class="packt_tip">
          <p>Note the use of function delegates. Since this piece of code will execute hundreds of times a minute, it is important to avoid unnecessary invocations. Function delegates help organize our code better, while deferring the execution of their logic unless absolutely necessary.</p>
        </div>
      </li>
      <li class="list">Now, initialize the <code class="Code-In-Text--PACKT-">fieldControl</code> property, which represents a <code class="Code-In-Text--PACKT-">formControl</code>. We will listen to the <code class="Code-In-Text--PACKT-">valueChanges</code> events of the control and, if the <a id="_idIndexMarker1306"/>validation status is invalid, then we execute our custom <code class="Code-In-Text--PACKT-">updateErrorMessage</code> logic to display error messages:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/user-controls/field-error/field-error.directive.ts</strong>
<span class="hljs-keyword">private</span> controlSubscription: Subscription | <span class="hljs-literal">undefined</span>
ngOnDestroy(): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">this</span>.unsubscribe()
}
unsubscribe(): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">this</span>.controlSubscription?.unsubscribe()
}
initFieldControl() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.input &amp;&amp; <span class="hljs-keyword">this</span>.group) {
      <span class="hljs-keyword">const</span> controlName = <span class="hljs-keyword">this</span>.input.
        getAttribute(<span class="hljs-string">'formControlName'</span>) ?? <span class="hljs-string">''</span>
      <span class="hljs-keyword">this</span>.fieldControl =
        <span class="hljs-keyword">this</span>.fieldControl || <span class="hljs-keyword">this</span>.group.get(controlName)
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.fieldControl) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( 
          <span class="hljs-string">`[appFieldError] couldn't bind to control <span class="hljs-subst">${controlName}</span>`</span>
        )
      }
      <span class="hljs-keyword">this</span>.unsubscribe()
      <span class="hljs-keyword">this</span>.controlSubscription = <span class="hljs-keyword">this</span>.fieldControl?.valueChanges
        .pipe(
          filter(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.fieldControl?.status === <span class="hljs-string">'INVALID'</span>),
          tap(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.updateErrorMessage())
        )
        .subscribe()
    }
  }
</code></pre>
        <div class="packt_tip">
          <p>Note that, since we're subscribing to <code class="Code-In-Text--PACKT-">valueChanges</code>, we must also unsubscribe. We unsubscribe once with <code class="Code-In-Text--PACKT-">ngOnDestroy</code> and again right before subscribing. This is because <code class="Code-In-Text--PACKT-">initFieldControl</code> may be called multiple times. If we don't clear the prior subscription, it will result in a memory leak and related performance issues.</p>
          <p class="Tip-Within-Bullet--PACKT-">Additionally, if we can't bind to a <code class="Code-In-Text--PACKT-">fieldControl</code>, we throw an error message, since this usually points to a coding error.</p>
        </div>
      </li>
      <li class="list" value="10">Finally, we configure all major attributes with the <code class="Code-In-Text--PACKT-">ngOnChanges</code> event, which triggers any time an <code class="Code-In-Text--PACKT-">@Input</code> attribute is updated. This ensures that in the <a id="_idIndexMarker1307"/>case where form elements could be dynamically added or removed, we will always consider the newest values. We call <code class="Code-In-Text--PACKT-">initFieldControl</code> to start listening to value changes, we implement an <code class="Code-In-Text--PACKT-">onblur</code> event handler that triggers <code class="Code-In-Text--PACKT-">updateErrorMessage()</code> for the HTML input element, and we assign the value of <code class="Code-In-Text--PACKT-">fieldLabel</code>:
        <pre class="programlisting"><code class="hljs javascript"><strong>src/app/user-controls/field-error/field-error.directive.ts</strong>
  ngOnChanges(changes: SimpleChanges): <span class="hljs-keyword">void</span> {
    <strong><span class="hljs-keyword">this</span>.initFieldControl()</strong>
    <span class="hljs-keyword">if</span> (changes.input.firstChange) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.input) {
        <strong><span class="hljs-keyword">this</span>.input.onblur = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.updateErrorMessage()</strong>
<strong>        <span class="hljs-keyword">this</span>.fieldLabel</strong> =
          <span class="hljs-keyword">this</span>.fieldLabel ||
          <span class="hljs-keyword">this</span>.input.placeholder ||
          <span class="hljs-keyword">this</span>.input.getAttribute(<span class="hljs-string">'aria-label'</span>) ||
          <span class="hljs-string">''</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
          <span class="hljs-string">`appFieldError.[input] couldn't bind to any input element`</span>
        )
      }
    }
  }
</code></pre>
        <div class="packt_tip">
          <p>Note that if we can't bind to an HTML <code class="Code-In-Text--PACKT-">input</code> element, this usually means that the developer simply forgot to wire things up correctly. In this case, we throw a new <code class="Code-In-Text--PACKT-">Error</code> object, which generates a helpful stack trace in the console, so you can pinpoint the location in the template where the error is happening.</p>
        </div>
      </li>
    </ol>
    <p class="normal">This wraps <a id="_idIndexMarker1308"/>up the implementation of the directive. Now, we need to package the directive in a module named <code class="Code-In-Text--PACKT-">field-error.module.ts</code>:</p>
    <pre class="programlisting"><code class="hljs dts"><strong>src<span class="hljs-meta-keyword">/app/</span>user-controls<span class="hljs-meta-keyword">/field-error/</span>field-error.directive.ts</strong>
  @NgModule({
<span class="hljs-symbol">  imports:</span> [CommonModule, ReactiveFormsModule],
<span class="hljs-symbol">  declarations:</span> [FieldErrorDirective],
<span class="hljs-symbol">  exports:</span> [FieldErrorDirective],
})
export class <span class="hljs-class">FieldErrorModule </span>{}
</code></pre>
    <p class="normal">Now go ahead and use the directive in our existing forms:</p>
    <ol>
      <li class="list" value="1">Import the module in <code class="Code-In-Text--PACKT-">app.module.ts</code> and <code class="Code-In-Text--PACKT-">user.module.ts</code>.</li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">profile.component.html</code> with the new directive.</li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">login.component.html</code> with the new directive.</li>
    </ol>
    <div class="packt_tip">
      <p>Be sure to define <code class="Code-In-Text--PACKT-">ErrorSets</code> as a public property variable in the <code class="Code-In-Text--PACKT-">component</code> class so that you can use it in the template.</p>
    </div>
    <p class="normal">Test your forms to ensure that our validation messages are being displayed as expected and that there are no console errors. </p>
    <p class="normal">Congratulations! You've learned how you can inject new behavior into other elements and components using directives. By doing this, we are able to avoid a lot of repeated code and standardize error messages across our app.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Before moving on, finish implementation of the form by looking at the implementation on GitHub. You can find the code for the form template at <code class="Code-In-Text--PACKT-">projects/ch11/src/app/user/profile/profile.initial.component.html</code> and the <code class="Code-In-Text--PACKT-">component</code> class at <code class="Code-In-Text--PACKT-">projects/ch11/src/app/user/profile/profile.initial.component.ts</code>.</p>
      <p class="Information-Box--PACKT-">Do not include the <code class="Code-In-Text--PACKT-">app-lemon-rater</code> and <code class="Code-In-Text--PACKT-">app-view-user </code>elements, and remove the <code class="Code-In-Text--PACKT-">mask</code> attribute from the phone number, which we will implement later in the chapter. </p>
    </div>
    <p class="normal">Here, you can <a id="_idIndexMarker1309"/>see the User Profile as it will appear on LemonMart:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_03.png"/></figure>
    <p class="packt_figref">Figure 11.3: Profile component in a mostly completed state</p>
    <p class="normal">Next, let's continue going over the <code class="Code-In-Text--PACKT-">profile</code> component and see how the <strong class="bold">Date of Birth</strong> ﬁeld works.</p>
    <h2 class="title" id="_idParaDest-400">Calculated properties and DatePicker</h2>
    <p class="normal">We can display <a id="_idIndexMarker1310"/>calculated properties <a id="_idIndexMarker1311"/>based on user input. For example, to display a person's age based on their date of birth, introduce class properties that calculate the age and display it as follows:</p>
    <pre class="programlisting"><code class="hljs kotlin"><strong>src/app/user/profile/profile.component.ts</strong>
now = new Date()
<span class="hljs-keyword">get</span> dateOfBirth() {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.formGroup.<span class="hljs-keyword">get</span>(<span class="hljs-string">'dateOfBirth'</span>)?.value || <span class="hljs-keyword">this</span>.now
}
<span class="hljs-keyword">get</span> age() {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.now.getFullYear() - <span class="hljs-keyword">this</span>.dateOfBirth.getFullYear()
}
</code></pre>
    <p class="normal">To validate a date within the last hundred years, implement a <code class="Code-In-Text--PACKT-">minDate</code> class property:</p>
    <pre class="programlisting"><code class="hljs gradle"><strong>src<span class="hljs-regexp">/app/u</span>ser<span class="hljs-regexp">/profile/</span>profile.component.ts</strong>
  minDate = <span class="hljs-keyword">new</span> Date(
    <span class="hljs-keyword">this</span>.now.getFullYear() - <span class="hljs-number">100</span>,
    <span class="hljs-keyword">this</span>.now.getMonth(),
    <span class="hljs-keyword">this</span>.now.getDate()
  )
</code></pre>
    <p class="normal">The usage of the calculated properties in the template looks like this:</p>
    <pre class="programlisting"><code class="hljs stata"><strong>src/<span class="hljs-keyword">app</span>/user/profile/profile.component.html</strong>
&lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field appearance=<span class="hljs-string">"outline"</span> fxFlex=<span class="hljs-string">"50%"</span>&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;Date of Birth&lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;
  &lt;<span class="hljs-keyword">input</span> matInput aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"Date of Birth"</span> formControlName=<span class="hljs-string">"dateOfBirth"</span>
    <strong>[min]=<span class="hljs-string">"minDate"</span> [max]=<span class="hljs-string">"now"</span></strong> [matDatepicker]=<span class="hljs-string">"dateOfBirthPicker"</span> #dob /&gt;
  &lt;<span class="hljs-keyword">mat</span>-hint *ngIf=<span class="hljs-string">"formGroup.get('dateOfBirth')?.value"</span>&gt;
    {{ age }} <span class="hljs-built_in">year</span>(s) old
  &lt;/<span class="hljs-keyword">mat</span>-hint&gt;
  &lt;<span class="hljs-keyword">mat</span>-datepicker-toggle matSuffix [<span class="hljs-keyword">for</span>]=<span class="hljs-string">"dateOfBirthPicker"</span>&gt;
  &lt;/<span class="hljs-keyword">mat</span>-datepicker-toggle&gt;
  &lt;<span class="hljs-keyword">mat</span>-datepicker #dateOfBirthPicker&gt;&lt;/<span class="hljs-keyword">mat</span>-datepicker&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> [<span class="hljs-keyword">input</span>]=<span class="hljs-string">"dob"</span> [group]=<span class="hljs-string">"formGroup"</span>
    [appFieldError]=<span class="hljs-string">"{error: 'invalid', message: 'Date must be within the last 100 years'}"</span>&gt;
  &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
&lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field&gt;
</code></pre>
    <div class="packt_tip">
      <p>Refer to the highlighted <code class="Code-In-Text--PACKT-">[min]</code> and <code class="Code-In-Text--PACKT-">[max]</code> attributes in the preceding snippet for the application of the hundred-year date range.</p>
    </div>
    <p class="normal">The <code class="Code-In-Text--PACKT-">DatePicker</code> in action <a id="_idIndexMarker1312"/>looks as follows:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_04.png"/></figure>
    <p class="packt_figref">Figure 11.4: Selecting a date with DatePicker</p>
    <p class="normal">Note that <a id="_idIndexMarker1313"/>dates beyond April 26, 2020 are grayed out. After the date is selected, the calculated age is displayed as follows:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_05.png"/></figure>
    <p class="packt_figref">Figure 11.5: Calculated age property</p>
    <p class="normal">Now, let's move on to the next step, <strong class="bold">Contact Information</strong>, and see how we can enable a convenient <a id="_idIndexMarker1314"/>way to display and input the state <a id="_idIndexMarker1315"/>portion of the address field.</p>
    <h2 class="title" id="_idParaDest-401">Typeahead support</h2>
    <p class="normal">In <code class="Code-In-Text--PACKT-">buildForm</code>, we set <a id="_idIndexMarker1316"/>a listener on <code class="Code-In-Text--PACKT-">address.state</code> to support a typeahead filtering drop-down experience:</p>
    <pre class="programlisting"><code class="hljs pf"><strong>src/app/<span class="hljs-keyword">user</span>/<span class="hljs-keyword">profile</span>/<span class="hljs-keyword">profile</span>.component.ts</strong>
const <span class="hljs-keyword">state</span> = this.formGroup.get('address.<span class="hljs-keyword">state</span>')
if (<span class="hljs-keyword">state</span> != null) {
  this.states$ = <span class="hljs-keyword">state</span>.valueChanges.pipe(
    startWith(''),
    map((value) =&gt; USStateFilter(value))
  )
}
</code></pre>
    <p class="normal">On the template, implement <code class="Code-In-Text--PACKT-">mat-autocomplete</code>, bound to the filtered states array with an <code class="Code-In-Text--PACKT-">async</code> pipe:</p>
    <pre class="programlisting"><code class="hljs stata"><strong>src/<span class="hljs-keyword">app</span>/user/profile/profile.component.html</strong>
...
&lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field appearance=<span class="hljs-string">"outline"</span> fxFlex=<span class="hljs-string">"30%"</span>&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;State&lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;
  &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span> aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"State"</span> matInput formControlName=<span class="hljs-string">"state"</span>
    [matAutocomplete]=<span class="hljs-string">"stateAuto"</span> #state /&gt;
  &lt;<span class="hljs-keyword">mat</span>-autocomplete #stateAuto=<span class="hljs-string">"matAutocomplete"</span>&gt;
    &lt;<span class="hljs-keyword">mat</span>-option *ngFor=<span class="hljs-string">"let state of (states$ | async)"</span> [value]=<span class="hljs-string">"state.name"</span>&gt;
      {{ state.name }}
    &lt;/<span class="hljs-keyword">mat</span>-option&gt;
  &lt;/<span class="hljs-keyword">mat</span>-autocomplete&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> [<span class="hljs-keyword">input</span>]=<span class="hljs-string">"state"</span> [group]=<span class="hljs-string">"formGroup.get('address')"</span>
    appFieldError=<span class="hljs-string">"required"</span>&gt;
  &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
&lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field&gt; 
...
</code></pre>
    <p class="normal">Here's how it looks when a user enters the <code class="Code-In-Text--PACKT-">V</code> character:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_06.png"/></figure>
    <p class="packt_figref">Figure 11.6: Dropdown with typeahead support</p>
    <p class="normal">In the <a id="_idIndexMarker1317"/>next section, let's enable the input of multiple phone numbers.</p>
    <h2 class="title" id="_idParaDest-402">Dynamic form arrays</h2>
    <p class="normal">Note that <code class="Code-In-Text--PACKT-">phones</code> is an array, potentially allowing for many inputs. We can implement this by <a id="_idIndexMarker1318"/>building a <code class="Code-In-Text--PACKT-">FormArray</code> with the <code class="Code-In-Text--PACKT-">this.formBuilder.array</code> function. We also define several helper functions to make it easier to build the <code class="Code-In-Text--PACKT-">FormArray</code>:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">buildPhoneFormControl</code> helps to build <code class="Code-In-Text--PACKT-">FormGroup</code> objects of individual entries.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">buildPhoneArray</code> creates as many <code class="Code-In-Text--PACKT-">FormGroup</code> objects as needed or, if the form is empty, it creates an empty entry.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">addPhone</code> adds a new empty <code class="Code-In-Text--PACKT-">FromGroup</code> object to the <code class="Code-In-Text--PACKT-">FormArray</code>.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">get phonesArray()</code> is a convenient property to get the <code class="Code-In-Text--PACKT-">phones</code> control from the form.</li>
    </ul>
    <p class="normal">Let's see how the implementation comes together:</p>
    <pre class="programlisting"><code class="hljs typescript"><strong>src/app/user/profile/profile.component.ts</strong>
...
phones: <span class="hljs-keyword">this</span>.formBuilder.array(<span class="hljs-keyword">this</span>.buildPhoneArray(user?.phones || [])),
...
  <span class="hljs-keyword">private</span> buildPhoneArray(phones: IPhone[]) {
    <span class="hljs-keyword">const</span> groups = []
    <span class="hljs-keyword">if</span> (phones?.length === <span class="hljs-number">0</span>) {
      groups.push(<span class="hljs-keyword">this</span>.buildPhoneFormControl(<span class="hljs-number">1</span>))
    } <span class="hljs-keyword">else</span> {
      phones.forEach(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> {
        groups.push(
          <span class="hljs-keyword">this</span>.buildPhoneFormControl(p.id, p.type, p.digits)
        )
      })
    }
    <span class="hljs-keyword">return</span> groups
      } 
<span class="hljs-keyword">private</span> buildPhoneFormControl(
  id: <span class="hljs-built_in">number</span>, <span class="hljs-keyword">type</span>?: <span class="hljs-built_in">string</span>, phoneNumber?: <span class="hljs-built_in">string</span>
) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.formBuilder.group({
      id: [id],
      <span class="hljs-keyword">type</span>: [<span class="hljs-keyword">type</span> || <span class="hljs-string">''</span>, Validators.required],
      digits: [phoneNumber || <span class="hljs-string">''</span>, USAPhoneNumberValidation],
  })
} 
...
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">buildPhoneArray</code> supports initialization of a form with a single phone input or filling it with the <a id="_idIndexMarker1319"/>existing data, working in tandem with <code class="Code-In-Text--PACKT-">buildPhoneFormControl</code>. The latter function comes in handy when a user clicks on an <strong class="screen-text">Add</strong> button to create a new row for the entry:</p>
    <pre class="programlisting"><code class="hljs kotlin"><strong>src/app/user/profile/profile.component.ts</strong>
...
addPhone() { <span class="hljs-keyword">this</span>.phonesArray.push(
<span class="hljs-keyword">this</span>.buildPhoneFormControl(
  <span class="hljs-keyword">this</span>.formGroup.<span class="hljs-keyword">get</span>(<span class="hljs-string">'phones'</span>).value.length + <span class="hljs-number">1</span>)
)
}
<span class="hljs-keyword">get</span> phonesArray(): FormArray {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.formGroup.<span class="hljs-keyword">get</span>(<span class="hljs-string">'phones'</span>) <span class="hljs-keyword">as</span> FormArray
}
...
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">phonesArray</code> property getter is a common pattern to make it easier to access certain form properties. However, in this case, it is also necessary because <code class="Code-In-Text--PACKT-">get('phones')</code> must be typecast to <code class="Code-In-Text--PACKT-">FormArray</code> so that we can access the <code class="Code-In-Text--PACKT-">length</code> property on it on the template:</p>
    <pre class="programlisting"><code class="hljs stata"><strong>src/<span class="hljs-keyword">app</span>/user/profile/profile.component.html</strong>
...
&lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">list</span> formArrayName=<span class="hljs-string">"phones"</span>&gt;
  &lt;h2 <span class="hljs-keyword">mat</span>-subheader&gt;Phone Number(s)
    &lt;button <span class="hljs-keyword">mat</span>-button (click)=<span class="hljs-string">"addPhone()"</span>&gt;
      &lt;<span class="hljs-keyword">mat</span>-icon&gt;add&lt;/<span class="hljs-keyword">mat</span>-icon&gt;
      Add Phone
    &lt;/button&gt;
  &lt;/h2&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">list</span>-item style=<span class="hljs-string">"margin-top: 36px;"</span>
<span class="hljs-comment">    *ngFor="let position of phonesArray.controls; let i = index"</span>
      [formGroupName]=<span class="hljs-string">"i"</span>&gt;
    &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field appearance=<span class="hljs-string">"outline"</span> fxFlex=<span class="hljs-string">"100px"</span>&gt;
      &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;<span class="hljs-keyword">Type</span>&lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;
      &lt;<span class="hljs-keyword">mat</span>-select formControlName=<span class="hljs-string">"type"</span>&gt;
        &lt;<span class="hljs-keyword">mat</span>-option *ngFor=<span class="hljs-string">"let type of PhoneTypes"</span>
             [value]=<span class="hljs-string">"</span><strong><span class="hljs-string">convertTypeToPhoneType(type)</span></strong><span class="hljs-string">"</span>&gt;
          {{ <span class="hljs-keyword">type</span> }}
        &lt;/<span class="hljs-keyword">mat</span>-option&gt;
      &lt;/<span class="hljs-keyword">mat</span>-select&gt;
    &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field&gt;
    &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field appearance=<span class="hljs-string">"outline"</span> fxFlex fxFlexOffset=<span class="hljs-string">"10px"</span>&gt;
      &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;Number&lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;
      &lt;<span class="hljs-keyword">input</span> matInput <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span> formControlName=<span class="hljs-string">"digits"</span>
        aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"Phone number"</span> prefix=<span class="hljs-string">"+1"</span> /&gt;
      &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>
<span class="hljs-comment">        *ngIf="phonesArray.controls[i].invalid &amp;&amp;  </span>
               phonesArray.controls[i].touched"&gt;
        A valid phone number is required
      &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
    &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field&gt;
    &lt;button fxFlex=<span class="hljs-string">"33px"</span> <span class="hljs-keyword">mat</span>-icon-button
      (click)=<span class="hljs-string">"</span><strong><span class="hljs-string">phonesArray.removeAt(i)</span></strong><span class="hljs-string">"</span>&gt; 
      &lt;<span class="hljs-keyword">mat</span>-icon&gt;delete&lt;/<span class="hljs-keyword">mat</span>-icon&gt;
    &lt;/button&gt;
  &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">list</span>-item&gt;
&lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">list</span>&gt; 
...
</code></pre>
    <div class="note">
      <p class="Information-Box--PACKT-">Note the highlighted <code class="Code-In-Text--PACKT-">convertTypeToPhoneType</code> function, which converts a <code class="Code-In-Text--PACKT-">string</code> to <code class="Code-In-Text--PACKT-">enum PhoneType</code>.</p>
      <p class="Information-Box--PACKT-">Also highlighted in the preceding code block, note how the <code class="Code-In-Text--PACKT-">remove</code> function is implemented inline in the template, making it easier to read and maintain.</p>
    </div>
    <p class="normal">Let's see <a id="_idIndexMarker1320"/>how the dynamic array should be working:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_07.png"/></figure>
    <p class="packt_figref">Figure 11.7: Multiple inputs using FormArray</p>
    <p class="normal">Now that we're done with inputting data, we can move on to the last step of the stepper, <strong class="bold">Review</strong>. However, as was mentioned earlier, the <strong class="bold">Review</strong> step uses the <code class="Code-In-Text--PACKT-">&lt;app-view-user&gt;</code> directive to display its data. Let's build that view first.</p>
    <h2 class="title" id="_idParaDest-403">Creating shared components</h2>
    <p class="normal">Here's a <a id="_idIndexMarker1321"/>minimal implementation of the <code class="Code-In-Text--PACKT-">&lt;app-view-user&gt;</code> directive that is a prerequisite for the <strong class="bold">Review</strong> step.</p>
    <p class="normal">Create a new <code class="Code-In-Text--PACKT-">viewUser</code> component under the <code class="Code-In-Text--PACKT-">user</code> module, as follows:</p>
    <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/user/view-user/view-user.component.ts</strong>
<span class="hljs-keyword">import</span> { Component, Input, OnChanges, SimpleChanges } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { Router } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>
<span class="hljs-keyword">import</span> { BehaviorSubject } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
<span class="hljs-keyword">import</span> { IUser, User } <span class="hljs-keyword">from</span> <span class="hljs-string">'../user/user'</span>
@Component({
  selector: <span class="hljs-string">'app-view-user'</span>,
  template: `<span class="javascript">
    &lt;div *ngIf=<span class="hljs-string">"currentUser$ | async as currentUser"</span>&gt;
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mat-card</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-header</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">mat-card-avatar</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span>&gt;</span>account_circle<span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-title</span>&gt;</span>
            {{ currentUser.fullName }}
          <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-title</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-subtitle</span>&gt;</span>
            {{ currentUser.role }}
          <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-subtitle</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-header</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-content</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mat-input bold"</span>&gt;</span>E-mail<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ currentUser.email }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mat-input bold"</span>&gt;</span>Date of Birth<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ currentUser.dateOfBirth | date: 'mediumDate' }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-content</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-actions</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"editMode"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-button</span> <span class="hljs-attr">mat-raised-button</span>
                  (<span class="hljs-attr">click</span>)=<span class="hljs-string">"editUser(currentUser._id)"</span>&gt;</span>
            Edit
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-actions</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card</span>&gt;</span></span>
    &lt;<span class="hljs-regexp">/div&gt;
  </span></span>`,
  styles: [
    `<span class="javascript"><span class="hljs-regexp">
      .bold {
        font-weight: bold;
      }
    </span></span>`,
  ],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewUserComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnChanges</span> {</span>
  @Input() user: IUser
  readonly currentUser$ = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-keyword">new</span> User())
  get editMode() {
    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.user
  }
  constructor(private router: Router) {}
  ngOnChanges(changes: SimpleChanges): void {
    <span class="hljs-keyword">this</span>.currentUser$.next(User.Build(changes.user.currentValue))
  }
  editUser(id: string) {
    <span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'/user/profile'</span>, id])
  }
}
</code></pre>
    <p class="normal">The preceding component uses input binding with <code class="Code-In-Text--PACKT-">@Input</code> to get user data, compliant with the <code class="Code-In-Text--PACKT-">IUser</code> interface, from an outside component. We implement the <code class="Code-In-Text--PACKT-">ngOnChanges</code> event, which fires whenever the bound data changes. In this event, we hydrate <a id="_idIndexMarker1322"/>the simple JSON object stored in the <code class="Code-In-Text--PACKT-">user</code> property as an instance of the <code class="Code-In-Text--PACKT-">User</code> class with <code class="Code-In-Text--PACKT-">User.Build</code>.</p>
    <p class="normal">We then define a read-only <code class="Code-In-Text--PACKT-">BehaviorSubject</code>, named <code class="Code-In-Text--PACKT-">this.currentUser$</code>, so we can asynchronously push updates to it using the next function. This flexibility will come in handy when we later make this component reusable in multiple contexts. Even if we wanted to, we couldn't directly bind to <code class="Code-In-Text--PACKT-">user</code>, because calculated properties such as <code class="Code-In-Text--PACKT-">fullName</code> will only work if the data is hydrated into an instance of the <code class="Code-In-Text--PACKT-">User</code> class.</p>
    <p class="normal">Now, we are ready to complete the multi-step form.</p>
    <h2 class="title" id="_idParaDest-404">Reviewing and saving form data</h2>
    <p class="normal">On the last <a id="_idIndexMarker1323"/>step of the multistep form, users should <a id="_idIndexMarker1324"/>be able to review and then save the form data. As a good practice, a successful <code class="Code-In-Text--PACKT-">POST</code> request will return the data that was saved back to the browser. We can then reload the form with the information received back from the server:</p>
    <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/user/profile/profile.component.ts</strong>
...
  async save(form: FormGroup) {
    <span class="hljs-keyword">this</span>.subs.add(
      <span class="hljs-keyword">this</span>.userService
        .updateUser(<span class="hljs-keyword">this</span>.currentUserId, form.value)
        .subscribe(
          <span class="hljs-function"><span class="hljs-params">(res: IUser)</span> =&gt;</span> {
            <strong><span class="hljs-keyword">this</span>.formGroup.patchValue(res)</strong>
            <span class="hljs-keyword">this</span>.uiService.showToast(<span class="hljs-string">'Updated user'</span>)
          },
          <span class="hljs-function"><span class="hljs-params">(err: string)</span> =&gt;</span> (<span class="hljs-keyword">this</span>.userError = err)
      )
    )
  }
...
</code></pre>
    <div class="packt_tip">
      <p>Note that <code class="Code-In-Text--PACKT-">updateUser</code> returns the saved value of the user. It is possible that the database returns a different version of <code class="Code-In-Text--PACKT-">user</code> than what we had before, so we use <code class="Code-In-Text--PACKT-">formGroup.patchValue</code> to update the data powering the form. The form automatically updates to reflect any changes.</p>
    </div>
    <p class="normal">If there are <a id="_idIndexMarker1325"/>errors when saving the data, they'll be set to <code class="Code-In-Text--PACKT-">userError</code> to be displayed on the form. And before saving the data, we present <a id="_idIndexMarker1326"/>it in a compact format with the reusable <code class="Code-In-Text--PACKT-">app-view-user</code> component that we can bind the form data to:</p>
    <pre class="programlisting"><code class="hljs django"><strong><span class="xml">src/app/user/profile/profile.component.html</span></strong><span class="xml">
...
<span class="hljs-tag">&lt;<span class="hljs-name">mat-step</span> [<span class="hljs-attr">stepControl</span>]=<span class="hljs-string">"formGroup"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"formGroup"</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"save(formGroup)"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> <span class="hljs-attr">matStepLabel</span>&gt;</span>Review<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stepContent"</span>&gt;</span>
      Review and update your user profile.
      </span><strong><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">app-view-user</span> [<span class="hljs-attr">user</span>]=<span class="hljs-string">"formGroup.getRawValue()"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-view-user</span>&gt;</span></span></strong><span class="xml">
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">fxLayout</span>=<span class="hljs-string">"row"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"margin-top"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-button</span> <span class="hljs-attr">matStepperPrevious</span>&gt;</span>Back<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex-spacer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"userError"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mat-caption error"</span>&gt;</span>
        </span><span class="hljs-template-variable">{{ </span><strong><span class="hljs-template-variable">userError</span></strong><span class="hljs-template-variable"> }}</span><span class="xml">
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-button</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"warn"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"</span></span></span><strong><span class="xml"><span class="hljs-tag"><span class="hljs-string">stepper.reset()</span></span></span></strong><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>&gt;</span>
        Reset
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-raised-button</span> <span class="hljs-attr">matStepperNext</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span> 
        <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> [<span class="hljs-attr">disabled</span>]=<span class="hljs-string">"formGroup.invalid"</span>&gt;</span>
        Update
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-step</span>&gt;</span>
...
</span></code></pre>
    <div class="packt_tip">
      <p>Note that we use <code class="Code-In-Text--PACKT-">formGroup.getRawValue()</code> to extract the JSON of the form data. See how we bind <code class="Code-In-Text--PACKT-">userError</code> to display error messages. Also, the <strong class="screen-text">Reset</strong> button uses <code class="Code-In-Text--PACKT-">stepper.reset()</code>, which can conveniently reset all the user input.</p>
    </div>
    <p class="normal">This is how <a id="_idIndexMarker1327"/>the final <a id="_idIndexMarker1328"/>product should appear:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_08.png"/></figure>
    <p class="packt_figref">Figure 11.8: Review step</p>
    <p class="normal">Now that the user profile input is done, we are about halfway to our eventual goal of creating a master/detail view where a <strong class="bold">Manager</strong> can click on a user and view their profile details. We still <a id="_idIndexMarker1329"/>have a lot more code to add, and along the way, we have fallen into a pattern of adding lots of boilerplate <a id="_idIndexMarker1330"/>code to load the requisite data for a component.</p>
    <p class="normal">Next, let's refactor our form to make our code reusable and scalable, so even if our form has dozens of fields, the code is still maintainable and we don't introduce an exponential cost increase to make changes.</p>
    <h1 class="title" id="_idParaDest-405">Scaling architecture with reusable form parts</h1>
    <p class="normal">As mentioned in the introduction to the <em class="italics">Multi-step responsive forms</em> section, forms are tightly <a id="_idIndexMarker1331"/>coupled beasts that can grow large, and using the wrong architectural pattern to scale your implementation can cause significant issues when implementing new features or maintaining existing ones.</p>
    <p class="normal">To demonstrate how you can break up your form into multiple parts, we will refactor the form to extract the highlighted section in the following screenshot, the name form group, as its own component. The technique to accomplish this is the same as you'd use when you want to put each step of your form into a separate component:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_09.png"/></figure>
    <p class="packt_figref">Figure 11.9: User profile's name part highlighted</p>
    <p class="normal">By making the name form group reusable, you will also learn about how you can reuse the business logic that you build into that form group in other forms. We will extract the name form group logic into a new component named <code class="Code-In-Text--PACKT-">NameInputComponent</code>. In doing so, we also have an opportunity to extract some reusable form functionality to a <code class="Code-In-Text--PACKT-">BaseFormComponent</code> as an <code class="Code-In-Text--PACKT-">abstract class</code>.</p>
    <p class="normal">There are going to be several components that are working together here, including <code class="Code-In-Text--PACKT-">ProfileComponent</code>, <code class="Code-In-Text--PACKT-">ViewUserComponent</code>, and <code class="Code-In-Text--PACKT-">NameInputComponent</code>. We need all the values in these three components to be up to date as the user enters them.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">ProfileComponent</code> will own the master form to which we'll need to register any child form. Once we do this, all the form validation techniques you've learned so far will still apply. </p>
    <p class="normal">This is <a id="_idIndexMarker1332"/>a key way to make your form able to scale across many components and continue to be easy to work with, without introducing unnecessary validation overhead. Hence, it is useful to review the different interactions between these objects to solidify your understanding of the asynchronous and decoupled nature of their behavior:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_10.png"/></figure>
    <p class="packt_figref">Figure 11.10: Form component interactions</p>
    <div class="packt_tip">
      <p>In this section, we bring together a lot of the different concepts that you've learned over the course of the book. Utilize the preceding diagram to understand how the various form components interact with each other. </p>
      <p>In the preceding diagram, properties in bold indicate data binding. Underlined function elements indicate event registrations. Arrows show the points of connection between the components.</p>
    </div>
    <p class="normal">The workflow begins with the instantiation of <code class="Code-In-Text--PACKT-">ProfileComponent</code>. The <code class="Code-In-Text--PACKT-">OnInit</code> event of the component begins building the <code class="Code-In-Text--PACKT-">formGroup</code> object, while asynchronously loading any potential <code class="Code-In-Text--PACKT-">initialData</code> that may need to be patched into the forms. Refer to the preceding diagram <a id="_idIndexMarker1333"/>for a visual representation of <code class="Code-In-Text--PACKT-">initialData</code> coming in from a service or cache.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">NameInputComponent</code> is used in the <code class="Code-In-Text--PACKT-">ProfileComponent</code> form as <code class="Code-In-Text--PACKT-">&lt;app-name-input&gt;</code>. In order to synchronize <code class="Code-In-Text--PACKT-">initialData</code> with the <code class="Code-In-Text--PACKT-">NameInputComponent</code>, we bind a <code class="Code-In-Text--PACKT-">nameInitialData$</code> subject using the <code class="Code-In-Text--PACKT-">async</code> pipe, since <code class="Code-In-Text--PACKT-">initialData</code> is coming in asynchronously. </p>
    <p class="normal"><code class="Code-In-Text--PACKT-">NameInputComponent</code> implements the <code class="Code-In-Text--PACKT-">OnChanges</code> life cycle hook, so whenever <code class="Code-In-Text--PACKT-">nameInitialData$</code> updates, its value is patched into the <code class="Code-In-Text--PACKT-">NameInputComponent</code> form.</p>
    <p class="normal">Like <code class="Code-In-Text--PACKT-">ProfileComponent</code>, <code class="Code-In-Text--PACKT-">NameInputComponent</code> also implements the <code class="Code-In-Text--PACKT-">OnInit</code> event to construct its <code class="Code-In-Text--PACKT-">formGroup</code> object. Since this is an asynchronous event, <code class="Code-In-Text--PACKT-">NameInputComponent</code> needs to expose a <code class="Code-In-Text--PACKT-">formReady</code> event that <code class="Code-In-Text--PACKT-">ProfileComponent</code> can subscribe to. Once the <code class="Code-In-Text--PACKT-">formGroup</code> object is ready, we emit the event, and the <code class="Code-In-Text--PACKT-">registerForm</code> function on <code class="Code-In-Text--PACKT-">ProfileComponent</code> triggers. <code class="Code-In-Text--PACKT-">registerForm</code> adds the <code class="Code-In-Text--PACKT-">formGroup</code> object of <code class="Code-In-Text--PACKT-">NameInputComponent</code> as a child element to the parent <code class="Code-In-Text--PACKT-">formGroup</code> on <code class="Code-In-Text--PACKT-">ProfileComponent</code>.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">ViewUserComponent</code> is used in the <code class="Code-In-Text--PACKT-">ProfileComponent</code> form as <code class="Code-In-Text--PACKT-">&lt;app-view-user&gt;</code>. When the values in the parent form change, we need <code class="Code-In-Text--PACKT-">&lt;app-view-user&gt;</code> to stay up to date. We bind to the <code class="Code-In-Text--PACKT-">user</code> property on <code class="Code-In-Text--PACKT-">ViewUserComponent</code>, which implements <code class="Code-In-Text--PACKT-">OnChanges</code> to receive updates. Every time there is an update, the <code class="Code-In-Text--PACKT-">User</code> object is hydrated from the <code class="Code-In-Text--PACKT-">IUser</code> object, so that calculated fields such as <code class="Code-In-Text--PACKT-">fullName</code> can continue to work. The updated <code class="Code-In-Text--PACKT-">User</code> is pushed to <code class="Code-In-Text--PACKT-">currentUser$</code>, which is bound to the template with an <code class="Code-In-Text--PACKT-">async</code>.</p>
    <p class="normal">We will begin by building a <code class="Code-In-Text--PACKT-">BaseFormComponent</code>, which <code class="Code-In-Text--PACKT-">NameInputComponent</code> and <code class="Code-In-Text--PACKT-">ProfileComponent</code> will then implement.</p>
    <h2 class="title" id="_idParaDest-406">Base form component as an abstract class</h2>
    <p class="normal">We can share <a id="_idIndexMarker1334"/>common functionality and standardize the implementation of all components that implement a form by implementing a base abstract class. An abstract class cannot be instantiated on its own because it wouldn't make sense to do so, since it will not have a template, making it useless on its own.</p>
    <div class="packt_tip">
      <p>Note that <code class="Code-In-Text--PACKT-">BaseFormComponent</code> is just a <code class="Code-In-Text--PACKT-">class</code> and not an Angular component.</p>
    </div>
    <p class="normal"><code class="Code-In-Text--PACKT-">BaseFormComponent</code> will standardize the following:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">@Input initialData</code>, and disable as binding targets</li>
      <li class="list">The <code class="Code-In-Text--PACKT-">@Output formReady</code> event</li>
      <li class="list"><code class="Code-In-Text--PACKT-">formGroup</code>, the <code class="Code-In-Text--PACKT-">FormGroup</code> to be used in the template's <code class="Code-In-Text--PACKT-">buildForm</code> function to build the <code class="Code-In-Text--PACKT-">formGroup</code></li>
    </ul>
    <p class="normal">With the <a id="_idIndexMarker1335"/>preceding assumptions, the base class can provide some generic functionality:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">patchUpdatedData</code>, which can update the data (partially or fully) in the <code class="Code-In-Text--PACKT-">formGroup</code> without having to rebuild it.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">registerForm</code> and <code class="Code-In-Text--PACKT-">deregisterForm</code> can register or deregister child forms.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">deregisterAllForms</code> can automatically deregister any registered child form.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">hasChanged</code> can determine whether <code class="Code-In-Text--PACKT-">initialData</code> has changed given a <code class="Code-In-Text--PACKT-">SimpleChange</code> object provided by the <code class="Code-In-Text--PACKT-">ngOnChange</code> event handler.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">patchUpdatedDataIfChanged</code> leverages <code class="Code-In-Text--PACKT-">hasChanged</code> and uses <code class="Code-In-Text--PACKT-">patchUpdatedData</code> to update the data if, and only if, there has been an update to <code class="Code-In-Text--PACKT-">initialData</code> and <code class="Code-In-Text--PACKT-">formGroup</code> is already initialized.</li>
    </ul>
    <p class="normal">Create a new class, <code class="Code-In-Text--PACKT-">BaseFormComponent</code>, under <code class="Code-In-Text--PACKT-">src/common</code> as follows:</p>
    <pre class="programlisting"><code class="hljs kotlin"><strong>src/app/common/base-form<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">ts</span></span></strong>
<span class="hljs-keyword">import</span> { EventEmitter, Input, Output, SimpleChange, SimpleChanges } 
   from <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { AbstractControl, FormGroup } from <span class="hljs-string">'@angular/forms'</span>
export <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseFormComponent</span>&lt;<span class="hljs-type">TFormData extends object</span>&gt; </span>{
  <span class="hljs-meta">@Input()</span> initialData: TFormData
  <span class="hljs-meta">@Input()</span> disable: boolean
  <span class="hljs-meta">@Output()</span> formReady: EventEmitter&lt;AbstractControl&gt;
  formGroup: FormGroup
  <span class="hljs-keyword">private</span> registeredForms: string[] = []
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.formReady = new EventEmitter&lt;AbstractControl&gt;(<span class="hljs-literal">true</span>)
  }
  <span class="hljs-keyword">abstract</span> buildForm(initialData?: TFormData): FormGroup
  patchUpdatedData(<span class="hljs-keyword">data</span>: <span class="hljs-keyword">object</span>) {
    <span class="hljs-keyword">this</span>.formGroup.patchValue(<span class="hljs-keyword">data</span>, { onlySelf: <span class="hljs-literal">false</span> })
  }
  patchUpdatedDataIfChanged(changes: SimpleChanges) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.formGroup &amp;&amp; <span class="hljs-keyword">this</span>.hasChanged(changes.initialData)) {
      <span class="hljs-keyword">this</span>.patchUpdatedData(<span class="hljs-keyword">this</span>.initialData)
    }
  }
  emitFormReady(control: AbstractControl | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">this</span>.formReady.emit(control || <span class="hljs-keyword">this</span>.formGroup)
  }
  registerForm(name: string, control: AbstractControl) {
    <span class="hljs-keyword">this</span>.formGroup.setControl(name, control)
    <span class="hljs-keyword">this</span>.registeredForms.push(name)
  }
  deregisterForm(name: string) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.formGroup.contains(name)) {
      <span class="hljs-keyword">this</span>.formGroup.removeControl(name)
    }
  }
  <span class="hljs-keyword">protected</span> deregisterAllForms() {
    <span class="hljs-keyword">this</span>.registeredForms.forEach(() =&gt; <span class="hljs-keyword">this</span>.deregisterForm(name))
  }
  <span class="hljs-keyword">protected</span> hasChanged(change: SimpleChange): boolean {
    <span class="hljs-keyword">return</span> change?.previousValue !== change?.currentValue
  }
}
</code></pre>
    <p class="normal">Let's <a id="_idIndexMarker1336"/>implement <code class="Code-In-Text--PACKT-">NameInputComponent</code> using the <code class="Code-In-Text--PACKT-">BaseFormComponent</code>.</p>
    <h2 class="title" id="_idParaDest-407">Implementing a reusable form part</h2>
    <p class="normal">Start by <a id="_idIndexMarker1337"/>identifying the name form group in the <code class="Code-In-Text--PACKT-">profile</code> component code and template files:</p>
    <ol>
      <li class="list" value="1">The following is the name form group implementation:
        <pre class="programlisting"><code class="hljs applescript"><strong>src/app/user/profile/profile.component.ts</strong>
...
<span class="hljs-built_in">name</span>: this.formBuilder.group({
  <span class="hljs-keyword">first</span>: [user?.<span class="hljs-built_in">name</span>?.<span class="hljs-keyword">first</span> || '', RequiredTextValidation],
  <span class="hljs-keyword">middle</span>: [user?.<span class="hljs-built_in">name</span>?.<span class="hljs-keyword">middle</span> || '', OneCharValidation],
  <span class="hljs-keyword">last</span>: [user?.<span class="hljs-built_in">name</span>?.<span class="hljs-keyword">last</span> || '', RequiredTextValidation],
}),
...
</code></pre>
        <div class="packt_tip">
          <p>Note that when we move these validation rules to a new component, we still want them to be in effect when determining the overall validation status of the parent form. We achieve this by using the <code class="Code-In-Text--PACKT-">registerForm</code> function we implemented in the previous section. Once our new <code class="Code-In-Text--PACKT-">FormGroup</code> is registered with the existing one, they work exactly the same way before our refactor.</p>
        </div>
      </li>
      <li class="list">Next is the name form group template:
        <pre class="programlisting"><code class="hljs stata"><strong>src/<span class="hljs-keyword">app</span>/user/profile/profile.component.html</strong>
...
&lt;div fxLayout=<span class="hljs-string">"row"</span> fxLayout.lt-sm=<span class="hljs-string">"column"</span> [formGroup]=<span class="hljs-string">"formGroup.get('name')"</span> fxLayoutGap=<span class="hljs-string">"10px"</span>&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field appearance=<span class="hljs-string">"outline"</span> fxFlex=<span class="hljs-string">"40%"</span>&gt;
    &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;First Name&lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;
    &lt;<span class="hljs-keyword">input</span> matInput aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"First Name"</span> 
           formControlName=<span class="hljs-string">"first"</span> #name /&gt;
    ...
&lt;/div&gt;
...
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">You will be moving most of this code to the new component.</p>
      </li>
      <li class="list">Create a new <code class="Code-In-Text--PACKT-">NameInputComponent</code> under the <code class="Code-In-Text--PACKT-">user</code> folder.</li>
      <li class="list">Extend the class from <code class="Code-In-Text--PACKT-">BaseFormComponent</code>.</li>
      <li class="list">Inject <code class="Code-In-Text--PACKT-">FormBuilder</code> in the <code class="Code-In-Text--PACKT-">constructor</code>:<div class="packt_tip">
          <p>For components with small or limited pieces of functionality, I prefer creating them with an inline template and styling, so it is easier to change the code from one place.</p>
        </div>
        <pre class="programlisting"><code class="hljs scala"><strong>src/app/user/name-input/name-input.component.ts</strong>
export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameInputComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseFormComponent&lt;IName&gt;</span> </span>{
  constructor(<span class="hljs-keyword">private</span> formBuilder: <span class="hljs-type">FormBuilder</span>) {
    <span class="hljs-keyword">super</span>()
  }
  buildForm(initialData?: <span class="hljs-type">IName</span>): <span class="hljs-type">FormGroup</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>(<span class="hljs-string">"Method not implemented."</span>);
  }
  ...
}
</code></pre>
        <div class="packt_tip">
          <p>Remember that <a id="_idIndexMarker1338"/>the base class already implements <code class="Code-In-Text--PACKT-">formGroup</code>, <code class="Code-In-Text--PACKT-">initialData</code>, <code class="Code-In-Text--PACKT-">disable</code>, and <code class="Code-In-Text--PACKT-">formReady</code> properties, so you don't need to redefine them.</p>
        </div>
        <div class="note">
          <p class="Information-Box--PACKT-">Note that we are forced to implement the <code class="Code-In-Text--PACKT-">buildForm</code> function since it was defined as abstract. This is a great way to enforce standards across developers. Also, note that any base function provided can be overridden by the implementing class by simply redefining the function. You'll see this in action when we refactor the <code class="Code-In-Text--PACKT-">ProfileComponent</code>.</p>
        </div>
      </li>
      <li class="list">Implement the <code class="Code-In-Text--PACKT-">buildForm</code> function.</li>
      <li class="list">Set the <code class="Code-In-Text--PACKT-">name</code> property part of the <code class="Code-In-Text--PACKT-">formGroup</code> in <code class="Code-In-Text--PACKT-">ProfileComponent</code> to <code class="Code-In-Text--PACKT-">null</code>:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>user<span class="hljs-regexp">/name-input/</span>name-input.component.ts</strong>
export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameInputComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OnInit</span> {</span>
  ...
  buildForm(initialData?: IName): FormGroup {
    const name = initialData
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.formBuilder.group({
<span class="hljs-symbol">      first:</span> [name?.first : <span class="hljs-string">''</span>, RequiredTextValidation],
<span class="hljs-symbol">      middle:</span> [name?.middle : <span class="hljs-string">''</span>, OneCharValidation], 
<span class="hljs-symbol">      last:</span> [name?.last : <span class="hljs-string">''</span>, RequiredTextValidation],
    })
  }
</code></pre>
      </li>
      <li class="list">Implement the template by bringing over the content from <code class="Code-In-Text--PACKT-">ProfileComponent</code>:
        <pre class="programlisting"><code class="hljs stata"><strong>src/<span class="hljs-keyword">app</span>/user/name-<span class="hljs-keyword">input</span>/name-<span class="hljs-keyword">input</span>.component.ts</strong>
template: `
    &lt;<span class="hljs-keyword">form</span> [formGroup]=<span class="hljs-string">"formGroup"</span>&gt;
      &lt;div fxLayout=<span class="hljs-string">"row"</span> fxLayout.lt-sm=<span class="hljs-string">"column"</span>
        fxLayoutGap=<span class="hljs-string">"10px"</span>&gt;
        ...
      &lt;/div&gt;
    &lt;/<span class="hljs-keyword">form</span>&gt;
  `,
</code></pre>
      </li>
      <li class="list">Implement <a id="_idIndexMarker1339"/>the <code class="Code-In-Text--PACKT-">ngOnInit</code> event handler:
        <pre class="programlisting"><code class="hljs kotlin"><strong>src/app/user/name-input/name-input.component.ts</strong>
ngOnInit() {
  <span class="hljs-keyword">this</span>.formGroup = <span class="hljs-keyword">this</span>.buildForm(<span class="hljs-keyword">this</span>.initialData)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.disable) {
    <span class="hljs-keyword">this</span>.formGroup.disable()
  }
  <span class="hljs-keyword">this</span>.formReady.emit(<span class="hljs-keyword">this</span>.formGroup)
}
</code></pre>
        <div class="packt_tip">
          <p>It is critical to get the implementation of the <code class="Code-In-Text--PACKT-">ngOnInit</code> event handler right in every implementation of <code class="Code-In-Text--PACKT-">BaseFormComponent</code>. The preceding example is fairly standard behavior for any <code class="Code-In-Text--PACKT-">child</code> component you may implement.</p>
          <p class="Tip-Within-Bullet--PACKT-">Note that the implementation in <code class="Code-In-Text--PACKT-">ProfileComponent</code> will be a bit different.</p>
        </div>
      </li>
      <li class="list">Implement the <code class="Code-In-Text--PACKT-">ngOnChanges</code> event handler, leveraging the base <code class="Code-In-Text--PACKT-">patchUpdatedDataIfChanged</code> behavior:
        <pre class="programlisting"><code class="hljs stylus"><strong>src/app/user/name-input/name-<span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.ts</span></strong>
<span class="hljs-function"><span class="hljs-title">ngOnChanges</span><span class="hljs-params">(changes: SimpleChanges)</span></span> {
  this.patchUpdatedDataIfChanged(changes)
}
</code></pre>
        <div class="packt_tip">
          <p>Note that in <code class="Code-In-Text--PACKT-">patchUpdatedDataIfChanged</code>, setting <code class="Code-In-Text--PACKT-">onlySelf</code> to <code class="Code-In-Text--PACKT-">false</code> will cause the parent form to also update. If you'd like to optimize this behavior, you may override the function.</p>
        </div>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Now you <a id="_idIndexMarker1340"/>have a fully implemented <code class="Code-In-Text--PACKT-">NameInputComponent</code> that you can integrate into <code class="Code-In-Text--PACKT-">ProfileComponent</code>.</p>
        <div class="note">
          <p class="Information-Box--PACKT-">To verify your <code class="Code-In-Text--PACKT-">ProfileComponent</code> code going forward, refer to <code class="Code-In-Text--PACKT-">projects/ch11/src/app/user/profile/profile.component.ts</code> and <code class="Code-In-Text--PACKT-">projects/ch11/src/app/user/profile/profile.component.html</code>.</p>
        </div>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Before you begin using <code class="Code-In-Text--PACKT-">NameInputComponent</code>, perform the following refactors:</p>
      </li>
      <li class="list">Refactor <code class="Code-In-Text--PACKT-">ProfileComponent</code> to extend <code class="Code-In-Text--PACKT-">BaseFormComponent</code> and conform to its default values as needed.</li>
      <li class="list">Define a readonly <code class="Code-In-Text--PACKT-">nameInitialData$</code> property with the <code class="Code-In-Text--PACKT-">BehaviorSubject&lt;IName&gt;</code> type and initialize it with empty strings.</li>
      <li class="list">Replace the content in <code class="Code-In-Text--PACKT-">ProfileComponent</code> with the new <code class="Code-In-Text--PACKT-">&lt;app-name-input&gt;</code> component:
        <pre class="programlisting"><code class="hljs xml"><strong>src/app/user/profile/profile.component.html</strong>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-horizontal-stepper</span> #<span class="hljs-attr">stepper</span>=<span class="hljs-string">"matHorizontalStepper"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-step</span> [<span class="hljs-attr">stepControl</span>]=<span class="hljs-string">"formGroup"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"formGroup"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> <span class="hljs-attr">matStepLabel</span>&gt;</span>Account Information<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stepContent"</span>&gt;</span>
<strong>          <span class="hljs-tag">&lt;<span class="hljs-name">app-name-input</span> [<span class="hljs-attr">initialData</span>]=<span class="hljs-string">"nameInitialData$ | async"</span></span></strong><span class="hljs-tag">
            </span><strong><span class="hljs-tag">(<span class="hljs-attr">formReady</span>)=<span class="hljs-string">"registerForm('name', $event)"</span>&gt;</span></strong>
          <span class="hljs-tag">&lt;/<span class="hljs-name">app-name-input</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        ...
      <span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">mat-step</span>&gt;</span>
  ...
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-horizontal-stepper</span>&gt;</span>
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that the base form component function, <code class="Code-In-Text--PACKT-">registerForm</code>, is leveraged here.</p>
      </li>
      <li class="list">Ensure that your <code class="Code-In-Text--PACKT-">ngOnInit</code> is implemented correctly:<div class="packt_tip">
          <p>Note that there are some additional refactors present on the updated <code class="Code-In-Text--PACKT-">ProfileComponent</code>, such as the <code class="Code-In-Text--PACKT-">patchUser</code> function seen in the following snippet. Don't miss these updates when you update your component.</p>
        </div>
        <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/user/profile/profile.component.ts</strong>
ngOnInit() {
  <span class="hljs-keyword">this</span>.formGroup = <span class="hljs-keyword">this</span>.buildForm()
  <span class="hljs-keyword">this</span>.subs.sink = <span class="hljs-keyword">this</span>.authService.currentUser$
    .pipe(
      filter(<span class="hljs-function"><span class="hljs-params">(user)</span> =&gt;</span> user != <span class="hljs-literal">null</span>),
      tap(<span class="hljs-function"><span class="hljs-params">(user)</span> =&gt;</span> <span class="hljs-keyword">this</span>.patchUser(user))
    )
    .subscribe()
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">It is important to update the current form's data with <code class="Code-In-Text--PACKT-">pathUpdatedData</code>, as well as <code class="Code-In-Text--PACKT-">nameInitialData$</code>, when there's an update to <code class="Code-In-Text--PACKT-">initialData</code>.</p>
      </li>
      <li class="list" value="15">Ensure that <code class="Code-In-Text--PACKT-">ngOnDestroy</code> is implemented correctly:
        <pre class="programlisting"><code class="hljs gradle"><strong>src<span class="hljs-regexp">/app/u</span>ser<span class="hljs-regexp">/profile/</span>profile.component.ts</strong>
  ngOnDestroy() {
    <span class="hljs-keyword">this</span>.subs.unsubscribe()
    <span class="hljs-keyword">this</span>.deregisterAllForms()
  }
</code></pre>
      </li>
    </ol>
    <p class="normal">Always remember <a id="_idIndexMarker1341"/>to unsubscribe from subscriptions, which you can do so easily with the <code class="Code-In-Text--PACKT-">SubSink</code> package. You can also leverage the base class functionality to automatically deregister from all child forms.</p>
    <p class="normal">Next, let's learn about masking user input to increase the quality of our data.</p>
    <h1 class="title" id="_idParaDest-408">Input masking</h1>
    <p class="normal">Masking user <a id="_idIndexMarker1342"/>input is an input UX tool, as well as a data quality one. I'm a <a id="_idIndexMarker1343"/>fan of the <strong class="bold">ngx-mask</strong> library, which makes it really easy to implement input masking in Angular. We will demonstrate input masking by updating the phone number input field so we can ensure that users input a valid phone number, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_11.png"/></figure>
    <p class="packt_figref">Figure 11.11: Phone number field with input masking</p>
    <p class="normal">Set up <a id="_idIndexMarker1344"/>your input masking as follows:</p>
    <ol>
      <li class="list" value="1">Install the library via npm with <code class="Code-In-Text--PACKT-">npm i ngx-mask</code>.</li>
      <li class="list">Import the <code class="Code-In-Text--PACKT-">forRoot</code> module:
        <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/app.<span class="hljs-built_in">module</span>.ts</strong>
<span class="hljs-keyword">export</span> const options: Partial&lt;IConfig&gt; | (<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> Partial&lt;IConfig&gt;) = {
  showMaskTyped: <span class="hljs-literal">true</span>,
}
@NgModule({
  imports: [
    ...
    <strong>NgxMaskModule.forRoot(options),</strong>
  ]
})
</code></pre>
      </li>
      <li class="list">Import the module in the <code class="Code-In-Text--PACKT-">user</code> feature module as well:
        <pre class="programlisting"><code class="hljs elm"><strong><span class="hljs-title">src</span>/app/user/user.<span class="hljs-keyword">module</span>.ts</strong>
@NgModule({
  imports: [
    ...
    <span class="hljs-type">NgxMaskModule</span>.forChild(),
  ]
})
</code></pre>
      </li>
      <li class="list" value="4">Update the <code class="Code-In-Text--PACKT-">number</code> field in <code class="Code-In-Text--PACKT-">ProfileComponent</code> as follows:
        <pre class="programlisting"><code class="hljs stata"><strong>src/<span class="hljs-keyword">app</span>/user/profile/profile.component.html</strong>
&lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field appearance=<span class="hljs-string">"outline"</span> fxFlex fxFlexOffset=<span class="hljs-string">"10px"</span>&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;Number&lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;
  &lt;<span class="hljs-keyword">input</span> matInput <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span> formControlName=<span class="hljs-string">"number"</span>
    prefix=<span class="hljs-string">"+1"</span> <strong>mask=<span class="hljs-string">"(000) 000-0000"</span> [showMaskTyped]=<span class="hljs-string">"true"</span></strong> /&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> *ngIf=<span class="hljs-string">"this.phonesArray.controls[i].invalid"</span>&gt;
    A valid phone number is required
  &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
&lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field&gt;
</code></pre>
      </li>
    </ol>
    <p class="normal">And it's that <a id="_idIndexMarker1345"/>simple. You can learn more about the module and its capabilities on GitHub at <a href="https://github.com/JsDaddy/ngx-mask"><span class="url">https://github.com/JsDaddy/ngx-mask</span></a>.</p>
    <h1 class="title" id="_idParaDest-409">Custom controls with ControlValueAccessor</h1>
    <p class="normal">So far, we've learned about forms using standard form controls and input controls provided <a id="_idIndexMarker1346"/>by Angular Material. However, it is possible for you to create custom user controls. If you implement the <code class="Code-In-Text--PACKT-">ControlValueAccessor</code> interface, then your custom controls will play nicely with forms and the <code class="Code-In-Text--PACKT-">ControlValueAccessor</code> interface's validation engine.</p>
    <p class="normal">We will be creating the custom rater control shown in the following screenshot, and will place it as a control on the first step of <code class="Code-In-Text--PACKT-">ProfileComponent</code>:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_12.png"/></figure>
    <p class="packt_figref">Figure 11.12: The lemon rater user control</p>
    <p class="normal">User controls are inherently highly reusable, tightly coupled, and customized components to enable rich user interactions. Let's implement one.</p>
    <h2 class="title" id="_idParaDest-410">Implementing a custom rating control</h2>
    <p class="normal">The lemon <a id="_idIndexMarker1347"/>rater will highlight the number of lemons selected dynamically as the user interacts with the control in real time. As such, creating a high-quality custom control is an expensive endeavor.</p>
    <div class="packt_tip">
      <p>The Lemon Rater is a modified version of Jennifer Wadella's Galaxy Rating App sample found at <a href="https://github.com/tehfedaykin/galaxy-rating-app"><span class="url">https://github.com/tehfedaykin/galaxy-rating-app</span></a>. I highly recommend that you watch Jennifer's Ng-Conf 2019 talk on <code class="Code-In-Text--PACKT-">ControlValueAccessor</code>, linked in the <em class="italics">Further reading</em> section.</p>
    </div>
    <p class="normal">Set up your custom rating control as follows:</p>
    <ol>
      <li class="list" value="1">Generate a new component called <code class="Code-In-Text--PACKT-">LemonRater</code> under the <code class="Code-In-Text--PACKT-">user-controls</code> folder.</li>
      <li class="list">Create a <code class="Code-In-Text--PACKT-">LemonRaterModule</code> in the same folder.</li>
      <li class="list">Declare and export the component.</li>
      <li class="list">In <code class="Code-In-Text--PACKT-">LemonRater</code>, implement the <code class="Code-In-Text--PACKT-">ControlValueAccess</code> interface:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/user-controls/lemon-rater/lemon-rater.component.ts</strong>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> LemonRaterComponent <span class="hljs-keyword">implements</span> ControlValueAccessor {
  disabled = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">private</span> internalValue: <span class="hljs-built_in">number</span>
  <span class="hljs-keyword">get</span> value() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.internalValue
  }
  onChanged: <span class="hljs-built_in">any</span> = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}
  onTouched: <span class="hljs-built_in">any</span> = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}
  writeValue(obj: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.internalValue = obj
  }
  registerOnChange(fn: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.onChanged = fn
  }
  registerOnTouched(fn: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.onTouched = fn
  }
  setDisabledState?(isDisabled: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.disabled = isDisabled
  }
}
</code></pre>
      </li>
      <li class="list">Add the <code class="Code-In-Text--PACKT-">NG_VALUE_ACCESSOR</code> provider with the <code class="Code-In-Text--PACKT-">multi</code> property set to <code class="Code-In-Text--PACKT-">true</code>. This will register our component with the form's change events, so form values can be updated when the user interacts with the rater:
        <pre class="programlisting"><code class="hljs less"><strong><span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">app</span>/<span class="hljs-selector-tag">user-controls</span>/<span class="hljs-selector-tag">lemon-rater</span>/<span class="hljs-selector-tag">lemon-rater</span><span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.ts</span></strong>
@<span class="hljs-selector-tag">Component</span>({
  <span class="hljs-attribute">selector</span>: <span class="hljs-string">'app-lemon-rater'</span>,   
  <span class="hljs-attribute">templateUrl</span>: <span class="hljs-string">'lemon-rater.component.html'</span>,
  <span class="hljs-attribute">styleUrls</span>: [<span class="hljs-string">'lemon-rater.component.css'</span>],
  <span class="hljs-attribute">providers</span>: [
    {
      <span class="hljs-attribute">provide</span>: NG_VALUE_ACCESSOR,
      <span class="hljs-attribute">useExisting</span>: forwardRef(() =&gt; LemonRaterComponent),
      <span class="hljs-attribute">multi</span>: true,
    },
  ],
</code></pre>
      </li>
      <li class="list">Implement a <a id="_idIndexMarker1348"/>custom rating scheme with a function to allow for setting the selected rating based on user input:
        <pre class="programlisting"><code class="hljs pgsql"><strong>src/app/<span class="hljs-keyword">user</span>-controls/lemon-rater/lemon-rater.component.ts</strong>
export <span class="hljs-keyword">class</span> LemonRaterComponent implements ControlValueAccessor { 
  @ViewChild(<span class="hljs-string">'displayText'</span>, { static: <span class="hljs-keyword">false</span> }) displayTextRef: ElementRef
  
  ratings = <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">freeze</span>([
    {
      <span class="hljs-keyword">value</span>: <span class="hljs-number">1</span>,
      <span class="hljs-type">text</span>: <span class="hljs-string">'no zest'</span>,
    },
    {
      <span class="hljs-keyword">value</span>: <span class="hljs-number">2</span>,
      <span class="hljs-type">text</span>: <span class="hljs-string">'neither a lemon or a lime '</span>,
    },
    {
      <span class="hljs-keyword">value</span>: <span class="hljs-number">3</span>,
      <span class="hljs-type">text</span>: <span class="hljs-string">'a true lemon'</span>,
    },
])
  setRating(lemon: <span class="hljs-keyword">any</span>) {
    <span class="hljs-keyword">if</span> (!this.disabled) {
      this.internalValue = lemon.<span class="hljs-keyword">value</span>
      this.ratingText = lemon.text
      this.onChanged(lemon.<span class="hljs-keyword">value</span>)
      this.onTouched()
    }
  }
  setDisplayText() {
    this.setSelectedText(this.internalValue)
  }
  private setSelectedText(<span class="hljs-keyword">value</span>: number) {
    this.displayTextRef.nativeElement.textContent = 
      this.getSelectedText(<span class="hljs-keyword">value</span>)
  }
  private getSelectedText(<span class="hljs-keyword">value</span>: number) {
    let <span class="hljs-type">text</span> = <span class="hljs-string">''</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span>) {
      <span class="hljs-type">text</span> = this.ratings
        .find((i) =&gt; i.<span class="hljs-keyword">value</span> === <span class="hljs-keyword">value</span>)?.text || <span class="hljs-string">''</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-type">text</span>
  }
}
</code></pre>
        <div class="packt_tip">
          <p>Note that by using <code class="Code-In-Text--PACKT-">@ViewChild</code>, we're getting the HTML element named <code class="Code-In-Text--PACKT-">#displayText</code> (highlighted in the following template). Using <code class="Code-In-Text--PACKT-">setSelectText</code>, we replace the <code class="Code-In-Text--PACKT-">textContent</code> of the element.</p>
        </div>
      </li>
      <li class="list">Implement the <a id="_idIndexMarker1349"/>template, referring to the sample code for the contents of the <code class="Code-In-Text--PACKT-">svg</code> tag:
        <pre class="programlisting"><code class="hljs dust"><strong><span class="xml">src/app/user-controls/lemon-rater/lemon-rater.component.html</span></strong><span class="xml">
</span><strong><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">i</span> #<span class="hljs-attr">displayText</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> </span></strong><span class="xml">
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lemons"</span> [<span class="hljs-attr">ngClass</span>]=<span class="hljs-string">"</span></span></span><span class="hljs-template-variable">{'disabled': disabled}</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let lemon of ratings"</span>&gt;</span> 
    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"24px"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"24px"</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 513 513"</span>
         [<span class="hljs-attr">attr.title</span>]=<span class="hljs-string">"lemon.text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lemon rating"</span>
         [<span class="hljs-attr">ngClass</span>]=<span class="hljs-string">"</span></span></span><span class="hljs-template-variable">{'selected': lemon.value &lt;= value}</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>
         (<span class="hljs-attr">mouseover</span>)=
           <span class="hljs-string">"displayText.textContent = !disabled ? lemon.text : ''"</span>
         (<span class="hljs-attr">mouseout</span>)=<span class="hljs-string">"setDisplayText()"</span>
         (<span class="hljs-attr">click</span>)=<span class="hljs-string">"setRating(lemon)"</span>
     &gt;</span>
     ...
     <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</span></code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The three most <a id="_idIndexMarker1350"/>important attributes in the template are <code class="Code-In-Text--PACKT-">mouseover</code>, <code class="Code-In-Text--PACKT-">mouseout</code>, and <code class="Code-In-Text--PACKT-">click</code>. <code class="Code-In-Text--PACKT-">mouseover</code> displays the text for the rating that the user is currently hovering over, <code class="Code-In-Text--PACKT-">mouseout</code> resets the display text to the selected value, and <code class="Code-In-Text--PACKT-">click</code> calls the <code class="Code-In-Text--PACKT-">setRating</code> method we implemented to record the user's selection. However, the control can have even richer user interactivity by highlighting the number of lemons when the user hovers over a rating or selects it. We will accomplish this via some CSS magic.</p>
      </li>
      <li class="list" value="8">Implement the <code class="Code-In-Text--PACKT-">css</code> for the user control:
        <pre class="programlisting"><code class="hljs less"><strong><span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">app</span>/<span class="hljs-selector-tag">user-controls</span>/<span class="hljs-selector-tag">lemon-rater</span>/<span class="hljs-selector-tag">lemon-rater</span><span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.css</span></strong>
<span class="hljs-selector-class">.lemons</span> {
  <span class="hljs-attribute">cursor</span>: pointer;
}
<span class="hljs-selector-class">.lemons</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.lemon</span> <span class="hljs-selector-id">#fill-area</span> {
  <span class="hljs-attribute">fill</span>: <span class="hljs-number">#ffe200</span> <span class="hljs-meta">!important</span>;
}
<span class="hljs-selector-class">.lemons</span><span class="hljs-selector-class">.disabled</span><span class="hljs-selector-pseudo">:hover</span> {
  <span class="hljs-attribute">cursor</span>: not-allowed;
}
<span class="hljs-selector-class">.lemons</span><span class="hljs-selector-class">.disabled</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.lemon</span> <span class="hljs-selector-id">#fill-area</span> {
  <span class="hljs-attribute">fill</span>: <span class="hljs-number">#d8d8d8</span> <span class="hljs-meta">!important</span>;
}
<span class="hljs-selector-class">.lemons</span> <span class="hljs-selector-class">.lemon</span> {
  <span class="hljs-attribute">float</span>: left; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span> <span class="hljs-number">5px</span>;
}
<span class="hljs-selector-class">.lemons</span> <span class="hljs-selector-class">.lemon</span> <span class="hljs-selector-id">#fill-area</span> {
  <span class="hljs-attribute">fill</span>: <span class="hljs-number">#d8d8d8</span>;
}
<span class="hljs-selector-class">.lemons</span> <span class="hljs-selector-class">.lemon</span><span class="hljs-selector-pseudo">:hover</span>~<span class="hljs-selector-class">.lemon</span> <span class="hljs-selector-id">#fill-area</span> {
  <span class="hljs-attribute">fill</span>: <span class="hljs-number">#d8d8d8</span> <span class="hljs-meta">!important</span>;
}
<span class="hljs-selector-class">.lemons</span> <span class="hljs-selector-class">.lemon</span><span class="hljs-selector-class">.selected</span> <span class="hljs-selector-id">#fill-area</span> {
  <span class="hljs-attribute">fill</span>: <span class="hljs-number">#ffe200</span> <span class="hljs-meta">!important</span>;
}
<span class="hljs-selector-class">.lemons</span> <span class="hljs-selector-class">.dad</span><span class="hljs-selector-class">.heart</span> <span class="hljs-selector-id">#ada</span>
    { 
       <span class="hljs-attribute">fill</span>: <span class="hljs-number">#6a0dad</span> <span class="hljs-meta">!important</span>;
}
</code></pre>
      </li>
    </ol>
    <p class="normal">The most <a id="_idIndexMarker1351"/>interesting bit is with <code class="Code-In-Text--PACKT-">.lemons .lemon:hover~.lemon #fill-area</code>. Note that the operator <code class="Code-In-Text--PACKT-">~</code> or the general sibling combinator is used to select a range of elements so that a dynamic number of lemons will be highlighted as the user hovers over them.</p>
    <div class="packt_tip">
      <p><code class="Code-In-Text--PACKT-">#fill-area</code> refers to a <code class="Code-In-Text--PACKT-">&lt;path&gt;</code> defined within the lemon <code class="Code-In-Text--PACKT-">svg</code>, which allows for the lemon's color to be adjusted dynamically. I had to manually inject this ID field into the <code class="Code-In-Text--PACKT-">svg</code> file.</p>
    </div>
    <p class="normal">Now, let's see how you can use this new user control in a form.</p>
    <h2 class="title" id="_idParaDest-411">Using custom controls in forms</h2>
    <p class="normal">We will use <a id="_idIndexMarker1352"/>the lemon rater in the <code class="Code-In-Text--PACKT-">profile</code> component to record the Limoncu level of the employee. </p>
    <div class="note">
      <p class="Information-Box--PACKT-">Limoncu, meaning a person who grows or sells lemons in Turkish, is Lemon Mart's proprietary employee engagement and performance measurement system.</p>
    </div>
    <p class="normal">Let's integrate the lemon rater:</p>
    <ol>
      <li class="list" value="1">Start by importing the <code class="Code-In-Text--PACKT-">LemonRaterModule</code> in <code class="Code-In-Text--PACKT-">UserModule</code>.</li>
      <li class="list">Ensure that the level form control is initialized in <code class="Code-In-Text--PACKT-">buildForm</code>:
        <pre class="programlisting"><code class="hljs dts"><strong>src<span class="hljs-meta-keyword">/app/</span>user<span class="hljs-meta-keyword">/profile/</span>profile.component.ts</strong>
buildForm(initialData?: IUser): <span class="hljs-class">FormGroup </span>{
...
<span class="hljs-symbol">  level:</span> [user?.level || <span class="hljs-number">0</span>, Validators.required],
...
}
</code></pre>
      </li>
      <li class="list" value="3">Insert the lemon rater as the last element of the first <code class="Code-In-Text--PACKT-">mat-step</code>, inside the <code class="Code-In-Text--PACKT-">form</code> element:
        <pre class="programlisting"><code class="hljs stata"><strong>src/<span class="hljs-keyword">app</span>/user/profile/profile.component.html</strong>
&lt;div fxLayout=<span class="hljs-string">"row"</span> fxLayout.lt-sm=<span class="hljs-string">"column"</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">"margin-top"</span> fxLayoutGap=<span class="hljs-string">"10px"</span>&gt;
  &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">"mat-body-1"</span>&gt;Select the Limoncu level:
    &lt;<span class="hljs-keyword">app</span>-lemon-rater formControlName=<span class="hljs-string">"level"</span>&gt;
    &lt;/<span class="hljs-keyword">app</span>-lemon-rater&gt;
  &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">label</span>&gt;
&lt;/div&gt;
</code></pre>
      </li>
    </ol>
    <p class="normal">We simply <a id="_idIndexMarker1353"/>integrate with the custom control by implementing <code class="Code-In-Text--PACKT-">formControlName</code> as you would with any other control.</p>
    <p class="normal">Congratulations! You should have a working custom control that is integrated with your form.</p>
    <h1 class="title" id="_idParaDest-412">Layouts using grid list</h1>
    <p class="normal">The Angular Flex Layout library is great for laying out content using CSS Flexbox. Angular Material provides <a id="_idIndexMarker1354"/>another mechanism to lay out content by using CSS Grid with its Grid List functionality. A good way to demonstrate this functionality is by implementing a helpful list for fake login information in the <code class="Code-In-Text--PACKT-">LoginComponent</code>, demonstrated here:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_13.png"/></figure>
    <p class="packt_figref">Figure 11.13: Login helper with the grid list</p>
    <p class="normal">Implement <a id="_idIndexMarker1355"/>your list as follows:</p>
    <ol>
      <li class="list" value="1">Start by defining a <code class="Code-In-Text--PACKT-">roles</code> property that is an array of all the roles:
        <pre class="programlisting"><code class="hljs pgsql"><strong>src/app/<span class="hljs-keyword">login</span>/<span class="hljs-keyword">login</span>.component.ts </strong>
roles = <span class="hljs-keyword">Object</span>.keys(<span class="hljs-keyword">Role</span>)
</code></pre>
      </li>
      <li class="list">Import <code class="Code-In-Text--PACKT-">MatExpansionModule</code> and <code class="Code-In-Text--PACKT-">MatGridListModule</code> into <code class="Code-In-Text--PACKT-">AppMaterialModule</code>:</li>
      <li class="list">Implement a new <code class="Code-In-Text--PACKT-">mat-card-content</code> below the existing one:
        <pre class="programlisting"><code class="hljs xml"><strong>src/app/login/login.component.html</strong>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">fxLayout</span>=<span class="hljs-string">"row"</span> <span class="hljs-attr">fxLayoutAlign</span>=<span class="hljs-string">"center"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-card</span> <span class="hljs-attr">fxFlex</span>=<span class="hljs-string">"400px"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-header</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mat-headline"</span>&gt;</span>Hello, Limoncu!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-title</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-content</span>&gt;</span>
      ...
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-content</span>&gt;</span>
    <strong><span class="hljs-tag">&lt;<span class="hljs-name">mat-card-content</span>&gt;</span></strong>
<strong>    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-content</span>&gt;</span></strong>
  <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
      </li>
      <li class="list">Inside the new <code class="Code-In-Text--PACKT-">mat-card-content</code>, put in a label to display the authentication mode:
        <pre class="programlisting"><code class="hljs django"><strong><span class="xml">src/app/login/login.component.html</span></strong><span class="xml">
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">fxLayout</span>=<span class="hljs-string">"row"</span> <span class="hljs-attr">fxLayoutAlign</span>=<span class="hljs-string">"start center"</span> <span class="hljs-attr">fxLayoutGap</span>=<span class="hljs-string">"10px"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Authentication Mode: <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span></span><span class="hljs-template-variable">{{ authMode }}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</span></code></pre>
      </li>
      <li class="list">Beneath <a id="_idIndexMarker1356"/>the label, implement an expansion list:
        <pre class="programlisting"><code class="hljs dts"><strong>src<span class="hljs-meta-keyword">/app/</span>login/login.component.html</strong>
<span class="hljs-params">&lt;mat-accordion&gt;</span>
  <span class="hljs-params">&lt;mat-expansion-panel&gt;</span>
    <span class="hljs-params">&lt;mat-expansion-panel-header&gt;</span>
        <span class="hljs-params">&lt;mat-panel-title&gt;</span>
          Fake Login Info
        <span class="hljs-params">&lt;/mat-panel-title&gt;</span>
    <span class="hljs-params">&lt;/mat-expansion-panel-header&gt;</span>
    <strong>...</strong>
  <span class="hljs-params">&lt;/mat-expansion-panel&gt;</span>
<span class="hljs-params">&lt;/mat-accordion&gt;</span>
</code></pre>
      </li>
      <li class="list" value="6">After <code class="Code-In-Text--PACKT-">mat-expansion-panel-header</code>, in the area marked with ellipses in the preceding step, implement a table of roles and email addresses, along with some hint text regarding password length using <code class="Code-In-Text--PACKT-">mat-grid-list</code>, shown in the following code block:
        <pre class="programlisting"><code class="hljs dust"><strong><span class="xml">src/app/login/login.component.html</span></strong><span class="xml">
<span class="hljs-tag">&lt;<span class="hljs-name">mat-grid-list</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">rowHeight</span>=<span class="hljs-string">"48px"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"list"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-grid-tile</span> [</span></span><strong><span class="xml"><span class="hljs-tag"><span class="hljs-attr">colspan</span></span></span></strong><span class="xml"><span class="hljs-tag">]=<span class="hljs-string">"3"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"listitem"</span> 
                 <span class="hljs-attr">style</span>=<span class="hljs-string">"background: pink"</span>&gt;</span>
    Use any 8 character string as password
  <span class="hljs-tag">&lt;/<span class="hljs-name">mat-grid-tile</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-grid-tile</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-grid-tile-header</span>&gt;</span>Role<span class="hljs-tag">&lt;/<span class="hljs-name">mat-grid-tile-header</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">mat-grid-tile</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-grid-tile</span> [<span class="hljs-attr">colspan</span>]=<span class="hljs-string">"2"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-grid-tile-header</span>&gt;</span>E-mail<span class="hljs-tag">&lt;/<span class="hljs-name">mat-grid-tile-header</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">mat-grid-tile</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let role of roles; odd as oddRow"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-grid-tile</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"listitem"</span>
            [<span class="hljs-attr">style.background</span>]=<span class="hljs-string">"oddRow ? 'lightGray': 'white'"</span>&gt;</span>
      </span><span class="hljs-template-variable">{{role}</span><span class="xml">}
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-grid-tile</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-grid-tile</span> [</span></span><strong><span class="xml"><span class="hljs-tag"><span class="hljs-attr">colspan</span></span></span></strong><span class="xml"><span class="hljs-tag">]=<span class="hljs-string">"2"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"listitem"</span>
            [<span class="hljs-attr">style.background</span>]=<span class="hljs-string">"oddRow ? 'lightGray': 'white'"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span></span><strong><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fxFlex</span> <span class="hljs-attr">fxLayoutAlign</span>=<span class="hljs-string">"end center"</span></span></span></strong><span class="xml"><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
          </span></span><strong><span class="xml"><span class="hljs-tag">*<span class="hljs-attr">ngIf</span></span></span></strong><span class="xml"><span class="hljs-tag">=<span class="hljs-string">"role.toLowerCase() === 'none'</span></span></span><strong><span class="xml"><span class="hljs-tag"><span class="hljs-string">; else otherRoles"</span></span></span></strong><span class="xml"><span class="hljs-tag">
        &gt;</span>
          Any @test.com email
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> </span></span><strong><span class="xml"><span class="hljs-tag">#<span class="hljs-attr">otherRoles</span></span></span></strong><span class="xml"><span class="hljs-tag">&gt;</span>
          </span><span class="hljs-template-variable">{{role.toLowerCase()}</span><span class="xml">}@test.com
        <span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"
            this.loginForm.patchValue(
              </span></span></span><span class="hljs-template-variable">{ email: role.toLowerCase() + '@test.com', 
              password: 'whatever' }</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">
            )"</span>&gt;</span>
          Fill
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-grid-tile</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-grid-list</span>&gt;</span>
</span></code></pre>
      </li>
    </ol>
    <p class="normal">We use <code class="Code-In-Text--PACKT-">colspan</code> to control the <a id="_idIndexMarker1357"/>width of each row and cell. We leverage <code class="Code-In-Text--PACKT-">fxLayoutAlign</code> to right-align the contents of the <strong class="bold">E-mail</strong> column. We use <code class="Code-In-Text--PACKT-">*ngIf; else</code> to selectively display content. Finally, a <strong class="bold">Fill</strong> button helps us to populate the login form with fake login information.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">In your application, you can use an expansion panel to communicate password complexity requirements to your users.</p>
    </div>
    <p class="normal">You can read <a id="_idIndexMarker1358"/>more about expansion panels at <a href="https://material.angular.io/components/expansion"><span class="url">https://material.angular.io/components/expansion</span></a> and <a id="_idIndexMarker1359"/>Grid List at <a href="https://material.angular.io/components/grid-list/overview"><span class="url">https://material.angular.io/components/grid-list/overview</span></a>.</p>
    <h1 class="title" id="_idParaDest-413">Restoring cached data</h1>
    <p class="normal">At the beginning <a id="_idIndexMarker1360"/>of the chapter, when implementing the <code class="Code-In-Text--PACKT-">updateUser</code> method in <code class="Code-In-Text--PACKT-">UserService</code>, we cached the <code class="Code-In-Text--PACKT-">user</code> object in case of any errors that may wipe out user-provided data:</p>
    <pre class="programlisting"><code class="hljs reasonml"><strong>src/app/user/user/user.service.ts</strong>
update<span class="hljs-constructor">User(<span class="hljs-params">id</span>: <span class="hljs-params">string</span>, <span class="hljs-params">user</span>: IUser)</span>: Observable&lt;IUser&gt; {<span class="hljs-operator">
  ...
  </span><strong>this.set<span class="hljs-constructor">Item('<span class="hljs-params">draft</span>-<span class="hljs-params">user</span>', <span class="hljs-params">user</span>)</span></strong><span class="hljs-operator">
  ...
</span>}
</code></pre>
    <p class="normal">Consider a scenario where the user may be temporarily offline when they attempt to save their data. In this case, our <code class="Code-In-Text--PACKT-">updateUser</code> function will save the data.</p>
    <p class="normal">Let's see how we can restore this data in <code class="Code-In-Text--PACKT-">ProfileComponent</code> when loading the user profile:</p>
    <ol>
      <li class="list" value="1">Start by adding functions named <code class="Code-In-Text--PACKT-">loadFromCache</code> and <code class="Code-In-Text--PACKT-">clearCache</code> to the <code class="Code-In-Text--PACKT-">ProfileComponent</code> class:
        <pre class="programlisting"><code class="hljs routeros"><strong>src/app/user/profile.component.ts</strong>
private loadFromCache(): Observable&lt;User | <span class="hljs-literal">null</span>&gt; {
  let<span class="hljs-built_in"> user </span>= <span class="hljs-literal">null</span>
  try {
    const draftUser = localStorage.getItem(<span class="hljs-string">'draft-user'</span>)
    <span class="hljs-keyword">if</span> (draftUser != <span class="hljs-literal">null</span>) {
     <span class="hljs-built_in"> user </span>= User.Build(JSON.parse(draftUser))
    }
    <span class="hljs-keyword">if</span> (user) {
      this.uiService.showToast(<span class="hljs-string">'Loaded data from cache'</span>)
    }
  } catch (err) {
    localStorage.removeItem(<span class="hljs-string">'draft-user'</span>)
  }
  return of(user)
} 
clearCache() {
  localStorage.removeItem(<span class="hljs-string">'draft-user'</span>)
}
</code></pre>
        <div class="packt_tip">
          <p>After loading the data, we parse the data into a JSON object, using <code class="Code-In-Text--PACKT-">JSON.parse</code>, and then hydrate the <code class="Code-In-Text--PACKT-">User</code> object with <code class="Code-In-Text--PACKT-">User.Build</code>.</p>
        </div>
      </li>
      <li class="list">Update the <a id="_idIndexMarker1361"/>template to call the <code class="Code-In-Text--PACKT-">clearCache</code> function, so when the user resets the form, we also clear the cache:
        <pre class="programlisting"><code class="hljs stylus"><strong>src/app/user/profile<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.html</span></strong>
&lt;<span class="hljs-selector-tag">button</span> mat-<span class="hljs-selector-tag">button</span> <span class="hljs-attribute">color</span>=<span class="hljs-string">"warn"</span>
    (click)=<span class="hljs-string">"stepper.reset(); </span><strong><span class="hljs-string">clearCache()</span></strong><span class="hljs-string">"</span>&gt;
  Reset
&lt;/button&gt;
</code></pre>
      </li>
      <li class="list" value="3">Update <code class="Code-In-Text--PACKT-">ngOnInit</code> to conditionally load data from cache or the latest <code class="Code-In-Text--PACKT-">currentUser$</code> from <code class="Code-In-Text--PACKT-">authService</code>:
        <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/user/profile.component.ts</strong>
ngOnInit() {
  <span class="hljs-keyword">this</span>.formGroup = <span class="hljs-keyword">this</span>.buildForm()
  <span class="hljs-keyword">this</span>.subs.sink = combineLatest([
        <span class="hljs-keyword">this</span>.loadFromCache(),
        <span class="hljs-keyword">this</span>.authService.currentUser$,
      ])
        .pipe(
          filter(
            <span class="hljs-function"><span class="hljs-params">([cachedUser, me])</span> =&gt;</span> 
              cachedUser != <span class="hljs-literal">null</span> || me != <span class="hljs-literal">null</span>
          ),
          tap(
            <span class="hljs-function"><span class="hljs-params">([cachedUser, me])</span> =&gt;</span> 
              <span class="hljs-keyword">this</span>.patchUser(cachedUser || me)
          )
        )
        .subscribe()
}
</code></pre>
      </li>
    </ol>
    <p class="normal">We leverage the <code class="Code-In-Text--PACKT-">combineLatest</code> operator to combine the outputs of <code class="Code-In-Text--PACKT-">loadFromCache</code> and <code class="Code-In-Text--PACKT-">currentUser$</code>. We check to see that one of the streams is returning a non-null value. If a cached user exists, it takes precedence over the value received from <code class="Code-In-Text--PACKT-">currentUser$</code>.</p>
    <p class="normal">You can test your cache by setting the network status of your browser to be offline, as shown:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_14.png"/></figure>
    <p class="packt_figref">Figure 11.14: Offline network status</p>
    <p class="normal">Set the <a id="_idIndexMarker1362"/>network status of your browser to offline as follows:</p>
    <ol>
      <li class="list" value="1">In Chrome DevTools, navigate to the <strong class="screen-text">Network</strong> tab.</li>
      <li class="list">Select <strong class="screen-text">Offline</strong> in the dropdown marked as <strong class="screen-text">2</strong> in the preceding screenshot.</li>
      <li class="list">Make a change to your form, such as the name, and hit <strong class="screen-text">Update</strong>.</li>
      <li class="list">You'll see an error reading <strong class="screen-text">An unknown error has occurred</strong> displayed at the bottom of the form.</li>
      <li class="list">In the <strong class="screen-text">Network</strong> tab, you'll see that your PUT request has failed.</li>
      <li class="list" value="6">Now, refresh your browser window and observe that the new name you entered is still present.</li>
    </ol>
    <p class="normal">Refer to the following screenshot, which shows the toast notification you get after loading data from the cache:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_11_15.png"/></figure>
    <p class="packt_figref">Figure 11.15: Data loaded from cache</p>
    <p class="normal">Implementing <a id="_idIndexMarker1363"/>a great UX around caching is incredibly challenging. I provided a rudimentary method to show what is possible. However, there are many edge cases that can impact how caching in your application works. </p>
    <p class="normal">In my case, the cache stubbornly sticks around until we successfully save the data to the server. This may be frustrating for some users.</p>
    <p class="normal">Congratulations! You've successfully implemented a sophisticated form to capture data from your users!</p>
    <h1 class="title" id="_idParaDest-414">Exercise</h1>
    <p class="normal">Further enhance the <code class="Code-In-Text--PACKT-">login</code> component to add a login helper for <code class="Code-In-Text--PACKT-">AuthMode.CustomServer</code>.</p>
    <h1 class="title" id="_idParaDest-415">Summary</h1>
    <p class="normal">In this chapter, we covered forms, directives, and user control-related functionality for LemonMart. We created reusable components that can be embedded within another component using data binding. We showed that you can use PUT to send data to the server and cache data input by the user. We also created a multistep input form that is responsive to changing screen sizes. We removed the boilerplate code from our components by leveraging reusable form parts, a base form class to house common functionality, and an attribute directive to encapsulate field-level error behavior and messages.</p>
    <p class="normal">We created dynamic form elements with a date picker, typeahead support, and form arrays. We implemented interactive controls with input masking and the lemon rater. Using the <code class="Code-In-Text--PACKT-">ControlValueAccessor</code> interface, we integrated the lemon rater seamlessly with our form. We showed that we can scale the size and complexity of our forms linearly by extracting the name as its own form section. Additionally, we covered building layouts using grid list.</p>
    <p class="normal">In the next chapter, we will further enhance our components so that we can orchestrate them using the router. We will also implement a master/detail view and a data table, and explore NgRx as an alternative to using RxJS/BehaviorSubject.</p>
    <h1 class="title" id="_idParaDest-416">Further reading</h1>
    <ul>
      <li class="list"><em class="italics">Reactive forms</em>, 2020, available at <a href="https://angular.io/guide/reactive-forms "><span class="url">https://angular.io/guide/reactive-forms</span></a></li>
      <li class="list"><em class="italics">Attribute directives</em>, 2020, available at <a href="https://angular.io/guide/attribute-directives "><span class="url">https://angular.io/guide/attribute-directives</span></a></li>
      <li class="list"><em class="italics">rxweb: Good way to show the error messages in Angular Reactive Forms</em>, Ajay Ojha, 2019, available at <a href="https://medium.com/@oojhaajay/rxweb-good-way-to-show-the-error-messages-in-angular-reactive-forms-c2"><span class="url">https://medium.com/@oojhaajay/rxweb-good-way-to-show-the-error-messages-in-angular-reactive-forms-c27429f51278</span></a></li>
      <li class="list"><em class="italics">The Control Value Accessor</em>, Jennifer Wadella, 2019, available at <a href="https://www.youtube.com/watch?v=kVbLSN0AW-Y"><span class="url">https://www.youtube.com/watch?v=kVbLSN0AW-Y</span></a> </li>
      <li class="list"><em class="italics">CSS Combinators</em>, 2020, available at <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators "><span class="url">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators</span></a></li>
    </ul>
    <h1 class="title" id="_idParaDest-417">Questions</h1>
    <p class="normal">Answer the following questions as best as you can to ensure that you've understood the key concepts from this chapter without Googling. Do you need help answering the questions? See <em class="italics">Appendix D</em>, <em class="italics">Self-Assessment Answers</em> online at <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf"><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf</span></a> or visit <a href="https://expertlysimple.io/angular-self-assessment"><span class="url">https://expertlysimple.io/angular-self-assessment</span></a>.</p>
    <ol>
      <li class="list" value="1">What is the difference between a component and a user control?</li>
      <li>What is an attribute directive?</li>
      <li>What is the purpose of the <code class="Code-In-Text--PACKT-">ControlValueAccessor</code> interface?</li>
      <li>What are serialization, deserialization, and hydration?</li>
      <li>What does it mean to patch values on a form?</li>
      <li>How do you associate two independent <code class="Code-In-Text--PACKT-">FormGroup</code> objects with each other?</li>
    </ol>
  </div>
</body></html>