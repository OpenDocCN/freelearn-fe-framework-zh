<html><head></head><body>
<div id="_idContainer089">
<h1 class="chapter-number" id="_idParaDest-162"><a id="_idTextAnchor328"/><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-163"><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.2.1">The Angular Renaissance</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Our applications need to continually evolve, and to meet this need, the Angular framework and its ecosystem also continue </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">to evolve.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will learn about the latest features of Angular. </span><span class="koboSpan" id="kobo.5.2">While many of them are still in the developer preview phase, it is important for us to get a glimpse of what the future holds for this </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">incredible framework.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Updating your project with the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Angular CLI</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Using a new way to create templates – </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">control flow</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Improving the user experience using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">defer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.15.1"> command</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Creating transitions between pages – </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">view transactions</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Simplifying application states – </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Angular Signals</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.20.1">By the end of this chapter, you will have learned how to stay up to date with future versions of the framework and how to update </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">your project.</span></span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.22.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.23.1">To follow the instructions in this chapter, you’ll need </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.25.1">Visual Studio </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Code (</span></span><a href="https://code.visualstudio.com/Download"><span class="No-Break"><span class="koboSpan" id="kobo.27.1">https://code.visualstudio.com/Download</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.28.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Node.js 18 or </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">higher (</span></span><a href="https://nodejs.org/en/download/"><span class="No-Break"><span class="koboSpan" id="kobo.31.1">https://nodejs.org/en/download/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.32.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.33.1">The code files for this chapter are available </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">at </span></span><a href="https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch13"><span class="No-Break"><span class="koboSpan" id="kobo.35.1">https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch13</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.36.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">During the course of this chapter, remember to run the backend of the application found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">gym-diary-backend</span></strong><span class="koboSpan" id="kobo.39.1"> folder with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">npm </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.42.1"> command.</span></span><a id="_idTextAnchor332"/></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.43.1">Updating your project with the Angular CLI</span></h1>
<p><span class="koboSpan" id="kobo.44.1">The </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.45.1">Angular framework is continually evolving with new </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.46.1">features and optimizations, but to help communities and developers keep organized and their applications up to date, the Angular team uses semantic versioning to number </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">their releases.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">A semantic version number is composed of three parts and each part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">following representation:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.50.1">Major</span></strong><span class="koboSpan" id="kobo.51.1">: A number</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.52.1"> that is increased every time there is a change in the framework, which in turn requires us to change something in our application so that it continues to work, also known as a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.53.1">breaking change</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.54.1">Minor</span></strong><span class="koboSpan" id="kobo.55.1">: A number</span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.56.1"> that is increased when the new version has a new functionality that we can use, but if we don’t use it, we don’t need to change </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">our application</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.58.1">Patch</span></strong><span class="koboSpan" id="kobo.59.1">: A </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.60.1">number that is increased when there is a correction to the framework and we do not need to change our code; this is widely used for versions that have </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">security corrections</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.62.1">In this book, we are working with version 16.2.0 of Angular, and the next version will be 17.0.0, which will bring new functionality and also some breaking changes. </span><span class="koboSpan" id="kobo.62.2">While the the term “breaking changes” is used, we should note that the Angular team has taken more and more care with these changes and currently, they only affect very specific cases that the vast majority of applications are not </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">affected by.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">In addition to rigorous versioning, the Angular team takes care to release major releases every six months, allowing the team to plan application updates. </span><span class="koboSpan" id="kobo.64.2">You may ask, should I always update the Angular version of my application? </span><span class="koboSpan" id="kobo.64.3">The answer is yes, and here are </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">some reasons:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.66.1">Every new version brings internal improvements to the framework that improve the rendering engines, which can make your application faster and the build time and the bundle size smaller and </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">more optimized</span></span></li>
<li><span class="koboSpan" id="kobo.68.1">New features give you more possibilities to create better experiences for </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">your users</span></span></li>
<li><span class="koboSpan" id="kobo.70.1">It provides security updates and framework </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">vulnerability fixes</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.72.1">It is important to highlight that the Angular team is committed to making corrections (long-term support) for up to two major versions before the current one, which means that using old versions of Angular can leave your application vulnerable to new security breaches. </span><span class="koboSpan" id="kobo.72.2">However, the task of updating the Angular version of an application is not that complex as the Angular CLI helps to automate the entire process. </span><span class="koboSpan" id="kobo.72.3">Let’s update our project to version 17 of Angular to use the new features in </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">On your operating system’s command line, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">gym-diary</span></strong><span class="koboSpan" id="kobo.76.1"> project folder, use the </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.78.1">
ng update @angular/core@17 @angular/cli@17</span></pre> <p><span class="koboSpan" id="kobo.79.1">With this command, the Angular CLI will update all Angular packages from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">package.json</span></strong><span class="koboSpan" id="kobo.81.1"> file. </span><span class="koboSpan" id="kobo.81.2">Furthermore, it will analyze all your code in search of situations where it needs to be changed due to a breaking change. </span><span class="koboSpan" id="kobo.81.3">Also, if possible, it will update your code for you. </span><span class="koboSpan" id="kobo.81.4">If this is not possible, it will indicate what type of correction should be made, but again this only happens in very specific </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">corner cases.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">After the </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.84.1">update is complete, to ensure that the application </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.85.1">continues to work after the process, we can run unit tests and end-to-end tests. </span><span class="koboSpan" id="kobo.85.2">For more details about the tests, see </span><a href="B19562_10.xhtml#_idTextAnchor264"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.86.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.87.1">, </span><em class="italic"><span class="koboSpan" id="kobo.88.1">Design for Tests: </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.89.1">Best Practices</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">With our updated project, we can explore the new syntax for HTML templates, which we will see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">next section.</span></span></p>
<h1 id="_idParaDest-166"><span class="koboSpan" id="kobo.93.1">Using a new way to create templates – contro</span><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.94.1">l flow</span></h1>
<p><span class="koboSpan" id="kobo.95.1">Since version 2 of the</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.96.1"> framework, the HTML template syntax has remained relatively stable and without much evolution. </span><span class="koboSpan" id="kobo.96.2">By using custom properties, we can evaluate conditions and iterate over lists and other forms of flow control to create visualization logic in components. </span><span class="koboSpan" id="kobo.96.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">*ngIf</span></strong><span class="koboSpan" id="kobo.98.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">*ngFor</span></strong><span class="koboSpan" id="kobo.100.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">*ngSwitch</span></strong><span class="koboSpan" id="kobo.102.1"> directives are used to improve the developer experience, internally generating the elements in the HTML. </span><span class="koboSpan" id="kobo.102.2">You can read more about this in </span><a href="B19562_04.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.103.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.104.1">, </span><em class="italic"><span class="koboSpan" id="kobo.105.1">Components </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.106.1">and Pages</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">Starting with </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.109.1">version 17, the Angular team introduced a new form of control flow in HTML. </span><span class="koboSpan" id="kobo.109.2">The </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.110.1">syntax in this version is in developer preview, which means that it is stable for production but may have changes in future versions. </span><span class="koboSpan" id="kobo.110.2">Let’s refactor our code to use the syntax and see the difference </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">in practice.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">app.component.html</span></strong><span class="koboSpan" id="kobo.114.1"> file, we will change </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
@if (loadService.isLoading) {
  &lt;app-loading-overlay /&gt;
}
&lt;router-outlet&gt;&lt;/router-outlet&gt;</span></pre> <p><span class="koboSpan" id="kobo.117.1">Here, we can notice the first new structure of the new control flow, </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">if</span></strong><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">Using the command in the HTML template with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">@</span></strong><span class="koboSpan" id="kobo.121.1"> symbol, we apply the conditional statement as in TypeScript, evaluating whether the function or variable is true </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">or false.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">The novelty of the syntax is that we now have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">@else</span></strong><span class="koboSpan" id="kobo.125.1"> instruction facilitating the chaining of conditionals, without the need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">ng-template</span></strong><span class="koboSpan" id="kobo.127.1"> directive for </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">this purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">We will refactor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">list-entries.component.html</span></strong><span class="koboSpan" id="kobo.131.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">a</span><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.133.1">s follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.134.1">
&lt;section class="mb-8"&gt;
  &lt;h2 class="mb-4 text-xl font-bold"&gt;List of entries&lt;/h2&gt;
  &lt;ul class="rounded border shadow"&gt;
    @for (item of exerciseList; track item.id) {
    &lt;li&gt;
      &lt;app-entry-item
        [exercise-set]="item"
        (deleteEvent)="deleteEvent.emit($event)"
        (editEvent)="editEvent.emit($event)"
      /&gt;
    &lt;/li&gt;
    } @empty {
      &lt;div&gt;
        No Items!
</span><span class="koboSpan" id="kobo.134.2">      &lt;/div&gt;
    }
  &lt;/ul&gt;
&lt;/section&gt;</span></pre> <p><span class="koboSpan" id="kobo.135.1">In this example, we are </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.136.1">using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">@for</span></strong><span class="koboSpan" id="kobo.138.1"> instruction to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">*ngFor</span></strong><span class="koboSpan" id="kobo.140.1"> directive. </span><span class="koboSpan" id="kobo.140.2">We provide the name of the variable that will receive the list iteration, in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">item</span></strong><span class="koboSpan" id="kobo.142.1">, and the list itself, in this component, </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">exerciseList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">In </span><a href="B19562_04.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.147.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.148.1">, </span><em class="italic"><span class="koboSpan" id="kobo.149.1">Components and Pages</span></em><span class="koboSpan" id="kobo.150.1">, we learned the good practice of using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">trackBy</span></strong><span class="koboSpan" id="kobo.152.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">*ngFor</span></strong><span class="koboSpan" id="kobo.154.1"> directive to improve list rendering performance. </span><span class="koboSpan" id="kobo.154.2">This good practice is now mandatory in the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">@for</span></strong><span class="koboSpan" id="kobo.156.1"> syntax, and in this case, it is even simpler as we can simply pass the attribute that Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">should check.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">A new element is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">@empty</span></strong><span class="koboSpan" id="kobo.160.1"> instruction, which indicates what should be shown if the list in question </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">is empty.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">The new </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">@for</span></strong><span class="koboSpan" id="kobo.164.1"> instruction, in addition to improving the development experience, is also 90% faster, according to the Angular team, when rendering lists than the previous solution. </span><span class="koboSpan" id="kobo.164.2">That’s because control statements aren’t just sugar syntax for directives; the template engine has been redesigned and the instructions manipulate Angular’s internal DOM </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">rendering elements.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Finally, let’s refactor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">new-entry-form-reactive.component.html</span></strong><span class="koboSpan" id="kobo.168.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.170.1">
. </span><span class="koboSpan" id="kobo.170.2">. </span><span class="koboSpan" id="kobo.170.3">.
</span><span class="koboSpan" id="kobo.170.4">@if (entryForm.get('date')?.invalid &amp;&amp; entryForm.get('date')?.touched) {
    &lt;div class="mt-1 text-red-500"&gt;Date is required.&lt;/div&gt;
    }
. </span><span class="koboSpan" id="kobo.170.5">. </span><span class="koboSpan" id="kobo.170.6">.
</span><span class="koboSpan" id="kobo.170.7">@if (showSuggestions) {
    &lt;ul
      class="absolute z-10 mt-2 w-auto rounded border border-gray-300 bg-white"
    &gt;
      @for (suggestion of exercises$ | async; track suggestion.id) {
      &lt;li
        class="cursor-pointer px-3 py-2 hover:bg-blue-500 hover:text-white"
        (click)="selectExercise(suggestion.description)"
      &gt;
        {{ suggestion.description }}
      &lt;/li&gt;
      }
    &lt;/ul&gt;
    } @if (entryForm.get('exercise')?.invalid &amp;&amp;
    entryForm.get('exercise')?.touched) {
    &lt;div class="mt-1 text-red-500"&gt;Exercise is required.&lt;/div&gt;
    }
. </span><span class="koboSpan" id="kobo.170.8">. </span><span class="koboSpan" id="kobo.170.9">.
</span><span class="koboSpan" id="kobo.170.10">@if (entryForm.get('reps')?.invalid &amp;&amp; entryForm.get('reps')?.touched) {
    &lt;div class="mt-1 text-red-500"&gt;
      Reps is required and must be a positive number.
</span><span class="koboSpan" id="kobo.170.11">    &lt;/div&gt;
    }@else if ( entryForm.get('reps')?.errors?.['isNotMultiple'] &amp;&amp;
    entryForm.get('reps')?.touched) {
    &lt;div class="mt-1 text-red-500"&gt;
      Reps is required and must be multiple of 3.
</span><span class="koboSpan" id="kobo.170.12">    &lt;/div&gt;
    }</span></pre> <p><span class="koboSpan" id="kobo.171.1">In this file, we are replacing the conditionals that evaluate form errors with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">@if</span></strong><span class="koboSpan" id="kobo.173.1"> statement. </span><span class="koboSpan" id="kobo.173.2">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">@for</span></strong><span class="koboSpan" id="kobo.175.1"> instruction that we use to render the list of exercises, we can notice that the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">async</span></strong><span class="koboSpan" id="kobo.177.1"> pipe remains very similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">*ngFor</span></strong><span class="koboSpan" id="kobo.179.1"> directive, and we added </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">track</span></strong><span class="koboSpan" id="kobo.181.1"> to further improve the rendering of the list. </span><span class="koboSpan" id="kobo.181.2">Finally, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">@else if</span></strong><span class="koboSpan" id="kobo.183.1"> command to chain </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">two conditionals.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">We can note that </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.186.1">we do not need to perform any additional configuration to use the flow control syntax because this functionality is fully compatible with the previous mechanics and they can coexist in the same project and even in the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">same file.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">The Angular team even created a migration command in the Angular CLI, </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.190.1">
ng g @angular/core:control-flow</span></pre> <p><span class="koboSpan" id="kobo.191.1">In the next section, we will see a new possibility that this template refactoring provides to our application, the option of lazy loading components in our </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">HTM</span><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.193.1">L </span><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.194.1">templates.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.195.1">Improving the user experience using the defer command</span></h1>
<p><span class="koboSpan" id="kobo.196.1">The</span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.197.1"> main intention behind the new HTML template flow control syntax was to have a new basis for building new possibilities in the framework’s templates. </span><span class="koboSpan" id="kobo.197.2">The first new feature made possible by the syntax is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">defer</span></strong><span class="koboSpan" id="kobo.199.1"> instruction, with which it is possible to lazy load components directly from the </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">HTML template.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">We learned in </span><a href="B19562_02.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.202.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.203.1">, </span><em class="italic"><span class="koboSpan" id="kobo.204.1">Organizing Your Application</span></em><span class="koboSpan" id="kobo.205.1">, that the best practice is to separate your application into functionality modules and configure Angular to load these modules in a lazy way. </span><span class="koboSpan" id="kobo.205.2">This means that the module and its components would only be loaded if the user accessed a certain route, resulting in smaller bundles and better performance of your application, especially if your user does not have a good internet connection (such </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">as 3G).</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">defer</span></strong><span class="koboSpan" id="kobo.209.1"> command has the same purpose but instead of working for modules, it works for </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">standalone</span></strong><span class="koboSpan" id="kobo.211.1"> components. </span><span class="koboSpan" id="kobo.211.2">We studied </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">standalone</span></strong><span class="koboSpan" id="kobo.213.1"> components in </span><a href="B19562_11.xhtml#_idTextAnchor285"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.214.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.215.1">, </span><em class="italic"><span class="koboSpan" id="kobo.216.1">Micro Frontend with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.217.1">Angular Elements</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">We will start our refactoring by transforming the exercise list components into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">standalone</span></strong><span class="koboSpan" id="kobo.221.1"> component. </span><span class="koboSpan" id="kobo.221.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">diary.component.ts</span></strong><span class="koboSpan" id="kobo.223.1"> file, make the </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">following changes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.225.1">
@Component({
  standalone: true,
  templateUrl: './diary.component.html',
  styleUrls: ['./diary.component.css'],
  imports: [ListEntriesComponent, NewItemButtonComponent],
})</span></pre> <p><span class="koboSpan" id="kobo.226.1">In the preceding code, we have included the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">standalone</span></strong><span class="koboSpan" id="kobo.228.1"> attribute set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">true</span></strong><span class="koboSpan" id="kobo.230.1"> and added the components it depends on directly using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">imports</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.232.1"> attribute.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">We will do the same procedure in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">EntryItemComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.236.1">
@Component({
  selector: 'app-entry-item',
  standalone: true,
  templateUrl: './entry-item.component.html',
  styleUrls: ['./entry-item.component.css'],
  imports: [DatePipe],
})</span></pre> <p><span class="koboSpan" id="kobo.237.1">In this component, in addition to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">standalone</span></strong><span class="koboSpan" id="kobo.239.1"> property, we need to add the dependency so that the date pipe works. </span><span class="koboSpan" id="kobo.239.2">It is necessary to note that the standalone component needs to have its dependencies declaratively in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">imports</span></strong><span class="koboSpan" id="kobo.241.1"> attribute, since it is not linked to any </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">Angular module.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">To lazy </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.244.1">load the template, we will also convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">NewItemButtonComponent</span></strong><span class="koboSpan" id="kobo.246.1"> component into a </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">standalone one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
@Component({
  selector: 'app-new-item-button',
  templateUrl: './new-item-button.component.html',
  styleUrls: ['./new-item-button.component.css'],
  standalone: true,
})</span></pre> <p><span class="koboSpan" id="kobo.249.1">The last component to be converted into a standalone component is </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">ListEntriesComponent</span></strong><span class="koboSpan" id="kobo.251.1">, changing it </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
@Component({
  selector: 'app-list-entries',
  standalone: true,
  templateUrl: './list-entries.component.html',
  styleUrls: ['./list-entries.component.css'],
  imports: [EntryItemComponent],
})</span></pre> <p><span class="koboSpan" id="kobo.254.1">In this </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.255.1">example, we added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">EntryItemComponent</span></strong><span class="koboSpan" id="kobo.257.1"> dependency to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">import</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.259.1"> attribute.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.260.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.261.1">The unit tests were also adjusted to consider the component dependencies in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">TestBed</span></strong><span class="koboSpan" id="kobo.263.1"> definition, and you can find the test code in the GitHub repository of </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">The last adjustment must be made in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">DiaryModule</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.267.1"> module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
@NgModule({
  declarations: [
    NewEntryFormTemplateComponent,
    NewEntryFormReactiveComponent,
  ],
  imports: [
    CommonModule,
    DiaryRoutingModule,
    RouterModule,
    FormsModule,
    ReactiveFormsModule,
  ],
})
export class DiaryModule {}</span></pre> <p><span class="koboSpan" id="kobo.269.1">As we will dynamically load the components that were converted to standalone, we have to remove these components from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">declarations</span></strong><span class="koboSpan" id="kobo.271.1"> attribute of </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">the module.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">After this</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.274.1"> preparation, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">defer</span></strong><span class="koboSpan" id="kobo.276.1"> command in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">diary.component.html</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.278.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
@defer {
  &lt;app-list-entries
    [exerciseList]="exerciseList"
    (deleteEvent)="deleteItem($event)"
    (editEvent)="editEntry($event)"
  /&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.280.1">To use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">defer</span></strong><span class="koboSpan" id="kobo.282.1"> command, we must create a block that includes the components that we want to </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">lazy load.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">If we run our application and analyze the </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">Networks</span></strong><span class="koboSpan" id="kobo.286.1"> tab, we will notice that specific bundles are loaded when the screen </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">is rendered:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.288.1"><img alt="Figure 12.1 – Lazy-loaded bundle" src="image/B19562_13_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.289.1">Figure 12.1 – Lazy-loaded bundle</span></p>
<p><span class="koboSpan" id="kobo.290.1">We can see that the effect is similar to the lazy loading of a route module, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">defer</span></strong><span class="koboSpan" id="kobo.292.1"> has other interesting options. </span><span class="koboSpan" id="kobo.292.2">Let’s see this in practice by changing </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">our code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">. </span><span class="koboSpan" id="kobo.294.3">.</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.295.1">@defer (on hover(trigger))</span></strong><span class="koboSpan" id="kobo.296.1">{
  &lt;app-list-entries
    [exerciseList]="exerciseList"
    (deleteEvent)="deleteItem($event)"
    (editEvent)="editEntry($event)"
  /&gt;
}
. </span><span class="koboSpan" id="kobo.296.2">. </span><span class="koboSpan" id="kobo.296.3">.
</span><span class="koboSpan" id="kobo.296.4">  &lt;button
    </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">#trigger</span></strong><span class="koboSpan" id="kobo.298.1">
    class="rounded bg-blue-500 px-4 py-2 font-bold text-white hover:bg-blue-700"
    (click)="newList()"
  &gt;
    Server Sync
  &lt;/button&gt;
. </span><span class="koboSpan" id="kobo.298.2">. </span><span class="koboSpan" id="kobo.298.3">.</span></pre> <p><span class="koboSpan" id="kobo.299.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">on hover(trigger)</span></strong><span class="koboSpan" id="kobo.301.1"> condition, the list is loaded when we hover over the </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">Server Sync</span></strong><span class="koboSpan" id="kobo.303.1"> button. </span><span class="koboSpan" id="kobo.303.2">This is just an example; the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">defer</span></strong><span class="koboSpan" id="kobo.305.1"> command opens up a range of opportunities for fine-tuning the user experience. </span><span class="koboSpan" id="kobo.305.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">defer</span></strong><span class="koboSpan" id="kobo.307.1"> command has the </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">following </span></span><span class="No-Break"><a id="_idIndexMarker602"/></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">conditions:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">on immediate</span></strong><span class="koboSpan" id="kobo.311.1">: The component will be loaded the moment the screen </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">is rendered.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">on idle</span></strong><span class="koboSpan" id="kobo.314.1">: The component will be loaded on the first call to the browser </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">requestIdleCallback</span></strong><span class="koboSpan" id="kobo.316.1"> API. </span><span class="koboSpan" id="kobo.316.2">This API allows non-blocking processing in the browser and is the default behavior of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">defer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.318.1"> command.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">on hover(target)</span></strong><span class="koboSpan" id="kobo.320.1">: We can define another interface component and loading will occur when the user hovers over </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">this component.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">on timer(time)</span></strong><span class="koboSpan" id="kobo.323.1">: Allows us to define in milliseconds when the component will be loaded after the interface </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">is rendered.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">on viewport(target)</span></strong><span class="koboSpan" id="kobo.326.1">: When the target component is in the browser’s viewport, the child components will be loaded. </span><span class="koboSpan" id="kobo.326.2">This behavior is ideal for loading a component that is located after the user has scrolled to the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">the page.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">on interaction(target)</span></strong><span class="koboSpan" id="kobo.329.1">: It has a similar behavior to </span><em class="italic"><span class="koboSpan" id="kobo.330.1">on hover</span></em><span class="koboSpan" id="kobo.331.1">, but it will be triggered by some interaction, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">a click.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">when (condition)</span></strong><span class="koboSpan" id="kobo.334.1">: Allows us to control the loading of the component imperatively, through a Boolean attribute, or a function that returns </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">a Boolean.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.336.1">Complementing </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.337.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">defer</span></strong><span class="koboSpan" id="kobo.339.1"> command, we have other commands that we can use. </span><span class="koboSpan" id="kobo.339.2">Returning to our code, we will change it </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.341.1">
@defer {
  &lt;app-list-entries
    [exerciseList]="exerciseList"
    (deleteEvent)="deleteItem($event)"
    (editEvent)="editEntry($event)"
  /&gt;
  } @loading {
  &lt;div&gt;Loading&lt;/div&gt;
  } @placeholder {
  &lt;div&gt;PlaceHolder&lt;/div&gt;
  } @error {
  &lt;div&gt;Error&lt;/div&gt;
  }</span></pre> <p><span class="koboSpan" id="kobo.342.1">These complementary commands have the </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">following functions:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">@loading</span></strong><span class="koboSpan" id="kobo.345.1">: Presents the content of the block while the components of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">defer</span></strong><span class="koboSpan" id="kobo.347.1"> block </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">are loaded</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">@placeholder</span></strong><span class="koboSpan" id="kobo.350.1">: Displays the content of the block, while the components of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">defer</span></strong><span class="koboSpan" id="kobo.352.1"> block do not start loading, for example, if the user does not hover over the </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">given target</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">@error</span></strong><span class="koboSpan" id="kobo.355.1">: Displays the content of the block if an error occurs when loading the components of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">defer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.357.1"> block</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.358.1">There are </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.359.1">many possibilities that we have with this </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">defer</span></strong><span class="koboSpan" id="kobo.361.1"> command in our templates, and we should explore them to improve our users’ experience. </span><span class="koboSpan" id="kobo.361.2">But note that we should not lazy load all the components of a screen. </span><span class="koboSpan" id="kobo.361.3">We need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">defer</span></strong><span class="koboSpan" id="kobo.363.1"> command on large components or components that are not essential for the page we </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">are building.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">In the next section, we will explore how to improve the experience of transitions between routes i</span><a id="_idTextAnchor339"/><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.366.1">n</span><a id="_idTextAnchor341"/> <span class="No-Break"><span class="koboSpan" id="kobo.367.1">our application.</span></span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.368.1">Creating transitions between pages – view transactions</span></h1>
<p><span class="koboSpan" id="kobo.369.1">As frontend</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.370.1"> developers, we need to worry about the technical performance of our applications. </span><span class="koboSpan" id="kobo.370.2">Small UI details, such as the loading screen that we created in </span><a href="B19562_08.xhtml#_idTextAnchor225"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.371.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.372.1">, </span><em class="italic"><span class="koboSpan" id="kobo.373.1">Improving Backend Integrations: the Interceptor Pattern</span></em><span class="koboSpan" id="kobo.374.1">, improve our users’ perception of the application’s performance. </span><span class="koboSpan" id="kobo.374.2">One of these UI details is the transition between pages of our application. </span><span class="koboSpan" id="kobo.374.3">Instead of dry loading from one route to another, we can create an animation that smooths this transition, making the user experience </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">more pleasant.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">Until version 17 of Angular, it was possible to make this animation using the standard Angular Animation package that we used earlier in the book, in the toaster animation created in </span><a href="B19562_08.xhtml#_idTextAnchor225"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.377.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.378.1">, </span><em class="italic"><span class="koboSpan" id="kobo.379.1">Improving Backend Integrations: the Interceptor Pattern</span></em><span class="koboSpan" id="kobo.380.1">. </span><span class="koboSpan" id="kobo.380.2">The way to create this animation is specific to Angular and is not very simple for designers specializing </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">in CSS.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">As of version 17 of Angular, there is support for </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.383.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.384.1">View Transitions API</span></strong><span class="koboSpan" id="kobo.385.1">, a specific web API for this use case that allows you to create transition animations using pure CSS. </span><span class="koboSpan" id="kobo.385.2">To use it in our project, we will change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">app-routing.module.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.387.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.388.1">
@NgModule({
  imports: [
    RouterModule.forRoot(routes, {
      bindToComponentInputs: true,
      enableViewTransitions: true,
    }),
  ],
  exports: [RouterModule],
})
export class AppRoutingModule {}</span></pre> <p><span class="koboSpan" id="kobo.389.1">We are configuring </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.390.1">Angular so that the route mechanisms will use view transitions written in CSS with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">enableViewTransitions</span></strong><span class="koboSpan" id="kobo.392.1"> property. </span><span class="koboSpan" id="kobo.392.2">With just this change, we can notice in our application that the transition between pages has a pleasant fade-in and fade-out animation. </span><span class="koboSpan" id="kobo.392.3">This default animation was created by the Angular team to make developers’ lives easier. </span><span class="koboSpan" id="kobo.392.4">But we can also customize this animation with a little CSS. </span><span class="koboSpan" id="kobo.392.5">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">styles.css</span></strong><span class="koboSpan" id="kobo.394.1"> file, we will create the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">following classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
@keyframes slide-right {
  from {
    transform: translateX(40px);
  }
}
@keyframes slide-left {
  to {
    transform: translateX(-40px);
  }
}
@keyframes fade-in {
  from {
    opacity: 0;
  }
}
@keyframes fade-out {
  to {
    opacity: 0;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.397.1">For CSS </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.398.1">animations, we need to define an initial and final state that we want the element to be in, in this case, the entire screen. </span><span class="koboSpan" id="kobo.398.2">For our example, we define a state where the screen goes to the right in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">slide-right</span></strong><span class="koboSpan" id="kobo.400.1"> keyframe and goes to the left in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">slide-left</span></strong><span class="koboSpan" id="kobo.402.1"> keyframe. </span><span class="koboSpan" id="kobo.402.2">Finally, we define the keyframes for the fade-in and </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">fade-out effects.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">Note that when we define the transition animation, we completely replace Angular’s default transition animation, so we are defining the fade-in and fade-out </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">keyframes here.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">To set up the animation, let’s add the following to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">styles.css</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.408.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.409.1">
::view-transition-old(root) {
  animation: 100ms cubic-bezier(0.4, 0, 1, 1) both fade-out,
  400ms cubic-bezier(0.4, 0, 0.2, 1) both slide-left;
}
::view-transition-new(root) {
  animation: 250ms cubic-bezier(0, 0, 0.2, 1) 90ms both fade-in,
  400ms cubic-bezier(0.4, 0, 0.2, 1) both slide-right;
}</span></pre> <p><span class="koboSpan" id="kobo.410.1">The View </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.411.1">Transitions API creates pseudo-elements in the CSS where we define the exit animation of the old page (</span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">::view-transition-old</span></strong><span class="koboSpan" id="kobo.413.1">) and the entrance animation of the new page (</span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">::view- transition-old</span></strong><span class="koboSpan" id="kobo.415.1">). </span><span class="koboSpan" id="kobo.415.2">In this case, we define that the old screen will fade out and move to the left and the new page will fade in and slide in from </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">the right.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.417.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.418.1">The View Transitions API was created in 2023 and is being gradually adopted by browsers. </span><span class="koboSpan" id="kobo.418.2">Go to </span><a href="https://caniuse.com/"><span class="koboSpan" id="kobo.419.1">https://caniuse.com/</span></a><span class="koboSpan" id="kobo.420.1"> and check whether the browsers your users will use have support for </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">this API.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">In the next section, we will explore Angular Signals and how we can use it to simplify state contro</span><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.423.1">l in </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">our application.</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.425.1">Simplifying application states – Angular Signals</span></h1>
<p><span class="koboSpan" id="kobo.426.1">Controlling the state of a frontend application is one of the biggest challenges for a developer, as by nature, the interface is dynamic and needs to react to various user actions. </span><span class="koboSpan" id="kobo.426.2">Angular, with its </span><em class="italic"><span class="koboSpan" id="kobo.427.1">stacks included</span></em><span class="koboSpan" id="kobo.428.1"> philosophy, already had tools suitable for this task, and we studied in </span><em class="italic"><span class="koboSpan" id="kobo.429.1">Chapters 5</span></em><span class="koboSpan" id="kobo.430.1">, </span><em class="italic"><span class="koboSpan" id="kobo.431.1">Angular Services and the Singleton Pattern</span></em><span class="koboSpan" id="kobo.432.1">, and </span><a href="B19562_09.xhtml#_idTextAnchor242"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.433.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.434.1">, </span><em class="italic"><span class="koboSpan" id="kobo.435.1">Exploring Reactivity with RxJS</span></em><span class="koboSpan" id="kobo.436.1">, how to use these tools. </span><span class="koboSpan" id="kobo.436.2">However, despite being effective, the Angular community and team recognize that they are a bit complex for new developers and for simple cases of reactivity in frontend projects. </span><span class="koboSpan" id="kobo.436.3">To fill this gap, the Angular team introduced, from version 17 onward, a new element to the framework, </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">called </span></span><span class="No-Break"><a id="_idIndexMarker610"/></span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">Signals.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">According to the Angular documentation, a</span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.440.1"> signal is a wrapper around a value that notifies consumers when that value changes. </span><span class="koboSpan" id="kobo.440.2">An analogy that you can associate with a signal is a cell in a spreadsheet. </span><span class="koboSpan" id="kobo.440.3">It can contain a value and we can create formulas in other</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.441.1"> cells that use its value to create </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">other values.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">Before refactoring our application, let’s illustrate this with a </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">simpler example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.445.1">
let a = signal&lt;number&gt;(2);
let b = signal&lt;number&gt;(3);
let sum = computed(() =&gt; a() + b());
console.log(sum());</span></pre> <p><span class="koboSpan" id="kobo.446.1">To create a signal, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">signal</span></strong><span class="koboSpan" id="kobo.448.1"> function, where we define what type of value it will store and declare an initial value for it. </span><span class="koboSpan" id="kobo.448.2">A signal can be writable or read-only; in this case, the variables </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">a</span></strong><span class="koboSpan" id="kobo.450.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">b</span></strong><span class="koboSpan" id="kobo.452.1"> are writable. </span><span class="koboSpan" id="kobo.452.2">The variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">c</span></strong><span class="koboSpan" id="kobo.454.1"> is also a signal but of a specific type, called computed. </span><span class="koboSpan" id="kobo.454.2">The computed type is, in our analogy of a spreadsheet, a cell that contains a formula where you can read the values of other cells to determine its value. </span><span class="koboSpan" id="kobo.454.3">Finally, we are reading the value of the signal by simply calling it as a function. </span><span class="koboSpan" id="kobo.454.4">The result of this code snippet is the </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">value </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">We will now change </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">the example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.460.1">
let a = signal&lt;number&gt;(2);
let b = signal&lt;number&gt;(3);
let sum = computed(() =&gt; a() + b());
console.log(sum());
a.set(9);
console.log(sum());</span></pre> <p><span class="koboSpan" id="kobo.461.1">In this </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.462.1">change, we are updating the value of signal </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">a</span></strong><span class="koboSpan" id="kobo.464.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">set</span></strong><span class="koboSpan" id="kobo.466.1"> method. </span><span class="koboSpan" id="kobo.466.2">When reading the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">sum</span></strong><span class="koboSpan" id="kobo.468.1"> signal, we can notice that the value was updated to </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">12</span></strong><span class="koboSpan" id="kobo.470.1">. </span><span class="koboSpan" id="kobo.470.2">Notice that the calculation reacts in real time just like it would in </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">a spreadsheet..</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">Another way to update the value of a writable signal is by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">update</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.474.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.475.1">
let a = signal&lt;number&gt;(2);
let b = signal&lt;number&gt;(3);
let sum = computed(() =&gt; a() + b());
console.log(sum());
a.set(9);
console.log(sum());
b.update((oldValue) =&gt; oldValue * 2);
console.log(sum());</span></pre> <p><span class="koboSpan" id="kobo.476.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">update</span></strong><span class="koboSpan" id="kobo.478.1"> method allows you to update the signal based on the last value </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">contained there.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">Despite being simple, </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">signal</span></strong><span class="koboSpan" id="kobo.482.1"> allows many possibilities as it can contain any type of value, from primitive ones such as numeric, string, and Boolean to </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">complex objects.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">We will </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.485.1">refactor our project to use signals, starting with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">LoadService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.487.1"> service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.488.1">
export class LoadService {
  isLoading = signal&lt;Boolean&gt;(false);
  showLoader() {
    this.isLoading.set(true);
  }
  hideLoader() {
    this.isLoading.set(false);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.489.1">Here, we are exchanging the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">isLoading</span></strong><span class="koboSpan" id="kobo.491.1"> attribute for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">isLoading</span></strong><span class="koboSpan" id="kobo.493.1"> signal, simplifying the service. </span><span class="koboSpan" id="kobo.493.2">We will change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">AppComponent</span></strong><span class="koboSpan" id="kobo.495.1"> component template </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.497.1">
@if (loadService.isLoading()) {
  &lt;app-loading-overlay /&gt;
}
&lt;router-outlet&gt;&lt;/router-outlet&gt;</span></pre> <p><span class="koboSpan" id="kobo.498.1">To read the contents of the signal, we call it as if it were a function. </span><span class="koboSpan" id="kobo.498.2">Normally, it is not a good practice to call a function in a template, due to unnecessary processing. </span><span class="koboSpan" id="kobo.498.3">However, the signal was created and optimized to be read in the template, so in this case, there is </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">no problem.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">The next task </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.501.1">will be to refactor the list of journal entries so that we no longer manage the list but leave everything to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.503.1"> service. </span><span class="koboSpan" id="kobo.503.2">We’ll start by changing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.505.1"> service </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
export class ExerciseSetsService {
. </span><span class="koboSpan" id="kobo.507.2">. </span><span class="koboSpan" id="kobo.507.3">.
</span><span class="koboSpan" id="kobo.507.4">  exerciseList = signal&lt;ExerciseSetList&gt;([] as ExerciseSetList);
  getInitialList() {
    const headers = new HttpHeaders().set('X-TELEMETRY', 'true');
    this.httpClient
      .get&lt;ExerciseSetListAPI&gt;(this.url, { headers })
      .pipe(map((api) =&gt; api?.items))
      .subscribe((list) =&gt; this.exerciseList.set(list));
  }
  deleteItem(id: string) {
    this.httpClient.delete&lt;boolean&gt;(`${this.url}/${id}`).subscribe(() =&gt; {
    this.exerciseList.update((list) =&gt;
      list.filter((exerciseSet) =&gt; exerciseSet.id !== id)
    );
    });
  }
. </span><span class="koboSpan" id="kobo.507.5">. </span><span class="koboSpan" id="kobo.507.6">.
</span><span class="koboSpan" id="kobo.507.7">}</span></pre> <p><span class="koboSpan" id="kobo.508.1">In the preceding code block, we created the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">exerciseList</span></strong><span class="koboSpan" id="kobo.510.1"> signal by declaring it to contain </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">ExerciseSetList</span></strong><span class="koboSpan" id="kobo.512.1"> and initializing it with an empty list. </span><span class="koboSpan" id="kobo.512.2">Then, we changed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">getInitialList</span></strong><span class="koboSpan" id="kobo.514.1"> method toupdate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">exerciseList</span></strong><span class="koboSpan" id="kobo.516.1"> signal based on the API return. </span><span class="koboSpan" id="kobo.516.2">We also changed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">delete</span></strong><span class="koboSpan" id="kobo.518.1"> method to update the signal after deleting the </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">diary entry.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">As we are</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.521.1"> changing the behavior of the function, we also need to exclude the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">diaryResolver</span></strong><span class="koboSpan" id="kobo.523.1"> function as now, the service will manage the query in the API and the component will consume the </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">created signal.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">ListEntriesComponent</span></strong><span class="koboSpan" id="kobo.527.1"> component, we will refactor to consume the signal list </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">we created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.529.1">
export class ListEntriesComponent {
  @Output() editEvent = new EventEmitter&lt;ExerciseSet&gt;();
  @Output() deleteEvent = new EventEmitter&lt;string&gt;();
  private exerciseSetsService = inject(ExerciseSetsService);
  exerciseList = this.exerciseSetsService.exerciseList;
}</span></pre> <p><span class="koboSpan" id="kobo.530.1">In the preceding code block, we replace the component’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">input</span></strong><span class="koboSpan" id="kobo.532.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.534.1"> service and receive the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">exerciseList</span></strong><span class="koboSpan" id="kobo.536.1"> signal </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">from it.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">We will change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">ListEntriesComponent</span></strong><span class="koboSpan" id="kobo.540.1"> component template </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.542.1">
&lt;section class="mb-8"&gt;
  &lt;h2 class="mb-4 text-xl font-bold"&gt;List of entries&lt;/h2&gt;
  &lt;ul class="rounded border shadow"&gt;
  @for (item of exerciseList(); track item.id) {
    &lt;li&gt;
      &lt;app-entry-item
        [exercise-set]="item"
        (deleteEvent)="deleteEvent.emit($event)"
        (editEvent)="editEvent.emit($event)"
      /&gt;
    &lt;/li&gt;
    } @empty {
      &lt;div&gt;
        No Items!
</span><span class="koboSpan" id="kobo.542.2">      &lt;/div&gt;
    }
  &lt;/ul&gt;
&lt;/section&gt;</span></pre> <p><span class="koboSpan" id="kobo.543.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">@for</span></strong><span class="koboSpan" id="kobo.545.1"> command</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.546.1"> is prepared to read the content of a signal, including checking the type of value contained </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">in it.</span></span></p>
<p><span class="koboSpan" id="kobo.548.1">To finish this refactoring, we will change the template of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">'</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">DiaryComponent'</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.551.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.552.1">
&lt;app-list-entries
  (deleteEvent)="deleteItem($event)"
  (editEvent)="editEntry($event)"
/&gt;</span></pre> <p><span class="koboSpan" id="kobo.553.1">We removed the exercise list from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">app-list-entries</span></strong><span class="koboSpan" id="kobo.555.1"> component as it will manage the </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">state itself.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">After changing the</span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.558.1"> template, we can change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">DiaryComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.560.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.561.1">
ngOnInit(): void {
  this.exerciseSetsService.getInitialList();
}
deleteItem(id: string) {
  this.exerciseSetsService.deleteItem(id);
}</span></pre> <p><span class="koboSpan" id="kobo.562.1">As the state is now managed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.564.1"> service, we are simplifying the component by just calling the service’s methods, without having to manage subscriptions </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">to observables.</span></span></p>
<p><span class="koboSpan" id="kobo.566.1">With the state managed by Signals, we can add a new feature here on this screen. </span><span class="koboSpan" id="kobo.566.2">Let’s assume that we need to inform the total training volume in the diary, that is, the total amount of </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">exercise performed.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">To have this information and react to events such as the deletion or inclusion of an entry, we can use </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">Angular Signals!</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.572.1"> component, we will make the </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">following change:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.574.1">
volume = computed&lt;number&gt;(() =&gt;
  this.exerciseSetsService
    .exerciseList()
    .reduce(
      (volume, exerciseSet) =&gt; volume + exerciseSet.reps * exerciseSet.sets,
      0
    )
);</span></pre> <p><span class="koboSpan" id="kobo.575.1">We create a new </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.576.1">computed signal called </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">'volume'</span></strong><span class="koboSpan" id="kobo.578.1"> and perform the calculation in it based on the value contained in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">'</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">exerciseList'</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.581.1"> signal.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">To use this new signal, let’s change </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">the template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.584.1">
&lt;header class="bg-blue-500 py-4 text-white"&gt;
  &lt;div class="mx-auto max-w-6xl px-4"&gt;
    &lt;h1 class="text-2xl font-bold"&gt;Workout diary - Total Volume: {{volume()}} &lt;/h1&gt;
  &lt;/div&gt;
&lt;/header&gt;</span></pre> <p><span class="koboSpan" id="kobo.585.1">We are consuming the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">volume</span></strong><span class="koboSpan" id="kobo.587.1"> signal by calling the signal directly in the template. </span><span class="koboSpan" id="kobo.587.2">By running our project, we can notice that this </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">volume</span></strong><span class="koboSpan" id="kobo.589.1"> signal reacts to the changes we make in our list </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">of exercises.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.591.1"><img alt="Figure 12.2 – Lazy-loaded bundle" src="image/B19562_13_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.592.1">Figure 12.2 – Lazy-loaded bundle</span></p>
<p><span class="koboSpan" id="kobo.593.1">Signals are </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.594.1">elements that will be increasingly improved by the Angular team, giving more control over the reactivity of our applications. </span><span class="koboSpan" id="kobo.594.2">An important point that we need to pay attention to is that Signals will not replace RxJS; in fact, they complement each other as we still need observables to control asynchronous flows and more complex flows, as we studied in </span><a href="B19562_09.xhtml#_idTextAnchor242"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.595.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.596.1">,</span><a id="_idTextAnchor345"/> <em class="italic"><span class="koboSpan" id="kobo.597.1">Exploring Reactivity </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.598.1">with RxJS</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">.</span></span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.600.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.601.1">In this chapter, we explored the possibilities that the future of the Angular framework can offer us. </span><span class="koboSpan" id="kobo.601.2">We learned how to update our project to new versions of Angular, an ongoing activity as the framework continues to evolve. </span><span class="koboSpan" id="kobo.601.3">We understood how Angular versioning works and the importance of continually updating our project, from the point of view of security, performance, and new features. </span><span class="koboSpan" id="kobo.601.4">Then, we changed our application to use the new template expressions, which, in addition to simplifying, can, depending on the case, improve the performance of our applications. </span><span class="koboSpan" id="kobo.601.5">With this improvement in template expressions, we looked at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">defer</span></strong><span class="koboSpan" id="kobo.603.1"> expression, which allows for the lazy loading of components within templates, giving us new options for optimizing interfaces with complex components. </span><span class="koboSpan" id="kobo.603.2">We also learned how to use the View Transactions API to improve our users’ experience with animations between page changes. </span><span class="koboSpan" id="kobo.603.3">Finally, we explored Angular Signals and simplified the state management of our application with this new element that complements RxJs. </span><span class="koboSpan" id="kobo.603.4">Angular is a framework that never stops evolving, as our users never stop demanding new features. </span><span class="koboSpan" id="kobo.603.5">In this chapter, we learned how to stay up to date </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">with Angular.</span></span></p>
</div>
</body></html>