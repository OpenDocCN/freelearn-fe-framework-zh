- en: '*Chapter 2*: Working with React Testing Library'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*: 使用 React 测试库'
- en: By the end of this chapter, you will know how to add React Testing Library to
    React projects. React Testing Library is a modern tool for testing the UI output
    of React components from the perspective of end users. You will learn how to properly
    structure tests using the methods from the API. You will learn how to test presentational
    components. Finally, you will learn how to use the `debug` method to assist in
    building out your tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何将 React 测试库添加到 React 项目中。React 测试库是一个现代工具，用于从最终用户的角度测试 React 组件的
    UI 输出。你将学习如何使用 API 中的方法正确构建测试。你将学习如何测试表现性组件。最后，你将学习如何使用 `debug` 方法来协助构建测试。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding React Testing Library to existing projects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 React 测试库添加到现有项目中
- en: Structuring tests with React Testing Library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 测试库构建测试结构
- en: Testing presentational components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试表现性组件
- en: Using the `debug` method while writing tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写测试时使用 `debug` 方法
- en: The skills you will learn in this chapter will set the foundation for more complex
    component scenarios in later chapters.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将学习的技能将为后续章节中更复杂的组件场景打下基础。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the examples in this chapter, you will need to have Node.js installed on
    your machine. We will be using the `create-react-app` CLI tool for all code examples.
    Please familiarize yourself with the tool before starting the chapter if needed.
    You can find code examples for this chapter here: [https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter02](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter02).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，你需要在你的机器上安装 Node.js。我们将使用 `create-react-app` CLI 工具来展示所有代码示例。如果需要，请在开始本章之前熟悉这个工具。你可以在这里找到本章的代码示例：[https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter02](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter02)。
- en: Adding React Testing Library to existing projects
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 React 测试库添加到现有项目中
- en: To get started with React Testing Library, the first thing we need to do is
    install the tool into our React project. We can either install it manually or
    use `create-react-app`, a specific React tool that automatically has React Testing
    Library installed for you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 React 测试库，我们首先需要将工具安装到我们的 React 项目中。我们可以手动安装它，或者使用 `create-react-app`，这是一个特定的
    React 工具，它自动为你安装了 React 测试库。
- en: Manual installation
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动安装
- en: 'Add React Testing Library to your project using the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将 React 测试库添加到你的项目中：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the tool is installed into your project, you can import the available API
    methods to use inside your test files.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工具安装到你的项目中，你就可以导入可用的 API 方法，在测试文件中使用。
- en: Next, we will see how to start a React project with React Testing Library when
    it is already installed for you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何在 React 测试库已经为你安装的情况下，如何开始一个 React 项目的构建。
- en: Automatic installation with create-react-app
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 create-react-app 自动安装
- en: The `create-react-app` tool allows you to create a one-page React application
    quickly. The `create-react-app` tool provides a sample application and an associated
    test to get you started. React Testing Library has become so popular that as of
    version 3.3.0, the `create-react-app` team added React Testing Library as the
    default testing tool. The `create-react-app` tool also includes the `user-event`
    and `jest-dom` utilities. We previously went over `jest-dom` in [*Chapter 1*](B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013),
    *Exploring React Testing Library*. We will cover the `user-event` utility in [*Chapter
    3*](B16887_03_Final_PG_ePub.xhtml#_idTextAnchor046), *Testing Complex Components
    with React Testing Library*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app` 工具允许你快速创建一个单页 React 应用程序。`create-react-app` 工具提供了一个示例应用程序和相关测试，以帮助你入门。React
    测试库已经变得如此流行，以至于从版本 3.3.0 开始，`create-react-app` 团队将 React 测试库作为默认测试工具添加。`create-react-app`
    工具还包括 `user-event` 和 `jest-dom` 工具。我们之前在 [*第一章*](B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013)，*探索
    React 测试库* 中介绍了 `jest-dom`。我们将在 [*第三章*](B16887_03_Final_PG_ePub.xhtml#_idTextAnchor046)，*使用
    React 测试库测试复杂组件* 中介绍 `user-event` 工具。'
- en: So, if you are using at least version 3.3.0 of `create-react-app`, you get a
    React application with React Testing Library, `user-event`, and `jest-dom` automatically
    installed and configured.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你至少使用 `create-react-app` 的 3.3.0 版本，你将获得一个带有 React 测试库、`user-event` 和 `jest-dom`
    自动安装和配置的 React 应用程序。
- en: 'There are two ways you can run the `create-react-app` tool to create a new
    React application. By default, both ways of running the `create-react-app` tool
    will automatically install the latest version of `create-react-app`. The first
    way is with `npx`, which allows you to create a React project without needing
    to have the `create-react-app` tool globally installed on your local machine:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式运行 `create-react-app` 工具来创建一个新的 React 应用程序。默认情况下，运行 `create-react-app`
    工具的两种方式都会自动安装 `create-react-app` 的最新版本。第一种方式是使用 `npx`，它允许你创建一个 React 项目，而无需在本地机器上全局安装
    `create-react-app` 工具：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When using the preceding command, be sure to replace `your-project-title-here`
    with a title to describe your unique project. Also, notice the `--use-npm` flag
    at the end of the command. By default, when you create a project using `create-react-app`,
    it uses Yarn as the package manager for the project. We will use `npm` as the
    package manager throughout this book. We can tell `create-react-app` we want to
    use `npm` as the package manager instead of Yarn using the `--use-npm` flag.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用前面的命令时，请确保将 `your-project-title-here` 替换为一个描述你独特项目的标题。同时，注意命令末尾的 `--use-npm`
    标志。默认情况下，当你使用 `create-react-app` 创建项目时，它使用 Yarn 作为项目的包管理器。在这本书中，我们将使用 `npm` 作为包管理器。我们可以通过使用
    `--use-npm` 标志来告诉 `create-react-app` 我们想要使用 `npm` 而不是 Yarn 作为包管理器。
- en: 'The second way to create a React application with `create-react-app` is by
    installing the tool globally to run on your local machine. Use the following command
    to install the tool globally:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `create-react-app` 创建 React 应用程序的第二种方式是将工具全局安装到本地机器上运行。使用以下命令全局安装该工具：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the previous command, we used the `-g` command to globally install the tool
    on our machine. Once the tool is installed on your machine, run the following
    command to create a project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令中，我们使用了 `-g` 命令在机器上全局安装该工具。一旦工具安装到你的机器上，运行以下命令来创建一个项目：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Like the command we ran in the previous example to create a project using `npx`,
    we create a new project titled `your-project-title-here` using `npm` as the package
    manager.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前使用 `npx` 创建项目时运行的命令一样，我们使用 `npm` 作为包管理器创建一个名为 `your-project-title-here`
    的新项目。
- en: Now you know how to manually install React Testing Library or have it automatically
    installed using `create-react-app`. Next, we will learn about common React Testing
    Library API methods used to structure tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何手动安装 React Testing Library 或者使用 `create-react-app` 自动安装它。接下来，我们将学习一些常用的
    React Testing Library API 方法，这些方法用于构建测试。
- en: Structuring tests with React Testing Library
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Testing Library 构建测试
- en: To structure and write our test code, we will use the *Arrange-Act-Assert* pattern
    that's typical in writing unit tests. There are a few ways to use React Testing
    Library API to structure tests, but we will be using React Testing Library team's
    recommended approach to render React elements into the **Document Object Model**
    (**DOM**), select resulting DOM elements, and make assertions on the expected
    resulting behavior.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建和编写我们的测试代码，我们将使用在编写单元测试中典型的 *安排-行动-断言* 模式。有几种方法可以使用 React Testing Library
    API 来构建测试，但我们将使用 React Testing Library 团队推荐的方法来渲染 React 元素到 **文档对象模型** (**DOM**)
    中，选择生成的 DOM 元素，并对预期的行为进行断言。
- en: Rendering elements
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染元素
- en: 'To test your React components'' output, you need a way to render them into
    the DOM. The React Testing Library''s `render` method takes a passed-in component,
    puts it inside a `div` element, and attaches it to the DOM, as we can see here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的 React 组件的输出，你需要一种方法将它们渲染到 DOM 中。React Testing Library 的 `render` 方法接受一个传入的组件，将其放入一个
    `div` 元素中，并将其附加到 DOM 上，正如我们在这里可以看到的：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous code, we have a test file. First, we import the `render` method
    from React Testing Library. Next, we import the Jumbotron component we want to
    test. Finally, we arrange our test code in the `it` method by using the `render`
    method to render the component to test.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们有一个测试文件。首先，我们从 React Testing Library 导入 `render` 方法。然后，我们导入我们想要测试的
    Jumbotron 组件。最后，我们通过使用 `render` 方法来渲染要测试的组件，在 `it` 方法中安排我们的测试代码。
- en: It is necessary to write additional code to clean up our test in many testing
    frameworks. For example, if a component is rendered into the DOM for one test,
    it needs to be removed before the next test is executed. Removing the component
    from the DOM allows the following test to start from a clean slate and not be
    affected by code from previous tests. React Testing Library's `render` method
    makes test cleanup easier by automatically taking care of removing components
    from the DOM, so there is no need to write additional code to clean up the state
    affected by previous tests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多测试框架中，编写额外的代码来清理我们的测试是必要的。例如，如果一个组件在一个测试中被渲染到DOM中，它需要在执行下一个测试之前被移除。从DOM中移除组件允许下一个测试从一个干净的状态开始，并且不受之前测试中的代码的影响。React
    Testing Library的`render`方法通过自动处理从DOM中移除组件，使得测试清理变得更容易，因此不需要编写额外的代码来清理受之前测试影响的州。
- en: Now that you know how to arrange a test by rendering a component into the DOM
    for testing, we will learn how to interact with the component's resulting DOM
    output in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何通过将组件渲染到DOM中进行测试来安排测试，我们将在下一节学习如何与组件的DOM输出进行交互。
- en: Selecting elements in the component DOM output
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择组件DOM输出中的元素
- en: 'Once we have rendered our component to test into the DOM, the next step is
    to select elements. We will do this by querying the output as a user would. The
    DOM Testing Library API has a `screen` object that is included with React Testing
    Library, allowing you to query the DOM:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将要测试的组件渲染到DOM中，下一步就是选择元素。我们将通过模拟用户查询输出来做这件事。DOM Testing Library API包含在React
    Testing Library中的`screen`对象，允许你查询DOM：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the previous code, we imported `screen` from React Testing Library just
    like we imported `render`. The `screen` object exposes many methods, such as `getByText`
    or `getByRole`, used to query the DOM for elements, similar to actual users that
    we can use in our tests. For example, we might have a component that renders the
    following DOM output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们像导入`render`一样导入了`screen`从React Testing Library。`screen`对象公开了许多方法，例如`getByText`或`getByRole`，用于查询DOM中的元素，类似于我们可以在测试中使用的实际用户。例如，我们可能有一个渲染以下DOM输出的组件：
- en: '![Figure 2.1 – Jumbotron component'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – Jumbotron组件'
- en: '](img/B16887_02_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16887_02_01.jpg)'
- en: Figure 2.1 – Jumbotron component
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – Jumbotron组件
- en: If we wanted to search the DOM for the element with the text **Welcome to our
    site!**, we could do so in two ways.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在DOM中搜索包含文本**欢迎来到我们的网站**的元素，我们可以有两种方式来做。
- en: 'One way would be using the `getByText` method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方式是使用`getByText`方法：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `getByText` method will query the DOM, looking for an element with text
    matching `getByText` method. A user looking for the element wouldn't care if the
    text was in upper or lower case, so `getByText` and all other `screen` object
    methods follow the same approach.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`getByText`方法将查询DOM，寻找与`getByText`方法匹配的文本的元素。一个寻找元素的普通用户不会关心文本是大写还是小写，所以`getByText`和所有其他`screen`对象方法都遵循相同的方法。'
- en: 'A second way we could query the DOM for the element with the text `getByRole`
    method:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种查询DOM中包含文本`getByRole`方法：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `getByRole` method allows you to query the DOM in ways similar to how anyone,
    including those using screen readers, would search. A screen reader would look
    for an element with the role `heading` and the text `welcome to our site!`. There
    are many other methods available on the `screen` object to query elements based
    on how you decide to find them. The DOM Testing Library team recommends using
    the `getByRole` method to select elements as much as possible in the documentation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`getByRole`方法允许你以类似于任何人（包括使用屏幕阅读器的人）搜索的方式查询DOM。屏幕阅读器会寻找具有`heading`角色和文本`欢迎来到我们的网站`的元素。`screen`对象上有许多其他方法，可以根据你决定如何找到它们来查询元素。DOM
    Testing Library团队建议在文档中尽可能使用`getByRole`方法来选择元素。'
- en: Also, because our test code essentially says, `search for a heading element
    with the text 'welcome to our site!'`, it is more explicit than the previous example,
    where we used `getByText` to `search for any element that has the text 'welcome
    to our site!'`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为我们的测试代码本质上说的是，`搜索一个包含文本'欢迎来到我们的网站'的标题元素`，它比之前的例子更明确，在之前的例子中，我们使用了`getByText`来`搜索任何包含文本'欢迎来到我们的网站'的元素`。
- en: In the *Enhancing jest assertions with jest-dom* section of [*Chapter 1*](B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013),
    *Exploring React Testing Library*, we learned that the methods of `jest-dom` provide
    context-specific error messages.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013)的*《增强 jest 断言的 jest-dom》*部分，*《探索
    React Testing Library》*中，我们了解到`jest-dom`的方法提供了上下文特定的错误信息。
- en: 'The methods on the `screen` object provide the same benefits. For example,
    if you attempt to use `getByRole` to select an element that is not present in
    the DOM, the method will stop test execution and provide the following error message:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`screen`对象上的方法提供了相同的好处。例如，如果你尝试使用`getByRole`来选择 DOM 中不存在的元素，该方法将停止测试执行并提供以下错误信息：'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the previous code, the error message explicitly tells you that the query
    method did not find the element. Also, the error message helps by logging elements
    that are selectable based on the rendered DOM:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，错误信息明确告诉你查询方法没有找到元素。此外，错误信息通过记录基于渲染 DOM 可选择的元素来帮助：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, the logged elements help by providing a visual representation
    of the DOM to understand better why the element you searched for was not found.
    Now you know how to select elements using React Testing Library.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，日志记录的元素通过提供 DOM 的视觉表示来帮助理解为什么找不到你搜索的元素。现在你知道如何使用 React Testing Library
    选择元素。
- en: We will learn more advanced ways of interacting with components, such as clicking
    or entering text, in [*Chapter 3*](B16887_03_Final_PG_ePub.xhtml#_idTextAnchor046),
    *Testing Complex Components with React Testing Library*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第3章*](B16887_03_Final_PG_ePub.xhtml#_idTextAnchor046)中学习更多与组件交互的高级方法，例如点击或输入文本，*《使用
    React Testing Library 测试复杂组件》*。
- en: Next, we will learn how to assert the expected output of components.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何断言组件的预期输出。
- en: Asserting expected behavior
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言预期行为
- en: 'The last step in the test structure is to make assertions on behavior. In the
    *Enhancing jest assertions with jest-dom* section of [*Chapter 1*](B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013),
    *Exploring React Testing Library*, we learned how to install and use the `jest-dom`
    tool to make assertions. Building on our test where we searched for the heading
    element with the text `welcome to our site!`, we can use the `toBeInTheDocument`
    method from `jest-dom` to verify whether the element is in the DOM:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结构中的最后一步是对行为进行断言。在[*第1章*](B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013)的*《增强
    jest 断言的 jest-dom》*部分，*《探索 React Testing Library》*中，我们学习了如何安装和使用`jest-dom`工具进行断言。基于我们搜索文本为`welcome
    to our site!`的标题元素的测试，我们可以使用`jest-dom`中的`toBeInTheDocument`方法来验证元素是否在 DOM 中：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the element is not found, we will receive error messages and visual feedback
    to help determine the source of the problem logged to the console, similar to
    what we saw in the *Interacting with the component DOM output* section. If we
    get the expected behavior, then we will receive feedback in the console that our
    test passed, as shown in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到元素，我们将收到错误信息和视觉反馈，以帮助确定记录到控制台的问题来源，类似于我们在*与组件 DOM 输出交互*部分所看到的。如果我们得到预期的行为，那么我们将在控制台收到反馈，如下面的截图所示：
- en: '![Figure 2.2 – Jumbotron component test results](img/B16887_02_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – Jumbotron 组件测试结果](img/B16887_02_02.jpg)'
- en: Figure 2.2 – Jumbotron component test results
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – Jumbotron 组件测试结果
- en: In the previous screenshot, the results indicate that the **displays the heading**
    test passes. Now you know how to make assertions on the output of components with
    React Testing Library. The skills learned in this section have set the foundational
    skills needed in the next section, where we start testing presentational components.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张截图，结果显示**显示标题**测试通过。现在你知道如何使用 React Testing Library 对组件的输出进行断言。本节学到的技能为下一节奠定了基础，下一节我们将开始测试表现性组件。
- en: Testing presentational components
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试表现性组件
- en: In this section, we will use our knowledge of installing and structuring tests
    with React Testing Library to test presentational components. Presentational components
    are components that do not manage state. Typically, you use presentational components
    to display data passed down from parent components as props or to display hardcoded
    data directly in the component itself.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用我们对使用 React Testing Library 安装和构建测试的知识来测试表现性组件。表现性组件是不管理状态的组件。通常，你使用表现性组件来显示从父组件传递下来的作为
    props 的数据，或者直接在组件本身中显示硬编码的数据。
- en: Creating snapshot tests
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建快照测试
- en: 'Snapshot tests are provided by Jest and are great to use when you simply want
    to make sure the HTML output of a component does not change unexpectedly. Suppose
    a developer does change the component''s HTML structure, for example, by adding
    another paragraph element with static text. In that case, the snapshot test will
    fail and provide a visual of the changes so you can respond accordingly. The following
    is an example of a presentational component that renders hardcoded data related
    to travel services to the DOM:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试由 Jest 提供，当您只想确保组件的 HTML 输出不会意外更改时非常有用。假设开发者更改了组件的 HTML 结构，例如，通过添加另一个包含静态文本的段落元素。在这种情况下，快照测试将失败，并提供更改的视觉表示，以便您可以相应地做出反应。以下是一个将有关旅行服务的数据硬编码到
    DOM 中的表现组件的示例：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The component displays an airplane icon in the previous code snippet in an
    `<i>` element and a heading inside an `<h4>` element:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，该组件在 `<i>` 元素中显示飞机图标，并在 `<h4>` 元素中显示标题：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the last piece of the component, the preceding code snippet displays text
    inside a paragraph element. The resulting DOM output looks like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的最后部分，前面的代码片段显示了段落元素内的文本。生成的 DOM 输出如下所示：
- en: '![Figure 2.3 – Travel component](img/B16887_02_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 旅行组件](img/B16887_02_03.jpg)'
- en: Figure 2.3 – Travel component
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 旅行组件
- en: 'Since the component simply displays a few lines of static hardcoded text, it
    makes it a good candidate for a snapshot test. In the following example, we use
    snapshot testing to test the `Travel` component:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该组件仅显示几行静态硬编码的文本，因此它是一个很好的快照测试候选者。在以下示例中，我们使用快照测试来测试 `Travel` 组件：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, in our test file we import the `render` method from React Testing Library.
    Next, we import the `Travel` component. Then, we use object destructuring to get
    `container` off the rendered component. `container` represents the resulting HTML
    output of the component. Finally, we use the `toMatchInlineSnapshot` method from
    Jest to capture the resulting HTML output.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的测试文件中，我们导入 React Testing Library 的 `render` 方法。接下来，我们导入 `Travel` 组件。然后，我们使用对象解构从渲染的组件中获取
    `container`。`container` 代表组件的最终 HTML 输出。最后，我们使用 Jest 的 `toMatchInlineSnapshot`
    方法来捕获生成的 HTML 输出。
- en: 'The following is a portion of the snapshot for the `Travel` component output
    we saw at the beginning of this section:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在本节开头看到的 `Travel` 组件输出的快照的一部分：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, if in the future a developer changes the output of the `Travel` component,
    the test will fail and inform us of the unexpected changes. For example, a developer
    may change the heading from `Travel Anywhere` to `Go Anywhere`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果将来开发者更改了 `Travel` 组件的输出，测试将失败，并通知我们意外的更改。例如，开发者可能将标题从 "Travel Anywhere"
    更改为 "Go Anywhere"：
- en: '![Figure 2.4 – Failed travel snapshot test'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – 失败的旅行快照测试](img/B16887_02_04.jpg)'
- en: '](img/B16887_02_04.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16887_02_04.jpg](img/B16887_02_04.jpg)'
- en: Figure 2.4 – Failed travel snapshot test
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 失败的旅行快照测试
- en: 'The preceding screenshot shows that the test failed and shows us which lines
    changed. `Travel Anywhere` is the text the snapshot is expected to receive that
    differed from the received text, **Go Anywhere**. Also, the line number, **8**,
    and position in the line, **11**, where the difference was found are also pointed
    out. If the change was intentional, we can update our snapshot with the new change.
    Run the following command to update the snapshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示测试失败，并显示了哪些行发生了变化。"Travel Anywhere" 是快照预期接收到的文本，与接收到的文本 "Go Anywhere"
    不同。此外，还指出了发现差异的行号 **8** 和行中的位置 **11**。如果更改是故意的，我们可以用新的更改更新我们的快照。运行以下命令来更新快照：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If your tests are currently running in watch mode, simply press the *U* key
    on your keyboard to update the snapshot. If the change was not intentional, we
    can simply change the text back to the original value inside the component file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的测试目前正在监视模式下运行，只需按键盘上的 *U* 键即可更新快照。如果更改不是故意的，我们只需将文本改回组件文件中的原始值即可。
- en: Now that you know how to create snapshot tests for presentational components,
    we will now learn how to verify properties passed into presentational components.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何为表现组件创建快照测试，我们将学习如何验证传递给表现组件的属性。
- en: Testing expected properties
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试预期属性
- en: 'Presentational components can have data passed into them as `props`, instead
    of hardcoded data directly in the component. The following is an example of a
    presentational component that expects an array of objects for employees to display
    in a table:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现式组件可以接收作为 `props` 传递的数据，而不是直接在组件中硬编码数据。以下是一个期望显示在表格中的员工对象数组的呈现式组件示例：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code snippet, the component has a table with the headings
    `Name`, `Department`, and `Title` for each employee. The following is the table
    body:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，该组件有一个包含每个员工 `Name`、`Department` 和 `Title` 标题的表格。以下是表格体：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code snippet, we iterate over the `employees` array from the
    `props` object inside the table body. We create a table row for each employee,
    access the employee's name, department, and title, and render the data into a
    table cell element.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在表格体内部迭代 `props` 对象中的 `employees` 数组。我们为每个员工创建一个表格行，访问员工的名字、部门和头衔，并将数据渲染到表格单元格元素中。
- en: 'The following is an example of the resulting DOM output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了生成的 DOM 输出：
- en: '![Figure 2.5 – Table component'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5 – 表格组件'
- en: '](img/B16887_02_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16887_02_05.jpg)'
- en: Figure 2.5 – Table component
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 表格组件
- en: 'The `Table` component displays rows of employees that match the expected shape
    of an array of objects with **Name**, **Department**, and **Title** properties.
    We can test that the component properly accepts and displays the rows of employee
    data in the DOM:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table` 组件显示与预期对象数组形状匹配的员工行，该数组具有 **Name**、**Department** 和 **Title** 属性。我们可以测试该组件是否正确接受并显示
    DOM 中的员工数据行：'
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'First, we import the `render` method and `screen` object from React Testing
    Library. Next, we pass in a fake array of employee objects called `fakeEmployees`,
    created for testing purposes, and the `Table` component. The `fakeEmployees` data
    looks like the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 React Testing Library 中导入 `render` 方法 和 `screen` 对象。接下来，我们传递一个名为 `fakeEmployees`
    的虚构员工对象数组，该数组是为了测试目的而创建的，以及 `Table` 组件。`fakeEmployees` 数据看起来如下：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we create the main test code to verify the `fakeEmployee` data is
    present in the DOM:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建主要的测试代码来验证 `fakeEmployee` 数据是否存在于 DOM 中：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For the preceding code snippet's assertions, we verified that at least one piece
    of each object was present in the DOM. You could also verify that every piece
    of data is present in the DOM if that aligns with your testing objectives. Be
    sure to verify that your code tests what you expect it is testing. For example,
    try making the test fail by using the `screen` object to query the DOM for employee
    data that should not be present. If the test fails, you can be more confident
    that the code tests what you expect.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面代码片段的断言，我们验证了每个对象中至少有一部分存在于 DOM 中。你也可以验证如果与你的测试目标一致，每条数据都存在于 DOM 中。务必验证你的代码测试了你期望测试的内容。例如，尝试通过使用
    `screen` 对象查询不应存在的员工数据来使测试失败。如果测试失败，你可以更有信心地认为代码测试了你期望的内容。
- en: 'Although most of the time we want to avoid implementation details and write
    our tests from the perspective of the user, there may be times where testing specific
    details is important to our testing goals. For example, if it might be important
    to you to verify that the striped color theme is present in the rendered version
    of the table component. The `toHaveAttribute` assertion method of `Jest-dom` can
    be used in this situation:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数时候我们想要避免实现细节并从用户的角度编写测试，但有时测试特定细节对于我们的测试目标可能是重要的。例如，如果验证表格组件渲染版本中是否存在条纹颜色主题对你很重要。在这种情况下，可以使用
    `Jest-dom` 的 `toHaveAttribute` 断言方法：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code snippet, we created a test to verify that the table component
    has the correct class attribute. First, we render the `Table` component with employees.
    Next, we select the `table` element using the `getByRole` method off the `screen`
    object. Finally, we assert that the component has a `class` attribute with the
    value `table table-striped`. By using `toHaveAttribute`, we can assert the value
    of component attributes when needed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个测试来验证表格组件具有正确的类属性。首先，我们使用员工渲染 `Table` 组件。接下来，我们使用 `screen`
    对象的 `getByRole` 方法选择 `table` 元素。最后，我们断言组件具有值为 `table table-striped` 的 `class`
    属性。通过使用 `toHaveAttribute`，我们可以在需要时断言组件属性的值。
- en: Now you know how to test presentational components that accept `props` as data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何测试接受 `props` 作为数据的呈现式组件。
- en: In the next section, we will learn how to use the `debug` method to analyze
    the current state of component output as we build out our tests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用`debug`方法在构建测试时分析组件的当前状态。
- en: Using the debug method
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`debug`方法
- en: The `debug` method, accessible from the `screen` object, is a helpful tool in
    React Testing Library's API that allows you to see the current HTML output of
    components as you build out your tests. In this section, we will learn how to
    display the resulting DOM output of an entire component or specific elements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug`方法可以通过`screen`对象访问，是React Testing Library API中的一个有用工具，它允许你在构建测试时查看组件的当前HTML输出。在本节中，我们将学习如何显示整个组件或特定元素的DOM输出结果。'
- en: Debugging the entire component DOM
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试整个组件DOM
- en: 'You can use the `debug` method to log the entire DOM output of a component
    when you run your test:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行测试时，你可以使用`debug`方法记录组件的整个DOM输出：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we first rendered the `Travel` component into the DOM.
    Next, we invoked the `debug` method. When we run our test, the following will
    be logged to the console:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先将`Travel`组件渲染到DOM中。接下来，我们调用了`debug`方法。当我们运行测试时，以下内容将被记录到控制台：
- en: '![Figure 2.6 – Travel DOM debug'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 – Travel DOM调试'
- en: '](img/B16887_02_6.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16887_02_6.jpg)'
- en: Figure 2.6 – Travel DOM debug
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – Travel DOM调试
- en: In the previous screenshot, the entire DOM output of the `Travel` component
    is logged to the screen. Logging the whole output can help you build out your
    test, especially when interacting with one element in the DOM affects elements
    elsewhere in the current DOM. Now you know how to log the output of the entire
    component DOM to the screen. Next, we will learn how to log specific elements
    of the DOM to the screen.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，`Travel`组件的整个DOM输出被记录到屏幕上。记录整个输出可以帮助你构建测试，尤其是在与DOM中的一个元素交互影响当前DOM中其他元素时。现在你已经知道如何将整个组件DOM的输出记录到屏幕上。接下来，我们将学习如何记录DOM的特定元素到屏幕上。
- en: Debugging specific component elements
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试特定组件元素
- en: 'You can use the `debug` method to log specific elements of the resulting component
    DOM to the screen:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`debug`方法将结果组件DOM的特定元素记录到屏幕上：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the previous code, first, we rendered the `Travel` component into the DOM.
    Next, we used the `getByRole` method to query the DOM for a heading with the name
    `travel anywhere` and saved it to a variable named `header`. Next, we invoked
    the `debug` method and passed in the `header` variable to the method. When we
    run our test, the following will be logged to the console:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们将`Travel`组件渲染到DOM中。接下来，我们使用`getByRole`方法查询DOM以获取名为`travel anywhere`的标题，并将其保存到名为`header`的变量中。然后，我们调用了`debug`方法并将`header`变量传递给该方法。当我们运行测试时，以下内容将被记录到控制台：
- en: '![Figure 2.7 – Travel element debug'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 – Travel元素调试'
- en: '](img/B16887_02_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16887_02_07.jpg)'
- en: Figure 2.7 – Travel element debug
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – Travel元素调试
- en: When you pass in a specific DOM node found by using one of the available query
    methods, the `debug` method only logs the HTML for the particular node. Logging
    the output for single elements can help you only focus on specific parts of the
    component. Be sure to remove any `debug` method code from your tests before making
    commits because you only need it while building out the test.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递一个通过可用查询方法找到的特定DOM节点时，`debug`方法只会记录该特定节点的HTML。记录单个元素的输出可以帮助你只关注组件的特定部分。确保在提交之前从测试中移除任何`debug`方法代码，因为你在构建测试时才需要它。
- en: Now you know how to use the `debug` method to render the resulting DOM output
    of your components. The `debug` method is a great visual tool to have while writing
    new tests and also when troubleshooting failing tests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何使用`debug`方法来渲染组件的DOM输出结果。`debug`方法是一个在编写新测试和调试失败的测试时非常有用的视觉工具。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you have learned how to install React Testing Library into
    your React projects. You now understand how to use the API methods to structure
    your tests. You know how to test presentational components, which serves as foundational
    knowledge to build on in the following chapters. Finally, you learned how to debug
    the HTML output of components as you build out your tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学会了如何将React Testing Library安装到你的React项目中。你现在理解了如何使用API方法来构建你的测试。你知道如何测试表现性组件，这为在下一章中构建知识奠定了基础。最后，你学会了如何在构建测试时调试组件的HTML输出。
- en: In the next chapter, we will learn how to test code with more complexity. We
    will also learn how to use the **Test-Driven Development** (**TDD**) approach
    to drive test creation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何测试更复杂的代码。我们还将学习如何使用**测试驱动开发**（**TDD**）方法来驱动测试的创建。
- en: Questions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What method is used to place React components into the DOM?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用来将 React 组件放置到 DOM 中的方法是什么？
- en: Name the object that has methods attached to query the DOM for elements.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名那个附加了查询 DOM 元素方法的对象。
- en: What types of components are good candidates for snapshot tests?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些类型的组件适合进行快照测试？
- en: What method is used for logging the DOM output of components?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于记录组件 DOM 输出的方法是什么？
- en: Create and test a presentational component that accepts an array of objects
    as props.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并测试一个接受对象数组作为 props 的展示组件。
