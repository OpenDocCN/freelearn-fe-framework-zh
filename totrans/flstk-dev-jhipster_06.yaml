- en: Testing and Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have scaffolded and developed our e-commerce application, it's time
    to make it ready for deployment to our production environment. Before that, there
    are two important aspects of engineering that we need to look at, *quality* and
    *stability*. In this chapter, we will see how this can be achieved using modern
    DevOps practices, such as continuous integration and automated testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fixing and running tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CI**/**CD** (**continuous integration**/**continuous deployment**) tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up CI with Jenkins using the JHipster CI-CD sub-generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevOps** is a software engineering practice that unifies software development
    (Dev) and software operation (Ops). The main focus of DevOps is automation and
    monitoring at all stages of software engineering, such as development, integration,
    testing, deployment, and infrastructure management. DevOps is one of the most
    trending engineering practices of this decade, and continuous integration and
    continuous deployment are two of its core aspects.'
  prefs: []
  type: TYPE_NORMAL
- en: Fixing and running tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into continuous integration tools, let's first make sure that
    our tests are working and still pass after the changes we made in the previous
    chapter. In an ideal world, where software development is done using practices
    such as **TDD** (**Test-driven development**), writing and fixing tests is done
    along with the development of the code, and specs are written before you develop
    the actual code. You should try to follow this practice so that you write failing
    tests first for an expected result, and then develop code that will make the tests
    pass. Since our tests were autogenerated by JHipster we can at least make sure
    that they are working when we make changes to the generated code.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster can also generate performance tests using Gatling for the entities.
    It is very useful, and a must if you are developing a high-availability and high-volume
    website. This can be enabled when creating the application. See [http://www.jhipster.tech/running-tests/](http://www.jhipster.tech/running-tests/) for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our unit and integration tests to see if any of them fail:'
  prefs: []
  type: TYPE_NORMAL
- en: Head over to your terminal and navigate to the online-store folder first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s first run the server-side tests using Gradle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that JHipster generates both unit tests and integration tests for the server
    side. The unit tests, files named `*UnitTest.java`, are simple JUnit tests intended
    for unit testing functions. The integration tests, files named `*IntTest.java`,
    are intended for testing a Spring component using the entire Spring environment.
    They are run with the `SpringRunner` class and normally start up the Spring environment,
    configure all the required beans, and run the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of our tests failed with the following error trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You could also run the tests from your IDE so that you have a better error message
    and failure report. Select the entire `src/test` folder, right-click, and select
    Run all tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are expected to fail as we changed the `Resource` classes for these entities
    in the previous chapter to handle authorizations, and the failure means that it''s
    working perfectly. Fortunately, it''s not difficult to fix the tests using Spring.
    We can use the `@WithMockUser` annotation provided by the Spring test context
    to provide a mock user for our tests. Add the annotation with user details as
    highlighted in the following code to all the failing test classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are providing a mock user with the `ADMIN` role here. Add the same to `OrderItemResourceIntTest`, `ProductOrderResourceIntTest`,
    and `ShipmentResourceIntTest`. Run the tests again and they should pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the changes made by running `git commit -am "fix server side tests with mockUser"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s make sure our client-side Karma unit tests are working. Since we
    didn''t make any logic changes on the client-side there shouldn''t be any failures.
    Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All tests should pass. Let''s head over to `src/test/javascript/spec/app/entities/product/product.component.spec.ts`. We
    use the Jasmine Framework for our tests. The existing test has the following structure.
    The `beforeEach` block sets up the Angular `TestBed`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s make sure our protractor `e2e` tests are working. Run the following
    commands in two separate terminals. Start the server first. Let''s clear the database
    as well by a running clean task so that tests run on a fresh setup. Since we are
    running a clean task we also need to run the `webpackBuildDev` task to rebuild
    the client side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the e2e tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer not to run scripts via Yarn or NPM, you could also run them via
    Gradle using the node integration provided by JHipster. For example, instead of
    `yarn e2e`, you could run `./gradlew yarn_e2e`, and instead of `yarn test` you
    could run `./gradlew yarn_test`. This is useful if you do not want to install
    NodeJS and Yarn and want everything to be managed for you by Gradle. If you choose
    Maven instead of Gradle the same feature is available for that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'All tests should pass here as well. But if you look at the generated `e2e`
    tests, for example, look at `src/test/javascript/e2e/entities/customer.spec.ts`,
    you will see that a test is commented out. Some tests are commented out during
    generation if an entity has a required relationship field, as we would have to
    create a relationship first and set its value for the test to work. Let''s focus
    on only the `Customer` page test. Uncomment the test named should create and save
    Customers and change the `describe` function to `fdescribe` on the test file,
    so that only this test file is executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now execute `yarn e2e` and we should see one failing test. First, let''s fix
    the email field by providing a valid email format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `yarn e2e` again and this time it should pass. But since we have a one-to-one
    relationship between user and customer the test will fail if we run it again,
    hence we need to delete the row created after it. Let''s add a test case for a
    delete action. In the `CustomerComponentsPage` class defined in the file (if you
    are using JHipster 5, this class will be available under `src/test/javascript/e2e/page-objects/customer-page-object.ts`),
    add a new property and methods as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add `expect(customerComponentsPage.getTable().isPresent()).toBeTruthy();`
    as the last line in our previous test to confirm if the row was created. Then
    add the following test to delete the row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run `yarn e2e` again to verify. Do not forget to remove the `fdescribe` from
    the file so that all tests get executed. Congratulations! You added you first
    protractor `e2e` tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, fix the commented out `e2e` tests in other files under `src/test/javascript/e2e/entities`
    as well. This is part of the *next steps* assignment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having automated testing ensures that we are creating bug-free code, and also
    ensures that there are no regressions introduced from new code. JHipster helps
    to an extent, by creating unit and integration tests for the generated code, but
    in real use cases, it won't be sufficient. We would have to add server-side unit
    tests for the business logic that we introduce and integration tests for new APIs
    we add. You will also have to add more unit tests for business logic handled on
    the client side and `e2e` tests, as JHipster only generates a few sample tests
    for you and doesn't know anything about your business logic.
  prefs: []
  type: TYPE_NORMAL
- en: The more tests you have, more confident you will be changing code, with fewer
    chances of regression.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and continuous integration is an integral part of full-stack development
    and is an important aspect of DevOps. Testing should be considered as important
    as developing features to build a quality product. Continuous integration is nothing
    more than continuously merging and testing your new code changes in an isolated
    environment against your master/main/stable codebase to identify potential bugs
    and regression. It is achieved by running automated unit, integration, end-to-end,
    and other test suites against the code. For example, if you are working with Git,
    these are typically run for every commit you make to your master branch and/or
    for every pull request, you create.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have automated tests, we can make use of continuous integration practices
    to make sure that any new code we introduce doesn't cause any regression in our
    stable code base. This will give us the confidence to merge new code and deploy
    that to production.
  prefs: []
  type: TYPE_NORMAL
- en: Modern DevOps teams often go a step further and do continuous delivery (continuous integration
    + continuous deployment). They often define CI/CD pipelines, which continuously integrate,
    test, and deploy code to production in a fully automated way.
  prefs: []
  type: TYPE_NORMAL
- en: Teams with a good continuous integration and continuous deployment setup can
    deliver more features more frequently with fewer bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Have I stressed the importance of continuous integration enough?
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JHipster provides excellent support for the well-known CI/CD tools. Let's take
    a look at the options available first.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins ([https://jenkins.io/](https://jenkins.io/)) is one of the leading CI/CD
    tools out there. It is free and open source. It is an automation server written
    in Java and supports integration with various version control tools, such as Git,
    CVS, SVN, and so on. Jenkins has a huge plugin ecosystem and this makes it one
    of the most flexible platforms. Jenkins can be used for building projects, running
    automated tests, automating deployment, and so on. It is available as an executable
    binary for various platforms and as Docker images. Blue Ocean is the latest UI
    interface for Jenkins giving it a much-needed breath of fresh air. Jenkins has
    the concept of a pipeline, achieved by using multiple plugins and a Groovy DSL
    to define the CI/CD pipeline. Jenkins pipeline plugins provide a comprehensive
    DSL-based configuration that can be defined in a file called a `Jenkinsfile`.
  prefs: []
  type: TYPE_NORMAL
- en: Travis CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Travis CI ([https://travis-ci.org/](https://travis-ci.org/)) is an open source
    hosted **PaaS** (**Platform as a Service**) solution for CI/CD. It is free for
    public/OSS projects and needs a subscription for use by private/enterprise projects.
    It supports applications written in a variety of languages and platforms, and
    is heavily used by open source projects, including JHipster, for their continuous
    integration needs. It has excellent integration with version control tools and
    offers an enterprise version as well. It is very easy to set up and use, and has
    a simple YAML-based configuration. Advanced setups are typically done using shell
    scripts that can be triggered by the YAML configuration using hooks.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab CI ([https://about.gitlab.com/features/gitlab-ci-cd/](https://about.gitlab.com/features/gitlab-ci-cd/))
    is a CI/CD solution available as part of GitLab, a web UI on top of Git. It is
    well integrated into the platform and is an excellent choice when using GitLab.
    It is free and open source for use by public projects and has an enterprise version
    as well. It has both a hosted solution and binaries to be used on-premises.
  prefs: []
  type: TYPE_NORMAL
- en: CircleCI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CircleCI ([https://circleci.com/](https://circleci.com/)) is another open source
    CI/CD solution that offers both a hosted PaaS and on-premises option. It has free
    options for small teams and subscription plans for bigger teams and enterprises.
    The configuration is simple and YAML-based, similar to Travis CI. It provides
    options to choose different OS environments for the builds and is very easy to
    set up.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use Jenkins as the CI tool for our application. We first need to set
    up a local Jenkins instance:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are already familiar with Docker, you can use the official Docker image
    provided by Jenkins and can skip the following steps.  The Docker image will be
    automatically generated by JHipster when creating the CD/CI pipeline in the following
    section. Visit [http://www.jhipster.tech/setting-up-ci-jenkins2/](http://www.jhipster.tech/setting-up-ci-jenkins2/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Let's download the latest binary from [http://mirrors.jenkins.io/war-stable/latest/jenkins.war](http://mirrors.jenkins.io/war-stable/latest/jenkins.war).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open a terminal and navigate to the folder where the file was downloaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `java -jar jenkins.war --httpPort=8989` from the terminal to start a
    Jenkins server. The port should not conflict with our application port. The default
    password will be printed on the console. Make a copy of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to [https://localhost:8989](http://localhost:8989) and paste the password
    copied before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Install suggested plugins button on the next page and wait for
    the plugin installation to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an admin user on the next page and complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that our Jenkins server is ready, let's go ahead and create a Jenkins pipeline
    for our project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Jenkins pipeline using JHipster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create the `Jenkinsfile` for our project using the `ci-cd sub-generator`
    from JHipster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, navigate to the online-store folder first. Now run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be asked to select from a list of options as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s select Jenkins pipeline from it. Next, we will have an option to choose
    additional stages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s skip this, as we won''t be needing these for now, and proceed. Next,
    we will be asked if we need to automatically deploy to Heroku from our CI/CD pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's choose this option as we will need it later. Once the option is selected
    JHipster will generate the files and log the following output on the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you want to use Travis instead of Jenkins you can do so by choosing the Travis
    option and then publishing the repository to GitHub as a public repository. Once
    published go to `https://github.com/<username>/<repoName>/settings/installations`
    and add Travis CI as a service and follow the instructions. You can now see automated
    builds when you make commits. Refer to [https://docs.travis-ci.com/user/getting-started/](https://docs.travis-ci.com/user/getting-started/)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we got a `Jenkinsfile` generated at the root and Docker image
    for Jenkins created in the `src/main/docker` directory. We also got an `idea.gdsl`
    file, which is used by IntelliJ Idea for autocompletion.
  prefs: []
  type: TYPE_NORMAL
- en: The Jenkinsfile and its stages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the generated `Jenkinsfile`, which has our pipeline definitions
    using the Groovy DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have multiple stages defined running in a sequence, highlighted in bold;
    there are eight to be exact. It starts with a checkout of the branch from version
    control ending with deployment to Heroku (we will see more about this in the following
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are quite straightforward as most of it is just triggering a Gradle
    task. Let''s look at each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checkout` stage does a local checkout of the source code revision that
    triggered the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This `check java` stage just prints the Java version installed on the Jenkins
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clean` stage first grants execution permission for the Gradle wrapper
    on a Unix-like OS and then executes the Gradle clean task. The `--no-daemon` flag
    disables the Gradle daemon feature, which is not required in a CI environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `install tools` stage makes sure that NodeJS and all the NPM modules are
    installed by running `yarn` install via Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-PnodeInstall` flag ensures that NodeJS is installed first if not done
    already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The **backend tests** stage runs all the server-side integration and unit tests
    by triggering the Gradle test task. It will fail the Jenkins pipeline when there
    is an error and register the test reports on the Jenkins web UI using the JUnit
    plugin after the test run is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to previously, the frontend tests stage runs the client-side unit tests
    by triggering the yarn test command via a `Gradle` task. It will also fail the
    pipeline on an error and register the test reports on the Jenkins web UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `packaging` stage triggers the `Gradle bootRepackage` task with the `prod`
    profile and archives the created WAR files with a unique fingerprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The final stage is for `deployment` and it also uses a Gradle task for this.
    We will see this in detail in the following chapter. For now, let's comment out
    this stage. We will re-enable it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s commit everything to `git` by running these commands. Make sure
    you are on the master branch, else `commit` and merge the branch with the master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the Jenkinsfile in a Jenkins server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our `Jenkinsfile` is ready, let''s set up CI/CD for our application.
    First, we need to upload our application to a GIT server, such as GitHub, GitLab,
    or BitBucket. Let''s use GitHub ([https://github.com/](https://github.com/)) for
    this. Make sure you have an account created in GitHub first:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In GitHub, create a new repository ([https://github.com/new](https://github.com/new));
    let''s call it online-store. *Do not* check the Initialize this repository with
    a README option. Once created, you will see instructions to add code. Let''s go
    with the option of push an existing repository from the command line by running
    the following commands inside our online-store application folder. Do not forget
    to replace `<username>` with your actual GitHub username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now go to the Jenkins server web UI by visiting `http://localhost:8989/` and
    create a new job using the **create new jobs** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter a name, select Pipeline from the list, and click OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2e80a96e-257c-42c0-afe3-5098de2242fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, on the next page, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down or click on the Build Triggers section.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Poll SCM checkbox.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter H/01 * * * * as the cron schedule value so that Jenkins polls our repository
    every minute and builds if there are new commits:![](img/16196b14-9c88-475d-a0b2-ec7e545fd80f.png)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, on the same page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down or click on the Pipeline section.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Pipeline script from SCM for the Definition field from the drop-down
    menu.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Git for the SCM field from the drop-down menu.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Repository URL for the application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click Save:![](img/7bd7ba52-fc98-4b40-924f-2a5a1bde738e.png)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Build Now to trigger a new build to test our pipeline:![](img/f4f6e27f-024e-4e2f-92be-a748bb6dc0fe.png)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should now see a build has started and its progress on the web UI as in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3df6580a-8ea4-44ed-b74f-1289d8bc3377.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! We have successfully set up CI/CD for our application. The
    builds will get triggered when you make new commits as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also the view the pipeline status using the new UI from the Jenkins
    Blue Ocean plugin. Install the plugin from the Plugin Manager (Click on Jenkins
    in the top menu and go to Manage Jenkins | Manage Plugins  | Available and search
    for `Blue Ocean` and install it). The Open Blue Ocean link is available on the
    left-hand side menu. The builds will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d289958e-4b4b-4fa5-b99d-c75e7030ad27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on a build to view the pipeline. You can click on each stage on the progress
    indicator to list the steps from that stage, and then expand the list items to
    view the logs from that step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2e88d7e-18eb-4f74-b4be-89c222a07b61.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at what CI/CD is, and the tools supported by JHipster.
    We also learned how to set up Jenkins and created our CI/CD pipeline using JHipster
    and Jenkins. We also fixed our automated tests and made them run on the CI server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to deploy our application to *production*
    using a cloud-hosting provider such as Heroku.
  prefs: []
  type: TYPE_NORMAL
