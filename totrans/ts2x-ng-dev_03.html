<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Typescript Native Types and Features</h1>
                </header>
            
            <article>
                
<p class="mce-root">You have seen different kinds of examples of using TypeScript. Hopefully, you now know what TypeScript can offer you as a developer. There are still some TypeScript core concepts to learn before hopping right into using it to build Angular 2 apps. This chapter will cover the following TypeScript concepts:</p>
<ul>
<li class="mce-root">Basic types, such as strings, numbers, Boolean, arrays, void, and so on</li>
<li class="mce-root">Function types</li>
<li class="mce-root">Interfaces</li>
<li class="mce-root">Decorators</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic types</h1>
                </header>
            
            <article>
                
<p>Let's revisit the basic types. Most of the types that we will be discussing are familiar to you from JavaScript, but it's nice to have a refresher session to better appreciate what TypeScript offers. Some of the types, on the other hand, are not available in JavaScript but are TypeScript-specific.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strings</h1>
                </header>
            
            <article>
                
<p>Strings are available in both JavaScript and TypeScript. They are used to represent textual data. This data appears in programs as string literals. These literals are easily identified in most programming languages because of the wrapping double quotes (<kbd>""</kbd>).  In JavaScript (and TypeScript), the literals are represented with both double quotes (<kbd>""</kbd>) and single quotes (<kbd>''</kbd>):</p>
<pre>let text: string = "Hi, I am a string. Now you know!";</pre>
<p>In the preceding snippet, the <kbd>text</kbd> variable stores this string: <kbd>"Hi, I am a string. Now you know!"</kbd>. Because TypeScript supports the latest features of JavaScript, you can use the new ES6 template literal:</p>
<pre>const outro: string = 'Now you know!';<br/><br/>let text: string = `Hi, I am not just a simple string.<br/>                    I am actually a paragraph. ${outro}`;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Numbers</h1>
                </header>
            
            <article>
                
<p>Numbers are available in JavaScript and TypeScript.<strong> </strong>Numbers represent floating numbers in JavaScript. You feed them right in with the keyboard, without any decoration like we had to do for strings:</p>
<pre><span class="hljs-keyword">let</span><span> whole: </span><span class="hljs-built_in">number</span><span> = </span><span class="hljs-number">6</span><span>;<br/>let decimal: number = 2.5;<br/></span><span class="hljs-keyword">let</span><span> hex: </span><span class="hljs-built_in">number</span><span> = </span><span class="hljs-number">0xf00d</span><span>; <br/></span><span class="hljs-keyword">let</span><span> binary: </span><span class="hljs-built_in">number</span><span> = </span><span class="hljs-number">0b1010</span><span>; <br/></span><span class="hljs-keyword">let</span><span> octal: </span><span class="hljs-built_in">number</span><span> = </span><span class="hljs-number">0o744</span><span>;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Boolean</h1>
                </header>
            
            <article>
                
<p>The Boolean type is available in JavaScript and TypeScript<strong>. </strong>Booleans are the simplest types you will ever meet in a programming language. They answer the question with yes or no, which is represented in JavaScript as <kbd>true</kbd> or <kbd>false</kbd>:</p>
<pre>let isHappy: boolean = true;<br/>let done: boolean = false;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arrays</h1>
                </header>
            
            <article>
                
<p>Arrays are available in both JavaScript and TypeScript<strong>. </strong>Data structures in JavaScript are basically represented with objects and arrays. Objects are key-value pairs while arrays have an indexable structure. There is no <kbd>array</kbd> type,  rather you provide types for the items that are contained in an array.</p>
<p>You have two options for doing this. You can use the <kbd>[]</kbd> symbol pair, as follows:</p>
<pre>let textArray: string[];<br/><br/>textArray = ["java", "kotlin", "typescript", "the rest..."]</pre>
<p>Alternatively, you can use the built-in generic type:</p>
<pre>let numberArray: Array&lt;number&gt; = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Void</h1>
                </header>
            
            <article>
                
<p>Void is available <em>only </em>in TypeScript<strong>. </strong>The <kbd>void</kbd> type is applicable to functions' return types (we will discuss this soon). Void indicates that a function is not expected to return anything:</p>
<pre><span class="hljs-function"><span class="hljs-keyword">let sum: number = 20<br/><br/>// No return type function<br/>function</span> <span class="hljs-title">addToGlobalSum</span>(numToAdd): <span class="hljs-title">void</span> </span><span>{     <br/>   number + numToAdd</span><span><br/>}<br/><br/><span class="hljs-function"><span class="hljs-title">addToGlobalSum</span></span>(30) <br/>console.log(number) // 50</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Any</h1>
                </header>
            
            <article>
                
<p>Any is available <em>only </em>in TypeScript<strong>.</strong> The<strong> </strong><kbd>any</kbd> type is the most flexible type. It allows you to get closer to the loose nature of JavaScript when there is a need for it. Such needs could arise from third-party libraries that are not typed and if you don't know which value type may be returned from a property or method.</p>
<p>This type can store all the known JavaScript types:</p>
<pre>// Stores a string<br/>let name: any = 'John Doe' <br/><br/>// Stores a number<br/>let age: any = 24<br/><br/>// Stores a boolean<br/>let employed: any = true<br/><br/>// ...even data structures<br/>let person: any[] =['John Doe', 24, true] </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tuple</h1>
                </header>
            
            <article>
                
<p>Tuples are available <em>only </em>in TypeScript<strong>. </strong>They allow you to have varying types in an array. Tuples come with the implication that the fixed number of elements in an array must be defined while creating the type. For example, if we need an array of <kbd>string</kbd>, <kbd>number</kbd>, and <kbd>boolean</kbd>, it will look like this:</p>
<pre>let flexibleArray: [string, number, boolean];<br/><br/>flexibleArray = ['John Doe', 24, true] </pre>
<p>When you try to access an index that was not initially created, the new index is added with the appropriate inferred type:</p>
<pre>let anotherFlexArray: [string, number];<br/><br/>anotherFlexArray = ['John Doe', 24];<br/><br/>Assign true to index 2<br/>anotherFlexArray[2] = true;<br/><br/>// anotherFlexArray becomes ['John Doe', 24, true]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enums</h1>
                </header>
            
            <article>
                
<p>Enums are available <em>only </em>in TypeScript<strong>.</strong> On a few occasions, you may simply want to store a set of numbers, serially or not. Enums hand you a numeric data structure control without having to drag in the complexities of arrays or objects.</p>
<p>The following example shows an <kbd>enum</kbd> type with numbers from <kbd>0</kbd> to <kbd>2</kbd>:</p>
<pre>enum Status {Started, InProgress, Completed}<br/><br/>let status:Status = Status.InProgress // 1</pre>
<p>Enums are <kbd>0</kbd>-based; therefore, <kbd>Started</kbd> holds <kbd>0</kbd>, <kbd>InProgress</kbd> holds <kbd>1</kbd>, and <kbd>Completed</kbd> holds <kbd>2</kbd>. In addition, enums are flexible; hence, you can provide a number for the starting point instead of <kbd>0</kbd>:</p>
<pre>enum Status {Started = 1, InProgress, Completed}<br/><br/>let status:Status = Status.InProgress // 2</pre>
<p>You can write more expressive code with Enums. Let's see how, by using percentage values for the status in the preceding example:</p>
<pre>enum Status {Started = 33, InProgress = 66, Completed = 100}<br/><br/>let status:Status = Status.InProgress + '% done' // 66% done</pre>
<p>It's easy to find out the name of the value if you know the actual value:</p>
<pre>enum Status {Started = 33, InProgress = 66, Completed = 100}<br/><br/>let status:string = Status[66] // InProgress<br/><br/></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions and function types</h1>
                </header>
            
            <article>
                
<p>JavaScript functions are loosely typed and are some of the most common sources of errors in the language. This is what a basic function looks like:</p>
<pre>function stringToArray(char) {<br/>  return char.split(' ')<br/>}</pre>
<p>How sure are we that <kbd>char</kbd> is not a number? Well, we might not have any control over what the developer consuming <kbd>stringToArray</kbd> will pass in. This is why we need to be strict about the value types using TypeScript.</p>
<p>Functions use types in two different parts of their declaration:</p>
<ol>
<li>Function parameters</li>
<li>Function return value</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Function parameters</h1>
                </header>
            
            <article>
                
<p>You can tell TypeScript what type of values a function should expect, and it will strictly adhere to it. The following example shows a function that receives a typed string and a number as its parameters:</p>
<pre>// Typed parameters<br/>function stringIndex(char: string, index: number) {<br/>  const arr = char.split(' ')<br/>  return arr[number];<br/>}</pre>
<p>The <kbd>char</kbd> and <kbd>index</kbd> parameters have the <kbd>string</kbd> and <kbd>number</kbd> <span>types, </span>respectively. Even before things get to the browser, TypeScript will alert you when you try something silly:</p>
<pre>function stringIndex(char: string, index: number) {<br/> const arr = char.split(' ')<br/> return arr[number];<br/>}<br/><br/>stringIndex(true, 'silly') // Types don't match</pre>
<p>Of course, function expressions are not left out:</p>
<pre>const stringIndex = function (char: string, index: number) {<br/> const arr = char.split(' ')<br/> return arr[number];<br/>}</pre>
<p>Moreover, arrow functions are welcome too:</p>
<pre>const stringIndex = (char: string, index: number) =&gt; char.split(' ')[number];</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Function return value</h1>
                </header>
            
            <article>
                
<p>The value expected from a function when it is executed can also be strictly typed:</p>
<pre>function stringIndex(char: string, index: number): string {<br/> const arr = char.split(' ')<br/> return arr[number];<br/>}</pre>
<p>As you can see from the preceding code snippet, the return type comes after the brackets containing the parameters and before the <span>opening curly bracket of the </span>function's body. The preceding function is expected to, and must, return a string. Anything other than a string will scream at you with errors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optional parameters</h1>
                </header>
            
            <article>
                
<p>When a function's parameter is strictly typed, it feels rigid when the function needs to be flexible. Why should we pass in <kbd>index</kbd> to our previous example in a situation where we intend to return the whole string if the index is missing? </p>
<p>When the index parameter is omitted while calling the function, TypeScript will throw an error. To overcome this issue, we can declare the <kbd>index</kbd> parameter as optional:</p>
<pre>function stringIndex(char: string, index?: number): string {<br/>  // Just return string as is<br/>  // if index is not passed in<br/>  if(!index) return char;<br/>  // else, return the index <br/>  // that was passed in<br/>  const arr = char.split(' ')<br/>  return arr[number];<br/>}</pre>
<p>The question mark succeeding the parameter name tells TypeScript that it's okay if the parameter is missing when called. Be careful to handle such cases of parameters not being supplied in the function body, as shown in the preceding example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interfaces</h1>
                </header>
            
            <article>
                
<p>Interfaces are contracts that our code adheres too. It's an agreement that data structures must follow. This helps every data/logic implementing an interface stay safe from improper or non-matching types. It also validates the types and availability of values passed in.</p>
<p>In TypeScript, interfaces are used for the following:</p>
<ol>
<li>Creating types for JavaScript objects.</li>
<li>Setting up contracts for classes to adhere to.</li>
</ol>
<p>We will discuss how interfaces are applied in the scenarios we just listed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interfaces for JavaScript object types</h1>
                </header>
            
            <article>
                
<p>We agree that the following is a valid JavaScript object:</p>
<pre>// Option bag<br/>let options = {show: true, container: '#main'};</pre>
<p>It is a valid JavaScript code but loosely typed. All this while, we have been discussing strings, numbers, Boolean, and even arrays. We are yet to consider objects.</p>
<p>As you may have imagined, the following code snippet demonstrates a typed version of the preceding example:</p>
<pre>// Typed object<br/>let options: {show: boolean, container: string};<br/><br/>// Assing values<br/>options = {show: true, container: '#main'};</pre>
<p>This is <span>correct</span> in fact, but TypeScript could use interfaces to make it more maintainable and easy to comprehend. The following is how we write interfaces in TypeScript:</p>
<pre>interface OptionBag {<br/>  show: boolean,<br/>  container: string<br/>}</pre>
<p>What you can then do is make the <kbd>options</kbd> variable of the <kbd>OptionBag</kbd> type:</p>
<pre>// Typed object<br/>let options: OptionBag = {show: true, container: '#main'};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optional properties</h1>
                </header>
            
            <article>
                
<p>One thing about interfaces, though, is that the defined properties/methods of an interface must be supplied when creating the values that are typed with that interface. Basically, I am saying that we must adhere strictly to the contract established with an interface.</p>
<p>Therefore, the following is incorrect and will throw an error:</p>
<pre>interface OptionBag {<br/> show: boolean,<br/> container: string<br/>}<br/><br/>let options: OptionBag = {show: true}; // Error</pre>
<p>We can make <kbd>container</kbd> optional; we use the question mark literal, as seen in a previous example:</p>
<pre>interface OptionBag {<br/> show: boolean,<br/> container?: string<br/>}<br/><br/>let options: OptionBag = {show: true}; // No Error</pre>
<p>Be careful, though, to account for when the optional parameter is not supplied. The following is an example that does so:</p>
<pre>// Get element<br/>function getContainerElement(options: OptionBag):HTMLElement {<br/>  let containerElement: HTMLElement<br/>  if(!options.container) {<br/>     // container was not passed in<br/>     containerElement = document.querySelector('body');<br/>  } else {<br/>     // container was passed in<br/>     containerElement = document.querySelector(options.container);<br/>  }<br/><br/>  return containerElement<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Read-only properties</h1>
                </header>
            
            <article>
                
<p>Another typical situation is when you have properties to which you intend to assign values only once, just <span>like we do with the ES6</span> <kbd>const</kbd><span> declaration keyword. You can mark the values as</span> <kbd>readonly</kbd><span>:</span></p>
<pre>interface StaticSettings {<br/>  readonly width: number,<br/>  readonly height: number<br/>}<br/><br/>// There are no problems here<br/>let settings: StaticSettings = {width: 1500, height: 750}<br/><br/>// ...but this will throw an error<br/>settings.width = 1000<br/>// or<br/>settings.height = 500</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interfaces as contracts</h1>
                </header>
            
            <article>
                
<p>You can ensure that a class adheres to a particular contract using interfaces. I use the term contract in the sense that all the properties and methods defined in the interface must be implemented in the class.</p>
<p>Let's assume that we have the following <kbd>Note</kbd> interface:</p>
<pre>interface Note {<br/>  wordCount: number<br/>}</pre>
<p>To implement the interface using a class, we add the <kbd>implements</kbd> keyword after the class name followed by the interface we are implementing:</p>
<pre>class NoteTaker implements Note {<br/>  // Implement wordCount from<br/>  // Note interface<br/>  wordCount: number;<br/>  constructor(count: number) {<br/>    this.wordCount = count<br/>  }<br/>}</pre>
<p>Interfaces do not only define the signatures for properties but they also accept function types as methods:</p>
<pre>interface Note {<br/>  wordCount: number;<br/>  updateCount(count: number): void<br/>}</pre>
<p>This could be implemented by a class in the following way:</p>
<pre>class NoteTaker implements Note {<br/> // Implement wordCount from<br/> // Note interface<br/> wordCount: number;<br/> constructor(count: number) {<br/>   this.wordCount = count<br/> }<br/><br/> updateCount(count: number): void {<br/>   wordCount += count<br/> }<br/>}</pre>
<p>TypeScript will throw an error if neither the <kbd>wordCount</kbd> property nor the <kbd>updateCount</kbd> method exists in the <kbd>NoteTaker</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorators</h1>
                </header>
            
            <article>
                
<p>The most common feature introduced in Angular 2+ is <strong>decorators</strong>. Decorators, at first glance, are confusing because of the unusual <kbd>@</kbd> sign preceding their usage:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-290 image-border" height="438" src="assets/f2d6b017-9e35-49d8-9d9e-85f6a967d310.png" width="616"/></div>
<p>The preceding screenshot is a code snippet from an Angular application. It shows a component decorator decorating a class called <kbd>AppComponent</kbd>.</p>
<p>At first, this might look overwhelming because, in the history of JavaScript, I have never seen the <kbd>@</kbd> literal used this way. If only we knew it was just a function that had access to the members of what it is decorating! Classes, properties, methods, and accessors are all allowed to be decorated. Let's discuss how to decorate methods and classes</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorating methods</h1>
                </header>
            
            <article>
                
<p>Let's assume that we want to make a method on a class read-only. Therefore, after creating the method, it cannot be overridden for any reason. For example, this is what the method looks like:</p>
<pre>class Report {<br/>  errPayload;<br/> <br/> // To become readonly<br/>  error() {<br/>     console.log(`The following error occured ${errPayload}`)<br/>  }<br/>}</pre>
<p>If we do not want to override <kbd>error</kbd> in the application's lifecycle, we could write a decorator to set the descriptor's <kbd>writable</kbd> property to <kbd>false</kbd>:</p>
<pre>function readonly(target, key, descriptor) {<br/>   descriptor.writable = false;<br/>   return descriptor<br/>}</pre>
<p>The common signature is that a method decorator takes the same parameters as <kbd>Object.defineProperty</kbd>. In such a case, the target will be the class, the key will be the method name, which is a property of the class, and the descriptor will be the <kbd>config</kbd> object.</p>
<p>We can now decorate the <kbd>error</kbd> method with the just created <kbd>readonly</kbd> decorator:</p>
<pre>class Report {<br/> errPayload;<br/><br/> // Decorated method <br/> @readonly<br/> error() {<br/>   console.log(`The following error occured ${errPayload}`)<br/> }<br/>}</pre>
<p>Any attempt to mutate the error property will fail:</p>
<pre>const report = new Report()<br/><br/>// This would never work<br/>// because 'error' is read only<br/>report.error = function() {<br/>  console.log('I won't even be called')<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorating classes</h1>
                </header>
            
            <article>
                
<p>Another commonly decorated member is the class. In fact, in Angular, almost all classes (components, services, modules, filters, and directives) are decorated. This is why it is important to understand the importance of the existence of decorators.</p>
<p>Decorators can be used to extend the features of a class, as shown in the following example:</p>
<pre>// decorator function<br/>function config(target) {<br/>  target.options = {<br/>    id: '#main',<br/>    show: true<br/>  }<br/>}<br/><br/>// class<br/>@config<br/>class App {}<br/><br/>// options added<br/>console.log(App.options) // {id: '#main', show: true}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorator factories</h1>
                </header>
            
            <article>
                
<p>The preceding example is rigid because the <kbd>options</kbd> object will always have the same value. What if we needed to receive dynamic values? Of course, that's a valid question to ask because the <kbd>id</kbd> property may not always be <kbd>#main</kbd>. Therefore, we need to be more flexible.</p>
<p>Decorator factories are functions that return a decorator, giving you the power to pass in arguments for the decorator via its factory:</p>
<pre>// decorator factory function<br/>function config(options) {<br/>  // decorator function<br/>  return function(target) {<br/>    target.options = options<br/>  }<br/>}<br/><br/>// class decorator<br/>// with arguments<br/>@config({id: '#main', show: true})<br/>class App {}<br/><br/>// options added<br/>console.log(App.options) // {id: '#main', show: true}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We spent time in the first three chapters discussing TypeScript fundamentals with the intention that while walking through the rest of the chapters (which are filled with a lot of Angular stuff), TypeScript will be something you don't have to worry about.</p>
<p>It is fine to assume that the basic types, function types, decorators, and interfaces have been added to your existing knowledge of TypeScript.</p>
<p>In the coming chapters of this book, we will soak ourselves in Angular. If you have come this far, then you made it through the boring parts of this book because, henceforth, we will be building a lot of fun examples with Angular 2+.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>