- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Is State and How Do We Manage It?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**State** is a mutable data source that can be used to store data in a **React**
    application and can change over time and be used to determine how your component
    renders.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will refresh your existing knowledge about state in the React ecosystem.
    We will review what it is and why it is needed, and understand how it helps you
    build React applications.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also review how you can manage state natively in React by using the **useState**
    hook, the **useReducer** hook, and **React Context**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll offer brief descriptions of the common state management solutions
    such as **Redux**, **Zustand**, and **MobX** and understand why they have been
    created and the main common concept they all share.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have either learned or remembered everything
    about state necessary to proceed in this book. You will also notice a pattern
    in how state is managed between different state management solutions and meet
    or get reacquainted with a familiar term. Spoiler alert: it is global state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is state in React?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing state in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do different state management libraries have in common?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this book, you are going to see some code snippets. If you want to try them
    out, you are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An **integrated development environment** (**IDE**) such as Visual Studio Code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web browser (Google Chrome, Firefox, or Edge).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js. All the code in this book was written with the current LTS version
    installed (16.16.0).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A package manager (npm, Yarn, or pnpm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A React project. If you don’t have one, you can create one with Create React
    App by running the following command in your terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_1](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_1).
  prefs: []
  type: TYPE_NORMAL
- en: What is state in React?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State is the heart of your React application.
  prefs: []
  type: TYPE_NORMAL
- en: I challenge you to try to build a React application without any type of state.
    You’d probably be able to do something, but you would soon conclude that props
    cannot do everything for you and get stuck.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the introduction, state is a mutable data source used to store
    your data.
  prefs: []
  type: TYPE_NORMAL
- en: State is mutable, which means that it can be changed over time. When a state
    variable changes, your React component will re-render to reflect any changes that
    the state causes to your UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now, you might be wondering, “*What will I store in my state?*” Well,
    the rule of thumb that I follow is that if your data fits into any of the following
    points, then it’s not state:'
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data that will always be the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data that can be derived from other state variables or props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything that doesn’t fit this list can be stored in state. This means things
    such as data you just fetched through a request, the light or dark mode option
    of a UI, and a list of errors that you got from filling a form in the UI are all
    examples of what can be state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a component called `NotState`. Let’s look at the values we have
    in there and use our rule of thumb.
  prefs: []
  type: TYPE_NORMAL
- en: The `aList` variable is a component prop. Since our component will receive this,
    it doesn’t need to be state.
  prefs: []
  type: TYPE_NORMAL
- en: Our `value` variable is assigned a string value. Since this value will always
    be *constant*, then it doesn’t need to be state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `filteredList` variable is something that can be derived from our
    `aList` prop; therefore, it doesn’t need to be state.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with the concept of state, let’s get our hands dirty
    and understand how can we manage it in React.
  prefs: []
  type: TYPE_NORMAL
- en: Managing state in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into some examples, it is important to mention that in this book,
    *all the examples shown are in a React version after 16.8*. This is because **React
    Hooks** were introduced in this version. Hooks changed the way we write React
    code and allowed for the appearance of libraries such as React Query, so it makes
    sense that any examples shown leverage them.
  prefs: []
  type: TYPE_NORMAL
- en: What is React Query?
  prefs: []
  type: TYPE_NORMAL
- en: React Query is a protocol-agnostic collection of hooks for fetching, caching,
    and updating server state in React.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll show you how React allows us to handle state in a component
    and what we should do if we need to share state between components.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the following scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to build an application that allows me to count something. In this application,
    I want to be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: See the current counter value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increment my counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrement my counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reset the counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s imagine that we have a React component called `App`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This app provides the UI needed to handle our counter needs, such as a `div`
    that we should use to display our `count` and three buttons with an `onClick`
    event waiting for a callback function to perform each of the following actions
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are just missing the heart of this component, which is the state. Natively,
    React gives us two ways to hold state in our applications: `useState` and `useReducer`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking at `useState`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing state with useState
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useState` is a React Hook that allows you to hold a stateful value. When calling
    this hook, it will return the stateful value and a function to update it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how to leverage `useState` to build the counter
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet leverages the `useState` hook to hold our counter state.
    When we first call `useState`, two things are done:'
  prefs: []
  type: TYPE_NORMAL
- en: The state value is initiated as 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `count` state variable is destructured; then, the same is done to the state
    updater function, called `setCount`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this, we declare functions where we use the state updater function, `setCount`,
    to either increment, decrement, or reset our state variable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we assign our state variable to the respective UI section and pass
    the callbacks to our buttons’ `onClick` events.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have built a simple counter application. Our application will
    start rendering our count as 0\. Every time we click on the buttons, it will execute
    the respective state update, re-render our application, and display the new count
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '`useState` is the answer most of the time when you need any state in your React
    applications. Just don’t forget to apply the “*what will I store in my state?*”
    rule of thumb before!'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see an example of how to manage state and build the same counter
    application by using the `useReducer` hook.
  prefs: []
  type: TYPE_NORMAL
- en: Managing state with useReducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useReducer` is the preferred option when we have a more complex state. Before
    using the hook, we need to do some setup so that we have everything we need to
    send to our `useReducer` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we created three things:'
  prefs: []
  type: TYPE_NORMAL
- en: An `initialState` object. This object has a property count with `0` as its value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `types` object that describes all the action types we will support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **reducer**. This reducer is responsible for receiving our state and action.
    By matching that action with the expected type, we’ll be able to update the state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that the setup is done, let’s create our counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet leverages the `useReducer` hook to hold our counter state.
    When we first call `useReducer`, three things are done:'
  prefs: []
  type: TYPE_NORMAL
- en: We indicate to our hook what `reducer` should be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We initialize our state with the `initialState` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We destructure the `state` object and then the `dispatch` function, which allows
    us to dispatch an action from the `useReducer` hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this, we create the functions that will be responsible for calling the
    `dispatch` function with the expected action.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we assign our state variable to the respective UI section and pass
    the callbacks to our buttons’ `onClick` events.
  prefs: []
  type: TYPE_NORMAL
- en: With these two *hooks* under your belt, you now know how to manage state in
    your components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s picture the following scenario: what if you need your counter state
    to be accessible in other components?'
  prefs: []
  type: TYPE_NORMAL
- en: You could pass them by props. But what if this state needs to be sent to five
    other components and different levels on the tree? Would you be prop-drilling
    it and passing it to every component?
  prefs: []
  type: TYPE_NORMAL
- en: To deal with this scenario and improve your code readability, **React Context**
    was created.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing state with React Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Context allows you to natively share values between components without having
    to prop drill them. Let’s learn how to build a context to handle our counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we are doing three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `createContext` function to create our context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `useState` hook. At the end of the store, we return an object that
    contains the functions to do the state updates and create our state variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `CountProvider`. This provider is responsible for creating a provider
    that will be used to wrap a component. This will allow every component that is
    inside of that provider to access our `CountStore` values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once this setup has been done, we need to make sure our components can access
    our context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet leverages `CountProvider`, which we created in the *previous
    snippet*, to wrap up our `App` component. This allows every component inside `App`
    to consume our context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in this snippet, we leverage the `useContext` hook to consume our `CountContext`.
    Since our component is rendered inside our custom provider, we can access the
    state held inside our context.
  prefs: []
  type: TYPE_NORMAL
- en: Every time the state updates inside of our context, React will make sure that
    every component that is consuming our context will re-render, as well as receive
    the state updates. This can often lead to unnecessary re-renders because if you
    are consuming only a variable from the state and for some reason another variable
    changes, then the context will force all consumers to re-render.
  prefs: []
  type: TYPE_NORMAL
- en: One of the downsides of context is that often, unrelated logic tends to get
    grouped. As you can see from the preceding snippets, it comes at the cost of a
    bit of boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, Context is still great, and it’s how React enables you to share state between
    components. However, it was not always around, so the community had to come up
    with ideas on how to enable state sharing. To do so, state management libraries
    were created.
  prefs: []
  type: TYPE_NORMAL
- en: What do different state management libraries have in common?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the freedoms React offers you is that it does not impose any standards
    or practices for your development. While this is great, it also leads to different
    practices and implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this easier and give developers some structure, state management libraries
    were created:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redux** promotes an approach focused on stores, reducers, and selectors.
    This leads to needing to learn specific concepts and filling your project with
    a bunch of boilerplate code that might impact the code’s readability and increase
    code complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zustand** promotes a custom hook approach where each hook holds your state.
    This is by far the simplest solution and currently my favorite one. It synergizes
    with React and fully embraces hooks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MobX** doesn’t impose an architecture but focuses on a functional reactive
    approach. This leads to more specific concepts, and the diversity of practices
    can lead the developer to run into the same struggles of code structure that they
    might already suffer from with React.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One common thing in all these libraries is that all of them are trying to solve
    the same type of issues that we tried to solve with React Context: *a way to manage
    our* *shared state*.'
  prefs: []
  type: TYPE_NORMAL
- en: The state that is accessible to multiple components inside a React tree is often
    called global state. Now, global state is often misunderstood, which leads to
    the addition of unnecessary complexity to your code and often needing to resort
    to the libraries mentioned in this section.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, each developer and team have their preferences and choices.
    Considering React gives you the freedom to handle your state however you want,
    you must consider all the advantages and disadvantages of each solution before
    making your choice. Migrating from one to another can take a lot of time and completely
    change the paradigm of how state is handled in your application, so choose wisely
    and take your time.
  prefs: []
  type: TYPE_NORMAL
- en: While global state is not the reason why React Query was built, it has an impact
    on its creation. The way global state is often composed led to the need to manage
    a specific part of it that has many challenges. This specific part is called server
    state and the way it was historically handled paved the way to motivate Tanner
    Linsley to create React Query.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we became familiar with the concept of state. By now, you should
    understand the importance of state as the heart of React applications and know
    how you can manage it natively with the help of `useState` and `useReducer`.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that sometimes, you need to share your state with multiple components
    and that you can do it with Context or by leveraging a third-party state management
    library. Each of these solutions has its pros and cons, and at the end of the
    day, it will be a question of developer preference.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18501_02.xhtml#_idTextAnchor049), *Server State versus Client
    State*, you will understand more about global state, and you find out that often,
    our global state is a combination of both server and client state. You will learn
    what these terms mean, how to identify these states, and what the common challenges
    associated with them are.
  prefs: []
  type: TYPE_NORMAL
