- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: React Server Components & Server Actions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 服务器组件 & 服务器操作
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几点：
- en: Create and use **React Server Components** ( **RSCs** )
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用 **React 服务器组件** ( **RSCs** )
- en: Describe how (and when) RSCs are executed and rendered to the screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述 RSCs 如何（以及何时）执行并渲染到屏幕上
- en: Fetch data and perform asynchronous operations with the help of RSCs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 RSCs 的帮助下获取数据并执行异步操作
- en: Draw server-client boundaries by building and using client components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构建和使用客户端组件绘制服务器-客户端边界
- en: Perform server-side data mutations with the help of Server Actions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端使用服务器操作执行数据突变
- en: Update the **user interface** ( **UI** ) in response to Server Actions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据服务器操作更新 **用户界面** ( **UI** )
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you learned that you can use **server-side rendering**
    ( **SSR** ) to render React components on the server. SSR ensures that users receive
    a fully populated HTML document upon their initial HTTP request, not an almost
    empty page shell. You were also introduced to Next.js and learned how you may
    use that framework to build React apps that come with SSR (and many other useful
    features) out of the box.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，你了解到你可以使用 **服务器端渲染** ( **SSR** ) 在服务器上渲染 React 组件。SSR 确保用户在他们的初始 HTTP
    请求时收到一个完全填充的 HTML 文档，而不是一个几乎空白的页面外壳。你还被介绍了 Next.js，并学习了如何使用该框架构建带有 SSR（以及许多其他有用功能）的
    React 应用程序。
- en: 'This chapter builds upon the previous one—specifically, you’ll learn about
    two crucial React features that are unlocked by Next.js: **React Server Components**
    ( **RSCs** ) and **Server Actions** .'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于前一章的内容——特别是，你将了解由 Next.js 解锁的两个关键 React 功能：**React 服务器组件** ( **RSCs** )
    和 **服务器操作** .
- en: Throughout this chapter, you’ll learn how these two features help with data
    fetching and mutations, and why you can’t use them in every React project, even
    though they’re technically part of React—not Next.js.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解这两个功能如何帮助数据获取和突变，以及为什么你无法在每一个 React 项目中使用它们，尽管它们在技术上属于 React——而不是 Next.js。
- en: '**Note**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: RSCs and Server Actions are relatively new React features. Supporting them in
    custom React projects is tricky, as you will learn throughout this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: RSCs 和服务器操作是相对较新的 React 功能。在本章中，你将了解到在自定义 React 项目中支持它们是棘手的。
- en: Whilst unlikely, it is possible that concepts or features related to RSCs or
    Server Actions change. It’s also possible that supporting these features in custom
    projects gets easier.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不太可能，但有关 RSCs 或服务器操作的概念或功能可能会发生变化。也有可能支持这些功能在自定义项目中变得更加容易。
- en: 'That’s why this book comes with a dedicated document that tracks any significant
    changes you should be aware of: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md)
    .'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这本书附带了一份专门的文档，跟踪你应该注意的任何重大变化：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md)
    .
- en: The Problem with Server-side Data Fetching
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端数据获取的问题
- en: If you have an SSR-enabled React app, either by manually enabling it, for example,
    in a Vite-based project, or by using a framework like Next.js, your React component
    functions get executed on the server. Thus, any data required by those components
    should be fetched on the server.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个启用了 SSR 的 React 应用程序，无论是通过手动启用它，例如在一个基于 Vite 的项目中，还是通过使用像 Next.js 这样的框架，你的
    React 组件函数将在服务器上执行。因此，这些组件所需的所有数据都应该在服务器上获取。
- en: But as explained in the previous chapter, in the *Server-side Data Fetching
    Is Not Trivial* section, sending HTTP requests with the help of `useEffect()`
    or trying to update the UI via `useState()` does not work when using SSR. On the
    server, React only calls the component functions once—it does not re-execute them
    when the state changes. It also doesn’t call your effect functions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如前一章中解释的，在 *服务器端数据获取并非易事* 部分中，使用 `useEffect()` 发送 HTTP 请求或尝试通过 `useState()`
    更新 UI 在使用 SSR 时不起作用。在服务器上，React 只调用组件函数一次——当状态改变时不会重新执行它们。它也不会调用你的效果函数。
- en: This is a serious limitation since many React apps need to fetch data from some
    backend or a database. Not being able to fetch and render that data on the server
    means that website visitors will again receive incomplete HTML documents (and
    wait for the data to be fetched on the client side), and search engine crawlers
    will not see the most important content of the web page.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个严重的限制，因为许多React应用需要从某些后端或数据库中获取数据。无法在服务器上获取和渲染这些数据意味着网站访客将再次收到不完整的HTML文档（并等待在客户端获取数据），而搜索引擎爬虫将看不到网页的最重要内容。
- en: That’s one of the reasons why React introduced **RSCs** .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是React引入**RSCs**的原因之一。
- en: Introducing RSCs
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍RSCs
- en: RSCs, despite their name, are not necessarily components that run on a server.
    Instead, their defining characteristic is that their component functions are never,
    under any circumstances, executed on the client side!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名为RSCs，但它们并不一定是运行在服务器上的组件。相反，它们的定义特征是，在任何情况下，它们的组件功能都不会在客户端执行！
- en: Consequently, RSCs may be executed on a server, but they may also be called
    during the build process, hence pre-generating components at build time. They
    definitely won’t be executed in the browser, though.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，RSCs可能会在服务器上执行，但它们也可能在构建过程中被调用，因此在构建时预先生成组件。不过，它们肯定不会在浏览器中执行。
- en: '![A diagram of a server  Description automatically generated](img/B31339_16_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![服务器图示 自动生成描述](img/B31339_16_01.png)'
- en: 'Figure 16.1: RSCs can’t be called from the client side'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：RSCs不能从客户端调用
- en: But what’s the purpose of RSCs? How are they created and used?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但RSCs的目的是什么？它们是如何创建和使用的？
- en: Making Sense of RSCs
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解RSCs
- en: The core idea behind RSCs is that you can build components that render outside
    of the browser (e.g., on the server). As a result, these components can execute
    code that wouldn’t work in the browser—for example, because Node.js-specific APIs
    are used, or code that relies on credentials (e.g., database credentials) that
    must not be exposed to the client.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: RSCs背后的核心思想是你可以构建在浏览器之外渲染的组件（例如，在服务器上）。因此，这些组件可以执行在浏览器中无法运行的代码——例如，因为使用了Node.js特定的API，或者依赖于必须不向客户端暴露的凭据（例如，数据库凭据）的代码。
- en: Unlike “normal” components (client components) that are rendered via SSR, RSCs
    can be rendered (on the server) after the initial page load. Hence, RSCs are not
    just about rendering an initial page snapshot. In addition, RSCs can fetch data
    on the server side. Later in this chapter, the *RSCs vs Server-side Rendering*
    section will take a closer look at the relationship between RSCs and “normal”
    components rendered via SSR.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过SSR渲染的“正常”组件（客户端组件）不同，RSCs可以在初始页面加载后（在服务器上）进行渲染。因此，RSCs不仅仅是关于渲染初始页面快照。此外，RSCs还可以在服务器端获取数据。在本章的后面部分，“RSCs与服务器端渲染”部分将更详细地探讨RSCs与通过SSR渲染的“正常”组件之间的关系。
- en: 'Hence, RSCs solve an important problem: they allow you to intertwine frontend
    and backend React code. Whereas, in the past, before RSCs, you typically had to
    build separate backend and frontend web applications, you can now build integrated
    fullstack apps that blend server-side and client-side React code.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，RSCs解决了重要问题：它们允许你将前端和后端React代码交织在一起。在过去，在RSCs之前，你通常必须构建单独的后端和前端Web应用程序，而现在你可以构建集成的全栈应用程序，将服务器端和客户端的React代码融合在一起。
- en: 'Using RSCs therefore offers various advantages:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用RSCs提供了各种优势：
- en: Building fully integrated fullstack applications where the backend and frontend
    are closely connected and use the same server becomes much easier.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建完全集成的全栈应用程序变得更加容易，其中后端和前端紧密相连并使用相同的服务器。
- en: 'Asynchronous server-side data fetching inside of components becomes possible:
    Unlike on the client side (or when using SSR), React allows you to use `async/await`
    and return a `Promise` value in your component functions.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件内部进行异步服务器端数据获取成为可能：与客户端（或使用SSR）不同，React允许你在组件函数中使用`async/await`并返回`Promise`值。
- en: Website visitors download smaller client-side JavaScript bundles since the code
    of RSCs is omitted.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站访客下载的客户端JavaScript包更小，因为RSCs的代码被省略了。
- en: Running compute-heavy operations or using large third-party libraries gets easier
    since the operations and their code can be outsourced to the server (or to the
    build process).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于操作及其代码可以外包给服务器（或构建过程），因此运行计算密集型操作或使用大型第三方库变得更加容易。
- en: Code or credentials that shouldn’t be accessible by your website users can be
    moved into RSCs.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应被网站用户访问的代码或凭据可以移动到RSCs中。
- en: 'For example, thanks to RSCs, you can create components like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，多亏了 RSC，您可以创建如下组件：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `ProductsPage` component contains code that reaches out to a PostgreSQL
    database to fetch product data from there.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductsPage` 组件包含代码，该代码会连接到 PostgreSQL 数据库以从那里获取产品数据。'
- en: Without RSCs, this kind of component would be impossible to build and use. You
    wouldn’t be allowed to use `async/await` , the `pg` package might rely on some
    APIs that are not available in the browser, and you would expose your database
    credentials in the client-side code bundle.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 没有RSC，这种组件将无法构建和使用。您将不允许使用 `async/await`，`pg` 包可能依赖于浏览器中不可用的某些 API，并且您会在客户端代码捆绑中暴露数据库凭证。
- en: All these things are allowed when building RSCs. React explicitly does allow
    you to return a `Promise` (and hence use `async/await` ) when building an RSC.
    Since the code is guaranteed to never end up on the client side, connecting to
    a database is safe, too.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 RSC 时，所有这些操作都是允许的。React 明确允许您在构建 RSC 时返回一个 `Promise`（因此可以使用 `async/await`）。由于代码保证永远不会出现在客户端，因此连接到数据库也是安全的。
- en: Therefore, you can easily build fully integrated fullstack apps where backend
    and frontend code blend seamlessly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以轻松构建完全集成的全栈应用程序，其中后端和前端代码无缝融合。
- en: However, using RSCs is both simple and complex at the same time, as the next
    section will explain.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 RSC 既是简单又是复杂的，下一节将进行解释。
- en: Creating & Using RSCs
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用 RSC
- en: In a Next.js project that uses the App Router, all React components, no matter
    if used as pages or nested in some other component, are, by default, RSCs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 App Router 的 Next.js 项目中，所有 React 组件，无论它们是作为页面使用还是嵌套在其他组件中，默认情况下都是 RSC。
- en: 'As you can tell if you inspect any React component function in a Next.js project,
    there really is nothing special about them. They look like regular React components:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 Next.js 项目中检查任何 React 组件函数时可以看出的，它们实际上并没有什么特别之处。它们看起来就像普通的 React 组件：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may use `async/await` with them, but you don’t have to. You may use server-side
    APIs and packages, but you don’t have to. So, creating RSCs is simple—they’re
    just normal components after all.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `async/await` 与它们一起使用，但您不必这样做。您可以使用服务器端 API 和包，但您不必这样做。因此，创建 RSC 是简单的——它们毕竟只是普通组件。
- en: 'The same is true for using them—you use them as you always used React components:
    as custom JSX elements:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们也是一样——您像使用 React 组件一样使用它们：作为自定义 JSX 元素：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, you wouldn’t be able to tell that this is a special kind of
    component. It’s created and used as you learned it through this entire book.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您无法分辨出这是一个特殊类型的组件。它是按照您在这本书中学到的全部内容创建和使用的。
- en: Nonetheless, all the other components from all the other chapters of this book,
    which were used in Vite-based React projects, were not RSCs. They were regular
    components or **client components** .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，本书其他章节中使用的所有其他组件，在基于 Vite 的 React 项目中，都不是 RSC。它们是普通组件或**客户端组件**。
- en: So, what makes the components in a Next.js project special? Why is a feature
    provided by React available in Next.js projects but not necessarily in other React
    projects (e.g., in Vite-based projects)?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是什么让 Next.js 项目的组件变得特殊？为什么 React 提供的功能在 Next.js 项目中可用，但在其他 React 项目（例如基于
    Vite 的项目）中不一定可用？
- en: Unlocking RSCs in React Projects
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 React 项目中解锁 RSC
- en: RSCs are a feature provided by React, not Next.js. Yet, not all React projects
    can use this feature.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: RSC（React Server Components）是 React 提供的功能，而不是 Next.js。然而，并非所有 React 项目都能使用这个功能。
- en: 'The reason for that, and for why RSCs are available in Next.js projects, is
    the Next.js build process and what Next.js does to these components (and to the
    entire React project code, actually) behind the scenes. At a high level, you can
    think of Next.js doing the following things:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于此，以及为什么 RSC 在 Next.js 项目中可用，是因为 Next.js 的构建过程以及 Next.js 在幕后对这些组件（以及整个 React
    项目代码）所做的事情。从高层次来看，您可以认为 Next.js 做了以下事情：
- en: The build workflow and bundling process separates server and client components
    to ensure that no RSC code ends up on the client side.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工作流程和捆绑过程将服务器和客户端组件分离，以确保没有 RSC 代码出现在客户端。
- en: Next.js sets up API endpoints (i.e., URL addresses to which the client-side
    code may send requests) that trigger RSC component functions on the server and
    return instructions that allow the client-side React code to update the UI.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要时，Next.js 会调用这些 API 端点（即客户端代码可以发送请求的 URL 地址），在服务器上触发 RSC 组件函数，并返回允许客户端 React
    代码更新 UI 的指令。
- en: Next.js calls these endpoints when needed—for example, when navigating to a
    new page.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当导航到新页面时，Next.js 会调用这些端点。
- en: Next.js passes the API response (which contains these rendering instructions)
    to React, which uses the returned instructions to update the UI as needed.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js将API响应（其中包含这些渲染指令）传递给React，React使用返回的指令按需更新UI。
- en: '![img](img/B31339_16_02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_16_02.png)'
- en: 'Figure 16.2: Client and server component code are separated; communication
    happens via HTTP requests'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：客户端和服务器组件代码是分开的；通信通过HTTP请求进行
- en: Technically, it’s a bit more complex than that, but for the purpose of this
    book and for using the feature, a deep understanding of the internals is not required—just
    as you don’t need to understand what exactly happens internally when using `useState()`
    , for example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这要复杂一些，但为了本书的目的和为了使用此功能，不需要深入了解内部机制——就像您在使用`useState()`时不需要了解内部具体发生了什么一样。
- en: 'You can verify the mentioned points by running a demo Next.js project you find
    here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/examples/01-rsc-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/examples/01-rsc-intro)
    .'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行您在此处找到的演示Next.js项目来验证所提到的点：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/examples/01-rsc-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/examples/01-rsc-intro)。
- en: 'This demo app consists of two basic page component files: `app/page.js` and
    `app/info/page.js` . The main page component (the `Home` component inside `app/page.js`
    ) outputs a `ServerComponentInfo` component:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此演示应用程序由两个基本的页面组件文件组成：`app/page.js`和`app/info/page.js`。主页面组件（位于`app/page.js`中的`Home`组件）输出一个`ServerComponentInfo`组件：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That component in turn simply outputs some static, hardcoded content:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件随后简单地输出一些静态、硬编码的内容：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both the `Home` and the `ServerComponentInfo` components are RSCs—simply because
    they are components in a Next.js project. As mentioned earlier, all components
    in Next.js projects are server components by default. If these components were
    part of a Vite-based React project that is not set up to support RSCs, these components
    would instead be “normal” components (client components).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Home`和`ServerComponentInfo`组件都是RSC——仅仅因为它们是Next.js项目中的组件。如前所述，Next.js项目中的所有组件默认都是服务器组件。如果这些组件是Vite-based
    React项目的一部分，并且该项目未设置以支持RSCs，则这些组件将变为“普通”组件（客户端组件）。'
- en: 'In the same demo project, there is also a component for the `/info` page. This
    component contains some code that wouldn’t work in a component that isn’t an RSC:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的演示项目中，还有一个用于`/info`页面的组件。该组件包含一些在非RSC组件中无法工作的代码：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code wouldn’t work in any of the (Vite-based) React projects you saw before
    in this book because of the following reasons:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以下原因，此代码在本书之前看到的任何（基于Vite的）React项目中都无法工作：
- en: The `InfoPage` component uses Node’s `fs` package to load data from a `rsc-info.json`
    file (which is part of the project).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InfoPage`组件使用Node的`fs`包从`rsc-info.json`文件（项目的一部分）加载数据。'
- en: The component uses `async/await` , hence returning a `Promise` that eventually
    yields the JSX code (i.e., the React elements).
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该组件使用`async/await`，因此返回一个`Promise`，最终产生JSX代码（即React元素）。
- en: In projects that do not support RSCs, you’re not able to use server-side APIs
    since all the code runs in the browser. You’re also not allowed to return a `Promise`
    in your components. In non-RSCs, that would not be considered a valid component
    function return value. When working with RSCs, both things are allowed and possible,
    though.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在不支持RSCs的项目中，由于所有代码都在浏览器中运行，因此无法使用服务器端API。同样，也不允许在组件中返回`Promise`。在非RSCs中，这不会被视为有效的组件函数返回值。尽管如此，当与RSCs一起工作时，这两者都是允许且可能的。
- en: As mentioned in the *Making Sense of RSCs* section, using server-side functionalities
    (like Node.js APIs) is something that’s unlocked because the `InfoPage` component,
    like all components in Next.js projects, is an RSC. For RSCs, React also supports
    the usage of `async/await` .
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*理解RSCs*部分所述，使用服务器端功能（如Node.js API）是因为`InfoPage`组件，就像Next.js项目中的所有组件一样，是一个RSC。对于RSCs，React也支持使用`async/await`。
- en: Consequently, as expected, you won’t find the code of the `InfoPage` component
    in the client-side JavaScript code bundles. You can verify this by visiting the
    `/info` page. If you open the **Network** tab in the browser developer tools,
    and you then reload the page, you’ll see all the HTTP requests sent to the server.
    This includes all requests for JavaScript code files that are needed on the client
    side of this React app.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如预期的那样，您在客户端JavaScript代码包中找不到`InfoPage`组件的代码。您可以通过访问`/info`页面来验证这一点。如果您在浏览器开发者工具中打开**网络**选项卡，然后重新加载页面，您将看到发送到服务器的所有HTTP请求。这包括所有在React应用的客户端需要的JavaScript代码文件的请求。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_16_03.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](img/B31339_16_03.png)'
- en: 'Figure 16.3: When visiting /info, requests for CSS, JS, and some other files
    are sent to the server'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：访问/info时，会向服务器发送对CSS、JS和一些其他文件的请求
- en: If you then go through all the JavaScript files requested and search for `rsc-info.json`
    in the downloaded code files, you won’t have any matches in any file. This proves
    that this code, which is part of the `InfoPage` component function, does not end
    up in any client-side code bundle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您浏览所有请求的JavaScript文件并搜索下载的代码文件中的`rsc-info.json`，您在任何文件中都不会找到匹配项。这证明了这部分代码，它是`InfoPage`组件函数的一部分，并没有出现在任何客户端代码包中。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_16_04.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](img/B31339_16_04.png)'
- en: 'Figure 16.4: The data source filename that’s included in the RSC code can’t
    be found on the client side'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：RSC代码中包含的数据源文件名在客户端找不到
- en: How does the content fetched from the `rsc-info.json` file show up on the screen
    then?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，从`rsc-info.json`文件获取的内容是如何显示在屏幕上的呢？
- en: This gets answered if you use a different browser than Chrome or Edge. This
    is required since there is a bug with the **Network** tab in the developer tools
    of Chrome/Edge that leads to the response of a request being hidden under certain
    circumstances.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用不同于Chrome或Edge的浏览器，这个问题就会得到解答。这是必需的，因为Chrome/Edge的开发者工具中的**网络**选项卡存在一个bug，在某些情况下会导致请求的响应被隐藏。
- en: Instead, you can, for example, use Firefox, to visit the root page ( `/` ).
    There, click the link that’s visible on the page to navigate to the `/info` page.
    As you do so, one new HTTP request will be sent. If you inspect that request and
    its response (in Firefox’s browser developer tools), you’ll see the serialized
    RSC instructions that are returned by the server.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，例如，您可以使用Firefox访问根页面（`/`）。在那里，点击页面上的链接导航到`/info`页面。在此过程中，将发送一个新的HTTP请求。如果您检查该请求及其响应（在Firefox的浏览器开发者工具中），您将看到服务器返回的序列化RSC指令。
- en: '![img](img/B31339_16_05.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_16_05.png)'
- en: 'Figure 16.5: Serialized instructions for client-side React are received from
    the server'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：客户端React的序列化指令从服务器接收
- en: As you can see, it’s not HTML content that’s received as a response. Instead,
    it’s a bunch of serialized instructions that are translated to DOM elements by
    React on the client side (i.e., in the browser).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，接收到的响应不是HTML内容。相反，是一系列序列化指令，由React在客户端（即在浏览器中）转换为DOM元素。
- en: Therefore, as you can tell, building and using RSCs is simple, but preparing
    the project to handle them is not. Instead, you need a build process that separates
    client and server code, and API endpoints that invoke server component functions
    on the server. You also need client-side code that sends requests to those API
    endpoints whenever the server components should be rendered.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如您所了解的，构建和使用RSC很简单，但准备项目来处理它们则不是。相反，您需要一个将客户端和服务器代码分离的构建过程，以及调用服务器组件函数的服务器端API端点。您还需要客户端代码，当服务器组件应该被渲染时，它会向这些API端点发送请求。
- en: RSCs and Server Actions Can’t Be Used in All Projects
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RSC和服务器操作不能在所有项目中使用
- en: Thus far in this book, whenever some new React feature was introduced, you could
    simply use it in your React project, no matter whether it was a project created
    and managed by Vite or any other tool (e.g., **create-react-app** ).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，每当介绍一个新的React特性时，您都可以简单地将其用于您的React项目，无论该项目是由Vite创建和管理，还是由其他工具（例如**create-react-app**）创建。
- en: With RSCs and Server Actions, this changes. Due to the many things that must
    be done behind the scenes (see the previous section), even though these are features
    provided by React, you can’t just start using them in any React project. Instead,
    to unlock these features, you must have a project that’s configured to support
    them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RSCs（React Server Components）和服务器操作，情况就不同了。由于幕后有许多必须完成的事情（参见上一节），尽管这些是React提供的功能，但你不能直接在任何React项目中使用它们。相反，为了解锁这些功能，你必须有一个配置了支持这些功能的项目的。
- en: As a result, at the point of time where this book is written, RSCs and Server
    Actions can really only be used with the help of frameworks that integrate and
    actively support these features—for example, the Next.js framework.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本书撰写之时，RSCs和服务器操作实际上只能借助集成并积极支持这些功能的框架来使用——例如，Next.js框架。
- en: Of course, it is technically possible to set up a project that supports both
    features on your own, but it requires advanced knowledge regarding backend development
    and build workflow configuration. Consequently, most React projects that need
    these features rely on frameworks like Next.js. Since the way you work with RSCs
    and Server Actions will always be the same, no matter in which kind of project
    you use them, this book will therefore ignore the custom setup part and instead
    focus on how to use these two core concepts.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，从技术上讲，你可以自己设置一个支持这两个功能的项目，但这需要关于后端开发和构建工作流程配置的高级知识。因此，大多数需要这些功能的React项目都依赖于像Next.js这样的框架。由于无论在哪种项目中使用RSCs和服务器操作，使用方式总是相同的，因此本书将忽略自定义设置部分，而是专注于如何使用这两个核心概念。
- en: RSCs vs Server-side Rendering
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RSCs与服务器端渲染对比
- en: At first sight, using RSCs may look similar to SSR React components. After all,
    both concepts are about running some code outside of the browser.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，使用RSCs可能看起来与SSR（服务器端渲染）的React组件相似。毕竟，这两个概念都是关于在浏览器之外运行一些代码。
- en: But even though the concepts sound similar, they are quite different.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但尽管这些概念听起来相似，它们实际上相当不同。
- en: SSR is all about rendering a component tree to HTML when a request is received.
    It’s about creating an initial page snapshot, in the end.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SSR主要是在接收到请求时将组件树渲染成HTML。它最终是创建一个初始页面快照。
- en: In addition, when building an interactive web application, a vital part of SSR
    is that the pre-rendered HTML snapshot gets hydrated on the client side—as explained
    in the previous chapter (see the *Making Sense of Server-side Rendering (SSR)*
    section and *Figure 15.3* ).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在构建交互式Web应用时，SSR的一个关键部分是预渲染的HTML快照在客户端被激活——如前一章所述（参见“理解服务器端渲染（SSR）”部分和“图15.3”）。
- en: As a result, when using SSR, the entire component tree with all its component
    functions is evaluated on the server side as well as on the client side. There
    is no split between server-side and client-side code—it’s the same app and the
    same component tree on both sides. For that reason, you also can’t have any server-exclusive
    code in your React components.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用SSR时，整个组件树及其所有组件函数在服务器端以及客户端都会被评估。服务器端和客户端代码之间没有分割——它是在两边都是同一个应用和同一个组件树。因此，你也不能在React组件中有任何仅服务器端的代码。
- en: With RSCs, that changes. The code of their component functions, as explained
    in the previous sections, never ends up on the client side.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RSCs时，情况就不同了。它们组件函数的代码，如前几节所述，永远不会出现在客户端。
- en: '![A diagram of a software application  Description automatically generated](img/B31339_16_06.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![软件应用程序的示意图  自动生成的描述](img/B31339_16_06.png)'
- en: 'Figure 16.6: RSCs are not hydrated; instead, their output is requested via
    HTTP requests'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：RSCs不会被激活；相反，它们的输出是通过HTTP请求请求的
- en: That’s why an SSR-enabled project doesn’t automatically support RSCs. On the
    other hand, you could set up a project that supports RSCs but also uses SSR for
    some components—components that should be pre-rendered on the server but that
    are also needed on the client side (e.g., because they add interactivity to the
    page). These types of components will be explored in the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么启用了SSR的项目并不自动支持RSCs。另一方面，你可以设置一个支持RSCs但同时也为某些组件使用SSR的项目——这些组件应该在服务器上预渲染，但同时也需要在客户端上使用（例如，因为它们增加了页面的交互性）。这些类型的组件将在下一节中探讨。
- en: It’s also worth noting that RSCs, like server-side rendered components in SSR
    projects, only execute once per request. However, RSCs, unlike “normal” components
    rendered via SSR, can be executed on-demand while the app is running. They’re
    not limited to being called to create an initial page snapshot.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，RSCs，就像SSR（服务器端渲染）项目中的服务器端渲染组件一样，每个请求只执行一次。然而，与通过SSR渲染的“正常”组件不同，RSCs可以在应用程序运行时按需执行。它们不仅限于被调用以创建初始页面快照。
- en: 'There is an important question, though: how can you add interactivity, and,
    for example, handle user input, in React apps where all components are rendered
    on the server? User interaction takes place in the browser, after all.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有一个重要的问题：在所有组件都在服务器上渲染的React应用程序中，你如何添加交互性，例如处理用户输入？毕竟，用户交互是在浏览器中发生的。
- en: RSCs vs Client Components
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RSCs与客户端组件
- en: 'RSCs provide some convincing advantages (see the *Making Sense of RSCs* section),
    but they also introduce one potentially big problem: if all the component code
    “lives” and executes on the server, there’s no room for client-side interactivity.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: RSCs（React Server Components）提供了一些令人信服的优势（参见*理解RSCs*部分），但它们也引入了一个可能的大问题：如果所有组件代码都“生活”并在服务器上执行，那么就没有空间进行客户端交互。
- en: Not All Components Should Be RSCs
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并非所有组件都应该是RSCs
- en: 'If you have a component that needs to manage some state (e.g., some shopping
    cart that should only be shown upon user interaction), that state and the UI must
    be managed and updated by client-side React. Because that was (and is) one of
    the main selling points of React: you can use it to build highly reactive and
    interactive UIs. But this goal clearly clashes with the idea of RSCs, where no
    component code makes it to the browser, and where components are only rendered
    once per request.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个需要管理某些状态（例如，仅在用户交互时显示的购物车）的组件，那么该状态和UI必须由客户端React进行管理和更新。因为那（以及现在）是React的主要卖点之一：你可以用它来构建高度反应性和交互式的UI。但这个目标显然与RSCs的理念相冲突，在RSCs中，没有组件代码到达浏览器，并且组件在每个请求中只渲染一次。
- en: That’s why React allows you to define so-called **server-client boundaries**
    by adding the `'use client'` directive at the top of files that contain component
    functions that should run on the client side.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，React 允许你通过在包含应在客户端运行的组件函数的文件顶部添加 `'use client'` 指令来定义所谓的**服务器-客户端边界**。
- en: '![img](img/B31339_16_07.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_16_07.png)'
- en: 'Figure 16.7: The ‘use client’ directive creates a boundary between server-side
    and client-side code'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：`'use client'` 指令在服务器端和客户端代码之间创建了一个边界
- en: You already encountered `'use client'` in the previous chapter, in the *Highlighting
    Active Links & Using the ‘use client’ Directive* section. Back then, this directive
    didn’t make a lot of sense. Now, with your newly gained knowledge about RSCs,
    the purpose behind this directive will become clearer.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在上一章的*突出显示活动链接和使用`'use client'`指令*部分遇到了 `'use client'`。当时，这个指令并没有太多意义。现在，随着你对RSCs的新认识，这个指令背后的目的将变得更加清晰。
- en: 'With `''use client''` added to a component file, the components defined in
    that file become client components. Client components are also pre-rendered on
    the server, but their code executes on the client side, too. They are hydrated,
    as explained in the previous chapter. Thus, unlike the code of server components,
    the code of client components makes it to the client side:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件文件中添加 `'use client'` 后，该文件中定义的组件将成为客户端组件。客户端组件在服务器上也会预先渲染，但它们的代码也会在客户端上执行。正如前一章所述，它们会被激活。因此，与服务器组件的代码不同，客户端组件的代码会到达客户端：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the `Cart` component is a client component because `'use client'`
    is added at the top of the file. This is required because the `Cart` component
    uses the `useState()` Hook, which only works in the browser.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Cart` 组件是一个客户端组件，因为文件顶部添加了 `'use client'`。这是必需的，因为 `Cart` 组件使用了 `useState()`
    钩子，它只能在浏览器中工作。
- en: Whenever you add the `'use client'` directive to a component file, the component
    functions in that file will be included in the client-side code bundle. Thus,
    the component functions can (and will) be executed in the browser—therefore you
    can use features that rely on running there, like `useState()` or code that should
    run upon user input (e.g., if a `<button>` was pressed).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你向组件文件添加 `'use client'` 指令时，该文件中的组件函数将被包含在客户端代码包中。因此，组件函数可以在浏览器中（并且将会）执行——因此你可以使用依赖于在该处运行的功能，如
    `useState()` 或在用户输入时运行的代码（例如，如果按下了 `<button>`）。
- en: That’s also why Next.js shows an error if you try to use a Hook in a component
    that’s not marked as a client component via `'use client'` .
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么Next.js会在你尝试在一个未通过`'use client'`标记为客户端组件的组件中使用Hook时显示错误。
- en: '![img](img/B31339_16_08.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_16_08.png)'
- en: 'Figure 16.8: Next.js complains about the usage of the useState() Hook in an
    RSC'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：Next.js对在RSC中使用useState() Hook表示不满
- en: 'This error occurs because you’re trying to build something impossible: a component
    that’s only evaluated on the server but that also reacts to user input and updates
    some state. Since the latter, as you learned in *Chapter 4* , *Working with Events
    and State* , will typically result in a UI update, the code needs to execute on
    the client side—something that’s clearly in conflict with the goal of running
    the component code only on the server.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误发生是因为你试图构建一个不可能的东西：一个只在服务器上评估但也能响应用户输入并更新一些状态的组件。由于后者，正如你在*第4章*，*与事件和状态一起工作*中学到的，通常会导致UI更新，代码需要在客户端执行——这显然与只在服务器上运行组件代码的目标相冲突。
- en: Thus, `'use client'` must be added whenever you have a component that needs
    to run in the browser.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当你有需要在浏览器中运行的组件时，都必须添加`'use client'`。
- en: '**Note**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Of course, you will not need to add the `'use client'` directive in projects
    that don’t implement RSCs. That’s why you didn’t see it in any other React project
    in earlier chapters.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在未实现RSC的项目中，你不需要添加`'use client'`指令。这就是为什么在早期章节中你未在其他任何React项目中看到它。
- en: ‘use client’ Affects Child Components, Too!
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ‘use client’也会影响子组件！
- en: 'Using the `''use client''` directive in a component file has one very important
    implication: all nested components become client components, too—even if you don’t
    use `''use client''` in their component files.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件文件中使用`'use client'`指令有一个非常重要的含义：所有嵌套组件也会变成客户端组件——即使你不在它们的组件文件中使用`'use client'`。
- en: This is technically necessary since the JSX code of client components is re-evaluated,
    and all custom components used there are re-executed, every time the client component
    function is called again (e.g., because of some state change)—that’s something
    you learned in *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    .
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这在技术上是有必要的，因为客户端组件的JSX代码在每次客户端组件函数再次调用时（例如，由于某些状态变化）都会重新评估，并且那里使用的所有自定义组件都会重新执行——这是你在*第10章*，*React幕后和优化机会*中学到的。
- en: As a result, all the components nested inside a client component must be client
    components themselves since their code would otherwise not be available on the
    client side.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，所有嵌套在客户端组件内部的组件都必须是客户端组件，因为否则它们的代码在客户端不可用。
- en: '![A diagram of a product  Description automatically generated](img/B31339_16_09.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![一个产品图的示意图，描述自动生成](img/B31339_16_09.png)'
- en: 'Figure 16.9: Child components of client components become client components,
    too'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：客户端组件的子组件也变成了客户端组件
- en: 'To keep the client code bundle small and performant, it’s typically a good
    idea to maximize the number of server components and thus minimize the number
    of client components. Since nested components of client components become client
    components automatically, you should therefore try to move the server-client boundary
    (i.e., the usage of `''use client''` ) as far down the component tree as possible.
    Ideally, only the leaves of your component tree use React Hooks or handle user
    input. Put in other words: only use `''use client''` when you must and try to
    affect as few components with it as possible.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持客户端代码包小而高效，通常最好最大化服务器组件的数量，从而最小化客户端组件的数量。由于客户端组件的嵌套组件会自动成为客户端组件，因此你应该尽量将服务器-客户端边界（即`'use
    client'`的使用）尽可能向下移动到组件树中。理想情况下，只有你的组件树的叶子使用React Hooks或处理用户输入。换句话说：只有在你必须的时候才使用`'use
    client'`，并尽量减少它影响组件的数量。
- en: '![A diagram of a product  Description automatically generated](img/B31339_16_10.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![一个产品图的示意图，描述自动生成](img/B31339_16_10.png)'
- en: 'Figure 16.10: The majority of components are RSCs'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：大多数组件都是RSC
- en: '*Figure 16.10* shows an example component tree where only a small subset of
    all components are client components.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.10*显示了一个示例组件树，其中只有所有组件的一小部分是客户端组件。'
- en: 'The question therefore is this: how can you combine and optimize the usage
    of server and client components in React projects that support RSCs?'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此问题是这样的：如何在支持RSC的React项目中结合和优化服务器和客户端组件的使用？
- en: Combining RSCs and Client Components
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合RSC和客户端组件
- en: Typically, you’ll end up with React projects where most components don’t need
    to be client components (therefore, they should be RSCs), but where some component
    functions do need to run in the browser (i.e., they do need `'use client'` ).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你最终会得到大多数组件不需要是客户端组件的React项目（因此，它们应该是RSCs），但有些组件函数需要在浏览器中运行（即，它们确实需要 `'use
    client'`）。
- en: You can think of `'use client'` marking the point in the component tree where
    the component type switches from server to client component (see *Figure 16.9*
    and *Figure 16.10* ).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `'use client'` 标记视为组件树中组件类型从服务器组件切换到客户端组件的点（参见 *图16.9* 和 *图16.10*）。
- en: 'For that reason, React allows you to combine both kinds of components in the
    same project, though, you need to follow a couple of important rules:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，React 允许你在同一个项目中结合这两种组件，尽管你需要遵循一些重要的规则：
- en: Server components may import and render client components (i.e., output a client
    component in their JSX code).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器组件可以导入并渲染客户端组件（即在它们的JSX代码中输出客户端组件）。
- en: Client components must not directly import and render server components that
    rely on server-side features.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端组件不得直接导入并渲染依赖于服务器功能的服务器组件。
- en: Client components may implicitly render server components via props (e.g., via
    the `children` prop).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端组件可以通过props隐式渲染服务器组件（例如，通过 `children` prop）。
- en: To make these rules a bit less abstract, each case will be shown with a concrete
    example.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些规则更加具体，每个情况都将通过一个具体的例子来展示。
- en: Outputting Client Components in Server Components
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在服务器组件中输出客户端组件
- en: You can use client components in the JSX code of server components without issues.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在服务器组件的JSX代码中使用客户端组件而不会出现问题。
- en: 'Consider the following example `UserTodos` component, which allows users to
    manage an array of to-dos that’s stored locally via `localStorage` :'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 `UserTodos` 组件的例子，它允许用户通过 `localStorage` 本地存储管理一系列待办事项：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since `localStorage` (a browser API), refs, state ( `todos` via `useState()`
    ), and event listeners ( `submit` via `onSubmit` ) are used, this must be a client
    component. That’s why `'use client'` is added at the top of the file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了 `localStorage`（一个浏览器API）、refs、状态（通过 `useState()` 的 `todos`）和事件监听器（通过 `onSubmit`
    的 `submit`），这必须是一个客户端组件。这就是为什么在文件顶部添加了 `'use client'` 的原因。
- en: 'However, this component can be used in a server component without issues:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个组件可以在服务器组件中使用而不会出现问题：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That’s possible because client components can also be rendered on the server—they’re
    just not exclusive to that environment (unlike RSCs, which are). Put in other
    words: client components are rendered on the server like all components were in
    SSR projects that do not support RSCs (e.g., the Vite-based SSR-enabled project
    from the previous section). An initial snapshot is rendered upon the first request,
    thereafter client-side React takes over and hydrates the component.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为客户端组件也可以在服务器上渲染——它们只是不是专属于那个环境（与RSCs不同，RSCs是）。换句话说：客户端组件在服务器上的渲染方式与所有组件在不支持RSCs的SSR项目中一样（例如，前一个章节中的基于Vite的SSR启用项目）。在第一次请求时渲染一个初始快照，之后客户端React接管并使组件活动化。
- en: '**Note**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In the preceding example, data is loaded from `localStorage` via `useEffect()`
    . This is done to ensure that the code runs on the server. Since `localStorage`
    is not available there, accessing it without wrapping with `useEffect()` would
    cause an error.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，数据是通过 `useEffect()` 从 `localStorage` 加载的。这样做是为了确保代码在服务器上运行。由于 `localStorage`
    在那里不可用，如果不使用 `useEffect()` 包装访问它，将会导致错误。
- en: Since `useEffect()` is ignored on the server, it’s a safe way of using browser-exclusive
    APIs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `useEffect()` 在服务器上被忽略，这是一种安全地使用浏览器专用API的方法。
- en: Outputting Server Components in Client Components
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在客户端组件中输出服务器组件
- en: As already mentioned in the *‘use client’ Affects Child Components, Too!* section,
    you can’t import server components into client components and render them there.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在 *“use client” 也会影响子组件* 部分所述，你不能将服务器组件导入客户端组件并在那里渲染它们。
- en: 'Though, in many situations, you’ll not get an error. For example, you might
    have a client-side `Cart` component defined like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在许多情况下，你不会得到错误。例如，你可能有一个如下定义的客户端 `Cart` 组件：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Unlike `Cart` , the `CartItem` component function might be a server component
    (i.e., it’s not marked via `''use client''` ):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Cart` 不同，`CartItem` 组件函数可能是一个服务器组件（即，它没有通过 `'use client'` 标记）：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code works because the component that used to be a server component ( `CartItem`
    ) simply becomes a client component once it is imported and used in a client component
    file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码之所以能正常工作，是因为之前作为服务器组件（`CartItem`）的组件，一旦被导入并用于客户端组件文件中，就简单地变成了客户端组件。
- en: You will, however, face an error message if you’re trying to import and use
    a server component that uses server component-specific features, like a Node.js
    API or `async/await` .
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试导入并使用一个使用服务器组件特定功能（如 Node.js API 或 `async/await`）的服务器组件，你将会遇到错误信息。
- en: 'For example, the following adjusted `DynamicCartItem` component tries to use
    Node’s `fs` package to load a cart item from a file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下调整后的 `DynamicCartItem` 组件试图使用 Node 的 `fs` 包从文件中加载购物车项：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Importing and using this component in the `Cart` component will cause an error.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cart` 组件中导入和使用此组件将导致错误。
- en: Trying to run this code will lead to an error message being shown on the screen
    because React fails to automatically convert `CartItem` to a client component
    (due to the usage of RSC-exclusive features). Therefore, it’ll complain about
    some server-side code (e.g., some Node.js API) you’re trying to use on the client
    side.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行此代码会导致屏幕上显示错误信息，因为 React 无法自动将 `CartItem` 转换为客户端组件（由于使用了 RSC 独有的功能）。因此，它会抱怨你在客户端侧尝试使用的某些服务器端代码（例如某些
    Node.js API）。
- en: '![img](img/B31339_16_11.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_16_11.png)'
- en: 'Figure 16.11: React complains about the usage of a Node.js API in the browser'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.11：React 对在浏览器中使用 Node.js API 的使用表示不满
- en: Hence, in situations like this, you’ll need to restructure your application
    to end up with a valid component combination again. For example, by passing server
    components as props to client components, instead of directly importing and rendering
    them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，你需要重新构建你的应用程序，以便再次得到有效的组件组合。例如，通过将服务器组件作为 prop 传递给客户端组件，而不是直接导入和渲染它们。
- en: Rendering Server Components via Props
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过 Props 渲染服务器组件
- en: You can’t import and use server components that perform some server-side exclusive
    operation (like using Node.js APIs) in client components.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在客户端组件中导入和使用执行某些服务器端专用操作（如使用 Node.js API）的服务器组件。
- en: 'But you can change your client component code to not directly import and use
    the server component. Instead, you can expect to get a server component as a prop—for
    example, via the special `children` prop about which you learned in *Chapter 3*
    , *Components and Props* :'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以修改你的客户端组件代码，使其不直接导入和使用服务器组件。相反，你可以期待从服务器组件作为 prop 获取——例如，通过你在 *第 3 章* 中学到的特殊
    `children` prop：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This adjusted `Cart` component is still a client component. However, since it
    no longer directly imports and renders the `DynamicCartItem` server component,
    React is happy.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调整后的 `Cart` 组件仍然是一个客户端组件。然而，由于它不再直接导入和渲染 `DynamicCartItem` 服务器组件，React 才会满意。
- en: 'Instead, the `DynamicCartItem` component is now imported and output in the
    `Home` component like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`DynamicCartItem` 组件现在是这样导入并在 `Home` 组件中输出的：
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `DynamicCartItem` elements are passed as a value for the `children` prop
    to the `Cart` component.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`DynamicCartItem` 元素作为 `children` prop 的值传递给 `Cart` 组件。'
- en: This might be unintuitive at first but it’s vital to understand that this works
    because the `DynamicCartItem` components are now rendered as part of another server
    component—the `Home` component. It’s the result of that rendering process that’s
    then passed as a value to the `Cart` component. That component therefore does
    not include the `DynamicCartItem` component in its part of the component tree.
    Instead, both `Cart` and `DynamicCartItem` are direct children of the `Home` component.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始看起来不太直观，但理解这一点至关重要，这是因为 `DynamicCartItem` 组件现在作为另一个服务器组件（`Home` 组件）的一部分被渲染。这是渲染过程的结果，然后作为值传递给
    `Cart` 组件。因此，该组件在其组件树的部分中不包括 `DynamicCartItem` 组件。相反，`Cart` 和 `DynamicCartItem`
    都是 `Home` 组件的直接子组件。
- en: 'The overall application component tree would look like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序组件树看起来会是这样：
- en: '![img](img/B31339_16_12.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_16_12.png)'
- en: 'Figure 16.12: DynamicCartItem and Cart are both direct child components of
    the Home component'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.12：`DynamicCartItem` 和 `Cart` 都是 `Home` 组件的直接子组件
- en: Even though, in the finished UI, it might look as if the `DynamicCartItem` is
    a child of `Cart` , technically, it’s not.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在完成后的 UI 中，`DynamicCartItem` 可能看起来像是 `Cart` 的子组件，但从技术上讲，它并不是。
- en: It’s key to understand that wrapping a component with another component ( `<Cart><DynamicCartItem
    /></Cart>` ) leads to a different component tree structure than rendering a component
    inside another component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点很重要：将一个组件包裹在另一个组件中（`<Cart><DynamicCartItem /></Cart>`）会导致与在另一个组件内部渲染组件不同的组件树结构。
- en: This is therefore a pattern that can be useful in situations where you might
    need to include a server component in a client component.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个在可能需要将服务器组件包含在客户端组件中的情况下有用的模式。
- en: Overall, you are able to combine RSCs and client components as needed. Furthermore,
    Next.js also provides some additional features that can help with RSCs and data
    fetching via RSCs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，你可以根据需要组合 RSCs 和客户端组件。此外，Next.js 还提供了一些额外的功能，可以帮助处理 RSCs 和通过 RSCs 的数据获取。
- en: Advanced Data Fetching with Next.js
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Next.js 进行高级数据获取
- en: As mentioned before, in the *Making Sense of RSCs* section, data fetching via
    RSCs offers various advantages compared to data fetching in client components.
    You don’t have to use `useEffect()` to send HTTP requests to separate backend
    APIs, you can directly reach out to a database, you can use `async/await` , and
    so on. Therefore, it’s absolutely recommended to fetch data via RSCs whenever
    possible.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在 *理解 RSCs* 部分中，通过 RSCs 进行数据获取与在客户端组件中进行数据获取相比提供了各种优势。你不必使用 `useEffect()`
    向单独的后端 API 发送 HTTP 请求，你可以直接访问数据库，可以使用 `async/await` 等。因此，在可能的情况下，绝对建议通过 RSCs 获取数据。
- en: When working with Next.js, RSC-based data fetching becomes even easier because
    Next.js helps with showing fallback content while you’re waiting for data to arrive.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Next.js 时，基于 RSC 的数据获取变得更加容易，因为 Next.js 帮助在等待数据到达时显示回退内容。
- en: Managing Loading States with Next.js
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Next.js 管理加载状态
- en: When working with Next.js (with the App Router), you can define `loading.js`
    files inside the `app/` folder to set up components that will be rendered while
    sibling or nested server components are loading data. Next.js determines whether
    a component is loading data or not by checking whether it returns a `Promise`
    that hasn’t resolved yet.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Next.js（带有 App Router）时，你可以在 `app/` 文件夹内定义 `loading.js` 文件来设置在兄弟或嵌套服务器组件加载数据时将被渲染的组件。Next.js
    通过检查组件是否返回一个尚未解决的 `Promise` 来确定组件是否正在加载数据。
- en: '**Note**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The next chapter will dive even deeper into handling loading states and showing
    fallback content. It will explore React’s Suspense feature, which allows for granular
    loading state management as data streams in.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将更深入地探讨处理加载状态和显示回退内容。它将探索 React 的 Suspense 功能，该功能允许在数据流进时进行细粒度的加载状态管理。
- en: 'Consider this example `GoalsPage` component, which fetches data from a file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个 `GoalsPage` 组件的例子，它从文件中获取数据：
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The function ( `fetchGoals()` ) that performs the actual data fetching has a
    delay built-in to simulate a slow database or network connection.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 执行实际数据获取的功能（`fetchGoals()`）内置了延迟来模拟缓慢的数据库或网络连接。
- en: Without a `loading.js` file added to the project, the user will stare at a blank
    or outdated page for a couple of seconds before the requested page is rendered.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目中没有添加 `loading.js` 文件，用户将在请求的页面渲染之前盯着一个空白或过时的页面几秒钟。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_16_13.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B31339_16_13.png)'
- en: 'Figure 16.13: After clicking the link, it takes three seconds for the new page
    to load'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.13：点击链接后，新页面需要三秒钟才能加载
- en: This behavior occurs because the new page is not ready yet and can’t be rendered
    since it’s still fetching data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为发生是因为新页面尚未准备好，无法渲染，因为它仍在获取数据。
- en: To improve the user experience, a `loading.js` file can be added next to the
    slow `app/goals/page.js` file (or, if necessary, in some parent folder, since
    `loading.js` will also display its content for child routes).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高用户体验，可以在缓慢的 `app/goals/page.js` 文件旁边添加一个 `loading.js` 文件（如果需要，也可以在某个父文件夹中，因为
    `loading.js` 也会为子路由显示其内容）。
- en: 'Inside the newly created `app/goals/loading.js` file, a regular React component
    is created. Like all components in Next.js projects, this is an RSC by default:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的 `app/goals/loading.js` 文件中，创建了一个常规的 React 组件。像 Next.js 项目中的所有组件一样，这是一个默认的
    RSC：
- en: '[PRE15]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The component name ( `LoadingGoals` ) does not matter. But this component now
    ensures that the `Loading user goals, please wait…` fallback text is shown on
    the screen while the user waits for the `GoalsPage` to load and render.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 组件名称（`LoadingGoals`）并不重要。但这个组件现在确保在用户等待`GoalsPage`加载和渲染时，屏幕上显示`Loading user
    goals, please wait…`的回退文本。
- en: '![img](img/B31339_16_14.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_16_14.png)'
- en: 'Figure 16.14: The loading fallback content is shown while the page is transitioning'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14：在页面过渡期间显示加载回退内容
- en: Of course, you can show any fallback content of your choice—it doesn’t have
    to be some simple text as in this example.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以显示任何你选择的回退内容——它不必像这个例子中那样只是简单的文本。
- en: Therefore, when working with Next.js, adding `loading.js` files to define fallback
    components can tremendously improve the experience of your website users.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用Next.js时，添加`loading.js`文件来定义回退组件可以极大地提高网站用户的体验。
- en: Besides fetching data, many React apps also need to change data at some point.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了获取数据外，许多React应用程序在某个时候也需要修改数据。
- en: From Data Fetching to Data Mutations
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据获取到数据修改
- en: At this point, you have learned a lot about RSCs, client components, and how
    they can (and cannot) work together. In the *Making Sense of RSCs* section, you
    also learned about some advantages offered by RSCs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学到了很多关于RSCs、客户端组件以及它们如何（以及如何不能）一起工作的知识。在*理解RSCs*部分，你还了解了一些RSCs提供的优势。
- en: Of course, you also might want to change data, though—not just load and display
    it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可能想修改数据，而不仅仅是加载和显示它。
- en: Handling Data Mutations with Server Actions
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用服务器操作处理数据修改
- en: React does not just provide support for RSCs; it also allows you to add so-called
    **Server Actions** to your applications.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: React不仅提供对RSCs的支持；它还允许你向应用程序添加所谓的**服务器操作**。
- en: Server Actions build up on the same idea as client (form) actions, which were
    introduced and explained in *Chapter 9* , *Handling User Input & Forms with Form
    Actions* . However, Server Actions, as their name implies, will execute on the
    server side, not on the client side.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器操作建立在客户端（表单）操作相同的概念之上，这些操作在*第9章*，*使用表单操作处理用户输入和表单*中介绍并解释了。然而，正如其名称所暗示的，服务器操作将在服务器端执行，而不是在客户端。
- en: Hence, you can use Server Actions to retrieve submitted user input on the server
    and process it there. For example, you could store the submitted data in a file
    or database.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用服务器操作在服务器上检索提交的用户输入并对其进行处理。例如，你可以将提交的数据存储在文件或数据库中。
- en: Consequently, Server Actions are an important building block when aiming to
    build fully integrated fullstack React applications. Typically, data fetching
    alone is not enough, which is why the Server Actions feature exists. By having
    both, RSCs and Server Actions, you’re able to fetch and mutate data on the server,
    while still enabling interactive client-side user experiences where needed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当目标是为构建完全集成的全栈React应用程序时，服务器操作是一个重要的构建块。通常，仅数据获取是不够的，这就是为什么存在服务器操作功能。通过同时拥有RSCs和服务器操作，你能够在服务器上获取和修改数据，同时在需要时仍然启用交互式的客户端用户体验。
- en: Unlocking Server Actions in React Projects
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在React项目中解锁服务器操作
- en: 'Like RSCs, you can’t use Server Actions in all React projects. Instead, a special
    project setup is required to use this feature. For example, Next.js projects support
    Server Actions out of the box (when using the App Router). Just as with RSCs,
    you can think of Next.js doing the following things:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与RSCs一样，你无法在所有React项目中使用服务器操作。相反，需要特殊的项目设置才能使用此功能。例如，Next.js项目支持服务器操作（当使用App
    Router时）。就像RSCs一样，你可以认为Next.js做以下事情：
- en: The build workflow and bundling process separate the code that belongs to Server
    Actions so that it doesn’t end up in the client-side bundle.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工作流程和捆绑过程将属于服务器操作的代码分离出来，以便它不会最终出现在客户端捆绑中。
- en: Next.js sets up API endpoints that trigger the Server Action functions and respond
    with any return values defined in those functions.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js设置API端点，触发服务器操作函数，并返回这些函数中定义的任何返回值。
- en: Next.js calls these endpoints when needed (e.g., when submitting a form that’s
    connected to a Server Action—as shown in the next section).
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要时（例如，提交与服务器操作连接的表单时——如下一节所示），Next.js会调用这些端点。
- en: Therefore, Server Actions, like RSCs, can be tricky to support in custom projects
    that do not use Next.js. It’s absolutely possible to create custom projects that
    provide support for both Server Actions and RSCs, but it’s not trivial.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于不使用Next.js的自定义项目来说，服务器操作（如RSCs）可能难以支持。虽然完全有可能创建既支持服务器操作也支持RSCs的自定义项目，但这并非易事。
- en: Thankfully, using Server Actions (in projects that support them) is not complicated,
    though.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在使用服务器操作（在支持它们的项目中）时并不复杂。
- en: Defining and Triggering Server Actions
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和触发服务器操作
- en: As mentioned in the *Handling Data Mutations with Server Actions* section, Server
    Actions are very similar to the client form actions you already know from *Chapter
    9* .
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*处理数据突变与服务器操作*章节中提到的，服务器操作与你在*第9章*中已经了解的客户表单操作非常相似。
- en: 'But there are two key differences that must be considered when creating a Server
    Action:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但在创建服务器操作时，有两个关键差异必须考虑：
- en: A Server Action function must be asynchronous— (i.e., it must use `async/await`
    ). There are no synchronous Server Actions.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器操作函数必须是异步的——（即，它必须使用`async/await`）。没有同步的服务器操作。
- en: Inside the Server Action function, at the very beginning of the function body,
    you must add the `'use server'` directive.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器操作函数中，在函数体开始时，你必须添加`'use server'`指令。
- en: 'A valid Server Action can therefore be defined and used in a component like
    this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个有效的服务器操作可以像这样定义和使用：
- en: '[PRE16]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, besides the fact that it must be asynchronous and that it uses
    the `'use server'` directive, this action function looks like the ones you saw
    in *Chapter 9* . It receives a `formData` object that will be provided by React
    when the form is submitted, and you set the `action` function as a value for the
    `action` prop on a `<form>` element.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，除了它必须是异步的并且使用`'use server'`指令之外，这个动作函数看起来与你在*第9章*中看到的类似。它接收一个`formData`对象，该对象将由React在表单提交时提供，并且你将`action`函数作为`<form>`元素上`action`属性的值设置。
- en: As mentioned in the previous section, if you were to search for this code in
    the code files downloaded by the browser, you wouldn’t find it—this code really
    only runs on the server side.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，如果你在浏览器下载的代码文件中搜索这段代码，你将找不到它——这段代码实际上只在服务器端运行。
- en: '**Note**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `UserFeedback` component from the previous example is an RSC.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例中的`UserFeedback`组件是一个RSC。
- en: If you think about it, this might be strange, though. After all, this component
    does handle some user input and interaction. Why does it work without `'use client'`
    then?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，这可能会有些奇怪。毕竟，这个组件确实处理了一些用户输入和交互。那么为什么它不需要`'use client'`就能工作呢？
- en: Because Server Actions (bound to the `<form>` 's `action` prop) are special.
    React explicitly supports this pattern inside of RSCs. `'use client'` is indeed
    required for any other kind of user input handling (e.g., if you rely on the `onSubmit`
    or `onChange` props). But binding Server Actions via the `action` prop is supported.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器操作（绑定到`<form>`的`action`属性）是特殊的。React在RSCs内部明确支持这种模式。`'use client'`确实对于任何其他类型的用户输入处理（例如，如果你依赖于`onSubmit`或`onChange`属性）都是必需的。但是，通过`action`属性绑定服务器操作是支持的。
- en: Furthermore, it’s important to understand that the `'use server'` directive
    only exists to mark actions as Server Actions. You, for example, can’t use it
    to mark components as server components.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要理解`'use server'`指令仅用于标记操作为服务器操作。例如，你不能用它来标记组件为服务器组件。
- en: Of course, the preceding example Server Action currently only logs the input
    to the console. A more realistic action would probably store that data somewhere
    and redirect the user to some other page.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的示例服务器操作目前仅将输入记录到控制台。更实际的操作可能会将数据存储到某个地方，并将用户重定向到其他页面。
- en: Handling User Input & Updating the UI
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理用户输入和更新UI
- en: 'Consider this updated version of the previous example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个前面示例的更新版本：
- en: '[PRE17]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `saveFeedback()` Server Action now stores the extracted feedback via the
    `storeFeedback()` function.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveFeedback()`服务器操作现在通过`storeFeedback()`函数存储提取的反馈。'
- en: 'This function is defined like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数定义如下：
- en: '[PRE18]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In a real app, data might be stored in a database. Here, in this simple example,
    it’s simply stored in a `user-feedback.json` file that’s part of the overall Next.js
    project.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，数据可能会存储在数据库中。在这个简单的例子中，它只是简单地存储在`user-feedback.json`文件中，该文件是Next.js项目的一部分。
- en: As you can tell, just as you can directly reach out to a file or database from
    inside an RSC, you are able to directly edit a file or send a database query from
    inside a Server Action.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以从图中看出，你可以在RSC内部直接访问文件或数据库，同样地，你也能在Server Action内部直接编辑文件或发送数据库查询。
- en: 'You can also update the UI by programmatically navigating the user to a different
    page thereafter. In a Next.js application, you can use the `redirect()` function
    provided by Next.js to trigger such a navigation action—for example, right after
    storing the submitted feedback text:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过编程方式在之后更新UI，将用户导航到不同的页面。在一个Next.js应用中，你可以使用Next.js提供的`redirect()`函数来触发这种导航操作——例如，在存储提交的反馈文本后：
- en: '[PRE19]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a very common pattern when building fullstack applications since you
    often want to navigate your website users to a different page once they have submitted
    data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建全栈应用时，这是一个非常常见的模式，因为你通常希望用户提交数据后导航到不同的页面。
- en: But you can also use a different pattern and update the UI that contains the
    form, based on the form submission.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也可以使用不同的模式，根据表单提交更新包含表单的UI。
- en: Server Actions and useActionState()
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Server Actions 和 useActionState()
- en: You might remember the `useActionState()` Hook from *Chapter 9* , *Handling
    User Input & Forms with Form Actions* . This Hook can be used to derive some component
    state from a (form) action. That state, in turn, can be used to update the UI
    based on the result of the action.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得*第9章*中的`useActionState()` Hook，*使用表单操作处理用户输入和表单*。这个Hook可以用来从一个（表单）操作中推导出一些组件状态。这个状态反过来可以用来根据操作的结果更新UI。
- en: Since a Server Action is a special kind of form action, you can use that same
    Hook to update the UI based on your Server Action and its returned values.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Server Action是一种特殊的表单操作，你可以使用相同的Hook根据Server Action及其返回值更新UI。
- en: 'For example, you could try using `useActionState()` in the `UserFeedback` component
    like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在`UserFeedback`组件中使用`useActionState()`，如下所示：
- en: '[PRE20]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, using this code would cause an error:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用此代码会导致错误：
- en: '![img](img/B31339_16_15.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_16_15.png)'
- en: 'Figure 16.15: React complaints about the usage of a Hook in an RSC'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15：React对在RSC中使用Hook表示抱怨
- en: It’s an error message you already know from the *Not All Components Should Be
    RSCs* section and *Figure 16.8* . React does not allow the usage of Hooks in RSCs—and
    `UserFeedback` is an RSC.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你已经从*Not All Components Should Be RSCs*部分和*图16.8*中知道的错误信息。React不允许在RSC中使用Hooks——而`UserFeedback`是一个RSC。
- en: 'The solution, of course, is straightforward: simply add the `''use client''`
    directive at the top of the `UserFeedback.js` file:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案当然是直接的：只需在`UserFeedback.js`文件的顶部添加`'use client'`指令：
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But with this change applied, you’ll encounter another error message:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但应用了这个更改后，你会遇到另一个错误信息：
- en: '![img](img/B31339_16_16.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_16_16.png)'
- en: 'Figure 16.16: React now complains about the usage of ‘use server’ and ‘use
    client’ in the same file'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16：React现在对同一文件中同时使用‘use server’和‘use client’表示抱怨
- en: This error message occurs because the `UserFeedback` component file is currently
    using both the `'use client'` and `'use server'` directives—in different places,
    but in the same file.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息发生是因为`UserFeedback`组件文件当前正在使用`'use client'`和`'use server'`指令——在不同的地方，但同一个文件中。
- en: 'Put in other words: you can only define a Server Action (and hence use `''use
    server''` ) inside an RSC—not inside a client component.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：你只能在RSC内部定义Server Action（因此使用`'use server'`），而不能在客户端组件内部。
- en: One possible solution for this problem is to move the feedback form and the
    `useActionState()` Hook into a new component that will be used as a child component
    of `UserFeedbackForm` . The Server Action function can then be passed via props
    to that newly added component.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的可能方法是将反馈表单和`useActionState()` Hook移动到一个新的组件中，该组件将作为`UserFeedbackForm`的子组件使用。然后，可以将Server
    Action函数通过props传递给这个新添加的组件。
- en: 'For example, you can create a `FeedbackForm` component that looks like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以创建一个看起来像这样的`FeedbackForm`组件：
- en: '[PRE22]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This `FeedbackForm` component expects an `action` prop, which is then passed
    as a value to `useActionState()` . Consequently, the `FeedbackForm` component
    can be used in the `UserFeedback` component like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`FeedbackForm`组件期望一个`action`属性，然后将其作为值传递给`useActionState()`。因此，`FeedbackForm`组件可以在`UserFeedback`组件中使用，如下所示：
- en: '[PRE23]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you were to run this code, the application would work without any problems.
    So, again, just as with RSCs, it’s all about coming up with a working component
    structure.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，应用程序将没有任何问题运行。所以，就像 RSCs 一样，关键在于提出一个有效的组件结构。
- en: This is an absolutely valid way of solving this problem. But if you would rather
    not split the `UserFeedback` component into multiple components and outsource
    the form into `FeedbackForm` , there is also another possible solution.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种绝对有效的解决问题的方式。但如果你不想将 `UserFeedback` 组件拆分成多个组件并将表单外包给 `FeedbackForm`，也有另一种可能的解决方案。
- en: Storing Server Actions in Separate Files
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将服务器操作存储在单独的文件中
- en: You can define Server Actions directly inside of RSCs. As you learned in the
    previous chapter, you can also pass them around via props.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在 RSCs 中定义服务器操作。正如你在上一章中学到的，你还可以通过 props 将它们传递。
- en: As an alternative, React also permits storing them in separate files. Doing
    so allows you to build leaner components since the Server Action code is moved
    out of the component functions. Furthermore, React is fine with importing a Server
    Action that’s stored in a separate file into a client component file.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，React 也允许将它们存储在单独的文件中。这样做可以让你构建更精简的组件，因为服务器操作代码被移出了组件函数。此外，React 允许将存储在单独文件中的服务器操作导入到客户端组件文件中。
- en: 'Considering the previous code examples, you could move the `saveFeedback()`
    Server Action into a separate `actions/feedback.js` file in your Next.js project
    folder—though, the file and folder names are entirely up to you. In that file,
    you can then also move the `''` `use server''` directive out of the Server Action
    and put it at the top of the file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到之前的代码示例，你可以在 Next.js 项目文件夹中将 `saveFeedback()` 服务器操作移动到单独的 `actions/feedback.js`
    文件中——尽管，文件和文件夹的名称完全由你决定。然后，你可以在该文件中将 `'use server'` 指令从服务器操作中移出，并将其放在文件顶部：
- en: '[PRE24]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Adding the `'use server'` directive at the top of the file enables you to create
    multiple Server Action functions in that same file. You can then export and use
    them in any other file they might be needed in.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部添加 `'use server'` 指令可以让你在同一文件中创建多个服务器操作函数。然后你可以将它们导出并用于可能需要的任何其他文件中。
- en: 'For example, you can import the `saveFeedback()` action into the `UserFeedback`
    component, which now doesn’t need the separate `FeedbackForm` child component
    anymore. Since externally stored Server Actions can be imported into client component
    files without issues, the final `UserFeedback.js` file looks like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将 `saveFeedback()` 操作导入到 `UserFeedback` 组件中，这样现在就不需要单独的 `FeedbackForm`
    子组件了。由于外部存储的服务器操作可以无问题地导入到客户端组件文件中，最终的 `UserFeedback.js` 文件看起来像这样：
- en: '[PRE25]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Therefore, storing Server Actions in separate files does not just lead to leaner
    components, but can also help prevent unnecessary component refactoring.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将服务器操作存储在单独的文件中不仅会导致组件更精简，还可以帮助防止不必要的组件重构。
- en: Though, no matter which approach you choose, you can use Server Actions to handle
    form submissions on the server. Together with RSCs, you can therefore build fullstack
    applications that seamlessly blend client-side and server-side code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，无论你选择哪种方法，你都可以使用服务器操作来处理服务器上的表单提交。因此，结合 RSCs，你可以构建无缝融合客户端和服务器代码的全栈应用程序。
- en: Summary and Key Takeaways
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: 'React supports two special server-side functionalities: RSCs and Server Actions.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 支持两种特殊的服务器端功能：RSCs 和服务器操作。
- en: Both features are not available in React projects unless the project is specifically
    configured to support them—typically, you’ll therefore need to use a framework
    that supports these features (e.g., Next.js).
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个功能在 React 项目中不可用，除非项目被特别配置以支持它们——通常，因此你需要使用支持这些功能的框架（例如 Next.js）。
- en: RSCs are components that are never rendered on the client side—instead, they
    may be rendered on the server (initiated via HTTP requests) or during the build
    process.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSCs 是那些永远不会在客户端渲染的组件——相反，它们可能在服务器上（通过 HTTP 请求启动）或构建过程中渲染。
- en: RSCs return rendering instructions that are picked up by client-side React.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSCs 返回客户端 React 会获取的渲染指令。
- en: Since RSCs never run on the client side, you may use server-exclusive APIs and
    features in them.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 RSCs 从不在客户端运行，你可以在其中使用专用于服务器的 API 和功能。
- en: React also permits RSCs to return `Promise` values, hence you can use `async/await`
    and fetch data asynchronously without issues in RSCs.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 还允许 RSCs 返回 `Promise` 值，因此你可以在 RSCs 中使用 `async/await` 并无问题地异步获取数据。
- en: In order to build interactive websites where the UI may change after being rendered,
    you can also mark components as client components by using the `'use client'`
    directive.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了构建在渲染后UI可能发生变化的交互式网站，你也可以通过使用`'use client'`指令将组件标记为客户端组件。
- en: Only client components can use Hooks like `useState()` or set up event listeners.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有客户端组件可以使用像`useState()`这样的Hooks或设置事件监听器。
- en: Client components are also pre-rendered on the server, but unlike RSCs, they
    may also execute on the client side.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端组件也会在服务器上预渲染，但与RSCs不同，它们也可能在客户端执行。
- en: You may import and use client components inside of RSCs.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在RSCs内部导入和使用客户端组件。
- en: When importing server components into client components, the server components
    automatically become client components, if possible.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将服务器组件导入客户端组件时，如果可能，服务器组件会自动成为客户端组件。
- en: If an RSC can’t be converted into a client component (e.g., because it uses
    `async/await` ), you’ll need to restructure the component tree.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果RSC无法转换为客户端组件（例如，因为它使用了`async/await`），你需要重新构建组件树。
- en: You may pass server components to client components (without converting them)
    via props.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过props将服务器组件传递给客户端组件（无需转换）。
- en: React helps with handling form submissions on the server via Server Actions.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React通过服务器操作帮助处理服务器上的表单提交。
- en: Server Actions work like client actions (see *Chapter 9* ) but must be asynchronous
    ( `async/await` ) and use the `'use server'` directive.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器操作类似于客户端操作（见*第9章*）但必须是异步的（`async/await`）并使用`'use server'`指令。
- en: You can define Server Actions inside of RSCs or in separate files—in the latter
    scenario, you can move the `'use server'` directive to the top of the file to
    define multiple Server Actions in the same file.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在RSCs内部或单独的文件中定义服务器操作——在后一种情况下，你可以将`'use server'`指令移动到文件顶部以在同一个文件中定义多个服务器操作。
- en: What’s Next?
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: In this chapter, you learned about RSCs and Server Actions. You learned that
    creating and using them is relatively straightforward, but that supporting them
    in projects is not—hence frameworks like Next.js are commonly used to take advantage
    of these features.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了RSCs和服务器操作。你了解到创建和使用它们相对简单，但在项目中支持它们并不容易——因此，像Next.js这样的框架通常被用来利用这些功能。
- en: This chapter gave you an idea of how RSCs and Server Actions work behind the
    scenes, and which advantages are offered by these features. Throughout this chapter,
    you also learned about client components and how to combine server and client
    components. Finally, Server Actions were discussed and different ways of defining
    and using Server Actions were shown.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 本章让你了解了RSCs和服务器操作在幕后是如何工作的，以及这些功能提供了哪些优势。在本章中，你还了解了客户端组件以及如何结合服务器和客户端组件。最后，讨论了服务器操作，并展示了定义和使用服务器操作的不同方法。
- en: The next chapter will build up on this chapter and explore how React’s **Suspense**
    functionality may help with showing fallback content while fetched data is being
    streamed in.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将在此基础上构建，并探讨React的**Suspense**功能如何在数据流式传输时显示回退内容方面可能有所帮助。
- en: Test Your Knowledge!
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to examples that can be
    found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/16-rsc-server-actions/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/16-rsc-server-actions/exercises/questions-answers.md)
    :'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '通过回答以下问题来测试你对本章涵盖的概念的了解。然后，你可以将你的答案与可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/16-rsc-server-actions/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/16-rsc-server-actions/exercises/questions-answers.md)找到的示例进行比较。:'
- en: What is the defining characteristic of React Server Components?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React服务器组件的标志性特征是什么？
- en: What are the problems that React Server Components solve?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React服务器组件解决了哪些问题？
- en: How are React Server Components created and used in Next.js projects?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在Next.js项目中创建和使用React服务器组件？
- en: Why can’t React Server Components and Server Actions be used in all React projects?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么React服务器组件和服务器操作不能在所有React项目中使用？
- en: What is the key difference between Server-Side Rendering (SSR) and React Server
    Components (RSCs)?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器端渲染（SSR）和React服务器组件（RSCs）之间的关键区别是什么？
- en: What is the purpose of the `'use client'` directive?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''use client''`指令的目的是什么？'
- en: How does the `'use client'` directive affect child components?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''use client''`指令如何影响子组件？'
- en: What are the rules for combining server components and client components?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器组件和客户端组件的组合规则是什么？
- en: How can you handle loading states in Next.js while fetching data with RSCs?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在Next.js中使用RSCs获取数据的同时处理加载状态？
- en: What are Server Actions in React, and how do they differ from client actions?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React中的服务器动作是什么，它们与客户端动作有何不同？
- en: How can you trigger a Server Action?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何触发服务器动作？
- en: How can you update the UI after a Server Action?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在服务器动作之后更新UI？
- en: Can you define Server Actions in separate files?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否在单独的文件中定义服务器动作？
- en: Apply What You Learned
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用所学知识
- en: With all the newly gained knowledge about Next.js, it’s time to apply it to
    a real demo project—a demo application that will be rendered on the server.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了关于Next.js的所有新知识后，是时候将其应用到实际演示项目中——一个将在服务器上渲染的演示应用程序。
- en: In the following section, you’ll find an activity that allows you to practice
    working with Next.js. As always, you will also need to employ some of the concepts
    covered in earlier chapters.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将找到一个活动，让你练习使用Next.js。一如既往，你还需要应用前面章节中介绍的一些概念。
- en: 'Activity 16.1: Build a Mini Blog'
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十六点一：构建一个迷你博客
- en: In this activity, your job is to build a very simple blog website (with Next.js)
    that allows users to create and view blog posts. Each blog post should consist
    of a title, date, and body text. A list of blog post titles and dates should be
    rendered on the starting page ( `/` ); upon clicking on a post, users should be
    taken to the details page ( `/blog/<some-id>` ), which shows the complete blog
    post data. A `/blog/new` page should display a form that can be used to create
    a new post.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你的任务是构建一个非常简单的博客网站（使用Next.js），允许用户创建和查看博客文章。每篇博客文章应包括标题、日期和正文文本。博客文章标题和日期列表应在起始页（`/`）上渲染；点击文章后，用户应被带到详情页（`/blog/<some-id>`），显示完整的博客文章数据。`/blog/new`页应显示一个表单，可以用来创建新文章。
- en: Posts should be stored in a `posts.json` file (which may simply store an array
    of post objects). After creating a new post, users should be redirected to that
    post’s detail page. If users leave either the title or the body field (or both)
    empty, an error message should be displayed below the form.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 文章应存储在`posts.json`文件中（可能只是存储文章对象的数组）。创建新文章后，用户应被重定向到该文章的详情页。如果用户留空标题或正文字段（或两者都留空），则应在表单下方显示错误消息。
- en: '**Note**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find a starting project snapshot for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    , in this case) to use the right code snapshot.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/activities/practice-1-start)找到这个活动的起始项目快照。下载此代码时，你将始终下载整个仓库。请确保然后导航到包含起始代码的子文件夹（在这个例子中是`activities/practice-1-start`），以使用正确的代码快照。
- en: In the provided starting project, you can explore the `globals.css` file to
    get an idea of the elements and element structure you might want to use to take
    advantage of the provided styles. Of course, you can also set up and use your
    own styles.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的起始项目中，你可以探索`globals.css`文件，以了解你可能想要使用的元素和元素结构，以利用提供的样式。当然，你也可以设置并使用你自己的样式。
- en: 'After downloading the code and running `npm install` in the project folder
    to install all required dependencies, the solution steps are as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码并在项目文件夹中运行`npm install`以安装所有必需的依赖项后，解决方案步骤如下：
- en: 'Add three new `page.js` files (and an appropriate folder structure) for the
    three pages: `/` , `/blog/new` , and `/blog/<some-id>` .'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为三个页面添加三个新的`page.js`文件（以及适当的文件夹结构）：`/`、`/blog/new`和`/blog/<some-id>`。
- en: Add a new `posts.json` file in a `data/` folder in the root project folder.
    This file should initially store an empty array.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根项目文件夹的`data/`文件夹中添加一个新的`posts.json`文件。该文件最初应存储一个空数组。
- en: Output a `<form>` with title and body input fields on the `/blog/new` page.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/blog/new`页面上输出一个包含标题和正文输入字段的`<form>`。
- en: Create a new Server Action in a separate file and import and “connect” it to
    `<form>` . The Server Action should retrieve the entered title and body text,
    create a new object, which also includes an ID and creation date snapshot, and
    store that data in the `posts.json` file. Data must be stored such that existing
    blog posts aren’t lost.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单独的文件中创建一个新的服务器操作，并将其导入并“连接”到`<form>`。服务器操作应检索输入的标题和正文文本，创建一个新的对象，该对象还包括ID和创建日期快照，并将这些数据存储在`posts.json`文件中。数据必须以不会丢失现有博客文章的方式存储。
- en: Update the Server Action to implement input validation and output the validation
    results above the submit button.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新服务器操作以实现输入验证，并在提交按钮上方输出验证结果。
- en: Fetch the blog posts on the starting page and output a list of blog posts (title
    and date). Each post should be clickable and take the user to the details page.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在起始页面获取博客文章，并输出博客文章列表（标题和日期）。每篇文章都应该是可点击的，并带用户到详情页面。
- en: On the details page, fetch and output the blog post details (by using the ID).
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![img](img/B31339_16_18.png)'
- en: Finally, redirect the user to the appropriate details page from inside the Server
    Action, after a blog post is created.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在创建博客文章后，从服务器操作内部将用户重定向到适当的详情页面。
- en: 'The final page should look as shown in the following screenshots:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最终页面应如下截图所示：
- en: '![img](img/B31339_16_17.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: 在详情页面上，通过使用ID获取并输出博客文章的详细信息。
- en: 'Figure 16.17: The home page, showing a list of blog posts'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17：主页，显示博客文章列表
- en: '![img](img/B31339_16_18.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_16_18.png)'
- en: 'Figure 16.18: The /blog/new page, waiting for user input'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.18：/blog/new页面，等待用户输入
- en: '![img](img/B31339_16_19.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_16_19.png)'
- en: 'Figure 16.19: The /blog/<some-id> page displaying blog post details'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '![img](img/B31339_16_19.png)'
- en: '**Note**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can find the full code for this activity, and an example solution, here:
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/activities/practice-1)
    .'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到此活动的完整代码和一个示例解决方案：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/activities/practice-1)。
