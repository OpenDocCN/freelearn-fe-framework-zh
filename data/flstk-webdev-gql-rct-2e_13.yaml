- en: '*Chapter 11*: Writing Tests for React and Node.js'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：为React和Node.js编写测试'
- en: So far, we've written a lot of code and come across a variety of problems. We
    haven't yet implemented automated testing for our software; however, it's a common
    approach to make sure everything works after making changes to your application.
    Automated testing drastically improves the quality of your software and reduces
    errors in production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了大量的代码，遇到了各种问题。我们尚未为我们的软件实现自动化测试；然而，在修改应用程序后确保一切正常工作是一种常见的方法。自动化测试极大地提高了软件的质量，并减少了生产中的错误。
- en: 'To achieve this, we will cover the following main topics in the chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，我们将在本章中涵盖以下主要主题：
- en: How to use Mocha for testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Mocha进行测试
- en: Testing the GraphQL **application programming interface** (**API**) with Mocha
    and Chai
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mocha和Chai测试GraphQL **应用程序编程接口**（**API**）
- en: Testing React with Enzyme and JSDOM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Enzyme和JSDOM测试React
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available in the following GitHub repository:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter11)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter11)'
- en: Testing with Mocha
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mocha进行测试
- en: The problem we're facing is that we must ensure the quality of our software
    without increasing the amount of manual testing. It isn't possible to recheck
    every feature of our software when new updates are released. To solve this problem,
    we're going to use Mocha, which is a JavaScript testing framework that is used
    to run a series of asynchronous tests. If all the tests pass successfully, your
    application is OK and can get released to production.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临的问题是，我们必须确保软件的质量，同时不增加手动测试的数量。当发布新更新时，不可能重新检查我们软件的每个功能。为了解决这个问题，我们将使用Mocha，这是一个用于运行一系列异步测试的JavaScript测试框架。如果所有测试都成功通过，则你的应用程序是正常的，可以发布到生产环境中。
- en: Many developers follow the **test-driven development** (**TDD**) approach. Often,
    when you implement tests for the first time, they fail because the business logic
    that's being tested is missing. After implementing all the tests, we have to write
    the actual application code to meet the requirements of the tests. In this book,
    we haven't followed this approach, but it isn't a problem as we can implement
    tests afterward too. Typically, I tend to write tests in parallel with the application
    code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者遵循**测试驱动开发**（**TDD**）的方法。通常，当你第一次实现测试时，它们会失败，因为正在被测试的业务逻辑缺失。在实现所有测试之后，我们必须编写实际的应用程序代码以满足测试的要求。在这本书中，我们没有遵循这种方法，但这并不是问题，因为我们也可以在之后实现测试。通常，我倾向于与应用程序代码并行编写测试。
- en: 'To get started, we have to install all the dependencies to test our application
    with `npm`, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们必须使用`npm`安装所有依赖项以测试我们的应用程序，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `mocha` package includes almost everything to run tests. Along with Mocha,
    we also install `chai`, which is an assertion library. It offers excellent ways
    to chain tests with many variables and types for use inside a Mocha test. We also
    install the `@babel/polyfill` package, which allows our test to support `request`
    package as a library to send all the queries or mutations within our test. I recommend
    you set the `NODE_ENV` environment variable to `production` to test every functionality,
    as in a live environment. Be sure that you set the environment variable correctly
    so that all production features are used.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`mocha`包几乎包含了运行测试所需的一切。除了Mocha，我们还安装了`chai`，这是一个断言库。它提供了将测试与许多变量和类型链式连接的出色方法，用于Mocha测试内部。我们还安装了`@babel/polyfill`包，它允许我们的测试将`request`包作为库来发送测试中的所有查询或突变。我建议你设置`NODE_ENV`环境变量为`production`以测试每个功能，就像在实时环境中一样。确保你正确设置了环境变量，以便使用所有生产功能。'
- en: Our first Mocha test
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一条Mocha测试
- en: 'First, let''s add a new command to the `scripts` field of our `package.json`
    file, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向我们的`package.json`文件的`scripts`字段添加一个新命令，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you now execute `npm run test`, we'll run the `mocha` package in the `test`
    folder, which we'll create in a second. The preceding `--require` option loads
    the specified file or package. We'll also load a `babel-hook.js` file, which we'll
    create as well. The `--recursive` parameter tells Mocha to run through the complete
    file tree of the `test` folder, not just the first layer. This behavior is useful
    because it allows us to structure our tests in multiple files and folders.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在执行`npm run test`，我们将运行`test`文件夹中的`mocha`包，我们将在下一秒创建这个文件夹。前面的`--require`选项加载指定的文件或包。我们还将加载一个`babel-hook.js`文件，我们也将创建它。`--recursive`参数告诉Mocha运行`test`文件夹的完整文件树，而不仅仅是第一层。这种行为很有用，因为它允许我们在多个文件和文件夹中结构化我们的测试。
- en: 'Let''s begin with the `babel-hook.js` file by adding it to the root of our
    project, next to the `package.json` file. Insert the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加到项目根目录的`babel-hook.js`文件开始，紧挨着`package.json`文件。插入以下代码：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The purpose of this file is to give us an alternative Babel configuration file
    to our standard `.babelrc` file. If you compare both files, you should see that
    we use the `require-context-hook` plugin. We already use this plugin when starting
    the backend with `npm run server`. It allows us to import our Sequelize models
    using a **regular expression** (**regex**).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的目的在于提供一个替代的Babel配置文件，相对于我们的标准`.babelrc`文件。如果你比较这两个文件，你应该会看到我们使用了`require-context-hook`插件。我们在使用`npm
    run server`启动后端时已经使用了这个插件。它允许我们使用**正则表达式**（**regex**）导入我们的Sequelize模型。
- en: If we start our test with `npm run test`, we require this file at the beginning.
    Inside the `babel-hook.js` file, we load `@babel/register`, which compiles all
    the files that are imported afterward in our test according to the preceding configuration.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以`npm run test`开始测试，我们会在文件开始处要求这个文件。在`babel-hook.js`文件内部，我们加载`@babel/register`，它根据前面的配置编译测试中随后导入的所有文件。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that when running a production build or environment, the production database
    is also used. All changes are made to this database. Verify that you have configured
    the database credentials correctly in the server's `configuration` folder. You
    have only to set the `host`, `username`, `password`, and `database` environment
    variables correctly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当运行生产构建或环境时，也会使用生产数据库。所有更改都应用到这个数据库上。请确认你已经在服务器的`configuration`文件夹中正确配置了数据库凭据。你只需正确设置`host`、`username`、`password`和`database`环境变量即可。
- en: 'This gives us the option to start our backend server from within our test file
    and render our application on the server. The preparation for our test is now
    finished. Create a folder named `test` inside the root of our project to hold
    all runnable tests. Mocha will scan all files or folders, and all tests will be
    executed. To get a basic test running, create an `app.test.js` file. This is the
    main file, which makes sure that our backend is running and in which we can subsequently
    define further tests. The first version of our test looks like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们从测试文件中启动后端服务器并在服务器上渲染应用的选择。我们的测试准备工作现在已完成。在项目根目录下创建一个名为`test`的文件夹来存放所有可运行的测试。Mocha将扫描所有文件或文件夹，所有测试都将被执行。为了运行一个基本的测试，创建一个`app.test.js`文件。这是主文件，确保我们的后端正在运行，我们可以在其中定义更多的测试。我们的测试的第一个版本如下所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s take a closer look at what''s happening here, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这里发生了什么，如下所示：
- en: We import the Node.js `assert` function. This gives us the ability to verify
    the value or type of a variable.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入Node.js的`assert`函数。这使我们能够验证变量的值或类型。
- en: We import the `request` package, which we use to send queries against our backend.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入`request`包，我们用它来向我们的后端发送查询。
- en: We import two Chai functions, `expect` and `should`, from the `chai` package.
    Neither of these is included in Mocha, but they both improve the test's functionality
    significantly.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`chai`包中导入两个Chai函数，`expect`和`should`。这两个函数都不包含在Mocha中，但它们都显著提高了测试的功能。
- en: The beginning of the test starts with the `describe` function. Because Mocha
    executes the `app.test.js` file, we're in the correct scope and can use all Mocha
    functions. The `describe` function is used to structure your test and its output.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试的开始部分使用`describe`函数。因为Mocha执行`app.test.js`文件，所以我们处于正确的范围，可以使用所有Mocha函数。`describe`函数用于结构化你的测试及其输出。
- en: We use the `it` function, which initiates the first test.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`it`函数，它启动第一个测试。
- en: The `it` function can be understood as a feature of our application that we
    want to test inside the callback function. As the first parameter, you should
    enter a sentence, such as `'it does this and that'`, that's easily readable. The
    function itself waits for the complete execution of the `callback` function in
    the second parameter. The result of the callback will either be that all assertions
    were successful or that, for some reason, a test failed or the callback didn't
    complete in a reasonable amount of time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`it` 函数可以理解为回调函数内我们想要测试的应用程序功能。作为第一个参数，你应该输入一个易于阅读的句子，例如 `''it does this and
    that''`。函数本身等待第二个参数中的 `callback` 函数的完整执行。回调的结果将是所有断言都成功，或者由于某种原因测试失败，或者回调没有在合理的时间内完成。'
- en: The `describe` function is the header of our test's output. Then, we have a
    new row for each `it` function we execute. Each row represents a single test step.
    The `it` function passes a `done` function to the callback. The `done` function
    has to be executed once all assertions are finished and there's nothing left to
    do. If it isn't executed in a certain amount of time, the current test is marked
    as failed. In the preceding code snippet, the first thing we did was send a `GET`
    request to `http://localhost:8000`, which is accepted by our backend server. The
    expected answer will be in the form of server-side rendered **HyperText Markup
    Language** (**HTML**) created through React.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 函数是我们测试输出的标题。然后，对于每个执行的 `it` 函数，我们都有一个新行。每一行代表一个单独的测试步骤。`it` 函数将一个
    `done` 函数传递给回调。`done` 函数必须在所有断言完成后执行，且没有其他事情要做。如果在一定时间内没有执行，当前测试将被标记为失败。在先前的代码片段中，我们首先发送了一个
    `GET` 请求到 `http://localhost:8000`，这被我们的后端服务器接受。预期的答案将以通过 React 创建的服务器端渲染的 **超文本标记语言**（**HTML**）的形式出现。'
- en: 'To prove that the response holds this information, we make some assertions
    in our preceding test, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明响应包含此信息，我们在先前的测试中做出了一些断言，如下所示：
- en: We use the `should` function from Chai. The great thing is that it's chainable
    and represents a sentence that directly explains the meaning of what we're doing.
    The `should.not.exist` function chain makes sure that the given value is empty.
    The result is `true` if the value is `undefined` or `null`, for example. The consequence
    is that when the `err` variable is filled, the assertion fails and so our test,
    `'renders and serves the index page'`, fails too.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 Chai 的 `should` 函数。它的好处是它是可链式的，并且代表一个直接解释我们正在做什么意义的句子。`should.not.exist`
    函数链确保给定的值是空的。如果值是 `undefined` 或 `null` 等示例，结果将是 `true`。结果是，当 `err` 变量被填充时，断言失败，因此我们的测试
    `'渲染并服务首页'` 也失败了。
- en: The same goes for the `should.exist` line. It makes sure that the `res` variable,
    which is the response given by the backend, is filled. Otherwise, there's a problem
    with the backend.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `should.exist` 这一行也是同样的道理。它确保了 `res` 变量，即后端给出的响应，被填充。否则，后端可能存在问题。
- en: The `expect` function can also represent a sentence, as with both functions
    before. We expect `res.statusCode` to have a value of `200`. This assertion can
    be written as `expect(res.statusCode).to.be.equal(200)`. We can be sure that everything
    has gone well if the HTTP status is `200`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`expect` 函数也可以像之前的两个函数一样表示一个句子。我们期望 `res.statusCode` 的值为 `200`。这个断言可以写成 `expect(res.statusCode).to.be.equal(200)`。如果我们收到
    HTTP 状态码为 `200`，我们可以确信一切顺利。'
- en: If nothing has failed so far, we check whether the returned `body` variable,
    which is the third callback parameter of the `request` function, is valid. For
    our test scenario, we only need to check whether it contains an `html` tag.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果到目前为止没有失败，我们检查返回的 `body` 变量，即 `request` 函数的第三个回调参数，是否有效。对于我们的测试场景，我们只需要检查它是否包含一个
    `html` 标签。
- en: We execute the `done` function. We pass the `err` object as a parameter. The
    result of this function is much like the `should.not.exist` function. If you pass
    a filled error object to the `done` function, the test fails. The tests become
    more readable when using the Chai syntax.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们执行 `done` 函数。我们将 `err` 对象作为参数传递。这个函数的结果与 `should.not.exist` 函数类似。如果你将一个填充的错误对象传递给
    `done` 函数，测试将失败。使用 Chai 语法时，测试变得更易读。
- en: 'If you execute `npm run test` now, you''ll receive the following error:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在执行 `npm run test`，你会收到以下错误：
- en: '![Figure 11.1 – Failed test because no server ran'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 服务器未运行导致的测试失败'
- en: '](img/Figure_11.01_B17337.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 11.01_B17337.jpg](img/Figure_11.01_B17337.jpg)'
- en: Figure 11.1 – Failed test because no server ran
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 服务器未运行导致的测试失败
- en: 'Our first `should.not.exist` assertion failed and threw an error. This is because
    we didn''t start the backend when we ran the test. Start the backend in a second
    terminal with the correct environment variables using `npm run server` and rerun
    the test. Now, the test is successful, as we can see here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次的`should.not.exist`断言失败并抛出了错误。这是因为我们在运行测试时没有启动后端。在第二个终端中使用正确的环境变量通过`npm
    run server`启动后端，然后重新运行测试。现在，测试成功，如下所示：
- en: '![Figure 11.2 – Test passes if the server runs'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.2 – 测试通过如果服务器运行]'
- en: '](img/Figure_11.02_B17337.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.02 – B17337.jpg]'
- en: Figure 11.2 – Test passes if the server runs
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 11.2 – 测试通过如果服务器运行
- en: The output is good, but the process isn't very intuitive. The current workflow
    is hard to implement when running the tests automatically while deploying your
    application or pushing new commits to your **version control system** (**VCS**).
    We'll change this behavior next.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果很好，但过程并不十分直观。在部署应用程序或推送新的提交到您的**版本控制系统**（**VCS**）时自动运行测试，当前的流程很难实现。我们将在下一个版本中改变这种行为。
- en: Starting the backend with Mocha
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Mocha启动后端
- en: 'When we want to run a test, the server should start automatically. There are
    two options to implement this behavior, as outlined here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要运行一个测试时，服务器应该自动启动。有两种方法可以实现这种行为，如下所述：
- en: We add the `npm run server` command to the `test` script inside our `package.json`
    file.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`npm run server`命令添加到`package.json`文件中的`test`脚本中。
- en: We import all the necessary files to launch the server within our `app.test.js`
    file. This allows us to run further assertions or commands against the backend.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`app.test.js`文件中导入所有必要的文件以启动服务器。这允许我们对后端运行更多的断言或命令。
- en: 'The best option is to start the server within our test and not rely on a second
    command because we can run further tests on the backend. We need to import a further
    package to allow the server to start within our test, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳选择是在我们的测试中启动服务器，而不是依赖于第二个命令，因为我们可以在后端运行更多的测试。我们需要导入一个额外的包，以便在测试中启动服务器，如下所示：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use and execute this package because we load the Sequelize models using the
    `require.context` function. By loading the package, the `require.context` function
    is executable for the server-side code. Before we started the server within the
    test, the plugin hadn't been used, although it was loaded in the `babel-hooks.js`
    file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用并执行这个包，因为我们使用`require.context`函数加载Sequelize模型。通过加载这个包，`require.context`函数对服务器端代码是可执行的。在我们开始在测试中启动服务器之前，插件尚未使用，尽管它已在`babel-hooks.js`文件中加载。
- en: 'Now, we can load the server directly in the test. Add the following lines of
    code at the top of the `describe` function, just before the test we''ve just written:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在测试中直接加载服务器。在刚刚编写的`describe`函数顶部添加以下代码行：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The idea is to load the server's `index.js` file inside of our test, which starts
    the backend automatically. To do this, we define an empty variable called `app`.
    Then, we use `this.timeout` to set the timeout for all tests inside Mocha to `50000`
    because starting our server, including Apollo Server, takes some time. Otherwise,
    the test will probably fail because the start time is too long for the standard
    Mocha timeout.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是在我们的测试中加载服务器的`index.js`文件，这会自动启动后端。为此，我们定义一个名为`app`的空变量。然后，我们使用`this.timeout`将Mocha中所有测试的超时时间设置为`50000`，因为启动我们的服务器，包括Apollo
    Server，需要一些时间。否则，测试可能会因为启动时间过长而失败，这对于标准的Mocha超时来说太长了。
- en: We must make sure that the server has been completely started before any of
    our tests are executed. This logic can be achieved with Mocha's `before` function.
    Using this function, you can set up and configure things such as starting a backend
    in our scenario. To continue and process all the tests, we need to execute the
    `done` function to complete the callback of the `before` function. To be sure
    that the server has started, we do not just run the `done` function after loading
    the `index.js` file. We bind the `listening` event of the server using the `app.on`
    function. If the server emits the `listening` event, we can securely run the `done`
    function, and all tests can send requests to the server. We could also save the
    return value of the `require` function directly into the `app` variable to hold
    the `server` object. The problem with this order, however, is that the server
    may start listening before we can bind the `listening` event. The way we are doing
    it now makes sure the server hasn't yet started.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保在执行任何测试之前服务器已经完全启动。这个逻辑可以通过Mocha的`before`函数实现。使用这个函数，你可以在我们的场景中设置和配置诸如启动后端等事情。为了继续并处理所有测试，我们需要执行`done`函数来完成`before`函数的回调。为了确保服务器已经启动，我们不仅在加载`index.js`文件后运行`done`函数。我们使用`app.on`函数绑定服务器的`listening`事件。如果服务器发出`listening`事件，我们可以安全地运行`done`函数，并且所有测试都可以向服务器发送请求。我们也可以直接将`require`函数的返回值保存到`app`变量中，以保存`server`对象。然而，这个顺序的问题在于服务器可能在我们可以绑定`listening`事件之前就开始监听。我们现在这样做确保服务器还没有启动。
- en: 'The test, however, still isn''t working. You''ll see an error message that
    says `''TypeError: app.on is not a function''`. Take a closer look at the server''s
    `index.js` file. At the end of the file, we aren''t exporting the `server` object
    because we only used it to start the backend. This means that the `app` variable
    in our test is empty and we can''t run the `app.on` function. The solution is
    to export the `server` object at the end of the server''s `index.js` file, like
    this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，测试仍然没有工作。你会看到一个错误消息，说`''TypeError: app.on is not a function''`。仔细看看服务器的`index.js`文件。在文件的末尾，我们没有导出`server`对象，因为我们只使用它来启动后端。这意味着我们测试中的`app`变量是空的，我们无法运行`app.on`函数。解决方案是在服务器`index.js`文件的末尾导出`server`对象，如下所示：'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can now execute the test again. Everything should look fine, and all tests
    should pass.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以再次执行测试。一切看起来都应该是正常的，并且所有测试都应该通过。
- en: 'There is, however, one last problem. If you compare the behavior from the test
    before importing the server directly in our test or starting it in a second terminal,
    you might notice that the test isn''t finished, or at least the process isn''t
    stopped. Previously, all steps were executed, we returned to the normal shell,
    and we could execute the next command. The reason for this is that the server
    is still running in our `app.test.js` file. Therefore, we must stop the backend
    after all tests have been executed. Insert the following code after the `before`
    function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个最后的问题。如果你比较在将服务器直接导入我们的测试或在一个第二个终端启动之前的行为，你可能会注意到测试并没有完成，或者至少进程没有停止。之前，所有步骤都执行了，我们回到了正常的shell，并且可以执行下一个命令。这是因为服务器仍然在我们的`app.test.js`文件中运行。因此，我们必须在所有测试执行完毕后停止后端。在`before`函数之后插入以下代码：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `after` function is run when all tests are finished. Our `app` object offers
    the `close` function, which terminates the server. As a callback, we hand over
    the `done` function, which is executed once the server has stopped. This means
    that our test has also finished.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有测试完成后，会运行`after`函数。我们的`app`对象提供了`close`函数，该函数终止服务器。作为一个回调，我们传递`done`函数，一旦服务器停止，该函数就会被执行。这意味着我们的测试也已经完成。
- en: Verifying the correct routing
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证正确的路由
- en: 'We now want to check whether all the features of our application are working
    as expected. One major feature of our application is that React Router redirects
    the user in the following two cases:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想检查我们应用程序的所有功能是否按预期工作。我们应用程序的一个主要功能是React Router在以下两种情况下将用户重定向：
- en: The user visits a route that cannot be matched.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户访问了一个无法匹配的路由。
- en: The user visits a route that can be matched, but they aren't allowed to view
    the page.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户访问了一个可以匹配的路由，但他们不允许查看页面。
- en: 'In both cases, the user should be redirected to the login form. In the first
    case, we can follow the same approach as for our first test. We send a request
    to a path that isn''t inside our router. Add the following code to the bottom
    of the `describe` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种情况下，用户都应该被重定向到登录表单。在第一种情况下，我们可以采用与第一次测试相同的方法。我们向一个不在我们路由器内的路径发送请求。将以下代码添加到`describe`函数的底部：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s quickly go through all the steps of the preceding test, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下前面测试的所有步骤，如下：
- en: We add a new `describe` function to structure our test's output.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个新的`describe`函数来结构化我们的测试输出。
- en: We send a request inside another `it` function to an unmatched path.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在另一个`it`函数内部向一个不匹配的路径发送请求。
- en: The checks are the same as the ones we used when starting the server.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查与我们在启动服务器时使用的检查相同。
- en: We verify that the response's path is the `/` root. That happens when the redirect
    is executed. Therefore, we use the `res.req.path === '/'` condition.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们验证响应的路径是`/`根路径。这是在执行重定向时发生的。因此，我们使用`res.req.path === '/'`条件。
- en: We check whether the returned `body` variable includes an HTML tag with the
    `authModal` class. This should happen when the user isn't logged in, and the login
    or register form is rendered.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查返回的`body`变量是否包含具有`authModal`类的HTML标签。这应该在用户未登录且渲染登录或注册表单时发生。
- en: 'If the assertions are successful, we know that React Router works correctly
    in the first scenario. The second scenario relates to private routes that can
    only be accessed by authenticated users. We can copy the preceding check and replace
    the request. The assertions we are doing stay the same, but the **Uniform Resource
    Locator** (**URL**) of the request is different. Add the following test under
    the previous one:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果断言成功，我们知道React Router在第一种场景中工作正确。第二种场景与只能由认证用户访问的私有路由相关。我们可以复制前面的检查并替换请求。我们进行的断言保持不变，但请求的**统一资源定位符**（**URL**）不同。在前面一个测试下面添加以下测试：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If an unauthenticated user requests the `/app` route, they're redirected to
    the `/` root path. The assertions verify whether the login form is displayed as
    before. To differentiate the tests, we add a new `describe` function so that it
    has a better structure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未认证的用户请求`/app`路由，他们将被重定向到`/`根路径。断言验证登录表单是否如之前一样显示。为了区分测试，我们添加一个新的`describe`函数，使其结构更好。
- en: In this section, we have learned how use Mocha to assert that our application
    works correctly. We are now verifying whether our application starts and also
    whether the routing works as expected and returns the correct pages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用Mocha断言我们的应用程序工作正确。我们现在正在验证我们的应用程序是否启动，以及路由是否按预期工作并返回正确的页面。
- en: Next, we want to test the GraphQL API that we built, not only the **server-side
    rendering** (**SSR**) functionality.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要测试我们构建的GraphQL API，而不仅仅是**服务器端渲染**（**SSR**）功能。
- en: Testing the GraphQL API with Mocha
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mocha测试GraphQL API
- en: 'We must verify that all the API functions we''re offering work correctly. I''m
    going to show you how to do this with two examples, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须验证我们提供的所有API函数是否正确工作。我将通过以下两个示例向您展示如何做到这一点：
- en: The user needs to sign up or log in. This is a critical feature where we should
    verify that the API works correctly.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要注册或登录。这是一个关键特性，我们应该验证API是否正确工作。
- en: The user queries or mutates data via the GraphQL API. For our test case, we
    will request all chats the logged-in user is related to.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户通过GraphQL API查询或修改数据。对于我们的测试用例，我们将请求登录用户相关的所有聊天。
- en: Those two examples should explain all the essential techniques to test every
    part of your API. You can add more functions that you want to test at any point.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例应该解释测试API每个部分的所有基本技术。您可以在任何时刻添加更多您想要测试的函数。
- en: Testing the authentication
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试认证
- en: We extend the authentication tests of our test with the signup functionality.
    We're going to send a simple GraphQL request to our backend, including all the
    required data to sign up a new user. We've already sent requests, so there's nothing
    new here. In comparison to all the requests before, however, we have to send a
    `POST` request, not a `GET` request. Also, the endpoint for the signup is the
    `/graphql` path, where our Apollo Server listens for incoming mutations or queries.
    Normally, when a user signs up for Graphbook, the authentication token is returned
    directly, and the user is logged in. We must preserve this token to make future
    GraphQL requests. We don't use Apollo Client for our test as we don't need to
    test the GraphQL API.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加注册功能扩展了我们的测试认证。我们将向我们的后端发送一个简单的GraphQL请求，包括注册新用户所需的所有数据。我们已经发送了请求，所以这里没有什么新的内容。然而，与之前的所有请求相比，我们必须发送一个`POST`请求，而不是`GET`请求。此外，注册的端点是`/graphql`路径，我们的Apollo
    Server在这里监听传入的突变或查询。通常，当用户在Graphbook上注册时，认证令牌会直接返回，用户会登录。我们必须保留这个令牌以进行未来的GraphQL请求。我们不需要使用Apollo
    Client进行测试，因为我们不需要测试GraphQL API。
- en: 'Create a global variable next to the `app` variable, where we can store the
    **JavaScript Object Notation (JSON) Web Token** (**JWT**) returned after signup,
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app`变量旁边创建一个全局变量，用于存储注册后返回的**JavaScript对象表示法（JSON）Web令牌（JWT**），如下所示：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the test, we can set the returned JWT. Add the following code to the
    `authentication` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试内部，我们可以设置返回的JWT。将以下代码添加到`authentication`函数中：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We begin by creating a `json` variable. This object is sent as a JSON body to
    our GraphQL API. The content of it should be familiar to you—it's nearly the same
    format we used when testing the GraphQL API in Postman.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`json`变量。这个对象以JSON体形式发送到我们的GraphQL API。其内容应该对你来说很熟悉——它几乎与我们之前在Postman中测试GraphQL
    API时使用的格式相同。
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The JSON we send represents a manual way of sending GraphQL requests. There
    are libraries that you can easily use to save this and directly send the query
    without wrapping it inside an object, such as `graphql-request`: [https://github.com/prisma-labs/graphql-request](https://github.com/prisma-labs/graphql-request).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送的JSON代表了一种手动发送GraphQL请求的方式。有一些库你可以轻松使用来保存这个请求并直接发送查询，而不需要将其包裹在对象中，例如`graphql-request`：[https://github.com/prisma-labs/graphql-request](https://github.com/prisma-labs/graphql-request)。
- en: The `json` object includes fake signup variables to create a user with the `mochatest`
    username. We'll send HTTP `POST` with the `request.post` function. To use the
    `json` variable, we pass it into the `json` field. The `request.post` function
    automatically adds the body as a JSON string and the correct `Content-Type` header
    for you. When the response arrives, we run the standard checks, such as checking
    for an error or checking an HTTP status code. We also check the format of the
    returned `body` variable because the response's `body` variable won't return HTML
    but will return JSON instead. We make sure that it's an object with the `should.be.an('object')`
    function. The `should` assertion can directly be used and chained to the `body`
    variable. If `body` is an object, we check whether there's a `data` property inside.
    That's enough security to read the token from the `body.data.signup.token` property.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`对象包含用于创建具有`mochatest`用户名的用户的模拟注册变量。我们将使用`request.post`函数发送HTTP `POST`请求。要使用`json`变量，我们将它传递到`json`字段。`request.post`函数会自动将正文作为JSON字符串添加，并为你添加正确的`Content-Type`头。当响应到达时，我们运行标准检查，例如检查错误或检查HTTP状态码。我们还检查返回的`body`变量的格式，因为响应的`body`变量不会返回HTML，而是返回JSON。我们确保它是一个使用`should.be.an(''object'')`函数的对象。`should`断言可以直接使用并链接到`body`变量。如果`body`是一个对象，我们检查其中是否有`data`属性。从`body.data.signup.token`属性读取令牌就足够安全了。'
- en: The user is now created in our database. We can use this token for further requests.
    Be aware that running this test a second time on your local machine is likely
    to result in a failure because the user already exists. In this case, you can
    delete it manually from your database. This problem won't occur when running this
    test while using **continuous integration** (**CI**). We'll focus on this topic
    in the last chapter. Next, we'll make an authenticated query to our Apollo Server
    and test the result of it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在已创建在我们的数据库中。我们可以使用这个令牌进行后续请求。请注意，在本地机器上再次运行此测试很可能会导致失败，因为用户已经存在。在这种情况下，你可以手动从数据库中删除它。当使用**持续集成（CI**）运行此测试时，这个问题不会发生。我们将在最后一章中关注这个主题。接下来，我们将向Apollo
    Server进行认证查询并测试其结果。
- en: Testing authenticated requests
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试认证请求
- en: 'We set the `authToken` variable after the signup request. You could also do
    this with a login request if a user already exists while testing. Only the query
    and the assertions we are using are going to change. Also, insert the following
    code into the `before` authentication function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册请求之后，我们设置了 `authToken` 变量。如果测试时用户已经存在，您也可以使用登录请求来做这件事。只有查询和我们所使用的断言将会改变。此外，将以下代码插入到
    `before` 认证函数中：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see in the preceding code snippet, the `json` object doesn''t include
    any variables because we only query the chats of the logged-in user. We changed
    the `query` string accordingly. Compared to the login or signup request, the chat
    query requires the user to be authenticated. The `authToken` variable we saved
    is sent inside the `Authorization` header. We now verify again whether the request
    was successful and check for a `data` property in the `body` variable. Notice
    that, before running the `done` function, we verify that the `data` object has
    a field called `chats`. We also check the length of the `chats` field, which proves
    that it''s an array. The length can be statically set to `0` because the user
    who''s sending the query just signed up and doesn''t have any chats yet. The output
    from Mocha looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码片段中所见，`json` 对象不包含任何变量，因为我们只查询了已登录用户的聊天记录。我们相应地更改了 `query` 字符串。与登录或注册请求相比，聊天查询需要用户进行身份验证。我们保存的
    `authToken` 变量被发送在 `Authorization` 头部中。我们现在再次验证请求是否成功，并在 `body` 变量中检查 `data` 属性。请注意，在运行
    `done` 函数之前，我们验证 `data` 对象是否有一个名为 `chats` 的字段。我们还检查 `chats` 字段的长度，这证明了它是一个数组。长度可以静态设置为
    `0`，因为发送查询的用户刚刚注册，还没有任何聊天记录。Mocha 的输出如下所示：
- en: '![Figure 11\. 3 – Authentication test'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 – 认证测试'
- en: '](img/Figure_11.03_B17337.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.03_B17337.jpg)'
- en: Figure 11\. 3 – Authentication test
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 认证测试
- en: This is all you need to know to test all the features of your API.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要了解的所有内容，以测试您 API 的所有功能。
- en: Next, we are going to have a look on Enzyme, which is a great testing tool that
    allows you to interact with the React components that we have written and ensure
    that they are working as expected.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看 Enzyme，这是一个伟大的测试工具，它允许我们与我们所编写的 React 组件进行交互，并确保它们按预期工作。
- en: Testing React with Enzyme
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Enzyme 测试 React
- en: 'So far, we''ve managed to test our server and all GraphQL API functions. Currently,
    however, we''re still missing the tests for our frontend code. While we render
    the React code when requesting any server route, such as the `/app` path, we only
    have access to the final result and not to each component. We should change this
    to execute the functions of certain components that aren''t testable through the
    backend. First, install some dependencies before using `npm`, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功测试了我们的服务器和所有 GraphQL API 函数。然而，目前我们仍然缺少对前端代码的测试。当我们请求任何服务器路由，如 `/app`
    路径时，我们只能访问最终结果，而不能访问每个组件。我们应该改变这一点，以执行某些无法通过后端测试的组件的功能。首先，在使用 `npm` 之前安装一些依赖项，如下所示：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The various packages are described in more detail here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有关各种包的详细信息，请参阅此处：
- en: The `enzyme` and `@wojtekmaj/enzyme-adapter-react-17` packages provide React
    with specific features to render and interact with the React tree. This can be
    through either a real **Document Object Model** (**DOM**) or shallow rendering.
    We are going to use a real DOM in this chapter because it allows us to test all
    features, while shallow rendering is limited to just the first layer of components.
    We need to rely on a third-party package for the React adapter because there is
    no official support at the moment for React 17 from Enzyme.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enzyme` 和 `@wojtekmaj/enzyme-adapter-react-17` 包为 React 提供了特定的功能，以渲染和与 React
    树进行交互。这可以通过真实的 **文档对象模型**（**DOM**）或浅渲染来实现。在本章中，我们将使用真实的 DOM，因为它允许我们测试所有功能，而浅渲染仅限于组件的第一层。我们需要依赖第三方包来提供
    React 适配器，因为目前 Enzyme 对 React 17 没有官方支持。'
- en: The `ignore-styles` package strips out all `import` statements for **Cascading
    Style Sheets** (**CSS**) files. This is very helpful since we don't need CSS for
    our tests.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore-styles` 包移除了所有针对 **层叠样式表**（**CSS**）文件的 `import` 语句。这非常有帮助，因为我们不需要 CSS
    进行测试。'
- en: The `jsdom` package creates a DOM object for us, which is then used to render
    the React code into.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The `jsdom` package creates a DOM object for us, which is then used to render
    the React code into.
- en: The `isomorphic-fetch` package replaces the `fetch` function that all browsers
    provide by default. This isn't available in Node.js, so we need a polyfill.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isomorphic-fetch`包替换了所有浏览器默认提供的`fetch`函数。这在Node.js中不可用，因此我们需要一个polyfill。'
- en: 'We start by importing the new packages directly under the other `require` statements,
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在其他`require`语句下面直接导入新的包，如下所示：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To use Enzyme, we import React. Then, we create an adapter for Enzyme that
    supports React 16\. We insert the adapter into Enzyme''s `configure` statement.
    Before starting with the frontend code, we import the `ignore-styles` package
    to ignore all CSS imports. I''ve also directly excluded **Syntactically Awesome
    Style Sheets** (**SASS**) and SCSS files. The next step is to initialize our DOM
    object, where all the React code is rendered. Here''s the code you''ll need:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Enzyme，我们导入React。然后，我们为支持React 16的Enzyme创建一个适配器。我们将适配器插入到Enzyme的`configure`语句中。在开始前端代码之前，我们导入`ignore-styles`包以忽略所有CSS导入。我还直接排除了**Syntactically
    Awesome Style Sheets**（**SASS**）和SCSS文件。下一步是初始化我们的DOM对象，所有React代码都将在这里渲染。以下是您需要的代码：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We require the `jsdom` package and initialize it with a small HTML string. We
    don't take the template file that we're using for the server or client because
    we just want to render our application to any HTML, so how it looks isn't important.
    The second parameter is an `options` object. We specify a `url` field, which is
    the host URL, under which we render the React code. Otherwise, we might get an
    error when accessing `localStorage`. After initialization, we extract the `window`
    object and define two global variables that are required to mount a React component
    to our fake DOM. These two properties behave like the `document` and `window`
    objects in the browser, but instead of the browser, they are global objects inside
    our Node.js server.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`jsdom`包，并用一个小的HTML字符串初始化它。我们不需要使用服务器或客户端的模板文件，因为我们只想将我们的应用程序渲染到任何HTML中，所以它的外观并不重要。第二个参数是一个`options`对象。我们指定一个`url`字段，这是渲染React代码的主机URL。否则，在访问`localStorage`时可能会出错。初始化后，我们提取`window`对象并定义两个全局变量，这些变量是挂载React组件到我们的模拟DOM所必需的。这两个属性在行为上类似于浏览器中的`document`和`window`对象，但它们不是浏览器中的全局对象，而是在我们的Node.js服务器内部的全局对象。
- en: In general, it isn't a good idea to mix up the Node.js `global` object with
    the DOM of a browser and render a React application in it. Still, we're merely
    testing our application and not running it in production in this environment,
    so while it might not be recommended, it helps our test to be more readable. We'll
    begin the first frontend test with our login form. The visitor to our page can
    either directly log in or switch to the signup form. Currently, we don't test
    this switch functionality in any way. This is a complex example, but you should
    be able to understand the techniques behind it quickly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将Node.js的`global`对象与浏览器的DOM混合在一起，并在其中渲染React应用程序并不是一个好主意。然而，我们只是在测试我们的应用程序，而不是在这个环境中运行生产环境，所以虽然这可能不被推荐，但它有助于使我们的测试更易于阅读。我们将从我们的登录表单开始第一个前端测试。访问我们页面的访客可以直接登录或切换到注册表单。目前，我们没有以任何方式测试这个切换功能。这是一个复杂的例子，但你应该能够快速理解其背后的技术。
- en: 'To render our complete React code, we''re going to initialize an Apollo Client
    for our test. Import all the dependencies, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染我们的完整React代码，我们将为我们的测试初始化一个Apollo客户端。导入所有依赖项，如下所示：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also import the `index.js` component of the server-rendered React code.
    This component will receive our client, which we''ll initialize shortly. Add a
    new `describe` function for all frontend tests, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入了服务器端渲染的React代码的`index.js`组件。这个组件将接收我们的客户端，我们将在稍后初始化它。为所有前端测试添加一个新的`describe`函数，如下所示：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code creates a new Apollo Client. The client doesn''t implement
    any logic, such as authentication or WebSockets, because we don''t need this to
    test the switch from the login form to the signup form. It''s merely a required
    property to render our application completely. If you want to test components
    that are only rendered when being authenticated, you can, of course, implement
    it easily. Enzyme requires us to pass a real React component, which will be rendered
    to the DOM. Add the following code directly beneath the `client` variable:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个新的Apollo客户端。客户端不实现任何逻辑，例如身份验证或WebSockets，因为我们不需要这些来测试从登录表单切换到注册表单。它只是一个渲染我们应用程序所必需的属性。如果你想测试仅在认证时渲染的组件，你当然可以轻松实现它。Enzyme要求我们传递一个真实的React组件，该组件将被渲染到DOM中。在`client`变量下面直接添加以下代码：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code is a small wrapper around the `App` variable that we imported
    from the server''s `ssr` folder. The `client` property is filled with the new
    Apollo Client. Follow the given instructions to render and test your React frontend
    code. The following code goes directly under the `Graphbook` class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是围绕从服务器的`ssr`文件夹导入的`App`变量的小包装。`client`属性填充了新的Apollo客户端。按照给定的说明来渲染和测试你的React前端代码。以下代码直接位于`Graphbook`类下方：
- en: 'We use the `mount` function of Enzyme to render the `Graphbook` class to the
    DOM, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用Enzyme的`mount`函数将`Graphbook`类渲染到DOM中，如下所示：
- en: '[PRE19]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `wrapper` variable provides many functions to access or interact with the
    DOM and the components inside it. We use it to prove that the first render displays
    the login form. The code is illustrated here:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`wrapper`变量提供了许多函数来访问或与DOM及其内部组件交互。我们使用它来证明第一次渲染显示了登录表单。代码如下所示：'
- en: '[PRE20]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `html` function of the `wrapper` variable returns the complete HTML string
    that has been rendered by the React code. We check this string with the `contain`
    function of Chai. If the check is successful, we can continue.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`wrapper`变量的`html`函数返回由React代码渲染的完整HTML字符串。我们使用Chai的`contain`函数来检查这个字符串。如果检查成功，我们可以继续。'
- en: 'Typically, the user clicks on the `wrapper` variable. The enzyme comes with
    that functionality innately, as illustrated here:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，用户点击`wrapper`变量。Enzyme自带这种功能，如下所示：
- en: '[PRE21]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `find` function gives us access to the `LoginRegisterForm` component. Inside
    the markup of the component, we search for an `a` tag, of which there can only
    be one. If the `find` method returns multiple results, we can't trigger things
    such as a click because the `simulate` function is fixed to only one possible
    target. After running both `find` functions, we execute Enzyme's `simulate` function.
    The only parameter needed is the event that we want to trigger. In our scenario,
    we trigger a `click` event on the `a` tag, which lets React handle all the rest.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`find`函数使我们能够访问`LoginRegisterForm`组件。在组件的标记内部，我们搜索一个`a`标签，只能有一个。如果`find`方法返回多个结果，我们无法触发点击等操作，因为`simulate`函数固定只针对一个可能的靶点。在运行了两个`find`函数之后，我们执行Enzyme的`simulate`函数。唯一需要的参数是我们想要触发的事件。在我们的场景中，我们在`a`标签上触发一个`click`事件，这允许React处理其余部分。'
- en: 'We check whether the form was changed correctly by executing the following
    code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过执行以下代码来检查表单是否正确更改：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We use the `html` and `contain` functions to verify that everything was rendered
    correctly. The `done` method of Mocha is used to finish the test.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`html`和`contain`函数来验证是否正确渲染了所有内容。使用Mocha的`done`方法来完成测试。
- en: Note
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a more detailed overview of the API and all the functions that Enzyme provides,
    have a look at the official documentation: [https://enzymejs.github.io/enzyme/docs/api/](https://enzymejs.github.io/enzyme/docs/api/).'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要获取API的更详细概述以及Enzyme提供的所有函数，请查看官方文档：[https://enzymejs.github.io/enzyme/docs/api/](https://enzymejs.github.io/enzyme/docs/api/)。
- en: 'This was the easy part. How does this work when we want to verify whether the
    client can send queries or mutations with authentication? It''s actually not that
    different. We already registered a new user and got a JWT in return. All we need
    to do is attach the JWT to our Apollo Client, and the router needs to receive
    the correct `loggedIn` property. The final code for this test looks like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分比较简单。当我们想要验证客户端是否可以发送带有身份验证的查询或突变时，这个过程实际上并没有那么不同。我们已注册了一个新用户并获得了JWT。我们只需要将JWT附加到我们的Apollo客户端上，并且路由器需要接收正确的`loggedIn`属性。这个测试的最终代码如下所示：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we are using the `AuthLink` function that we used in the original frontend
    code. We pass the `authToken` variable to every request that's made by the Apollo
    Client. In the `Apollo.from` method, we add it before `httpLink`. In the `Graphbook`
    class, we set `loggedIn` to `true` and `location` to `/app` to render the newsfeed.
    Because the requests are asynchronous by default and the `mount` method doesn't
    wait for the Apollo Client to fetch all queries, we couldn't directly check the
    DOM for the correct content. Instead, we wrapped the assertions and the `done`
    function in a `setTimeout` function. A timeout of 2,000 `currentUser` query has
    been run and the top bar has been rendered to show the logged-in user. With these
    two examples, you should now be able to run any test you want with your application's
    frontend code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用的是我们在原始前端代码中使用的`AuthLink`函数。我们将`authToken`变量传递给Apollo Client发出的每一个请求。在`Apollo.from`方法中，我们在`httpLink`之前添加它。在`Graphbook`类中，我们将`loggedIn`设置为`true`，将`location`设置为`/app`以渲染新闻源。由于请求默认是异步的，而`mount`方法不会等待Apollo
    Client获取所有查询，所以我们不能直接检查DOM以获取正确的内容。相反，我们将断言和`done`函数包裹在一个`setTimeout`函数中。运行了2,000毫秒的`currentUser`查询，并且顶栏已经渲染出来以显示已登录用户。通过这两个示例，你现在应该能够使用你的应用程序的前端代码运行任何你想要的测试。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned all the essential techniques to test your application
    automatically, including testing the server, the GraphQL API, and the user's frontend.
    You can apply the Mocha and Chai patterns you learned to other projects to reach
    a high software quality at any time. Your personal testing time will be greatly
    reduced.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了测试应用程序自动化的所有基本技术，包括测试服务器、GraphQL API和用户的客户端。你可以将你学到的Mocha和Chai模式应用到其他项目中，以在任何时候达到高软件质量。你的个人测试时间将大大减少。
- en: In the next chapter, we'll have a look at how to improve performance and error
    logging so that we're always providing a good **user experience** (**UX**).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何提高性能和错误日志记录，以确保我们始终提供良好的**用户体验**（**UX**）。
