- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing a Backend Using Express, Mongoose ODM, and Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After learning the basics of Node.js and MongoDB, we will now put them into
    practice by building our first backend service using Express to provide a REST
    API, Mongoose **object data modeling** (**ODM**) to interface with MongoDB, and
    Jest to test our code. We will first learn how to structure a backend project
    using an architectural pattern. Then, we will create database schemas using Mongoose.
    Next, we will make service functions to interface with the database schemas and
    write tests for them using Jest. Then, we will learn what REST is and when it
    is useful. Finally, we provide a REST API and serve it using Express. At the end
    of this chapter, we will have a working backend service to be consumed by a frontend
    developed in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a backend service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating database schemas using Mongoose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing and testing service functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a REST API using Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, please install all requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing for Full-stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  prefs: []
  type: TYPE_NORMAL
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If you are having an issue with the code and steps
    provided in this book, please try using the versions mentioned in *Chapters 1*
    and *2*.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for this chapter on GitHub at [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch3](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch3).
  prefs: []
  type: TYPE_NORMAL
- en: If you cloned the full repository for the book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git init` in the
    root of the corresponding chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for the chapter can be found at: [https://youtu.be/fFHVVVn03rc](https://youtu.be/fFHVVVn03rc).'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a backend service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To design our backend service, we are going to use a variation of an existing
    architectural pattern called **model–view–controller** (**MVC**) pattern. The
    MVC pattern consists of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: Handles data and basic data logic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: Controls how data is processed and displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: Displays the current state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In traditional full-stack applications, the backend would render and display
    the frontend completely, and an interaction would usually require a full-page
    refresh. The MVC architecture was designed mainly for such applications. However,
    in modern applications, the frontend is usually interactive and rendered in the
    backend only through server-side rendering. In modern applications, we thus often
    distinguish between the actual backend service(s) and the backend for frontend
    (which handles static site generation and server-side rendering):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – A modern full-stack architecture, with a single backend service
    and a frontend with server-side rendering (SSR) and static-site generation (SSG)](img/B19385_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – A modern full-stack architecture, with a single backend service
    and a frontend with server-side rendering (SSR) and static-site generation (SSG)
  prefs: []
  type: TYPE_NORMAL
- en: 'For modern applications, the idea is that the backend service only deals with
    processing and serving requests and data and does not render the user interface
    anymore. Instead, we have a separate application that handles the frontend and
    server-side rendering of user interfaces specifically. To adapt to this change,
    we adjust the MVC architectural pattern to a data-service-route pattern for the
    backend service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route layer**: Defines routes that consumers can access and handles user
    input by processing the request parameters and body and then calling service functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service layer**: Provides service functions, such as **create–read–update–delete**
    (**CRUD**) functions, which access the database through the data layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data layer**: Only deals with accessing the database and does basic validation
    to ensure that the database is consistent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This separation of concerns works best for services that only expose routes
    and do not deal with rendering user interfaces. Each layer in this pattern only
    deals with one step in processing the request.
  prefs: []
  type: TYPE_NORMAL
- en: After learning about the design of backend services, let’s get started creating
    a folder structure reflecting what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the folder structure for our backend service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now going to create a folder structure for our backend service based
    on this pattern. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, copy the **ch2** folder to a new **ch3** folder to create a new folder
    for our backend service, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the new **ch3** folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the **.eslintrc.json** file and replace the **browser** env with the **node**
    and **es6** env, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, *remove* the **react** and **jsx-a11y** plugins from the **.eslintrc.json**
    file. We can also remove the React-related **settings** and **overrides** now
    by removing the highlighted lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Delete* the **index.html** and **vite.config.js** files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now also *remove* the **vite.config.js** file from the **.****eslintignore**
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Delete* the **public**, **backend**, and **src** folders.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **ch3** folder in VS Code, open a Terminal and run the following commands
    to remove **vite** and **react**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the **package.json** file and *remove* the **dev**, **build**, and **preview**
    scripts from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, create a new **src/** folder, and within it, create **src/db/** (for the
    data layer), **src/services/** (for the services layer), and **src/routes/** (for
    the routes layer) folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our first application is going to be a blog application. For such an application,
    we are going to need the API to be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a list of posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a single post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update an existing post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete an existing post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To provide these functions, we first need to create a database schema to define
    what a blog post object should look like in our database. Then, we need service
    functions to handle CRUD functionality for blog posts. Finally, we are going to
    define our REST API to query, create, update, and delete blog posts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating database schemas using Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can get started defining the database schemas, we first need to set
    up Mongoose itself. Mongoose is a library that simplifies MongoDB object modeling
    by reducing the boilerplate code needed to interface with MongoDB. It also includes
    common business logic such as setting `createdAt` and `updatedAt` timestamps automatically
    and validation and type casting to keep the database state consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to set up the `mongoose` library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the **mongoose** library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **src/db/init.js** file and import **mongoose** there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define and export a function that will initialize the database connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we define **DATABASE_URL** to point to our local MongoDB instance running
    via Docker and specify **blog** as the database name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The connection string is similar to what we used in the previous chapter when
    directly accessing the database via Node.js.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, add a listener to the **open** event on the Mongoose connection so that
    we can show a log message once we are connected to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, use the **mongoose.connect()** function to connect to our MongoDB database
    and return the **connection** object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **src/example.js** file and import and run the **initDatabase**
    function there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the **src/example.js** file using Node.js to see Mongoose successfully
    connecting to our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As always, you can stop the server by pressing *Ctrl* + *C* in the Terminal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can see our log message being printed to the Terminal, so we know that Mongoose
    was able to successfully connect to our database! If there is an error, for example,
    because Docker (or the container) is not running, it will hang for a while and
    then throw an error about the connection being refused (`ECONNREFUSED`). In that
    case, make sure the Docker MongoDB container is running properly and can be connected
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a model for blog posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After initializing the database, the first thing we should do is define the
    data structure for blog posts. Blog posts in our system should have a title, an
    author, contents, and some tags associated with the post. Follow these steps to
    define the data structure for blog posts:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/db/models/** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside that folder, create a new **src/db/models/post.js** file, import the
    **mongoose** and the **Schema** classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new schema for posts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now specify all properties of a blog post and the corresponding types. We have
    a required **title**, an **author**, and **contents**, which are all strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we have **tags**, which are a string array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have defined the schema, we can create a Mongoose model from it
    by using the **mongoose.model()** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to **mongoose.model()** specifies the name of the collection.
    In our case, the collection will be called **posts** because we specified **post**
    as the name. In Mongoose models, we need to specify the name of the document in
    singular form.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined the data structure and model for blog posts, we can
    start using it to create and query posts.
  prefs: []
  type: TYPE_NORMAL
- en: Using the blog post model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating our model, let’s try using it! For now, we are simply going
    to access it in the `src/example.js` file because we have not defined any service
    functions or routes yet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the **Post** model in the **src/example.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The **initDatabase()** function we defined earlier is an **async** function,
    so we need to **await** it; otherwise, we would be attempting to access the database
    before we are connected to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new blog post by calling **new Post()**, defining some example data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call **.save()** on the blog post to save it to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can use the **.find()** function to list all posts, and log the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the example script to see our post being inserted and listed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get the following result after running the preceding script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Our first document inserted via Mongoose!](img/B19385_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Our first document inserted via Mongoose!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, using Mongoose is very similar to using MongoDB directly. However,
    it offers us some wrappers around models for convenience, making it easier to
    deal with documents.
  prefs: []
  type: TYPE_NORMAL
- en: Defining creation and last update dates in the blog post
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that we have not added any dates to our blog post. So,
    we do not know when a blog post is created or when it was last updated. Mongoose
    makes implementing such functionality simple, let’s try it out now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the **src/db/models/post.js** file and add a second argument to the **new
    Schema()** constructor. The second argument specifies options for the schema.
    Here, we set the **timestamps:** **true** setting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now all we need to do is create a new blog post by running the example script,
    and we will see that the last post inserted now has **createdAt** and **updatedAt**
    timestamps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see if the **updatedAt** timestamp works, let’s try updating the created
    blog post by using the **findByIdAndUpdate** method. Save the result of **await
    post.save()** in a **createdPost** constant, then add the following code close
    to the end of the **src/example.js** file, before the **Post.find()** call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the server again to see the blog posts being updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get three posts, and the last one of them now looks as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Our updated document with the automatically updated timestamps](img/B19385_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Our updated document with the automatically updated timestamps
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, using Mongoose makes dealing with MongoDB documents much more
    convenient! Now that we have defined our database model, let’s start developing
    (and writing tests for) service functions!
  prefs: []
  type: TYPE_NORMAL
- en: Developing and testing service functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have always been testing code by putting it in the `src/example.js`
    file. Now, we are going to write some service functions and learn how to write
    actual tests for them by using Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the test environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we are going to set up our test environment by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install **jest** and **mongodb-memory-server** as dev dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a **src/test/** folder to put the setup for our tests in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this folder, create a **src/test/globalSetup.js** file, where we will import
    **MongoMemoryServer** from the previously installed library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now define a **globalSetup** function, which creates a memory server for MongoDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When creating the **MongoMemoryServer**, set the binary version to **6.0.4**,
    which is the same version that we installed for our Docker container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will store the MongoDB instance as a global variable to be able to access
    it later in the **globalTeardown** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also store the URL to connect to our test instance in the **DATABASE_URL**
    environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/db/init.js** and adjust the **DATABASE_URL** to come from the environment
    variable so that our tests will be using the correct database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, create a **src/test/globalTeardown.js** file to stop the MongoDB
    instance when our tests are finished and add the following code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a **src/test/setupFileAfterEnv.js** file. Here, we will define
    a **beforeAll** function to initialize our database connection in Mongoose before
    all tests run and an **afterAll** function to disconnect from the database after
    all tests finish running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a new **jest.config.json** file in the root of our project where
    we will define the config for our tests. In the **jest.config.json** file, we
    first set the test environment to **node**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, tell Jest to use the **globalSetup**, **globalTeardown**, and **setupFileAfterEnv**
    files we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this case, **<rootDir>** is a special string that automatically gets resolved
    to the root directory by Jest. You do not need to manually fill in a root directory
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, edit the **package.json** file and add a **test** script, which will
    run Jest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the JavaScript ecosystem is still in the process of
    moving to the **ECMAScript module** (**ESM**) standard. In this book, we already
    use this new standard. However, Jest does not support it yet by default, so we
    need to pass the **--experimental-vm-modules** option when running Jest.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we attempt running this script now, we will see that there are no tests
    found, but we can still see that Jest is set up and working properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 3.4 – Jest is set up successfully, but we have not defined any tests
    yet](img/B19385_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Jest is set up successfully, but we have not defined any tests
    yet
  prefs: []
  type: TYPE_NORMAL
- en: Now that our test environment is set up, we can start writing our service functions
    and unit tests. It is always a good idea to write unit tests right after writing
    service functions, as it means we will be able to debug them right away while
    still having their intended behavior fresh in our minds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing our first service function: createPost'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our first service function, we are going to make a function to create a
    new post. We can then write tests for it by verifying that the create function
    creates a new post with the specified properties. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/services/posts.js** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **src/services/posts.js** file, first import the **Post** model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new **createPost** function, which takes an object with **title**,
    **author**, **contents**, and **tags** as arguments and creates and returns a
    new post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We specifically listed all properties that we want the user to be able to provide
    here instead of simply passing the whole object to the `new Post()` constructor.
    While we need to type more code this way, it allows us to have control over which
    properties a user should be able to set. For example, if we later add permissions
    to the database models, we may be accidentally allowing users to set those permissions
    here, if we forget to exclude those properties. For those security reasons, it
    is always good practice to have a list of allowed properties instead of simply
    passing down the whole object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After writing our first service function, let’s continue by writing test cases
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining test cases for the createPost service function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test if the `createPost` function works as expected, we are going to define
    unit test cases for it using Jest:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/__tests__/** folder, which will contain all test definitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, test files can also be co-located with the related files that
    they are testing. However, in this book, we use the **__tests__** directory to
    make it easier to distinguish tests from other files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **src/__tests__/posts.test.js** file for our tests related to
    posts. In this file, start by importing **mongoose** and the **describe**, **expect**,
    and **test** functions from **@jest/globals**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also import the **createPost** function from our services and the **Post**
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, use the **describe()** function to define a new test. This function describes
    a group of tests. We can call our group **creating posts**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the group, we will define a test by using the **test()** function. We
    can pass an **async** function here to be able to use async/await syntax. We call
    the first test **creating posts with all parameters** **should succeed**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this test, we will use the **createPost** function to create a new post
    with some parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, verify that it returns a post with an ID by using the **expect()** function
    from Jest and the **toBeInstanceOf** matcher to verify that it is an **ObjectId**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now use Mongoose directly to find the post with the given ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We **expect()** the **foundPost** to equal an object containing at least the
    properties of the original post object we defined. Additionally, we expect the
    created post to have **createdAt** and **updatedAt** timestamps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, define a second test, called **creating posts without title should
    fail**. As we defined the **title** to be required, it should not be possible
    to create a post without one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a **try**/**catch** construct to catch the error and **expect()** the error
    to be a Mongoose **ValidationError**, which tells us that the title is required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, make a test called **creating posts with minimal parameters should
    succeed** and only enter the **title**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have defined our tests, run the script we defined earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, using unit tests we can do isolated tests on our service functions
    without having to define and manually access routes or write some manual test
    setups. These tests also have the added advantage that when we change code later,
    we can ensure that the previously defined behavior did not change by re-running
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a function to list posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After defining a function to create posts, we are now going to define an internal
    `listPosts` function, which allows us to query posts and define a sort order.
    Then, we are going to use this function to define `listAllPosts`, `listPostsByAuthor`,
    and `listPostsByTag` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `query` and an `options` argument (with `sortBy` and `sortOrder` properties).
    With `sortBy`, we can define which field we want to sort by, and the `sortOrder`
    argument allows us to specify whether posts should be sorted in ascending or descending
    order. By default, we list all posts (empty object as query) and show the newest
    posts first (sorted by `createdAt`, in `descending` order):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use the **.find()** method from our Mongoose model to list all posts,
    passing an argument to sort them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can define a function to list all posts, which simply passes an empty
    object as query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, we can create a function to list all posts by a certain author by
    passing **author** to the query object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, define a function to list posts by tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In MongoDB, we can simply match strings in an array by matching the string
    as if it was a single value, so all we need to do is add a query for `tags: ''nodejs''`.
    MongoDB will then return all documents that have a `''nodejs''` string in their
    `tags` array.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The **{ [variable]: … }** operator resolves the string stored in the **variable**
    to a key name for the created object. So, if our variable contains **''createdAt''**,
    the resulting object will be **{ createdAt: … }**.'
  prefs: []
  type: TYPE_NORMAL
- en: After defining the list post function, let’s also write test cases for it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining test cases for list posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defining test cases for list posts is similar to create posts. However, we
    now need to create an initial state where we already have some posts in the database
    to be able to test the list functions. We can do this by using the `beforeEach()`
    function, which executes some code before each test case is executed. We can use
    the `beforeEach()` function for a whole test file or only run it for each test
    inside a `describe()` group. In our case, we are going to define it for the whole
    file, as the sample posts will come in handy when we test the delete post function
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the **src/__tests__/posts.js** file, adjust the **import** statement to
    import the **beforeEach** function from **@jest/globals** and import the various
    functions to list posts from our services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the file, define an array of sample posts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define an empty array, which will be populated with the created posts.
    Then, define a **beforeEach** function, which first clears all posts from the
    database and clears the array of created sample posts and then creates the sample
    posts in the database again for each of the posts defined in the array earlier.
    This ensures that we have a consistent state of the database before each test
    case runs and that we have an array to compare against when testing the list post
    functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To ensure that our unit tests are modular and independent from each other, we
    insert posts into the database directly by using Mongoose functions (instead of
    the `createPost` function).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have some sample posts ready, let’s write our first test case,
    which should simply list all posts. We will define a new test group for **listing
    posts** and a test to verify that all sample posts are listed by the **listAllPosts()**
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, make a test that verifies that the default sort order shows newest posts
    first. We sort the **createdSamplePosts** array manually by **createdAt** (descending)
    and then compare the sorted dates to those returned from the **listAllPosts()**
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The **.map()** function applies a function to each element of an array and returns
    the result. In our case, we select the **createdAt** property from all elements
    of the array. We cannot directly compare the arrays with each other because Mongoose
    returns documents with a lot of additional information in hidden metadata, which
    Jest will attempt to compare.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, define a test case where the **sortBy** value is changed to **updatedAt**,
    and the **sortOrder** value is changed to **ascending** (showing oldest updated
    posts first):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add a test to ensure that listing posts by author works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are controlling the test environment by creating a specific set of sample
    posts before each test case runs. We can make use of this controlled environment
    to simplify our tests. As we already know that there are only three posts with
    that author, we can simply check if the function returned exactly three posts.
    Doing so keeps our tests simple, and they are still safe because we control the
    environment completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add a test to verify that listing posts by tag works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the tests again and watch them all pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 3.5 – All our tests passing successfully!](img/B19385_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – All our tests passing successfully!
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, for some tests, we need to prepare an initial state. In our case,
    we only had to create some posts, but this initial state may become more sophisticated.
    For example, on a more advanced blogging platform, it may be necessary to create
    a user account first, then create a blog on the platform, and then create blog
    posts for that blog. In that case, we could create test utility functions, such
    as `createTestUser`, `createTestBlog`, `createTestPost` and import them in our
    tests. We can then use these functions in `beforeEach()` across multiple test
    files instead of manually doing it every single time. Depending on your application
    structure, different test utility functions may be needed, so feel free to define
    them as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the test cases for the list posts function, let’s continue by
    defining the get single post, update post, and delete post functions.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the get single post, update and delete post functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The get single post, update and delete post functions can be defined very similarly
    to the list posts function. Let’s do that quickly now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the **src/services/posts.js** file and define a **getPostById** function
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It may seem a bit trivial to define a service function that just calls `Post.findById`,
    but it is good practice to define it anyway. Later, we may want to add some additional
    restrictions, such as access control. Having the service function allows us to
    change it only in one place and we do not have to worry about forgetting to add
    it somewhere. Another benefit is that if we, for example, want to change the database
    provider later, the developer only needs to worry about getting the service functions
    working again, and they can be verified with the test cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same file, define the **updatePost** function. It will take an ID of
    an existing post, and an object of parameters to be updated. We are going to use
    the **findOneAndUpdate** function from Mongoose, together with the **$set** operator,
    to change the specified parameters. As a third argument, we provide an options
    object with **new: true** so that the function returns the modified object instead
    of the original:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, also define a **deletePost** function, which simply takes
    the ID of an existing post and deletes it from the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your application, you may want to set a **deletedOn** timestamp
    instead of deleting it right away. Then, set up a function that gets all documents
    that have been deleted for more than 30 days and delete them. Of course, this
    means that we need to always filter out already deleted posts in the **listPosts**
    function and that we need to write test cases for this behavior!
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the **src/__tests__/posts.js** file and import the **getPostById** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add tests for getting a post by ID and failing to get a post because the ID
    did not exist in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the first test, we use`.toObject()` to convert the Mongoose object with all
    its internal properties and metadata to a **plain old JavaScript object** (**POJO**)
    so that we can compare it to the sample post object by comparing all properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, import the **updatePost** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add tests for updating a post successfully. We add one test to verify
    that the specified property was changed and another test to verify that it does
    not interfere with other properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, add a test to ensure the **updatedAt** timestamp was updated.
    To do so, first convert the **Date** objects to numbers by using **.getTime()**,
    and then we can compare them by using the **expect(…).toBeGreaterThan(…)** matcher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also add a failing test to see if the **updatePost** function returns **null**
    when no post with a matching ID was found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, import the **deletePost** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add tests for successful and unsuccessful deletes by checking if the
    post was deleted and verifying the returned **deletedCount**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, run all tests again; they should all pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Writing tests for service functions may be tedious, but it will save us a lot
    of time in the long run. Adding additional functionality later, such as access
    control, may change the basic behavior of the service functions. By having the
    unit tests, we can ensure that we do not break existing behavior when adding new
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Jest VS Code extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up until now, we have run our tests by using Jest via the Terminal. There is
    also a Jest extension for VS Code, which we can use to make running tests more
    visual. The extension is especially helpful for larger projects where we have
    many tests in multiple files. Additionally, the extension can automatically watch
    and re-run tests if we change the definitions. We can install the extension as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Extensions** tab in the VS Code sidebar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **Orta.vscode-jest** in the search box to find the Jest extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the extension by pressing the **Install** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now go to the newly added test icon on the sidebar (it should be a chemistry
    flask icon):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The Testing tab in VS Code provided by the Jest extension](img/B19385_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – The Testing tab in VS Code provided by the Jest extension
  prefs: []
  type: TYPE_NORMAL
- en: The Jest extension provides us an overview of all tests that we have defined.
    We can hover over them and press on the **Play** icon to re-run a specific test.
    By default, the Jest extension enables **auto-run-watch** (as can be seen in *Figure
    3**.6*). If **auto-run-watch** is enabled, the extension will re-run tests automatically
    when test definition files are saved. That’s pretty handy!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined and tested our service functions, we can start using
    them when defining routes, which we are going to do next!
  prefs: []
  type: TYPE_NORMAL
- en: Providing a REST API using Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having our data and service layers set up, we have a good framework for being
    able to write our backend. However, we still need an interface that lets users
    access our backend. This interface will be a **representational state transfer**
    (**REST**) API. A REST API provides a way to access our server via HTTP requests,
    which we can make use of when we develop our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The interaction between client and server using HTTP requests](img/B19385_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The interaction between client and server using HTTP requests
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, clients can send requests to our backend server, and the server
    will respond to them. There are five commonly used methods in a REST-based architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET**: This is used to read resources. Generally, it should not influence
    the database state and, given the same input, it should return the same output
    (unless the database state was changed through other requests). This behavior
    is called **idempotence**. In response to a successful GET request, a server usually
    returns the resource(s) with a 200 OK status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST**: This is used to create new resources, from the information provided
    in the request body. In response to a successful POST request, a server usually
    either returns the newly created object with a 201 Created status code or returns
    an empty response (with 201 Created status code) with a URL in the **Location**
    header that points to the newly created resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PUT**: This is used to update an existing resource with a given ID, replacing
    the resource completely with the new data provided in the request body. In some
    cases, it can also be used to create a new resource with a client-specified ID.
    In response to a successful PUT request, a server either returns the updated resource
    with a 200 OK status code, 204 No Content if it does not return the updated resource,
    or 201 Created if it created a new resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PATCH**: This is used to modify an existing resource with a given ID, only
    updating the fields specified in the request body instead of replacing the whole
    resource. In response to a successful PATCH request, a server either returns the
    updated resource with 200 OK or 204 No Content if it does not return the updated
    resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE**: This is used to delete a resource with a given ID. In response
    to a successful DELETE request, a server either returns the deleted resource with
    200 OK or 204 No Content if it does not return the deleted resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP REST API routes are usually defined in a folder-like structure. It is always
    a good idea to prefix all routes with `/api/v1/` (`v1` being the version of the
    API definition, starting with `1`). If we want to change the API definition later,
    we can then easily run `/api/v1/` and `/api/v2/` in parallel for a while until
    everything is migrated.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our API routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have learned how HTTP REST APIs work, let’s start by defining routes
    for our backend, covering all functionality we have already implemented in the
    service functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET /api/v1/posts**: Get a list of all posts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GET /api/v1/posts?sortBy=updatedAt&sortOrder=ascending**: Get a list of all
    posts sorted by **updatedAt** (ascending)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Everything after the **?** symbol is called a query string and follows the format
    **key1=value1&key2=value2&…**. The query string can be used to provide additional
    optional parameters to a route.
  prefs: []
  type: TYPE_NORMAL
- en: '**GET /api/v1/posts?author=daniel**: Get a list of posts by author “daniel”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GET /api/v1/posts?tag=react**: Get a list of posts with the tag **react**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GET /api/v1/posts/:id**: Get a single post by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST /api/v1/posts**: Create a new post'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PATCH /api/v1/posts/:id**: Update an existing post by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE /api/v1/posts/:id**: Delete an existing post by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, by putting together our already developed service functions and
    what we have learned about REST APIs, we can easily define routes for our backend.
    Now that we have defined our routes, let’s set up Express and our backend server
    to be able to expose those routes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is just one example of how a REST API can be designed. It is intended as
    an example to get you started with full-stack development. Later, on your own
    time, feel free to check out other resources, such as [https://standards.rest](https://standards.rest),
    to deepen your knowledge of REST API designs.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Express is a web application framework for Node.js. It provides utility functions
    to easily define routes for REST APIs and serve HTTP servers. Express is also
    very extensible, and there are many plugins for it in the JavaScript ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While Express is the most well-known framework at the time of writing, there
    are also newer ones, such as Koa ([https://koajs.com](https://koajs.com)) or Fastify
    ([https://fastify.dev](https://fastify.dev)). Koa is designed by the team behind
    Express but aims to be smaller, more expressive, and more robust. Fastify focuses
    on efficiency and low overhead. Feel free to check these out on your own time
    to see if they fit your requirements better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can set up the routes, let’s take some time to set up our Express
    application and backend server by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the **express** dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **src/app.js** file. This file will contain everything needed
    to set up our Express app. In this file, first import **express**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then create a new Express app, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can define routes on the Express app. For example, to define a GET route,
    we can write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We export the app to be able to use it in other files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to create a server and specify a port, similar to what we did
    before when creating an HTTP server. To do so, we create a new **src/index.js**
    file. In this file, we import the Express app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define a port, make the Express app listen to it, and log a message
    telling us where the server is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **package.json** and add a **start** script to run our server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the backend server by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, navigate to **http://localhost:3000/** in your browser and you will see
    **Hello from Express!** Being printed, just like before with the plain http server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Accessing our first Express app from the browser!](img/B19385_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Accessing our first Express app from the browser!
  prefs: []
  type: TYPE_NORMAL
- en: That’s all there is to setting up a simple Express app! We can now keep defining
    routes by using `app.get()` for GET routes, `app.post()` for POST routes, etc.
    However, before we start developing our routes, let’s take some time to improve
    our development environment. First, we should make `PORT` and `DATABASE_URL` configurable
    so that we can change them without having to change the code. To do so, we are
    going to use environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Using dotenv for setting environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A good way to load environment variables is using `dotenv`, which loads environment
    variables from `.env` files into our `process.env`. This makes it easy to define
    environment variables for local development while keeping it possible to set them
    differently in, for example, a testing environment. Follow these steps to set
    up `dotenv`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the **dotenv** dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/index.js**, import **dotenv** there, and call **dotenv.config()**
    to initialize the environment variables. We should do this before we call any
    other code in our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can start replacing our static variables with environment variables.
    Edit **src/index.js** and replace the static port **3000** with **process.env.PORT**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have already migrated the **initDatabase** function to use **process.env.DATABASE_URL**
    earlier when we set up Jest. Now, we can edit **src/index.js** and import **initDatabase**
    there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Adjust the existing code to first call **initDatabase**, and only when the
    database initialized, start the Express app. We can now also handle errors while
    connecting to the database by adding a try/catch block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create a **.env** file in the root of the project and define the two
    environment variables there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should exclude the **.env** file from the Git repository, as it is only
    used for local development. Edit **.gitignore** and add **.env** to it in a new
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the moment, we have no sensible information in our environment variables,
    but it is still a good practice to do this already now. Later, we may have some
    credentials in the environment variables, which we do not want to accidentally
    push to a Git repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To make it easier for someone to get started with our project, we can create
    a copy of our **.env** file and duplicate it to **.env.template**, making sure
    that it does not contain any sensitive credentials, of course! Sensitive credentials
    could instead be stored in, for example, a shared password manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If it is still running from before, stop the server (by pressing *Ctrl* + *C*
    in the Terminal) and start it again as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Initializing the database connection and the Express server
    with environment variables](img/B19385_03_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Initializing the database connection and the Express server with
    environment variables
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, `dotenv` makes it easy to maintain environment variables for
    development while still allowing us the possibility to change them in a continuous
    integration, testing, or production environment.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we need to manually restart the server after making
    some changes. This is a stark contrast to the hot reloading we got out of the
    box from Vite, where any changes we make are applied to the frontend in the browser
    instantly. Let’s now spend some time to improve the development experience by
    making the server auto-restart on changes.
  prefs: []
  type: TYPE_NORMAL
- en: Using nodemon for easier development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make our server auto-restart on changes, we can use the `nodemon` tool. The
    `nodemon` tool allows us to run our server, similarly to the node CLI command.
    However, it offers the possibility to auto-restart the server on changes to the
    source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the **nodemon** tool as a dev dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **nodemon.json** file in the root of your project and add the
    following contents to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This makes sure that all code in the `src/` folder is watched for changes, and
    it will refresh if any files inside it are changed. Additionally, we specified
    the `.env` file in case environment variables are changed and the `package-lock.json`
    file in case packages are added or upgraded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, edit **package.json** and define a new **"dev"** script that runs **nodemon**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Stop the server (if it is currently running) and start it again by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we can see, our server is now running through **nodemon**! We can try it
    out by changing the port in the **.****env** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **.env.template** as well to change the port to **3001**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Keep the server running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Nodemon automatically restarting the server after we changed
    the port](img/B19385_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Nodemon automatically restarting the server after we changed the
    port
  prefs: []
  type: TYPE_NORMAL
- en: After making the change, `nodemon` automatically restarted the server for us
    with the new port. We now have something like hot reloading, but for backend development—awesome!
    Now that we have improved the developer experience on the backend, let’s start
    writing our API routes with Express. Keep the server running (via `nodemon`) to
    see it restart and update live while coding!
  prefs: []
  type: TYPE_NORMAL
- en: Creating our API routes with Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now start creating our previously defined API routes with express. We
    start by defining the GET routes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **src/routes/posts.js** file and import the service functions
    there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create and export a new function called **postsRoutes**, which takes the
    Express app as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this function, define the routes. Start with the **GET /****api/v1/posts**
    route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this route, we need to make use of query params (**req.query** in Express)
    to map them to the arguments of our functions. We want to be able to add query
    params for **sortBy**, **sortOrder**, **author**, and **tag**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we call our service functions, which might throw an error if we pass
    invalid data to the database functions, we should add a try-catch block to handle
    potential errors properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to check if the **author** or **tag** was provided. If both were
    provided, we return a **400 Bad Request** status code and a JSON object with an
    error message by calling **res.json()**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Otherwise, we call the respective service function and return a JSON response
    in Express by calling **res.json()**. In case an error happened, we catch it,
    log it, and return a 500 status code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define an API route to get a single post. We use the **:id** param
    placeholder to be able to access it as a dynamic parameter in the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can access **req.params.id** to get the **:id** part of our route and
    pass it to our service function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the result of the function is **null**, we return a 404 response because
    the post was not found. Otherwise, we return the post as a JSON response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, Express will return the JSON response with status 200 OK.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After defining our GET routes, we still need to mount them in our app. Edit
    **src/app.js** and import the **postsRoutes** function there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, call the **postsRoutes(app)** function after initializing our Express
    app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to http://localhost:3001/api/v1/posts to see the route in action!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Our first real API route in action!](img/B19385_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Our first real API route in action!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can install a **JSON Formatter** extension in your browser to format the
    JSON response nicely, like in *Figure 3**.11*.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the GET routes, we need to define the POST routes. However, these
    accept a body, which will be formatted as JSON objects. As such, we need a way
    to parse this JSON body in Express.
  prefs: []
  type: TYPE_NORMAL
- en: Defining routes with a JSON request body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To define routes with a JSON request body in Express, we need to use the `body-parser`
    module. This module detects if a client sent a JSON request (by looking at the
    `Content-Type` header) and then automatically parses it for us so that we can
    access the object in `req.body`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the **body-parser** dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/app.js** and import the **body-parser** there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the following code after our app is initialized to load the **body-parser**
    plugin as middleware into our Express app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Middleware in Express allows us to do something before and after each request.
    In this case, **body-parser** is reading the JSON body for us, parsing it as JSON
    and giving us a JavaScript object that we can easily access from our route definitions.
    It should be noted that only routes defined after the middleware have access to
    it, so the order of defining middleware and routes is important!
  prefs: []
  type: TYPE_NORMAL
- en: 'After loading the **body-parser**, we edit **src/routes/posts.js** and import
    the service functions needed to make the rest of our routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define the **POST /api/v1/posts** route by using **app.post** and **req.body**,
    inside of the **postsRoutes** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, we can define the update route, where we need to make use of the
    **id** param and the request body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we define the delete route, which does not require the **body-parser**;
    we just need to get the **id** param here. We return 404 if the post was not found,
    and 204 No Content if the post was deleted successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, Express makes defining and handling routes, requests, and responses
    much easier. It already detects and sets headers for us, and thus it can read
    and send JSON responses properly. It also allows us to change the HTTP status
    code easily.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we finished defining the routes with a JSON request body, let’s allow
    access to our routes from other URLs using **cross-origin resource** **sharing**
    (**CORS**).
  prefs: []
  type: TYPE_NORMAL
- en: Allowing access from other URLs using CORS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Browsers have a safety feature to only allow us to access APIs on the same
    URL as the page we are currently on. To allow access to our backend from other
    URLs than the backend URL itself (for example, when we run the frontend on a different
    port in the next chapter), we need to allow CORS requests. Let’s set that up now
    by using the `cors` library with Express:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the **cors** dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/app.js** and import **cors** there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the following code after our app is initialized to load the **cors**
    plugin as middleware into our Express app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that CORS requests are allowed, we can start trying out the routes in a
    browser!
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After defining our routes, we can try them out by using the `fetch()` function
    in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: In your browser, go to **http://localhost:3001/**, open the console by right-clicking
    on a page and clicking **Inspect**, then go to the **Console** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the console, enter the following code to make a GET request to get all posts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can modify this code to make a POST request by specifying the **Content-Type**
    header to tell the server that we will be sending JSON and then sending a body
    with **JSON.stringify** (as the body has to be a string):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, we can also send a **PATCH** request, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace the MongoDB IDs in the URL with the one returned from the
    `POST` request made before!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can send a **DELETE** request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When doing a GET request, we can see that our post has now been deleted again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This request should now return a `404`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the browser console, you can also use command line tools such as
    **curl** or apps such as Postman to make the requests. Feel free to use different
    tools to try out the requests if you are already familiar with them.
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully defined all routes needed to handle a simple blog post
    API!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first version of our backend service is now complete, allowing us to create,
    read, update, and delete blog posts via a REST API (using Express), which then
    get stored in a MongoDB database (using Mongoose). Additionally, we have created
    service functions with unit tests, defined using the Jest test suite. All in all,
    we managed to create a solid foundation for our backend in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 4*](B19385_04.xhtml#_idTextAnchor076), *Integrating
    a Frontend Using React and TanStack Query*, we are going to integrate our backend
    into a React frontend using TanStack Query, a library to handle asynchronous state
    and thus data fetched from our server. This means that, after the next chapter,
    we will have developed our first full-stack application!
  prefs: []
  type: TYPE_NORMAL
