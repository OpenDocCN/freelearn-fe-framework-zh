<html><head></head><body>
<div id="_idContainer044">
<h1 class="chapter-number" id="_idParaDest-109"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-110"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.2.1">Using React Query for Server-Side-Driven State Management</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Welcome, my dear reader, to the last chapter describing state management solutions for our Funbook app. </span><span class="koboSpan" id="kobo.3.2">In the previous chapter, we looked at the youngest state management library (as of the writing of this book) – </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Jotai</span></strong><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">Jotai is a minimal solution, based on ideas proposed by the </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Facebook</span></strong><span class="koboSpan" id="kobo.7.1"> team in their open source library – </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Recoil</span></strong><span class="koboSpan" id="kobo.9.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">React</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.11.1">Query</span></strong><span class="koboSpan" id="kobo.12.1"> is minimal as well but in a very different sense. </span><span class="koboSpan" id="kobo.12.2">React Query is created for managing fetching and mutating data on the server. </span><span class="koboSpan" id="kobo.12.3">In this chapter, we will look at what React Query has to offer. </span><span class="koboSpan" id="kobo.12.4">We will start by taking a broad look at this library; we will then implement it for data fetching. </span><span class="koboSpan" id="kobo.12.5">With our current app setup, we don’t have a real backend server to communicate with, so we can only look at mutating data in theory. </span><span class="koboSpan" id="kobo.12.6">We will also look at a few specialized utilities created for </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">React</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.14.1">Native</span></strong><span class="koboSpan" id="kobo.15.1"> by the React </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Query team.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">Here’s a list of topics we will cover in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">What is React Query and why is it in </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">this book?</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Installing and configuring </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">React Query</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Using React Query for </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">data fetching</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Other React </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Query functionalities</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">React Query utilities for </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">React Native</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">By the end of this chapter, you will have a good understanding of how you can use React Query to improve your developer experience and your code bases. </span><span class="koboSpan" id="kobo.29.2">You will have a good knowledge of how to handle fetching data with React Query and a general knowledge of other functionalities of </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">this library.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.31.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.32.1">In order to follow along with this chapter, you will need some knowledge of </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">JavaScript</span></strong><span class="koboSpan" id="kobo.34.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">ReactJS</span></strong><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">If you have followed at least </span><em class="italic"><span class="koboSpan" id="kobo.37.1">Chapters 1</span></em><span class="koboSpan" id="kobo.38.1"> through </span><em class="italic"><span class="koboSpan" id="kobo.39.1">4</span></em><span class="koboSpan" id="kobo.40.1"> of this book, you should be able to go forward without </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">any issues.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">Feel free to use an IDE of your choice, as </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">React</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.44.1">Native</span></strong><span class="koboSpan" id="kobo.45.1"> does not need any specific functionality. </span><span class="koboSpan" id="kobo.45.2">Currently, the most popular IDEs for frontend developers are Microsoft’s VSCode, Atom, Sublime Text, </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">and WebStorm.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">The code snippets provided in this chapter are here to illustrate what we should be doing with the code. </span><span class="koboSpan" id="kobo.47.2">They do not provide the whole picture. </span><span class="koboSpan" id="kobo.47.3">For a better experience while coding alongside reading this chapter, please open the GitHub repo in your IDE and look at the files in there. </span><span class="koboSpan" id="kobo.47.4">You can either start with the files in the folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">example-app-full</span></strong><span class="koboSpan" id="kobo.49.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">chapter-9</span></strong><span class="koboSpan" id="kobo.51.1"> If you start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">example-app-full</span></strong><span class="koboSpan" id="kobo.53.1"> you will be responsible for implementing the solutions described in this chapter. </span><span class="koboSpan" id="kobo.53.2">If you choose to look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">chapter-9</span></strong><span class="koboSpan" id="kobo.55.1"> you will see the entire solution implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">by me.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">If you get stuck or lost, you can check the code in the GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">repo: </span></span><a href="https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-9"><span class="No-Break"><span class="koboSpan" id="kobo.59.1">https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-9</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.60.1">.</span></span></p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.61.1">What is React Query and why is it in this book?</span></h1>
<p><span class="koboSpan" id="kobo.62.1">First things first: let’s talk about the name of this library. </span><span class="koboSpan" id="kobo.62.2">In this chapter, I use the name React Query, it is also </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.63.1">a commonly used name. </span><span class="koboSpan" id="kobo.63.2">However, the creator of React Query, </span><em class="italic"><span class="koboSpan" id="kobo.64.1">Tanner Linsley</span></em><span class="koboSpan" id="kobo.65.1">, did some restructuring in 2022, in the open source libraries that he owns and maintains. </span><span class="koboSpan" id="kobo.65.2">He created an umbrella name, </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">TanStack</span></strong><span class="koboSpan" id="kobo.67.1">, and placed a plethora of libraries </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.68.1">under this name. </span><span class="koboSpan" id="kobo.68.2">And so, React Query became TanStack Query, as of React Query version 4. </span><span class="koboSpan" id="kobo.68.3">You can find a link to the TanStack home page in the </span><em class="italic"><span class="koboSpan" id="kobo.69.1">Further reading</span></em><span class="koboSpan" id="kobo.70.1"> section at end of </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">Now that we have the name out of the way, let’s talk about the place of React Query in this book. </span><span class="koboSpan" id="kobo.72.2">React Query is </span><em class="italic"><span class="koboSpan" id="kobo.73.1">not</span></em><span class="koboSpan" id="kobo.74.1"> a state management library. </span><span class="koboSpan" id="kobo.74.2">It’s a library offering a solution for comfortable fetching and data mutations on the server. </span><span class="koboSpan" id="kobo.74.3">Why are we talking about it then? </span><span class="koboSpan" id="kobo.74.4">Because it turns out that efficient communication with the server can replace any need for global state management. </span><span class="koboSpan" id="kobo.74.5">Given our real-life social media app clone, we’ve been managing liked images in every chapter. </span><span class="koboSpan" id="kobo.74.6">What if, instead of working with the app state, every time a user likes an image, we sent that information to the server? </span><span class="koboSpan" id="kobo.74.7">Or when the user visits the </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">FavoritedImages</span></strong><span class="koboSpan" id="kobo.76.1"> surface we pull the latest version of the list from the server? </span><span class="koboSpan" id="kobo.76.2">You may think: “Boy, that would be a lot of requests! </span><span class="koboSpan" id="kobo.76.3">A lot of loading states and </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.77.1">the app being useless…” And you would be right! </span><span class="koboSpan" id="kobo.77.2">Except if you use React Query. </span><span class="koboSpan" id="kobo.77.3">React Query not only facilitates data fetching, but it also manages cached values, refreshing values, background fetching, and </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">much more.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Now that we have a theoretical understanding of what React Query is, we can get to coding. </span><span class="koboSpan" id="kobo.79.2">Let’s play with this </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">non-state-management library.</span></span></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.81.1">Installing and configuring React Query</span></h1>
<p><span class="koboSpan" id="kobo.82.1">Installing this </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.83.1">library is no different from any other dependency, we </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.84.1">need to run an installation script. </span><span class="koboSpan" id="kobo.84.2">To do this using </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">npm</span></strong><span class="koboSpan" id="kobo.86.1">, enter </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.88.1">
$ npm i @tanstack/react-query</span></pre>
<p><span class="koboSpan" id="kobo.89.1">Or if you would prefer to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">yarn</span></strong><span class="koboSpan" id="kobo.91.1">, enter </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.93.1">
$ yarn add @tanstack/react-query</span></pre>
<p><span class="koboSpan" id="kobo.94.1">Once the library is installed, we will need to add some minimal boilerplate. </span><span class="koboSpan" id="kobo.94.2">We will need to let our app know that we’re using React Query. </span><span class="koboSpan" id="kobo.94.3">We will need to use a special wrapper. </span><span class="koboSpan" id="kobo.94.4">Do you see where I’m going with this? </span><span class="koboSpan" id="kobo.94.5">Yes! </span><span class="koboSpan" id="kobo.94.6">We will use a provider </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.96.1">
// App.js
import {
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'
//…
const queryClient = new QueryClient()
export default function App() {
//…
  return (
    &lt;SafeAreaProvider&gt;
    &lt;QueryClientProvider client={queryClient}&gt;
//…
       &lt;/QueryClientProvider&gt;
    &lt;/SafeAreaProvider&gt;
  );
}
//…</span></pre>
<p><span class="koboSpan" id="kobo.97.1">We will start by </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.98.1">importing the necessary functions from React Query – </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">QueryClient</span></strong><span class="koboSpan" id="kobo.100.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">QueryClientProvider</span></strong><span class="koboSpan" id="kobo.102.1">. </span><span class="koboSpan" id="kobo.102.2">Then, we will create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">QueryClient</span></strong><span class="koboSpan" id="kobo.104.1"> function </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.105.1">and pass it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">QueryClientProvider</span></strong><span class="koboSpan" id="kobo.107.1">. </span><span class="koboSpan" id="kobo.107.2">Our app is ready to use React Query functionalities instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">simple fetching.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">This is a good moment to make sure the app is running correctly on your simulator </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">or device.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">Once you have made sure installing new dependencies did not break anything unexpected in your project, we will be ready to implement real data fetching with React Query in the </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">next section.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.113.1">Using React Query for data fetching</span></h1>
<p><span class="koboSpan" id="kobo.114.1">As you know, we </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.115.1">need to fetch a few different pieces of data </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.116.1">for our app. </span><span class="koboSpan" id="kobo.116.2">We will fetch a list of avatars, a list of images for the feed surface, a list of images for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">FavoritedImages</span></strong><span class="koboSpan" id="kobo.118.1"> surface, and a list of conversations. </span><span class="koboSpan" id="kobo.118.2">We are free to add the React Query fetching wherever we like. </span><span class="koboSpan" id="kobo.118.3">For simple queries, we can simply use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">useQuery</span></strong><span class="koboSpan" id="kobo.120.1"> hook provided by the library in our components. </span><span class="koboSpan" id="kobo.120.2">We can also write our own custom hooks, holding more logic or conditions. </span><span class="koboSpan" id="kobo.120.3">Let’s start by looking at the simplest possible example: querying the server to check whether the user is </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">logged in.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">In order to use a React Query hook in the top-level component where we set up our navigation to display either the login screen or not, we will need to reorganize our code a little bit. </span><span class="koboSpan" id="kobo.122.2">We </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.123.1">cannot have </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">QueryClientProvider</span></strong><span class="koboSpan" id="kobo.125.1"> in the </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.126.1">return statement of the same component trying to use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">useQuery</span></strong><span class="koboSpan" id="kobo.128.1"> hook. </span><span class="koboSpan" id="kobo.128.2">Let’s change the name of the main component from </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">App</span></strong><span class="koboSpan" id="kobo.130.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">AppWrapped</span></strong><span class="koboSpan" id="kobo.132.1"> and let’s add this new app component in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">App.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.135.1">
// App.js
export default function App() {
    return (
      &lt;QueryClientProvider client={queryClient}&gt;
      &lt;AppWrapped /&gt;
    &lt;/QueryClientProvider&gt;
  )
};</span></pre>
<p><span class="koboSpan" id="kobo.136.1">Now, let’s change the name of the main component from </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">App</span></strong><span class="koboSpan" id="kobo.138.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">AppWrapped</span></strong><span class="koboSpan" id="kobo.140.1">, and let’s remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">QueryClientProvider</span></strong><span class="koboSpan" id="kobo.142.1"> from the child component. </span><span class="koboSpan" id="kobo.142.2">Let me remind you that if you ever get lost in the code examples, you can take a look at the GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">repo: </span></span><a href="https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-9"><span class="No-Break"><span class="koboSpan" id="kobo.144.1">https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-9</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.145.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">AppWrapped</span></strong><span class="koboSpan" id="kobo.148.1"> component should be ready to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">useQuery</span></strong><span class="koboSpan" id="kobo.150.1"> hook. </span><span class="koboSpan" id="kobo.150.2">Make sure you start by importing it </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
// App.js
import {
  useQuery,
//…
} from '@tanstack/react-query'
//…
const fetchLoginStatus = async () =&gt; {
    const response = await fetch(requestBase +
      "/loginState.json");
    return response.json();
  }
const AppWrapped = () =&gt; {
  const { data } = useQuery(['loginState'],
    fetchLoginStatus);
//…
{!data?.loggedIn ? </span><span class="koboSpan" id="kobo.152.2">(
    &lt;Stack.Screen name='Login' component={Login} /&gt;
          ) : (
            &lt;&gt;
               &lt;Stack.Screen
                name='Home'
//…</span></pre>
<p><span class="koboSpan" id="kobo.153.1">After you’ve imported the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">useQuery</span></strong><span class="koboSpan" id="kobo.155.1"> hook, you need to create a function responsible for fetching and </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.156.1">awaiting data from the server. </span><span class="koboSpan" id="kobo.156.2">This is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">fetchLoginStatus</span></strong><span class="koboSpan" id="kobo.158.1"> function, which we will pass to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">useQuery</span></strong><span class="koboSpan" id="kobo.160.1"> hook. </span><span class="koboSpan" id="kobo.160.2">This function </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.161.1">can be created in any file you would like. </span><span class="koboSpan" id="kobo.161.2">Once we have the fetching set up, we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">useQuery</span></strong><span class="koboSpan" id="kobo.163.1"> hook in the component. </span><span class="koboSpan" id="kobo.163.2">We pull in a destructured object key data, where we check the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">loggedInStatus</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1"> value.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.166.1">Object destructuring</span></p>
<p class="callout"><span class="koboSpan" id="kobo.167.1">Depending on how often you use modern JavaScript, you may have noticed the destructuring syntax, where </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.168.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">const</span></strong><span class="koboSpan" id="kobo.170.1"> keyword is followed by items in curly or square brackets. </span><span class="koboSpan" id="kobo.170.2">This syntax is called destructuring assignment and is used to unpack values from arrays (square brackets), objects, or properties (</span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">curly brackets).</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">const { data } = objectWithADataItem</span></strong><span class="koboSpan" id="kobo.173.1"> is the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">const data = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">objectWithADataItem.data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">Now that we have </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.178.1">seen a simple example, let’s look at something </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.179.1">slightly more complex and create a custom hook and a </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">dependent query.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.181.1">Fetching image data</span></h2>
<p><span class="koboSpan" id="kobo.182.1">Fetching image data could be just as simple as fetching the login state data; however, I would like to talk </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.183.1">about something more complicated. </span><span class="koboSpan" id="kobo.183.2">So, we will artificially complicate our lives by making sure the images are fetched only after the user is logged in. </span><span class="koboSpan" id="kobo.183.3">We will start by creating a custom hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">useCustomImageQuery</span></strong><span class="koboSpan" id="kobo.185.1"> inside a newly created </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">queries</span></strong><span class="koboSpan" id="kobo.187.1"> folder. </span><span class="koboSpan" id="kobo.187.2">Our custom hook will return a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">useQuery</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1"> hook:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
// src/queries/useCustomImageQuery
import { useQuery } from "@tanstack/react-query";
import { requestBase } from "../utils/constants";
const getImages = async () =&gt; {
  const response = await fetch(requestBase +
    "/john_doe/likedImages.json");
  return response.json();
}
export const useCustomImageQuery = () =&gt; {
  const { data } = useQuery(['loginState']);
  return useQuery(
    ["imageList"],
    getImages,
    {
    enabled: data?.loggedIn,
  });
};</span></pre>
<p><span class="koboSpan" id="kobo.191.1">We started by importing the necessary </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">useQuery</span></strong><span class="koboSpan" id="kobo.193.1"> function and our utility </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">requestBase</span></strong><span class="koboSpan" id="kobo.195.1">. </span><span class="koboSpan" id="kobo.195.2">Next, we created our fetching function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">getImages</span></strong><span class="koboSpan" id="kobo.197.1">. </span><span class="koboSpan" id="kobo.197.2">This function fetches data </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.198.1">from a given API endpoint and returns it. </span><span class="koboSpan" id="kobo.198.2">Finally, we created a custom hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">useCustomImageQuery</span></strong><span class="koboSpan" id="kobo.200.1">. </span><span class="koboSpan" id="kobo.200.2">On the first line of the hook, we check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">loginState</span></strong><span class="koboSpan" id="kobo.202.1"> query. </span><span class="koboSpan" id="kobo.202.2">It looks different than in </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">App.js</span></strong><span class="koboSpan" id="kobo.204.1"> where we used it first, doesn’t it? </span><span class="koboSpan" id="kobo.204.2">It has only one parameter: </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">loginState</span></strong><span class="koboSpan" id="kobo.206.1">. </span><span class="koboSpan" id="kobo.206.2">This parameter is called a </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">query key</span></strong><span class="koboSpan" id="kobo.208.1"> in the React Query world and it is literally a key to unlocking the </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.209.1">power of React Query. </span><span class="koboSpan" id="kobo.209.2">Using this key, you can access any and all previously fetched data; you could also invalidate it manually or mutate it. </span><span class="koboSpan" id="kobo.209.3">As for us, we only need to check the login status now, using this particular </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">query key.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">return</span></strong><span class="koboSpan" id="kobo.213.1"> statement of our custom hook consists of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">useQuery</span></strong><span class="koboSpan" id="kobo.215.1"> hook with three parameters. </span><span class="koboSpan" id="kobo.215.2">In the first place, we have the awesomely important query key, </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">imageList</span></strong><span class="koboSpan" id="kobo.217.1">. </span><span class="koboSpan" id="kobo.217.2">Next, we see the call to the fetching function. </span><span class="koboSpan" id="kobo.217.3">Last but not least, we have a configuration object holding a key called </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">enabled</span></strong><span class="koboSpan" id="kobo.219.1">. </span><span class="koboSpan" id="kobo.219.2">This key determines when the given query should be called. </span><span class="koboSpan" id="kobo.219.3">In our case, the query will be called when the result of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">loginStatus</span></strong><span class="koboSpan" id="kobo.221.1"> query returns the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">true</span></strong><span class="koboSpan" id="kobo.223.1">. </span><span class="koboSpan" id="kobo.223.2">We just successfully set up React Query to fetch images. </span><span class="koboSpan" id="kobo.223.3">All that is left is to display them. </span><span class="koboSpan" id="kobo.223.4">Let’s go to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">ListOfFavorited</span></strong><span class="koboSpan" id="kobo.225.1"> component where we will replace the context call with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">custom hook:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
// src/components/ListOfFavorited.js
import { useCustomImageQuery } from "../queries/
  useCustomImageQuery";
//…
export const ListOfFavorites = ({ navigation }) =&gt; {
  const { data: queriedImages } = useCustomImageQuery();
//…
  return (
//…
    &lt;FlatList
    data={ queriedImages }
//…</span></pre>
<p><span class="koboSpan" id="kobo.228.1">If everything went according to plan, you should be able to run the application now and see a list of favorited images, which is pulled by React Query from the backend. </span><span class="koboSpan" id="kobo.228.2">If you run into any trouble, remember that the custom hook we created is just another function, and can be debugged as such. </span><span class="koboSpan" id="kobo.228.3">You can put </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">console.log</span></strong><span class="koboSpan" id="kobo.230.1"> in the component, in the hook, or in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">getImages</span></strong><span class="koboSpan" id="kobo.232.1"> function called by </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">the hook.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">Hopefully, you were able to set up everything smoothly. </span><span class="koboSpan" id="kobo.234.2">In this section, we practiced using React Query for </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.235.1">fetching and displaying data. </span><span class="koboSpan" id="kobo.235.2">We leveraged ReactJS knowledge – because we created a custom hook – but React Query hooks can be set up in many ways. </span><span class="koboSpan" id="kobo.235.3">Given that our app has a fake backend that can only serve data, this is as far as we can go in practical usage of React Query. </span><span class="koboSpan" id="kobo.235.4">I invite you though, my dear reader, to continue reading and find out what other great functionalities this </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">library holds.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.237.1">Other React Query Functionalities</span></h1>
<p><span class="koboSpan" id="kobo.238.1">As stated above, we </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.239.1">can’t use React Query in our example app to mutate data on the server because our backend is not robust enough. </span><span class="koboSpan" id="kobo.239.2">In a real-life application, you would most probably use an API that accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">POST</span></strong><span class="koboSpan" id="kobo.241.1"> request just as well as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">GET</span></strong><span class="koboSpan" id="kobo.243.1"> request. </span><span class="koboSpan" id="kobo.243.2">In these cases, you would be able to change data with the help of React Query. </span><span class="koboSpan" id="kobo.243.3">In order to do so, we are provided with another specialized hook: </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">useMutation</span></strong><span class="koboSpan" id="kobo.245.1">. </span><span class="koboSpan" id="kobo.245.2">Here’s what this hook would look like if we could use it for the </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">favorited images:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.247.1">
  const imageListMutation = useMutation(newImage =&gt; {
    return fetch('/john_doe/likedImages ',
      {method: 'POST', body: newImage})
  });</span></pre>
<p><span class="koboSpan" id="kobo.248.1">The preceding function is very simple. </span><span class="koboSpan" id="kobo.248.2">It wraps a </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">fetch</span></strong><span class="koboSpan" id="kobo.250.1"> call in a React Query utility. </span><span class="koboSpan" id="kobo.250.2">This utility offers us a </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.251.1">few things, such as the fact that it has the following states: </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">isIdle</span></strong><span class="koboSpan" id="kobo.253.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">isLoading</span></strong><span class="koboSpan" id="kobo.255.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">isError</span></strong><span class="koboSpan" id="kobo.257.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">isSuccess</span></strong><span class="koboSpan" id="kobo.259.1">. </span><span class="koboSpan" id="kobo.259.2">We can check these states and update the view accordingly. </span><span class="koboSpan" id="kobo.259.3">We would use this mutation </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">ImageDetailsmodal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
// src/surfaces/ImageDetailsmodal.js
//…
export const ImageDetailsmodal = ({ navigation }) =&gt; {
  const imageListMutation = useMutation(newImage =&gt; {
    return fetch('/john_doe/likedImages ',
      {method: 'POST', body: newImage})
  });
//…
  return (
//…
      &lt;Pressable
          onPress={() =&gt; {
           imageListMutation.mutate({route.params.imageItem
             })
          }}
        &gt;
        {mutation.isLoading ? </span><span class="koboSpan" id="kobo.263.2">(
            &lt;Text&gt;Loading…&lt;/Text&gt;
              ) : (
                &lt;Ionicons
                  //…
          /&gt; )
          }
        &lt;/Pressable&gt;
//…</span></pre>
<p><span class="koboSpan" id="kobo.264.1">Let me reiterate: we are doing a dry run of sending data to the server because our app’s backend cannot handle a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">POST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.266.1"> request.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">In the preceding code, we started by adding a React Query mutation function to </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">ImageDetailsModal</span></strong><span class="koboSpan" id="kobo.269.1">. </span><span class="koboSpan" id="kobo.269.2">We passed it into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">Pressable</span></strong><span class="koboSpan" id="kobo.271.1"> component. </span><span class="koboSpan" id="kobo.271.2">Then, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">Pressable</span></strong><span class="koboSpan" id="kobo.273.1"> component, we added a ternary operator to check whether the mutation is in a loading state. </span><span class="koboSpan" id="kobo.273.2">In case it is, we display a </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">Text</span></strong><span class="koboSpan" id="kobo.275.1"> component saying </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">Loading…</span></strong><span class="koboSpan" id="kobo.277.1">. </span><span class="koboSpan" id="kobo.277.2">This is a </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.278.1">minimal example of how you can take advantage of mutation states. </span><span class="koboSpan" id="kobo.278.2">In a real-world app, you would probably check for </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">isSucccess</span></strong><span class="koboSpan" id="kobo.280.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">isError</span></strong><span class="koboSpan" id="kobo.282.1"> as well and you would probably handle loading </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">more gracefully.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">This is all nice, but the way we implemented the mutation above we would still need to re-fetch the data traditionally to have the latest version in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">ListOfFavorites</span></strong><span class="koboSpan" id="kobo.286.1"> component. </span><span class="koboSpan" id="kobo.286.2">Unless, we use the full power of React Query and update the cached version of data, fetched previously through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">useCustomImageQuery</span></strong><span class="koboSpan" id="kobo.288.1"> hook! </span><span class="koboSpan" id="kobo.288.2">Here’s what we would need to change in </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">the mutation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.290.1">
const updateImges = () =&gt; {
   return fetch('/john_doe/likedImages ',
     {method: 'POST', body: newImage})
}
const imageListMutation = useMutation(updateImges, {
   onSuccess: data =&gt; {
    queryClient.setQueryData(['imageList'], data)
  }
})</span></pre>
<p><span class="koboSpan" id="kobo.291.1">In the preceding code snippet, we started by extracting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">fetch</span></strong><span class="koboSpan" id="kobo.293.1"> function for better readability. </span><span class="koboSpan" id="kobo.293.2">We then add </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">onSuccess</span></strong><span class="koboSpan" id="kobo.295.1"> logic to the mutation and we tell it to update the item marked by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">imageList</span></strong><span class="koboSpan" id="kobo.297.1"> query key with the new data. </span><span class="koboSpan" id="kobo.297.2">Thanks to this strategy we will not have to manually update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">imageList</span></strong><span class="koboSpan" id="kobo.299.1"> data every time a mutation occurs. </span><span class="koboSpan" id="kobo.299.2">You can read more about updating after mutation responses in the TanStack documentation, linked in the </span><em class="italic"><span class="koboSpan" id="kobo.300.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.301.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">We have covered the two most important aspects of React Query: fetching and mutating data. </span><span class="koboSpan" id="kobo.303.2">However, there’s much more functionality to be taken advantage of in a real-life project. </span><span class="koboSpan" id="kobo.303.3">You </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.304.1">can check the fetching status, just like we did with the example mutation. </span><span class="koboSpan" id="kobo.304.2">You can also do parallel queries for fetching data simultaneously. </span><span class="koboSpan" id="kobo.304.3">If you want to, you can set initial data to fill your views before fetching is complete. </span><span class="koboSpan" id="kobo.304.4">It is also possible to pause or disable queries whenever you need. </span><span class="koboSpan" id="kobo.304.5">For large datasets, there is a special type of query, a paginated query, which will batch data into consumable chunks. </span><span class="koboSpan" id="kobo.304.6">In case your data is infinite, React Query provides utilities for infinite queries. </span><span class="koboSpan" id="kobo.304.7">Many big apps may take advantage of prefetching data on </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">page load.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">I encourage you, my dear reader, to read the React Query documentation to be able to grasp all the possible solutions it offers. </span><span class="koboSpan" id="kobo.306.2">I was surprised myself while using React Query by how many common problems are solved out of the box by </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">this library.</span></span></p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.308.1">React Query utilities for React Native</span></h1>
<p><span class="koboSpan" id="kobo.309.1">As we all know, React Native </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.310.1">has its own quirks as compared to pure ReactJS. </span><span class="koboSpan" id="kobo.310.2">React Query doesn’t leave managing those quirks to the developers, but rather steps up with some interesting solutions. </span><span class="koboSpan" id="kobo.310.3">For example, there’s an </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">onlineManager</span></strong><span class="koboSpan" id="kobo.312.1"> that can be added to React Native apps to have our apps reconnect when they are online. </span><span class="koboSpan" id="kobo.312.2">If we would like to refresh or refetch data when the app is focused, we can </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.313.1">use React Query’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">focusManager</span></strong><span class="koboSpan" id="kobo.315.1"> together with React Native’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">AppState</span></strong><span class="koboSpan" id="kobo.317.1">. </span><span class="koboSpan" id="kobo.317.2">In some cases, we may want to refetch data when a specific screen in our app is focused, and React Query offers a solution for that use case as well. </span><span class="koboSpan" id="kobo.317.3">If you want to read about these utilities and how to use them </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.318.1">in more detail, head over to the TanStack documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">at </span></span><a href="https://tanstack.com/query/v4/docs/react-native"><span class="No-Break"><span class="koboSpan" id="kobo.320.1">https://tanstack.com/query/v4/docs/react-native</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.321.1">.</span></span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.322.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.323.1">React Query is battle tested for scaling applications and can be a great solution for all sorts of projects. </span><span class="koboSpan" id="kobo.323.2">In this chapter, we installed it in the Funbook app and added it to the app. </span><span class="koboSpan" id="kobo.323.3">We didn’t configure anything specific, as our project is small and didn’t require any changes from the default configuration. </span><span class="koboSpan" id="kobo.323.4">We then looked at how a simple data fetching mechanism can be used for checking the login status of the user. </span><span class="koboSpan" id="kobo.323.5">Next, we created and used another, more complex, data-fetching hook with a dependency. </span><span class="koboSpan" id="kobo.323.6">We displayed the fetched data and then we took a tour of other React Query utilities. </span><span class="koboSpan" id="kobo.323.7">React Query is the last stop in our journey through the world of state management libraries for React Native apps. </span><span class="koboSpan" id="kobo.323.8">I hope you enjoyed </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">the ride!</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">I invite you, my dear reader, to accompany me to the last chapter, where we will summarize everything we have learned on the topic of state management in React </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">Native apps.</span></span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.327.1">Further reading</span></h1>
<ul>
<li><a href="https://tanstack.com/"><span class="koboSpan" id="kobo.328.1">https://tanstack.com/</span></a><span class="koboSpan" id="kobo.329.1"> – The TanStack </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">home page.</span></span></li>
<li><a href="https://tanstack.com/query/v4/docs/guides/updates-from-mutation-responses"><span class="koboSpan" id="kobo.331.1">https://tanstack.com/query/v4/docs/guides/updates-from-mutation-responses</span></a><span class="koboSpan" id="kobo.332.1"> – TanStack Query, </span><em class="italic"><span class="koboSpan" id="kobo.333.1">Updates from </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.334.1">Mutation Responses.</span></em></span></li>
</ul>
</div>


<div class="Content" id="_idContainer045">
<h1 id="_idParaDest-120"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.1.1">Part 4 – Summary</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, readers will get an overview of all the different solutions covered throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">the book.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapter:</span></span></p>
<ul>
<li><a href="B18396_10.xhtml#_idTextAnchor122"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Appendix</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer046">
</div>
</div>
</body></html>