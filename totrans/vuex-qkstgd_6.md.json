["```js\nconst consolePlugin = (store) => {\nstore.subscribe((mutation, state) => {\n    // called after every mutation.\n    // The mutation comes in the format of { type, payload }.\n    console.log(mutation, state);\n  });\n};\n```", "```js\nconst store = new Vuex.Store({\n  // ...\n  plugins: [consolePlugin]\n});\n```", "```js\n// src/store/plugins.js\n// ...\nconst lastEditDate = (store) => {\n  store.subscribe((mutation) => {\n    if (mutation.type !== types.UPDATE_LAST_EDIT_DATE) {\n      store.commit(types.UPDATE_LAST_EDIT_DATE);\n    }\n  });\n};\n```", "```js\nnpm install --save vuex-persistedstate\n```", "```js\n// src/store/index.js\n// ...\nimport createPersistedState from 'vuex-persistedstate';\n// ...\n\nplugins.push(createPersistedState());\nconst store = new Vuex.Store({\n  state: {\n   // ...\n  },\n  mutations,\n  actions,\n  strict: debug,\n  plugins,\n});\n```", "```js\n// src/api/api-mock.js\nexport default {\n  fetchAllNotes() {\n    return Promise.resolve([]);\n  },\n};\n```", "```js\nnpm install vuex-router-sync --save\n```", "```js\nnpm install vue-router --save\n```", "```js\n// src/store/index.js\nimport { sync } from 'vuex-router-sync';\n// ...\n\nconst store = new Vuex.Store({\n  state: {\n   // ...\n  },\n  mutations,\n  actions,\n  strict: debug,\n  plugins,\n});\n\nsync(store, router);\n// ...\n```", "```js\nstore.state.route.path // current path (string)\nstore.state.route.params // current params (object)\nstore.state.route.query // current query (object)\n```", "```js\nsync(store, router, { moduleName: 'CustomRouteSyncModule' } );\n```", "```js\n<!-- index.html -->\n\n<!-- Global site tag (gtag.js) - Google Analytics -->\n<script async src=\"img/js?id=GA_TRACKING_ID\"></script>\n<script>\n  window.dataLayer = window.dataLayer || [];\n  function gtag(){dataLayer.push(arguments);}\n  gtag('js', new Date());\n\n  gtag('config', 'GA_TRACKING_ID');\n</script>\n```", "```js\ngtag('event', 'MUTATION_NAME');\n```", "```js\n// src/store/plugins.js\n// ...\nexport const googleAnalytics = (store) => {\n  store.subscribe((mutation) => {\n    gtag('event', mutation.type);\n  });\n};\n```", "```js\n// src/store/plugins.js\nimport analytics from '../gtag';\n// ...\nexport const googleAnalytics = (store) => {\n  store.subscribe((mutation, state) => {\n    if (mutation.type === 'route/ROUTE_CHANGED') {\n      analytics.sendPageView(state.route.path);\n    } else {\n      analytics.sendEvent(mutation.type);\n    }\n  });\n};\n```", "```js\n// src/gtag/index.js\nconst GA_TRACKING_ID = 'GA_TRACKING_ID';\n\nclass GtagAnalytics {\n  static sendEvent(action) {\n    gtag('event', action);\n  }\n\n  static sendPageView(pagePath) {\n    gtag('config', GA_TRACKING_ID, { page_path: pagePath });\n  }\n}\n\nexport default GtagAnalytics;\n```", "```js\ngit checkout chapter-5/step-7_google-analytics-plugin\n```", "```js\nstore.registerModule(moduleName, {\n  namespaced: true,\n  getters: {\n    canUndo() {}, // Tells if undo can be performed\n    canRedo() {}, // Tells if redo can be performed\n  },\n  state: {\n    currentPosition: 0, // Position in the history\n    snapshots: [], // Snapshots taken\n  },\n  mutations: {\n    [UNDO]() {}, // Mutation to undo last mutation\n    [REDO](state) {}, // Mutation to redo last mutation\n    [UPDATE_CURRENT_POSITION](){},//update currentPosition\n    [UPDATE_SNAPSHOTS](){}, //update snapshots \n  },\n});\n```", "```js\nconst undoRedoPlugin = (store) => {\n  function takeStateSnapshot(state) {\n    // ...\n  }\n\n  function restoreStateSnapshot(state, toRestore) {\n    // ...\n  }\n\n  store.subscribe(({ type }, state) => {\n    if (mutationsToExclude[type] === undefined) {\n      const index = state[moduleName].currentPosition + 1;\n      const snapshots = state[moduleName].snapshots.slice();\n      snapshots.length = index + 1;\n      snapshots[index] = takeStateSnapshot(state);\n      store.commit(currentPositionType, index);\n      store.commit(updateSnapshotType, snapshots);\n    }\n  });\n\n  store.registerModule(moduleName, {\n    // ...\n  });\n};\n```", "```js\nstore.registerModule(moduleName, {\n  namespaced: true,\n  getters: {\n    canUndo({ currentPosition }) {\n      return currentPosition >= 1;\n    },\n    canRedo({ currentPosition, snapshots }) {\n      return currentPosition < snapshots.length - 1;\n    },\n  },\n  state: {\n    currentPosition: 0,\n    snapshots: [takeStateSnapshot(store.state)],\n  },\n  mutations: {\n    [UNDO](state) {\n      if (store.getters[canUndoGetter]) {\n        state.currentPosition--;\n        const { snapshots } = state;\n        const snapShot = snapshots[state.currentPosition];\n        restoreStateSnapshot(store.state, snapShot);\n      }\n    },\n    [REDO](state) {\n      if (store.getters[canRedoGetter]) {\n        state.currentPosition++;\n        const { snapshots } = state;\n        const snapShot = snapshots[state.currentPosition];\n        restoreStateSnapshot(store.state, snapShot);\n      }\n    },\n    [UPDATE_CURRENT_POSITION](state, value) {\n      state.currentPosition = value;\n    },\n    [UPDATE_SNAPSHOTS](state, value) {\n      state.snapshots = value;\n    },\n  },\n});\n```", "```js\nfunction takeStateSnapshot(state) {\n  const toClone = {};\n  Object.keys(state).forEach((key) => {\n    if (statePropsToExclude[key] === undefined) {\n      toClone[key] = state[key];\n    }\n  });\n\n  return JSON.stringify(toClone);\n}\n\nfunction restoreStateSnapshot(state, toRestore) {\n  const clone = JSON.parse(toRestore);\n  Object.keys(clone).forEach((key) => {\n    state[key] = clone[key];\n  });\n}\n```", "```js\n// src/store/undo-redo-plugin.js\nexport default (options) => {\n  const moduleName = 'undoRedo' || options.moduleName;\n  const UNDO = 'undo';\n  const REDO = 'redo';\n  const UPDATE_CURRENT_POSITION = 'UPDATE_CURRENT_POSITION';\n  const UPDATE_SNAPSHOTS = 'UPDATE_SNAPSHOTS';\n  const undoType = `${moduleName}/${UNDO}`;\n  const redoType = `${moduleName}/${REDO}`;\n  const currentPositionType =\n    `${moduleName}/${UPDATE_CURRENT_POSITION}`;\n  const updateSnapshotType =\n    `${moduleName}/${UPDATE_SNAPSHOTS}`;\n  const canUndoGetter = `${moduleName}/canUndo`;\n  const canRedoGetter = `${moduleName}/canRedo`;\n\n  const statePropsToExclude = {\n    [moduleName]: '',\n  };\n  if (options.statePropsToExclude) {\n    options.statePropsToExclude.forEach((toExclude) => {\n      statePropsToExclude[toExclude] = '';\n    });\n  }\n\n  const mutationsToExclude = {\n    [undoType]: '',\n    [redoType]: '',\n    [currentPositionType]: '',\n    [updateSnapshotType]: '',\n  };\n  if (options.mutationsToExclude) {\n    options.mutationsToExclude.forEach((toExclude) => {\n      mutationsToExclude[toExclude] = '';\n    });\n  }\n\n  const undoRedoPlugin = (store) => {\n    function takeStateSnapshot(state) {\n      const toClone = {};\n      Object.keys(state).forEach((key) => {\n        if (statePropsToExclude[key] === undefined) {\n          toClone[key] = state[key];\n        }\n      });\n\n      return JSON.stringify(toClone);\n    }\n\n    function restoreStateSnapshot(state, toRestore) {\n      const clone = JSON.parse(toRestore);\n      Object.keys(clone).forEach((key) => {\n        state[key] = clone[key];\n      });\n    }\n\n    store.subscribe(({ type }, state) => {\n      if (mutationsToExclude[type] === undefined) {\n        const index = state[moduleName].currentPosition + 1;\n        const snapshots = state[moduleName].snapshots.slice();\n        snapshots.length = index + 1;\n        snapshots[index] = takeStateSnapshot(state);\n        store.commit(currentPositionType, index);\n        store.commit(updateSnapshotType, snapshots);\n      }\n    });\n\n    store.registerModule(moduleName, {\n      namespaced: true,\n      getters: {\n        canUndo({ currentPosition }) {\n          return currentPosition >= 1;\n        },\n        canRedo({ currentPosition, snapshots }) {\n          return currentPosition < snapshots.length - 1;\n        },\n      },\n      state: {\n        currentPosition: 0,\n        snapshots: [takeStateSnapshot(store.state)],\n      },\n      mutations: {\n        [UNDO](state) {\n          if (store.getters[canUndoGetter]) {\n            state.currentPosition--;\n            const { snapshots } = state;\n            const snapShot = snapshots[state.currentPosition];\n            restoreStateSnapshot(store.state, snapShot);\n          }\n        },\n        [REDO](state) {\n          if (store.getters[canRedoGetter]) {\n            state.currentPosition++;\n            const { snapshots } = state;\n            const snapShot = snapshots[state.currentPosition];\n            restoreStateSnapshot(store.state, snapShot);\n          }\n        },\n        [UPDATE_CURRENT_POSITION](state, value) {\n          state.currentPosition = value;\n        },\n        [UPDATE_SNAPSHOTS](state, value) {\n          state.snapshots = value;\n        },\n      },\n    });\n  };\n\n  return undoRedoPlugin;\n};\n```", "```js\ngit checkout chapter-5/step-8_undo-redo-plugin\n```", "```js\n// Just don't use this way!\nlet dataFromServer;\n\n// ...\n\nconst waitForData = () => {\n    if(dataFromServer !== undefined) {\n        doSomethingWith(dataFromServer);\n    } else {\n        setTimeout(waitForData, 100);\n    }\n};\nsetTimeout(waitForData, 100);\n```", "```js\napi.getDataFromServer((dataFromServer) => {\n    // do something with dataFromServer\n});\n```", "```js\napi.getDataFromServer().then(function success(dataFromServer){\n    // do something with dataFromServer\n}, function fail(error) {\n    // Handle the error\n});\n```", "```js\nstore.dispatch('action 1').then(() => {\n    return store.dispatch('action 2');\n}).then(() => {\n    store.commit('mutation depending on action 1 and 2');\n});\n```", "```js\n// Creates a resolved promise with a return value 'A'\nconst p1 = Promise.resolve('A'); \n\nconsole.log('start');\n// Chaining promises\np1\n  .then(result => result + 'B')\n  .then(result => asyncEcho(result + 'C')) // wait 1000 ms\n  .then(result => console.log(result))\nconsole.log('end');\n\nfunction asyncEcho(echoMsg) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(echoMsg), 1000);\n    });\n}\n```", "```js\nstart end\n// after 1000 ms\nABC\n```", "```js\n// Creates a resolved promise\nconst p1 = Promise.resolve(); \n\n// Chaining promises\np1\n  .then(() => {console.log(1); return asyncFail();})\n  .then(() => console.log(2), // success\n        () => console.log('Fail 2')) // fail\n  .then(() => {console.log(3); throw 'An error';}, // success\n        () => console.log('Fail 3')) // fail\n  .then(() => console.log(4), // success\n        () =>{console.log('Fail 4');return Promise.reject()}) \n  .catch(()=> console.log('Catch called'));\n\nfunction asyncFail() {\n    return new Promise((resolve, reject) => {\n        setTimeout(reject, 1000);\n    });\n}\n```", "```js\n1\nFail 2\n3\nFail 4\nCatch called\n```", "```js\nconst p1 = asyncEcho('A', 500);\nconst p2 = asyncEcho('B', 1000);\nconst e = asyncFail('E1', 100);\n\nPromise.all([p1, p2]).then((values) => \n    console.log('OK', values));\n\nPromise.all([p1, p2, e]).then(() => {\n  console.log('this gets not executed');\n}, (error) => {\n  console.log('Err', error);\n});\n\nfunction asyncEcho(echoMsg, delay) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(echoMsg), delay);\n    });\n}\n\nfunction asyncFail(error, delay) {\n     return new Promise((resolve, reject) => {\n        setTimeout(() => reject(error), delay);\n    });\n}\n```", "```js\nErr E1 // After 100 ms\nOK A, B // After 1000 ms\n```", "```js\nconsole.log(1);\nbuggyExecuteLater(() => console.log(3));\nconsole.log(2);\n\nfunction buggyExecuteLater(callback) {\n  new Promise(() => callback());\n}\n\n// Output\n// 1\n// 3\n// 2\n```", "```js\nfunction iMayFail() {\n  const rand = Math.random();\n  const successP = Promise.resolve();\n  const failP = Promise.reject();\n\n  return rand < 0.5 ? successP : failP;\n}\n\nfunction buggyToss() {\n  return iMayFail().then(\n    () => 'Success', // Success callback\n    () => 'Fail' // Fail callback\n  );\n}\n\nbuggyToss().then(\n  result => console.log('Resolved ' + result),\n  result => console.log('Rejected ' + result)\n);\n\n// Output is always 'Resolved Fail' or 'Resolved Success'\n```", "```js\nfunction correctToss() {\n  return iMayFail().then(\n    () => 'Success', // Success callback\n    () => Promise.reject('Fail') // Fail callback\n);\n```"]