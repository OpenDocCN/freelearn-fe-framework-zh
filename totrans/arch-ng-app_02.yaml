- en: 1.21 Gigawatt – Flux Pattern Explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first off explain our title. What do we mean by 1.21 Gigawatt? I''m
    going to quote the character Doc Brown from the movie *Back to the Future* ([http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu](http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"Marty, I''m sorry, but the only power source capable of generating 1.21 gigawatts
    of electricity is a bolt of lightning."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why are we talking about the movie Back to the Future? This is where the name
    Flux comes from. It''s time for another quote from the same movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes! Of course! November 5, 1955! That was the day I invented time-travel.
    I remember it vividly. I was standing on the edge of my toilet hanging a clock,
    the porcelain was wet, I slipped, hit my head on the sink, and when I came to
    I had a revelation! A vision! A picture in my head! A picture of this! This is
    what makes time travel possible: the **flux** capacitor!"'
  prefs: []
  type: TYPE_NORMAL
- en: So as you can see, there is an explanation for the name Flux. It obviously allows
    us to travel in time. At least for Redux, which we will write about later in this
    book, time travel is possible through something called time-travel debugging.
    Whether that needs a bolt of lightning is for you to find out dear reader.
  prefs: []
  type: TYPE_NORMAL
- en: Flux is an architectural pattern created by Facebook. It came about as it was
    perceived that the MVC pattern simply did not scale. It did not scale for large
    code bases as they tended to become fragile, generally complicated as more and
    more features were added, and most of all, unpredictable. Now let's hang on that
    word for a second, unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Large systems were thought to become unpredictable due to their bidrectional
    data flow between models and views when the number of models and views really
    grew, as depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/100fc94f-7809-4ac9-b96d-d4b6ed0853d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that the number of models and views is starting to grow. Everything
    is somewhat under control as long as one model talks to one view and vice versa.
    This is, however, seldom the case. In the preceding diagram, we see that suddenly
    a view can talk to more than one model and vice versa, which means we have a cascading
    effect on the system and we suddenly lose control. Sure, it doesn't look so bad
    with just one deviating arrow, but imagine that this one is suddenly ten arrows,
    then we have a real problem on our hands.
  prefs: []
  type: TYPE_NORMAL
- en: It is the very fact that we allow bidrectional data flows to happen that things
    get complicated and we lose predictability. The medicine or cure for that is thought
    to be a simpler type of data flow, a unidirectional flow. Now, there are some
    key players involved in enabling undirectional data flow, which brings us to what
    this chapter is meant to teach us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What an action and an action creator are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the dispatcher plays a central role in your application as a hub for messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State management with a store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to put our knowledge of Flux into practice by coding up a Flux application
    flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core concepts overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the core of the Flux pattern is a unidirectional data flow. It uses some
    core concepts to achieve this flow. The main idea is when an event is created
    on a UI, through the interaction of a user, an action is created. This action
    consists of an intent and a payload. The intent is what your are trying to achieve.
    Think of the intent as a verb. Add an item, remove an item, and so on. The payload
    is the data change that needs to happen to achieve our intent. If we are trying
    to add an item, then the payload is the newly created item. The action is then
    propagated in the flow with the help of a dispatcher. The action and its data
    eventually end up in a store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concepts that make up the Flux pattern are:'
  prefs: []
  type: TYPE_NORMAL
- en: Action and action creators, where we set up an intention and a payload of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dispatcher, our spider in the web that is able to send messages left and
    right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The store, our central place for state and state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these together form the Flux pattern and promote unidirectional data flow.
    Consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01e73ee8-9f3d-4376-8718-597c54d94836.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What is depicted here is a undirectional data flow. The data flows from **View**
    to **Action**, from **Action** to **Dispatcher**, from **Dispatcher** to **Store**.
    There are two possible ways that the flow is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: The application is loaded a first time, in which the data is pulled from the
    **Store** to populate the view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user interaction happens in the view that leads to an intent to change something.
    The intent is encapsulated in an **Action**, and thereafter sent to the **Store**,
    via the **Dispatcher**. At the **Store**, it may be persisted in a database, through
    an **API** or saved as an application state, or both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's dive into each concept in more detail, together with highlighting some
    code examples, in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: A uniform data flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s introduce all parties involved in our uniform data flow by starting
    from the very top and slowly work our way down, concept by concept. We will build
    an application consisting of two views. In the first view, the user will select
    an item from a list. This should result in an action being created. This action
    will then be dispatched, by the dispatcher. The action and its payload will end
    up in a store. The other view meanwhile listens to changes from the store. When
    an item is selected, the second view will be made aware and can therefore indicate
    in its UI that a specific item has been selected. On a high level, our application
    and its flow will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d4d0bd5-2b05-4d97-b471-d26c97a9f49c.png)'
  prefs: []
  type: TYPE_IMG
- en: Action – capture the intent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An action is something as simple as an intent with accompanying data, that is,
    a message. How does an action come about though? An action comes about when a
    user interacts with a UI. The user may select a specific item in a list or a press
    a button with the intention of submitting a form. Submitting the form should,
    in turn, lead to a product being created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at two different actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting an item in a list, here we are interested in saving the index of our
    selected item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving a todo to a todo list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An action is represented by an object. The object has two properties of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type: This is a unique string that tells us the intention of the action,
    for example, `SELECT_ITEM`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data: This is the data we mean to persist, for example, the numerical index
    of a selected item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given our first example action, a code representation of that action would
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: OK, so we have prepared our action, which we can also think of as a message.
    We want the message to be sent so that the selected item is highlighted in the
    UI. As this is a undirectional flow, we need to follow a charted course and pass
    our message over to the next party, which is the dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatcher – the spider in the web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Think of the dispatcher as the spider in the web that handles messages being
    passed to it. You can also think of the dispatcher as a mailman who promises that
    your message will reach its target destination. A dispatcher lives, for one thing,
    to dispatch messages to anyone who will listen. There is usually just one `dispatcher`
    in a Flux architecture and a typical usage looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Listening to the dispatcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have established that the dispatcher dispatches a message to anyone who
    will listen. Now it is time to be that listener. The dispatcher needs a `register`
    or `subscribe` method so that you, who listens, have the ability to listen for
    incoming messages. The setup for that usually looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you set up a listener this way, it will have the capability to listen
    to any message type being sent. You want to narrow this down; usually, a listener
    is specified to only handle a few message types around a certain theme. Your listener
    most likely looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so we are able to filter out only the message types we care about, but
    before actually filling in some code we need to think about who this listener
    is. The answer is simple: it is the store.'
  prefs: []
  type: TYPE_NORMAL
- en: The store – managing state, data retrieval, and callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s easy to think of the store as the place where our data lives. That is,
    however, not all it is. What the store''s responsibilities are can be expressed
    by this list:'
  prefs: []
  type: TYPE_NORMAL
- en: Holder of state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manages the state, able to update it if need be
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Able to handle side effects such as fetching/persisting data through HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handles callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, that is a bit more than just storing the state. Let''s now
    reconnect to what we were doing when we set up a listener with the `dispatcher`.
    Let''s move that code into our store file, `store.js`, and let''s persist our
    message content in our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: OK, so now the store is being told about the new index, but an important piece
    is missing, how do we tell the UI? We need a way to tell the UI that something
    has changed. A change means that the UI should reread its data.
  prefs: []
  type: TYPE_NORMAL
- en: The view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To tell the view that something has happened and act on it, three things need
    to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The view needs to register with the store as a listener
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The store needs to send off an event conveying that a change has happened
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view needs to reload its data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Starting with the store, we need to build it out so that you can register as
    a listener to its events. We therefore add the `addListener()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we also add the ability to emit an event with the addition
    of the `emitChange()` method. You can easily switch out this implementation to
    use an `EventEmitter` or similar. So now is the time to hook up our view to the
    store. We do so by calling the `addListener()` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we implement the `notifyChanged()` method, which when
    called invokes the `getSelectedItem()` method from the store and thereby receives
    the new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have described the whole chain: how one view receives a user
    interaction, turns that into an action, which is then dispatched to a store, which
    updates the store''s state. The store then emits an event that the other view
    is listening to. When the event is received, in the view the state from the store
    is reread and the view is then free to render this state, which it just read in,
    the way it sees fit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have described two things here:'
  prefs: []
  type: TYPE_NORMAL
- en: How to set up the flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the information flows in Flux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting up the flow can be depicted with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f71e618-477b-4d27-a8d6-3704673d6609.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As for the second scenario, how the information flows through the system, it
    can be depicted in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/754e1c56-ddb8-4214-8af8-2d461f20fa18.png)'
  prefs: []
  type: TYPE_IMG
- en: Demoing a uniform data flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ok, so we have described the parts our application consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: A view where a user is able to select an index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dispatcher that allows us to send a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A store that contains our selected index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second view where the selected index is read from the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's build a real app from all of this. The following code is found in the
    code repository under `Chapter2/demo`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a selection view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First off we need our view in which we will perform the selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have bolded the `selectIndex()` method above that we intend to use.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the dispatcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next off we need a dispatcher that is able to take our message, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The store will act as the data source for our state but will also be able tell
    any listeners when a change to the store happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Adding a selected view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This view will register itself with the store and ask for updates to its content.
    If there are any updates it will be notified and the data from the store will
    be read and this view will communicate what the store value now is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running the demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can run our demo we need an application file, `app.js`. The `app.js`
    file should require in our views and also carry out the selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To run our demo we need to compile it. Above we are using ES2015 modules. To
    compile those we will use `webpack`. We need to install `webpack` by typing the
    following in our terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have done so we need to create `webpack.config.js` file where we tell
    Webpack how to compile our files and where to place the resulting bundle. That
    file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This tells Webpack that `app.js` is the entry point to our application and it
    should crawl all the dependencies when creating the output file, `bundle.js`.
    Webpack will by default place `bundle.js` in the `dist` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing, we need an HTML file that we will name `index.html`. We will
    place under the `dist` folder. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to run our application, we need to compile it with Webpack and start
    a HTTP server and start up a browser. We will do all that with the following command
    from the `demo` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, start a browser and navigate to `http://localhost:5000`. You should see
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6e36d83-970c-4c21-a65c-331129d78474.png)'
  prefs: []
  type: TYPE_IMG
- en: All of this demonstrates how to views can be made to communicate using a dispatcher
    and a store.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more actions to our flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's do a reality check here. We haven't built the Flux flow as prettily as
    we could make it. The overall picture is correct but it'd be nice if we can clean
    it up a bit to make room for more actions so we get a real sense of how the application
    should grow from here.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first order of business is to have a look at our first view and how it
    reacts to user interactions. It looks like this currently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a few more actions into the mix means we would extend the view with
    a few methods like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so now we get how we can add actions. It looks a little ugly though with
    all these calls to the `dispatcher` and magic strings, so we clean this up a bit
    by creating a file with constants, called `product.constants.js`, which consists
    of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do one more thing. Let''s move the `dispatcher` into a `product.actions.js`;
    this is generally known as an action creator. This will contain the `dispatcher`
    and refer to our `product.constants.js` file. So let''s create said file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With these constructs, we can clean up our view considerably to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning up the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are improvements we can make to on the store. There is no need to write
    all the code we do currently. In fact, there are libraries out there that do a
    better job of handling certain functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Before we apply all those changes we have in mind, let's recap what our store
    can do and what features still need to be in place after the cleanup work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remind ourselves, what our store is capable of so far:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Handles state changes: It handles the state changes; the store is able to change
    the state regardless of whether it is creating, updating, listing, or removing
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subscribable: It lets you subscribe to it; it''s important for the store to
    have a subscription functionality so a view, for example, can listen to the store''s
    state when it changes. A suitable reaction by the view is, for example, rerendering
    based on new data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Can communicate a state change: It can send an event that its state has been
    changed; this goes together with being able to subscribe to the store, but this
    is the very act of actually notifying a listener that a state has changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding EventEmitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two last bullets can really be condensed into one theme, namely eventing,
    or the ability to register to and fire off events.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what does a cleanup of the store look like, and why would we need to clean
    it up? The reason for cleaning it up is it makes for simpler code. There is a
    standard library that is often used when constructing a store, called `EventEmitter`.
    The library handles just what we mentioned previously, namely it is able to register
    and fire off events. It is a simple implementation of the pub-sub pattern. Basically,
    `EventEmitter` allows you to subscribe to certain events and also allows you to
    trigger events. For more information on the pattern itself, have a look at the
    following link: [https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern).'
  prefs: []
  type: TYPE_NORMAL
- en: You could definitely write your own code for this, but it's nice to be able
    to use a dedicated library so you can focus on other things that matter, such
    as solving business problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We decided to use the `EventEmitter` library and we do so in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This makes our code a little cleaner because we no longer need to hold an internal
    list of subscribers. There are more changes we can make though, so let us talk
    about that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding to and cleaning up the register method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the store''s jobs has been to handle eventing, especially when the store
    wants to convey to a view that a change has happened to its state. In the `store.js`
    file, other things were happening as well, things like registering ourselves with
    the `dispatcher` and being able to receive dispatched actions. We used these actions
    to alter the state of the store. Let''s remind ourselves what that looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are only supporting one action, namely `SELECT_INDEX`. There are two
    things we need to do here:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the other two actions, `CREATE_PRODUCT` and `REMOVE_PRODUCT`, and the accompanying
    functions `createProduct()` and `removeProduct()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop using magic strings and start using our constants file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the store we created in the `store-event-emitter.js` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s implement the suggested changes from our preceding list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Further improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are definitely more improvements we can make to this code. We did use
    ES2015 imports to import other files, but most of our code was written in ES5
    so why not use most of what ES2015 gives us? Another improvement we can make is
    introducing immutability and making sure our store is not mutated but transitions
    from one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the store file, primarily because that is where we can
    add the most ES2015 syntax. Our revealing module pattern looks like this currently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be replaced with a simple class and instead of instantiating an `EventEmitter`,
    we can inherit from it. In all fairness, we could have used ES2015 inheritance
    or the merge library to not have to create a separate `EventEmitter` instance,
    but this shows how elegant ES2015 can make things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Adding immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other thing we can undertake is adding immutability. The reasons for using
    immutability in the first place are to make your code more predictable, and some
    frameworks can use this for simpler change detection and can rely on reference
    checking over dirty checking. This was the case when AngularJS got its whole change
    detection mechanism changed when Angular was written. From a practical standpoint,
    this means that there are functions we can target in our store and apply immutable
    principles on. The first principle is to not mutate but create an entirely new
    state, instead of where the new state is *the old state + the state change*. A
    simple example of this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are creating a new variable, `newState`, rather than mutating our
    `oldState` variable. There are functions that will help us with this, called `Object.assign`
    and the function filter. We can use these for updating scenarios, as well as adding
    or removing things from a list. Let us use these and rewrite part of our store
    code. Let''s highlight the code we mean to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s apply `Object.assign` and `filter()`, and remember to not mutate things.
    The end result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `createProduct()` method uses an ES2015 construct, namely
    the spread parameter, `...`, which takes a list and turns its members into a comma-separated
    list of items. `Object.assign()` is used to copy over all the values from an object
    so we store the value of an object rather than its reference. The `removeProduct()`
    method becomes very simple when we use the filter method. We simply create a projection
    that does not include the product that we should remove; removing has never been
    this easy or elegant. We haven't mutated anything.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our cleanup started with the view; we wanted to remove a direct connection to
    the dispatcher and also stop having to use magic strings as this is quite error
    prone, and it's easy to misspell. Instead, we can rely on constants. To remedy
    this, we created an action creator class that talked to the dispatcher instead.
  prefs: []
  type: TYPE_NORMAL
- en: We also created a constants module to remove the magic strings.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we improved the store by starting to use `EventEmitter`. Finally,
    we further improved the store by adding more actions to it and also started to
    refer to the constants.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our solution is ready for more actions to be added to it and
    we should feel pretty clear on what files we need to add to, as we support more
    and more user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we added improvements around ES2015 and immutability, which made our
    code look a lot cleaner. With this foundation, we are now ready to go from static
    data to involve working with side effects and Ajax in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us summarize all our improvements in a diagram showing the constructs added
    to our flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dbe10b0-0de5-4ebd-b1b0-a23271451d5e.png)'
  prefs: []
  type: TYPE_IMG
- en: It is clear that using an action creator isn't strictly necessary but it does
    clean up the code quite a bit, and the same goes for using an `EventEmitter` in
    the store; it's nice but not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Adding AJAX calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have only been dealing with static data in our Flux flow. The time
    has now come to add real data connections to the flow and thereby real data. It
    is time to start talking to APIs through AJAX and HTTP. Fetching data is quite
    easy nowadays, thanks to the fetch API and libraries such as RxJS. What you need
    to think about when incorporating it in the flow is:'
  prefs: []
  type: TYPE_NORMAL
- en: Where to place the HTTP call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to ensure that the store is updated and interested views are notified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have a point at which we register the store to the `dispatcher`, with this
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do this for real, that is, call an API to persist this product, `createProduct()`
    would be where we would do the API call, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `fetch()` returns a `Promise`. Let''s use async/await however, as it
    makes the call much more readable. The difference in code can be seen in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Replacing what happens in `createProduct()` with this adds code with a lot
    of noise so it is a good idea to wrap your HTTP interactions in an API construct
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us replace the `createProduct()` method content with the call to our
    API construct like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s not really enough though. Because we created a product through an API
    call, we should dispatch an action that forces the product list to be reread.
    We don''t have such an action or supporting method in a store to handle it, so
    let''s add one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add the required method in the store and the case to handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `CREATE_PRODUCT` case will call the corresponding API method
    `createProduct()`, which on completion will dispatch the `GET_PRODUCTS` action.
    The reason for doing so is that when we successfully manage to create a product,
    we need to read from the endpoint to get an updated version of the products list.
    We don't see that in detail, but it is being invoked through us calling `getProducts()`.
    Again, it is nice to have a wrapper on everything being dispatched, that wrapper
    being an action creator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: An even bigger solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been describing a solution that consists of only a product''s
    topic and communication has only taken place from one view to another. In a more
    realistic application, we would have a lot of topics such as user management,
    orders, and so on; exactly what they are called is dependent on the domain of
    your application. As for views, it is quite possible that you will have a ton
    of views listening to another view, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6da86ae3-4750-451a-8e0c-f0118a549cc3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This describes an application that contains four different view components
    around their own topic. The **Customers view** contains a list of customers and
    it allows us to alter which customer we currently want to focus on. The other
    three supporting views show **Orders**, **Messages**, and **Friends** and their
    content depends on which customer is currently highlighted. From a Flux standpoint,
    the **Orders**, **Messages**, and **Friends** views can easily register with the
    store to know when things gets updated so they can fetch/refetch the data they
    need. However, imagine that the supporting views themselves want to support CRUD
    actions; then they would need their own set of constants, action creator, API,
    and store. So now your application would need to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Two interesting situations exist here:'
  prefs: []
  type: TYPE_NORMAL
- en: You have a self-contained view; all CRUD actions happen within it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a view that needs to listen to other views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first situation, a good rule of thumb is to create its own set of constants,
    action creator, API, and store.
  prefs: []
  type: TYPE_NORMAL
- en: For the second situation, ensure your view registers itself with the store of
    that topic. For example, if the friends view needs to listen to the customer view,
    then it needs to register itself with the customer store.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We set out trying only to explain the Flux architecture pattern. It would have
    been very easy to start mentioning how it fits with React and how there are nice
    libraries and tools that support Flux and React. That would, however, have taken
    our focus away from explaining the pattern from a more framework-agnostic viewpoint.
    Therefore, the rest of this chapter set out to explain core concepts such as actions,
    action creator, dispatcher, store, and uniform data flow. Little by little, we
    improved the code to start using constants, action creators, and a nice supporting
    library such as `EventEmitter`. We explained how HTTP fits into this and, lastly,
    we discussed how we could build out our application. There is a lot more that
    can be said about Flux, but we chose to limit the scope to understanding the fundamentals
    so we can compare its approach as we dive into Redux and NgRx in later chapters,
    which is the main focus of this book.
  prefs: []
  type: TYPE_NORMAL
