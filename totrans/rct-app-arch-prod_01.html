<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer008">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/>1</h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Understanding the Architecture of React Applications</h1>
<p>React is an open source JavaScript library for building user interfaces created and maintained by <span class="No-Break">Meta (Facebook).</span></p>
<p>It is probably the most popular library for building user interfaces nowadays. The reason for its popularity is that it is quite performant and has a small API, which makes it a simple yet very powerful tool for creating <span class="No-Break">user interfaces.</span></p>
<p>It is component-based, which allows us to split large applications into smaller parts and work on them <span class="No-Break">in isolation.</span></p>
<p>React is also great because its core API is decoupled from the platform, allowing projects such as React Native to exist outside the <span class="No-Break">web platform.</span></p>
<p>One of React’s biggest strengths but also weaknesses is that it is very flexible. This has allowed its community to build great solutions. However, defining a good application architecture out of the box can <span class="No-Break">be challenging.</span></p>
<p>Making the right architectural decisions is crucial for any application to succeed, especially once it needs changes or it grows in terms of size, the number of users, and the number of people working <span class="No-Break">on it.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Benefits of having a good <span class="No-Break">application architecture</span></li>
<li>Exploring the architectural challenges of <span class="No-Break">React applications</span></li>
<li>Understanding architectural decisions when building <span class="No-Break">React applications</span></li>
<li>Planning <span class="No-Break">our application</span></li>
</ul>
<p>By the end of this chapter, we will learn to think a bit more from the architectural point of view when starting React <span class="No-Break">application development.</span></p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Benefits of having a good application architecture</h1>
<p>Every application uses some architecture, even without thinking about it. It might have been chosen <a id="_idIndexMarker000"/>randomly and might not be the right one for its needs and requirements, but still, every application does have <span class="No-Break">an architecture.</span></p>
<p>That’s why being mindful of the proper architecture at the beginning is essential for every project. Let’s define a couple of <span class="No-Break">reasons why:</span></p>
<ul>
<li>A good foundation for <span class="No-Break">the project</span></li>
<li>Easier <span class="No-Break">project management</span></li>
<li>Increased development speed <span class="No-Break">and productivity</span></li>
<li><span class="No-Break">Cost-effectiveness</span></li>
<li>Better <span class="No-Break">product quality</span></li>
</ul>
<p>It is worth noting that all applications are prone to requirement changes, so it is not always possible to predict everything upfront. However, we should be mindful of the architecture from the start. We will discuss these reasons in detail in the <span class="No-Break">following sections.</span></p>
<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>A good foundation for the project</h2>
<p>Every building should be built on solid foundations to remain resilient to different conditions such as age, weather conditions, earthquakes, and <span class="No-Break">other causes.</span></p>
<p>The same thing can apply to applications. Multiple factors cause various changes during a project’s lifetime, such as changes in requirements, organization, technologies, market, finance, and more. Being built on solid foundations will make it resilient to all <span class="No-Break">those changes.</span></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Easier project management</h2>
<p>Having different components <a id="_idIndexMarker001"/>organized properly will make organizing and delegating tasks much easier, especially if a larger team <span class="No-Break">is involved.</span></p>
<p>Good component decoupling will allow better splitting of work between teams and team members and faster iterations without team members being blocked by <span class="No-Break">each other.</span></p>
<p>It also allows better estimates to be made regarding how much time is required for a feature to <span class="No-Break">be completed.</span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Increased development speed and productivity</h2>
<p>Having a good architecture defined allows developers to focus on the product they are building without overthinking the technical implementations since most of the technical decisions should have already <span class="No-Break">been made.</span></p>
<p>Besides that, it will provide a smoother onboarding process for new developers, who can be productive quickly after familiarizing themselves with the <span class="No-Break">overall architecture.</span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Cost-effectiveness</h2>
<p>All the reasons mentioned in the previous sections indicate that the improvements a good architecture brings will <span class="No-Break">reduce costs.</span></p>
<p>In most cases, the most expensive cost of every project is people and their work and time. Therefore, by allowing them to be more efficient, we can reduce some redundant costs a bad architecture <span class="No-Break">could bring.</span></p>
<p>It will also allow better financial analysis and planning of pricing models for software products. It will make it easier to predict all the costs the platform requires to <span class="No-Break">be functional.</span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Better product quality</h2>
<p>Making all team members productive gives them time to focus and spend more time on important things, such <a id="_idIndexMarker002"/>as the business requirements and the needs of users, rather than spending most of the time fixing bugs and reducing <span class="No-Break">technical debt.</span></p>
<p>Better product quality will also make our users more satisfied, which should be the <span class="No-Break">end goal.</span></p>
<p>To exist, every piece of software needs to meet its requirements. We’ll see what these software requirements are in the <span class="No-Break">following section.</span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Exploring the architectural challenges of React applications</h1>
<p>In this section, we <a id="_idIndexMarker003"/>will focus on React and see what things are necessary to consider when building React applications and the main challenges most React developers face when building <span class="No-Break">their applications.</span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>What are the challenges when building a React application?</h2>
<p>React is a great tool for building user interfaces. However, there are some challenging things we should <a id="_idIndexMarker004"/>think about when building an application. It is very flexible, which is both a good and a bad thing. It is good in the sense that we can define the architecture of different parts of the application without the library getting in <span class="No-Break">our way.</span></p>
<p>By being so flexible, React has gathered a large community of developers worldwide, building different open-source solutions. There is a complete solution for literally any problem we might encounter during development. This makes the React ecosystem <span class="No-Break">very rich.</span></p>
<p>However, that flexibility and ecosystem richness come with <span class="No-Break">a cost.</span></p>
<p>Let’s take a look at the following React ecosystem overview diagram made <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">roadmap.sh</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer006">
<img alt="Figure 1.1 – React developer roadmap by roadmap.sh " height="1136" src="image/B17297_01_01.jpg" width="984"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – React developer roadmap by roadmap.sh</p>
<p>As shown in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em>, there is a lot to consider when building an application with React. Let’s also keep in mind that this diagram might show just the tip of the iceberg. Many different <a id="_idIndexMarker005"/>packages and solutions could be used to build the <span class="No-Break">same application.</span></p>
<p>Some of the most frequent questions when starting with a new React application are <span class="No-Break">as follows:</span></p>
<ul>
<li>What project structure are <span class="No-Break">we using?</span></li>
<li>What rendering strategy are <span class="No-Break">we using?</span></li>
<li>What state management solution are <span class="No-Break">we using?</span></li>
<li>What styling solution are <span class="No-Break">we using?</span></li>
<li>What data fetching approach are <span class="No-Break">we using?</span></li>
<li>How are we going to handle <span class="No-Break">user authentication?</span></li>
<li>What testing strategies are we going <span class="No-Break">to use?</span></li>
</ul>
<p>These challenges are not limited to React – they are relevant to building frontend applications in general, regardless of which tools are being used. But since this book focuses on React, we will be approaching them from <span class="No-Break">that perspective.</span></p>
<h3>What project structure are we using?</h3>
<p>Because React is very flexible and has a very small API, it is unopinionated about how we should structure our projects. Here is what <em class="italic">Dan Abramov</em>, one of the maintainers of React, says <span class="No-Break">on this:</span></p>
<p class="author-quote">“<em class="italic">Move files around until it feels right</em>”</p>
<p>And that is a very good point. It will mostly depend on the nature of the application. For example, we wouldn’t organize a social network application and a text editor application in the same way because they have different needs and different problems <span class="No-Break">to solve.</span></p>
<h3>What rendering strategy are we using?</h3>
<p>It depends on the nature of <span class="No-Break">our application.</span></p>
<p>If we are building an <a id="_idIndexMarker006"/>internal dashboard application, a single-page application is more <span class="No-Break">than enough.</span></p>
<p>On the other hand, if we build a customer-facing application that should also be public and SEO-friendly, we should think about server-side rendering or static generation, depending on how often the data on the pages are <span class="No-Break">being updated.</span></p>
<h3>What state management solution are we using?</h3>
<p>React comes with built-in state management mechanisms with its hooks and Context API, but for more complex applications, we often reach for external solutions such as <strong class="bold">Redux</strong>, <strong class="bold">MobX</strong>, <strong class="bold">Zustand</strong>, <strong class="bold">Recoil</strong>, <span class="No-Break">and others.</span></p>
<p>Choosing the right state management solution is something that depends a lot on the application’s needs and requirements. We will not reach for the same tools if we are building a to-do app or an <span class="No-Break">e-commerce application.</span></p>
<p>It mostly depends on the amount of state that needs to be shared across the entire application and the frequency of updating those pieces <span class="No-Break">of state.</span></p>
<p>Will our application <a id="_idIndexMarker007"/>have a lot of frequent updates? If that is the case, we might <a id="_idIndexMarker008"/>consider atom-based solutions such as <strong class="bold">Recoil</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="bold">Jotai</strong></span><span class="No-Break">.</span></p>
<p>If our application requires a <a id="_idIndexMarker009"/>lot of different components to share the same state, then <strong class="bold">Redux</strong> with <strong class="bold">Redux Toolkit</strong> is a <a id="_idIndexMarker010"/><span class="No-Break">good option.</span></p>
<p>On the other hand, if we <a id="_idIndexMarker011"/>do not have a lot of global states and don’t update it <a id="_idIndexMarker012"/>very often, then <strong class="bold">Zustand</strong> or <strong class="bold">React Context API</strong>, in combination with hooks, are <span class="No-Break">good choices.</span></p>
<p>At the end of the day, it all depends on the application’s needs and the nature of the problem we are trying <span class="No-Break">to solve.</span></p>
<h3>What styling solution are we using?</h3>
<p>This one mostly depends <a id="_idIndexMarker013"/>on preference. Some people prefer vanilla CSS, some people love <a id="_idIndexMarker014"/>utility-first CSS libraries such as <strong class="bold">Tailwind</strong>, and some developers can’t live without <strong class="bold">CSS </strong><span class="No-Break"><strong class="bold">in JS</strong></span><span class="No-Break">.</span></p>
<p>Making this decision should also depend on whether our application will be re-rendered very often. If that is the <a id="_idIndexMarker015"/>case, we might consider build-time <a id="_idIndexMarker016"/>solutions such as vanilla CSS, SCSS, Tailwind, and others. Otherwise, we <a id="_idIndexMarker017"/>can use runtime styling solutions such as <strong class="bold">Styled Components</strong>, <strong class="bold">Emotion</strong>, <span class="No-Break">and more.</span></p>
<p>We should also keep in mind whether we want to use a pre-built component library or if we want to build everything <span class="No-Break">from scratch.</span></p>
<h3>How are we going to handle user authentication?</h3>
<p>This depends on the API implementation. Are we using token-based authentication? Does our API server <a id="_idIndexMarker018"/>support cookie-based authentication? It is considered to be safer to use cookie-based authentication with <strong class="source-inline">httpOnly</strong> cookies to prevent <strong class="bold">cross-site scripting</strong> (<span class="No-Break"><strong class="bold">XSS</strong></span><span class="No-Break">) attacks.</span></p>
<p>Most of these things should be defined together with the <span class="No-Break">backend teams.</span></p>
<h3>What testing strategies are we going to use?</h3>
<p>This depends on the <a id="_idIndexMarker019"/>team structure, so if we have QA engineers available, we will be able to let them do <span class="No-Break">end-to-end tests.</span></p>
<p>It also depends on how much time we can devote to testing and other aspects. Keep in mind that we should always consider having some level of testing, at least integration, and end-to-end testing for the most critical parts of <span class="No-Break">our application.</span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Understanding architectural decisions when building React applications</h1>
<p>Regardless of the specific needs of the application, there are some generally bad and good decisions we can make when <span class="No-Break">building it.</span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Bad architectural decisions</h2>
<p>Let’s look at some of <a id="_idIndexMarker020"/>the bad architectural decisions that might slow <span class="No-Break">us down.</span></p>
<h3>Flat project structure</h3>
<p>Imagine having a lot of components, all living in the same folder. The simplest thing to do is to place all the React components within the components folder, which is fine if our components count does not exceed 20 components. After that, it becomes difficult to find where a component should belong because they are <span class="No-Break">all mixed.</span></p>
<h3>Large, tightly coupled components</h3>
<p>Having large and coupled components have a couple of downsides. They are difficult to test in isolation, they are difficult to reuse, and they may also have performance issues in some cases because the component would need to be re-rendered entirely instead of us re-rendering just a small part of it that needs to <span class="No-Break">be re-rendered.</span></p>
<h3>Unnecessary global state</h3>
<p>Having a global state is fine, and often required. But keeping too many things in a global state can be a bad idea. It might affect performance, but also maintainability because it makes it difficult to understand the scope of <span class="No-Break">the state.</span></p>
<h3>Using the wrong tools to solve problems</h3>
<p>The number of choices <a id="_idIndexMarker021"/>in the React ecosystem makes it easier to choose the wrong tools to solve a problem – for example, caching server responses in the global store. It may be possible, and we have been doing this in the past, but that doesn’t mean we should keep doing that because there are tools to solve this problem, such as React Query, SWR, Apollo Client, and <span class="No-Break">so on.</span></p>
<h3>Putting the entire application in a single component in a single file</h3>
<p>This is something that shouldn’t ever happen, but it is still worth mentioning. Nothing is preventing us from creating a complete application in a single file. It could be thousands of lines long – that is, a single component that would do everything. But for the same reason as having large components, it should <span class="No-Break">be avoided.</span></p>
<h3>Not sanitizing user inputs</h3>
<p>Many hackers on the web are trying to steal our user’s data. Therefore, we should do everything possible to prevent such things from happening. By sanitizing user inputs, we can prevent hackers from executing some malicious piece of code in our application and stealing user data. For example, we should prevent our users from inputting anything that could be executed in our application by removing any parts of the input that might <span class="No-Break">be risky.</span></p>
<h3>Using unoptimized infrastructure to serve our application</h3>
<p>Using unoptimized infrastructure to serve our application will make our application slow when accessed from different parts of <span class="No-Break">the world.</span></p>
<p>Now that we have <a id="_idIndexMarker022"/>covered some bad architectural decisions, let’s see how to <span class="No-Break">improve them.</span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Good architectural decisions</h2>
<p>Let’s look at <a id="_idIndexMarker023"/>some of the good decisions we can make to make our <span class="No-Break">application better.</span></p>
<h3>Better structured project structure based on domain and features</h3>
<p>Splitting the application structure into different features or domain-specific modules, each responsible for its own role, will allow better separation of concerns of different application pieces, better modularity of different parts of the application, better flexibility, <span class="No-Break">and scalability.</span></p>
<h3>Better state management</h3>
<p>Instead of putting everything in a global state, we should start by defining a piece of a state as close as possible to where it is being used in the component and lift it only <span class="No-Break">if necessary.</span></p>
<h3>Smaller components</h3>
<p>Having smaller components will make them more testable, easier to track changes, and easier to work in <span class="No-Break">larger teams.</span></p>
<h3>Separation of concerns</h3>
<p>Have each component do as little as possible. This makes components easy to understand, test, modify, and <span class="No-Break">even reuse.</span></p>
<h3>Static code analysis</h3>
<p>Relying on static code analysis tools such as <strong class="bold">ESLint</strong>, <strong class="bold">Prettier</strong>, and <strong class="bold">TypeScript</strong> will improve our <a id="_idIndexMarker024"/>code quality without <a id="_idIndexMarker025"/>us having to think too much about it. We just need <a id="_idIndexMarker026"/>to configure these tools, and they will let us know when something is wrong with our code. These tools also introduce consistency in the code base regarding formatting, code practices, <span class="No-Break">and documentation.</span></p>
<h3>Deploying the application over a CDN</h3>
<p>Having users worldwide means our application should be functional and accessible from all over the world. By deploying <a id="_idIndexMarker027"/>the application on a CDN, users all over the world can access the application in the most <span class="No-Break">optimal way.</span></p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Planning our application</h1>
<p>Now, let’s apply the principles we just learned about to a real-world scenario where we will be planning the application that we will <span class="No-Break">be building.</span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>What are we building?</h2>
<p>We will be building an <a id="_idIndexMarker028"/>application that allows organizations to manage their job boards. The organization admins can create job postings for their organizations, and the candidates can apply for <span class="No-Break">the jobs.</span></p>
<p>We will be building an MVP version of the application with the minimum set of features, but it should be extendable for more features in the future. At the end of this book, we will cover the features that the final application could have, but to keep things simple, we will be focusing on the <span class="No-Break">MVP version.</span></p>
<p>Proper application planning starts with gathering the requirements of <span class="No-Break">the application.</span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Application requirements</h2>
<p>The application <a id="_idIndexMarker029"/>has two types of <span class="No-Break">application requirements:</span></p>
<ul>
<li><span class="No-Break">Functional requirements</span></li>
<li><span class="No-Break">Non-functional requirements</span></li>
</ul>
<h3>Functional requirements</h3>
<p>Functional requirements should <a id="_idIndexMarker030"/>define what the <a id="_idIndexMarker031"/>application should do. They are descriptions of all the features <a id="_idIndexMarker032"/>and functionalities of an application <a id="_idIndexMarker033"/>that our users <span class="No-Break">would use.</span></p>
<p>Our application can be split into <span class="No-Break">two parts:</span></p>
<ul>
<li>Publicly <span class="No-Break">facing part</span></li>
<li>Organization <span class="No-Break">admin dashboard</span></li>
</ul>
<h4>Publicly facing part</h4>
<ul>
<li>Landing page<a id="_idIndexMarker034"/> with some basic information about <span class="No-Break">our application.</span></li>
<li>Public organization view where the visitors can find information about the given organization. Besides the basic organization information, it should also include the list of jobs of <span class="No-Break">the organization.</span></li>
<li>A public job view where the visitors can view some basic information about the given job. Besides this information, it should also include the action for applying for <span class="No-Break">the job.</span></li>
</ul>
<h4>Organization admin dashboard</h4>
<ul>
<li>Authentication system <a id="_idIndexMarker035"/>for the dashboard that should allow organization admins to authenticate into the dashboard. For our MVP, we will just implement the login functionality with an existing <span class="No-Break">test user.</span></li>
<li>Jobs list view where the admin can view all the jobs of <span class="No-Break">the organization.</span></li>
<li>Create a job view that contains the form for creating <span class="No-Break">new jobs.</span></li>
<li>Job details view, which contains all the information about <span class="No-Break">the job.</span></li>
</ul>
<h3>Non-functional requirements</h3>
<p>Non-functional requirements <a id="_idIndexMarker036"/>should define how <a id="_idIndexMarker037"/>the application should work from the <span class="No-Break">technical side:</span></p>
<ul>
<li><strong class="bold">Performance</strong>: The application must be interactive within 5 seconds. By that, we mean that the user should be able to interact with the page within 5 seconds from when the request to load the application was made until the user can interact with <span class="No-Break">the page.</span></li>
<li><strong class="bold">Usability</strong>: The application must be user-friendly and intuitive. This includes implementing responsive design for smaller screens. We want the user experience to be smooth <span class="No-Break">and straightforward.</span></li>
<li><strong class="bold">SEO</strong>: The public-facing pages of the application should <span class="No-Break">be SEO-friendly.</span></li>
</ul>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Data model overview</h2>
<p>To better understand <a id="_idIndexMarker038"/>how our application will work <a id="_idIndexMarker039"/>under the hood, it is helpful to understand its data model, so we will dive into that in <span class="No-Break">this section.</span></p>
<p>In the following diagram, we can see what our data model looks like from the <span class="No-Break">database perspective:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer007">
<img alt="Figure 1.2 – Data model overview " height="804" src="image/B17297_01_02.jpg" width="1135"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Data model overview</p>
<p>As seen in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.2</em>, there <a id="_idIndexMarker040"/>are three main models <a id="_idIndexMarker041"/>in <span class="No-Break">the application:</span></p>
<ul>
<li><span class="No-Break">User</span></li>
<li><span class="No-Break">Organization</span></li>
<li><span class="No-Break">Job</span></li>
</ul>
<p>Defining the application requirements and data model should give us a good understanding of what we are building. Now, let’s explore the technical decisions for <span class="No-Break">our application.</span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Exploring the technical decisions</h2>
<p>Let’s see what technical <a id="_idIndexMarker042"/>decisions we need to <a id="_idIndexMarker043"/>make for <span class="No-Break">our application.</span></p>
<h3>Project structure</h3>
<p>We will be using <a id="_idIndexMarker044"/>a feature-based project structure that allows good feature isolation and good communication between <span class="No-Break">the features.</span></p>
<p>This means <a id="_idIndexMarker045"/>we will create a feature folder for every larger functionality, which will make the application structure <span class="No-Break">more scalable.</span></p>
<p>It will scale very well when the number of features increases because we only need to worry about a specific feature and not the entire application at once, where the code is scattered all over <span class="No-Break">the place.</span></p>
<p>We will see the project structure definition in action in the <span class="No-Break">upcoming chapters.</span></p>
<h3>Rendering strategy</h3>
<p>When it comes <a id="_idIndexMarker046"/>to the rendering strategy, we are referring to the <a id="_idIndexMarker047"/>way the pages of our application are <span class="No-Break">being created.</span></p>
<p>Let’s look at the different types of <span class="No-Break">rendering strategies:</span></p>
<ul>
<li><strong class="bold">Server-side rendering</strong>:  In the early days of the web, this was the most common way <a id="_idIndexMarker048"/>to generate pages with dynamic content. The page content is created on the fly, inserted into the page on the server, and then returned to the client. The benefits of this approach are that the pages are easier to crawl by search engines, which is important for SEO, and users might get faster initial loads of the page compared to single-page apps. The downside of this approach is that it might require more server resources. In our scenario, we will be using this approach for the pages that can be updated frequently and should be SEO optimized at the same time, such as the public organization page and public <span class="No-Break">job page.</span></li>
<li><strong class="bold">Client-side rendering</strong>: The existence of client-side JavaScript libraries and frameworks, such <a id="_idIndexMarker049"/>as React, Angular, Vue, and others, allows us to create complex client-side applications completely on the client. The benefit of this is that once the application is loaded in the browser, the transition between pages seems very fast. On the other hand, for the application to load, we need to download a lot of JavaScript to use the application. This can be improved by code splitting and lazy loading. It is also more <a id="_idIndexMarker050"/>difficult to crawl the page’s content using search engines, which can impact SEO scores. We can use this approach for protected pages, which is every page in the dashboard of <span class="No-Break">our application.</span></li>
<li><strong class="bold">Static generation</strong>: This is the most straightforward approach. Here, we can generate our <a id="_idIndexMarker051"/>pages while building the application and serve them statically. It is very fast, and we can use this approach for <a id="_idIndexMarker052"/>pages that never update but need to <a id="_idIndexMarker053"/>be SEO optimized, such as the landing page of <span class="No-Break">our application.</span></li>
</ul>
<p>Since our application requires multiple rendering strategies, we will use Next.js, which supports each of them <span class="No-Break">very well.</span></p>
<h3>State management</h3>
<p>State management is probably one of the most discussed topics in the React ecosystem. It is very <a id="_idIndexMarker054"/>fragmented, meaning there are so many libraries that <a id="_idIndexMarker055"/>handle state that it makes it difficult for the developers to make <span class="No-Break">a choice.</span></p>
<p>To make state management easier for us, we need to understand that there are multiple types <span class="No-Break">of states:</span></p>
<ul>
<li><strong class="bold">Local state</strong>: This is <a id="_idIndexMarker056"/>the simplest type of state. It is the state that is being used in a single component only and is not required anywhere else. We will use the built-in React hooks to <span class="No-Break">handle that.</span></li>
<li><strong class="bold">Global state</strong>: This is the state <a id="_idIndexMarker057"/>that is shared across <a id="_idIndexMarker058"/>multiple components in the application. It is used to avoid prop drilling. We will be using a lightweight library called <strong class="bold">Zustand</strong> <span class="No-Break">for this.</span></li>
<li><strong class="bold">Server state</strong>: This state is <a id="_idIndexMarker059"/>used to store data responses from the API. Things such as loading states, request de-duplications, polling, and others are very challenging to implement from scratch. Therefore, we <a id="_idIndexMarker060"/>will be using <strong class="bold">React Query</strong> to handle this elegantly so that we have less code <span class="No-Break">to write.</span></li>
<li><strong class="bold">Form state</strong>: This should <a id="_idIndexMarker061"/>handle form inputs, validation, and other aspects. We will be using the <strong class="bold">React Hook Form</strong> library to handle forms in <span class="No-Break">our application.</span></li>
<li><strong class="bold">URL state</strong>: This type of state is often overlooked yet very powerful. URL and query params <a id="_idIndexMarker062"/>can also be considered as pieces of state. This is <a id="_idIndexMarker063"/>especially useful when we <a id="_idIndexMarker064"/>want to deep-link some part of the view. Capturing the state in the URL makes it very easy to <span class="No-Break">share it.</span></li>
</ul>
<h3>Styling</h3>
<p>Styling is also a big <a id="_idIndexMarker065"/>topic in the React ecosystem. There are many great libraries <a id="_idIndexMarker066"/>for styling <span class="No-Break">React components.</span></p>
<p>To style our application, we will use the <strong class="bold">Chakra UI</strong> component library, which uses Emotion under the <a id="_idIndexMarker067"/>hood, and it comes with a variety of nice-looking and accessible components that are very flexible and easy <span class="No-Break">to modify.</span></p>
<p>The reason for choosing Chakra UI is that it has a great developer experience. It is very customizable, and its components are accessibility-friendly out of <span class="No-Break">the box.</span></p>
<h3>Authentication</h3>
<p>The authentication <a id="_idIndexMarker068"/>of our application will be cookie-based, meaning <a id="_idIndexMarker069"/>that on a successful auth request, a cookie will be attached to the headers, which will handle user authentication on the server. We are choosing cookie-based authentication because it is <span class="No-Break">more secure.</span></p>
<h3>Testing</h3>
<p>Testing is a very important <a id="_idIndexMarker070"/>method of asserting that our application is <a id="_idIndexMarker071"/>working as it’s <span class="No-Break">supposed to.</span></p>
<p>We don’t want to ship our product with bugs in it. Also, manual testing takes more time and effort to discover new bugs, so we want to have automated tests for <span class="No-Break">our application.</span></p>
<p>There are multiple types <span class="No-Break">of tests:</span></p>
<ul>
<li><strong class="bold">Unit tests</strong>: Unit tests only test the <a id="_idIndexMarker072"/>smallest units of an application in <a id="_idIndexMarker073"/>isolation. We will be using <strong class="bold">Jest</strong> to unit-test the shared components of <span class="No-Break">our application.</span></li>
<li><strong class="bold">Integration tests</strong>: Integration tests test multiple units at once. They are very useful for testing the communication <a id="_idIndexMarker074"/>between multiple different parts of the <a id="_idIndexMarker075"/>application. We will be using <strong class="bold">React Testing Library</strong> to test <span class="No-Break">our pages.</span></li>
<li><strong class="bold">End-to-end tests</strong>: End-to-end tests allow <a id="_idIndexMarker076"/>us to test our application’s most important parts end to <a id="_idIndexMarker077"/>end, meaning we can test <a id="_idIndexMarker078"/>the entire flow. Usually, the most important end-to-end tests should test the most <a id="_idIndexMarker079"/>critical features. For this kind of testing, we will be <span class="No-Break">using </span><span class="No-Break"><strong class="bold">Cypress</strong></span><span class="No-Break">.</span></li>
</ul>
<p>This was an overview of <a id="_idIndexMarker080"/>how our application should work. Now, we should be <a id="_idIndexMarker081"/>able to start implementing it in code in the <span class="No-Break">upcoming chapters.</span></p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Summary</h1>
<p>React is a very popular library for building user interfaces, and it leaves most of the architectural choices to developers, which can <span class="No-Break">be challenging.</span></p>
<p>In this chapter, we learned that some of the benefits of setting up a good architecture are a good project foundation, easier project management, increased productivity, cost-effectiveness, and better <span class="No-Break">product quality.</span></p>
<p>We also learned about the challenges to consider, such as project structure, rendering strategies, state management, styling, authentication, testing, <span class="No-Break">and others.</span></p>
<p>Then, we covered the planning phase of the application that we will be building, which is an application for managing job boards and job applications by gathering requirements. We did that by defining the data model of the application and choosing the right tools to overcome the <span class="No-Break">architectural challenges.</span></p>
<p>This has given us a good foundation to implement our architecture in a real-world scenario, as we will see in the <span class="No-Break">following chapters.</span></p>
<p>In the next chapter, we will cover the entire setup that we will be using for building <span class="No-Break">the application.</span></p>
</div>
</div></body></html>