- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Understanding React Components and JSX
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 React 组件和 JSX
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几点：
- en: Define what exactly components are
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义组件的确切含义
- en: Build and use components effectively
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地构建和使用组件
- en: Utilize common naming conventions and code patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用常见的命名约定和代码模式
- en: Describe the relationship between components and JSX
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述组件和 JSX 之间的关系
- en: Write JSX code and understand why it’s used
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 JSX 代码并理解其用途
- en: Write React components without using JSX code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用 JSX 代码编写 React 组件
- en: Write your first React apps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你的第一个 React 应用程序
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you learned about React in general, what it is, and
    why you should consider using it for building user interfaces. You also learned
    how to create React projects with the help of Vite, by running `npm create vite@latest
    <your-project-name>` .
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你了解了 React 的基础知识，它是什么，以及为什么你应该考虑使用它来构建用户界面。你还学习了如何使用 Vite 创建 React 项目，通过运行
    `npm create vite@latest <your-project-name>` 来实现。
- en: In this chapter, you will learn about one of the most important React concepts
    and building blocks. You will learn that components are reusable building blocks
    that are used to build user interfaces. In addition, JSX code will be discussed
    in greater detail so that you will be able to use the concept of components and
    JSX to build your own first basic React apps.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 React 最重要概念和构建块之一。你将了解到组件是可重用的构建块，用于构建用户界面。此外，还将更详细地讨论 JSX 代码，以便你能够使用组件和
    JSX 的概念来构建你自己的第一个基本 React 应用程序。
- en: What Are Components?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件是什么？
- en: A key concept of React is the usage of so-called components. **Components**
    are reusable building blocks that are combined to compose the final user interface.
    For example, a basic website could be made up of a sidebar that includes navigation
    items and a main section that includes elements for adding and viewing tasks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: React 的一个关键概念是所谓的组件的使用。**组件**是可重用的构建块，它们被组合起来构成最终的用户界面。例如，一个基本的网站可以由包含导航项的侧边栏和一个包含添加和查看任务元素的主体部分组成。
- en: '![img](img/B31339_02_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_02_01.png)'
- en: 'Figure 2.1: An example task management screen with sidebar and main area'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：一个包含侧边栏和主区域的示例任务管理屏幕
- en: 'If you look at this example page, you might be able to identify various building
    blocks (i.e., components). Some of these components are even reused:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这个示例页面，你可能能够识别出各种构建块（即组件）。其中一些组件甚至被重复使用：
- en: The sidebar and its navigation items
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侧边栏及其导航项
- en: The main page area
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页面区域
- en: In the main area, the header with the title and due date
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主区域，包含标题和截止日期的页眉
- en: A form for adding tasks
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加任务的表单
- en: A list of tasks
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务列表
- en: Please note that some components are nested inside other components—i.e., components
    are also made up of other components. That’s a key feature of React and similar
    libraries.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些组件嵌套在其他组件内部——即，组件也由其他组件组成。这是 React 和类似库的关键特性。
- en: Why Components?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要组件？
- en: No matter which web page you look at, they are all made up of building blocks
    like this. It’s not a React-specific concept or idea. Indeed, HTML itself “thinks”
    in components if you take a closer look. You have elements like `<img>` , `<header>`
    , `<nav>` , etc., and you combine these elements to describe and structure your
    website content.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你查看哪个网页，它们都是由这样的构建块组成的。这不是一个特定于 React 的概念或想法。实际上，如果你仔细观察，HTML 本身“认为”在组件中。你有一些元素，如
    `<img>`、`<header>`、`<nav>` 等，你将这些元素组合起来描述和结构化你的网站内容。
- en: But React **embraces** this idea of breaking a web page into reusable building
    blocks because it is an approach that allows developers to work on small, manageable
    chunks of code. It’s easier and more maintainable than working on a single, huge
    HTML (or React code) file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但 React **接受**将网页分解为可重用构建块的想法，因为这是一种允许开发者对小块、可管理的代码进行工作的方法。与处理单个、巨大的 HTML（或
    React 代码）文件相比，这更容易且更易于维护。
- en: That’s why other libraries—both frontend libraries like React or Angular as
    well as backend libraries and templating engines like **EJS** ( **Embedded JavaScript
    templates** )—also embrace components (though the names might differ, you also
    find *“partials”* or *“includes”* as common names).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，其他库——无论是前端库如 React 或 Angular，还是后端库和模板引擎如 **EJS**（**嵌入式 JavaScript 模板**）——也接受组件（尽管名称可能不同，你也会找到
    *“部分”* 或 *“包含”* 作为常见名称）。
- en: '**Note**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: EJS is a popular templating engine for JavaScript. It’s especially popular for
    backend web development with Node.js.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: EJS是JavaScript的一个流行模板引擎。它特别适合与Node.js一起进行后端Web开发。
- en: When working with React, it’s especially important to keep your code manageable
    and work with small, reusable components because React components are not just
    collections of HTML code. Instead, a React component also encapsulates JavaScript
    logic and often also CSS styling. For complex user interfaces, the combination
    of markup (JSX), logic (JavaScript), and styling (CSS) could quickly lead to large
    chunks of code, thus making it difficult to maintain that code. Think of a large
    HTML file that also includes JavaScript and CSS code. Working in such a code file
    wouldn’t be a lot of fun.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用React时，保持你的代码可管理并与小型、可重用组件一起工作尤为重要，因为React组件不仅仅是HTML代码的集合。相反，React组件还封装了JavaScript逻辑，通常还封装了CSS样式。对于复杂的用户界面，标记（JSX）、逻辑（JavaScript）和样式（CSS）的组合可能会迅速导致大量代码，这使得维护这些代码变得困难。想象一下一个包含JavaScript和CSS代码的大型HTML文件。在这样的代码文件中工作不会很有趣。
- en: To make a long story short, when working on a React project, you will work with
    lots of components. You will split your code into small, manageable building blocks
    and then combine these components to form the overall user interface. It’s a key
    feature of React.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当你在React项目中工作时，你将处理很多组件。你会将你的代码分割成小而可管理的构建块，然后将这些组件组合起来形成整体的用户界面。这是React的一个关键特性。
- en: '**Note**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: When working with React, you should embrace this idea of working with components.
    But technically, they’re optional. You could, theoretically, build very complex
    web pages with one single component alone. It would not be much fun, and it would
    not be practical, but it would technically be possible without any issues.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用React时，你应该接受这种与组件一起工作的想法。但从技术上讲，这是可选的。理论上，你可以仅使用一个组件构建非常复杂的网页。这不会很有趣，也不太实用，但从技术上讲，没有任何问题。
- en: The Anatomy of a Component
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件的解剖结构
- en: Components are important. But what exactly does a React component look like?
    How do you write React components on your own?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 组件很重要。但一个React组件究竟是什么样子？你如何自己编写React组件？
- en: 'Here’s an example component:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例组件：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Typically, you would store a code snippet like this in a separate file (e.g.,
    a file named `SubmitButton.jsx` , stored inside a `/components` folder, which
    in turn resides in the `/src` folder of your React project) and import it into
    other component files that need this component. `.jsx` is used as an extension
    since the file contains JSX code. Vite enforces the usage of `.jsx` as a file
    extension if you’re writing JSX code – storing such code in `.js` files is not
    allowed in Vite projects (even though it might work in other React project setups).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会将这样的代码片段存储在一个单独的文件中（例如，一个名为`SubmitButton.jsx`的文件，存储在`/components`文件夹中，该文件夹位于你的React项目的`/src`文件夹中），并将其导入需要此组件的其他组件文件中。`.jsx`被用作扩展名，因为该文件包含JSX代码。Vite强制使用`.jsx`作为文件扩展名，如果你正在编写JSX代码——在Vite项目中不允许将此类代码存储在`.js`文件中（尽管在其他React项目设置中可能可行）。
- en: 'The following component imports the component defined above and uses it in
    its `return` statement to output the `SubmitButton` component:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下组件导入上面定义的组件，并在其`return`语句中使用它来输出`SubmitButton`组件：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `import` statements you see in these examples are standard JavaScript `import`
    statements. Theoretically, in Vite-based projects, you could omit the file extension
    ( `.jsx` in this case) in the `import` statement. However, it might be a good
    idea to include the extension since that’s in line with standard JavaScript. When
    importing from third-party packages (like `useState` from the `react` package),
    no file extension is added though – you just use the package name. `import` and
    `export` are standard JavaScript keywords that help with splitting related code
    across multiple files. Things like variables, constants, classes, or functions
    can be exported via `export` or `export default` so that they can then be used
    in other files after importing them there.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这些示例中看到的`import`语句是标准的JavaScript `import`语句。理论上，在基于Vite的项目中，你可以在`import`语句中省略文件扩展名（在这个例子中是`.jsx`）。然而，包含扩展名可能是个好主意，因为这符合标准JavaScript。当你从第三方包（如`react`包中的`useState`）导入时，不需要添加文件扩展名——你只需使用包名。`import`和`export`是标准的JavaScript关键字，有助于将相关代码分割到多个文件中。像变量、常量、类或函数这样的东西可以通过`export`或`export
    default`导出，以便在导入后可以在其他文件中使用。
- en: '**Note**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If the concept of splitting code into multiple files and using `import` and
    `export` is brand-new to you, you might want to dive into more basic JavaScript
    resources on this topic first. For example, MDN has an excellent article that
    explains the fundamentals, which you can find at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)
    .
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将代码拆分为多个文件并使用`import`和`export`的概念对你来说完全陌生，你可能首先需要深入了解有关此主题的基本JavaScript资源。例如，MDN有一篇优秀的文章解释了基础知识，您可以在[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)找到。
- en: Of course, the components shown in these examples are highly simplified and
    also contain features that you haven’t learned about yet (e.g., `useState()` ).
    However, the general idea of having standalone building blocks that can be combined
    should be clear.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些示例中展示的组件非常简化，也包含了一些你尚未学习到的功能（例如，`useState()`）。然而，拥有可以组合的独立构建块的一般想法应该是清晰的。
- en: 'When working with React, there are two alternative ways to define components:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用React时，有两种不同的方式来定义组件：
- en: '**Class-based components** (or “class components”): Components defined via
    the `class` keyword'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于类的组件**（或“类组件”）：通过`class`关键字定义的组件'
- en: '**Functional components** (or “function components”): Components that are defined
    via regular JavaScript functions'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数组件**（或“函数组件”）：通过常规JavaScript函数定义的组件'
- en: In all the examples covered in this book, components are built as JavaScript
    functions. As a React developer, you have to use one of these two approaches as
    React expects components to be functions or classes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书涵盖的所有示例中，组件都是作为JavaScript函数构建的。作为一名React开发者，你必须使用这两种方法之一，因为React期望组件是函数或类。
- en: '**Note**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'Until late 2018, you had to use class-based components for certain kinds of
    tasks—specifically, for components that use state internally. (State will be covered
    in *Chapter 4* , *Working with Events and State* ). However, in late 2018, a new
    concept was introduced: **React Hooks** . This allows you to perform all operations
    and tasks with functional components. Consequently, while still supported by React,
    class-based components are on their way out and are not covered in this book.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 直到2018年底，你必须使用基于类的组件来完成某些类型的任务——特别是对于使用内部状态的组件。（状态将在*第4章*，*处理事件和状态*中介绍）。然而，在2018年底，引入了一个新的概念：**React
    Hooks**。这允许你使用函数组件执行所有操作和任务。因此，尽管仍然由React支持，但基于类的组件正在逐渐淘汰，本书中不会涉及。
- en: 'In the examples above, there are a couple of other noteworthy things:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，还有一些其他值得注意的事情：
- en: The component functions carry capitalized names (e.g., `SubmitButton` )
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件函数具有大写命名的名称（例如，`SubmitButton`）
- en: Inside the component functions, other “inner” functions can be defined (e.g.,
    `handleSubmit` , typically written in **camelCase** )
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件函数内部，可以定义其他“内部”函数（例如，`handleSubmit`，通常使用**camelCase**编写）
- en: The component functions return *HTML-like* code (JSX code)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件函数返回类似*HTML*的代码（JSX代码）
- en: Features like `useState()` can be used inside the component functions
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于`useState()`这样的功能可以在组件函数内部使用
- en: The component functions are exported (via `export default` )
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件函数通过`export default`导出
- en: Certain features (like `useState` or the custom component `SubmitButton` ) are
    imported via the `import` keyword
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些功能（如`useState`或自定义组件`SubmitButton`）通过`import`关键字导入
- en: The following sections will take a closer look at these different concepts that
    make up components and their code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将更深入地探讨构成组件及其代码的不同概念。
- en: What Exactly Are Component Functions?
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件函数究竟是什么？
- en: In React, components are functions (or classes, but as mentioned above, those
    aren’t relevant anymore).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，组件是函数（或类，但如上所述，那些不再相关了）。
- en: A function is a regular JavaScript construct, not a React-specific concept.
    This is important to note. React is a JavaScript library and consequently **uses
    JavaScript features** (like functions); React is **not a brand-new programming
    language** .
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一个常规的JavaScript构造，不是一个React特定的概念。这一点很重要。React是一个JavaScript库，因此**使用JavaScript功能**（如函数）；React**不是一个全新的编程语言**。
- en: 'When working with React, regular JavaScript functions can be used to encapsulate
    HTML (or, to be more precise, JSX) code and JavaScript logic that belongs to that
    markup code. However, it depends on the code you write in a function whether it
    qualifies to be treated as a React component or not. For example, in the code
    snippets above, the `handleSubmit` function is also a regular JavaScript function,
    but it’s not a React component. The following example shows another regular JavaScript
    function that doesn’t qualify as a React component:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React 时，可以使用常规 JavaScript 函数来封装属于该标记代码的 HTML（或者更准确地说，是 JSX）代码和 JavaScript
    逻辑。然而，一个函数是否可以被视为 React 组件，取决于你在这个函数中编写的代码。例如，在上面的代码片段中，`handleSubmit` 函数也是一个常规
    JavaScript 函数，但它不是 React 组件。以下示例展示了另一个不符合 React 组件资格的常规 JavaScript 函数：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Indeed, a function will be treated as a component and can therefore be used
    like an HTML element in JSX code if it returns a **renderable** value (typically
    JSX code). This is very important. You can only use a function as a React component
    in JSX code if it is a function that returns something that can be rendered by
    React. The returned value technically doesn’t have to be JSX code, but in most
    cases, it will be. You will see an example of non-JSX code being returned in *Chapter
    7* , *Portals and Refs* .
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果一个函数返回一个 **可渲染** 的值（通常是 JSX 代码），它将被视为一个组件，因此可以像 HTML 元素一样在 JSX 代码中使用。这非常重要。你只能在
    JSX 代码中使用函数作为 React 组件，如果它返回的是 React 可以渲染的东西。返回的值在技术上不必是 JSX 代码，但在大多数情况下，它将是。你将在
    *第 7 章* 中看到一个返回非 JSX 代码的例子，*Portals 和 Refs*。
- en: In the code snippet where functions named `SubmitButton` and `AuthForm` were
    defined, those two functions qualified as React components because they both returned
    JSX code (which is code that can be rendered by React, making it renderable).
    Once a function qualifies as a React component, it can be used like an HTML element
    inside of JSX code, just as `<SubmitButton />` was used like a (self-closing)
    HTML element.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义名为 `SubmitButton` 和 `AuthForm` 的函数的代码片段中，这两个函数符合 React 组件的资格，因为它们都返回了 JSX
    代码（这是 React 可以渲染的代码，使其可渲染）。一旦一个函数符合 React 组件的资格，它就可以像 HTML 元素一样在 JSX 代码中使用，就像
    `<SubmitButton />` 被用作（自闭合的）HTML 元素一样。
- en: When working with vanilla JavaScript, you, of course, typically call functions
    to execute them. With functional components, that’s different. React calls these
    functions on your behalf, and for that reason, as a developer, you use them like
    HTML elements inside of this JSX code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用纯 JavaScript 时，你当然通常调用函数来执行它们。对于函数组件，情况不同。React 代表你调用这些函数，因此，作为一个开发者，你将它们用作
    JSX 代码中的 HTML 元素。
- en: '**Note**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: When referring to renderable values, it is worth noting that by far the most
    common value type being returned or used is indeed JSX code—i.e., markup defined
    via JSX. This should make sense because, with JSX, you can define the HTML-like
    structure of your content and user interface.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当提到可渲染值时，值得注意的是，到目前为止，最常见返回或使用的值类型确实是 JSX 代码——即通过 JSX 定义的标记。这应该是有道理的，因为使用 JSX，你可以定义你内容和使用界面的类似
    HTML 的结构。
- en: But besides JSX markup, there are a couple of other key values that also qualify
    as renderable and therefore could be returned by custom components (instead of
    JSX code). Most notably, you can also return strings or numbers as well as arrays
    that hold JSX elements or strings or numbers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 JSX 标记之外，还有一些其他关键值也符合可渲染的资格，因此也可以由自定义组件返回（而不是 JSX 代码）。最值得注意的是，你也可以返回字符串或数字，以及包含
    JSX 元素、字符串或数字的数组。
- en: What Does React Do with All These Components?
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 都用这些组件做了些什么？
- en: If you follow the trail of all components and their `import` and `export` statements
    to the top, you will find a `root.render(...)` instruction in the main entry script
    of the React project. Typically, this main entry script can be found in the `main.jsx`
    file, located in the project’s `src/` folder. This `render()` method, which is
    provided by the React library (to be precise, by the `react-dom` package), takes
    a snippet of JSX code and interprets and executes it for you.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你追踪所有组件及其 `import` 和 `export` 语句到顶部，你将在 React 项目的入口脚本中找到一个 `root.render(...)`
    指令。通常，这个主入口脚本可以在项目的 `src/` 文件夹中的 `main.jsx` 文件中找到。这个由 React 库（确切地说，由 `react-dom`
    包）提供的 `render()` 方法接受一段 JSX 代码，并为你解释和执行它。
- en: 'The complete snippet you find in the root entry file ( `main.jsx` ) typically
    looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你在根入口文件（`main.jsx`）中找到的完整代码片段通常如下所示：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The exact code you find in your new React project might look slightly different.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你在新的 React 项目中找到的确切代码可能看起来略有不同。
- en: It may, for instance, include an extra `<StrictMode>` element that’s wrapped
    around `<App>` . `<StrictMode>` turns on extra checks that can help catch subtle
    bugs in your React code. But it can also lead to confusing behavior and unexpected
    error messages, especially when experimenting with React or learning React. As
    this book is primarily interested in the coverage of React core features and key
    concepts, `<StrictMode>` will not be used.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它可能包含一个额外的 `<StrictMode>` 元素，该元素被 `<App>` 包围。`<StrictMode>` 会开启额外的检查，这有助于捕捉
    React 代码中的细微错误。但这也可能导致令人困惑的行为和意外的错误信息，尤其是在实验 React 或学习 React 时。由于本书主要关注 React
    核心功能和关键概念的覆盖，因此不会使用 `<StrictMode>`。
- en: 'While omitted here, strict mode will be covered in *Chapter 10* , *Behind the
    Scenes of React and Optimization Opportunities* . If you want to learn more about
    it right now, you can delve into the official documentation: [https://react.dev/reference/react/StrictMode](https://react.dev/reference/react/StrictMode)
    . Just be aware that some of the effects triggered by strict mode will be easier
    to understand after you’ve read more of this book.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这里省略了，但严格模式将在第 10 章“React 背后场景和优化机会”中介绍。如果你现在想了解更多关于它的信息，可以深入了解官方文档：[https://react.dev/reference/react/StrictMode](https://react.dev/reference/react/StrictMode)。但请注意，在阅读更多本书内容之后，严格模式触发的某些效果将更容易理解。
- en: To follow along smoothly then, cleaning up a newly created `main.jsx` file to
    look like the code snippet above is a good idea.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了顺利地跟随，清理一个新创建的 `main.jsx` 文件，使其看起来像上面的代码片段是一个好主意。
- en: The `createRoot()` method instructs React to create a new **entry point** ,
    which will be used to inject the generated user interface into the actual HTML
    document that will be served to website visitors. The argument passed to `createRoot()`
    therefore is a pointer to a DOM element that can be found in `index.html` —the
    single page that will be served to website visitors.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`createRoot()` 方法指示 React 创建一个新的 **入口点**，该入口点将用于将生成的用户界面注入要提供给网站访问者的实际 HTML
    文档中。因此传递给 `createRoot()` 的参数是指向可以在 `index.html` 中找到的 DOM 元素的指针——这是将被提供给网站访问者的单个页面。'
- en: In many cases, `document.getElementById('root')` is used as an argument. This
    built-in vanilla JavaScript method yields a reference to a DOM element that is
    already part of the `index.html` document. Hence, as a developer, you must ensure
    that such an element with the provided `id` attribute value ( `root` , in this
    example) exists in the HTML file into which the React app script is loaded. In
    a default React project created via `npm create vite@latest` , this will be the
    case. You can find a `<div id="root">` element in the `index.html` file in the
    root project folder.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，`document.getElementById('root')` 被用作参数。这个内置的纯 JavaScript 方法返回一个指向 `index.html`
    文档中已存在的 DOM 元素的引用。因此，作为开发者，你必须确保具有提供的 `id` 属性值（在这个例子中是 `root`）的此类元素存在于加载 React
    应用脚本的那个 HTML 文件中。在一个通过 `npm create vite@latest` 创建的默认 React 项目中，情况就是这样。你可以在根项目文件夹中的
    `index.html` 文件中找到一个 `<div id="root">` 元素。
- en: This `index.html` file is a relatively empty file that only acts as a shell
    for the React app. React just needs an entry point (defined via `createRoot()`
    ), which will be used to attach the generated user interface to the displayed
    website. The HTML file and its content, as a result, do not directly define the
    website content. Instead, the file just serves as a starting point for the React
    application, allowing React to then take over and control the actual user interface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `index.html` 文件是一个相对空白的文件，它仅作为 React 应用的外壳。React 只需要一个入口点（通过 `createRoot()`
    定义），该入口点将用于将生成的用户界面附加到显示的网站上。因此，HTML 文件及其内容并不直接定义网站内容。相反，该文件仅作为 React 应用的起点，允许
    React 然后接管并控制实际的用户界面。
- en: 'Once the root entry point has been defined, a method called `render()` can
    be called on the `root` object created via `createRoot()` :'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了根入口点，就可以在通过 `createRoot()` 创建的 `root` 对象上调用 `render()` 方法：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This `render()` method tells React which content (i.e., which React component)
    should be injected into that root entry point. In most React apps, this is a component
    called `App` . React will then generate appropriate DOM-manipulating instructions
    to reflect the markup defined via JSX in the `App` component on the actual web
    page.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `render()` 方法告诉 React 应将哪个内容（即哪个 React 组件）注入到该根入口点中。在大多数 React 应用中，这是一个名为
    `App` 的组件。React 将生成适当的 DOM 操作指令，以反映 `App` 组件在网页上通过 JSX 定义的标记。
- en: This `App` component is a component function that is imported from some other
    file. In a default React project, the `App` component function is defined and
    exported in an `App.jsx` file, which is also located in the `src/` folder.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`App`组件是一个从其他文件导入的组件函数。在一个默认的React项目中，`App`组件函数在`App.jsx`文件中定义并导出，该文件也位于`src/`文件夹中。
- en: This component, which is handed to `render()` ( `<App />` , typically), is also
    called the **root component** of the React app. It’s the main component that is
    rendered to the DOM. All other components are nested in the JSX code of that `App`
    component or the JSX code of even more nested descendent components. You can think
    of all these components building up a tree of components that is evaluated by
    React and translated into actual DOM-manipulating instructions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个传递给`render()`（通常是`<App />`）的组件也被称为React应用的**根组件**。它是渲染到DOM中的主要组件。所有其他组件都嵌套在`App`组件的JSX代码中，或者嵌套在更多嵌套的子组件的JSX代码中。你可以将这些组件视为由React评估并转换为实际DOM操作指令的组件树。
- en: '![A diagram of a product  Description automatically generated](img/B31339_02_02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![产品图描述自动生成](img/B31339_02_02.png)'
- en: 'Figure 2.2: Nested React components form a component tree'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：嵌套的React组件形成一个组件树
- en: '**Note**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: As mentioned in the previous chapter, React can be used on various platforms.
    With the `react-native` package, it could be used to build native mobile apps
    for iOS and Android. The `react-dom` package, which provides the `createRoot()`
    method (and therefore, implicitly, the `render()` method), is focused on the browser.
    It provides the “bridge” between React’s capabilities and the browser instructions
    that are required to bring the UI (described via JSX and React components) to
    life in the browser. If you build for different platforms, replacements for `ReactDOM.createRoot()`
    and `render()` are required (and, of course, such alternatives do exist).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，React可以在各种平台上使用。使用`react-native`包，它可以用来为iOS和Android构建原生移动应用。`react-dom`包，它提供了`createRoot()`方法（因此隐式地提供了`render()`方法），专注于浏览器。它提供了React的能力和浏览器指令之间的“桥梁”，这些指令是必需的，以便在浏览器中将UI（通过JSX和React组件描述）呈现出来。如果你为不同的平台构建，则需要`ReactDOM.createRoot()`和`render()`的替代品（当然，这样的替代品确实存在）。
- en: Either way, no matter whether you use a component function like an HTML element
    inside of JSX code of other components or use it like an HTML element that’s passed
    as an argument to the `render()` method, React takes care of interpreting and
    executing the component function on your behalf.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，无论你是否在JSX代码中像HTML元素一样使用组件函数，或者将其作为参数传递给`render()`方法，React都会为你处理解释和执行组件函数。
- en: Of course, this is not a new concept. In JavaScript, functions are **first-class
    objects** , which means that you can pass functions as arguments to other functions.
    This is basically what happens here, just with the extra twist of using this JSX
    syntax, which is not a default JavaScript feature.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是一个新概念。在JavaScript中，函数是**一等对象**，这意味着你可以将函数作为参数传递给其他函数。这里基本上就是这样做的，只是额外地使用了这种JSX语法，这不是JavaScript的默认功能。
- en: React executes these component functions for you and translates the returned
    JSX code into DOM instructions. To be precise, React traverses the returned JSX
    code and dives into any other custom components that might be used in that JSX
    code until it ends up with JSX code that is only made up of native, built-in HTML
    elements (technically, it’s not really HTML, but that will be discussed later
    in this chapter).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: React为你执行这些组件函数，并将返回的JSX代码转换为DOM指令。更准确地说，React遍历返回的JSX代码，并深入到该JSX代码中可能使用的任何其他自定义组件，直到它最终得到只由原生、内置HTML元素组成的JSX代码（技术上，它并不是真正的HTML，但这将在本章后面的内容中讨论）。
- en: 'Take these two components as an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以这两个组件为例：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `App` component uses the `Greeting` component inside its JSX code. React
    will traverse the entire JSX markup structure and derive this final JSX code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件在其JSX代码中使用了`Greeting`组件。React会遍历整个JSX标记结构，并推导出以下最终的JSX代码：'
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code will instruct React and ReactDOM to perform the following DOM operations:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将指示React和ReactDOM执行以下DOM操作：
- en: Create a `<div>` element
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`<div>`元素
- en: 'Inside that `<div>` , create two child elements: `<h2>` and `<p>`'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个`<div>`内部，创建两个子元素：`<h2>`和`<p>`
- en: Set the text content of the `<h2>` element to `'Hello World!'`
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`<h2>`元素的文本内容设置为`'Hello World!'`
- en: Set the text content of the `<p>` element to `'Welcome to this book!'`
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `<p>` 元素的文本内容设置为 `'欢迎来到这本书！'`
- en: Insert the `<div>` , with its children, into the already-existing DOM element,
    which has the ID `'root'`
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `<div>` 及其子元素插入到已经存在的 DOM 元素中，该元素的 ID 为 `'root'`
- en: This is a bit simplified, but you can think of React handling components and
    JSX code as described above.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点简化，但你可以将 React 处理组件和 JSX 代码的方式想象成上述描述的那样。
- en: '**Note**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: React doesn’t actually work with JSX code internally. It’s just easier to use
    as a developer. Later, in this chapter, you will learn what JSX code gets transformed
    into and what the actual code that React works with looks like.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: React 实际上并不在内部使用 JSX 代码。它只是对开发者来说更容易使用。在本章的后面，你将学习 JSX 代码会被转换成什么，以及 React 实际上使用的代码是什么样的。
- en: Built-In Components
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置组件
- en: 'As shown in the earlier examples, you can create your own custom components
    by creating functions that return JSX code. And indeed, that’s one of the main
    things you will do all the time as a React developer: create component functions
    – lots of component functions.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，你可以通过创建返回 JSX 代码的函数来创建自己的自定义组件。确实，作为 React 开发者，你将一直要做的主要事情之一就是创建组件函数——大量的组件函数。
- en: But, ultimately, if you were to merge all JSX code into just one big snippet
    of JSX code, as shown in the last example, you would end up with a chunk of JSX
    code that includes only standard HTML elements like `<div>` , `<h2>` , `<p>` ,
    and so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但，最终，如果你要将所有 JSX 代码合并成一个大片段，就像在最后一个例子中展示的那样，你将得到一个只包含标准 HTML 元素（如 `<div>`、`<h2>`、`<p>`
    等）的 JSX 代码块。
- en: When using React, you don’t create brand-new HTML elements that the browser
    would be able to display and handle. Instead, you create components that **only
    work inside the React environment** . Before they reach the browser, they have
    been evaluated by React and “translated” into DOM-manipulating JavaScript instructions
    (like `document.append(…)` ).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React 时，你不会创建浏览器能够显示和处理的全新 HTML 元素。相反，你创建的组件 **仅在 React 环境中工作**。在它们到达浏览器之前，它们已经被
    React 评估并“转换”成 DOM 操作的 JavaScript 指令（如 `document.append(…)`）。
- en: But keep in mind that all this JSX code is a feature that’s not part of the
    JavaScript language itself. It’s basically **syntactical sugar** (i.e., a simplification
    regarding the code syntax) provided by the React library and the project setup
    you’re using to write React code. Therefore, elements like `<div>` , when used
    in JSX code, also **aren’t normal HTML elements** because you **don’t write HTML
    code** . It might look like that, but it’s inside a `.jsx` file and it’s not HTML
    markup. Instead, it’s this special JSX code. It is important to keep this in mind.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，所有这些 JSX 代码都是 React 库和用于编写 React 代码的项目设置提供的一个特性，而不是 JavaScript 语言本身的一部分。它基本上是
    **语法糖**（即关于代码语法的简化）的提供。因此，当在 JSX 代码中使用 `<div>` 等元素时，它们也不是常规的 HTML 元素，因为你 **没有编写
    HTML 代码**。它看起来可能像那样，但它是在 `.jsx` 文件中，并且它不是 HTML 标记。相反，它是这种特殊的 JSX 代码。这一点很重要。
- en: Accordingly, these `<div>` and `<h2>` elements you see in all these examples
    are also just React components in the end. But they are not components built by
    you, but instead provided by React (or, to be precise, by ReactDOM).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这些所有例子中看到的 `<div>` 和 `<h2>` 元素最终也只是 React 组件。但它们不是你构建的组件，而是由 React（或更准确地说，由
    ReactDOM）提供的。
- en: When working with React, you consequently always end up with these primitives—these
    built-in component functions that are later translated to browser instructions
    that generate and append or remove normal DOM elements. The idea behind building
    custom components is to group these elements together such that you end up with
    reusable building blocks that can be used to build the overall UI. But, in the
    end, this UI is made up of regular HTML elements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React 时，你最终总是得到这些原语——这些内置的组件函数，这些函数最终会被转换成浏览器指令，用于生成和附加或删除常规 DOM 元素。构建自定义组件背后的想法是将这些元素组合在一起，这样你最终得到的是可重用的构建块，可以用来构建整体
    UI。但是，最终，这个 UI 是由常规 HTML 元素组成的。
- en: '**Note**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Depending on your level of frontend web development knowledge, you might have
    heard about a web feature called **Web Components** . The idea behind this feature
    is that you can indeed build brand-new HTML elements with vanilla JavaScript.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你对前端 Web 开发知识的了解程度，你可能已经听说过一个名为 **Web Components** 的 Web 特性。这个特性的想法是，你确实可以使用纯
    JavaScript 构建全新的 HTML 元素。
- en: As mentioned, React does not pick up this feature; you don’t build new custom
    HTML elements with React.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，React 并不识别这个特性；你不会用 React 构建新的自定义 HTML 元素。
- en: Naming Conventions
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名约定
- en: All component functions that you can find in this book carry names like `SubmitButton`
    , `AuthForm` , or `Greeting` .
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中所能找到的所有组件函数的名称都像 `SubmitButton`、`AuthForm` 或 `Greeting` 这样。
- en: You can generally name your React functions however you want—at least in the
    file where you are defining them. But it is a common convention to use the **PascalCase**
    naming convention, wherein the first character is uppercase and multiple words
    are grouped into one single word ( `SubmitButton` instead of `Submit Button` ),
    where every “subword” then starts with another uppercase character.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意命名你的 React 函数——至少在你定义它们的文件中是这样。但使用 **PascalCase** 命名约定是一种常见的惯例，其中第一个字符是大写，多个单词组合成一个单词（例如
    `SubmitButton` 而不是 `Submit Button`），然后每个“子词”都以另一个大写字母开头。
- en: In the place where you define your component function, it is only a naming convention,
    not a hard rule. However, it **is** a hard rule in the place where you **use**
    the component functions—i.e., in the JSX code where you embed your own custom
    components.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义你的组件函数的地方，这只是一种命名约定，而不是一个硬性规则。然而，在你**使用**组件函数的地方——即嵌入你自定义组件的 JSX 代码中——这是一个硬性规则。
- en: 'You can’t use your own custom component function as a component like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能像这样将自定义组件函数用作组件：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: React forces you to use an uppercase starting character for your own custom
    component names when using them in JSX code. This rule exists to give React a
    clear and easy way of telling custom components apart from built-in components
    like `<div>` , etc. React only needs to look at the starting character to determine
    whether it’s a built-in element or a custom component.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: React 强制你在 JSX 代码中使用大写字母开头来自定义组件名称。这个规则存在是为了让 React 有一个清晰且简单的方法来区分自定义组件和内置组件（如
    `<div>` 等）。React 只需要查看起始字符就能确定它是一个内置元素还是一个自定义组件。
- en: Besides the names of the actual component functions, it is also important to
    understand file naming conventions. Custom components are typically stored in
    separate files that live inside a `src/components/` folder. However, this is not
    a hard rule. The exact placement as well as the folder name is up to you, but
    it should be somewhere inside the `src/` folder. Using a folder named `components/`
    is the standard though.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实际组件函数的名称外，了解文件命名约定也很重要。自定义组件通常存储在 `src/components/` 文件夹内的单独文件中。然而，这并不是一个硬性规则。确切的放置位置以及文件夹名称由你决定，但应该在
    `src/` 文件夹内。使用名为 `components/` 的文件夹是标准做法。
- en: Whereas it is the standard to use PascalCase for the component functions, there
    is no general default regarding file names. Some developers prefer PascalCase
    for file names as well; and, indeed, in brand-new React projects, created as described
    in this book, the `App` component can be found inside a file named `App.jsx` .
    Nonetheless, you will also encounter many React projects where components are
    stored in files that follow the kebab-case naming convention. (All lowercase and
    multiple words are combined into a single word via a dash). With this convention,
    component functions could be stored in files named `submit-button.jsx` , for example.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 PascalCase 命名组件函数是标准，但对于文件名来说并没有一个通用的默认约定。一些开发者也倾向于使用 PascalCase 命名文件；实际上，按照本书描述创建的新
    React 项目中，`App` 组件可以在名为 `App.jsx` 的文件中找到。然而，你也会遇到许多 React 项目，其中组件存储在遵循 kebab-case
    命名约定的文件中。（所有小写字母和多个单词通过连字符合并成一个单词）。按照这种约定，组件函数可以存储在名为 `submit-button.jsx` 的文件中，例如。
- en: Ultimately, it is up to you (and your team) which file naming convention you
    want to follow. In this book, PascalCase will be used for file names.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，选择哪种文件命名约定取决于你（以及你的团队）。在这本书中，我们将使用 PascalCase 来命名文件。
- en: JSX vs HTML vs Vanilla JavaScript
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 与 HTML 与纯 JavaScript
- en: As mentioned above, React projects typically contain lots of JSX code. Most
    custom components will return JSX code snippets. You can see this in all the examples
    shared thus far, and you will see it in basically every React project you explore,
    no matter whether you are using React for the browser or other platforms like
    `react-native` .
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，React 项目通常包含大量的 JSX 代码。大多数自定义组件将返回 JSX 代码片段。你可以在迄今为止分享的所有示例中看到这一点，你将在探索的几乎所有
    React 项目中看到这一点，无论你是使用 React 为浏览器还是其他平台如 `react-native`。
- en: But what exactly is this JSX code? How is it different from HTML? And how is
    it related to vanilla JavaScript?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但JSX代码究竟是什么？它与HTML有何不同？它与纯JavaScript有何关联？
- en: JSX is a feature that’s not part of vanilla JavaScript. What can be confusing,
    though, is that it’s also not directly part of the React library.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: JSX是一个不属于纯JavaScript的功能。但令人困惑的是，它也不是React库的直接部分。
- en: Instead, JSX is syntactical sugar that is provided by the build workflow that’s
    part of the overall React project. When you start the development web server via
    `npm run dev` or build the React app for production (i.e., for deployment) via
    `npm run build` , you kick off a process that transforms this JSX code back to
    regular JavaScript instructions. As a developer, you don’t see those final instructions
    but React, the library, actually receives and evaluates them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，JSX是构建工作流程提供的一种语法糖，它是React项目整体的一部分。当你通过`npm run dev`启动开发Web服务器或通过`npm run
    build`构建React应用程序以进行生产（即部署）时，你启动了一个将此JSX代码转换回常规JavaScript指令的过程。作为开发者，你不会看到那些最终指令，但React库实际上接收并评估它们。
- en: So, what does the JSX code get transformed to?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，JSX代码会被转换成什么？
- en: 'In modern React projects, it gets transformed to rather complex, unintuitive
    code that looks something like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代React项目中，它被转换成相当复杂、不直观的代码，看起来像这样：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, this code is not very developer-friendly. It’s not the kind of code
    you would write. Instead, it’s the code produced by Vite (i.e., by the underlying
    build process) for the browser to execute.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码对开发者来说并不友好。这不是你想要编写的代码类型。相反，这是Vite（即底层构建过程）为浏览器执行生成的代码。
- en: 'But you could, in theory, write code like this instead of using JSX—if, for
    some reason, you wanted to avoid writing JSX code. React has a built-in method
    you can use instead of JSX: you can use React’s `createElement(…)` method.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但从理论上讲，你可以用这样的代码代替JSX——如果你出于某种原因想避免编写JSX代码。React有一个内置的方法可以用来代替JSX：你可以使用React的`createElement(…)`方法。
- en: 'Here’s a concrete example, first in JSX:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个具体的例子，首先是JSX：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instead of using JSX, you could also write this component code like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用JSX，你也可以这样编写组件代码：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`createElement()` is a method built into the React library. It instructs React
    to create a paragraph element with `''Hello World!''` as child content (i.e.,
    as inner, nested content). This paragraph element is then created internally first
    (via a concept called the **virtual DOM** , which will be discussed later in the
    book, in *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    ). Thereafter, once all elements for all JSX elements have been created, the virtual
    DOM is translated into real DOM-manipulating instructions that are executed by
    the browser.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`createElement()` 是React库中内置的一个方法。它指示React创建一个段落元素，其子内容为`''Hello World!''`（即作为内部、嵌套内容）。然后这个段落元素首先在内部创建（通过一个称为**虚拟DOM**的概念，本书将在第10章*React和优化机会背后的场景*中稍后讨论）。之后，一旦所有JSX元素的所有元素都已创建，虚拟DOM将被转换为浏览器执行的真正DOM操作指令。'
- en: '**Note**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'It has been mentioned before that React (in the browser) is actually a combination
    of two packages: `react` and `react-dom` .'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之前已经提到，React（在浏览器中）实际上是由两个包组成的：`react`和`react-dom`。
- en: 'With the introduction of `React.createElement(…)` , it’s now easier to explain
    how these two packages work together: React creates this virtual DOM internally
    and then passes it to the `react-dom` package. This package then generates the
    actual DOM-manipulating instructions that must be executed in order to update
    the web page such that the desired user interface is displayed there.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`React.createElement(…)`的引入，现在更容易解释这两个包是如何协同工作的：React在内部创建这个虚拟DOM，然后将其传递给`react-dom`包。然后这个包生成必须执行的真正DOM操作指令，以便更新网页，显示所需的用户界面。
- en: As mentioned, this will be covered in greater detail in *Chapter 10* .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如提到的，这将在第10章中更详细地介绍。
- en: The middle parameter value ( `{}` , in the example) is a JavaScript object that
    may contain extra configuration for the element that is to be created.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 中间参数值（`{}`，在示例中）是一个JavaScript对象，它可能包含要创建的元素的额外配置。
- en: 'Here’s an example where this middle argument becomes important:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，其中这个中间论点变得很重要：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This would be transformed to the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被转换为以下内容：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last argument that’s passed to `React.createElement(…)` is the child content
    of the element—i.e., the content that should be between the element’s opening
    and closing tags. For nested JSX elements, nested `React.createElement(…)` calls
    would be produced:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `React.createElement(…)` 的最后一个参数是元素的子内容——即应该在元素的开标签和闭标签之间的内容。对于嵌套的 JSX 元素，将生成嵌套的
    `React.createElement(…)` 调用：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This would be transformed like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被转换成这样：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using React without JSX
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不使用 JSX 使用 React
- en: Since all JSX code gets transformed to these native JavaScript method calls
    anyway, you can actually build React apps and user interfaces with React without
    using JSX.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有 JSX 代码最终都会被转换成这些原生 JavaScript 方法调用，因此你实际上可以使用 React 而不使用 JSX 来构建 React
    应用和用户界面。
- en: You can skip JSX entirely if you want to. Instead of writing JSX code in your
    components and all the places where JSX is expected, you can simply call `React.createElement(…)`
    .
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，完全可以跳过 JSX。你不需要在你的组件和 JSX 期望的所有地方编写 JSX 代码，你只需简单地调用 `React.createElement(…)`
    即可。
- en: 'For example, the following two snippets will produce exactly the same user
    interface in the browser:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下两个代码片段将在浏览器中产生完全相同的外观界面：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding snippet will ultimately be the same as the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段最终将与以下代码相同：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, it’s a different question whether you would want to do this. As you
    can see in this example, it’s way more cumbersome to rely on `React.createElement(…)`
    only. You end up writing a lot more code and deeply nested element structures
    will lead to code that can become almost impossible to read.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你是否想这样做是另一个问题。正如你在本例中可以看到的，仅仅依赖 `React.createElement(…)` 会非常繁琐。你最终会写很多代码，深度嵌套的元素结构会导致代码几乎无法阅读。
- en: That’s why, typically, React developers use JSX. It’s a great feature that makes
    building user interfaces with React way more enjoyable. But it is important to
    understand that it’s neither HTML nor a vanilla JavaScript feature, but that it
    instead is some syntactical sugar that gets transformed to function calls behind
    the scenes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么，通常，React 开发者使用 JSX。这是一个使使用 React 构建用户界面变得更加愉快的出色功能。但重要的是要理解，它既不是 HTML
    也不是纯 JavaScript 功能，而是一种在幕后转换为函数调用的语法糖。
- en: JSX Elements Are Treated Like Regular JavaScript Values
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX 元素被当作常规 JavaScript 值处理
- en: 'Because JSX is just syntactical sugar that gets transformed, there are a couple
    of noteworthy concepts and rules you should be aware of:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 JSX 只是一种会被转换的语法糖，所以有一些值得注意的概念和规则你应该知道：
- en: JSX elements are just **regular JavaScript values** (functions, to be precise)
    in the end
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 元素最终只是 **常规 JavaScript 值**（更准确地说，是函数）。
- en: The same rules that apply to all JavaScript values also apply to JSX elements
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于所有 JavaScript 值的规则也适用于 JSX 元素。
- en: As a result, in a place where only one value is expected (e.g., after the `return`
    keyword), you must only have one JSX element
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，在只期望一个值的地方（例如，在 `return` 关键字之后），你只能有一个 JSX 元素。
- en: 'This code would cause an error:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会导致错误：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code might look valid at first, but it’s actually incorrect. In this example,
    you would return two values instead of just one. That is not allowed in JavaScript.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能看起来是有效的，但实际上是错误的。在这个例子中，你会返回两个值而不是一个。在 JavaScript 中这是不允许的。
- en: 'For example, the following non-React code would also be invalid:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下非 React 代码也将无效：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can’t return more than one value. No matter how you write it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能返回超过一个值。无论你如何写它。
- en: 'Of course, you can return an array or an object though. For example, this code
    would be valid:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以返回一个数组或一个对象。例如，以下代码将是有效的：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It would be valid because you only return one value: an array. This array contains
    multiple values, as arrays typically do. That would be fine and the same would
    be the case if you used JSX code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是有效的，因为你只返回一个值：一个数组。这个数组包含多个值，就像数组通常那样。这将是可行的，如果你使用 JSX 代码也是同样的情况：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This kind of code would be allowed since you are returning one array with two
    elements inside of it. The two elements are JSX elements in this case, but as
    mentioned earlier, JSX elements are just regular JavaScript values. Thus, you
    can use them anywhere where values would be expected.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的代码将被允许，因为你返回了一个包含两个元素的数组。在这种情况下，这两个元素是 JSX 元素，但如前所述，JSX 元素只是常规 JavaScript
    值。因此，你可以在任何期望值的地方使用它们。
- en: When working with JSX, you won’t see this array approach too often though—simply
    because it can become annoying to remember wrapping JSX elements via square brackets.
    It also looks less like HTML, which kind of defeats the purpose and core idea
    behind JSX (it was invented to allow developers to write HTML code inside JavaScript
    files).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JSX时，你不会经常看到这种数组方法——仅仅是因为通过方括号包装JSX元素可能会变得令人烦恼，而且它看起来也不太像HTML，这有点违背了JSX的目的和核心思想（它被发明出来是为了允许开发者在JavaScript文件中编写HTML代码）。
- en: 'Instead, if sibling elements are required, as in these examples, a special
    kind of wrapping component is used: a React **fragment** . That’s a built-in component
    that serves the purpose of allowing you to return or define sibling JSX elements:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果需要兄弟元素，就像这些例子中一样，会使用一种特殊的包装组件：一个React **片段**。这是一个内置组件，其目的是允许你返回或定义兄弟JSX元素：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This special `<>…</>` element is available in most modern React projects (for
    instance, ones created via Vite), and you can think of it wrapping your JSX elements
    with an array behind the scenes. Alternatively, you can also use `<React.Fragment>…</React.Fragment>`
    . Since some React projects might not support the shorter `<>…</>` syntax, this
    built-in component is always available.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊的`<>…</>`元素在大多数现代React项目中都是可用的（例如，通过Vite创建的项目），你可以将其想象为在幕后用数组包装你的JSX元素。或者，你也可以使用`<React.Fragment>…</React.Fragment>`。由于一些React项目可能不支持较短的`<>…</>`语法，这个内置组件始终可用。
- en: The parentheses ( `()` ) that are wrapped around the JSX code in all these examples
    are required to allow for nice multiline formatting. Technically, you could put
    all your JSX code into one single line, but that would be pretty unreadable. In
    order to split the JSX elements across multiple lines, just as you typically do
    with regular HTML code in `.html` files, you need those parentheses; they tell
    JavaScript where the returned value starts and ends.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些例子中围绕JSX代码的括号（`()`）是必需的，以便允许进行多行格式化。技术上，你可以将所有的JSX代码放在一行中，但那样会非常难以阅读。为了将JSX元素拆分到多行，就像你在`.html`文件中通常对常规HTML代码所做的那样，你需要那些括号；它们告诉JavaScript返回值的开始和结束位置。
- en: Since JSX elements are regular JavaScript values (after being translated by
    the build process at least), you can also use JSX elements in all the places where
    values can be used.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JSX元素是常规JavaScript值（至少在构建过程中被转换后），你还可以在所有可以使用值的地方使用JSX元素。
- en: 'Thus far, that has been the case for all these `return` statements, but you
    can also store JSX elements in variables or pass them as arguments to other functions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有这些`return`语句都是这样，但你也可以将JSX元素存储在变量中或将它们作为参数传递给其他函数：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will be important once you dive into slightly more advanced concepts like
    conditional or repeated content—something that will be covered in *Chapter 5*
    , *Rendering Lists and Conditional Content* .
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你深入研究到更高级的概念，比如条件或重复内容——这些内容将在*第五章*，*渲染列表和条件内容*中介绍——这将会变得很重要。
- en: JSX Elements Must Have a Closing Tag
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX元素必须有闭合标签
- en: 'Another important rule related to JSX elements is that they must always have
    a closing tag. Therefore, JSX elements must be self-closing if there is no content
    between the opening and closing tags:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与JSX元素相关的重要规则之一是它们必须始终有一个闭合标签。因此，如果开标签和闭合标签之间没有内容，JSX元素必须是自闭合的：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In regular HTML, you would not need that forward backslash at the end. Instead,
    regular HTML supports void elements (i.e., `<img src="img/…">` ). You can add
    that forward slash there as well, but it’s not mandatory.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规HTML中，你不需要在末尾使用那个前向反斜杠。相反，常规HTML支持空元素（即，`<img src="img/…">`）。你同样可以在那里添加那个前向斜杠，但这不是强制的。
- en: When working with JSX, these forward slashes are mandatory if your element doesn’t
    contain any child content.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JSX时，如果你的元素不包含任何子内容，这些前向斜杠是强制的。
- en: Moving Beyond Static Content
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越静态内容
- en: Thus far, in all these examples, the content that was returned was static. It
    was content like `<p>Hello World!</p>` —which of course is content that never
    changes. It will always output a paragraph that says, `'Hello World!'` .
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在所有这些例子中，返回的内容都是静态的。它像`<p>Hello World!</p>`这样的内容——当然，这是永远不会改变的内容。它总是会输出一个显示“Hello
    World!”的段落。
- en: But most websites, of course, need to output dynamic content that may change
    (e.g., due to user input). Similarly, you’ll have a hard time finding lots of
    websites without any images.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但当然，大多数网站都需要输出可能改变的内容（例如，由于用户输入）。同样，你也很难找到没有任何图片的网站。
- en: Thus, as a React developer, it’s important to know how to output dynamic content
    (and what “dynamic content” actually means) and how to display images in a React
    app.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一名 React 开发者，了解如何输出动态内容（以及“动态内容”实际上是什么意思）以及如何在 React 应用中显示图像是很重要的。
- en: Outputting Dynamic Content
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出动态内容
- en: At this point in the book, you don’t yet have any tools to make the content
    more dynamic. To be precise, React requires that state concept (which will be
    covered in *Chapter 4* , *Working with Events and State* ) to change the content
    that is displayed (e.g., upon user input or some other event).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，你还没有任何工具来使内容更加动态。更准确地说，React 需要状态概念（将在 *第 4 章* ，*处理事件和状态* 中介绍）来改变显示的内容（例如，在用户输入或其他事件发生时）。
- en: 'Nonetheless, since this chapter is about JSX, it is worth diving into the syntax
    for outputting dynamic content, even though it’s not yet truly dynamic:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，由于本章是关于 JSX 的，因此深入了解输出动态内容的语法是值得的，即使它还不是真正的动态：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This example technically still produces static output since `userName` never
    changes, but you can already see the syntax for outputting dynamic content as
    part of the JSX code. You use opening and closing curly braces ( `{…}` ) with
    a JavaScript expression (like the name of a variable or constant, as is the case
    here) between those braces.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在技术上仍然产生静态输出，因为 `userName` 从未改变，但你已经可以看到输出动态内容作为 JSX 代码一部分的语法。你使用开闭花括号（`{…}`）和其中的
    JavaScript 表达式（如变量或常量的名称，就像这里的情况一样）。
- en: You can put any valid JavaScript expression between those curly braces. For
    example, you can also call a function (e.g., `{getMyName()}` ) or do simple inline
    calculations (e.g., `{1 + 1}` ).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在那些花括号之间放置任何有效的 JavaScript 表达式。例如，你也可以调用一个函数（例如，`{getMyName()}`）或进行简单的内联计算（例如，`{1
    + 1}`）。
- en: You can’t add complex statements like loops or `if` statements between those
    curly braces though. Again, standard JavaScript rules apply. You output a (potentially)
    dynamic value, and therefore, anything that produces a single value is allowed
    in that place. However, it’s worth noting that a few value types can’t be used
    for outputting a value in JSX. For example, trying to output a JavaScript object
    in JSX will cause an error.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在那些花括号之间添加复杂的语句，如循环或 `if` 语句。再次强调，标准 JavaScript 规则适用。你输出一个（可能是）动态值，因此，任何产生单个值的任何东西都可以放在那个位置。然而，值得注意的是，一些值类型不能用于在
    JSX 中输出值。例如，尝试在 JSX 中输出 JavaScript 对象将导致错误。
- en: 'It’s also worth noting that you’re not limited to outputting dynamic content
    between element tags. Instead, you can also set dynamic values for attributes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，你不仅限于在元素标签之间输出动态内容。相反，你还可以为属性设置动态值：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Rendering Images
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染图像
- en: Most websites do not just display plain text. Instead, you often need to render
    images as well.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网站不仅仅显示纯文本。相反，你通常还需要渲染图像。
- en: 'Of course, when working with React, you can use the default `<img />` element
    like in any other web project. But there are two important things to keep in mind
    when displaying images in React projects:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当使用 React 时，你可以像在其他任何 Web 项目中一样使用默认的 `<img />` 元素。但在显示 React 项目中的图像时，有两个重要的事情需要记住：
- en: '`<img />` must be a self-closing tag.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<img />` 必须是自闭合标签。'
- en: When displaying local images stored inside of the `src/` folder, you must import
    them into your `.jsx` files.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当显示存储在 `src/` 文件夹中的本地图像时，你必须将它们导入到你的 `.jsx` 文件中。
- en: As explained above, in the *JSX elements must have a closing tag* section, you
    can’t have void JSX elements, i.e., elements without any closing tag.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，在 *JSX 元素必须有闭合标签* 这一部分，你不能有空的 JSX 元素，即没有任何闭合标签的元素。
- en: In addition, when outputting locally stored images (i.e., images stored in the
    project’s `src/` folder, not on some remote server), you typically don’t set a
    string path to the image in your code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当输出本地存储的图像（即存储在项目的 `src/` 文件夹中的图像，而不是某个远程服务器上的图像）时，你通常不需要在代码中设置图像的字符串路径。
- en: 'You might be used to outputting images like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能习惯于输出如下所示的图像：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: But React projects (e.g., when created with Vite) do involve some kind of build
    process. In most projects, the final project structure that will be deployed onto
    a server will look quite different from the project structure you work on during
    development.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 但 React 项目（例如，使用 Vite 创建时）确实涉及某种构建过程。在大多数项目中，最终部署到服务器上的项目结构将与你在开发期间工作的项目结构大不相同。
- en: That being the case, if you store an image in the `src/assets` folder in a Vite-based
    React project, and you use that as a path ( `<img src="img/my-image.jpg" />` ),
    the image will not load on the deployed website. It will not load there because
    the deployable folder structure will not contain a `src/assets` folder anymore.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 既然如此，如果你在一个基于 Vite 的 React 项目中将图像存储在 `src/assets` 文件夹中，并使用该路径（`<img src="img/my-image.jpg"
    />`），那么在部署的网站上图像将无法加载。它无法加载是因为可部署的文件夹结构将不再包含 `src/assets` 文件夹。
- en: Indeed, you can get an idea of the production-ready folder structure by running
    `npm run build` . This will build the project for deployment and produce a new
    `dist` folder in your project directory. It’s the content of that `dist` folder
    that will be deployed onto some server. If you inspect that folder, you won’t
    find a `src` folder in there.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你可以通过运行 `npm run build` 来了解生产就绪的文件夹结构。这将构建用于部署的项目，并在你的项目目录中产生一个新的 `dist`
    文件夹。将部署到某个服务器上的内容就是那个 `dist` 文件夹的内容。如果你检查那个文件夹，你不会在那里找到一个 `src` 文件夹。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_02_03.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B31339_02_03.png)'
- en: 'Figure 2.3: The dist folder contains a different structure'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：dist 文件夹包含不同的结构
- en: 'Put in other words: You can’t tell the exact path of a locally stored image
    in advance. That’s why you should import the image file into your `.jsx` file.
    As a result, you’ll get a string value that will contain the actual path (which
    will work in production). This value can then be set as a dynamic value for the
    `src` attribute of the `<img />` element:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：你无法提前知道本地存储的图像的确切路径。这就是为什么你应该将图像文件导入到你的 `.jsx` 文件中。结果，你将得到一个包含实际路径的字符串值（这在生产中是有效的）。然后，可以将此值设置为
    `<img />` 元素的 `src` 属性的动态值：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This might look strange at first, but it is code that will work in pretty much
    all React projects. Behind the scenes, this import gets analyzed by the underlying
    build process. The `import` statement then gets removed, and the image path is
    hardcoded into the production-ready output code (i.e., the code that’s stored
    in the `dist` folder).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始看起来有些奇怪，但这是在几乎所有 React 项目中都能正常工作的代码。幕后，这个导入被底层的构建过程分析。然后，`import` 语句被移除，图像路径被硬编码到生产就绪的输出代码中（即存储在
    `dist` 文件夹中的代码）。
- en: 'There is one important exception though: if you store an image file (or, actually,
    any asset) in the `public/` folder of your project, you can directly reference
    its path.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有一个重要的例外：如果你将图像文件（实际上，任何资产）存储在你的项目 `public/` 文件夹中，你可以直接引用其路径。
- en: 'For example, a `demo.jpg` image file stored in `public/images/demo.jpg` can
    be rendered and displayed like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个存储在 `public/images/demo.jpg` 的 `demo.jpg` 图像文件可以像这样渲染和显示：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This works because the contents of the `public/` folder are simply copied into
    the `dist/` folder. Unlike the `src/` folder and its nested files, the `public/`
    folder files skip the transpilation step.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以可行，是因为 `public/` 文件夹的内容被简单地复制到 `dist/` 文件夹中。与 `src/` 文件夹及其嵌套文件不同，`public/`
    文件夹的文件跳过了转译步骤。
- en: Please note that the public folder name itself is not part of the paths referenced—it’s
    `src="img/demo.jpg"` , not `src="img/demo.jpg"` .
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，公共文件夹名称本身不是引用路径的一部分——它是 `src="img/demo.jpg"` ，而不是 `src="img/demo.jpg"`。
- en: Which approach should you use then? Store images in `src/` or `public/` ?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你应该使用哪种方法？将图像存储在 `src/` 还是 `public/`？
- en: For most images, `src/` is a sensible choice since the pre-processing step assigns
    a unique file name to each imported file. As a result, files can be cached more
    efficiently once the application is deployed.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数图像，`src/` 是一个合理的选择，因为预处理步骤为每个导入的文件分配一个唯一的文件名。因此，一旦应用程序部署，文件可以更有效地缓存。
- en: Any files imported in the root `index.html` file, or files where the file name
    must never change (e.g., because it’s also referenced by some other app, running
    on some other server) should typically go into the `public/` folder.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 任何导入到根 `index.html` 文件中的文件，或者文件名必须永远不变的文件（例如，因为它也被其他应用程序引用，该应用程序在某个其他服务器上运行）通常应该放入
    `public/` 文件夹中。
- en: 'Thus, in most cases, when outputting images that are stored locally in your
    project, you should store them in the `src/` folder and then import them into
    your JSX files. When using images that are stored on some remote server, you would
    instead use the full image URL:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在大多数情况下，当你输出存储在你项目中的本地图像时，你应该将它们存储在 `src/` 文件夹中，然后导入到你的 JSX 文件中。当使用存储在某个远程服务器上的图像时，你会使用完整的图像
    URL：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When Should You Split Components?
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你应该在何时拆分组件？
- en: 'As you work with React and learn more and more about it, and as you dive into
    more challenging React projects, you will most likely come up with one very common
    question: *When should I split a single React component into multiple separate
    components?*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你使用React并对其了解更多，以及你深入到更具挑战性的React项目中，你很可能会提出一个非常常见的问题：*我应该何时将单个React组件拆分为多个单独的组件？*
- en: As mentioned earlier in this chapter, React is all about components, and it
    is therefore very common to have dozens, hundreds, or even thousands of React
    components in a single React project.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，React的一切都是关于组件的，因此在单个React项目中拥有数十、数百甚至数千个React组件是非常常见的。
- en: When it comes to splitting a single React component into multiple smaller components,
    there is no hard rule you must follow. As mentioned earlier, you could put all
    your UI code into one single, large component. Alternatively, you could create
    a separate custom component for every single HTML element and piece of content
    that you have in your UI. Both approaches are probably not that great. Instead,
    a good rule of thumb is to create a separate React component for every **data
    entity** that can be identified.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到将单个React组件拆分为多个较小的组件时，并没有必须遵循的硬性规则。如前所述，你可以将所有的UI代码放入一个单独的、较大的组件中。或者，你也可以为UI中的每一个HTML元素和内容创建一个单独的定制组件。这两种方法可能都不是很好。相反，一个好的经验法则是为每个可识别的**数据实体**创建一个单独的React组件。
- en: 'For example, if you’re outputting a “to-do” list, you could identify two main
    entities: the individual to-do item and the overall list. In this case, it could
    make sense to create two separate components instead of writing one bigger component.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在输出一个“待办事项”列表，你可以识别出两个主要实体：单个待办事项和整体列表。在这种情况下，创建两个单独的组件而不是编写一个更大的组件是有意义的。
- en: The advantage of splitting your code into multiple components is that the individual
    components stay manageable because there’s less code per component and component
    file.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码拆分为多个组件的优势在于，由于每个组件和组件文件中的代码更少，因此单个组件更容易管理。
- en: 'However, when it comes to splitting components into multiple components, a
    new problem arises: *How do you make your components reusable and configurable?*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当涉及到将组件拆分为多个组件时，会出现一个新的问题：*如何使你的组件可重用和可配置？*
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, all “to-dos” would be the same because we use the same `<Todo
    />` component, which can’t be configured. You might want to make it configurable
    by either adding custom attributes ( `<Todo text="Learn React!" />)` or by passing
    content between the opening and closing tags `(<Todo>Learn React!</Todo>` ).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有的“待办事项”都是相同的，因为我们使用的是相同的`<Todo />`组件，它无法配置。你可能希望通过添加自定义属性（`<Todo text="Learn
    React!" />`）或在开闭标签之间传递内容（`(<Todo>Learn React!</Todo>`）来使其可配置。
- en: And, of course, React supports this. In the next chapter, you will learn about
    a key concept called **props** , which allows you to make your components configurable
    like this.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，React支持这一点。在下一章中，你将学习一个关键概念，称为**props**，它允许你使你的组件像这样可配置。
- en: Summary and Key Takeaways
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: 'React embraces **components** : reusable building blocks that are combined
    to define the final user interface'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React拥抱**组件**：可重用的构建块，它们被组合起来定义最终的用户界面
- en: Components must return **renderable** content – typically, JSX code that defines
    the HTML code that should be produced in the end
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件必须返回**可渲染**的内容——通常是定义最终应生成的HTML代码的JSX代码。
- en: 'React provides a lot of built-in components: besides special components like
    `<>…</>` , you get components for all standard HTML elements'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React提供了许多内置组件：除了特殊的`<>…</>`组件之外，你还可以获得所有标准HTML元素的组件。
- en: To allow React to tell custom components apart from built-in components, custom
    component names have to start with capital letters when being used in JSX code
    (typically, PascalCase naming is used)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了让React能够区分自定义组件和内置组件，自定义组件名称在JSX代码中使用时必须以大写字母开头（通常使用PascalCase命名法）。
- en: JSX is neither HTML nor a standard JavaScript feature – instead, it’s **syntactical
    sugar** provided by build workflows that are part of all React projects
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX既不是HTML也不是标准的JavaScript特性——相反，它是所有React项目中构建工作流程提供的**语法糖**。
- en: You could replace JSX code with `React.createElement(…)` calls, but since this
    leads to significantly more unreadable code, it’s typically avoided
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以用`React.createElement(…)`调用替换JSX代码，但由于这会导致代码的可读性显著降低，通常避免这样做。
- en: When using JSX elements, you must not have sibling elements in places where
    single values are expected (e.g., directly after the `return` keyword)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用JSX元素时，在期望单个值的地方（例如，直接在`return`关键字之后）不允许有兄弟元素
- en: JSX elements must always be self-closing if there is no content between the
    opening and closing tags
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在开标签和闭标签之间没有内容，JSX元素必须始终自闭合
- en: Dynamic content can be output via curly braces (e.g., `<p>{someText}</p>` )
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态内容可以通过花括号输出（例如，`<p>{someText}</p>`）
- en: Images can be rendered by referencing their paths (if stored remotely or in
    the `public/` folder) or by importing the image files into JSX files and outputting
    them with the dynamic content syntax
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过引用它们的路径（如果存储在远程或`public/`文件夹中）或通过将图像文件导入JSX文件并使用动态内容语法输出它们来渲染图像
- en: In most React projects, you split your UI code across dozens or hundreds of
    components, which are then exported and imported in order to be combined again
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数React项目中，你将UI代码拆分到数十个或数百个组件中，然后导出并导入以再次组合
- en: What’s Next?
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: In this chapter, you learned a lot about components and JSX. The next chapter
    builds upon this key knowledge and explains how you can make components reusable
    by making them configurable.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了很多关于组件和JSX的知识。下一章将在此基础上，解释如何通过使组件可配置来使组件可重用。
- en: Before you continue, you can also practice what you have learned up to this
    point by going through the questions and exercises below.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续之前，你也可以通过下面的问题和练习来练习你到目前为止所学到的内容。
- en: Test Your Knowledge!
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: 'Test your knowledge about the concepts covered in this chapter by answering
    the questions below. You can then compare your answers to example answers that
    can be found here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/exercises/questions-answers.md)
    .'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章涵盖的概念的了解。然后，你可以将你的答案与这里可以找到的示例答案进行比较：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/exercises/questions-answers.md)。
- en: What’s the idea behind using components?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用组件背后的想法是什么？
- en: How can you create a React component?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建一个React组件？
- en: What turns a regular function into a React component function?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么将一个普通函数转换成一个React组件函数？
- en: Which core rules should you keep in mind regarding JSX elements?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JSX元素方面，你应该记住哪些核心规则？
- en: How is JSX code handled by React and ReactDOM?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSX代码是如何被React和ReactDOM处理的？
- en: Apply What You Learned
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用你所学的知识
- en: With this and the previous chapter, you have all the knowledge you need to create
    a React project and populate it with some first, basic components.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章和上一章，你已经拥有了创建React项目并填充一些基本组件所需的所有知识。
- en: Below, you’ll find your first two practical activities for this book.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，你将找到这本书的第一个两个实际活动。
- en: 'Activity 2.1: Creating a React App to Present Yourself'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二.1：创建一个React App来展示自己
- en: Suppose you are creating your personal portfolio page, and as part of that page,
    you want to output some basic information about yourself (e.g., your name or age).
    You could use React and build a React component that outputs this kind of information,
    as outlined in the following activity.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在创建你的个人作品集页面，作为该页面的部分，你想要输出一些关于你自己的基本信息（例如，你的名字或年龄）。你可以使用React并构建一个React组件来输出这类信息，如以下活动概述。
- en: The aim is to create a React app as you learned in the previous chapter (i.e.,
    create it via `npm create vite@latest <your-project-name>` and run `npm run dev`
    to start the development server) and edit the `App.jsx` file such that you output
    some basic information about yourself. You could, for example, output your full
    name, address, job title, or other kinds of information. In the end, it is up
    to you what content you want to output and which HTML elements you choose.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是创建一个React应用，就像你在上一章中学到的那样（即通过`npm create vite@latest <your-project-name>`创建，并通过`npm
    run dev`启动开发服务器）并编辑`App.jsx`文件，以便输出一些关于你自己的基本信息。例如，你可以输出你的全名、地址、职位或其他类型的信息。最后，输出什么内容以及选择哪些HTML元素取决于你。
- en: The idea behind this first exercise is that you practice project creation and
    working with JSX code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个练习的目的是练习项目创建和与JSX代码一起工作。
- en: 'The steps are as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: 'Create a new React project via `npm create vite@latest <project>` . Alternatively,
    you can use the starting project snapshot provided here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-1-start)
    .'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`npm create vite@latest <project>`创建一个新的React项目。或者，你也可以使用这里提供的起始项目快照：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-1-start)。
- en: Edit the `App.jsx` file in the `/src folder` of the created project and return
    JSX code with any HTML elements of your choice to output basic information about
    yourself. You can use the styles in the `index.css` file in the starting project
    snapshot to apply some styling.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑创建的项目中的`/src`文件夹下的`App.jsx`文件，并返回带有任何HTML元素的JSX代码以输出关于你自己的基本信息。你可以使用起始项目快照中的`index.css`文件中的样式来应用一些样式。
- en: Also, store an image in the `src/assets` folder and output it in the `App` component.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将图片存储在`src/assets`文件夹中，并在`App`组件中输出它。
- en: 'You should get output like this in the end:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最终你应该得到如下输出：
- en: '![img](img/B31339_02_04.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_02_04.png)'
- en: 'Figure 2.4: The final activity result—some user information being output on
    the screen'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：最终活动结果——一些用户信息被输出到屏幕上
- en: '**Note**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'Styling will of course differ. To get the same styling as shown in the screenshot,
    use my prepared starting project, which you can find here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-1-start)
    .'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 样式当然会有所不同。要获得截图中所显示的相同样式，请使用我准备的起始项目，你可以在以下位置找到：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-1-start)。
- en: Analyze the `index.css` file in that project to determine how to structure your
    JSX code to apply the styles.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 分析该项目的`index.css`文件，以确定如何构建你的JSX代码来应用样式。
- en: 'You’ll find an example solution on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/activities/practice-1/SOLUTION-INSTRUCTIONS.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/activities/practice-1/SOLUTION-INSTRUCTIONS.md)
    .'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到一个示例解决方案：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/activities/practice-1/SOLUTION-INSTRUCTIONS.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/activities/practice-1/SOLUTION-INSTRUCTIONS.md)。
- en: Besides the linked instructions, you will also find the finished example solution
    code in the project folder that contains the `SOLUTIONS-INSTRUCTIONS.md` file.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 除了链接的说明外，你还会在包含`SOLUTIONS-INSTRUCTIONS.md`文件的工程文件夹中找到完成的示例解决方案代码。
- en: However, before you explore this solution, you should consider trying to solve
    this task on your own. Even if your result deviates from the example solution,
    or if you fail to come up with a working application, you’ll learn more by at
    least giving it a try because, as always in life, only practice makes perfect.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在你探索这个解决方案之前，你应该考虑先尝试自己解决这个问题。即使你的结果与示例解决方案不同，或者如果你无法创建一个可工作的应用程序，至少尝试一下你也会学到更多，因为，就像生活中始终一样，只有实践才能使完美。
- en: 'Activity 2.2: Creating a React App to Log Your Goals for This Book'
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二.2：创建一个React应用来记录这本书的目标
- en: Suppose you are adding a new section to your portfolio site, where you plan
    to track your learning progress. As part of this page, you plan to define and
    output your main goals for this book (e.g., *“Learn about key React features”*
    , *“Do all the exercises”* , etc.).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为你的作品集网站添加一个新章节，你计划在这里跟踪你的学习进度。作为这个页面的一个部分，你计划定义并输出这本书的主要目标（例如，*“了解关键React特性”*，*“完成所有练习”*等）。
- en: The aim of this activity is to create another new React project in which you
    add **multiple new components** . Each goal will be represented by a separate
    component, and all these goal components will be grouped together into another
    component that lists all the main goals. In addition, you can add an extra header
    component that contains the main title for the web page.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是创建另一个新的React项目，在这个项目中添加**多个新组件**。每个目标将代表一个单独的组件，所有这些目标组件将组合成另一个组件，列出所有主要目标。此外，你可以添加一个额外的标题组件，包含网页的主要标题。
- en: 'The steps to complete this activity are as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个活动的步骤如下：
- en: 'Create a new React project via `npm create vite@latest <project>` , or use
    the project starting snapshot provided here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-2-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-2-start)
    .'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`npm create vite@latest <project>`创建一个新的React项目，或者使用这里提供的项目起始快照：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-2-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-2-start)。
- en: Inside the new project, create a `components` folder that contains multiple
    component files (for the individual goals as well as for the list of goals and
    the page header).
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新项目中，创建一个包含多个组件文件（包括单个目标、目标列表和页面标题）的`components`文件夹。
- en: Inside the different component files, define and export multiple component functions
    ( `FirstGoal` , `SecondGoal` , `ThirdGoal` , etc.) for the different goals (one
    component per file).
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的组件文件中，为不同的目标（每个文件一个组件）定义并导出多个组件函数（`FirstGoal`、`SecondGoal`、`ThirdGoal`等）。
- en: Also, define one component for the overall list of goals ( `GoalList` ) and
    another component for the page header ( `Header` ).
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，定义一个组件用于整体目标列表（`GoalList`）和另一个组件用于页面标题（`Header`）。
- en: In the individual goal components, return JSX code with the goal text and a
    fitting HTML element structure to hold this content.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在各个目标组件中，返回包含目标文本和适合的HTML元素结构的JSX代码来包含此内容。
- en: In the `GoalList` component, import and output the individual goal components.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GoalList`组件中，导入并输出各个目标组件。
- en: Import and output the `GoalList` and `Header` components in the root `App` component
    (replace the existing JSX code).
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根`App`组件中导入并输出`GoalList`和`Header`组件（替换现有的JSX代码）。
- en: Apply any style of your choice. You can also use the `index.css` file that’s
    part of the starting project snapshot for inspiration.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 应用你喜欢的任何样式。你也可以使用起始项目快照中的`index.css`文件来获取灵感。
- en: 'You should get the following output in the end:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最终你应该得到以下输出：
- en: '![img](img/B31339_02_05.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_02_05.png)'
- en: 'Figure 2.5: The final page output, showing a list of goals'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：最终页面输出，显示目标列表
- en: 'You’ll also find an example solution for this activity on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/activities/practice-2/SOLUTION-INSTRUCTIONS.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/activities/practice-2/SOLUTION-INSTRUCTIONS.md)
    .'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在GitHub上找到这个活动的示例解决方案：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/activities/practice-2/SOLUTION-INSTRUCTIONS.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/activities/practice-2/SOLUTION-INSTRUCTIONS.md)。
- en: As before, besides the linked instructions, you will also find the finished
    example solution code in the project folder that contains the `SOLUTIONS-INSTRUCTIONS.md`
    file.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，除了链接的说明外，你还会在包含`SOLUTIONS-INSTRUCTIONS.md`文件的工程文件夹中找到完成的示例解决方案代码。
