- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Organizing Your Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织您的应用程序
- en: A messed-up project is a bug’s nest waiting to spoil your user experience. In
    addition to quality, good organization of your project from the beginning will
    give your team productivity and, in the case of Angular, potential improvement
    in the performance of your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个混乱的项目是一个等待破坏用户体验的虫窝。除了质量外，从开始就组织良好的项目将为您的团队带来生产力，在 Angular 的情况下，还有可能提高您应用程序的性能。
- en: In this chapter, you will learn about the function of Angular modules, the difference
    between these and JavaScript modules, and how to use them in the best way for
    your project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解 Angular 模块的功能，这些模块与 JavaScript 模块之间的区别，以及如何以最佳方式在项目中使用它们。
- en: You will learn about the single module app anti-pattern and how and why to avoid
    it. You will also use Angular modules to optimize the import of common components
    to your application using the `SharedModule` pattern. Finally, you will understand
    how to use lazy loading to optimize your application’s performance.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您将了解单模块应用的反模式以及如何避免它，以及为什么要避免它。您还将使用 Angular 模块通过 `SharedModule` 模式优化对应用程序中常用组件的导入。最后，您将了解如何使用懒加载来优化您应用程序的性能。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Organizing the application with Angular modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 模块组织应用程序
- en: 'The first module: `AppModule`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个模块：`AppModule`
- en: 'Avoiding anti-pattern: single module app'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免反模式：单模块应用
- en: 'Optimizing the usage of common modules: the `SharedModule` pattern'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化常用模块的使用：`SharedModule` 模式
- en: 'Improving the size of your app: lazy loading'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高您应用程序的大小：懒加载
- en: By the end of this chapter, you will be able to organize your Angular application
    into functional and optimized modules.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够将您的 Angular 应用程序组织成功能化和优化的模块。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，您需要以下内容：
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 18 或更高版本 ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch2](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在 [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch2](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch2)
    获取。
- en: Organizing the application with Angular modules
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular 模块组织应用程序
- en: The basis for organizing the components of an application using the framework
    is the Angular modules, more recognized in the documentation and the community
    by the name **NgModules**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用框架组织应用程序组件的基础是 Angular 模块，在文档和社区中更广为人知的是名称 **NgModules**。
- en: 'An Angular module is a TypeScript class marked with the `@NgModule` decorator
    that contains metadata, as in this example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 模块是一个带有 `@NgModule` 装饰器的 TypeScript 类，其中包含元数据，如下例所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s detail each of these types of metadata in the following subsections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下子节中详细说明这些元数据类型。
- en: declarations
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明
- en: 'This metadata contains an array of components, directives, and pipes that make
    up the module. These components must belong to only one module, otherwise, the
    Angular compiler will throw an error, as shown in *Figure 2**.1*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此元数据包含一个由组件、指令和管道组成的数组，这些组件必须只属于一个模块，否则 Angular 编译器将抛出错误，如图 *图 2**.1* 所示：
- en: "![Figure 2.1 – Error message when declaring a component in more than one modu\uFEFF\
    le](img/B19562_02_1.jpg)"
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 在多个模块中声明组件时的错误信息](img/B19562_02_1.jpg)'
- en: Figure 2.1 – Error message when declaring a component in more than one module
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 在多个模块中声明组件时的错误信息
- en: providers
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供者
- en: In this attribute, we can register the classes we want to inject using Angular’s
    dependency injector system, normally used for services (which will be detailed
    in [*Chapter 5*](B19562_05.xhtml#_idTextAnchor163), *Angular Services and the*
    *Singleton Pattern*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个属性中，我们可以使用 Angular 的依赖注入系统注册我们想要注入的类，通常用于服务（将在 [*第 5 章*](B19562_05.xhtml#_idTextAnchor163)，*Angular
    服务和* *单例模式* 中详细介绍）。
- en: imports
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入
- en: In this metadata, we inform the modules that we want to import and use their
    components and services. For example, if we want to use Angular’s HTTP request
    services, we must declare the `HttpClientModule` module here.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个元数据中，我们通知模块我们想要导入并使用它们的组件和服务。例如，如果我们想使用 Angular 的 HTTP 请求服务，我们必须在这里声明 `HttpClientModule`
    模块。
- en: It is important to know that, here, we should not import components or services,
    only Ngmodules.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，在这里，我们不应该导入组件或服务，而只导入 Ngmodules。
- en: exports
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: exports
- en: 'By default, all items in the `declarations` attribute are private. This means
    that if a module contains the `StateSelectorComponent` component and another module,
    for example, importing the module to use this component will cause the following
    error to occur:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`declarations` 属性中的所有项都是私有的。这意味着如果一个模块包含了 `StateSelectorComponent` 组件和另一个模块，例如，导入该模块以使用此组件将导致以下错误发生：
- en: '![Figure 2.2 – Error message when using a component not exported correctly](img/B19562_02_2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 使用未正确导出的组件时的错误信息](img/B19562_02_2.jpg)'
- en: Figure 2.2 – Error message when using a component not exported correctly
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 使用未正确导出的组件时的错误信息
- en: To inform Angular that the component can be used, it is necessary to declare
    it in the `exports` metadata.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Angular 知道该组件可以被使用，必须在 `exports` 元数据中声明它。
- en: Unlike the `imports` metadata, here, you can declare components, pipes, directives,
    and other modules (as we’ll see in the *Optimizing the usage of common modules
    – the SharedModule* *pattern* section).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `imports` 元数据不同，在这里，你可以声明组件、管道、指令和其他模块（如我们将在 *优化常用模块的使用 – SharedModule 模式*
    部分中看到的）。
- en: Now that we know how to declare a module, let’s study the module that is generated
    when creating an Angular project.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何声明一个模块，让我们来研究创建 Angular 项目时生成的模块。
- en: The first module – AppModule
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个模块 – AppModule
- en: The modules in Angular are so important to the framework that when you start
    a project, it automatically creates a module called **AppModule**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 中的模块对于框架来说非常重要，因此当您启动一个项目时，它会自动创建一个名为 **AppModule** 的模块。
- en: 'This module contains all the parameters we studied in the previous section
    (`declarations`, `providers`, `imports`, and `exports`), plus one additional parameter:
    `bootstrap`. This module contains the first component to be injected into the
    application’s `index.html` file and will be the root of your Angular application’s
    component tree.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块包含我们在上一节中研究的所有参数（`declarations`、`providers`、`imports` 和 `exports`），以及一个额外的参数：`bootstrap`。此模块包含将被注入到应用程序的
    `index.html` 文件中的第一个组件，并将成为您 Angular 应用程序组件树的根。
- en: You may be wondering which `index.html` file and which tree this is.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道这是哪个 `index.html` 文件和哪个树。
- en: As we described in [*Chapter 1*](B19562_01.xhtml#_idTextAnchor017), *Starting
    Projects the Right Way*, Angular is a framework for `index.html` file is in fact
    the only *page* delivered by the web server to its user.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 [*第 1 章*](B19562_01.xhtml#_idTextAnchor017) 中所述，*正确开始项目*，Angular 是一个框架，`index.html`
    文件实际上是网络服务器向其用户提供的唯一 *页面*。
- en: All interfaces rendered by the Angular engine (called `index.html` file and
    the first component is described in the `bootstrap` metadata. This rendering obeys
    a data structure of the logical tree type, and the root of this tree is this first
    component.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Angular 引擎渲染的所有接口（称为 `index.html` 文件，第一个组件在 `bootstrap` 元数据中描述）遵循逻辑树类型的数据结构，此树的根是第一个组件。
- en: What is the difference between Angular and JavaScript modules?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 和 JavaScript 模块之间的区别是什么？
- en: Almost all programming languages offer a way for their developers to organize
    functions, classes, and variables in one or more files, allowing greater maintainability
    and separation of concerns.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有编程语言都为开发者提供了一种方式，可以在一个或多个文件中组织函数、类和变量，从而提高可维护性和关注点的分离。
- en: 'In JavaScript, sometime after its creation and several proposals, the concept
    of language modules was consolidated. The best way to explain this concept is
    to demonstrate it with an example. First, we create a `sum.mjs` file – the `sum`
    function that receives two numbers and returns their sum. The important thing
    here is that we use the `export` keyword to indicate that we want to use it in
    a scope outside of its source file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，在其创建和几个提议之后，语言模块的概念得到了巩固。解释这个概念的最佳方式是使用示例来演示。首先，我们创建一个 `sum.mjs`
    文件 – 一个接收两个数字并返回它们的和的 `sum` 函数。这里重要的是，我们使用 `export` 关键字来指示我们想在源文件之外的作用域中使用它：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `index.mjs` file, we will use the created function and, for that, we
    make the declaration in the first line of the file. Using the reserved word `import`,
    we indicate which function and which file it is from:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.mjs`文件中，我们将使用创建的函数，为此，我们在文件的第一行进行声明。使用保留字`import`，我们指明哪个函数以及它来自哪个文件：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may be wondering why the `.mjs` extension is used. It’s because, in the
    example, we are using Node.js to execute, and this type of module – **ECMAScript
    modules** (**ESM**), as the official name of the Javascript language is ECMAScript
    – was introduced in version 14.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么使用`.mjs`扩展名。这是因为，在示例中，我们正在使用Node.js来执行，这种类型的模块——**ECMAScript模块**（**ESM**），因为JavaScript语言的官方名称是ECMAScript——是在版本14中引入的。
- en: 'Angular, as well as all other SPA frameworks, uses JavaScript modules in its
    development, and we can notice in any Angular component or service that we export
    the classes and import using the ESM:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Angular，以及所有其他SPA框架，在其开发中使用JavaScript模块，我们可以在任何Angular组件或服务中注意到我们导出类并使用ESM导入：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, we are importing the `Component` decorator from
    the `@angular/core` library and exporting the `HomeComponent` class to use in
    other parts of our project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在从`@angular/core`库中导入`Component`装饰器，并将`HomeComponent`类导出以在其他项目部分中使用。
- en: Modules type
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块类型
- en: Now that we understand and have reinforced the concept of modules in the Angular
    framework, let’s divide our application and make better use of this feature. There
    is no fixed rule for organizing the modules of an application, but the Angular
    team and the community suggest the separation of modules based on the grouping
    of functionalities with common characteristics.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解和加强了Angular框架中模块的概念，让我们将应用程序分割并更好地利用这个特性。组织应用程序模块没有固定的规则，但Angular团队和社区建议根据具有共同特性的功能分组来分离模块。
- en: 'Based on this thought, we can have the following types of Angular modules:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个想法，我们可以有以下类型的Angular模块：
- en: Business domain modules
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务领域模块
- en: Component modules
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件模块
- en: Business domain modules
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 业务领域模块
- en: An application will serve one or more user workflows. This type of module aims
    to group these flows based on the affinity of the interfaces that compose them.
    For example, in an application for resource management, we can have the accounting
    module and the inventory module.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序将服务于一个或多个用户工作流程。此类模块旨在根据组成它们的接口的亲和力对这些流程进行分组。例如，在资源管理应用程序中，我们可以有会计模块和库存模块。
- en: 'In the application available in the `ch2` folder, there is the *talktalk* application
    that we will use in this and other chapters to put our knowledge into practice.
    In the project folder, let’s create the `home` module with the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch2`文件夹中可用的应用程序中，有一个我们将用于本章和其他章节以将我们的知识付诸实践的*talktalk*应用程序。在项目文件夹中，让我们使用以下命令创建`home`模块：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this command, we use the Angular CLI, `ng`, and the abbreviations `g` for
    `m` for `home`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，我们使用Angular CLI的缩写`ng`和`g`代表`m`代表`home`。
- en: 'Let’s create the `Page` component that will represent the application’s home
    page and, since we are using Angular material, we will use the Angular CLI to
    generate a page with a side menu using the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个表示应用程序主页的`Page`组件，由于我们正在使用Angular material，我们将使用Angular CLI来生成一个带有侧菜单的页面，使用以下命令：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The Angular CLI, besides creating the component, also edited the `home.module.ts`
    file by adding it to the `declarations` attribute. Change this file as shown in
    the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建组件外，Angular CLI还编辑了`home.module.ts`文件，将其添加到`declarations`属性中。按照以下示例更改此文件：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this module, we will export the `HomeComponent` component to use in the
    application’s route. In the `app.module.ts` file, import the module as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模块中，我们将导出`HomeComponent`组件以在应用程序的路由中使用。在`app.module.ts`文件中，按以下方式导入模块：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the module in the `import` attribute of the `NgModule` metadata, we can
    change the route in the `app-routing.module.ts` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NgModule`元数据的`import`属性中，我们可以更改`app-routing.module.ts`文件中的路由：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `routes` component is also `NgModule`, however, it is specialized in organizing
    routes, and imports and exports only `RouterModule` from Angular. Here, in the
    `routes` array, we create the direction for `HomeComponent`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes`组件也是`NgModule`，然而，它专门用于组织路由，并且只从Angular导入和导出`RouterModule`。在这里，在`routes`数组中，我们为`HomeComponent`创建方向。'
- en: 'Running the `ng serve --o` command, we get the application’s home page:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`ng serve --o`命令，我们得到应用程序的主页：
- en: "![Figure 2.3 – talktalk sample a\uFEFFpplication menu page](img/B19562_02_3.jpg)"
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – talktalk 示例应用程序菜单页面](img/B19562_02_3.jpg)'
- en: Figure 2.3 – talktalk sample application menu page
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – talktalk 示例应用程序菜单页面
- en: Component modules
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件模块
- en: The purpose of this module is to group directive components and pipes that will
    be reused by business domain components and even other components. Even using
    a component library such as Angular Material, your system will need custom components
    according to the business rules of your business domain.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块的目的是将那些将被业务域组件和其他组件重用的指令组件和管道分组。即使使用像 Angular Material 这样的组件库，你的系统也需要根据你的业务域规则创建自定义组件。
- en: 'This type of component has components, directives, and pipes declared in the
    `declaration` attribute and exported in the `exports` attribute, as shown in the
    following example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的组件在 `declaration` 属性中声明了组件、指令和管道，并在 `exports` 属性中导出，如下面的示例所示：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Separating the project into business domain modules and components will organize
    your code and improve its maintainability. Let’s analyze a common anti-pattern
    in Angular applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目分解为业务域模块和组件将组织你的代码并提高其可维护性。让我们分析 Angular 应用程序中的一种常见反模式。
- en: Avoiding anti-pattern – single module app
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免反模式 – 单模块应用
- en: When we are starting to study and develop with Angular, it is very common not
    to pay much attention to the organization and use of the application modules.
    As we studied at the beginning of this chapter, NgModules are so fundamental to
    Angular that as soon as we start a project, the Angular CLI creates the first
    module for the project, `AppModule`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用 Angular 进行学习和开发时，通常不太关注应用模块的组织和使用。正如我们在本章开头所学的，NgModules 对 Angular 来说是如此基础，以至于当我们开始一个项目时，Angular
    CLI 就会为该项目创建第一个模块，即 `AppModule`。
- en: 'In theory, only this module is necessary for your application to work. From
    there, we can declare all the components and directives, and import all the libraries
    that the project might need, as we can see in the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，仅此模块对于你的应用程序运行是必要的。从那里，我们可以声明所有组件和指令，并导入项目可能需要的所有库，如下面的示例所示：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This approach has some problems and is an anti-pattern that we’ll call a single-module
    app.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法存在一些问题，是一种我们称之为单模块应用的反模式。
- en: 'The problems we have here are as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里遇到的问题如下：
- en: '**Disorganized folder structure**: The team will soon not know which components
    belong to which area of the project. As the project grows, this file will get
    bigger and more confusing.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无序的文件夹结构**：随着项目的增长，团队将很快不知道哪些组件属于项目的哪个区域。随着项目的增长，这个文件将变得更大、更混乱。'
- en: '**Bundle size and build time**: Angular has several build and bundle optimizations
    that depend on the definition of application modules. Staying in just one module,
    these optimizations are not very effective.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包大小和构建时间**：Angular 有几个构建和打包优化，这些优化依赖于应用模块的定义。如果我们只在一个模块中，这些优化效果并不明显。'
- en: '**Component maintainability and update issues**: As this file grows, the team
    will have difficulties deprecating no longer used components or updating those
    components where the Angular CLI is unable to update automatically.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件可维护性和更新问题**：随着这个文件的增长，团队将难以弃用不再使用的组件或更新那些 Angular CLI 无法自动更新的组件。'
- en: 'The solution to this anti-pattern is to apply what we learned in this chapter:
    separating modules into business domain (or feature) and component modules.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这种反模式的方法是应用我们在本章中学到的知识：将模块分为业务域（或功能）和组件模块。
- en: We can use `NgModel` to reduce the repetition of importing common components
    in the application, as we will see in the next section about the `SharedModule`
    pattern.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `NgModel` 来减少在应用程序中重复导入常用组件，正如我们将在下一节关于 `SharedModule` 模式的部分中所看到的。
- en: Optimizing the usage of common modules – the SharedModule pattern
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化常用模块的使用 – SharedModule 模式
- en: 'If we look at Angular projects, we will see patterns of use of modules such
    as `HttpModule`, as in the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察 Angular 项目，我们将看到模块使用模式，例如 `HttpModule`，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To avoid code duplication and also make it easier for new team members, don’t
    forget to add an important module to the project; we can create the `SharedModule`
    call to centralize the common dependencies of an Angular project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免代码重复并使新团队成员更容易上手，别忘了将一个重要的模块添加到项目中；我们可以创建 `SharedModule` 来集中管理 Angular 项目的公共依赖。
- en: 'Let’s do this in our project using the Angular CLI:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的项目中使用 Angular CLI 来实现这一点：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the newly generated file, we will place the Angular Material dependencies:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的文件中，我们将放置Angular Material的依赖项：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this module, we are importing Angular Material’s dependencies and exporting
    the same dependencies, without declaring any component, directive, or pipe.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本模块中，我们正在导入Angular Material的依赖项并导出相同的依赖项，而不声明任何组件、指令或管道。
- en: 'In the `home.module.ts` file, we can refactor to use `SharedModule`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home.module.ts`文件中，我们可以重构以使用`SharedModule`：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how the file has become much more succinct and easier to read using `SharedModule`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`SharedModule`后，文件变得多么简洁且易于阅读。
- en: Important
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: The modules present in `SharedModule` must be modules common to the majority
    of modules in your project, as this can increase the size of the module’s bundle.
    If the module needs some specific dependency, you must declare it in that dependency
    and not in `SharedModule`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SharedModule`中存在的模块必须是您项目中大多数模块共有的模块，因为这会增加模块包的大小。如果模块需要一些特定的依赖项，您必须在那个依赖项中声明它，而不是在`SharedModule`中。
- en: In the next topic, we’ll see a feature that will improve your user’s experience
    and is based on organizing the application into modules.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将看到一个将提高用户体验的功能，该功能基于将应用程序组织成模块。
- en: Improving the size of your app – lazy loading
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高应用程序的大小 – 懒加载
- en: A good strategy for separating modules from your Angular application will increase
    your team’s productivity and improve code organization. But another advantage
    that will impact the quality for your user is the use of the lazy loading technique
    for modules.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块从您的Angular应用程序中分离出来的好策略将提高团队的生产力并改善代码组织。但另一个将影响用户质量的优势是使用模块的懒加载技术。
- en: 'If we run the build process of the sample application using the `ng build`
    command, we can see the following message:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`ng build`命令运行示例应用程序的构建过程，我们可以看到以下消息：
- en: '![Figure 2.4 – Sample application bundle size](img/B19562_02_4.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 示例应用程序包大小](img/B19562_02_4.jpg)'
- en: Figure 2.4 – Sample application bundle size
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 示例应用程序包大小
- en: The size of our application’s initial bundle (the `main.ts` file) is 94.73 kB,
    which may seem small, but for the size of our application with few features, it
    is a considerable size.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的初始包（`main.ts`文件）的大小为94.73 kB，这可能看起来很小，但考虑到我们的应用程序功能较少，这是一个相当大的大小。
- en: As the project has more features, the tendency is for this initial bundle to
    increase considerably, harming our users’ experience as they will initially need
    to download a larger file. This problem particularly manifests itself in environments
    where the internet is not very good, such as 3G networks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目功能的增加，这种初始包的增长趋势会相当明显，这会损害用户的体验，因为他们最初需要下载一个更大的文件。这个问题在互联网不太好的环境中尤其明显，例如3G网络。
- en: To reduce this file and consequently improve our user experience, the ideal
    is to have smaller packages and for these packages to be loaded only when necessary
    – that is, in a lazy way.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减小这个文件并相应地提高用户体验，理想的情况是拥有更小的包，并且这些包只在必要时加载 – 也就是说，以懒加载的方式。
- en: We are going to refactor our project, and the first step we have already taken
    is to separate the functionalities into feature modules (in the *Avoiding anti-pattern
    – single module app* section, we explained the danger of not separating the application
    modules, and without a doubt, the size of the bundle is the most impactful for
    the user).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构我们的项目，我们已经采取的第一步是将功能分离到功能模块中（在*避免反模式 – 单模块应用*部分，我们解释了不分离应用程序模块的危险，毫无疑问，包的大小对用户影响最大）。
- en: Now, let’s create a route file for the `Home` module. As the module already
    exists, let’s manually create the `home-routing.module.ts` file in the same folder
    as the `home.module.ts` file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为`Home`模块创建一个路由文件。由于该模块已经存在，让我们在`home.module.ts`文件所在的同一文件夹中手动创建`home-routing.module.ts`文件。
- en: 'In this file, we will add the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们将添加以下代码：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This route file is similar to the application’s main route file, with the difference
    that `@NgModule`’s import uses the `forChild` method instead of `forRoot`. This
    is because this module is a subroute of the main route.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由文件与应用程序的主要路由文件类似，不同之处在于`@NgModule`的导入使用`forChild`方法而不是`forRoot`。这是因为此模块是主路由的子路由。
- en: Another important detail to note is that the chosen path for the `HomeComponent`
    component is empty. We can explain this because the main route file that defines
    the `/home` route and how this module represents the `/home` component is already
    defined.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的重要细节是，为`HomeComponent`组件选择的路径是空的。我们可以解释这一点，因为定义`/home`路由以及如何表示`/home`组件的主要路由文件已经定义。
- en: 'In the `home.module.ts` file, let’s change it to import the route file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home.module.ts`文件中，让我们将其更改为导入路由文件：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this file, we also removed the export of the `HomeComponent` component because
    the `Home` module route file will load it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们还移除了`HomeComponent`组件的导出，因为`Home`模块的路由文件会加载它。
- en: 'In the project’s main route file, `app-routing.module.ts`, let’s refactor it
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的主要路由文件`app-routing.module.ts`中，让我们按照以下方式重构它：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this code, the most important part is the `loadChildren` attribute. This
    is where we configure the lazy load, as we pass to Angular’s route mechanism a
    function that returns an `import` promise.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，最重要的部分是`loadChildren`属性。这是我们配置懒加载的地方，因为我们向Angular的路由机制传递一个返回`import`承诺的函数。
- en: Note that the `import` function is not an Angular function, but a standard JavaScript
    function that allows dynamic loading of code. Angular’s route engine uses this
    language feature to bring this functionality.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`import`函数不是一个Angular函数，而是一个标准的JavaScript函数，它允许动态加载代码。Angular的路由引擎使用这个语言特性来实现这一功能。
- en: 'Finally, in the main module, `AppModule`, let’s remove the `HomeModule` import:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在主模块`AppModule`中，让我们移除`HomeModule`的导入：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running our application with the `ng serve` command, we didn’t notice any difference.
    However, when executing the `ng build` command, we can notice the following diagnosis:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ng serve`命令运行我们的应用程序时，我们没有注意到任何差异。然而，当执行`ng build`命令时，我们可以注意到以下诊断：
- en: '![Figure 2.5 – Application bundle size after refactoring with lazy loading](img/B19562_02_5.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 使用懒加载重构后的应用程序包大小](img/B19562_02_5.jpg)'
- en: Figure 2.5 – Application bundle size after refactoring with lazy loading
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 使用懒加载重构后的应用程序包大小
- en: The Angular build process has separated the `Home` module into its own bundle
    and the `main.ts` bundle has been made smaller. The difference may seem small
    but note that, this way, our application can scale and grow in complexity and
    the initial bundle will remain small or grow very little.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Angular构建过程已将`Home`模块分离成其自己的包，并将`main.ts`包变得更小。这种差异可能看起来很小，但请注意，这样我们的应用程序可以扩展并增加复杂性，而初始包将保持较小或增长很少。
- en: The new features continue to exist and be loaded by the application, but the
    initial loading will be faster, and these new features will be downloaded on demand
    only when the user accesses the route they want, giving a very positive fluidity
    and responsiveness.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能仍然存在并被应用程序加载，但初始加载将更快，并且这些新功能将仅在用户访问他们想要的路径时按需下载，从而提供非常积极的流畅性和响应性。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we studied the Angular modules in detail and how we can use
    them for the organization and performance of our applications. We learned the
    difference between Angular modules and JavaScript modules, and we saw each attribute
    of a module definition and the types that we can create in the project. Finally,
    we learned how to avoid the single module app anti-pattern and how to create the
    `SharedModule`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细研究了Angular模块以及我们如何利用它们来组织应用程序的性能。我们学习了Angular模块与JavaScript模块之间的区别，并看到了模块定义的每个属性以及我们可以在项目中创建的类型。最后，我们学习了如何避免单模块应用程序的反模式以及如何创建`SharedModule`。
- en: We reiterated our example application to use lazy loading of bundles, which
    demonstrates that good module organization reflects performance and fluidity for
    our users. Now, you are able to organize your application in such a way that it
    can scale and increase in complexity and features without compromising the maintainability
    of the project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重申了我们的示例应用，使用分批懒加载，这证明了良好的模块组织反映了我们用户的表现力和流畅性。现在，你可以以这种方式组织你的应用程序，使其能够扩展并增加复杂性和功能，而不会损害项目的可维护性。
- en: In the next chapter, we will learn how to use TypeScript effectively and productively
    for our Angular projects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何有效地使用TypeScript来为我们的Angular项目提高生产效率。
