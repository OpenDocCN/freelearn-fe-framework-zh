- en: Chapter 1. Saying Hello!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 说你好！
- en: 'Let''s follow several steps to establish a development environment for the
    simplest application possible, to show you how easy it is to get a web application
    up and running with Angular 2 and Bootstrap 4\. At the end of the chapter, you
    will have a solid understanding of:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照几个步骤来建立一个尽可能简单的应用程序的开发环境，向你展示使用Angular 2和Bootstrap 4轻松地启动和运行Web应用程序有多容易。在本章结束时，你将对以下内容有扎实的理解：
- en: How to set up your development environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置你的开发环境
- en: How TypeScript can change your development life
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript如何改变你的开发生活
- en: Core concepts of Angular and Bootstrap
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular和Bootstrap的核心概念
- en: How to create a simple Angular component with Bootstrap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Bootstrap创建一个简单的Angular组件
- en: How to display some data through it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过它显示一些数据
- en: Setting up a development environment
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Let's set up your development environment. This process is one of the most overlooked
    and often frustrating parts of learning to program because developers don't want
    to think about it. Developers must know the nuances of how to install and configure
    many different programs before they start real development. Everyone's computers
    are different; as a result, the same setup may not work on your computer. We will
    expose and eliminate all of these problems by defining the various pieces of environment
    you need to set up.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来设置你的开发环境。这个过程是学习编程中最容易被忽视和经常令人沮丧的部分之一，因为开发人员不想考虑它。开发人员必须了解如何安装和配置许多不同的程序，然后才能开始真正的开发。每个人的电脑都不一样；因此，相同的设置可能在你的电脑上无法工作。我们将通过定义你需要设置的各种环境的各个部分来暴露和消除所有这些问题。
- en: Defining a shell
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个shell
- en: The **shell** is a required part of your software development environment. We
    will use the shell to install software and run commands to build and start the
    web server to bring life to your web project. If your computer has the Linux operating
    system installed then you will use a shell called **Terminal** . There are many
    Linux-based distributions out there that use diverse desktop environments, but
    most of them use the equivalent keyboard shortcut to open Terminal.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell** 是你的软件开发环境的必需部分。我们将使用Shell来安装软件并运行命令来构建和启动Web服务器，为你的Web项目注入生命。如果你的电脑安装了Linux操作系统，那么你将使用一个叫做**Terminal**的Shell。有许多基于Linux的发行版，它们使用不同的桌面环境，但大多数都使用相同的键盘快捷键来打开Terminal。'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use keyboard shortcut *Ctrl* + *Alt* + *T* to open Terminal in Ubuntu, Kali,
    and Linux Mint. If it doesn't work for you, please check the documentation for
    your version of Linux.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu、Kali和Linux Mint中使用键盘快捷键*Ctrl* + *Alt* + *T*来打开Terminal。如果对你不起作用，请查看你的Linux版本的文档。
- en: If you have a Mac computer with OS X installed, then you will use the Terminal
    shell as well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的Mac电脑安装了OS X，那么你也将使用Terminal shell。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use keyboard shortcut *command* + *space* to open the **Spotlight** , type Terminal
    to search and run.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键盘快捷键*command* + *space*来打开**Spotlight**，输入Terminal进行搜索和运行。
- en: If you have a computer with a Windows operating system installed, you can use
    the standard **Command Prompt** , but we can do better. In a minute I will show
    you how can you install Git on your computer, and you will have Git Bash free.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的电脑安装了Windows操作系统，你可以使用标准的**命令提示符**，但我们可以做得更好。一会儿我会告诉你如何在你的电脑上安装Git，并且你将免费获得Git
    Bash。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can open a Terminal with the `Git Bash` shell program on Windows.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Windows上使用`Git Bash` shell程序打开一个Terminal。
- en: I will use the Bash shell for all exercises in this book whenever I need to
    work in Terminal.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我需要在Terminal中工作时，我会在本书的所有练习中使用Bash shell。
- en: Installing Node.js
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Node.js
- en: '**Node.js** is technology we will use as a cross-platform runtime environment
    to run server-side web applications. It is a combination of a native, platform-independent
    runtime based on Google''s V8 JavaScript engine and a huge number of modules written
    in JavaScript. Node.js ships with different connectors and libraries help you
    use HTTP, TLS, compression, file system access, raw TCP and UDP, and more. You
    as a developer can write your own modules on JavaScript and run them inside the
    Node.js engine. The Node.js runtime makes it easy to build a network event-driven
    application servers.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node.js**是我们将用作跨平台运行时环境来运行服务器端Web应用程序的技术。它是基于Google的V8 JavaScript引擎的本地、平台无关的运行时和大量用JavaScript编写的模块的组合。Node.js附带了不同的连接器和库，帮助您使用HTTP、TLS、压缩、文件系统访问、原始TCP和UDP等。作为开发人员，您可以在JavaScript中编写自己的模块，并在Node.js引擎内运行它们。Node.js运行时使构建网络事件驱动的应用服务器变得容易。'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The terms *package* and *library* are synonymous in JavaScript so we will use
    them interchangeably.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*package*和*library*在JavaScript中是同义的，因此我们将它们互换使用。
- en: Node.js is utilizing the **JavaScript Object Notation** ( **JSON** ) format
    widely in data exchanges between the server and client sides because it is readily
    expressed in several parse diagrams, notably without the complexities of XML,
    SOAP, and other data exchange formats.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js广泛利用**JavaScript对象表示法**（**JSON**）格式在服务器和客户端之间进行数据交换，因为它可以在几个解析图中轻松表达，特别是没有XML、SOAP和其他数据交换格式的复杂性。
- en: You can use Node.js for the development of service-oriented applications, doing
    something different than web servers. One of the most popular service-oriented
    applications is **node package manager** ( **npm** ), which we will use to manage
    library dependencies, deployment systems, and which underlies the many **platform-as-a-service**
    ( **PaaS** ) providers for Node.js.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Node.js开发面向服务的应用程序，做一些与Web服务器不同的事情。最受欢迎的面向服务的应用程序之一是**node package manager**（**npm**），我们将使用它来管理库依赖关系、部署系统，并为Node.js的许多**平台即服务**（**PaaS**）提供商提供基础。
- en: 'If you do not have Node.js installed on your computer, you should download
    the pre-build installer from [https://nodejs.org/en/download](https://nodejs.org/en/download)
    , or you can use the unofficial package managers from [https://nodejs.org/en/download/package-manager](https://nodejs.org/en/download/package-manager)
    . You can start to use Node.js immediately after installation. Open Terminal and
    type:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机上没有安装Node.js，您应该从[https://nodejs.org/en/download](https://nodejs.org/en/download)下载预构建的安装程序，或者您可以使用来自[https://nodejs.org/en/download/package-manager](https://nodejs.org/en/download/package-manager)的非官方包管理器。安装后，您可以立即开始使用Node.js。打开终端并键入：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Node.js will respond with the version number of the installed runtime:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js将以安装的运行时的版本号作出响应：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Bear in mind that the version of Node.js installed on my computer could be different
    from yours. If these commands give you a version number, you are ready to go with
    Node.js development.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我计算机上安装的Node.js版本可能与您的不同。如果这些命令给您一个版本号，那么您已经准备好开始Node.js开发了。
- en: Setting up npm
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置npm
- en: 'The npm is a package manager for JavaScript. You can use it to find, share,
    and reuse packages of code from many developers across the world. The number of
    packages dramatically grows every day and now is more than 250K. The npm is a
    Node.js package manager and utilizes it to run itself. The npm is included in
    the setup bundle of Node.js and available just after installation. Open Terminal
    and type:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: npm是JavaScript的包管理器。您可以使用它来查找、共享和重用来自世界各地许多开发人员的代码包。包的数量每天都在急剧增长，现在已经超过250K。npm是Node.js的包管理器，并利用它来运行自身。npm包含在Node.js的安装包中，并在安装后立即可用。打开终端并键入：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The npm must respond on your command with a version number:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: npm必须以版本号的形式响应您的命令：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'My Node.js comes with that particular version of npm. The npm gets updated
    quite frequently, so you''ll want to move to the latest version with the following
    command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我的Node.js带有特定版本的npm。npm经常更新，所以您需要使用以下命令切换到最新版本：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may experience permission problems to search or install packages with npm.
    If that is the case, I recommend following the instructions from [https://docs.npmjs.com/getting-started/fixing-npm-permissions](https://docs.npmjs.com/getting-started/fixing-npm-permissions)
    and don't use superuser privileges to fix them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到使用npm搜索或安装软件包时的权限问题。如果是这种情况，我建议按照[https://docs.npmjs.com/getting-started/fixing-npm-permissions](https://docs.npmjs.com/getting-started/fixing-npm-permissions)上的说明操作，不要使用超级用户权限来修复它们。
- en: 'The following command gives us information about Node.js and the npm install:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令为我们提供了有关Node.js和npm安装的信息：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are two ways to install npm packages: locally or globally. In cases when
    you would like to use the package as a tool, it''s better install it globally:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以安装npm软件包：本地安装或全局安装。在您希望将软件包用作工具时，最好进行全局安装：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you need to find the folder with globally installed packages you can use
    the next command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要找到全局安装软件包的文件夹，可以使用以下命令：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installation global packages are important, but best to avoid if not needed.
    Mostly you will install packages locally.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 全局安装软件包很重要，但最好在不需要时避免。大多数情况下，您会进行本地安装。
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You may find locally installed packages in the `node_modules` folder of your
    project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目的`node_modules`文件夹中找到本地安装的软件包。
- en: Installing Git
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Git
- en: If you're not familiar with Git then you're really missing out! Git is a distributed
    version control system and each Git working directory is a full-fledged repository.
    It keeps a complete history of changes and has full version tracking capabilities.
    Each repository is entirely independent of network access or a central server.
    You can keep Git repositories on your computer and share it with your mates, or
    you can take advantage of the many online VCS providers. The big guys you should
    look at closely are GitHub, Bitbucket, and Gitlab.com. Each has its own benefits,
    depending on your needs and project type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉Git，那您真的错过了很多！Git是一个分布式版本控制系统，每个Git工作目录都是一个完整的仓库。它保留了完整的更改历史，并具有完整的版本跟踪功能。每个仓库都完全独立于网络访问或中央服务器。您可以在计算机上保存Git仓库并与同事共享，或者利用许多在线VCS提供者。您应该仔细查看的大公司是GitHub、Bitbucket和Gitlab.com。每个都有自己的好处，取决于您的需求和项目类型。
- en: 'Mac computers comes with Git already installed into the operating system but
    usually the version of Git is not the same as the latest one. You can update or
    install Git on your computer via a set of pre-build installers available on the
    official website [https://git-scm.com/downloads](https://git-scm.com/downloads)
    . After installation, you can open Terminal and type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Mac计算机已经安装了Git到操作系统中，但通常Git的版本与最新版本不同。您可以通过官方网站[https://git-scm.com/downloads](https://git-scm.com/downloads)上提供的一组预构建安装程序来更新或安装Git到您的计算机上。安装完成后，您可以打开终端并输入：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Git must respond with a version number:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Git必须以版本号做出响应：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As I said, for developers who use computers with an installed Windows operation
    system, you now have Git Bash free on your system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，对于使用安装了Windows操作系统的计算机的开发人员，您现在可以在系统上免费使用Git Bash。
- en: Code editor
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码编辑器
- en: You can imagine how many programs for code editing exist, but we will talk today
    only about the free, open source, runs everywhere Visual Studio Code from Microsoft.
    You can use any program you prefer for development, but I will be using only Visual
    Studio code in our future exercises, so please install it from [http://code.visualstudio.com/Download](http://code.visualstudio.com/Download)
    .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以想象有多少用于代码编辑的程序存在，但我们今天只谈论免费、开源、可以在任何地方运行的微软Visual Studio Code。您可以使用任何您喜欢的程序进行开发，但在我们未来的练习中，我将只使用Visual
    Studio Code，请从[http://code.visualstudio.com/Download](http://code.visualstudio.com/Download)
    安装它。
- en: A TypeScript crash course
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript的速成课程
- en: TypeScript is an open source programming language developed and maintained by
    Microsoft. Its initial public release was in October 2012 and was presented by
    Anders Hejlsberg, the lead architect of C# and creator of Delphi and Turbo Pascal.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是由微软开发和维护的开源编程语言。它最初于2012年10月公开发布，并由C#的首席架构师、Delphi和Turbo Pascal的创始人Anders
    Hejlsberg进行了介绍。
- en: TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.
    Any existing JavaScript is also valid TypeScript. It gives you type checking,
    explicit interfaces, and easier module exports. For now, it includes **ES5** ,
    **ES2015** , **ES2016** , and, in fact, it's a little like getting some of tomorrow's
    ECMAScripts early so that we can play with some of those features today.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是JavaScript的一种类型化超集，可以编译为普通的JavaScript。任何现有的JavaScript也都是有效的TypeScript。它提供了类型检查、显式接口和更容易的模块导出。目前，它包括**ES5**，**ES2015**，**ES2016**，实际上有点像提前获得明天的ECMAScript的一些功能，这样我们就可以今天就使用一些这些功能。
- en: 'Here is the relationship between ECMAScripts and TypeScript:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是ECMAScript和TypeScript之间的关系：
- en: '![A TypeScript crash course](Image00001.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![TypeScript速成课程](Image00001.jpg)'
- en: Writing code using TypeScript is relatively straightforward if you already have
    a background in the JavaScript language. Try the TypeScript playground [http://www.typescriptlang.org/play](http://www.typescriptlang.org/play)
    to play with IntelliSense, find references, and so on, directly from your browser.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经熟悉JavaScript语言，使用TypeScript编写代码相对简单。可以在TypeScript playground [http://www.typescriptlang.org/play](http://www.typescriptlang.org/play)
    中使用IntelliSense、查找引用等功能，直接从浏览器中进行操作。
- en: Types
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: 'TypeScript provides a static type checking operation that allows many bugs
    in the development cycle to be caught early. TypeScript enables type checking
    at compile time via type annotations. Types in TypeScript are always optional,
    so you can ignore them if you prefer the regular dynamic typing of JavaScript.
    It supports `number` , `boolean` , and `string` type annotations for primitive
    types and `any` for dynamically-typed structures. In the following example, I
    added type annotations to `return` and parameters for `function` :'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript提供了静态类型检查操作，可以在开发周期中捕捉到许多错误。TypeScript通过类型注解实现了编译时的类型检查。TypeScript中的类型始终是可选的，因此如果您更喜欢JavaScript的常规动态类型，则可以忽略它们。它支持原始类型的`number`，`boolean`和`string`类型注解，以及动态类型结构的`any`。在下面的示例中，我为`function`的`return`和参数添加了类型注解：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In one moment of compilation, a TypeScript compiler can generate a declaration
    file which contains only signatures of the exported types. The resulting declaration
    file with the extension `.d.ts` along with a JavaScript library or module can
    be consumed later by a third-party developer. You can find a vast collection of
    declaration files for many popular JavaScript libraries at:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译的某一时刻，TypeScript编译器可以生成一个仅包含导出类型签名的声明文件。带有扩展名`.d.ts`的结果声明文件以及JavaScript库或模块可以稍后由第三方开发人员使用。您可以在以下网址找到许多流行JavaScript库的声明文件的广泛集合：
- en: The **DefinitelyTyped** ([https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)
    )
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DefinitelyTyped** ([https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)
    )'
- en: The **Typings** registry ([https://github.com/typings/registry](https://github.com/typings/registry)
    )
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Typings** 注册表 ([https://github.com/typings/registry](https://github.com/typings/registry)
    )'
- en: Arrow function
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'Functions in JavaScript are first class citizens, which means they can be passed
    around like any other values:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的函数是头等公民，这意味着它们可以像其他任何值一样传递：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first parameter in `reduce` is an anonymous function. Anonymous functions
    are very useful in many scenarios but too verbose. TypeScript introduced new,
    less verbose syntax to define anonymous functions called **arrow function** syntax:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 中的第一个参数是匿名函数。匿名函数在许多场景中非常有用，但太啰嗦了。TypeScript 引入了一种新的、不那么啰嗦的语法来定义匿名函数，称为
    **箭头函数** 语法：'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or event less:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至更简洁：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When defining parameters, you can even omit parentheses if the parameters are
    just a single identifier. So the regular `map` method of array:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义参数时，如果参数只是一个标识符，甚至可以省略括号。所以数组的常规 `map` 方法：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Could be much more concise:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更加简洁：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both syntaxes `(x) => x * x` and `x => x * x` are allowed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 两种语法 `(x) => x * x` 和 `x => x * x` 都是允许的。
- en: 'Another important feature of arrow function is that it doesn''t shadow `this`
    and pick it up from the lexical scope. Let''s assume we have a constructor function
    `Counter` which increments the value of an internal variable `age` in timeout
    and prints it out:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数的另一个重要特性是它不会遮蔽 `this`，而是从词法作用域中获取它。假设我们有一个构造函数 `Counter`，它在超时中增加内部变量 `age`
    的值并将其打印出来：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As result of using the arrow function, the `age` from the scope of `Counter`
    is available inside the callback function of `setTimeout` . Here is the converted
    to JavaScript ECMAScript 5 code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头函数的结果是，`Counter` 作用域中的 `age` 在 `setTimeout` 的回调函数中是可用的。以下是转换为 JavaScript
    ECMAScript 5 代码：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following variables are all lexical inside arrow functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下变量在箭头函数内部都是词法作用域的：
- en: '`arguments`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments`'
- en: '`super`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super`'
- en: '`this`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`'
- en: '`new.target`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new.target`'
- en: Block scope variables
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块作用域变量
- en: 'All variables in ES5 declared with a `var` statement are function-scoped, and
    their scope belongs to enclosing functions. The result of the following code can
    be confusing because it returns `undefined` :'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，使用 `var` 声明的所有变量都是函数作用域的，它们的作用域属于封闭函数。以下代码的结果可能令人困惑，因为它返回 `undefined`：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `x` is an inner variable of the `random` function and does not have any
    relation to the variable defined on the first line. The result of calling the
    `random` function at the last line returned `undefined` , because the JavaScript
    interprets the code in `random` function like that:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 是 `random` 函数的内部变量，与第一行定义的变量没有任何关系。在最后一行调用 `random` 函数的结果返回 `undefined`，因为
    JavaScript 解释 `random` 函数中的代码如下：'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This confusing code can be fixed in TypeScript with new block-scope variable
    declarations:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，这段令人困惑的代码可以通过新的块作用域变量声明来修复：
- en: The `let` is a block-scope version of `var`
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let` 是 `var` 的块作用域版本'
- en: The `const` is similar `let` but allows initialize variable only once
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const` 类似于 `let`，但只允许初始化变量一次'
- en: 'The TypeScript compiler throws more errors with new block-scope variable declarations
    and prevents writing complicated and damaged code. Let''s change `var` to `let`
    in the previous example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器使用新的块作用域变量声明会抛出更多错误，并防止编写复杂和损坏的代码。让我们在前面的例子中将 `var` 改为 `let`：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And now our code works as expected.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码按预期工作了。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I recommend using `const` and `let` to make the code cleaner and safer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用 `const` 和 `let` 来使代码更清晰、更安全。
- en: Template literals
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板文字
- en: 'If we need string interpolation, we usually combine the values of variables
    and string fragments such as:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要字符串插值，通常会将变量的值与字符串片段组合在一起，例如：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The TypeScript supports template literals--string literals allowing embedded
    expressions. You can use the string interpolation features of the template literals
    out of the box:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持模板文字--允许嵌入表达式的字符串文字。您可以直接使用模板文字的字符串插值功能：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you need multiline string, the template literals can help again:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要多行字符串，模板文字可以再次帮助：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last line prints results as follow:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行打印结果如下：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I recommend using template literals as a safer way of string interpolation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用模板文字作为更安全的字符串插值方式。
- en: The for-of loop
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for-of循环
- en: 'We usually use `for` statement or `forEach` method of `Array` to iterate over
    elements in JavaScript ES5:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用`for`语句或JavaScript ES5中`Array`的`forEach`方法来迭代元素：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each of these methods has its benefit:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其好处：
- en: We can interrupt the `for` statement via `break` or`continue`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过`break`或`continue`中断`for`语句
- en: The `forEach` method is less verbose
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach`方法更简洁'
- en: 'The TypeScript has `for-of` loop as a combination of both of them:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript具有`for-of`循环，结合了这两种方法：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `for-of` loop supports `break` and `continue` and can use the `index` and
    `value` of each array via new `Array` method `entries` :'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-of`循环支持`break`和`continue`，并且可以使用`entries`方法的`index`和`value`来使用每个数组：'
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Default value, optional and rest parameters
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认值、可选和剩余参数
- en: 'We quite often need to check the input parameters of functions and assign default
    values to them:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要检查函数的输入参数并为它们分配默认值：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The TypeScript has syntax to handle default values of parameters to make previous
    functions shorter and safer:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript有语法来处理参数的默认值，使之前的函数更短、更安全：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A default value of a parameter is assigned only by its `undefined` value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的默认值只有在其`undefined`值时才会被赋值。
- en: 'Each parameter of a function in JavaScript ES5 is optional, so an omitted one
    equals `undefined` . To make it strict, TypeScript expects a question mark at
    the end of parameters we want to be optional. We can mark the last parameter of
    the `square` function as optional and call the function with one or two parameters:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript ES5中函数的每个参数都是可选的，因此省略的参数等于`undefined`。为了使其严格，TypeScript希望在我们想要可选的参数末尾加上一个问号。我们可以将`square`函数的最后一个参数标记为可选，并使用一个或两个参数调用该函数：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any optional parameters must follow the required parameters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可选参数必须跟在必需参数后面。
- en: 'In some scenarios, we need to work with multiple parameters as a group, or
    we may not know how many parameters a function takes. The JavaScript ES5 provides
    the `arguments` variable in the scope of functions to work with them. In TypeScript,
    we can use a formal variable to keep the rest of the parameters. The compiler
    builds an array of the arguments passed in with the name given after the ellipses
    so that we can use it in our function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要将多个参数作为一组处理，或者我们可能不知道函数需要多少个参数。JavaScript ES5在函数范围内提供了`arguments`变量来处理它们。在TypeScript中，我们可以使用一个形式变量来保存其余的参数。编译器使用省略号后面给定的名称构建传递的参数数组，以便我们可以在函数中使用它：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Interfaces
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'The interface is the way of defining contracts inside and outside the code
    of your project. We use the interface in TypeScript only to describe a type and
    the shape of data to help us keep our code error-free. In comparison with many
    other languages, the TypeScript compiler doesn''t generate any code for the interface
    so that it has not runtime cost. The TypeScript defines interfaces via the interface
    keyword. Let''s define a type `Greetable` :'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是定义项目内外合同的方式。我们在TypeScript中使用接口只是为了描述类型和数据的形状，以帮助我们保持代码无误。与许多其他语言相比，TypeScript编译器不会为接口生成任何代码，因此它没有运行时成本。TypeScript通过interface关键字定义接口。让我们定义一个类型`Greetable`：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It has a member function called `greetings` that takes a string argument. Here
    is how we can use it as a type of parameter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个名为`greetings`的成员函数，接受一个字符串参数。以下是我们如何将其用作参数类型：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Classes
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'JavaScript has a prototype-based, object-oriented programming model. We can
    instantiate objects using the object literal syntax or constructor function. Its
    prototype-based inheritance is implemented on prototype chains. If you come from
    an object-oriented approach, you may feel uncomfortable when you try to create
    classes and inheritance based on prototypes. TypeScript allows for writing code
    based on an object-oriented class-based approach. The compiler translates the
    class down to JavaScript and works across all major web browsers and platforms.
    Here is the class `Greeter` . It has a property called `greeting` , a `constructor`
    , and a method `greet` :'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript具有基于原型的面向对象编程模型。我们可以使用对象文字语法或构造函数来实例化对象。它的基于原型的继承是在原型链上实现的。如果您来自面向对象的方法，当您尝试基于原型创建类和继承时，可能会感到不舒服。TypeScript允许基于面向对象的类的方法编写代码。编译器将类转换为JavaScript，并在所有主要的Web浏览器和平台上运行。这是类`Greeter`。它有一个名为`greeting`的属性，一个`constructor`和一个`greet`方法：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To refer to any member of the class we prepend `this` . To create an instance
    of the class we use the `new` keyword:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用类的任何成员，我们需要在前面加上`this`。要创建类的实例，我们使用`new`关键字：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can extend an existing class to create new ones via inheritance:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过继承来扩展现有的类以创建新的类：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the class `EmailGreeter` , we demonstrate several features of inheritance
    in TypeScript:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在类`EmailGreeter`中，我们展示了TypeScript中继承的几个特性：
- en: We use `extends` to create a subclass
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`extends`来创建一个子类
- en: We must call `super` in the first line of the constructor to pass values into
    base class
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须在构造函数的第一行调用`super`以将值传递给基类
- en: We call the `greet` method of the base class to create a subject for `mailto`
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用基类的`greet`方法来创建一个`mailto`的主题
- en: The TypeScript classes support `public` , `protected` , and `private` modifiers
    to access the members that we declared throughout our programs. Each member of
    the class is public by default. There are not a requirement to labeled all `public`
    members with that keyword but you may mark them explicitly. Use protected modifier
    if you need to restrict access to members of the class from outside, but bear
    in mind that they are still available from deriving classes. You can mark the
    constructor as protected so that we cannot instantiate the class but we can extend
    it. The `private` modifier restricts access to member only on the class level.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript类支持`public`、`protected`和`private`修饰符，以访问我们在整个程序中声明的成员。类的每个成员默认为public。不需要使用关键字标记所有`public`成员，但您可以显式标记它们。如果需要限制从外部访问类的成员，则使用protected修饰符，但请记住它们仍然可以从派生类中访问。您可以将构造函数标记为protected，以便我们无法实例化该类，但可以扩展它。`private`修饰符限制了仅在类级别上访问成员。
- en: 'If you look at constructors of `EmailGreeter` , we had to declare a private
    member `email` and a constructor parameter `emailAddr` . Instead, we can use parameter
    properties to let us create and initialize a member in one place:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看“EmailGreeter”的构造函数，我们必须声明一个私有成员“email”和一个构造函数参数“emailAddr”。相反，我们可以使用参数属性来让我们在一个地方创建和初始化成员：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can use any modifier in parameter properties.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在参数属性中使用任何修饰符。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use parameter properties to consolidate the declaration and assignment in one
    place.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数属性将声明和赋值 consoli在一个地方。
- en: 'TypeScript supports getters and setters to organize intercepting access to
    members of an object. We can change the original `Greeter` class with the following
    code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持使用getter和setter来组织拦截对象成员的访问。我们可以使用以下代码更改原始的“Greeter”类：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We check the `value` parameter inside the setter of `greeting` and modify it
    if necessary to empty string before assigning it to the private member.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“问候语”的setter中检查“value”参数，并在将其分配给私有成员之前，根据需要将其修改为空字符串。
- en: 'TypeScript supports class members via the static modifier as well. Here the
    class `Types` contains only static members:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript还通过静态修饰符支持类成员。这里的“Types”类仅包含静态成员：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can access those values through prepending the name of the class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在类名前加上访问这些值：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'TypeScript gives us supreme flexibility via abstract classes. We cannot create
    instances of them, but we can use them to organize base classes from which each
    distinct class may be derived. We can convert the `greeting` class into abstract
    with just one keyword:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript通过抽象类为我们提供了极大的灵活性。我们无法创建它们的实例，但我们可以使用它们来组织基类，从而可以派生出每个不同的类。我们可以使用一个关键字将“greeting”类转换为抽象类：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The method `greet` is marked as `abstract` . It doesn't contain an implementation
    and must be implemented in derived classes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 方法“greet”被标记为“abstract”。它不包含实现，必须在派生类中实现。
- en: Modules
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: When we are writing the code, we usually divide it into functions and the blocks
    inside those functions. The size of a program can increase very quickly, and individual
    functions start to blend into the background. We can make such a program more
    readable if we split them into large units of an organization like modules. At
    the beginning of writing a program, you may not know how to structure it, and
    you can use structureless principles. When your code becomes stable you can put
    pieces of functionality into separate modules to make them easy to track, update,
    and share. We store modules of TypeScript in files, exactly one module per file
    and one file per module.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，通常将其分成函数和这些函数内部的块。程序的大小可能会迅速增加，个别函数开始混为一体。如果我们将它们分成像模块这样的大型组织单位，可以使这样的程序更易读。在编写程序的开始阶段，您可能不知道如何构造它，可以使用无结构的原则。当您的代码变得稳定时，可以将功能片段放入单独的模块中，以便跟踪、更新和共享。我们将TypeScript的模块存储在文件中，每个文件恰好一个模块，每个模块一个文件。
- en: The JavaScript ES5 doesn't have built-in support for modules and we used AMD
    or CommonJS syntax to work with them. TypeScript supports the concept of modules.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript ES5没有内置对模块的支持，我们使用AMD或CommonJS语法来处理它们。TypeScript支持模块的概念。
- en: 'How do the scope and module depend on each other? The global scope of JavaScript
    doesn''t have access to the scope of executing modules. It creates its own scope
    for each individual execution module, so everything declared inside the module
    is not visible from outside. We need to explicitly export them to make them visible
    and import them to consume them. The relationship between modules is defined at
    the file level regarding exports and imports. Any file defines a top-level `export`
    or `import` and is considered a module. Here is a `string-validator.ts` file which
    contains the exported declaration:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域和模块如何相互依赖？JavaScript的全局作用域无法访问执行模块的作用域。它为每个单独的执行模块创建自己的作用域，因此模块内声明的所有内容都无法从外部访问。我们需要显式导出它们以使其可见，并导入它们以使用它们。模块之间的关系是根据导出和导入在文件级别上定义的。任何文件都定义了顶级的`export`或`import`，并被视为一个模块。这里有一个`string-validator.ts`文件，其中包含导出的声明：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'I have created another file `zip-validator.ts` with several members, but exported
    only one of them to hide another one from outside:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了另一个文件`zip-validator.ts`，其中包含几个成员，但只导出其中一个，以隐藏另一个成员：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can re-export declarations if your module extends other modules. Here `validators.ts`
    contains a module, wraps other validator modules, and combines all their exports
    in one place:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的模块扩展其他模块，可以重新导出声明。这里的`validators.ts`包含一个模块，包装其他验证器模块，并将它们的所有导出组合在一个地方：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we can import validator modules using one of the import forms. Here is
    a single export from a module:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用一种导入形式导入验证器模块。这是一个模块的单个导出：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To prevent a naming conflict we can rename an imported declaration:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止命名冲突，我们可以重命名导入的声明：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we can import an entire module into a single variable, and use it
    to access module exports:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将整个模块导入到单个变量中，并使用它来访问模块导出：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Generics
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: 'The authors of TypeScript put maximal effort into helping us to write reusable
    code. One of the tools that helps us to create code that can work with a variety
    of types rather than a single one is **generics** . The benefits of generics include:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的作者们竭尽全力帮助我们编写可重用的代码。其中一个帮助我们创建可以与各种类型一起工作而不是单一类型的代码的工具是**泛型**。泛型的好处包括：
- en: Allows you to write code/use methods which are type-safe. An `Array<string>`
    is guaranteed to be an array of strings.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许您编写代码/使用方法，这些方法是类型安全的。`Array<string>`保证是一个字符串数组。
- en: The compiler can perform a compile-time check on code for type safety. Any attempt
    to assign the `number` into an array of strings causes an error.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器可以对代码进行编译时检查，以确保类型安全。任何尝试将`number`分配到字符串数组中都会导致错误。
- en: Faster than using `any` type to avoid casting into a required reference type.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比使用`any`类型更快，以避免转换为所需的引用类型。
- en: Allows you to write code which is applicable to many types with the same underlying
    behavior.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许您编写适用于许多具有相同基本行为的类型的代码。
- en: 'Here is the class I have created to show you how useful generics can be:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我创建的类，向您展示泛型有多么有用：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This class keeps the single value of a particular type. To set or return it
    we can use corresponding getter and setter methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类保留特定类型的单个值。我们可以使用相应的getter和setter方法来设置或返回它：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: What are promises?
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是promises？
- en: A promise represents the final result of an asynchronous operation. There are
    a number of libraries that support the use of promises in TypeScript. But before
    starting to talk about this, let's talk a bit about the browser environment which
    executes your JavaScript code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺代表异步操作的最终结果。有许多支持在TypeScript中使用承诺的库。但在开始讨论这个之前，让我们先谈一下执行JavaScript代码的浏览器环境。
- en: Event loop
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件循环
- en: 'Each browser tab has an event loop and uses different tasks to coordinate events,
    user interactions, running scripts, rendering, networking, and so on. It has one
    or more queues to keep an ordered list of tasks. Other processes run around the
    event loop and communicate with it by adding tasks to its queue such as:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 每个浏览器选项卡都有一个事件循环，并使用不同的任务来协调事件、用户交互、运行脚本、渲染、网络等。它有一个或多个队列来保持任务的有序列表。其他进程围绕事件循环运行，并通过向其队列添加任务与其通信，例如：
- en: The timer waits after a given period and then adds a task to the queue
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器在给定时间后等待，然后将任务添加到队列
- en: We can call a `requestAnimationFrame` function to coordinate DOM updates
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以调用`requestAnimationFrame`函数来协调DOM更新
- en: DOM elements can call event handlers
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM元素可以调用事件处理程序
- en: The browser can request the parsing of an HTML page
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器可以请求解析HTML页面
- en: JavaScript can load an external program and perform computation on it
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript可以加载外部程序并对其进行计算
- en: 'Many of the items in the list above are JavaScript code. They are usually small
    enough, but if we run any long-running computation it could block execution of
    other tasks, and as a result it freezes the user interface. To avoid blocking
    the event loop we can:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上面列表中的许多项目都是JavaScript代码。它们通常足够小，但如果运行任何长时间的计算，可能会阻塞其他任务的执行，导致用户界面冻结。为了避免阻塞事件循环，我们可以：
- en: Use the **web worker API** to execute a long-running computation in a different
    process of the browser
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**web worker API**在浏览器的不同进程中执行长时间运行的计算
- en: Do not wait for the result of a long-running computation synchronously and allow
    the task to inform us about results via events or callbacks asynchronously
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同步等待长时间运行的计算结果，并允许任务通过事件或回调异步通知我们结果
- en: Asynchronous results via events
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过事件实现的异步结果
- en: 'The following code uses an event-driven approach to convince us and adds event
    listeners to execute small code snippets inside:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用基于事件的方法来说服我们，并添加事件侦听器以执行内部的小代码片段：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The method `send` in the last line of code just adds another task to the queue.
    This approach is useful if you receive results multiple times, but this code is
    quite verbose for a single result.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一行中的`send`方法只是向队列添加另一个任务。如果您多次接收结果，则此方法很有用，但对于单个结果来说，此代码相当冗长。
- en: Asynchronous results via callbacks
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过回调实现的异步结果
- en: 'To manage asynchronous results via callbacks, we need to pass a callback function
    as a parameter into asynchronous function calls:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过回调管理异步结果，我们需要将回调函数作为参数传递给异步函数调用：
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This approach is very easy to understand, but it has its disadvantages:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常容易理解，但它也有其缺点：
- en: It mixes up input and output parameters
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混淆输入和输出参数
- en: It is complicated to handle errors especially in the code combined many callbacks
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是在代码中组合了许多回调时，处理错误会变得复杂
- en: It is more complicated to return result from combined asynchronous functions
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从组合的异步函数返回结果更加复杂
- en: Asynchronous results via promises
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过承诺实现的异步结果
- en: 'As I mentioned earlier, the promise represents the final result of an asynchronous
    operation happening in the future. Promises have the following advantages:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，承诺代表将来发生的异步操作的最终结果。承诺具有以下优点：
- en: You write cleaner code without callback parameters
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以编写更干净的代码，而无需回调参数
- en: You do not adapt the code of the underlying architecture for delivery results
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不需要调整底层架构的代码以交付结果
- en: Your code handles errors with ease
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的代码可以轻松处理错误
- en: 'A promise may be in one of the following states:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺可能处于以下状态之一：
- en: '**Pending state** : The asynchronous operation hasn''t completed yet'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**待定状态**：异步操作尚未完成'
- en: '**Resolved state** : The asynchronous operation has completed and the promise
    has a value'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已解决状态**：异步操作已完成，承诺具有值'
- en: '**Rejected state** : The asynchronous operation failed and the promise has
    a reason which indicates why it failed'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rejected state**：异步操作失败，承诺有一个原因，指示失败的原因'
- en: The promise becomes immutable after resolving or rejecting.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺在解析或拒绝后变为不可变。
- en: 'Usually, you write the code to return the promise from functions or methods:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您编写代码从函数或方法返回承诺：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We use the `new` keyword with a function constructor to create the promise.
    We add a factory function with two parameters into the constructor, which does
    the actual work. Both parameters are callback functions. Once the operation has
    successfully completed the factory function calls the first callback with the
    result. If the operation fails it calls the second function with the reason.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `new` 关键字与函数构造函数一起创建承诺。我们在构造函数中添加一个具有两个参数的工厂函数，该函数执行实际工作。两个参数都是回调函数。一旦操作成功完成，工厂函数将使用结果调用第一个回调。如果操作失败，它将使用原因调用第二个函数。
- en: 'The returned promise has several methods such as `.then` and `.catch` to inform
    us of the result of the execution so that we can act accordingly:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的承诺有几种方法，如 `.then` 和 `.catch`，以通知我们执行的结果，以便我们可以相应地采取行动：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can call another operation returns promise to quickly transform the result
    of original one:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用另一个操作返回的承诺，快速转换原始操作的结果：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Angular 2 concepts
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2 概念
- en: The **Angular 2** is a development platform for building web, mobile, and desktop
    applications. It is based on web standards to make web development simpler and
    more efficient, and entirely different from the Angular JS 1.x. The architecture
    of Angular 2 builds on top of the web component standard so that we can define
    custom HTML selectors and program behavior for them. The Angular team develops
    Angular 2 to use in the ECMAScript 2015, TypeScript, and Dart languages.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular 2** 是一个用于构建 Web、移动和桌面应用程序的开发平台。它基于 Web 标准，使 Web 开发更简单、更高效，与 Angular
    JS 1.x 完全不同。Angular 2 的架构建立在 Web 组件标准之上，以便我们可以为其定义自定义 HTML 选择器和程序行为。Angular 团队开发
    Angular 2 以在 ECMAScript 2015、TypeScript 和 Dart 语言中使用。'
- en: Building blocks of Angular 2
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2 的构建块
- en: 'Any web application built on Angular 2 consist of:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 任何构建在 Angular 2 上的 Web 应用程序包括：
- en: HTML templates with Angular-specific markup
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有 Angular 特定标记的 HTML 模板
- en: Directives and components managing the HTML templates
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令和组件管理 HTML 模板
- en: Services containing application logic
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含应用程序逻辑的服务
- en: Special `bootstrap` function which helps to load and start the Angular application
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊的 `bootstrap` 函数帮助加载和启动 Angular 应用程序
- en: Module
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: 'The Angular 2 application is an assembly of many modules. Angular 2 itself
    is a set of modules with names beginning with the `@angular` prefix, combined
    into libraries:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 应用程序是许多模块的组合。Angular 2 本身是一组以 `@angular` 前缀开头的模块，组合成库：
- en: The `@angular/core` is the primary Angular 2 library and contains all core public
    APIs
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@angular/core` 是主要的 Angular 2 库，包含所有核心公共 API'
- en: The `@angular/common` is the library which restricts APIs to reusable components,
    directives, and form building
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@angular/common` 是一个限制 API 用于可重用组件、指令和表单构建的库'
- en: The `@angular/router` is the library that supports navigation
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@angular/router` 是支持导航的库'
- en: The `@angular/http` is the library that helps us work asynchronously via HTTP
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@angular/http` 是帮助我们通过 HTTP 异步工作的库'
- en: Metadata
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元数据
- en: Metadata is information we can attach to underlying definitions via TypeScript
    decorators to tell Angular how to modify them. Decorators play a significant role
    in Angular 2.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据是我们可以通过 TypeScript 装饰器附加到底层定义的信息，告诉 Angular 如何修改它们。装饰器在 Angular 2 中扮演着重要的角色。
- en: Directives
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令
- en: 'Directives are the fundamental building block of Angular 2 and allows you to
    connect behavior to an element in the DOM. There are three kinds of directive:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是Angular 2的基本构建块，允许您将行为连接到DOM中的元素。有三种类型的指令：
- en: Attribute directives
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性指令
- en: Structural directives
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构指令
- en: Components
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: A directive is a class with an assigned `@Directive` decorator.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是一个带有分配的`@Directive`装饰器的类。
- en: Attribute directives
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性指令
- en: The attribute directive usually changes the appearance or behavior of an element.
    We can change several styles, or use it to render text bold or italic by binding
    it to a property.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令通常改变元素的外观或行为。我们可以通过将其绑定到属性来改变多种样式，或者使用它将文本呈现为粗体或斜体。
- en: Structural directives
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构指令
- en: The structural directive changes the DOM layout by adding and removing other
    elements.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令通过添加和移除其他元素来改变DOM布局。
- en: Component
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: 'The component is a directive with a template. Every component is made up of
    two parts:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件是一个带有模板的指令。每个组件由两部分组成：
- en: The class, where we define the application logic
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序逻辑的类
- en: The view, which is controlled by the component and interacts with it through
    an API of properties and methods
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图，由组件控制，并通过属性和方法的API与其交互
- en: A component is a class with the assigned `@Component` decorator.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是一个带有分配的`@Component`装饰器的类。
- en: Template
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: The component uses the template to render the view. It is regular HTML with
    custom defined selectors and Angular-specific markups.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 组件使用模板来呈现视图。它是常规的HTML，具有自定义定义的选择器和特定于Angular的标记。
- en: Data binding
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定
- en: The Angular 2 supports *data binding* to update parts of the template via the
    properties or methods of a component. The *binding markup* is part of data binding;
    we use it on the template to connect both sides.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2支持*数据绑定*，以通过组件的属性或方法更新模板的部分。*绑定标记*是数据绑定的一部分；我们在模板上使用它来连接两侧。
- en: Service
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: Angular 2 has no definition of a service. Any value, function, or feature can
    be a service, but usually it is a class created for a distinct purpose with an
    assigned `@Injectable` decorator.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2没有对服务的定义。任何值、函数或特性都可以是服务，但通常它是一个为特定目的创建的类，并带有分配的`@Injectable`装饰器。
- en: Dependency injection
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Dependency injection is a design pattern that helps configure objects by an
    external entity and resolve dependencies between them. All elements in the loosely
    coupled system know little or nothing about definitions of each other. We can
    replace almost any element with alternative implementation without breaking the
    whole system.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种设计模式，它帮助通过外部实体配置对象并解决它们之间的依赖关系。松散耦合系统中的所有元素对彼此的定义知之甚少或根本不知道。我们几乎可以用替代实现替换任何元素，而不会破坏整个系统。
- en: SystemJS loader and JSPM package manager
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SystemJS加载器和JSPM包管理器
- en: We have discussed TypeScript modules, so it's time to talk about tools we can
    use for loading modules in our scripts.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了TypeScript模块，现在是时候谈谈我们可以用来加载脚本中的模块的工具了。
- en: SystemJS Loader
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SystemJS加载器
- en: '**SystemJS** is a universal dynamic module loader. It hosts the source code
    on GitHub at the following address [https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs)
    . It can load modules in the web browser and Node.js in the following formats:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**SystemJS**是一个通用的动态模块加载器。它在GitHub上托管源代码，地址为[https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs)。它可以以以下格式在Web浏览器和Node.js中加载模块：'
- en: ECMAScript 2015 (ES6) or TypeScript
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 2015（ES6）或TypeScript
- en: AMD
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMD
- en: CommonJS
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS
- en: Global scripts
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局脚本
- en: SystemJS loads modules with an exact circle reference, binding support, and
    assets through the module naming system such as CSS, JSON, or images. Developers
    can easily extend the functionality of the loader via plugins.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: SystemJS通过模块命名系统加载具有精确循环引用、绑定支持和资产的模块，如CSS、JSON或图像。开发人员可以通过插件轻松扩展加载器的功能。
- en: 'We can add SystemJS loader to our future project:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将SystemJS加载器添加到我们未来的项目中：
- en: Via direct link to a  **Content Delivery Network** ( **CDN** )
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过直接链接到**内容传送网络**（**CDN**）
- en: By installing via npm manager
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过npm管理器安装
- en: 'In both scenarios, we include a reference to the SystemJS library in our code
    and configure it via the `config` method:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们在代码中包含对SystemJS库的引用，并通过`config`方法进行配置：
- en: '[PRE56]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We will speak about installation via npm manager a bit later in this chapter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章稍后讨论通过npm管理器进行安装。
- en: JSPM package manager
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSPM包管理器
- en: 'The developers of the SystemJS followed the single-responsibility principle
    and implemented a loader for doing only one thing: loading the modules. To make
    modules available in your project, we need to use the package manager. We spoke
    about the npm package manager at the beginning, so now we will talk about the
    JSPM package manager sitting on top of SystemJS. It can:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: SystemJS的开发人员遵循单一职责原则，并实现了一个仅执行一项任务的加载器。为了使模块在项目中可用，我们需要使用包管理器。我们在开头谈到了npm包管理器，现在我们将谈论坐落在SystemJS之上的JSPM包管理器。它可以：
- en: Download modules from any registry such as npm and GitHub
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从任何注册表（如npm和GitHub）下载模块
- en: Compile modules into simple, layered, and self-executing bundles with a single
    command
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个命令将模块编译成简单、分层和自执行的捆绑包
- en: The JSPM package manager looks like an npm package manager, but it puts the
    browser loader first. It helps you organize a seamless workflow for installing
    and using libraries in the browser with minimum effort.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: JSPM包管理器看起来像npm包管理器，但它将浏览器加载器放在首位。它可以帮助您组织无缝的工作流程，以便在浏览器中轻松安装和使用库。
- en: Writing your first application
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个应用程序
- en: 'Now, when we have everything in place, it''s time to create our first project,
    which is actually an npm module. Open Terminal and create the folder `hello-world`
    . I intentionally follow the npm package naming conventions:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当一切就绪时，是时候创建我们的第一个项目了，实际上它是一个npm模块。打开终端并创建名为`hello-world`的文件夹。我特意遵循npm包命名约定：
- en: The package name length should be greater than zero and cannot exceed 214
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名长度应大于零且不得超过214
- en: All the characters in the package name must be lowercase
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名中的所有字符必须为小写
- en: The package name can consist of/include hyphens
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名可以包含/包括连字符
- en: The package name must contain any URL-safe characters (since the name ends up
    being part of a URL)
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名必须包含任何URL安全字符（因为名称最终成为URL的一部分）
- en: The package name should not start with dot or underscore letters
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名不应以点或下划线字母开头
- en: The package name should not contain any leading or trailing spaces
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名不应包含任何前导或尾随空格
- en: The package name cannot be the same as a `node.js/io.js` core module or a reserved/blacklisted
    name like `http` , stream, `node_modules` , and so on.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名不能与`node.js/io.js`核心模块或保留/黑名单名称相同，如`http`、stream、`node_modules`等。
- en: 'Move the folder in and run the command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件夹移入并运行命令：
- en: '[PRE57]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'npm will ask you several questions to create a `package.json` file. This file
    keeps important information about your package in JSON format:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: npm将询问您几个问题以创建`package.json`文件。该文件以JSON格式保存有关您的包的重要信息：
- en: Project information like name, version, author, and license
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目信息如名称、版本、作者和许可证
- en: Set of packages the project depends on
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目依赖的一组包
- en: Set of pre-configured commands to build and test the project
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组预配置的用于构建和测试项目的命令
- en: 'Here is how `package.js` could look:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.js`可能如下所示：'
- en: '[PRE58]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We are ready to configure our project.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好配置我们的项目了。
- en: TypeScript compile configuration
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 编译配置
- en: 'Run the Visual Studio code and open the project folder. We need to create a configuration
    file which guides the TypeScript compiler on where to find the source folder and
    required libraries and how to compile the project. From the **File** menu create
    `tsconfig.json` file, and copy/paste the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Visual Studio 代码并打开项目文件夹。我们需要创建一个配置文件，指导 TypeScript 编译器在哪里找到源文件夹和所需的库，以及如何编译项目。从
    **文件** 菜单创建 `tsconfig.json` 文件，并复制/粘贴以下内容：
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s look closer at the `compilerOptions` :'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下 `compilerOptions`：
- en: The `target` option specifies the ECMAScript version such `es3` , `es5` , or
    `es6` .
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target` 选项指定 ECMAScript 版本，例如 `es3`，`es5` 或 `es6`。'
- en: 'The `module` option specifies the module code generator from one of these:
    `none` , `commojs` , `amd` , `system` , `umd` , `es6` , or `es2015` .'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module` 选项指定模块代码生成器，可以是以下之一：`none`，`commojs`，`amd`，`system`，`umd`，`es6` 或
    `es2015`。'
- en: The `moduleResolution` option determines how modules get resolved. Use `node`
    for `Node.js/io.js` style resolution or `classic` .
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moduleResolution` 选项确定模块的解析方式。使用 `node` 来进行 `Node.js/io.js` 风格的解析，或者使用 `classic`。'
- en: The `sourceMap` flag tells the compiler to generate a corresponding `map` file.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sourceMap` 标志告诉编译器生成相应的 `map` 文件。'
- en: The `emitDecoratorMetadata` emits the design-type metadata for decorated declarations
    in source.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emitDecoratorMetadata` 会为源中装饰的声明发出设计类型元数据。'
- en: The `experimentalDecorator` enables experimental support for ES7 decorators
    such iterators, generators and array comprehensions.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`experimentalDecorator` 启用对 ES7 装饰器的实验性支持，比如迭代器、生成器和数组推导。'
- en: The `removeComments` removes all comments except copyright header comments beginning
    with `/*!` .
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeComments` 会移除除版权头注释以外的所有注释，这些注释以 `/*!` 开头。'
- en: The `noImplicitAny` raises an error on expressions and declarations with an
    implied `any` type.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noImplicitAny` 会在具有隐含的 `any` 类型的表达式和声明上引发错误。'
- en: 'You can find the full list of compiler options here: [https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)
    .'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到编译器选项的完整列表：[https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)。
- en: 'The TypeScript compiler needs type definition files of JavaScript libraries
    from `node_modules` of our project because it doesn''t recognize them natively.
    We help it with `typings.json` file. You should create the file and copy/paste
    the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器需要 JavaScript 库的类型定义文件，这些文件位于我们项目的 `node_modules` 中，因为它无法本地识别它们。我们可以通过
    `typings.json` 文件来帮助它。您应该创建该文件并复制/粘贴以下内容：
- en: '[PRE60]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We should provide enough information to typings tool to get any typings file:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该提供足够的信息给 typings 工具来获取任何 typings 文件：
- en: The registry dt is located in the DefinitelyTyped source. This value could be
    npm, git
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dt 注册表位于 DefinitelyTyped 源中。这个值可以是 npm，git
- en: The package name in `DefinitelyTyped` source is the `es6-shim`
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefinitelyTyped` 源中的包名是 `es6-shim`。'
- en: We are looking for the version `0.31.2` updated `2016.03.17 12:06:54`
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在寻找更新于 `2016.03.17 12:06:54` 的版本 `0.31.2`。
- en: Task automation and dependency resolution
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务自动化和依赖项解析
- en: 'Now, it''s time to add the libraries into the `package.json` file that the
    application requires. Please update it accordingly:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将应用程序所需的库添加到 `package.json` 文件中了。请相应地更新它：
- en: '[PRE61]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Our configuration includes `scripts` to handle common development tasks such:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配置包括 `scripts` 来处理常见的开发任务，比如：
- en: The `postinstall` script runs after the package is installed
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postinstall` 脚本在包安装后运行'
- en: The `start` script runs by the npm `start` command
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start` 脚本由 npm 的 `start` 命令运行'
- en: The arbitrary scripts `lite` , `tsc` , `tsc:w` , and `typings` are executed
    by the `npm run <script>` .
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意脚本 `lite`，`tsc`，`tsc:w` 和 `typings` 都可以通过 `npm run <script>` 来执行。
- en: 'You can find more documentation on the following web page: [https://docs.npmjs.com/misc/scripts](https://docs.npmjs.com/misc/scripts)
    .'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网页上找到更多文档：[https://docs.npmjs.com/misc/scripts](https://docs.npmjs.com/misc/scripts)。
- en: 'After finishing the configuration let''s run `npm` manager to install the packages
    required. Go back to Terminal and enter the following command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 完成配置后，让我们运行 `npm` 管理器来安装所需的软件包。返回到终端并输入以下命令：
- en: '[PRE62]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'During installation, you may see warning messages in red starting with:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，您可能会看到以红色开始的警告消息：
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You should ignore them if the installation finishes successfully. After installation,
    the npm executes the `postinstall` script to run `typings` installation.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装成功完成，您应该忽略它们。安装完成后，npm 执行 `postinstall` 脚本来运行 `typings` 安装。
- en: Creating and bootstrapping an Angular component
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和引导 Angular 组件
- en: 'The Angular 2 application must always have a top-level component, where all
    other components and logic lie. Let''s create it. Go to the Visual Studio code
    and create a sub-folder `app` of the root directory where we will keep the source
    code. Create the file `app.component.ts` under `app` folder, and copy/paste the
    following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 应用程序必须始终具有顶层组件，其中包含所有其他组件和逻辑。让我们创建它。转到 Visual Studio 代码并在根目录下创建一个名为
    `app` 的子文件夹，我们将在其中保存源代码。在 `app` 文件夹下创建文件 `app.component.ts`，并复制/粘贴以下内容：
- en: '[PRE64]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As you can see, we have added metadata via `@Component` decorator to the class
    `AppComponent` . This decorator tells Angular how to process the class via configuration
    with the following options:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们通过 `@Component` 装饰器向 `AppComponent` 类添加了元数据。此装饰器告诉 Angular 如何通过以下选项的配置来处理该类：
- en: The `selector` defines the name of an HTML tag which our component will link
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector` 定义了我们的组件将链接的 HTML 标签的名称'
- en: We pass in any service in the `providers` property. Any service registered here
    becomes available to this component and its children
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 `providers` 属性中传递任何服务。在此注册的任何服务都将对该组件及其子组件可用
- en: We give away any number of style files to `styles` a particular component
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将任意数量的样式文件赋予 `styles` 特定组件
- en: The `template` property will hold the template of the component
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template` 属性将保存组件的模板'
- en: The template `url` is a URL to an external file containing a template for the
    view
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template url` 是指向包含视图模板的外部文件的 URL'
- en: We need to `export` the class `AppComponent` to make it visible from other modules
    and Angular can instantiate it.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导出 `AppComponent` 类，以使其从其他模块可见，并且 Angular 可以实例化它。
- en: 'The Angular application is a composition of multiple modules marked with `NgModule`
    decorator. Any application must have at least one root module, so let''s create
    `AppModule` in the `app.module.ts` file:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序是由多个使用 `NgModule` 装饰器标记的模块组成。任何应用程序必须至少有一个根模块，因此让我们在 `app.module.ts`
    文件中创建 `AppModule`：
- en: '[PRE65]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The WebBrowser is a collection of modules and providers specific for web browsers
    such as document DomRootRenderer, and so on. We import WebBrowser into the application
    module to make all of those providers and modules available in our application,
    thereby reducing the amount of boilerplate code-writing required. Angular contains
    the `ServerModule` : a similar module for the server side.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: WebBrowser 是专为 Web 浏览器而设计的模块和提供程序的集合，例如 document DomRootRenderer 等。我们将 WebBrowser
    导入应用程序模块，以使所有这些提供程序和模块在我们的应用程序中可用，从而减少所需的样板代码编写量。Angular 包含 `ServerModule`：用于服务器端的类似模块。
- en: 'Now we need to start up our application. Let''s create `main.ts` file under
    `app` folder, and copy/paste the following:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要启动我们的应用程序。在 `app` 文件夹下创建 `main.ts` 文件，并复制/粘贴以下内容：
- en: '[PRE66]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Last but not least, we rely on the `bootstrap` function to load top-level components.
    We import it from `''@angular/platform-browser-dynamic''` . Angular has a different
    kind of `bootstrap` function for:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们依赖于`bootstrap`函数来加载顶层组件。我们从`'@angular/platform-browser-dynamic'`中导入它。Angular有一种不同类型的`bootstrap`函数：
- en: Web workers
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web工作者
- en: Development on mobile devices
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动设备上进行开发
- en: Rendering the first page of an application on a server
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上渲染应用程序的第一页
- en: 'Angular does several tasks after instantiation of any component:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在实例化任何组件后执行几项任务：
- en: It creates a shadow DOM for it
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为其创建了一个影子DOM
- en: It loads the selected template into the shadow DOM
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将选定的模板加载到影子DOM中
- en: It creates all the injectable objects configured with `'providers'` and `'viewProviders'`
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了所有配置了'providers'和'viewProviders'的可注入对象
- en: In the end, Angular 2 evaluates all template expressions and statements against
    the component instance.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Angular 2会对所有模板表达式和语句进行评估，与组件实例进行比较。
- en: 'Now, create `index.html` file in Microsoft Visual Studio code under the root
    folder with the following content:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Microsoft Visual Studio代码中在根文件夹下创建`index.html`文件，并包含以下内容：
- en: '[PRE67]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Because we are referencing the `systemjs.config.js` file, let''s create it
    in the root folder with the code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在引用`systemjs.config.js`文件，让我们在根文件夹中创建它，其中包含以下代码：
- en: '[PRE68]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Compiling and running
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译和运行
- en: 'We are ready to run our first application. Go back to Terminal and type:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好运行我们的第一个应用程序。返回终端并键入：
- en: '[PRE69]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This script runs two parallel Node.js processes:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本运行两个并行的Node.js进程：
- en: The TypeScript compiler in watch mode
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript编译器处于监视模式
- en: The static `lite-server` loads `index.html` and refreshes the browser when the
    application file changes
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态的`lite-server`加载`index.html`并在应用程序文件更改时刷新浏览器
- en: 'In your browser you should see the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中，您应该看到以下内容：
- en: '![Compiling and running](Image00002.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![编译和运行](Image00002.jpg)'
- en: Tip
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code in the `chapter_1/1.hello-world`  folder.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter_1/1.hello-world`文件夹中找到源代码。
- en: Adding user input
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加用户输入
- en: 'We now need to include our text input and also, specify the model we want to
    use. When a user types in the text input, our application shows the changed value
    in the title. Also, we should import the `FormsModule` into the `AppModule` :'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要包含我们的文本输入，并指定我们想要使用的模型。当用户在文本输入中键入时，我们的应用程序会在标题中显示更改后的值。此外，我们应该将`FormsModule`导入到`AppModule`中：
- en: '[PRE70]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here is the updated version of `app.component.ts` :'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`app.component.ts`的更新版本：
- en: '[PRE71]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `ngModel` attribute declares a model binding on that element, and anything
    we type into the input box will be automatically bound to it by Angular. Obviously,
    this isn''t going to be displayed on our page by magic; we need to tell the framework
    where we want it echoed. To show our model on the page, we just need to wrap the
    name of it in double curly braces:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`属性在该元素上声明了一个模型绑定，我们在输入框中输入的任何内容都将被Angular自动绑定到它。显然，这不会通过魔术显示在我们的页面上；我们需要告诉框架我们想要在哪里回显它。要在页面上显示我们的模型，我们只需要用双大括号包裹它的名称：'
- en: '[PRE72]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'I popped this in place of World in our `<h1>` tag and refreshed the page in
    my browser. If you pop your name in the input field, you''ll notice that it''s
    automatically displayed in your heading in real time. Angular does all of this
    for us, and we haven''t written a single line of code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其放在了我们的`<h1>`标签中的World位置，并在浏览器中刷新了页面。如果您在输入框中输入您的姓名，您会注意到它会实时自动显示在您的标题中。Angular为我们完成了所有这些工作，而我们没有写一行代码：
- en: '![Adding user input](Image00003.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![添加用户输入](Image00003.jpg)'
- en: 'Now, while that''s great, it would be nice if we could have a default in place
    so it doesn''t look broken before a user has entered their name. What''s awesome
    is that everything in between those curly braces is parsed as an Angular expression,
    so we can check and see if the model has a value, and if not, it can echo `''World''`
    . Angular calls this an expression and it''s just a case of adding two pipe symbols
    as we would in TypeScript:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然这很棒，但如果我们可以有一个默认值，这样在用户输入他们的名字之前就不会看起来不完整，那就更好了。令人惊奇的是，花括号之间的所有内容都被解析为Angular表达式，因此我们可以检查并查看模型是否有值，如果没有，它可以回显`'World'`。Angular将其称为表达式，只需添加两个管道符号，就像在TypeScript中一样：
- en: '[PRE73]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It's good to remember that this is TypeScript, and that's why we need to include
    the quotation marks here, to let it know that this is a string and not the name
    of a model. Remove them and you'll notice that Angular displays nothing again.
    That's because both the name and `World` models are undefined.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这是TypeScript，这就是为什么我们需要在这里包含引号，让它知道这是一个字符串，而不是模型的名称。删除它们，您会注意到Angular再次显示为空。这是因为名称和`World`模型都未定义。
- en: Tip
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code into the `chapter_1/2.hello-input` . folder.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter_1/2.hello-input`文件夹中找到源代码。
- en: Integrating Bootstrap 4
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Bootstrap 4
- en: 'Now that we''ve created our `Hello World` application, and everything is working
    as expected, it''s time to get involved with Bootstrap and add a bit of style
    and structure to our app. At the time of writing this book Bootstrap 4 was in
    alpha version, so bear in mind that the code and markup of your application might
    be slightly different. We need to add the Bootstrap 4 style sheet into the `index.html`
    file:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的“Hello World”应用程序，并且一切都按预期工作，是时候参与Bootstrap并为我们的应用程序添加一些样式和结构了。在撰写本书时，Bootstrap
    4处于alpha版本，因此请记住您的应用程序的代码和标记可能略有不同。我们需要将Bootstrap 4样式表添加到`index.html`文件中：
- en: '[PRE74]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The application is currently misaligned to the left, and everything is looking
    cramped, so let''s sort that out first with a bit of scaffolding. Bootstrap comes
    with a great *mobile first* responsive grid system that we can utilize with the
    inclusion of a few `div` elements and classes. First, though, let''s get a container
    around our content to clean it up immediately:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序目前左对齐，一切看起来很拥挤，所以让我们首先用一些脚手架解决这个问题。Bootstrap带有一个很棒的*移动优先*响应式网格系统，我们可以利用它来包含一些`div`元素和类。不过，首先让我们在内容周围获取一个容器，以立即清理它：
- en: Note
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mobile first is a way of designing/developing for the smallest screens first
    and adding to the design rather than taking elements away.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 移动优先是一种首先为最小屏幕设计/开发并添加设计元素而不是减少元素的方法。
- en: '[PRE75]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If you resize your browser window, you should start to notice some of the responsiveness
    of the framework coming through and see it collapsing:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您调整浏览器窗口大小，您应该开始注意到框架的一些响应性，并看到它的折叠：
- en: '![Integrating Bootstrap 4](Image00004.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![集成Bootstrap 4](Image00004.jpg)'
- en: 'Now, I think it''s a good idea to wrap this in what Bootstrap calls a Jumbotron
    (in previous versions of Bootstrap this was a hero unit). It''ll make our headline
    stand out a lot more. We can do this by wrapping our `H1` and `input` tags in
    a new `div` with the `jumbotron` class:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我认为将其包装在Bootstrap称为Jumbotron的东西中是个好主意（在以前的Bootstrap版本中，这被称为hero unit）。这将使我们的标题更加突出。我们可以通过将我们的`H1`和`input`标签包装在一个带有`jumbotron`类的新`div`中来实现这一点：
- en: '[PRE76]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '![Integrating Bootstrap 4](Image00005.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![集成Bootstrap 4](Image00005.jpg)'
- en: It's starting to look a lot better, but I'm not too happy about our content
    touching the top of the browser like that. We can make it look a lot nicer with
    a page header, but that input field still looks out of place to me.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 它开始看起来好多了，但我对我们的内容触及浏览器顶部并不太满意。我们可以通过一个页面标题让它看起来更好，但是那个输入框对我来说看起来还是不合适。
- en: 'First, let''s sort out that page header:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们整理一下页面标题：
- en: '[PRE77]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![Integrating Bootstrap 4](Image00006.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![集成Bootstrap 4](Image00006.jpg)'
- en: I've included the chapter number and title here. The `<small>` tag within our
    `<h2>` tag gives us a nice differentiation between the chapter number and the
    title. The page-header class itself just gives us some additional margin and padding
    as well as a subtle border along the bottom.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里包含了章节编号和标题。在我们的`<h2>`标签中的`<small>`标签给我们的章节编号和标题之间提供了一个很好的区分。page-header类本身只是给我们一些额外的边距和填充，以及底部的细微边框。
- en: 'The utmost thing I think we could improve upon is that input box. Bootstrap
    comes with some cool input styles so let''s include those. First, we need to add
    the class of form-control to the text input. This will set the width to 100% and
    also bring out some beautiful styling such as rounded corners and glowing when
    we focus on the element:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们最需要改进的是输入框。Bootstrap带有一些很酷的输入样式，所以让我们包含进去。首先，我们需要在文本输入中添加form-control类。这将把宽度设置为100%，并且在我们聚焦在元素上时，还会带出一些漂亮的样式，比如圆角和发光。
- en: '[PRE78]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '![Integrating Bootstrap 4](Image00007.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![集成Bootstrap 4](Image00007.jpg)'
- en: 'Much better, but to me it looks a little small when you compare it with the
    heading. Bootstrap provides two additional classes we can include that will either
    make the element smaller or larger: `form-control-lg` and `form-control-sm` respectively.
    In our case, the `form-control-lg` class is the one we want, so go ahead and add
    that to the input.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了，但是对我来说，与标题相比，它看起来有点小。Bootstrap提供了两个额外的类，我们可以包含其中一个，要么使元素更小，要么更大：`form-control-lg`和`form-control-sm`。在我们的情况下，我们想要的是`form-control-lg`类，所以继续添加到输入框中。
- en: '[PRE79]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![Integrating Bootstrap 4](Image00008.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![集成Bootstrap 4](Image00008.jpg)'
- en: Tip
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code in the `chapter_1/3.hello-bootstrap` .
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`chapter_1/3.hello-bootstrap`中找到源代码。
- en: 读累了记得休息一会哦~
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Summary
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Our app's looking great and working exactly how it should, so let's recap what
    we've learnt in the first chapter.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序看起来很棒，而且正好按照预期工作，所以让我们回顾一下我们在第一章学到的东西。
- en: To begin with, we saw just how to setup a working environment and finish the
    TypeScript crash course.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到了如何设置工作环境并完成TypeScript速成课程。
- en: 'The `Hello World` app we''ve created, while being very basic, demonstrates
    some of Angular''s core features:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`Hello World`应用程序虽然非常基础，但演示了一些Angular的核心功能：
- en: Component directives
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件指令
- en: Application bootstrapping
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序引导
- en: Two-way data binding
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向数据绑定
- en: All of this was possible without writing a single line of TypeScript, as the
    component we created was just to demonstrate two-way data binding.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是可能的，而不需要写一行TypeScript，因为我们创建的组件只是为了演示双向数据绑定。
- en: With Bootstrap, we utilized a few of the many available components such as the
    Jumbotron and the page-header classes to give our application some style and substance.
    We also saw the framework's new mobile first responsive design in action without
    cluttering up our markup with unnecessary classes or elements.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bootstrap，我们利用了许多可用的组件，比如Jumbotron和page-header类，为我们的应用程序增添了一些样式和内容。我们还看到了框架的新的移动优先响应式设计，而不会用不必要的类或元素来混乱我们的标记。
- en: In [Chapter 2](text00023.html#page "Chapter 2. Working with Bootstrap Components")
    , *Working with Bootstrap Components* , we're going to explore more Bootstrap
    fundamentals and introduce the project we're going to be building over the course
    of this book.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](text00023.html#page "第2章. 使用Bootstrap组件")中，*使用Bootstrap组件*，我们将探索更多Bootstrap基础知识，并介绍本书将要构建的项目。
