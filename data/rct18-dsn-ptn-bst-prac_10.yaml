- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: React 18 New Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 18 新特性
- en: React 18, the latest version of the popular JavaScript library for building
    user interfaces, introduces a host of new features and enhancements that aim to
    improve performance and enhance the developer experience. As a part of the ever-evolving
    React ecosystem, it is crucial to stay up to date with these advancements. In
    this chapter, we will provide a succinct overview of the most notable additions
    in React 18, followed by a brief explanation of the latest features in Node.js
    19.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: React 18，作为流行的 JavaScript 库的最新版本，引入了许多新特性和改进，旨在提高性能并增强开发者体验。作为不断发展的 React 生态系统的一部分，了解这些进步至关重要。在本章中，我们将简要概述
    React 18 中最显著的新增功能，随后简要介绍 Node.js 19 的最新功能。
- en: 'The new features in React 18 include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: React 18 的新特性包括：
- en: '**Automatic Batching of State Updates**: React 18 automatically batches multiple
    state updates into a single update, which results in improved performance and
    smoother animations. This automatic batching eliminates the need for manual batching.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态更新的自动批处理**：React 18 自动将多个状态更新批处理为单个更新，从而提高了性能和更平滑的动画。这种自动批处理消除了手动批处理的需求。'
- en: '**Concurrent Rendering**: This feature enables React to prioritize the rendering
    of certain components, leading to faster load times, smoother animations, and
    better user experiences.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发渲染**：此功能允许 React 优先渲染某些组件，从而实现更快的加载时间、更平滑的动画和更好的用户体验。'
- en: '**Suspense for Data Fetching**: Suspense enables developers to suspend the
    rendering of a component until the required data is loaded, providing a seamless
    user experience and improved error handling.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据获取的 Suspense**：Suspense 允许开发者挂起组件的渲染，直到所需数据加载完成，从而提供无缝的用户体验和改进的错误处理。'
- en: '**Improved Error Handling**: React 18 simplifies error handling by offering
    more information about errors such as the component and code location where the
    error occurred, streamlining the debugging process.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的错误处理**：React 18 通过提供更多关于错误的信息，如错误发生的组件和代码位置，简化了错误处理，从而简化了调试过程。'
- en: '**New Component Types**: React 18 introduces two new component types – portals
    and components with side effects. Portals enable rendering components outside
    of their parent components, while components with side effects allow performing
    side effects without a separate function.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新的组件类型**：React 18 引入了两种新的组件类型—— portals 和具有副作用组件。Portals 允许在父组件之外渲染组件，而具有副作用组件允许在不使用单独函数的情况下执行副作用。'
- en: '**No Support for Internet Explorer 11**: To leverage modern web standards and
    enhance performance, React 18 no longer supports Internet Explorer 11\. Developers
    must ensure their users employ a modern, supported browser like Google Chrome,
    Mozilla Firefox, Apple Safari, or Microsoft Edge.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不支持 Internet Explorer 11**：为了利用现代网络标准并提高性能，React 18 不再支持 Internet Explorer
    11。开发者必须确保他们的用户使用现代、受支持的浏览器，如 Google Chrome、Mozilla Firefox、Apple Safari 或 Microsoft
    Edge。'
- en: 'We’re going to cover the following main topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主要主题：
- en: Concurrent mode
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发模式
- en: Automatic batching
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动批处理
- en: Suspense on the server
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端的 Suspense
- en: New APIs
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 API
- en: New hooks
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 Hook
- en: Strict mode
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格模式
- en: Node.js latest features
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 最新特性
- en: Concurrent mode
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发模式
- en: React **concurrent mode** is a set of new features in React 18 that enable faster
    and more responsive user interfaces by allowing React to work on multiple tasks
    simultaneously.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: React **并发模式**是 React 18 的一组新特性，通过允许 React 同时处理多个任务，从而实现更快的响应式用户界面。
- en: In traditional React, the rendering process is synchronous, which means that
    React updates the user interface in a single pass. This can sometimes lead to
    performance issues, especially when rendering large, complex applications or handling
    real-time updates.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 React 中，渲染过程是同步的，这意味着 React 在单次遍历中更新用户界面。这有时会导致性能问题，尤其是在渲染大型、复杂的应用程序或处理实时更新时。
- en: Concurrent mode allows React to split the rendering process into smaller units
    of work that can be executed independently and in parallel. This means that React
    can prioritize certain tasks, such as updating the user interface, while still
    allowing other tasks to run in the background, such as handling user input or
    fetching data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 并发模式允许 React 将渲染过程拆分为更小的独立工作单元，这些单元可以独立并行执行。这意味着 React 可以优先处理某些任务，例如更新用户界面，同时仍然允许其他任务在后台运行，例如处理用户输入或获取数据。
- en: 'Here are some of the key features of React concurrent mode:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 React 并发模式的几个关键特性：
- en: '**Time slicing**: Time slicing is a technique that allows React to break up
    large chunks of work into smaller pieces and prioritize the most important tasks
    first. This can help to reduce the perceived latency of an application and make
    it feel more responsive.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间分片**：时间分片是一种技术，允许 React 将大量工作分解成小块，并优先处理最重要的任务。这可以帮助减少应用程序的感知延迟，使其感觉更响应。'
- en: '**Suspense**: Suspense is a new feature in React that allows developers to
    suspend the rendering of a component until the necessary data has been loaded.
    This can help to improve the perceived performance of an application and provide
    a better user experience.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Suspense**：Suspense 是 React 中的一种新特性，允许开发者挂起组件的渲染，直到必要的数据被加载。这可以帮助提高应用程序的感知性能并提供更好的用户体验。'
- en: '**Concurrent rendering**: Concurrent rendering is a new rendering mode in React
    that allows React to update the user interface more frequently, resulting in smoother
    animations and transitions.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发渲染**：并发渲染是 React 中的一种新渲染模式，允许 React 更频繁地更新用户界面，从而实现更平滑的动画和过渡效果。'
- en: 'Overall, React concurrent mode is a powerful new set of features that can help
    developers create faster and more responsive user interfaces. While it may require
    some adjustments to existing code, adopting concurrent mode can help to improve
    the user experience of your applications and keep them competitive in a fast-paced
    digital landscape. Here’s an example that demonstrates the use of time slicing
    and concurrent rendering in React 18:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，React 并发模式是一组强大的新特性，可以帮助开发者创建更快、更响应式的用户界面。虽然这可能需要对现有代码进行一些调整，但采用并发模式可以帮助改善应用程序的用户体验，并在快速发展的数字领域中保持竞争力。以下是一个演示在
    React 18 中使用时间分片和并发渲染的例子：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Automatic batching
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动批处理
- en: Automatic batching is a new feature in React 18 that improves the performance
    of updates by automatically batching multiple updates into a single render pass.
    In traditional React, updates to the user interface are typically processed synchronously,
    which means that each update triggers a new render pass.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 自动批处理是 React 18 中的一个新特性，通过自动将多个更新组合成一个渲染遍历来提高更新的性能。在传统的 React 中，用户界面的更新通常是同步处理的，这意味着每次更新都会触发一个新的渲染遍历。
- en: This can be inefficient, especially when multiple updates occur in rapid succession.
    Automatic batching solves this problem by grouping multiple updates together and
    processing them in a single render pass.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能效率低下，尤其是在多个更新连续发生时。自动批处理通过将多个更新组合在一起并在单个渲染遍历中处理它们来解决这个问题。
- en: 'Here’s an example to illustrate how automatic batching works:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个说明自动批处理如何工作的例子：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we have a `MyComponent` component that uses the `useState`
    hook to manage a `count` state variable. When the user clicks the `Increment`
    button, we call the `setCount` function three times in rapid succession, each
    time incrementing the count by 1.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个名为 `MyComponent` 的组件，它使用 `useState` 钩子来管理一个 `count` 状态变量。当用户点击 `Increment`
    按钮，我们会连续三次快速调用 `setCount` 函数，每次将计数增加 1。
- en: In traditional React, each call to `setCount` would trigger a new render pass,
    resulting in three separate updates to the user interface. However, with automatic
    batching in React 18, these updates are automatically grouped together and processed
    in a single render pass. This can result in significant performance improvements,
    especially when handling user input or real-time updates.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 React 中，每次调用 `setCount` 都会触发一个新的渲染遍历，导致用户界面有三个单独的更新。然而，在 React 18 的自动批处理中，这些更新会自动组合在一起并在单个渲染遍历中处理。这可以实现显著的性能提升，尤其是在处理用户输入或实时更新时。
- en: Overall, automatic batching is a powerful new feature in React 18 that can help
    to improve the performance and responsiveness of your applications. By automatically
    batching multiple updates together, React can optimize the rendering process and
    reduce unnecessary render passes, resulting in faster and more efficient updates
    to the user interface.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，自动批处理是 React 18 中的一个强大新特性，可以帮助提高应用程序的性能和响应速度。通过自动将多个更新组合在一起，React 可以优化渲染过程并减少不必要的渲染遍历，从而实现更快、更高效的界面更新。
- en: Transitions
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过渡效果
- en: React 18 introduces a new feature called **transitions** that allows developers
    to create smooth, declarative animations and transitions in their applications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: React 18 引入了一个名为 **transitions** 的新特性，允许开发者在其应用程序中创建平滑、声明式的动画和过渡效果。
- en: Transitions build on the existing capabilities of React’s declarative programming
    model to provide a simple and intuitive way to animate elements and components.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡建立在React的声明式编程模型现有功能之上，提供了一种简单直观的方式来动画化元素和组件。
- en: 'Here’s a simple example to illustrate how transitions work:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的例子，说明过渡是如何工作的：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we use the `Transition` component from the `react-transition-group`
    library to animate the appearance and disappearance of a `p` element. The `Transitio`n
    component takes an `in` prop that determines whether the element should be shown
    or hidden, and a `timeout` prop that specifies the duration of the transition
    in milliseconds.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`react-transition-group`库中的`Transition`组件来动画化`p`元素的显示和消失。`Transition`组件接受一个`in`属性，该属性确定元素是否应该显示或隐藏，以及一个`timeout`属性，该属性指定过渡的持续时间（以毫秒为单位）。
- en: Inside the `Transition` component, we define a function that takes a state argument
    and returns the contents of the transitioned element. The state argument is a
    string that represents the current state of the transition, which can be one of
    `entering`, `entered`, `exiting`, or `exited`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Transition`组件内部，我们定义了一个函数，该函数接受一个状态参数并返回过渡元素的 内容。状态参数是一个字符串，表示过渡的当前状态，可以是`entering`、`entered`、`exiting`或`exited`之一。
- en: In our example, we use the state argument to set the opacity of the `div` element
    based on the current state of the transition. When the state is `entered`, we
    set the opacity to `1` to make the element fully visible. When the state is `exiting`
    or `exited`, we set the opacity to `0` to make the element fade out smoothly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用状态参数来根据过渡的当前状态设置`div`元素的透明度。当状态是`entered`时，我们将透明度设置为`1`以使元素完全可见。当状态是`exiting`或`exited`时，我们将透明度设置为`0`以使元素平滑地淡出。
- en: By using the `Transition` component and the state argument, we can create a
    smooth, declarative animation that responds to changes in the application state.
    This can be a powerful way to create engaging and dynamic user interfaces that
    feel alive and responsive.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Transition`组件和状态参数，我们可以创建一个平滑、声明式的动画，该动画能够响应应用程序状态的变化。这可以是一种强大的方式来创建引人入胜且动态的用户界面，使其感觉生动且响应迅速。
- en: Overall, transitions are a powerful new feature in React 18 that allow developers
    to create declarative animations and transitions with ease. By leveraging the
    power of React’s declarative programming model, developers can create complex
    animations and transitions with a few lines of code, making it easier than ever
    to create engaging and dynamic user interfaces.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，过渡是React 18中的一个强大新特性，它允许开发者轻松地创建声明式动画和过渡。通过利用React的声明式编程模型，开发者可以用几行代码创建复杂的动画和过渡，使创建引人入胜且动态的用户界面变得比以往任何时候都更容易。
- en: Suspense on the server
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器上的Suspense
- en: React 18 introduces some improvements to **server-side rendering** (**SSR**)
    with **Suspense** that allow developers to create more efficient and scalable
    server-rendered applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: React 18通过Suspense引入了一些改进，这些改进允许开发者创建更高效和可扩展的服务器渲染应用程序。
- en: Before React 18, Suspense was primarily used in client-side rendering to manage
    asynchronous data loading and code splitting. However, with React 18, Suspense
    can also be used on the server to optimize the rendering of server-rendered components.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在React 18之前，Suspense主要用于客户端渲染来管理异步数据加载和代码拆分。然而，随着React 18的推出，Suspense也可以在服务器上使用以优化服务器渲染组件的渲染。
- en: 'Here’s a high-level overview of how Suspense works on the server:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Suspense在服务器上工作的高级概述：
- en: During the initial render of a server-rendered component, any Suspense boundaries
    are registered, and their fallback content is rendered instead of the main content.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器渲染组件的初始渲染过程中，任何Suspense边界都会被注册，并且它们的回退内容会被渲染而不是主内容。
- en: When data loading or code splitting is required, the server can return a “placeholder”
    HTML response that contains the fallback content for the Suspense boundaries.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要数据加载或代码拆分时，服务器可以返回一个包含Suspense边界回退内容的“占位符”HTML响应。
- en: Once the asynchronous data or code has loaded, the client can hydrate the Suspense
    boundaries with the actual content, replacing the fallback content with the final
    content.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦异步数据或代码加载完成，客户端可以使用实际内容来填充Suspense边界，用最终内容替换回退内容。
- en: This approach allows the server to avoid the expensive rendering of component
    trees that may be blocked by data loading or code splitting. Instead, the server
    can return a simple HTML response with fallback content, which can be quickly
    and easily rendered by the client. This can significantly improve the performance
    and scalability of server-rendered applications.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许服务器避免渲染可能因数据加载或代码拆分而阻塞的组件树的开销。相反，服务器可以返回一个包含回退内容的简单 HTML 响应，客户端可以快速轻松地渲染它。这可以显著提高服务器端渲染应用程序的性能和可伸缩性。
- en: 'Here’s an example to illustrate how Suspense can be used on the server:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，说明如何在服务器上使用 Suspense：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we have a `MyComponent` component that fetches user data from
    an API and renders it alongside a `UserProfile` component that requires additional
    data loading. By wrapping the `UserProfile` component in a `Suspense` boundary,
    we can ensure that the fallback content is displayed until the additional data
    has been loaded.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个 `MyComponent` 组件，它从 API 获取用户数据并将其与需要额外数据加载的 `UserProfile` 组件一起渲染。通过在
    `UserProfile` 组件周围包裹 `Suspense` 边界，我们可以确保在额外数据加载完成之前显示回退内容。
- en: When rendering on the server, the server can return a simple HTML response with
    the fallback content for the Suspense boundary, allowing the client to render
    the fallback content quickly and easily. Once the data has been loaded, the client
    can hydrate the Suspense boundary with the actual content, replacing the fallback
    content with the final content.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端渲染时，服务器可以返回一个简单的 HTML 响应，包含 Suspense 边界的回退内容，允许客户端快速轻松地渲染回退内容。一旦数据加载完成，客户端可以使用实际内容来填充
    Suspense 边界，用最终内容替换回退内容。
- en: Overall, the improvements to SSR with Suspense in React 18 can help to improve
    the performance and scalability of server-rendered applications, making it easier
    to create fast and responsive web experiences for users.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，React 18 中 Suspense 对 SSR 的改进有助于提高服务器端渲染应用程序的性能和可伸缩性，使用户能够创建快速响应的 Web 体验。
- en: New APIs
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新 API
- en: React 18 has introduced a variety of new APIs that are focused on enhancing
    the user interface, improving application performance, and providing a better
    developer experience. Notably, significant additions include `createRoot`, `hydrateRoot`,
    and `renderToPipeableStream`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: React 18 引入了一系列新的 API，这些 API 专注于增强用户界面，提高应用程序性能，并为开发者提供更好的体验。值得注意的是，重要的新增包括
    `createRoot`、`hydrateRoot` 和 `renderToPipeableStream`。
- en: createRoot
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: createRoot
- en: React 18 introduces a new API called `createRoot`, which provides a simpler
    and more explicit way to render React components into the DOM.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: React 18 引入了一个名为 `createRoot` 的新 API，它提供了一种更简单、更明确的渲染 React 组件到 DOM 中的方法。
- en: 'Traditionally, when rendering a React application into the DOM, you would use
    the `ReactDOM.render` method to specify the root element and the React component
    to render into it. For example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，当将 React 应用程序渲染到 DOM 中时，你会使用 `ReactDOM.render` 方法来指定根元素和要渲染到其中的 React 组件。例如：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With `createRoot`, you can create a root element that can be used to **render
    multiple components**, instead of specifying the root element for each component.
    Here’s an example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `createRoot`，你可以创建一个根元素，可以用来 **渲染多个组件**，而不是为每个组件指定根元素。下面是一个示例：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we first create a root element using `createRoot`, passing
    in the DOM element that we want to render our React application into. We then
    use the `render` method on the `root` element to specify the React component to
    render.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先使用 `createRoot` 创建一个根元素，将我们想要渲染 React 应用程序的 DOM 元素传递给它。然后，我们在 `root`
    元素上使用 `render` 方法来指定要渲染的 React 组件。
- en: 'The `createRoot` API also supports concurrent mode, which allows React to update
    the UI in a more efficient and responsive way by breaking up large updates into
    smaller chunks. To use concurrent mode with `createRoot`, you can pass a `mode`
    option:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`createRoot` API 也支持并发模式，这允许 React 通过将大型更新拆分为更小的块来更高效、更响应式地更新 UI。要使用 `createRoot`
    的并发模式，你可以传递一个 `mode` 选项：'
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we pass the `mod`e option with a value of `'concurrent'`, indicating
    that we want to use concurrent mode when rendering our React components.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们传递了 `mod`e 选项，其值为 `'concurrent'`，表示我们希望在渲染 React 组件时使用并发模式。
- en: Overall, the `createRoot` API provides a simpler and more flexible way to render
    React components into the DOM and supports the new features introduced in React
    18, such as concurrent mode and the improved server-side rendering with Suspense.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，`createRoot` API 提供了一种更简单、更灵活的方式来将 React 组件渲染到 DOM 中，并支持 React 18 中引入的新功能，如并发模式和改进的带有
    Suspense 的服务器端渲染。
- en: hydrateRoot
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: hydrateRoot
- en: '`hydrateRoot` is another new API introduced in React 18 that works in conjunction
    with `createRoot`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`hydrateRoot` 是 React 18 中引入的另一个新 API，它与 `createRoot` 一起工作。'
- en: In the traditional React rendering model, the server would render a static HTML
    document and send it to the client, which would then create a new React root and
    render the app on the client side. However, with SSR, React can render the initial
    HTML on the server and send it to the client, which can then “hydrate” the HTML
    into a fully functional React app.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 React 渲染模型中，服务器会渲染一个静态的 HTML 文档并发送到客户端，客户端随后会创建一个新的 React 根并渲染应用在客户端。然而，随着
    SSR 的出现，React 可以在服务器上渲染初始 HTML 并发送到客户端，客户端随后可以将 HTML “水合”成完全功能的 React 应用。
- en: '`hydrateRoot` is used for this process of hydrating the initial HTML sent by
    the server into a React component tree. It allows React to reuse the server-rendered
    markup so that the initial page load is faster and there’s less work for the client
    to do.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`hydrateRoot` 用于将服务器发送的初始 HTML 水合到 React 组件树的过程。它允许 React 重新使用服务器渲染的标记，从而使初始页面加载更快，客户端的工作量更少。'
- en: 'Here’s an example of how you can use `hydrateRoot` to hydrate the initial HTML
    on the client:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个如何使用 `hydrateRoot` 水合客户端初始 HTML 的示例：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we first create a root element using `createRoot` as we did
    in the previous example. We then check if the root is already mounted by calling
    `root.isMounted()`. If it is, we use `hydrateRoot` to hydrate the existing HTML
    on the page. If not, we use `root.render` to render the React component as usual.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先使用 `createRoot` 创建一个根元素，就像在之前的示例中做的那样。然后我们通过调用 `root.isMounted()`
    检查根是否已经挂载。如果是，我们使用 `hydrateRoot` 来水合页面上现有的 HTML。如果不是，我们使用 `root.render` 以通常的方式渲染
    React 组件。
- en: Note that you need to ensure that the server and client render the same HTML
    structure, otherwise, hydration may fail, and you may end up with a mismatch between
    the server-rendered markup and the hydrated React component tree. To avoid this,
    you can use the Suspense component to handle asynchronous rendering and data fetching
    on both the server and client and ensure that the HTML structure remains the same.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要确保服务器和客户端渲染相同的 HTML 结构，否则，水合可能会失败，你可能会在服务器渲染的标记和已水合的 React 组件树之间出现不匹配。为了避免这种情况，你可以使用
    Suspense 组件来处理服务器和客户端的异步渲染和数据获取，并确保 HTML 结构保持一致。
- en: renderToPipeableStream
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: renderToPipeableStream
- en: '`renderToPipeableStream` is another new API introduced in React 18 that allows
    you to render a React component tree to a **Node.js** stream. This can be useful
    for server-side rendering in scenarios where you need to send the rendered content
    over a network or to a file.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToPipeableStream` 是 React 18 中引入的另一个新 API，它允许你将 React 组件树渲染到 **Node.js**
    流中。这在需要通过网络或文件发送渲染内容的服务器端渲染场景中非常有用。'
- en: 'Here’s an example of how you can use `renderToPipeableStream` to render a React
    component to a stream:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个如何使用 `renderToPipeableStream` 将 React 组件渲染到流中的示例：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we first create a simple React component called `App`. We then
    create a Node.js HTTP server using the `createServer` method. When a request is
    made to the server, we use `renderToPipeableStream` to render the `App` component
    to a Node.js stream. We then pipe the stream to the response object using the
    `pipe` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先创建一个简单的 React 组件，称为 `App`。然后我们使用 `createServer` 方法创建一个 Node.js HTTP
    服务器。当对服务器发出请求时，我们使用 `renderToPipeableStream` 将 `App` 组件渲染到 Node.js 流中。然后我们使用 `pipe`
    方法将流管道连接到响应对象。
- en: Note that `renderToPipeableStream` returns a Node.js stream that you can pipe
    to other streams or write to a file. This allows you to easily generate server-rendered
    content and send it over a network or save it to disk without having to buffer
    the entire HTML in memory.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`renderToPipeableStream` 返回一个 Node.js 流，你可以将其管道连接到其他流或将内容写入文件。这允许你轻松生成服务器端渲染的内容，并通过网络发送或将其保存到磁盘，而无需在内存中缓冲整个
    HTML。
- en: Also note that `renderToPipeableStream` is asynchronous, so it returns a Promise
    that resolves to the stream. This means that you can use it with `await` to wait
    for the rendering to complete before sending the response.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`renderToPipeableStream` 是异步的，因此它返回一个解析为流的 Promise。这意味着你可以使用 `await` 等待渲染完成后再发送响应。
- en: Overall, `renderToPipeableStream` is a useful API for SSR in Node.js environments
    and can help improve the performance and scalability of your server-rendered applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，`renderToPipeableStream` 是 Node.js 环境中 SSR 的一个有用 API，可以帮助提高你服务器端渲染应用程序的性能和可扩展性。
- en: New Hooks
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新钩子
- en: In React 18, a set of innovative hooks has been introduced, which provide enhanced
    techniques for managing IDs, transitions, and optimizing performance. These hooks
    include `useId`, `useTransition`, `useDeferredValue`, and `useInsertionEffect`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 18 中，引入了一系列创新的钩子，这些钩子提供了管理 ID、过渡和优化性能的增强技术。这些钩子包括 `useId`、`useTransition`、`useDeferredValue`
    和 `useInsertionEffect`。
- en: useId
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useId
- en: '`useId` is a new built-in hook in React 18 that can be used to generate a unique
    ID. This can be useful in scenarios where you need to generate unique identifiers
    for elements in a React component, for example, when building forms.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`useId` 是 React 18 中的一个新内置钩子，可用于生成唯一 ID。这在需要为 React 组件中的元素生成唯一标识符的场景中非常有用，例如在构建表单时。'
- en: 'Here’s an example of how you can use `useId` to generate a unique ID:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用 `useId` 生成唯一 ID 的示例：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we use the `useId` hook to generate a unique ID, which we then
    use as the `id` attribute of a `<div>` element.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用 `useId` 钩子生成一个唯一 ID，然后将其用作 `<div>` 元素的 `id` 属性。
- en: '`useId` generates a unique ID that is guaranteed to be different on each render.
    It takes an optional parameter that can be used to specify a prefix for the generated
    ID, which can be useful for naming elements in a consistent way.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`useId` 生成一个在每次渲染中保证不同的唯一 ID。它接受一个可选参数，可以用来指定生成 ID 的前缀，这对于以一致的方式命名元素非常有用。'
- en: 'Here’s an example of how you can use the `prefix` parameter to specify a prefix
    for the generated ID:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用 `prefix` 参数指定生成 ID 的前缀的示例：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we use the `useId` hook with the `'my-prefix'` prefix, which
    generates an ID that starts with the string `'my-prefix'`. This can be useful
    for naming elements in a way that is consistent with your application’s naming
    conventions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用带有 `'my-prefix'` 前缀的 `useId` 钩子，它生成以字符串 `'my-prefix'` 开头的 ID。这可以用于以与你的应用程序命名约定一致的方式命名元素。
- en: Overall, `useId` is a useful addition to React 18 and can simplify the process
    of generating unique identifiers for elements in a React component.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，`useId` 是 React 18 的一个有用补充，可以简化为 React 组件中的元素生成唯一标识符的过程。
- en: Although the `useId` hook in React 18 offers unique benefits, it’s essential
    to be aware of certain caveats to avoid potential issues. Firstly, it’s not recommended
    to use `useId` for generating keys in a list. The preferred approach is to derive
    keys directly from your data. Secondly, the `useId` Hook requires a perfect match
    between the component trees on the server and the client side during server rendering.
    Any discrepancies between the server and client-rendered trees could lead to inconsistent
    IDs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 React 18 中的 `useId` 钩子提供了独特的优势，但了解某些注意事项对于避免潜在问题至关重要。首先，不建议使用 `useId` 为列表中的元素生成键。首选的方法是直接从你的数据中派生键。其次，`useId`
    钩子在服务器渲染期间需要服务器端和客户端组件树之间完全匹配。服务器和客户端渲染树之间的任何差异都可能导致 ID 不一致。
- en: useTransition
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useTransition
- en: '`useTransition` is a new built-in hook in React 18 that allows you to add smooth
    transitions to your application. It’s part of the new concurrent mode feature
    and is designed to work with Suspense to create loading states and fallbacks for
    data fetching.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`useTransition` 是 React 18 中的一个新内置钩子，允许你为你的应用程序添加平滑的过渡效果。它是新并发模式功能的一部分，旨在与
    Suspense 一起使用，以创建数据获取的加载状态和回退。'
- en: 'Here’s an example of how you can use `useTransition` to add a loading spinner
    while data is being fetched:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用 `useTransition` 在数据获取时添加加载指示器的示例：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we use `useState` to store the fetched data and `useTransition`
    to handle the loading state while the data is being fetched. When the **Fetch
    Data** button is clicked, the `startTransition` function is called with a callback
    that fetches the data and updates the state. The `isPending` value returned from
    `useTransition` is used to conditionally render a loading spinner.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `useState` 来存储获取的数据，并使用 `useTransition` 来处理数据获取时的加载状态。当点击 **Fetch
    Data** 按钮时，调用 `startTransition` 函数并传递一个回调函数，该回调函数获取数据并更新状态。从 `useTransition` 返回的
    `isPending` 值用于条件性地渲染一个加载指示器。
- en: '`useTransition` takes an optional configuration object with a `timeoutMs` property
    that specifies the maximum amount of time to spend in the pending state before
    showing the loading spinner. If the data is fetched before the timeout expires,
    the loading spinner is not displayed.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`useTransition` 接收一个可选的配置对象，其中包含一个 `timeoutMs` 属性，该属性指定了在显示加载指示器之前，在挂起状态中可以花费的最大时间。如果数据在超时之前被获取，则不会显示加载指示器。'
- en: Overall, `useTransition` is a powerful new feature in React 18 that can help
    you create smoother, more responsive applications with better user experiences.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，`useTransition` 是 React 18 中一个强大的新特性，可以帮助你创建更平滑、更响应的应用程序，提供更好的用户体验。
- en: useDeferredValue
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useDeferredValue
- en: '`useDeferredValue` is a new built-in hook in React 18 that allows you to defer
    updates to a value until the next frame. This can be useful when working with
    performance-intensive operations like animations.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`useDeferredValue` 是 React 18 中一个新的内置钩子，允许你将值的更新延迟到下一帧。当处理性能密集型操作，如动画时，这可能很有用。'
- en: 'Here’s an example of how you can use `useDeferredValue` to animate a component:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用 `useDeferredValue` 来动画化组件的例子：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we use `useState` to store the current position of the component,
    and `useDeferredValue` to defer updates to the position until the next frame.
    When the component is clicked, the position is updated using `setX`. The deferred
    value is used to render the component with a transition effect using CSS transforms.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `useState` 来存储组件的当前位置，并使用 `useDeferredValue` 来延迟对位置的更新直到下一帧。当组件被点击时，使用
    `setX` 更新位置。延迟的值用于使用 CSS 变换渲染组件，并添加过渡效果。
- en: '`useDeferredValue` takes two arguments: the value to defer and an optional
    configuration object. The configuration object can be used to specify a `timeoutMs`
    property that determines the maximum time to defer updates. By default, updates
    are deferred until the next frame.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`useDeferredValue` 接收两个参数：要延迟的值和一个可选的配置对象。配置对象可以用来指定一个 `timeoutMs` 属性，该属性决定了延迟更新的最大时间。默认情况下，更新将延迟到下一帧。'
- en: Note that `useDeferredValue` only works in conjunction with the `useTransition`
    hook, which provides the timing information necessary to defer updates to the
    next frame.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`useDeferredValue` 只能与 `useTransition` 钩子一起使用，它提供了必要的定时信息，以便将更新延迟到下一帧。
- en: useInsertionEffect
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useInsertionEffect
- en: '`useInsertionEffect` is a variation of the existing `useEffect` hook that allows
    you to perform actions after a DOM node has been inserted into the page. This
    can be useful for integrating with third-party libraries or for performing actions
    that require the presence of a DOM node.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`useInsertionEffect` 是现有 `useEffect` 钩子的一种变体，允许你在 DOM 节点被插入页面后执行操作。这对于与第三方库集成或执行需要
    DOM 节点存在的操作非常有用。'
- en: 'Here’s an example of how to use `useInsertionEffect`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用 `useInsertionEffect` 的例子：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we use `useInsertionEffect` to create a new `canvas` element
    and add it to the DOM when the component is mounted. The cleanup function returned
    by the hook removes the canvas element when the component is unmounted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `useInsertionEffect` 来创建一个新的 `canvas` 元素，并在组件挂载时将其添加到 DOM 中。钩子返回的清理函数在组件卸载时移除
    canvas 元素。
- en: Note that the second argument to `useInsertionEffect` is an empty array. This
    is because we only want to perform the insertion action once the component is
    mounted. If we included any dependencies in the array, the insertion action would
    be performed every time those dependencies changed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`useInsertionEffect` 的第二个参数是一个空数组。这是因为我们只想在组件挂载后执行一次插入操作。如果我们在这个数组中包含了任何依赖项，那么插入操作会在这些依赖项每次变化时执行。
- en: Strict mode
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格模式
- en: React 18 introduces a new feature called **Strict Mode,** which allows you to
    opt in to a stricter set of checks and warnings for your React application. The
    goal of Strict Mode is to catch potential problems early in development and to
    encourage best practices that make your code more performant and easier to debug.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: React 18引入了一个名为**Strict Mode**的新功能，允许你为你的React应用程序选择更严格的检查和警告集。Strict Mode的目标是在开发早期捕捉潜在的问题，并鼓励最佳实践，使你的代码更高效且更容易调试。
- en: 'Here’s an example of how to use Strict Mode:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用Strict Mode的例子：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we wrap our component tree with the `React.StrictMode` component.
    This enables several additional checks and warnings during development, such as
    detecting unsafe lifecycle methods, identifying potential side effects, and highlighting
    potential performance issues.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们用`React.StrictMode`组件包裹我们的组件树。这可以在开发期间启用一些额外的检查和警告，例如检测不安全的生命周期方法、识别潜在的副作用，以及突出潜在的性能问题。
- en: Strict Mode does not affect the behavior of your application in production and
    should only be used during development. Once you are confident that your code
    is free of any issues highlighted by Strict Mode, you can remove the `React.StrictMode`
    component from your code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Strict Mode不会影响生产环境中应用程序的行为，并且仅在开发期间使用。一旦你确信你的代码没有Strict Mode突出显示的任何问题，你就可以从你的代码中移除`React.StrictMode`组件。
- en: It’s worth noting that while Strict Mode can be useful for catching potential
    issues early in development, it is not a replacement for thorough testing and
    debugging. Always test your code thoroughly before deploying to production and
    use tools like React’s built-in debugging tools to identify and fix any issues
    that arise.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然Strict Mode可以在开发早期捕捉潜在的问题很有用，但它不能替代彻底的测试和调试。在部署到生产之前，始终彻底测试你的代码，并使用像React内置调试工具这样的工具来识别和修复出现的任何问题。
- en: Node.js latest features
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js最新特性
- en: There are some relevant new features in the latest versions of Node (18 and
    19); let’s see what is new in those versions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node的最新版本（18和19）中，有一些相关的新特性；让我们看看这些版本中有什么新内容。
- en: Experimental Fetch API
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验性Fetch API
- en: Node.js 18 (also in version 19) includes an experimental global **Fetch API**
    that is now available by default. The API’s implementation is inspired by **node-fetch**,
    which is originally based on **undici-fetch** and comes from **undici**. The API’s
    developers aim to make it as close to the specification as possible, but some
    features require a browser environment and are thus omitted.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 18（也包括在版本19中）包括一个默认可用的实验性全局**Fetch API**。该API的实现灵感来源于**node-fetch**，它最初基于**undici-fetch**，并来自**undici**。API的开发者旨在使其尽可能接近规范，但一些功能需要浏览器环境，因此被省略。
- en: 'Here is an example that hits the Pokémon API:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个调用宝可梦API的例子：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This addition to Node.js 18 (also included in version 19) makes the following
    global variables available: `fetch`, `FormData`, `Headers`, `Request`, and `Response`.
    Users can disable the API by specifying the `--no-experimental-fetch` command-line
    flag.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Node.js 18（也包括在版本19中）的添加使得以下全局变量可用：`fetch`、`FormData`、`Headers`、`Request`和`Response`。用户可以通过指定`--no-experimental-fetch`命令行标志来禁用此API。
- en: Experimental test runner module
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验性测试运行器模块
- en: It’s important to note that the test runner module is still in its experimental
    phase. To write unit tests and generate reports in **Test Anything Protocol**
    (**TAP**) format, we can import the `node:test` module. In this section, we’ll
    provide a few examples to illustrate how it works. This testing approach bears
    some similarity to Jest, a widely used JavaScript testing framework.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，测试运行器模块仍然处于实验阶段。为了编写单元测试并生成**Test Anything Protocol**（**TAP**）格式的报告，我们可以导入`node:test`模块。在本节中，我们将提供一些示例来说明它是如何工作的。这种测试方法与广泛使用的JavaScript测试框架Jest有一些相似之处。
- en: 'The `node:test` module simplifies the process of writing JavaScript tests that
    generate reports in **TAP** format. To access it, simply use the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`node:test`模块简化了编写生成**TAP**格式报告的JavaScript测试的过程。要访问它，只需使用以下代码：'
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To provide an example, here’s a demonstration of a parent test with two subtests:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个例子，这里是一个带有两个子测试的父测试演示：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If everything works fine, you should see something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该会看到类似以下的内容：
- en: '![Text  Description automatically generated](img/B18414_10_01.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_10_01.png)'
- en: 'Figure 10.1: Experimental test runner module'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：实验性测试运行器模块
- en: Experimental node watch
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验性node watch
- en: '`Node --watch` was introduced as a direct competitor to `nodemon`, and is a
    popular tool used for watching anything, although it has primarily been used for
    Node.js projects. However, with the code snippet provided below, you can now use
    it more easily:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node --watch`被引入作为`nodemon`的直接竞争对手，并且是一个用于监视任何内容的流行工具，尽管它主要用于Node.js项目。然而，通过下面提供的代码片段，你现在可以更轻松地使用它：'
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code will automatically detect any changes made to the specified file or
    directory and restart the server or script accordingly. This feature is available
    in versions 19.0.0 and 18.11.0+ of Node.js.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将自动检测对指定文件或目录所做的任何更改，并根据需要重新启动服务器或脚本。此功能在Node.js 19.0.0和18.11.0+版本中可用。
- en: Node 18 is now Long-Term Support (LTS)
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node 18现在是长期支持（LTS）
- en: Following the release of Node.js 19, Node.js 18 became a **LTS** version on
    October 25, 2022, with the codename *Hydrogen*. This transition marks the end
    of the active development phase of Node.js 18.x.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js 19发布之后，Node.js 18于2022年10月25日成为**LTS**版本，代号为*Hydrogen*。这一过渡标志着Node.js
    18.x的活跃开发阶段的结束。
- en: The current Node.js 18.x release has moved to **Active LTS** status and will
    remain so until October 2023\. After that, it will enter the **Maintenance** phase
    and continue to receive necessary security fixes and updates until the end of
    April 2025.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当前Node.js 18.x版本已升级到**Active LTS**状态，并将保持这一状态直到2023年10月。之后，它将进入**维护**阶段，并继续接收必要的安全修复和更新，直到2025年4月底。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In React 18, a wide array of new features and enhancements are introduced, which
    simplify the development of high-quality and interactive applications. These include
    automatic batching of state updates, concurrent rendering, the inclusion of Suspense
    for data fetching, improved error handling, and the addition of new component
    types. As a result, developers now have the ability to create more responsive
    and engaging user interfaces. For React developers, considering an upgrade to
    React 18 holds significant value. Additionally, we have also explored key features
    in Node.js 18 and 19, which are crucial for enhancing our web projects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在React 18中，引入了一系列新的功能和改进，这些功能简化了高质量和交互式应用程序的开发。这包括自动批处理状态更新、并发渲染、包含用于数据获取的Suspense、改进的错误处理以及新增组件类型。因此，开发者现在能够创建更响应和吸引人的用户界面。对于React开发者来说，考虑升级到React
    18具有重大价值。此外，我们还探讨了Node.js 18和19的关键特性，这些特性对于增强我们的Web项目至关重要。
- en: In the next chapter, we will learn how to handle data properly by using React
    Context API, React Suspense, and **stale-while-revalidate** (**SWR**).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过使用React Context API、React Suspense和**stale-while-revalidate**（**SWR**）来正确处理数据。
