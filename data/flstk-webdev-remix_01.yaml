- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Era of Full Stack Web Frameworks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全栈网络框架时代
- en: “The only constant in life is change.”
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “生活中唯一不变的是变化。”
- en: – Heraclitus
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: – 赫拉克利特
- en: We live in exciting times for web development. The landscape is changing at
    an astonishing pace. There have never been more technologies to choose from to
    develop for the web. It feels like a new framework or library is published every
    other month. Existing frameworks and libraries release new major versions with
    new features, breaking changes, and new conventions. The industry’s fast pace
    can feel overwhelming, but it is also fascinating to see such a high level of
    innovation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正处于网络开发的激动人心时期。这个领域的变革速度令人惊叹。从未有过如此多的技术可供选择来开发网络应用。感觉每隔一个月就会有一个新的框架或库发布。现有的框架和库发布带有新功能、破坏性更改和新约定的新主要版本。行业的快速步伐可能让人感到压倒，但看到如此高的创新水平也是令人着迷的。
- en: The larger web development community moves at a much slower pace than the cutting
    edge does. Most enterprises and developers are waiting to see what technologies
    stick around before adopting them – creating something we can consider the industry
    standard. I would count React as part of this standard. However, moving fast and
    adopting a new technology can be a competitive advantage if it moves the needle
    far enough. I believe Remix is such a technology.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发的大众群体比前沿技术的步伐要慢得多。大多数企业和开发者都在等待看到哪些技术能够持续存在，然后再采用它们——创造出我们可以认为是行业标准的东西。我会把React视为这一标准的一部分。然而，快速行动并采用新技术如果能够大幅推动进步，可以成为一种竞争优势。我相信Remix就是这样一种技术。
- en: 'Since you bought this book, you’ve decided to try Remix – awesome! As a React
    developer, Remix provides you with many benefits, such as the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 自从您购买这本书以来，您已经决定尝试Remix——太棒了！作为一个React开发者，Remix为您提供了许多好处，例如以下这些：
- en: A backend environment for your frontend
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的前端提供后端环境
- en: A full stack data mutation story
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全栈数据突变故事
- en: A declarative approach to error handling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式错误处理方法
- en: Simplified client-side state management
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化的客户端状态管理
- en: Server-side rendering
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: The latest advancements in React, such as streaming
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React的最新进展，例如流式传输
- en: An app runtime that can run anywhere, even on the edge
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以在任何地方运行的应用程序运行时，甚至在边缘
- en: Progressive enhancement through an embrace of web standards
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过拥抱网络标准实现渐进式增强
- en: 'With Remix, you can tap into the full capabilities of the web. This book guides
    you through the process, starting with the basics and progressing to more advanced
    techniques. In this first chapter, we will go over the following topics:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Remix，你可以充分利用网络的全功能。这本书将引导你通过这个过程，从基础知识开始，逐步过渡到更高级的技术。在本章的第一部分，我们将讨论以下主题：
- en: Introducing Remix
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Remix
- en: The philosophy behind Remix
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix背后的哲学
- en: Primitives, conventions, and levers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本元素、约定和杠杆
- en: Remix behind the scenes
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix幕后
- en: First, we will introduce Remix as a full stack web framework. After that, we
    will investigate the philosophy behind Remix and introduce a mental model to categorize
    the different tools Remix provides. Finally, we will look under the hood and learn
    about the different responsibilities that Remix takes on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍Remix作为全栈网络框架。然后，我们将研究Remix背后的哲学，并介绍一个心智模型来分类Remix提供的不同工具。最后，我们将深入了解Remix承担的不同责任。
- en: The goal of this first chapter is to introduce you to Remix. Most importantly,
    we want to showcase the advantages of Remix to your React development. We hope
    this will motivate you to get going. Therefore, this chapter touches upon several
    advanced concepts. But fear not; everything mentioned will be studied in detail
    later in this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向您介绍Remix。最重要的是，我们希望展示Remix在React开发中的优势。我们希望这能激励您开始使用。因此，本章涉及了几个高级概念。但请放心；本书后面将详细研究所有提到的内容。
- en: Introducing Remix
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Remix
- en: It’s intuitive to think of Remix as another React framework. Still, the team
    behind Remix stresses that Remix is not a React framework but a **full stack web
    framework** – an important distinction.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Remix可以被视为另一个React框架，但Remix背后的团队强调Remix不是一个React框架，而是一个**全栈网络框架**——这是一个重要的区别。
- en: In this first section, we will summarize what it means that Remix is a full
    stack web framework. First, we will look at the web framework part and explain
    why Remix is genuinely a framework for the web. After that, we will highlight
    why Remix is full stack.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将总结Remix作为全栈网络框架的含义。首先，我们将查看网络框架部分，并解释为什么Remix真正是网络框架。之后，我们将强调为什么Remix是全栈的。
- en: Remix is a web framework
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Remix是一个Web框架
- en: The main reason Remix is a web framework is its deep embrace of the web platform.
    Remix aims to enable a “fast, slick, and resilient user experience” by using web
    standards. HTML forms and anchor tags, URLs, cookies, meta tags, HTTP headers,
    and the **Web Fetch API** are all first-class citizens in Remix. Remix’s conventions,
    levers, and primitives are thoughtfully designed abstraction layers of existing
    web APIs and standards. This sets Remix apart from other popular frameworks that
    feel more decoupled from the web platform.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Remix之所以是Web框架，主要原因是它对Web平台的深度拥抱。Remix旨在通过使用Web标准来实现“快速、流畅且弹性良好的用户体验”。HTML表单和锚点标签、URL、cookies、元标签、HTTP头和**Web
    Fetch API**都是Remix中的第一公民。Remix的约定、杠杆和原语是精心设计的现有Web API和标准的抽象层。这使得Remix与其他感觉更脱离Web平台的流行框架有所不同。
- en: The **Open Web Platform** is the collection of standards defined by the **World
    Wide Web Consortium** (**W3C**). This includes JavaScript web APIs, HTML and CSS,
    accessibility guidelines, and HTTP. The web standard moves at a much slower pace
    than the industry standard does. New web standards take a long time and go through
    many iterations before being released, and it’s even longer before all browsers
    support them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放Web平台**是由**万维网联盟**（**W3C**）定义的一系列标准。这包括JavaScript Web API、HTML和CSS、无障碍性指南和HTTP。Web标准的推进速度比行业标准慢得多。新的Web标准需要很长时间，并且要经过多次迭代才能发布，而且所有浏览器支持它们的时间还要更长。'
- en: As a web developer, your resources are limited. To make the most of your time
    and energy, it’s essential to focus on learning the core principles of the web,
    which will be applicable regardless of the tools you choose. Learning the foundations
    of the web is transferable knowledge that benefits you regardless of what frameworks
    and libraries you use. When using Remix, you will often refer to the MDN Web Docs
    instead of the Remix documentation. Learning Remix means learning standard web
    APIs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Web开发者，您的资源有限。为了最大限度地利用您的时间和精力，关注学习Web的核心原则至关重要，这些原则无论您选择什么工具都将适用。学习Web的基础知识是可转移的知识，无论您使用什么框架和库都将受益。当使用Remix时，您通常会参考MDN
    Web文档而不是Remix文档。学习Remix意味着学习标准Web API。
- en: React plays a vital role in Remix. Remix leverages the latest features of React
    where it makes sense. With React 18, React is becoming more sophisticated. React’s
    latest features are more tailored to framework authors than app developers. Remix
    provides necessary abstractions to take advantage of these latest advancements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: React在Remix中扮演着至关重要的角色。当有道理时，Remix利用React的最新功能。随着React 18的推出，React变得越来越复杂。React的最新功能更适合框架作者而不是应用程序开发者。Remix提供了必要的抽象，以利用这些最新进展。
- en: When paired with React, Remix utilizes client-side routing and data fetching,
    creating a similar experience to building **single-page applications** (**SPAs**)
    with React. However, Remix has a broader scope than React and addresses additional
    concerns in web development, such as caching, user sessions, and data mutations.
    This makes Remix a web framework.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当与React配合使用时，Remix利用客户端路由和数据获取，创建类似于使用React构建**单页应用程序**（**SPAs**）的体验。然而，Remix的范畴比React更广，解决了Web开发中的其他问题，如缓存、用户会话和数据变更。这使得Remix成为一个Web框架。
- en: Remix is a full stack framework
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Remix是一个全栈框架
- en: 'Let’s see why Remix is full stack. Remix embraces the client/server model of
    the web platform. It orchestrates both the frontend and the backend of your web
    application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为什么Remix是全栈的。Remix采用了Web平台的客户端/服务器模型。它协调了您的Web应用程序的前端和后端：
- en: On the server, Remix acts as an HTTP request handler
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上，Remix充当HTTP请求处理器
- en: On the client, Remix orchestrates a server-side-rendered React application
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端，Remix协调一个服务器端渲染的React应用程序
- en: Remix acts as a frontend and a backend framework. These two frameworks are independent
    pieces executed in different environments (the browser and the server environment).
    During your app’s runtime, the two frameworks communicate over the network.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Remix充当前端和后端框架。这两个框架是独立的部分，在不同的环境中执行（浏览器和服务器环境）。在您的应用程序运行时，这两个框架通过网络进行通信。
- en: During development, you create one Remix application where the client and server
    code is nicely co-located in one `/app` directory. We can even write client and
    server code in the same files.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，您创建一个Remix应用程序，其中客户端和服务器代码在一个`/app`目录中很好地集中。我们甚至可以在同一文件中编写客户端和服务器代码。
- en: 'The following code example showcases what a page/route file looks like in Remix:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了Remix中页面/路由文件的样子：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the code example, we use Remix’s route module API to define a `loader` function
    for server-side data loading, an `action` function for mutating data, and the
    route’s React component for rendering the UI.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，我们使用Remix的路由模块API定义了一个用于服务器端数据加载的`loader`函数、一个用于数据突变的`action`函数以及用于渲染UI的路由的React组件。
- en: Remix co-locates server-side request handlers and the app’s route components.
    This makes sharing code between the client and server way easier and provides
    full visibility and control over how our app’s frontend and backend work together.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Remix将服务器端请求处理程序和应用程序的路由组件本地化。这使得在客户端和服务器之间共享代码变得容易得多，并提供了对应用程序的前端和后端如何协同工作的全面可见性和控制。
- en: On the server, we handle incoming HTTP requests and prepare responses using
    Remix’s `action` and `loader` functions. In the code example, the server-side
    request handlers manage user sessions and load and mutate data. We use web standards
    such as the Fetch API, `FormData`, and HTTP cookies.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，我们使用Remix的`action`和`loader`函数处理传入的HTTP请求并准备响应。在代码示例中，服务器端请求处理程序管理用户会话、加载数据并进行数据突变。我们使用Web标准，如Fetch
    API、`FormData`和HTTP cookies。
- en: In the route component, we access the server-side-loaded data and read transition
    states with Remix’s React hooks. We further use Remix’s `Form` component to define
    a data mutation declaratively. On the client, Remix runs JavaScript to enhance
    the browser’s default experience. This is where we utilize the power of React
    to compose dynamic UIs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由组件中，我们使用Remix的React钩子访问服务器端加载的数据并读取过渡状态。我们进一步使用Remix的`Form`组件声明式地定义数据突变。在客户端，Remix运行JavaScript来增强浏览器的默认体验。这就是我们利用React的力量来构建动态UI的地方。
- en: Remix is a web framework that lets you take advantage of the full stack. Remix
    truly allows you to unlock the full potential of the web platform for your React
    development.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Remix是一个让你充分利用全栈的Web框架。Remix真正地让你能够释放Web平台在React开发中的全部潜力。
- en: Now that we have introduced Remix, let’s dive into its philosophy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了Remix，让我们深入了解其哲学。
- en: Understanding the philosophy behind Remix
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Remix背后的哲学
- en: Remix’s mission is to let you build fast, slick, and resilient user experiences.
    The vision is to let you deliver software that people love. In this section, we
    will have a closer look into the philosophy behind Remix. You will learn about
    the creation of Remix and the values that the team promotes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Remix的使命是让你构建快速、流畅且具有弹性的用户体验。愿景是让你交付人们喜爱的软件。在本节中，我们将更深入地了解Remix背后的哲学。你将了解Remix的创建以及团队所倡导的价值观。
- en: Remix was created by Ryan Florence and Michael Jackson (`@ryanflorance` and
    `@mjackson` on Twitter and GitHub). Ryan and Michael are React veterans and the
    authors behind React Router – the most popular routing library for React applications
    with over 1 billion downloads on `npm`. Remix’s philosophy is heavily influenced
    by the lessons Ryan and Michael learned by building and maintaining React Router.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Remix是由Ryan Florence和Michael Jackson（在Twitter和GitHub上的`@ryanflorance`和`@mjackson`）创建的。Ryan和Michael是React的老兵，也是React
    Router的作者——这是React应用程序最受欢迎的路由库，在`npm`上有超过10亿次下载。Remix的哲学深受Ryan和Michael在构建和维护React
    Router过程中学到的教训的影响。
- en: Initially, Remix was intended to be a license-based framework. But in October
    2021, the development team behind Remix announced that they had secured seed funding
    and would make Remix open source. In November 2021, the team released v1 of Remix
    after 18 months of development. A year later, in October 2022, Shopify acquired
    Remix. The Remix team is now fully focused on Remix’s development while still
    pursuing the same mission and vision at Shopify.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Remix被设计为一个基于许可证的框架。但在2021年10月，Remix背后的开发团队宣布他们已经获得了种子资金，并将Remix开源。2021年11月，该团队在经过18个月的开发后发布了Remix的v1版本。一年后，在2022年10月，Shopify收购了Remix。现在，Remix团队完全专注于Remix的开发，同时仍在Shopify追求相同的使命和愿景。
- en: Not only is Remix open source, but the Remix team also embraces open development.
    The team has made the roadmap and all **Requests for Comments** (**RFCs**) and
    proposals available to the public. They also live-stream roadmap meetings and
    actively encourage community participation and contributions. The goal is to open
    the development process to the community as much as possible while still fostering
    the philosophy that guided Ryan and Michael.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 不仅开源，而且 Remix 团队还拥抱开放开发。该团队已将路线图以及所有**请求评论**（**RFCs**）和提案公开。他们还进行路线图会议的直播，并积极鼓励社区参与和贡献。目标是尽可能地向社区开放开发过程，同时仍然培养引导
    Ryan 和 Michael 的哲学思想。
- en: Over time, the team behind Remix has mentioned many of the things that are important
    to them. Above all, Remix is meant to push the web forward. Both Ryan and Michael
    stress that they want to see better websites. The mission is to provide you with
    the tools to build great user experiences. They want people to love using your
    stuff.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Remix 背后的团队提到了许多对他们来说重要的事情。最重要的是，Remix 的目的是推动 Web 的发展。Ryan 和 Michael
    都强调，他们希望看到更好的网站。使命是为您提供构建出色用户体验的工具。他们希望人们喜欢使用您的东西。
- en: 'The Remix team did a great job summarizing its philosophy in the Remix documentation.
    Some of the points that the Remix team has emphasized are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 团队在 Remix 文档中很好地总结了其哲学思想。Remix 团队强调的一些要点如下：
- en: Remix aims to avoid over-abstraction. In Remix, APIs are meant to be a thin
    abstraction layer on top of the web platform. Simplicity is king. Remix does not
    reinvent the wheel.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix 旨在避免过度抽象。在 Remix 中，API 被视为 Web 平台之上的一个薄抽象层。简洁是王道。Remix 不会重新发明轮子。
- en: Remix looks both forward and backward. It mixes cutting-edge technologies and
    matches them with battle-proven web standards to create new approaches. Remix
    takes advantage of HTTP2 streaming and edge deployment but simultaneously embraces
    HTML forms, cookies, and URLs.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix 既能展望未来，也能回顾过去。它将尖端技术与经过实战检验的 Web 标准相结合，创造新的方法。Remix 利用 HTTP2 流和边缘部署，同时拥抱
    HTML 表单、cookies 和 URL。
- en: Remix progressively enhances the user experience without straying from the browser’s
    default behavior. The goal is to stay true to the browser’s default behavior and
    be able to fall back to it whenever possible.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix 逐步增强用户体验，同时不偏离浏览器的默认行为。目标是始终忠于浏览器的默认行为，并在可能的情况下随时回退到它。
- en: Remix is about unlocking the full stack of the web platform – or, as the Remix
    team phrases it, the client/server model.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix 是关于解锁 Web 平台的全部功能——或者，正如 Remix 团队所表述的，客户端/服务器模型。
- en: The team behind Remix deeply cares about the network tab and your app’s bundle
    size. The goal is to load less and load things as quickly as possible.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix 背后的团队非常关注网络标签和您的应用程序包大小。目标是加载更少的内容，尽可能快地加载。
- en: Frameworks provide the foundation and framing for your application code. The
    Remix team also refers to Remix as being center stack (instead of full stack).
    Remix is meant to be the core, reaching out to both the client and server sides
    of your application. It is meant to be the centerpiece.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 框架为您的应用程序代码提供基础和框架。Remix 团队还将 Remix 称为中心栈（而不是全栈）。Remix 的目的是成为核心，连接到您的应用程序的客户端和服务器两端。它旨在成为中心。
- en: For me, Remix is a powerful tool with great developer experience that lets me
    build for the web. I value the simplicity and utility of the APIs that Remix provides.
    I have learned a lot about the web since picking up Remix, all thanks to the emphasis
    on using the web platform. Remix combines new approaches with old ones. It is
    refreshing to use and has already started influencing the ecosystem around it.
    We now truly live in the era of full stack web frameworks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，Remix 是一款功能强大的工具，具有出色的开发者体验，让我能够为 Web 构建内容。我重视 Remix 提供的 API 的简洁性和实用性。自从我开始使用
    Remix 以来，我学到了很多关于 Web 的知识，这都要归功于对使用 Web 平台的强调。Remix 结合了新的方法与旧的方法。使用它令人耳目一新，并且已经开始影响其周围的生态系统。我们现在真正生活在全栈
    Web 框架的时代。
- en: 'The Remix team promotes the Remix way of thinking. For instance, Ryan suggests
    a three-step process for developing web experiences:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 团队推广 Remix 思维方式。例如，Ryan 提出了一种三步法来开发网络体验：
- en: Make everything work without JavaScript.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让所有内容在没有 JavaScript 的情况下也能工作。
- en: Enhance the experience with JavaScript.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 JavaScript 增强体验。
- en: Move as much business logic as possible to the server.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能地将业务逻辑移至服务器。
- en: 'In each step, we build upon the last step to enhance the experience:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，我们都是在上一步的基础上构建，以增强体验：
- en: First, we focus on building the feature without JavaScript. With Remix, we take
    advantage of the web platform. We use forms to mutate data and use server-side
    redirects to communicate feedback. After the feature works without JavaScript,
    we could possibly publish it and be done.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们专注于在不使用 JavaScript 的情况下构建特性。使用 Remix，我们利用了 Web 平台。我们使用表单来修改数据，并使用服务器端重定向来传递反馈。在特性在不使用
    JavaScript 的情况下工作后，我们可能可以发布它并完成。
- en: Next, we use JavaScript on the client to enhance the user experience. We may
    add optimistic UIs, deferred data loading, and real-time data updates.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在客户端使用 JavaScript 来增强用户体验。我们可能会添加乐观 UI、延迟数据加载和实时数据更新。
- en: Finally, we move as much business logic as possible to the server. This allows
    for graceful degradation in case client-side JavaScript isn’t loaded. It also
    decreases the bundle size of your app.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将尽可能多的业务逻辑移至服务器。这允许在客户端 JavaScript 未加载的情况下优雅降级。它还减少了你的应用程序的包大小。
- en: By using Remix and engaging with the Remix community, you are exposed to Remix’s
    philosophy. Applying Remix’s philosophy to your development process will truly
    supercharge your React development.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Remix 并参与 Remix 社区，你将接触到 Remix 的哲学。将 Remix 的哲学应用到你的开发过程中将真正提升你的 React 开发能力。
- en: Remix’s philosophy can also be understood by the tools it provides you. In the
    next section, I want to introduce you to a mental model of framework features.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 的哲学也可以通过它提供的工具来理解。在下一节中，我想向您介绍框架特性的心智模型。
- en: Primitives, conventions, and levers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原语、约定和杠杆
- en: 'In this section, we will categorize the different features Remix offers. A
    framework provides the foundation and framing for your application. It further
    exposes tools to you as a developer. We can divide these tools into three categories:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将对 Remix 提供的不同特性进行分类。一个框架为你的应用程序提供了基础和框架。它进一步向你作为开发者暴露工具。我们可以将这些工具分为三个类别：
- en: Primitives
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原语
- en: Conventions
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约定
- en: Levers
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杠杆
- en: Primitives, conventions, and levers can serve as a great mental model to map
    different features of Remix. Let’s see how the three categories differ.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 原语、约定和杠杆可以作为一个很好的心智模型来映射 Remix 的不同特性。让我们看看这三个类别如何不同。
- en: Primitives
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原语
- en: Primitives are used in your application code to interact with the framework
    layer. They are the wiring that integrates your application into the foundation
    and framing provided by the framework. Common primitives are functions, hooks,
    constants, types, classes, and components. The framework exposes these primitives
    so you can use them in your code. The art is to make primitives easy to understand
    yet composable enough to enable powerful business logic. Remix has done just that.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 原语用于你的应用程序代码与框架层交互。它们是将你的应用程序集成到框架提供的基础和框架中的连接线。常见的原语包括函数、钩子、常量、类型、类和组件。框架暴露这些原语，以便你可以在代码中使用它们。艺术在于使原语易于理解，同时足够可组合，以实现强大的业务逻辑。Remix
    正是这样做的。
- en: Remix provides primitives for both your client and server code. Remix primitives
    are often just a thin abstraction layer of the web platform and offer similar
    APIs to the native primitives. For instance, Remix’s `Form` component accepts
    the same properties as the native form element but also offers some additional
    properties to enhance the experience.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 为你的客户端和服务器端代码提供了原语。Remix 的原语通常是 Web 平台的薄层抽象，并提供与原生原语相似的 API。例如，Remix 的
    `Form` 组件接受与原生表单元素相同的属性，但还提供了一些额外的属性来增强体验。
- en: Also, Remix’s primitives themselves expose standard web APIs. Most server-side
    code you write in Remix has access to a `Request` object that follows the Web
    Fetch API specification. Remix does not reinvent the wheel.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Remix 的原语本身也暴露了标准的 Web API。你在 Remix 中编写的绝大多数服务器端代码都可以访问一个遵循 Web Fetch API
    规范的 `Request` 对象。Remix 并没有重新发明轮子。
- en: Conventions
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约定
- en: Frameworks also introduce conventions. Common conventions are file and folder
    naming conventions. In the previous section, we showed a code example of a route
    file in Remix. Remix’s route files (route modules) allow you to export specific
    functions that are part of Remix’s route filenaming convention.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 框架还引入了约定。常见的约定包括文件和文件夹命名约定。在前一节中，我们展示了 Remix 中路由文件的代码示例。Remix 的路由文件（路由模块）允许你导出属于
    Remix 路由文件命名约定的特定函数。
- en: Conventions are meant to improve the developer experience. For instance, file-based
    routing lets you define your application’s route structure as a file and folder
    hierarchy. Remix compiles your code and infers your route hierarchy, so you don’t
    have to define your route hierarchy as code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 约定旨在提升开发者体验。例如，基于文件的路由允许你将应用程序的路由结构定义为文件和文件夹层次结构。Remix编译你的代码并推断你的路由层次结构，因此你无需将路由层次结构定义为代码。
- en: Intuitive conventions reduce the amount of configuration required to wire an
    application. They shift the burden toward the framework. Conventions make up the
    contract between the framework and your application and can significantly reduce
    the amount of boilerplate code you have to write.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 直观的约定可以减少连接应用程序所需的配置量。它们将负担转移到框架上。约定构成了框架与你的应用程序之间的合同，并且可以显著减少你必须编写的样板代码量。
- en: 'The API of a framework is mainly composed of primitives and conventions. All
    frameworks include primitives, and many frameworks utilize conventions. However,
    Remix places a particular emphasis on a third category: levers.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的API主要由原语和约定组成。所有框架都包含原语，许多框架也利用约定。然而，Remix特别强调第三类：杠杆。
- en: Levers
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杠杆
- en: Levers can be interpreted as options. Ryan coined the metaphor in one of his
    first conference talks about Remix. Ryan emphasizes that Remix is just a thin
    abstraction layer on top of the web platform. Remix lets you decide what web vitals
    to optimize for. **Time to First Byte** (**TTFB**) or **Cumulative Layout Shift**
    (**CLS**)? Loading spinners or slower page loads? Optimizing for different web
    vitals can be conflicting goals. Remix offers levers so that you can stir your
    web app in the direction that is right and important for you.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 杠杆可以理解为选项。Ryan在关于Remix的第一场会议演讲中提出了这个隐喻。Ryan强调，Remix只是网络平台上的一个薄抽象层。Remix让你决定要优化哪些网络关键指标。**首次字节时间**（**TTFB**）或**累积布局偏移**（**CLS**）？加载旋转器还是较慢的页面加载？优化不同的网络关键指标可能是冲突的目标。Remix提供了杠杆，让你可以引导你的网络应用程序朝着对你正确且重要的方向前进。
- en: With levers comes utility but also responsibility. Remix provides the primitives,
    but you must decide how to design your application. I believe this power makes
    you a better web developer. But more importantly, it unlocks the full potential
    of the web platform. There are many things to optimize for, and Remix provides
    the levers. This sets Remix apart from other frameworks that don’t give you the
    same kind of flexibility and control.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 杠杆带来了实用性和责任。Remix提供了原语，但你必须决定如何设计你的应用程序。我相信这种力量使你成为一个更好的网络开发者。但更重要的是，它释放了网络平台的全部潜力。有许多事情需要优化，Remix提供了杠杆。这使得Remix与其他不提供相同类型灵活性和控制的框架区别开来。
- en: Now that we’ve prepared a mental model for how to categorize Remix’s features,
    we will have a look behind the scenes. Remix offers many great features and comes
    with many quality-of-life improvements. This is because it takes on several responsibilities
    at once. Let’s peek under the hood to understand what that means.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为如何分类Remix的功能准备了一个心理模型，我们将揭开幕布。Remix提供了许多出色的功能，并带来了许多生活质量的提升。这是因为它同时承担了多项责任。让我们揭开盖子，了解这意味着什么。
- en: Remix behind the scenes
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Remix幕后
- en: So, how does Remix work behind the scenes? Based on what we have learned so
    far, Remix seems to do quite a lot. In this section, we will have a look behind
    the curtain. This will help you understand some of the responsibilities Remix
    takes on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Remix在幕后是如何工作的呢？根据我们迄今为止所学到的，Remix似乎做了很多事情。在本节中，我们将揭开幕布。这将帮助你理解Remix承担的一些责任。
- en: Remix offers a fantastic developer experience but can also feel like magic.
    A bit of magic goes a long way, but it can also be overwhelming when one doesn’t
    understand what is happening. Magic is also hard to troubleshoot if something
    goes wrong. That is why I want to reveal some of Remix’s inner workings even before
    creating our first Remix project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Remix提供了出色的开发者体验，但有时也感觉像魔法。一点魔法可以走得很远，但如果不理解发生了什么，也可能让人感到不知所措。如果出现问题，魔法也很难调试。这就是为什么我想在我们创建第一个Remix项目之前就揭示一些Remix的内部工作原理。
- en: 'We can identify three distinct responsibilities that Remix takes on:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以识别出Remix承担的三个不同的责任：
- en: Remix bundles your code
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix打包你的代码
- en: Remix manages routing in your application
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix管理你的应用程序的路由
- en: Remix handles incoming HTTP requests
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix处理传入的HTTP请求
- en: 'Based on the identified responsibilities, Remix can be broken down into three
    main components: a compiler, a router, and a runtime. In the following sections,
    we will examine each component. To start, let’s take a closer look at how Remix
    operates as a compiler.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据确定的职责，Remix可以分为三个主要组件：编译器、路由器和运行时。在接下来的章节中，我们将检查每个组件。首先，让我们更详细地看看Remix作为编译器是如何运作的。
- en: Remix is a compiler
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Remix是一个编译器
- en: Remix compiles your file-based route modules into code. It infers the route
    structure from the file and folder hierarchy. For each route module, Remix inspects
    what functions it exports and translates the routes folder into a data structure
    used during runtime. This makes Remix a compiler.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Remix将基于文件的路线模块编译成代码。它从文件和文件夹层次结构中推断路线结构。对于每个路线模块，Remix检查它导出的函数，并将路线文件夹转换成运行时使用的数据结构。这使得Remix成为一个编译器。
- en: One thing you will notice while working with Remix is the speed of its build
    step. This is thanks to esbuild, the build tool used by Remix. Remix doesn’t expose
    esbuild. Hence, Remix can adapt how it bundles your code and be competitive in
    the future by using the latest and greatest build tools. If an even faster, more
    powerful build tool is released, Remix could switch out esbuild tomorrow.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Remix工作时，你会注意到其构建步骤的速度。这要归功于Remix使用的构建工具esbuild。Remix不暴露esbuild。因此，Remix可以调整其打包代码的方式，并通过使用最新的构建工具在未来保持竞争力。如果发布了更快、更强大的构建工具，Remix明天就可以切换到esbuild。
- en: 'Remix builds on top of esbuild to bundle your JavaScript files into the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Remix基于esbuild将你的JavaScript文件打包成以下内容：
- en: A server bundle
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器包
- en: A client bundle
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端包
- en: An asset manifest
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产清单
- en: Remix’s **command-line interface** (**CLI**) builds your code into a client
    and server bundle. The server bundle contains Remix’s HTTP handler and adapter
    logic. This is the code that runs on the server. The client build contains client-side
    scripts that operate Remix’s client-side React application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Remix的**命令行界面**（CLI）将你的代码编译成客户端和服务器包。服务器包包含Remix的HTTP处理程序和适配器逻辑。这是在服务器上运行的代码。客户端构建包含操作Remix客户端React应用程序的客户端脚本。
- en: Remix also compiles an **asset manifest** based on your route hierarchy. Both
    the client and server use the asset manifest, which includes information about
    the dependency graph of your application. The manifest tells Remix what to load
    and allows prefetching assets and application data for page transitions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Remix还会根据你的路由层次结构编译一个**资产清单**。客户端和服务器都使用资产清单，其中包含应用程序的依赖关系图信息。清单告诉Remix需要加载什么，并允许在页面转换时预取资产和应用程序数据。
- en: Speaking of page transitions…
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 说到页面转换...
- en: Remix is a router
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Remix是一个路由器
- en: Remix implements a router for both your client and server code. This eases the
    server-to-client handoff. The deep integration between the frontend and backend
    makes Remix bridge the network gap. This allows Remix to do some neat things.
    For instance, Remix calls your route `loader` functions in parallel to avoid request
    waterfalls.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Remix为你的客户端和服务器代码实现了一个路由器。这简化了服务器到客户端的移交。前端和后端的深度集成使得Remix弥合了网络差距。这允许Remix做一些很酷的事情。例如，Remix并行调用你的路由`loader`函数，以避免请求瀑布。
- en: We can simplify things and say that Remix uses React Router under the hood.
    To be more specific, Remix uses both `react-router-dom` and `@remix-run/router`.
    `@remix-run/router` is a frontend library/framework-agnostic package used by React
    Router v6 and Remix. React Router and Remix have been aligned and share a similar
    API surface. In many ways, you can think of Remix as a compiler for its underlying
    routing solution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简化一下，说Remix在底层使用React Router。更具体地说，Remix同时使用`react-router-dom`和`@remix-run/router`。`@remix-run/router`是一个前端库/框架无关的包，由React
    Router v6和Remix使用。React Router和Remix已经对齐，并具有相似的API表面。从许多方面来看，你可以把Remix看作是其底层路由解决方案的编译器。
- en: Remix has a client-side and a server-side part, as does its routing solution.
    The React components exposed by Remix make sure your application feels like an
    SPA. Remix handles form submissions and link clicks. It prevents the browser’s
    default behavior if JavaScript is loaded but can fall back to full page loads
    if necessary. All that is managed by Remix’s router at runtime.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Remix具有客户端和服务器部分，其路由解决方案也是如此。Remix暴露的React组件确保你的应用程序感觉像一个单页应用（SPA）。Remix处理表单提交和链接点击。如果加载了JavaScript，它会阻止浏览器默认行为，但在必要时可以回退到完整页面加载。所有这些都是在运行时由Remix的路由器管理的。
- en: Speaking of runtimes…
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 说到运行时...
- en: Remix is a runtime
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Remix是一个运行时
- en: Remix runs on an existing server, such as an Express.js Node server. Remix provides
    adapters to create combability with different server-side JavaScript environments.
    This enables Remix’s HTTP handler to be agnostic to the underlying server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 在现有的服务器上运行，例如 Express.js Node 服务器。Remix 提供适配器以创建与不同服务器端 JavaScript 环境的兼容性。这使得
    Remix 的 HTTP 处理器对底层服务器保持无感知。
- en: The adapter translates incoming requests from the server environment to standard
    `Request` objects and reverts the HTTP handler’s responses back to the server
    environment’s response implementation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器将来自服务器环境的传入请求转换为标准的 `Request` 对象，并将 HTTP 处理器的响应转换回服务器环境响应的实现。
- en: Remix receives HTTP requests via the JavaScript server and prepares the responses.
    Remix’s router knows what route modules to load and render and which assets to
    fetch. On the client, Remix hydrates your React application and orchestrates the
    routing and data fetching. As a framework, Remix provides the foundation for your
    application and executes your application’s code. Next, let’s have a look at what
    Remix is not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 通过 JavaScript 服务器接收 HTTP 请求并准备响应。Remix 的路由器知道要加载和渲染哪些路由模块以及要获取哪些资源。在客户端，Remix
    激活您的 React 应用程序并协调路由和数据获取。作为一个框架，Remix 为您的应用程序提供基础并执行应用程序的代码。接下来，让我们看看 Remix 不是什么。
- en: What Remix is not
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Remix 不是什么
- en: 'Earlier in this chapter, we introduced Remix and explored many of the tools
    and features that it provides. Remix is a full stack web framework, but it is
    also essential to understand what Remix is not. Most importantly, Remix is not
    one of the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们介绍了 Remix 并探讨了它提供的许多工具和功能。Remix 是一个全栈 Web 框架，但了解 Remix 不是什么也同样重要。最重要的是，Remix
    以下列内容之一：
- en: A JavaScript server
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 JavaScript 服务器
- en: A database
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据库
- en: An **Object Relation** **Mapper** (**ORM**)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **对象关系映射器**（**ORM**）
- en: A cloud provider
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个云服务提供商
- en: A styling or theming library
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个样式或主题库
- en: A magic crystal ball
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个魔法水晶球
- en: Remix is neither a server nor a JavaScript engine. Remix runs on a JavaScript
    environment such as Node.js and uses adapters to communicate with a web server
    such as Express.js. Remix also provides no solutions for the data layer of your
    application. It helps you load and mutate data, but it is your job to implement
    those data loaders and actions. It is your job to select a database solution that
    fits your use case. Remix is also not an ORM. Hence, you must query your data
    in your actions and loaders, define your data types, or use third-party libraries
    for support.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 既不是服务器也不是 JavaScript 引擎。Remix 在 Node.js 等JavaScript 环境上运行，并使用适配器与 Express.js
    等Web 服务器通信。Remix 也不提供应用程序数据层的解决方案。它帮助您加载和修改数据，但实现这些数据加载器和动作是您的工作。您需要选择适合您用例的数据库解决方案。Remix
    也不是一个 ORM。因此，您必须在动作和加载器中查询数据，定义您的数据类型，或使用第三方库以获得支持。
- en: The company behind Remix does not act as a cloud provider or offer a cloud hosting
    service. You can host your Remix application almost anywhere where JavaScript
    can be executed. Many cloud services support Remix out of the box, but Remix as
    a company does not offer any hosting services.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 背后的公司不作为云服务提供商或提供云托管服务。您几乎可以在任何可以执行 JavaScript 的地方托管您的 Remix 应用程序。许多云服务默认支持
    Remix，但 Remix 公司本身不提供任何托管服务。
- en: Remix is also not a styling or theming library. Remix is opinionated on how
    to work with CSS, but its solution is generic. Remix provides no tools for styling
    or theming other than utilities to load your stylesheets on a prefix route level.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 也不是一个样式或主题库。Remix 对如何使用 CSS 有自己的看法，但其解决方案是通用的。除了在前缀路由级别加载样式表的实用工具之外，Remix
    不提供用于样式或主题化的工具。
- en: Most things listed are out of scope for Remix, but some might be up for change
    in the future. For now, let’s focus on the present. In this first chapter, we
    have learned a lot about the many features Remix has to offer. Most of the things
    mentioned happen behind the scenes. This book will guide you through each aspect
    of Remix step by step. Each chapter will focus on a specific topic, such as routing,
    data fetching and mutation, error handling, and state management. By examining
    these topics one by one, we will explore the significance of Remix. I am certainly
    excited to start coding!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的许多内容都不在 Remix 的范围内，但其中一些可能在将来有所变化。现在，让我们专注于现在。在本章的第一部分，我们了解了很多关于 Remix 提供的众多功能。提到的大多数事情都是在幕后发生的。本书将逐步引导您了解
    Remix 的每个方面。每一章都将专注于一个特定主题，例如路由、数据获取和修改、错误处理以及状态管理。通过逐一检查这些主题，我们将探讨 Remix 的意义。我当然很兴奋开始编码！
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this first chapter, we introduced Remix as a full stack web framework. Remix
    promotes the usage of the web platform and lets you take advantage of standard
    web APIs. It bridges the network gap by tightly integrating the frontend and the
    backend. This allows Remix to do some cool things.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们将 Remix 介绍为一个全栈 Web 框架。Remix 推崇使用 Web 平台，并让您利用标准 Web API。它通过紧密集成前端和后端来弥合网络差距。这使得
    Remix 能够做一些酷的事情。
- en: We also looked at the philosophy behind Remix. The team behind Remix emphasizes
    avoidance of over-abstraction. Its mission is to let you build fast, slick, and
    resilient user experiences. The vision is to let you deliver software that people
    will love.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了 Remix 背后的哲学。Remix 背后的团队强调避免过度抽象。其使命是让您能够快速、流畅且稳健地构建用户体验。愿景是让您交付人们会喜爱的软件。
- en: We introduced the terms primitives, conventions, and levers to categorize Remix’s
    different features. Primitives are the exposed utilities that can be imported
    and used in our code. Conventions are contracts such as file and folder naming
    conventions that are used to avoid tedious configuration. Levers are options provided
    by Remix that allow us to optimize our application for what’s important to us.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了术语原语、约定和杠杆来对 Remix 的不同功能进行分类。原语是可以导入并用于我们代码中的暴露工具。约定是诸如文件和文件夹命名约定之类的合同，用于避免繁琐的配置。杠杆是
    Remix 提供的选项，允许我们针对对我们重要的事情优化我们的应用程序。
- en: You also learned more about what Remix does behind the scenes. Remix takes on
    three distinct responsibilities. It is a compiler, a router, and a runtime. Combining
    those three responsibilities in one framework enables great things, such as flattening
    request waterfalls and avoiding the frontend-backend split by co-locating client
    and server code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您还了解了 Remix 在幕后所做的工作。Remix 承担了三个不同的职责。它是一个编译器、一个路由器和运行时。将这三个职责结合在一个框架中，可以实现一些了不起的事情，例如通过将客户端和服务器代码放置在一起来简化请求瀑布并避免前端-后端分离。
- en: In this chapter, we touched upon many concepts, such as server-side rendering,
    prefetching, and client-side routing. We will revisit all the mentioned concepts
    throughout this book. In the next chapter, we start our Remix development journey
    and create a “Hello World” Remix app.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提到了许多概念，如服务器端渲染、预取和客户端路由。我们将在本书的后续章节中重新审视所有提到的概念。在下一章中，我们将开始我们的 Remix
    开发之旅，并创建一个“Hello World” Remix 应用程序。
- en: Further reading
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you haven’t looked through Remix’s home page ([https://remix.run](https://remix.run)),
    I encourage you to do so. The team behind Remix has done a great job of breaking
    down its value proposition and pitching its solutions. Also, it looks awesome.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有查看 Remix 的主页 ([https://remix.run](https://remix.run))，我鼓励您去查看。Remix 背后的团队在阐述其价值主张和提出解决方案方面做得非常出色。而且，它看起来很棒。
- en: 'The same goes for the Remix documentation. I encourage you to familiarize yourself
    with Remix''s documentation as you work through the chapters of this book. For
    example, the team behind Remix has done a fantastic job of summarizing its philosophy.
    You can read more about it here: [https://remix.run/docs/en/v1/pages/philosophy](https://remix.run/docs/en/v1/pages/philosophy).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 文档也是如此。我鼓励您在阅读本书的章节时熟悉 Remix 的文档。例如，Remix 背后的团队对其哲学进行了出色的总结。您可以在以下链接了解更多：[https://remix.run/docs/en/v1/pages/philosophy](https://remix.run/docs/en/v1/pages/philosophy)。
- en: 'Are you interested in more in-depth explanations about Remix? You can find
    an in-depth technical explanation about Remix here: [https://remix.run/docs/en/2/pages/technical-explanation](https://remix.run/docs/en/2/pages/technical-explanation).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否对 Remix 的深入解释更感兴趣？您可以在以下链接找到关于 Remix 的深入技术解释：[https://remix.run/docs/en/2/pages/technical-explanation](https://remix.run/docs/en/2/pages/technical-explanation)。
- en: 'You can find the official announcement of Remix joining forces with Shopify
    here: [https://remix.run/blog/remixing-shopify](https://remix.run/blog/remixing-shopify).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到 Remix 与 Shopify 联合的官方公告：[https://remix.run/blog/remixing-shopify](https://remix.run/blog/remixing-shopify)。
- en: 'The public roadmap and most other planning documents are located on GitHub.
    The roadmap can be found here: [https://github.com/orgs/remix-run/projects/5](https://github.com/orgs/remix-run/projects/5).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 公共路线图和大多数其他规划文档都位于 GitHub 上。路线图可以在以下链接找到：[https://github.com/orgs/remix-run/projects/5](https://github.com/orgs/remix-run/projects/5)。
- en: 'If you want to learn more about Remix’s approach compared to alternative technologies,
    check out this blog post: [https://remix.run/blog/remix-and-the-edge](https://remix.run/blog/remix-and-the-edge).
    If you want more context around alternative solutions, I recommend the following
    blog post: [https://frontendmastery.com/posts/the-new-wave-of-javascript-web-frameworks](https://frontendmastery.com/posts/the-new-wave-of-javascript-web-frameworks).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解Remix与其他技术相比的方法，请查看这篇博客文章：[https://remix.run/blog/remix-and-the-edge](https://remix.run/blog/remix-and-the-edge)。如果你想了解更多关于替代解决方案的背景信息，我推荐以下博客文章：[https://frontendmastery.com/posts/the-new-wave-of-javascript-web-frameworks](https://frontendmastery.com/posts/the-new-wave-of-javascript-web-frameworks).
