<html><head></head><body>
<div id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-133"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-134"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.2.1">Handling Application State with Grace</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, you’ll learn about application state. </span><span class="koboSpan" id="kobo.3.2">Understanding and handling the state of your application is one of the most essential parts of frontend development. </span><span class="koboSpan" id="kobo.3.3">If the state of your applications becomes messy, entangled, and hard to understand, your development process and the quality of your application </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">will suffer.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">To help you better manage your application state, we will talk about the different state levels you’ll find within your applications. </span><span class="koboSpan" id="kobo.5.2">You will learn how to partition and divide your state for maximum efficiency. </span><span class="koboSpan" id="kobo.5.3">You will also create a state management solution using RxJS and Signals and build a facade service to access your state from the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">component layer.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Next, you will learn how to handle more complex states with the NgRx library. </span><span class="koboSpan" id="kobo.7.2">NgRx is the most commonly used state management library within the Angular community and uses the Redux pattern to manage state. </span><span class="koboSpan" id="kobo.7.3">Since the introduction of Angular Signals, NgRx also provides different approaches to working with Signals while using the tools we love </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">from NgRx.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">By the end of this chapter, you will have implemented state management solutions using different methods. </span><span class="koboSpan" id="kobo.9.2">You’ll have learned how easy it is to change your state management solution when using a facade service and seen how Angular Signals has changed the way we handle state within </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Angular applications.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">This chapter will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">application state</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Handling global application state </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">using RxJS</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Handling global application state </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">using Signals</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Handling global application state </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">with NgRx</span></span></li>
</ul>
<h1 id="_idParaDest-135"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.21.1">Understanding application state</span></h1>
<p><span class="koboSpan" id="kobo.22.1">In simple terms, </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">application state</span></strong><span class="koboSpan" id="kobo.24.1"> is a snapshot of the current condition (or state) of your data, configurations, and views at a specific point in time. </span><span class="koboSpan" id="kobo.24.2">Application state is the sum of all actions that are performed within your application from the moment it is loaded in the browser. </span><span class="koboSpan" id="kobo.24.3">The state is </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.25.1">a dynamic landscape that influences your application’s view, user interactions, data flow, and </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">overall functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">It’s essential to have good state management within your application so that all your components can display the correct data to the end user and you have accurate data to work with within your application code. </span><span class="koboSpan" id="kobo.27.2">Good state management prevents unintended data changes, resulting in incorrect views and operations being performed within your application code that you did not intend </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">to perform.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">Now that you have an idea of what application state is and why you need it, let’s dive deeper, starting with the different levels of </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">application state.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.31.1">Different levels of application state</span></h2>
<p><span class="koboSpan" id="kobo.32.1">In the realm of frontend </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.33.1">development, we can distinguish between two levels of state: global and local state. </span><span class="koboSpan" id="kobo.33.2">In this section, we’ll delve into the nuanced distinction between global and local application states within the context of Angular, shedding light on their roles in crafting robust and maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">frontend applications.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">As their names imply, </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">local state</span></strong><span class="koboSpan" id="kobo.37.1"> is localized to</span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.38.1"> a file, component, or element within your application, whereas </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">global state</span></strong><span class="koboSpan" id="kobo.40.1"> is shared through your entire application. </span><span class="koboSpan" id="kobo.40.2">The global application state serves </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.41.1">as the central repository for shared information across various components, ensuring coherence and synchronicity in the application’s behavior. </span><span class="koboSpan" id="kobo.41.2">On the other hand, the local application state encapsulates the internal data and configuration specific to individual Angular components </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">and services.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">By understanding the dual nature of global and local states, your Angular applications can strike a harmonious balance between reusability, encapsulation, and shared data integrity. </span><span class="koboSpan" id="kobo.43.2">Let’s start by diving a bit deeper into the local application state within </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">Angular applications.</span></span></p>
<h3><span class="koboSpan" id="kobo.45.1">Local application state</span></h3>
<p><span class="koboSpan" id="kobo.46.1">When we refer to local state, we’re talking about properties that have been localized to a component or service that determine</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.47.1"> how that component or service behaves and presents data to your</span><a id="_idIndexMarker746"/> <span class="No-Break"><span class="koboSpan" id="kobo.48.1">application’s user.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">A simple example of a local state would be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">Counter</span></strong><span class="koboSpan" id="kobo.51.1"> component with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">count</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.53.1"> state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.54.1">
export class Counter {
  count = signal(0);
  add() { this.count.update((count) =&gt; count + 1) }
  subtract() { this.count.update((count) =&gt; count - 1) }
}</span></pre> <p><span class="koboSpan" id="kobo.55.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">count</span></strong><span class="koboSpan" id="kobo.57.1"> property is used to display the current count to the user. </span><span class="koboSpan" id="kobo.57.2">The declaration and update behavior of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">count</span></strong><span class="koboSpan" id="kobo.59.1"> property is handled locally within the </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">current component.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Within components, you can consider the state as local when the stateful property isn’t shared between multiple smart components and doesn’t need to be persisted when you navigate from one page </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">to another.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Within services, the state can be considered local whenever it entails a private property that isn’t shared with the outside world, and the property doesn’t have to persist longer than the life cycle of the service file. </span><span class="koboSpan" id="kobo.63.2">If the property doesn’t meet these criteria, you probably need to locate it somewhere within your global </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">application state.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">Here are some common examples of local state within </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">Angular applications:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.67.1">Disabled </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">button state</span></span></li>
<li><span class="koboSpan" id="kobo.69.1">Form </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">validity state</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.71.1">Modal visibility</span></span></li>
<li><span class="koboSpan" id="kobo.72.1">Sorting </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">and filtering</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.74.1">Accordion state</span></span></li>
<li><span class="koboSpan" id="kobo.75.1">Selected </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">tab state</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.77.1">You now have a good understanding of local state. </span><span class="koboSpan" id="kobo.77.2">You know what local state is, how you can recognize it, and what the preferred tool is to handle local state within your Angular applications. </span><span class="koboSpan" id="kobo.77.3">You also</span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.78.1"> learned about some common examples of local state. </span><span class="koboSpan" id="kobo.78.2">Next, you will learn about global </span><a id="_idIndexMarker748"/><span class="No-Break"><span class="koboSpan" id="kobo.79.1">application state.</span></span></p>
<h3><span class="koboSpan" id="kobo.80.1">Global application state</span></h3>
<p><span class="koboSpan" id="kobo.81.1">In contrast to local state, global application state refers to the data and configurations you share across multiple components </span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.82.1">and services within an Angular application. </span><span class="koboSpan" id="kobo.82.2">You </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.83.1">can think of your global application state as a centralized repository for your data. </span><span class="koboSpan" id="kobo.83.2">This centralized repository of information is pivotal in ensuring consistency, synchronization, and efficient communication between various </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">application parts.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">Unlike local state, which is confined to a specific component or service, global application state persists throughout the entire application, making it particularly useful for scenarios where data needs to be shared and synchronized across different components and services, as well as during the whole </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">user session.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">Within Angular application, global state is commonly handled inside services. </span><span class="koboSpan" id="kobo.87.2">By creating a service dedicated to managing global state, developers can ensure that components have a centralized access point to crucial information. </span><span class="koboSpan" id="kobo.87.3">Services that contain global application state are often named </span><em class="italic"><span class="koboSpan" id="kobo.88.1">stores</span></em><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">For example, you can call the service to store global user state </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">user.store.ts</span></strong><span class="koboSpan" id="kobo.91.1"> with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">UserStore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.93.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Within smaller Angular applications, state is commonly managed using </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">Subjects</span></strong><span class="koboSpan" id="kobo.96.1">. </span><span class="koboSpan" id="kobo.96.2">More specifically, </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.98.1"> stores and distributes stateful properties, and the regular </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">Subject</span></strong><span class="koboSpan" id="kobo.100.1"> distributes global events. </span><span class="koboSpan" id="kobo.100.2">With the introduction of Signals, some </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.102.1"> classes can be replaced with Signals. </span><span class="koboSpan" id="kobo.102.2">We will see this in detail in the </span><em class="italic"><span class="koboSpan" id="kobo.103.1">Handling global application state using RxJS</span></em><span class="koboSpan" id="kobo.104.1"> section when we start building global </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">state management.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">For larger Angular applications, libraries such as NgRx, NgXs, Akita, and Angular Query are the preferred methods for handling global state. </span><span class="koboSpan" id="kobo.106.2">These libraries enhance your capabilities to manage the states gracefully and implement structured and battle-tested design patterns for managing and updating the global state in a predictable and </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">scalable manner.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">Understanding when to utilize the global application state is crucial. </span><span class="koboSpan" id="kobo.108.2">A global state might be more appropriate if a stateful property needs to be shared across multiple smart components or persists beyond a</span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.109.1"> single component’s life cycle. </span><span class="koboSpan" id="kobo.109.2">Now that you know what local and global state are, when to use which, and what tools are available to manage both gracefully, let’s </span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.110.1">learn about some important concepts within </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">state management.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.112.1">Fundamental concepts within state management</span></h2>
<p><span class="koboSpan" id="kobo.113.1">To build a robust state management system within your Angular applications, you need to understand the fundamental concepts of state management. </span><span class="koboSpan" id="kobo.113.2">You need to know these concepts, why they are essential, and the dangers of not </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">using them.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">In this section, we will learn about unidirectional data flow, immutability, and side effects. </span><span class="koboSpan" id="kobo.115.2">Other important </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.116.1">fundamentals for state management include reactivity and design patterns such as the Redux pattern, but we already discussed both in </span><em class="italic"><span class="koboSpan" id="kobo.117.1">Chapters 6</span></em><span class="koboSpan" id="kobo.118.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.119.1">7</span></em><span class="koboSpan" id="kobo.120.1">, so we won’t dive deeper </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">into this.</span></span></p>
<h3><span class="koboSpan" id="kobo.122.1">Unidirectional data flow</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.123.1">Unidirectional data flow</span></strong><span class="koboSpan" id="kobo.124.1"> is the first concept </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.125.1">of state management we will discuss. </span><span class="koboSpan" id="kobo.125.2">As its name suggests, the concept states that data </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.126.1">should only flow in one direction throughout your application. </span><span class="koboSpan" id="kobo.126.2">Changes to the data occur through well-defined actions or events, ensuring a clear and predictable flow of information. </span><span class="koboSpan" id="kobo.126.3">Unidirectional data flow simplifies debugging, makes code more predictable, and enhances maintainability. </span><span class="koboSpan" id="kobo.126.4">It prevents unexpected side effects by enforcing a clear flow of data through </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">Without unidirectional data flow, tracing the origin of state changes becomes challenging, leading to debugging difficulties and potential issues with data consistency. </span><span class="koboSpan" id="kobo.128.2">Uncontrolled data flow can result in unpredictable behavior, especially in large and </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">complex applications.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">The concept of unidirectional data flow is important throughout your entire application and for both local and global application state. </span><span class="koboSpan" id="kobo.130.2">For the global application state, I recommend always having a unidirectional data flow. </span><span class="koboSpan" id="kobo.130.3">Within the local component state, you can sometimes make an exception by using Angular two-way </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">data binding.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">To help you understand how unidirectional data flow looks in an Angular application, here’s an example </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">of flow:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.134.1">The state is passed from the store to the</span><a id="_idIndexMarker756"/> <span class="No-Break"><span class="koboSpan" id="kobo.135.1">facade service.</span></span></li>
<li><span class="koboSpan" id="kobo.136.1">The state is passed from the facade service to the </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">smart component.</span></span></li>
<li><span class="koboSpan" id="kobo.138.1">The smart component passes the data to the (dumb) </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">child components.</span></span></li>
<li><span class="koboSpan" id="kobo.140.1">The view is rendered based on the state of the smart component and its </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">child components.</span></span></li>
<li><span class="koboSpan" id="kobo.142.1">An action can be</span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.143.1"> triggered in </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">the view.</span></span></li>
<li><span class="koboSpan" id="kobo.145.1">The event of the action and the related data move from the (dumb) child component up to the </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">smart component.</span></span></li>
<li><span class="koboSpan" id="kobo.147.1">The smart component or facade dispatches an action to </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">the store.</span></span></li>
<li><span class="koboSpan" id="kobo.149.1">The store updates the state based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">dispatched action.</span></span></li>
<li><span class="koboSpan" id="kobo.151.1">The state is passed from the store to </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">the facade.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.153.1">As you can see, the data starts in the store and flows in one direction until the view can be rendered. </span><span class="koboSpan" id="kobo.153.2">When the user triggers an action within the view, the data flows in one direction and in a predictable manner back into the store until we reach full circle. </span><span class="koboSpan" id="kobo.153.3">Now that you know what unidirectional data flow is and why it’s important in state management, let’s learn </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">about immutability.</span></span></p>
<h3><span class="koboSpan" id="kobo.155.1">Immutability</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.156.1">Immutability</span></strong><span class="koboSpan" id="kobo.157.1"> involves the practice of not modifying existing data structures directly. </span><span class="koboSpan" id="kobo.157.2">Instead, new copies are created with the desired changes, preserving the integrity of the original data. </span><span class="koboSpan" id="kobo.157.3">Immutability simplifies </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.158.1">state management by providing a single place to mutate your state. </span><span class="koboSpan" id="kobo.158.2">It helps prevent unintended state changes and side effects and is particularly valuable when you’re tracking and managing complex state in </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">Angular applications.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">With immutability, you may find it easier to track state changes and keep your state synchronized. </span><span class="koboSpan" id="kobo.160.2">Directly modifying state objects can lead to bugs and unexpected behavior. </span><span class="koboSpan" id="kobo.160.3">Immutability was mainly used within global state management, but with the introduction of Signals, it’s now also applied within the local state of </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">Angular applications.</span></span></p>
<h3><span class="koboSpan" id="kobo.162.1">Side effects</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.163.1">Side effects</span></strong><span class="koboSpan" id="kobo.164.1"> refer to an operation or changes you perform when a specific piece of your state changes. </span><span class="koboSpan" id="kobo.164.2">Side effects can</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.165.1"> include things such as </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.167.1">Fetching data</span></span></li>
<li><span class="koboSpan" id="kobo.168.1">Updating the </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">local storage</span></span></li>
<li><span class="koboSpan" id="kobo.170.1">Dispatching </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">additional actions</span></span></li>
<li><span class="koboSpan" id="kobo.172.1">Setting </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">local variables</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.174.1">By isolating side effects, you can maintain a clear separation of concerns in your application. </span><span class="koboSpan" id="kobo.174.2">The core application logic (reducers, actions, and selectors) remains focused on state changes, while side effects are handled separately. </span><span class="koboSpan" id="kobo.174.3">Side effects are natively introduced in the Angular framework within the Signals API, and they are used in popular state management libraries such as NgRx </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">and NgXs.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">So, to summarize, there is local and global state within your applications. </span><span class="koboSpan" id="kobo.176.2">Local state is localized to components or services, whereas global state affects the entire application. </span><span class="koboSpan" id="kobo.176.3">Some of the fundamental concepts of state management are unidirectional data flow, immutability, and side effects. </span><span class="koboSpan" id="kobo.176.4">You learned about the advantages of these concepts and why they are important for a state management solution. </span><span class="koboSpan" id="kobo.176.5">You also learned what state management is and why you need it within </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">your applications.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">In the next section, you will start building a global state management solution and create a facade service to access the state from within your </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">smart components.</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.180.1">Handling global application state using RxJS</span></h1>
<p><span class="koboSpan" id="kobo.181.1">In this section, you will create a simple state management solution using RxJS. </span><span class="koboSpan" id="kobo.181.2">At the core of this state management solution lies the RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.183.1"> class. </span><span class="koboSpan" id="kobo.183.2">You will also create a facade service to interact with the state </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">management solution.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">The facade will do all the</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.186.1"> communication with the state management solution and the smart components. </span><span class="koboSpan" id="kobo.186.2">This decouples our smart components from the state </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.187.1">management solution, making it easy to swap our state management implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">when needed.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">Once we’ve created the RxJS state management solution and connected it with the component layer of the application, we can change the state management and facade to use Signals where it is possible and </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">makes sense.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">By converting the state management solution from RxJS into Signals, you’ll be able to understand both concepts and learn about the differences. </span><span class="koboSpan" id="kobo.191.2">Building both approaches will also serve you best so that you can recognize and work with both systems when you encounter them in a project </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.192.1">you join. </span><span class="koboSpan" id="kobo.192.2">Let’s start by building the RxJS state </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">management solution.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.194.1">Building a state management solution using RxJS</span></h2>
<p><span class="koboSpan" id="kobo.195.1">To start building the state </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.196.1">management solution, create a folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">stores</span></strong><span class="koboSpan" id="kobo.198.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">data-access</span></strong><span class="koboSpan" id="kobo.200.1"> library of the finance domain. </span><span class="koboSpan" id="kobo.200.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">stores</span></strong><span class="koboSpan" id="kobo.202.1"> folder should be located inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">lib</span></strong><span class="koboSpan" id="kobo.204.1"> folder, at the same level as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">adapters</span></strong><span class="koboSpan" id="kobo.206.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">HTTP</span></strong><span class="koboSpan" id="kobo.208.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">models</span></strong><span class="koboSpan" id="kobo.210.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">services</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.212.1"> folders.</span></span></p>
<h3><span class="koboSpan" id="kobo.213.1">Creating a service</span></h3>
<p><span class="koboSpan" id="kobo.214.1">First, you can create a service by </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.215.1">using the </span><em class="italic"><span class="koboSpan" id="kobo.216.1">Nx generator</span></em><span class="koboSpan" id="kobo.217.1"> in the newly created </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">stores</span></strong><span class="koboSpan" id="kobo.219.1"> folder. </span><span class="koboSpan" id="kobo.219.2">Name the new service </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">expenses.store</span></strong><span class="koboSpan" id="kobo.221.1">. </span><span class="koboSpan" id="kobo.221.2">Because we’re using the Nx generator, it will create a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">expenses.store.service.ts</span></strong><span class="koboSpan" id="kobo.223.1">; you can remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">.service</span></strong><span class="koboSpan" id="kobo.225.1"> part manually and do the same for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">spec</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">Next, rename the class </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">ExpensesStore</span></strong><span class="koboSpan" id="kobo.230.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">ExpensesStoreService</span></strong><span class="koboSpan" id="kobo.232.1"> and remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">constructor</span></strong><span class="koboSpan" id="kobo.234.1">; this should be in your file when </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">you’re ready:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.236.1">
@Injectable({ providedIn: 'root' })
export class ExpensesStore {}</span></pre> <p><span class="koboSpan" id="kobo.237.1">Next, you need something that can hold the state for your list of expenses. </span><span class="koboSpan" id="kobo.237.2">We will use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.239.1"> class that will emit an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">ExpenseModel</span></strong><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.243.1"> class will be a </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.244.1">private property, so you cannot directly mutate the state from outside our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">ExpensesStore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.246.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">Only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">ExpenseStore</span></strong><span class="koboSpan" id="kobo.249.1"> class should be able to mutate the state directly; all other parts of the application should mutate it through </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">ExpenseStore</span></strong><span class="koboSpan" id="kobo.251.1"> and, more precisely, through the facade, which will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">ExpenseStore</span></strong><span class="koboSpan" id="kobo.253.1">. </span><span class="koboSpan" id="kobo.253.2">Allowing the state to be directly mutated from other parts of your application can lead to unintended state mutations, breaking </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">Because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.257.1"> class is private, you also need a public property that exposes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.259.1"> class to the outside world as </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">an Observable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.261.1">
private expenses = new BehaviorSubject&lt;ExpenseModel[]&gt;([]);
expenses$ = this.expenses.asObservable();</span></pre> <p><span class="koboSpan" id="kobo.262.1">As you can see, we first defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">expenses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.264.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.265.1"> class, and we created the public </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">expenses$</span></strong><span class="koboSpan" id="kobo.267.1"> Observable by taking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">expenses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.269.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.270.1"> class and calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">asObservable()</span></strong><span class="koboSpan" id="kobo.272.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.274.1"> class. </span><span class="koboSpan" id="kobo.274.2">We gave the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">expenses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.276.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.277.1"> class an empty array as its default value. </span><span class="koboSpan" id="kobo.277.2">Next, let’s add some logic to fetch and distribute </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">our data.</span></span></p>
<h3><span class="koboSpan" id="kobo.279.1">Fetching and distributing data in our store</span></h3>
<p><span class="koboSpan" id="kobo.280.1">Next, we’ll add some logic to </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.281.1">make an API request that retrieves the expenses and emits the received expenses through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.283.1"> class. </span><span class="koboSpan" id="kobo.283.2">To achieve this, start by injecting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">ExpensesHttpService</span></strong><span class="koboSpan" id="kobo.285.1"> class we created in </span><a href="B21625_06.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.286.1">Chapter 6</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.287.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.288.1">
protected expensesApi = inject(ExpensesHttpService);</span></pre> <p><span class="koboSpan" id="kobo.289.1">Next, you need to create a method to make the API request and update the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">BehaviorSubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.291.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.292.1">
fetchExpenses(): void {
  this.expensesApi.get().subscribe({
    next: (expenses) =&gt; { this.expenses.next(expenses) },
    error: (err) =&gt; { console.log(‹err ==&gt;›, err) }
  });
}</span></pre> <p><span class="koboSpan" id="kobo.293.1">As you can see, we made a method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.295.1">, and inside this method, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">expensesApi</span></strong><span class="koboSpan" id="kobo.297.1"> to make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">get</span></strong><span class="koboSpan" id="kobo.299.1"> request. </span><span class="koboSpan" id="kobo.299.2">We subscribed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">get</span></strong><span class="koboSpan" id="kobo.301.1"> request and handled the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">next</span></strong><span class="koboSpan" id="kobo.303.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">error</span></strong><span class="koboSpan" id="kobo.305.1"> events of the subscription. </span><span class="koboSpan" id="kobo.305.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">next</span></strong><span class="koboSpan" id="kobo.307.1"> error is handled when the</span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.308.1"> subscription of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">get</span></strong><span class="koboSpan" id="kobo.310.1"> request receives a response, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">error</span></strong><span class="koboSpan" id="kobo.312.1"> event is handled whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">get</span></strong><span class="koboSpan" id="kobo.314.1"> request fails and returns with an </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">error status.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">If the API request responds successfully, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">next()</span></strong><span class="koboSpan" id="kobo.318.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">expenses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.320.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.321.1"> class and give it the received </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">expenses</span></strong><span class="koboSpan" id="kobo.323.1"> as a parameter. </span><span class="koboSpan" id="kobo.323.2">If the API responds with an error, we simply log the error. </span><span class="koboSpan" id="kobo.323.3">In a production application, you should handle this better and alert the user with a toaster message or </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">something similar.</span></span></p>
<h3><span class="koboSpan" id="kobo.325.1">Adding additional expense methods</span></h3>
<p><span class="koboSpan" id="kobo.326.1">Next, you’ll want to add methods to get an expense by ID, as well as update, delete, and add expenses. </span><span class="koboSpan" id="kobo.326.2">Before you create these </span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.327.1">methods, </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">MockInterceptor</span></strong><span class="koboSpan" id="kobo.329.1"> must be adjusted to handle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">delete</span></strong><span class="koboSpan" id="kobo.331.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">getByID</span></strong><span class="koboSpan" id="kobo.333.1"> requests. </span><span class="koboSpan" id="kobo.333.2">You can modify the interceptor yourself or get the adjusted </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">MockInterceptor</span></strong><span class="koboSpan" id="kobo.335.1"> from this book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">repository: </span></span><a href="https://github.com/PacktPublishing/Effective-Angular"><span class="No-Break"><span class="koboSpan" id="kobo.337.1">https://github.com/PacktPublishing/Effective-Angular</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.338.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">After adjusting </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">MockInterceptor</span></strong><span class="koboSpan" id="kobo.341.1">, you can start to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">add</span></strong><span class="koboSpan" id="kobo.343.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">delete</span></strong><span class="koboSpan" id="kobo.345.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">update</span></strong><span class="koboSpan" id="kobo.347.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">getByID</span></strong><span class="koboSpan" id="kobo.349.1"> methods in our expenses store. </span><span class="koboSpan" id="kobo.349.2">Inside all these methods, we need access to the current list of expenses. </span><span class="koboSpan" id="kobo.349.3">You can access the current list of expenses through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">value</span></strong><span class="koboSpan" id="kobo.351.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">expenses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.353.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.354.1"> class. </span><span class="koboSpan" id="kobo.354.2">Let’s create a getter that retrieves the current expenses from </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">our state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.356.1">
private get currentExpenses() {return this.expenses.value}</span></pre> <p><span class="koboSpan" id="kobo.357.1">Now, we can start adding </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">the methods.</span></span></p>
<h4><span class="koboSpan" id="kobo.359.1">Adding expenses</span></h4>
<p><span class="koboSpan" id="kobo.360.1">Let’s start by creating a</span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.361.1"> method to add </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">an expense:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.363.1">
addExpense(expense: ExpenseModel): void {
  this.expensesApi.post(expense).subscribe({
    next: (addedExpense) =&gt; {
      addedExpense.id = !addedExpense.id ? </span><span class="koboSpan" id="kobo.363.2">this.currentExpenses.length + 1 : addedExpense.id;
      this.expenses.next([...this.currentExpenses, addedExpense]);
    },
    error: (err) =&gt; { console.log(‹err ==&gt;›, err) }
  })
}</span></pre> <p><span class="koboSpan" id="kobo.364.1">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">addExpense</span></strong><span class="koboSpan" id="kobo.366.1"> code takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">expense</span></strong><span class="koboSpan" id="kobo.368.1"> as a function parameter. </span><span class="koboSpan" id="kobo.368.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">expense</span></strong><span class="koboSpan" id="kobo.370.1"> parameter is used to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">POST</span></strong><span class="koboSpan" id="kobo.372.1"> request </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">expenseApi</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">When the API returns with the response, we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">ID</span></strong><span class="koboSpan" id="kobo.378.1"> property (we’re only updating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">ID</span></strong><span class="koboSpan" id="kobo.380.1"> property because we don’t have an actual backend. </span><span class="koboSpan" id="kobo.380.2">Normally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">ID</span></strong><span class="koboSpan" id="kobo.382.1"> would be populated by the backend). </span><span class="koboSpan" id="kobo.382.2">After updating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">ID</span></strong><span class="koboSpan" id="kobo.384.1"> property, we add the newly created </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">expense</span></strong><span class="koboSpan" id="kobo.386.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">expenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.388.1"> state.</span></span></p>
<h4><span class="koboSpan" id="kobo.389.1">Deleting expenses</span></h4>
<p><span class="koboSpan" id="kobo.390.1">After creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">addExpense</span></strong><span class="koboSpan" id="kobo.392.1"> method, you can</span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.393.1"> make a method to delete </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">an expense:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.395.1">
deleteExpense(id: number): void {
  this.expensesApi.delete(id).subscribe({
    next: () =&gt; {
      this.expenses.next(this.currentExpenses.filter(expense =&gt; expense.id !== id));
    },
    error: (err) =&gt; { console.log(‹err ==&gt;›, err) }
  })
}</span></pre> <p><span class="koboSpan" id="kobo.396.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">delete</span></strong><span class="koboSpan" id="kobo.398.1"> method is pretty</span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.399.1"> straightforward. </span><span class="koboSpan" id="kobo.399.2">We make the API request, and when the API responds, we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">expenses</span></strong><span class="koboSpan" id="kobo.401.1"> state with the new list of expenses by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">next()</span></strong><span class="koboSpan" id="kobo.403.1"> method. </span><span class="koboSpan" id="kobo.403.2">As a parameter for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">next()</span></strong><span class="koboSpan" id="kobo.405.1"> method, we use the current list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">expenses</span></strong><span class="koboSpan" id="kobo.407.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">filter</span></strong><span class="koboSpan" id="kobo.409.1"> out the deleted expenses. </span><span class="koboSpan" id="kobo.409.2">If the API responds with an error, we log the error, again in a production application, and we show some sort of message to </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">the user.</span></span></p>
<h4><span class="koboSpan" id="kobo.411.1">Fetching, getting, and selecting expenses</span></h4>
<p><span class="koboSpan" id="kobo.412.1">After adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">delete</span></strong><span class="koboSpan" id="kobo.414.1"> method, we </span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.415.1">will add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">getExpense</span></strong><span class="koboSpan" id="kobo.417.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">selectExpense</span></strong><span class="koboSpan" id="kobo.419.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">fetchExpenseById</span></strong><span class="koboSpan" id="kobo.421.1"> methods. </span><span class="koboSpan" id="kobo.421.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">getExpense</span></strong><span class="koboSpan" id="kobo.423.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">selectExpense</span></strong><span class="koboSpan" id="kobo.425.1"> methods will be public methods, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">fetchExpenseById</span></strong><span class="koboSpan" id="kobo.427.1"> will be private. </span><span class="koboSpan" id="kobo.427.2">We will also create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">expense</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.429.1">Subject</span></strong><span class="koboSpan" id="kobo.430.1"> class</span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.431.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">selectedExpense</span></strong><span class="koboSpan" id="kobo.433.1"> state using a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">BehaviorSubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.435.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">Let’s start by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">Subject</span></strong><span class="koboSpan" id="kobo.438.1"> class</span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.439.1"> and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">selectedExpense</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.441.1"> state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
private expense: Subject&lt;ExpenseModel&gt; = new Subject();
expense$: Observable&lt;ExpenseModel&gt; = this.expense.asObservable();
private selectedExpense: BehaviorSubject&lt;ExpenseModel | null&gt; = new BehaviorSubject&lt;ExpenseModel | null&gt;(null);
selectedExpense$ = this.selectedExpense.asObservable();</span></pre> <p><span class="koboSpan" id="kobo.443.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">expense</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.445.1">Subject</span></strong><span class="koboSpan" id="kobo.446.1"> class and </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">selectedExpense</span></strong><span class="koboSpan" id="kobo.448.1"> state can be used to retrieve the selected expense reactively. </span><span class="koboSpan" id="kobo.448.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">selectedExpense</span></strong><span class="koboSpan" id="kobo.450.1"> state is used when you need to persist the selection in your global application state. </span><span class="koboSpan" id="kobo.450.2">In contrast, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">expense Subject</span></strong><span class="koboSpan" id="kobo.452.1"> class can be used to </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.453.1">emit an expense as an event that is only received by Observers who are subscribed when the event is </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.454.1">emitted. </span><span class="koboSpan" id="kobo.454.2">After adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">expense Subject</span></strong><span class="koboSpan" id="kobo.456.1"> class and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">selectedExpense</span></strong><span class="koboSpan" id="kobo.458.1"> state, we</span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.459.1"> will continue with the private </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">fetchExpenseById</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.461.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
private fetchExpenseById(id: number, select = false) {
  this.expensesApi.getById(id).subscribe({
    next: (expense) =&gt; { select ? </span><span class="koboSpan" id="kobo.462.2">this.selectedExpense.next(expense) : this.expense.next(expense) },
    error: (err) =&gt; { console.log(‹err ==&gt;›, err) }
  })
}</span></pre> <p><span class="koboSpan" id="kobo.463.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">fetchExpenseById</span></strong><span class="koboSpan" id="kobo.465.1"> method has </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">id</span></strong><span class="koboSpan" id="kobo.467.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">select</span></strong><span class="koboSpan" id="kobo.469.1"> parameters. </span><span class="koboSpan" id="kobo.469.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">id</span></strong><span class="koboSpan" id="kobo.471.1"> parameter is required, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">select</span></strong><span class="koboSpan" id="kobo.473.1"> property is optional with a default value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">false</span></strong><span class="koboSpan" id="kobo.475.1">. </span><span class="koboSpan" id="kobo.475.2">The method starts by making an API call to retrieve an expense by ID. </span><span class="koboSpan" id="kobo.475.3">When the API responds with an expense, we emit a new value using </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">expense Subject</span></strong><span class="koboSpan" id="kobo.477.1"> or emit a value and set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">selectedExpense</span></strong><span class="koboSpan" id="kobo.479.1"> state using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.481.1"> class. </span><span class="koboSpan" id="kobo.481.2">Depending on the needs of your application, you can also add the fetched expense to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">expenses</span></strong><span class="koboSpan" id="kobo.483.1"> state, but for our demo application, this </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">isn’t necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">Now, to finish up the get expense by </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">id</span></strong><span class="koboSpan" id="kobo.487.1"> logic, we need to implement the public </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">getExpense</span></strong><span class="koboSpan" id="kobo.489.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">selectExpense</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.491.1"> methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.492.1">
getExpense(id: number): void {
  const expense = this.currentExpenses.find(expense =&gt; expense.id === id);
  expense ? </span><span class="koboSpan" id="kobo.492.2">this.expense.next(expense) : this.fetchExpenseById(id);
}
selectExpense(id: number): void {
  const expense = this.currentExpenses.find(expense =&gt; expense.id === id);
  expense ? </span><span class="koboSpan" id="kobo.492.3">this.selectedExpense.next(expense) : this.fetchExpenseById(id, true);
}</span></pre> <p><span class="koboSpan" id="kobo.493.1">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">getExpense</span></strong><span class="koboSpan" id="kobo.495.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">selectExpense</span></strong><span class="koboSpan" id="kobo.497.1"> methods are very similar. </span><span class="koboSpan" id="kobo.497.2">Both methods receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">id</span></strong><span class="koboSpan" id="kobo.499.1"> as a parameter</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.500.1"> and check if the expense with the provided </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">id</span></strong><span class="koboSpan" id="kobo.502.1"> parameter can be found inside the</span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.503.1"> current </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">expenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.505.1"> state.</span></span></p>
<p><span class="koboSpan" id="kobo.506.1">When the expense is found in the</span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.507.1"> current state, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">next()</span></strong><span class="koboSpan" id="kobo.509.1"> method is called on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">expense Subject</span></strong><span class="koboSpan" id="kobo.511.1"> class or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">selectedExpense</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.513.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.514.1"> class. </span><span class="koboSpan" id="kobo.514.2">When no expense is found in the current </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">expenses</span></strong><span class="koboSpan" id="kobo.516.1"> state, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">fetchExpenseById</span></strong><span class="koboSpan" id="kobo.518.1"> method is called to get the expense from the backend; in that case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">fetchExpenseById</span></strong><span class="koboSpan" id="kobo.520.1"> method will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">expense Subject</span></strong><span class="koboSpan" id="kobo.522.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">selectedExpense BehaviorSubject</span></strong><span class="koboSpan" id="kobo.524.1"> class. </span><span class="koboSpan" id="kobo.524.2">Now that we’ve added everything to get or select an expense reactively, let’s add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">updateExpense</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.526.1"> method.</span></span></p>
<h4><span class="koboSpan" id="kobo.527.1">Updating expenses</span></h4>
<p><span class="koboSpan" id="kobo.528.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">update</span></strong><span class="koboSpan" id="kobo.530.1"> method will </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.531.1">receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">expense</span></strong><span class="koboSpan" id="kobo.533.1"> as a function parameter. </span><span class="koboSpan" id="kobo.533.2">Next, it will make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">PUT</span></strong><span class="koboSpan" id="kobo.535.1"> request using </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">expensesApi</span></strong><span class="koboSpan" id="kobo.537.1"> to update the request in the backend. </span><span class="koboSpan" id="kobo.537.2">After the API responds successfully, the method will update the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">expenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.539.1"> state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.540.1">
updateExpense(expense: ExpenseModel): void {
  this.expensesApi.put(expense).subscribe({
    next: (expense) =&gt; {
      this.expenses.next(this.currentExpenses.map(exp =&gt; exp.id === expense.id ? </span><span class="koboSpan" id="kobo.540.2">expense : exp));
    },
    error: (err) =&gt; { console.log(‹err ==&gt;›, err) }})
}</span></pre> <p><span class="koboSpan" id="kobo.541.1">As you can see, we make the </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.542.1">API request and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">next()</span></strong><span class="koboSpan" id="kobo.544.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">expenses BehaviorSubject</span></strong><span class="koboSpan" id="kobo.546.1"> to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">expenses</span></strong><span class="koboSpan" id="kobo.548.1"> state. </span><span class="koboSpan" id="kobo.548.2">As an argument for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">next()</span></strong><span class="koboSpan" id="kobo.550.1"> method, we take the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">currentExpenses</span></strong><span class="koboSpan" id="kobo.552.1"> getter and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">map()</span></strong><span class="koboSpan" id="kobo.554.1"> function to replace the </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">updated expense.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">Now that we’ve added the methods to add, update, delete, and get expenses, let’s finish up the store with some additional state and methods to reset </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">the state.</span></span></p>
<h3><span class="koboSpan" id="kobo.558.1">Extending ExpensesStore</span></h3>
<p><span class="koboSpan" id="kobo.559.1">We will start by adding an </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.560.1">additional piece of state to manage whether we show prices, including or excluding VAT. </span><span class="koboSpan" id="kobo.560.2">We can do this by creating a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.562.1"> class and a method to adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">BehaviorSubject</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.564.1">class’ value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.565.1">
private inclVat = new BehaviorSubject&lt;boolean&gt;(false);
inclVat$ = this.inclVat.asObservable();
adjustVat(): void {
  this.inclVat.next(!this.inclVat.value);
}</span></pre> <p><span class="koboSpan" id="kobo.566.1">As you can see, the VAT state is just a simple Boolean indicating whether we show the prices, including or </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">excluding VAT.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">Lastly, we need some logic to reset our application state and clear the selected product state. </span><span class="koboSpan" id="kobo.568.2">We will create two different methods for this </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">resetState</span></strong><span class="koboSpan" id="kobo.570.1"> to reset all the states to the default values. </span><span class="koboSpan" id="kobo.570.2">We’ll use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">clearExpenseSelection</span></strong><span class="koboSpan" id="kobo.572.1"> method to clear the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">selectedExpense</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.574.1"> state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.575.1">
clearExpenseSelection(): void {
  this.selectedExpense.next(null);
}
resetState(): void {
  this.expenses.next([]);
  this.selectedExpense.next(null);
  this.inclVat.next(false);
}</span></pre> <p><span class="koboSpan" id="kobo.576.1">This was the last piece of the puzzle for our expense store. </span><span class="koboSpan" id="kobo.576.2">You created a simple yet effective state management solution to handle the global application state of the expenses. </span><span class="koboSpan" id="kobo.576.3">You did so using the RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">Subject</span></strong><span class="koboSpan" id="kobo.578.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.580.1"> classes. </span><span class="koboSpan" id="kobo.580.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">ExpensesStore</span></strong><span class="koboSpan" id="kobo.582.1"> can now be used as the single source of truth for all your expense data throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">If a component needs the </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.585.1">current state of some expense data, it will come from this </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">ExpensesStore</span></strong><span class="koboSpan" id="kobo.587.1">. </span><span class="koboSpan" id="kobo.587.2">When your application grows, and you have other entities with a state besides the expenses, such as users, reports, or settings, each entity will have a store file to manage the state of </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">that entity.</span></span></p>
<p><span class="koboSpan" id="kobo.589.1">Now that you’ve created a state management solution using RxJS, we will start building the facade service and connect the view layer with the store through </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">the facade.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.591.1">Connecting your state management and view layer with a facade service</span></h2>
<p><span class="koboSpan" id="kobo.592.1">Now that you have a state management</span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.593.1"> solution in place, it’s time to connect it to the view layer of your application. </span><span class="koboSpan" id="kobo.593.2">As mentioned several times in this book, the best approach is to create a facade service for this. </span><span class="koboSpan" id="kobo.593.3">This facade provides an additional layer of abstraction, providing a simple interface for your view layer to interact with the application state. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.594.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.595.1">.1</span></em><span class="koboSpan" id="kobo.596.1"> provides a visual representation of the facade service and how data flows from your state through the facade into </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">your components:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.598.1"><img alt="Figure 8.1: Data flow with a facade, components, and state" src="image/B21625_08_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.599.1">Figure 8.1: Data flow with a facade, components, and state</span></p>
<p><span class="koboSpan" id="kobo.600.1">As you can see, your components make a simple request to the facade service, and the facade will collect the data from your different state services and send it back to the component in the format that the</span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.601.1"> component needs. </span><span class="koboSpan" id="kobo.601.2">This ensures your components only have one dependency and your facade will host all other necessary dependencies to retrieve the data you need in </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">your components.</span></span></p>
<h3><span class="koboSpan" id="kobo.603.1">Creating a facade service</span></h3>
<p><span class="koboSpan" id="kobo.604.1">Start by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">facades</span></strong><span class="koboSpan" id="kobo.606.1"> folder inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">lib</span></strong><span class="koboSpan" id="kobo.608.1"> folder of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">expenses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.610.1">data-access</span></strong><span class="koboSpan" id="kobo.611.1"> library. </span><span class="koboSpan" id="kobo.611.2">The new </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">facades</span></strong><span class="koboSpan" id="kobo.613.1"> folder will be</span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.614.1"> located in the same folder as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">store</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.616.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">Inside the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">facades</span></strong><span class="koboSpan" id="kobo.619.1"> folder, you must create a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">expenses.facade.ts</span></strong><span class="koboSpan" id="kobo.621.1"> with an injectable class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">ExpensesFacade</span></strong><span class="koboSpan" id="kobo.623.1">. </span><span class="koboSpan" id="kobo.623.2">You can use the Nx generator to create a service and rename it or create the facade manually. </span><span class="koboSpan" id="kobo.623.3">Also, add an export inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">index.ts</span></strong><span class="koboSpan" id="kobo.625.1"> file so that you can consume the facade outside </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">the library.</span></span></p>
<p><span class="koboSpan" id="kobo.627.1">When you’re finished, you </span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.628.1">should have the following in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">expenses.facade.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.630.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.631.1">
@Injectable({ providedIn: 'root' })
export class ExpensesFacade {}</span></pre> <h3><span class="koboSpan" id="kobo.632.1">Creating the facade interface</span></h3>
<p><span class="koboSpan" id="kobo.633.1">Next, create a file next to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">expenses.facade.ts</span></strong><span class="koboSpan" id="kobo.635.1"> file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">expensesFacade.interface.ts</span></strong><span class="koboSpan" id="kobo.637.1">. </span><span class="koboSpan" id="kobo.637.2">In this interface, we will declare the blueprint of our facade. </span><span class="koboSpan" id="kobo.637.3">So long as your</span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.638.1"> facade implements this interface, you can switch the implementation of the state without touching the component layer. </span><span class="koboSpan" id="kobo.638.2">If you change the interface, you also need to adjust the </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">component layer.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">In the interface file, declare the </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">following interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.642.1">
export interface IExpensesFacade {
  expenseSelector$: Observable&lt;ExpenseModel&gt;;
  selectedExpenseSelector$: Observable&lt;ExpenseModel&gt;;
  inclVatSelector$: Observable&lt;boolean&gt;;
  addExpense(expense: ExpenseModel): void;
  adjustVat(): void;
  clearExpenseSelection(): void;
  deleteExpense(id: number): void;
  fetchExpenses(): void;
  getExpense(id: number): void;
  getExpenses(id: number): Observable&lt;ExpensesViewModel&gt;;
  resetExpenseState(): void;
  selectExpense(id: number): void;
  updateExpense(expense: ExpenseModel): void;
}</span></pre> <p><span class="koboSpan" id="kobo.643.1">After defining the interface, we</span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.644.1"> can start with the facade service. </span><span class="koboSpan" id="kobo.644.2">Start by implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">the interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.646.1">
export class ExpensesFacade implements IExpensesFacade {…}</span></pre> <p><span class="koboSpan" id="kobo.647.1">Now, you want to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">ExpensesStore</span></strong><span class="koboSpan" id="kobo.649.1"> inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">facade service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.651.1">
protected readonly expensesStore = inject(ExpensesStore);</span></pre> <p><span class="koboSpan" id="kobo.652.1">Now that we’ve injected the store, we will add a method to fetch </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">the expenses.</span></span></p>
<h3><span class="koboSpan" id="kobo.654.1">Connecting the facade with the store</span></h3>
<p><span class="koboSpan" id="kobo.655.1">Let’s add a simple</span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.656.1"> method to the facade that simply calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">fetch</span></strong><span class="koboSpan" id="kobo.658.1"> method inside </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">the store:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.660.1">
fetchExpenses() {
  this.expensesStore.fetchExpenses();
}</span></pre> <p><span class="koboSpan" id="kobo.661.1">Next, we will create a method to get the fetched expenses. </span><span class="koboSpan" id="kobo.661.2">But before we do this, we will create a new interface </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">ExpensesViewModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.665.1">
export interface ExpensesViewModel {
  total: number;
  inclVat: boolean;
  expenses: ExpenseModel[];
}</span></pre> <p><span class="koboSpan" id="kobo.666.1">You can also adjust </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">ExpenseModel</span></strong><span class="koboSpan" id="kobo.668.1"> a bit and rename the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">amountExclVat</span></strong><span class="koboSpan" id="kobo.670.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">value</span></strong><span class="koboSpan" id="kobo.672.1">. </span><span class="koboSpan" id="kobo.672.2">If you’re using VS Code, you can select the property and press </span><em class="italic"><span class="koboSpan" id="kobo.673.1">F2</span></em><span class="koboSpan" id="kobo.674.1"> to rename it. </span><span class="koboSpan" id="kobo.674.2">When you rename using the </span><em class="italic"><span class="koboSpan" id="kobo.675.1">F2</span></em><span class="koboSpan" id="kobo.676.1"> key, the property will be renamed in every instance (besides the </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">HTML templates).</span></span></p>
<p><span class="koboSpan" id="kobo.678.1">Now that you’ve created </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">ExpensesViewModel</span></strong><span class="koboSpan" id="kobo.680.1"> and adjusted </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">ExpenseModel</span></strong><span class="koboSpan" id="kobo.682.1">, let’s create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">getExpenses</span></strong><span class="koboSpan" id="kobo.684.1"> method inside </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">the facade:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.686.1">
getExpenses(): Observable&lt;ExpensesViewModel&gt; {
  return combineLatest([this.expensesStore.expenses$, this.expensesStore.inclVat$]).pipe(
    distinctUntilChanged(),
    map(([expenses, inclVat]) =&gt; ({
      expenses: structuredClone(expenses).map(expense =&gt; {
        expense.amount.value = inclVat ? </span><span class="koboSpan" id="kobo.686.2">expense.amount.value * (1 + expense.amount.vatPercentage / 100) : expense.amount.value;
        return expense;
      }),
      inclVat,
      total: expenses.reduce((acc, expense) =&gt; {
        return acc + (inclVat ? </span><span class="koboSpan" id="kobo.686.3">(expense.amount.value * (1 + expense.amount.vatPercentage / 100)) : expense.amount.value);
      }, 0),
    }))
  );
}</span></pre> <p><span class="koboSpan" id="kobo.687.1">As you can see, there is quite </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.688.1">a lot going on in this method. </span><span class="koboSpan" id="kobo.688.2">This is one of the reasons why using a facade service </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">is beneficial.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">In a large application, the chances are high that you need this </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">ExpensesViewModel</span></strong><span class="koboSpan" id="kobo.692.1"> in multiple components. </span><span class="koboSpan" id="kobo.692.2">Instead of having to define this chunk of logic in multiple component classes, you can define it inside the facade, and inside the component layer, you can use a simple function call, keeping your components simple and clean. </span><span class="koboSpan" id="kobo.692.3">Also, when you need to adjust the logic, you only have to do it in this single place instead of in multiple component classes. </span><span class="koboSpan" id="kobo.692.4">Now, to better understand what we did inside the function, let’s break it down line </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">by line:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.694.1">We started by naming the method </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">getExpenses</span></strong><span class="koboSpan" id="kobo.696.1"> and specified that it would return an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">ExpensesViewModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.698.1"> Observable.</span></span></li>
<li><span class="koboSpan" id="kobo.699.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">getExpenses()</span></strong><span class="koboSpan" id="kobo.701.1"> method, we returned an Observable using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">combineLatest()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.703.1"> method.</span></span></li>
<li><span class="koboSpan" id="kobo.704.1">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.706.1">, we combined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">expenses$</span></strong><span class="koboSpan" id="kobo.708.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">inclVat$</span></strong><span class="koboSpan" id="kobo.710.1"> Observables from the store</span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.711.1"> and applied the RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">pipe()</span></strong><span class="koboSpan" id="kobo.713.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">combineLatest()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.717.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">pipe()</span></strong><span class="koboSpan" id="kobo.719.1"> function, we applied two operators, starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">distinctUntilChanged()</span></strong><span class="koboSpan" id="kobo.721.1"> operators, so that we only emitted a new value when the </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">values changed.</span></span></li>
<li><span class="koboSpan" id="kobo.723.1">Next, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">map()</span></strong><span class="koboSpan" id="kobo.725.1"> operator to map the two Observable streams </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">into </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">ExpensesViewModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.729.1">Depending on the state of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">inclVat$</span></strong><span class="koboSpan" id="kobo.731.1"> Observable, we returned the expense value properties and the total property, including or </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">excluding VAT.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.733.1">Now that you’ve created the </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">fetch-</span></strong><span class="koboSpan" id="kobo.735.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">getExpenses</span></strong><span class="koboSpan" id="kobo.737.1"> methods inside the facade, let’s adjust the expenses </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">overview page.</span></span></p>
<h3><span class="koboSpan" id="kobo.739.1">Adjusting the expenses overview page</span></h3>
<p><span class="koboSpan" id="kobo.740.1">Inside the page </span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.741.1">component, start by injecting the </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">facade service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.743.1">
protected readonly expensesFacade = inject(ExpensesFacade);</span></pre> <p><span class="koboSpan" id="kobo.744.1">After injecting the facade, you can fetch the expenses inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">ngOnInit()</span></strong><span class="koboSpan" id="kobo.746.1"> method of the </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">page component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.748.1">
ngOnInit() { this.expensesFacade.fetchExpenses() }</span></pre> <p><span class="koboSpan" id="kobo.749.1">Next, you can clean up the component. </span><span class="koboSpan" id="kobo.749.2">In </span><a href="B21625_07.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.750.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.751.1">, we used a Signal with mocked data for </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">expenses</span></strong><span class="koboSpan" id="kobo.753.1">; in this section, we will use the expenses we receive from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">getExpenses</span></strong><span class="koboSpan" id="kobo.755.1"> method inside the facade. </span><span class="koboSpan" id="kobo.755.2">Start by reassigning the </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">expenses</span></strong><span class="koboSpan" id="kobo.757.1"> property, </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.759.1">
expenses = this.expensesFacade.getExpenses();</span></pre> <p><span class="koboSpan" id="kobo.760.1">After reassigning the </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">expenses</span></strong><span class="koboSpan" id="kobo.762.1"> property, you will get some errors inside the component and template file of the expenses overview page because you don’t have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">expenses</span></strong><span class="koboSpan" id="kobo.764.1"> Signal anymore. </span><span class="koboSpan" id="kobo.764.2">Go ahead and remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">totalInclVat</span></strong><span class="koboSpan" id="kobo.766.1"> computed Signal; you can also remove the Signal effect in the component and clear out the logic inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">onAddExpense</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.768.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.769.1">Next, we need to make some adjustments to the </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">HTML template.</span></span></p>
<p><span class="koboSpan" id="kobo.771.1">Start by adding an </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">if-else</span></strong><span class="koboSpan" id="kobo.773.1"> block around the </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">HTML table:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.775.1">
@if(expenses | async; as expensesVm) {……} @else {Loading… }</span></pre> <p><span class="koboSpan" id="kobo.776.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">if</span></strong><span class="koboSpan" id="kobo.778.1"> block, you will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">expenses</span></strong><span class="koboSpan" id="kobo.780.1"> property with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">async</span></strong><span class="koboSpan" id="kobo.782.1"> pipe so that you can retrieve </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">expenses</span></strong><span class="koboSpan" id="kobo.784.1"> from</span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.785.1"> the facade and use those values within </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">the template.</span></span></p>
<p><span class="koboSpan" id="kobo.787.1">After adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">if</span></strong><span class="koboSpan" id="kobo.789.1"> block, you need to adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">for</span></strong><span class="koboSpan" id="kobo.791.1"> block inside the HTML template and switch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">expenses</span></strong><span class="koboSpan" id="kobo.793.1"> Signal for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">expenses</span></strong><span class="koboSpan" id="kobo.795.1"> property you retrieved from </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">the facade:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.797.1">
@for (expense of expensesVm.expenses; track expense.id){…}</span></pre> <p><span class="koboSpan" id="kobo.798.1">After adjusting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">for</span></strong><span class="koboSpan" id="kobo.800.1"> block, you need to adjust the table rows to correctly reflect the new model structure and to improve the UI. </span><span class="koboSpan" id="kobo.800.2">Do this by rounding the value to two decimals, and then adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">currency</span></strong><span class="koboSpan" id="kobo.802.1"> pipe and percentage (</span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">%</span></strong><span class="koboSpan" id="kobo.804.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">sign:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.806.1">
&lt;td&gt;{{ expense.amount.value.toFixed(2) | currency }}&lt;/td&gt;
&lt;td&gt;{{ expense.amount.vatPercentage }}%&lt;/td&gt;</span></pre> <p><span class="koboSpan" id="kobo.807.1">Lastly, you need to switch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">totalInclVat</span></strong><span class="koboSpan" id="kobo.809.1"> computed Signal we used inside the template for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">total</span></strong><span class="koboSpan" id="kobo.811.1"> property </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">expensesVm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.815.1">
&lt;td&gt;Total: {{expensesVm.total}}&lt;/td&gt;</span></pre> <p><span class="koboSpan" id="kobo.816.1">Here, we adjusted the text to </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">total</span></strong><span class="koboSpan" id="kobo.818.1"> because we now show the total, including or excluding VAT, depending on the global state. </span><span class="koboSpan" id="kobo.818.2">After making these adjustments, you should see the total amount and expenses inside the table again, only now using RxJS and the global state instead of the Signals with </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">mocked </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">expenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.822.1">Next, you want something to toggle the VAT so that you can see the expenses and total amount being automatically updated when the VAT </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">status changes.</span></span></p>
<p><span class="koboSpan" id="kobo.824.1">Start by adding a new method inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">facade service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.826.1">
adjustVat() { this.expensesStore.adjustVat() }</span></pre> <p><span class="koboSpan" id="kobo.827.1">As you can see, this is just a simple method calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">adjustVat</span></strong><span class="koboSpan" id="kobo.829.1"> method inside the store. </span><span class="koboSpan" id="kobo.829.2">This will change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">inclVat</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.831.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.832.1"> class inside the store. </span><span class="koboSpan" id="kobo.832.2">This, in turn, will trigger the </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.834.1"> method we used inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">getExpenses</span></strong><span class="koboSpan" id="kobo.836.1"> method inside </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">the facade.</span></span></p>
<p><span class="koboSpan" id="kobo.838.1">So, when you change the VAT</span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.839.1"> status, </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">ExpensesViewModel</span></strong><span class="koboSpan" id="kobo.841.1">, which we retrieved through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">getExpenses</span></strong><span class="koboSpan" id="kobo.843.1"> method, will automatically be updated and show the total and expense amounts, including or excluding VAT, depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">the state.</span></span></p>
<p><span class="koboSpan" id="kobo.845.1">Once you’ve added the method to adjust the VAT, you also need something to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">inclVat</span></strong><span class="koboSpan" id="kobo.847.1"> status inside the facade. </span><span class="koboSpan" id="kobo.847.2">You can simply create a property for this and assign it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">inclVat$</span></strong><span class="koboSpan" id="kobo.849.1"> Observable from </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">the store:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.851.1">
inclVatSelector$ = this.expensesStore.inclVat$;</span></pre> <p><span class="koboSpan" id="kobo.852.1">After adding the method and property to adjust and retrieve the VAT status, let’s add a toggle inside the HTML template of the expenses overview page to adjust the </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">VAT state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.854.1">
&lt;div class="vatToggle"&gt;
  &lt;span&gt;Incl. </span><span class="koboSpan" id="kobo.854.2">VAT:&lt;/span&gt;
  &lt;label class=»switch»&gt;
    &lt;input (click)=»expensesFacade.adjustVat()" type="checkbox"
      [checked]=»expensesFacade.inclVatSelector$ | async"&gt;
    &lt;span class=»slider round»&gt;&lt;/span&gt;
  &lt;/label&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.855.1">I’ve added the VAT toggle next to the </span><strong class="bold"><span class="koboSpan" id="kobo.856.1">add expense</span></strong><span class="koboSpan" id="kobo.857.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.858.1">show summary</span></strong><span class="koboSpan" id="kobo.859.1"> buttons. </span><span class="koboSpan" id="kobo.859.2">You can get the CSS from this book’s GitHub repository or add your own styling. </span><span class="koboSpan" id="kobo.859.3">As you can see, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">inclVatSelector$</span></strong><span class="koboSpan" id="kobo.861.1"> from the facade combined with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">async</span></strong><span class="koboSpan" id="kobo.863.1"> pipe to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">checked</span></strong><span class="koboSpan" id="kobo.865.1"> property of the </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">VAT toggle.</span></span></p>
<p><span class="koboSpan" id="kobo.867.1">We’ve also added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">click</span></strong><span class="koboSpan" id="kobo.869.1"> event to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">input</span></strong><span class="koboSpan" id="kobo.871.1"> value of the toggle to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">adjustVat</span></strong><span class="koboSpan" id="kobo.873.1"> method in the facade. </span><span class="koboSpan" id="kobo.873.2">If you click on the toggle, you will see the expense amounts in the table and the total amount in the table summary change to include or exclude the VAT amount, depending on the </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">VAT state.</span></span></p>
<p><span class="koboSpan" id="kobo.875.1">As you might have noticed, this is a</span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.876.1"> very reactive approach because everything reacts upon the state changes automatically. </span><span class="koboSpan" id="kobo.876.2">The code is also very performant because the updates are performed in a non-blocking manner, allowing all your code to </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">keep running.</span></span></p>
<p><span class="koboSpan" id="kobo.878.1">Now that we’ve implemented the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">getExpenses</span></strong><span class="koboSpan" id="kobo.880.1"> method and the VAT status, let’s finish up the </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">facade service.</span></span></p>
<h3><span class="koboSpan" id="kobo.882.1">Finishing up the facade service</span></h3>
<p><span class="koboSpan" id="kobo.883.1">For all the other methods exposed by the </span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.884.1">store, you can add simple methods inside the facade service that call them from the store, similar to what we did with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.886.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">adjustVat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.888.1"> methods.</span></span></p>
<p><span class="koboSpan" id="kobo.889.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">selectedExpense</span></strong><span class="koboSpan" id="kobo.891.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">expense</span></strong><span class="koboSpan" id="kobo.893.1"> properties inside the store, you need to add a selector property inside the facade service. </span><span class="koboSpan" id="kobo.893.2">Because we will also map the expenses emitted by </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">selectedExpense</span></strong><span class="koboSpan" id="kobo.895.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">expense</span></strong><span class="koboSpan" id="kobo.897.1">, we will abstract the mapping behavior into a new function so that we can </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">reuse it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.899.1">
private mapExpense(expense: ExpenseModel, inclVat: boolean) {
  const expenseClone = structuredClone(expense) as ExpenseModel;
  expenseClone.amount.value = inclVat ? </span><span class="koboSpan" id="kobo.899.2">expenseClone.amount.value * (1 + expenseClone.amount.vatPercentage / 100) : expenseClone.amount.value;
  return expenseClone;
}</span></pre> <p><span class="koboSpan" id="kobo.900.1">Next, you can adjust the mapping of the expenses inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">getExpenses</span></strong><span class="koboSpan" id="kobo.902.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.904.1">
expenses: expenses.map(expense =&gt; this.mapExpense(expense, inclVat)),</span></pre> <p><span class="koboSpan" id="kobo.905.1">Lastly, we will add the selector properties for </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">selectedExpense</span></strong><span class="koboSpan" id="kobo.907.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">expense</span></strong><span class="koboSpan" id="kobo.909.1">, starting </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">expenseSelector$</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.913.1">
expenseSelector$ = this.expensesStore.expense$.pipe(withLatestFrom(this.expensesStore.inclVat$), map(([expense, inclVat]) =&gt; this.mapExpense(expense, inclVat)));</span></pre> <p><span class="koboSpan" id="kobo.914.1">As you can see, for </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">expenseSelector$</span></strong><span class="koboSpan" id="kobo.916.1">, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">withLatestFrom()</span></strong><span class="koboSpan" id="kobo.918.1"> operator and didn’t use </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.920.1">. </span><span class="koboSpan" id="kobo.920.2">We did this because </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">expenseSelector$</span></strong><span class="koboSpan" id="kobo.922.1"> will only emit a value as an event using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">Subject</span></strong><span class="koboSpan" id="kobo.924.1"> class instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.926.1">. </span><span class="koboSpan" id="kobo.926.2">There is no state here, and we don’t want the selector to emit a new value when the VAT toggle</span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.927.1"> changes. </span><span class="koboSpan" id="kobo.927.2">We only want it to respond when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">expense</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.929.1">Subject</span></strong><span class="koboSpan" id="kobo.930.1"> class emits a value, and when that happens, take the current value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">inclVat$</span></strong><span class="koboSpan" id="kobo.932.1"> Observable to map </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">the expense.</span></span></p>
<p><span class="koboSpan" id="kobo.934.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">selector</span></strong><span class="koboSpan" id="kobo.936.1"> property for </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">selectedExpense</span></strong><span class="koboSpan" id="kobo.938.1"> will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.940.1"> function to combine the </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">selectedExpense$</span></strong><span class="koboSpan" id="kobo.942.1"> Observable and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">inclVat$</span></strong><span class="koboSpan" id="kobo.944.1"> Observable, </span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.946.1">
selectedExpenseSelector$ = combineLatest([this.expensesStore.selectedExpense$, this.expensesStore.inclVat$]).pipe(filter(([expense]) =&gt; !!expense), map(([expense, inclVat]) =&gt; this.mapExpense(expense as ExpenseModel, inclVat)));</span></pre> <p><span class="koboSpan" id="kobo.947.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">selectedExpenseSelector$</span></strong><span class="koboSpan" id="kobo.949.1">, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.951.1"> function because the selected expense is stateful and persists in our store. </span><span class="koboSpan" id="kobo.951.2">We might use the selected expense in our view while we can change the VAT, and because of that, we want it to react when the VAT status changes and update the amount in the view. </span><span class="koboSpan" id="kobo.951.3">Because we want </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">selectedExpense</span></strong><span class="koboSpan" id="kobo.953.1"> to be reactive on the VAT status as well, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.955.1"> operator, which triggers whenever one of the combined Observables emits a </span><span class="No-Break"><span class="koboSpan" id="kobo.956.1">new value.</span></span></p>
<p><span class="koboSpan" id="kobo.957.1">This was the last part of implementing the state management solution using RxJS. </span><span class="koboSpan" id="kobo.957.2">This approach to state management is commonly used within smaller Angular applications where the state isn’t used in many different components and services. </span><span class="koboSpan" id="kobo.957.3">The solution offers good reactivity and is easy to build </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">and understand.</span></span></p>
<p><span class="koboSpan" id="kobo.959.1">Now, let’s learn how to convert this state management solution so that it uses Signals instead of RxJS. </span><span class="koboSpan" id="kobo.959.2">Using Signals will simplify your facade service and component layer. </span><span class="koboSpan" id="kobo.959.3">It also allows Angular to perform </span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.960.1">better change detection. </span><span class="koboSpan" id="kobo.960.2">If you need to combine many data streams with tailored logic and apply modifications to them, the RxJS approach will fit your </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">application better.</span></span></p>
<p><span class="koboSpan" id="kobo.962.1">That said, using Signals is much simpler for simple state and data streams. </span><span class="koboSpan" id="kobo.962.2">Even if you need to combine some data streams without needing to have too much control over how this happens, the Signal approach will be best suited for you. </span><span class="koboSpan" id="kobo.962.3">Signals are the way to go for your state if you find yourself only using </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.964.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">withLatestFrom()</span></strong><span class="koboSpan" id="kobo.966.1"> and some basic operators such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">map()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.968.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">filter()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">.</span></span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.971.1">Handling global application state using Signals</span></h1>
<p><span class="koboSpan" id="kobo.972.1">To convert your state management solution so that it uses Signals instead of RxJS, you must change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.974.1"> classes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">ExpensesStore</span></strong><span class="koboSpan" id="kobo.976.1"> to Signals. </span><span class="koboSpan" id="kobo.976.2">You still want to ensure that the state </span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.977.1">only emits a new value when it’s set in the store; you don’t want to be able to set the state outside of </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">the store.</span></span></p>
<p><span class="koboSpan" id="kobo.979.1">To achieve this, we will create a private </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">WritableSignal</span></strong><span class="koboSpan" id="kobo.981.1"> and a public Signal that is read-only. </span><span class="koboSpan" id="kobo.981.2">You can change all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.983.1"> classes to Signals using the </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.985.1">
private expensesState = signal&lt;ExpenseModel[]&gt;([]);
expenses = this.expensesState as Signal&lt;ExpenseModel[]&gt;;</span></pre> <p><span class="koboSpan" id="kobo.986.1">Here, we declared a private Signal using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">signal()</span></strong><span class="koboSpan" id="kobo.988.1"> function. </span><span class="koboSpan" id="kobo.988.2">Declaring a Signal in this manner will create </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">WritableSignal</span></strong><span class="koboSpan" id="kobo.990.1">. </span><span class="koboSpan" id="kobo.990.2">In the line after, we created a public property and assigned it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">WritableSignal</span></strong><span class="koboSpan" id="kobo.992.1"> but cast it to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">Signal</span></strong><span class="koboSpan" id="kobo.994.1"> type with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">as</span></strong><span class="koboSpan" id="kobo.996.1"> keyword; here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">Signal</span></strong><span class="koboSpan" id="kobo.998.1"> type is read-only. </span><span class="koboSpan" id="kobo.998.2">After adjusting all your </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.1000.1"> classes, you need to change the references you had to them inside </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">the store.</span></span></p>
<p><span class="koboSpan" id="kobo.1002.1">Start by removing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">currentExpenses</span></strong><span class="koboSpan" id="kobo.1004.1"> getter and change all instances </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">this.current</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">
Expenses</span></strong><span class="koboSpan" id="kobo.1008.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1010.1">
this.expenses()</span></pre> <p><span class="koboSpan" id="kobo.1011.1">Next, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">adjustVat()</span></strong><span class="koboSpan" id="kobo.1013.1"> function, change </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">!this.incluVat.value</span></strong><span class="koboSpan" id="kobo.1015.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1017.1">
!this.inclVat()</span></pre> <p><span class="koboSpan" id="kobo.1018.1">Lastly, you need to adjust all instances where you used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">next()</span></strong><span class="koboSpan" id="kobo.1020.1"> method on one of your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">BehaviorSubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1"> classes.</span></span></p>
<p><span class="koboSpan" id="kobo.1023.1">Here’s an example of how to </span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.1024.1">convert the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">resetState()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1027.1">
resetState(): void {
  this.expensesState.set([]);
  this.selectedExpenseState.set(null);
  this.inclVatState.set(false);
}</span></pre> <p><span class="koboSpan" id="kobo.1028.1">Now, change all other instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">next()</span></strong><span class="koboSpan" id="kobo.1030.1"> method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">Subject</span></strong><span class="koboSpan" id="kobo.1032.1"> class and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">set()</span></strong><span class="koboSpan" id="kobo.1034.1"> method. </span><span class="koboSpan" id="kobo.1034.2">That’s all we need to do for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">ExpensesStore</span></strong><span class="koboSpan" id="kobo.1036.1">; you now have state management that uses Signals instead of RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.1038.1"> classes. </span><span class="koboSpan" id="kobo.1038.2">After adjusting the state, we need to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">ExpensesFacade</span></strong><span class="koboSpan" id="kobo.1040.1"> so that it can work with Signals instead </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">of Observables.</span></span></p>
<p><span class="koboSpan" id="kobo.1042.1">Normally speaking, one of the advantages of a facade service is that it is an abstraction layer, and we don’t need to touch the component layer when changing the state management solution. </span><span class="koboSpan" id="kobo.1042.2">But in this situation, we need to adjust both the facade service and the component layer; this is because we will be changing the interface of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">facade service.</span></span></p>
<p><span class="koboSpan" id="kobo.1044.1">In theory, we could maintain the interface and still return Observables by converting the Signals back into Observables in the service; doing so would allow you to leave the component layer untouched. </span><span class="koboSpan" id="kobo.1044.2">However, we want to utilize the full power of these Signals and also implement them in our components so that Angular can perform better change detection and we can make our templates synchronous. </span><span class="koboSpan" id="kobo.1044.3">To achieve this, we need to return Signals from our facade service instead of Observables, changing the interface of </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">the facade.</span></span></p>
<p><span class="koboSpan" id="kobo.1046.1">We will start changing the facade by changing the interface. </span><span class="koboSpan" id="kobo.1046.2">Replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">getExpenses</span></strong><span class="koboSpan" id="kobo.1048.1"> method inside the interface with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">expenses</span></strong><span class="koboSpan" id="kobo.1050.1"> property and adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">selectedExpenseSelector$</span></strong><span class="koboSpan" id="kobo.1052.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">inclVatSelector$</span></strong><span class="koboSpan" id="kobo.1054.1"> properties </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1056.1">
selectedExpense: Signal&lt;ExpenseModel | null&gt;;
inclVat: Signal&lt;boolean&gt;;
expenses: Signal&lt;ExpensesViewModel&gt;</span></pre> <p><span class="koboSpan" id="kobo.1057.1">After making the preceding </span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.1058.1">adjustments in the interface, you can start implementing the interface inside the facade service. </span><span class="koboSpan" id="kobo.1058.2">To implement the changes in the interface, remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">getExpenses</span></strong><span class="koboSpan" id="kobo.1060.1"> method. </span><span class="koboSpan" id="kobo.1060.2">Instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">getExpenses</span></strong><span class="koboSpan" id="kobo.1062.1"> method, you must create a computed Signal that returns the same value as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">getExpenses</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1064.1">method did:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1065.1">
expenses = computed&lt;ExpensesViewModel&gt;(() =&gt; {
  const inclVat = this.expensesStore.inclVat();
  return {
    expenses: this.expensesStore.expenses().map(expense =&gt; this.mapExpense(expense, inclVat)),
    inclVat,
    total: this.expensesStore.expenses().reduce((acc, expense) =&gt; {
      return acc + (inclVat ? </span><span class="koboSpan" id="kobo.1065.2">(expense.amount.value * (1 + expense.amount.vatPercentage / 100)) : expense.amount.value);
    }, 0),
  }
});</span></pre> <p><span class="koboSpan" id="kobo.1066.1">As you can see, the computed Signal is very similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">getExpenses</span></strong><span class="koboSpan" id="kobo.1068.1"> method. </span><span class="koboSpan" id="kobo.1068.2">The main difference is that we no longer need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.1070.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">map()</span></strong><span class="koboSpan" id="kobo.1072.1"> operators. </span><span class="koboSpan" id="kobo.1072.2">We can now use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">inclVat</span></strong><span class="koboSpan" id="kobo.1074.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">expenses</span></strong><span class="koboSpan" id="kobo.1076.1"> Signals inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1077.1">computed Signals.</span></span></p>
<p><span class="koboSpan" id="kobo.1078.1">When one of the two Signals receives a new value, the computed Signal will automatically compute a new one. </span><span class="koboSpan" id="kobo.1078.2">The computed Signals can be seen as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.1080.1"> of the Signals realm. </span><span class="koboSpan" id="kobo.1080.2">The equivalent of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">withLatestFrom()</span></strong><span class="koboSpan" id="kobo.1082.1"> would be using a Signal inside the computed Signal and wrapping the Signal using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">untracked()</span></strong><span class="koboSpan" id="kobo.1084.1"> function, as we </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.1085.1">discussed in </span><a href="B21625_07.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1086.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1088.1">After adding the computed Signal, we need to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">inclVat</span></strong><span class="koboSpan" id="kobo.1090.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">selectedExpense</span></strong><span class="koboSpan" id="kobo.1092.1"> Signals inside the facade service. </span><span class="koboSpan" id="kobo.1092.2">This is pretty straightforward – you simply define the property and assign it with the Signal </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">ExpensesStore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1096.1">
inclVat = this.expensesStore.inclVat;
selectedExpense = this.expensesStore.selectedExpense;</span></pre> <p><span class="koboSpan" id="kobo.1097.1">Here, we assign the property with the Signal from the store; we do not call the Signal by adding function brackets, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">()</span></strong><span class="koboSpan" id="kobo.1099.1">. </span><span class="koboSpan" id="kobo.1099.2">We don’t add these function brackets because we want to use the actual Signal inside the component layer, not the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">Signal</span></strong><span class="koboSpan" id="kobo.1101.1"> value. </span><span class="koboSpan" id="kobo.1101.2">If you were to call the Signal here and retrieve the value inside the component layer, the update behavior wouldn’t work as expected, and the view wouldn’t be updated when your </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">state changes.</span></span></p>
<p><span class="koboSpan" id="kobo.1103.1">The last thing to do is adjust </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">ExpensesOverviewPageComponent</span></strong><span class="koboSpan" id="kobo.1105.1"> and its template. </span><span class="koboSpan" id="kobo.1105.2">Inside the component class, you can adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">expenses</span></strong><span class="koboSpan" id="kobo.1107.1"> property and assign it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1108.1">expenses Subject</span></strong><span class="koboSpan" id="kobo.1109.1"> class from the facade instead of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">getExpenses()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1111.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1112.1">
expenses = this. </span><span class="koboSpan" id="kobo.1112.2">expensesFacade.expenses;</span></pre> <p><span class="koboSpan" id="kobo.1113.1">Now, inside the HTML template, you need to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">inclVatSelector$</span></strong><span class="koboSpan" id="kobo.1115.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">inclVat()</span></strong><span class="koboSpan" id="kobo.1117.1">, remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">async</span></strong><span class="koboSpan" id="kobo.1119.1"> pipe, and change </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">expenses</span></strong><span class="koboSpan" id="kobo.1121.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">async</span></strong><span class="koboSpan" id="kobo.1123.1"> pipe to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">expenses()</span></strong><span class="koboSpan" id="kobo.1125.1"> without the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">async</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1"> pipe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1128.1">
[checked]="expensesFacade.inclVat()"
@if(expenses(); as expensesVm) { …… }</span></pre> <p><span class="koboSpan" id="kobo.1129.1">With the preceding changes, you’ve adjusted the component class and the HTML template to use Signals instead of Observables. </span><span class="koboSpan" id="kobo.1129.2">As you can see, using the Signal approach is slightly simpler and needs fewer lines of code. </span><span class="koboSpan" id="kobo.1129.3">It also makes your HTML template synchronous and helps Angular to perform better change detection, leading to </span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1">better performance.</span></span></p>
<p><span class="koboSpan" id="kobo.1131.1">The flip side is that you have less control over the data streams, and it’s not as easy to modify the stream before it reaches your application logic. </span><span class="koboSpan" id="kobo.1131.2">Compared to RxJS, Signals also offers less control when you want to combine different streams of data, so depending on your needs, you can decide whether to use Signals </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">or RxJS.</span></span></p>
<p><span class="koboSpan" id="kobo.1133.1">You can also make a hybrid solution and convert Observables into Signals, giving you the best of both worlds. </span><span class="koboSpan" id="kobo.1133.2">In that </span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.1134.1">case, you can use the RxJS operators you need and still consume the values as Signals in your component classes and </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">HTML templates.</span></span></p>
<p><span class="koboSpan" id="kobo.1136.1">With that, you’ve learned how to create a state management solution using RxJS and Signals. </span><span class="koboSpan" id="kobo.1136.2">You made a facade service as an additional abstraction layer and learned when you have to change the component layer and when you only have to change the state management layer when working with a </span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">facade service.</span></span></p>
<p><span class="koboSpan" id="kobo.1138.1">Both state management solutions we’ve created work well for small applications with relatively simple global states. </span><span class="koboSpan" id="kobo.1138.2">The RxJS method is implemented a lot, and with the popularity of Signals, I imagine the Signal approach will be implemented a lot as well. </span><span class="koboSpan" id="kobo.1138.3">But when you have a larger application where the state is used in a lot of components and services, you will run into issues with our current implementation. </span><span class="koboSpan" id="kobo.1138.4">In the next section, you will learn about these issues and how to </span><span class="No-Break"><span class="koboSpan" id="kobo.1139.1">resolve them.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.1140.1">The problem with using RxJS or Signals for global state management</span></h1>
<p><span class="koboSpan" id="kobo.1141.1">While our current state management solution is used in many applications and works well for our current application, there’s a</span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.1142.1"> huge problem: our current global state management solution </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">isn’t immutable.</span></span></p>
<p><span class="koboSpan" id="kobo.1144.1">You cannot modify your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.1146.1"> classes or Signals from outside the store, so in that sense, it is immutable. </span><span class="koboSpan" id="kobo.1146.2">Also, when using primitive values for your state, the state itself is immutable. </span><span class="koboSpan" id="kobo.1146.3">However, when you’re using reference objects as values for your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.1148.1"> classes or Signals, the state itself </span><span class="No-Break"><span class="koboSpan" id="kobo.1149.1">isn’t immutable.</span></span></p>
<p><span class="koboSpan" id="kobo.1150.1">When you use an array or object for your state and retrieve the state through </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.1152.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">Signal</span></strong><span class="koboSpan" id="kobo.1154.1">, you can modify the value of the state unintentionally. </span><span class="koboSpan" id="kobo.1154.2">When you adjust the retrieved state object within a component or service class, the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.1156.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">Signal</span></strong><span class="koboSpan" id="kobo.1158.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">also modified!</span></span></p>
<p><span class="koboSpan" id="kobo.1160.1">This is also the reason why we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">structuredClone()</span></strong><span class="koboSpan" id="kobo.1162.1"> function inside our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">mapExpenses()</span></strong><span class="koboSpan" id="kobo.1164.1"> function. </span><span class="koboSpan" id="kobo.1164.2">If you remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">structuredClone()</span></strong><span class="koboSpan" id="kobo.1166.1"> and toggle the VAT a couple of times in the view, you will notice that the amounts keep increasing instead of adding and removing the VAT. </span><span class="koboSpan" id="kobo.1166.2">This happens because we modify the object inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">Signal</span></strong><span class="koboSpan" id="kobo.1168.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.1170.1"> whenever we adjust it inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1171.1">facade service.</span></span></p>
<p><span class="koboSpan" id="kobo.1172.1">The next time we retrieve the state, it still has the adjusted values instead of the real state we expect. </span><span class="koboSpan" id="kobo.1172.2">Relying on</span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.1173.1"> developers to always clone the object when it’s modified is risky and not how you want it </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">to be.</span></span></p>
<p><span class="koboSpan" id="kobo.1175.1">Allowing your state to be modified outside the store and without calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">next()</span></strong><span class="koboSpan" id="kobo.1177.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">set()</span></strong><span class="koboSpan" id="kobo.1179.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.1181.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">Signal</span></strong><span class="koboSpan" id="kobo.1183.1"> opens the door for unintended state changes, resulting in a corrupted state. </span><span class="koboSpan" id="kobo.1183.2">When your state is not what you expect it to be, you can display incorrect values to the user and perform actions within your code that </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">aren’t intended.</span></span></p>
<p><span class="koboSpan" id="kobo.1185.1">For small applications where the state isn’t used in many places, this might be a manageable problem, but when your application grows, your state is used in multiple places and often the retrieved state is modified locally, so the problem will </span><span class="No-Break"><span class="koboSpan" id="kobo.1186.1">surface quickly.</span></span></p>
<p><span class="koboSpan" id="kobo.1187.1">To have a state management system that is truly immutable, reactive, and can handle the state of any application no matter how large it becomes, your best bet is to go with a good library that focuses on state management. </span><span class="koboSpan" id="kobo.1187.2">Some popular choices within the Angular community are </span><span class="No-Break"><span class="koboSpan" id="kobo.1188.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1189.1">NgRx</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">NgXs</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">RxAngular</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1192.1">Akita</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1193.1">Angular Query</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1194.1">All of these libraries have their advantages and disadvantages. </span><span class="koboSpan" id="kobo.1194.2">My personal favorites are RxAngular, NgXs, and NgRx. </span><span class="koboSpan" id="kobo.1194.3">NgRx is by far the most commonly used state management solution within the community and offers support for Observable and Signal-based state management. </span><span class="koboSpan" id="kobo.1194.4">RxAngular is gaining a lot of popularity and has a very intuitive approach for reactively managing state with little to no boilerplate code; it also enables you to ditch ZoneJS and boost the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.1196.1">In the next section, we will </span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.1197.1">convert our state management solution into an NgRx state management solution. </span><span class="koboSpan" id="kobo.1197.2">I’ve picked NgRx because this is the most commonly used solution, but I recommend that you investigate some of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1198.1">other solutions.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.1199.1">Handling global application state with NgRx</span></h1>
<p><span class="koboSpan" id="kobo.1200.1">When working on enterprise software or an application with extensive or complex state management, you should use a battle-tested state management solution that provides true immutability, unidirectional</span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.1201.1"> data flow, and good tools to perform side effects and modify the state securely. </span><span class="koboSpan" id="kobo.1201.2">The best way forward is to use a</span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.1202.1"> battle-tested library that focuses on </span><span class="No-Break"><span class="koboSpan" id="kobo.1203.1">state management.</span></span></p>
<p><span class="koboSpan" id="kobo.1204.1">The most commonly used library for state management within the Angular community is </span><strong class="bold"><span class="koboSpan" id="kobo.1205.1">NgRx</span></strong><span class="koboSpan" id="kobo.1206.1">; it has a huge community and all the tools you might need to handle even the most complex state. </span><span class="koboSpan" id="kobo.1206.2">NgRx</span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.1207.1"> implements the Redux pattern and consists of four main building blocks: actions, reducers, selectors, </span><span class="No-Break"><span class="koboSpan" id="kobo.1208.1">and effects.</span></span></p>
<p><span class="koboSpan" id="kobo.1209.1">In this section, we will change our custom-made state management solution so that it uses NgRx. </span><span class="koboSpan" id="kobo.1209.2">We will keep the store file we made in the previous section for reference purposes and build the NgRx state management in </span><span class="No-Break"><span class="koboSpan" id="kobo.1210.1">new files.</span></span></p>
<p><span class="koboSpan" id="kobo.1211.1">In a production environment, you should remove the old unused store file. </span><span class="koboSpan" id="kobo.1211.2">Inside the facade service, we will simply replace the current implementation with the NgRx implementation, and this time, we will not adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">IExpensesFacade</span></strong><span class="koboSpan" id="kobo.1213.1"> interface, meaning we do not have to change our component layer. </span><span class="koboSpan" id="kobo.1213.2">Let’s go over the step-by-step process of implementing NgRx </span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">state management.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.1215.1">Installing the @ngrx/store and @ngrx/effects packages</span></h2>
<p><span class="koboSpan" id="kobo.1216.1">To start implementing NgRx state</span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.1217.1"> management, you need to install some packages by running the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">npm</span></strong><span class="koboSpan" id="kobo.1219.1"> commands in</span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.1220.1"> the root of your </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1221.1">Nx monorepo</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1222.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1223.1">
npm install @ngrx/store --save
npm i @ngrx/effects</span></pre> <p><span class="koboSpan" id="kobo.1224.1">After installing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">@ngrx/store</span></strong><span class="koboSpan" id="kobo.1226.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1227.1">@ngrx/effects</span></strong><span class="koboSpan" id="kobo.1228.1"> packages, you need to create some folders and files. </span><span class="koboSpan" id="kobo.1228.2">There is an Nx generator to create the initial setup for your NgRx store, but we will </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.1229.1">set up everything manually so that you get a better understanding of how</span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.1230.1"> everything works and what’s needed when </span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">using NgRx.</span></span></p>
<p><span class="koboSpan" id="kobo.1232.1">Start by creating a folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">state</span></strong><span class="koboSpan" id="kobo.1234.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">lib</span></strong><span class="koboSpan" id="kobo.1236.1"> folder of the expenses data-access library (next to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">stores</span></strong><span class="koboSpan" id="kobo.1238.1"> folder). </span><span class="koboSpan" id="kobo.1238.2">Inside the newly created </span><strong class="source-inline"><span class="koboSpan" id="kobo.1239.1">state</span></strong><span class="koboSpan" id="kobo.1240.1"> folder, create another folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">expenses</span></strong><span class="koboSpan" id="kobo.1242.1">. </span><span class="koboSpan" id="kobo.1242.2">Now, inside the newly created </span><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">expenses</span></strong><span class="koboSpan" id="kobo.1244.1"> folder, create these </span><span class="No-Break"><span class="koboSpan" id="kobo.1245.1">five files:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">expenses.actions.ts</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">expenses.reducers.ts</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1248.1">expenses.selectors.ts</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">expenses.effects.ts</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">index.ts</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1251.1">When you’re done creating the folders and files, you can start adding some actions inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">expenses.actions.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1253.1"> file.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.1254.1">Defining your first NgRx actions</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.1255.1">Actions</span></strong><span class="koboSpan" id="kobo.1256.1"> are one of the main building blocks of NgRx and the Redux pattern. </span><span class="koboSpan" id="kobo.1256.2">Actions define the unique events you can </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.1257.1">dispatch and perform for your NgRx state. </span><span class="koboSpan" id="kobo.1257.2">Actions are defined as constants using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1258.1">createAction()</span></strong><span class="koboSpan" id="kobo.1259.1"> function, which the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">@ngrx/store</span></strong><span class="koboSpan" id="kobo.1261.1"> package exposes </span><span class="No-Break"><span class="koboSpan" id="kobo.1262.1">to you.</span></span></p>
<p><span class="koboSpan" id="kobo.1263.1">You must provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">createAction()</span></strong><span class="koboSpan" id="kobo.1265.1"> function with a description of the action and, optionally, with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">props()</span></strong><span class="koboSpan" id="kobo.1267.1"> function to define the properties you have to provide the action with to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.1268.1">the action.</span></span></p>
<p><span class="koboSpan" id="kobo.1269.1">Alternatively, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">createActionGroup()</span></strong><span class="koboSpan" id="kobo.1271.1"> function to create multiple events and group them under a single constant. </span><span class="koboSpan" id="kobo.1271.2">We won’t use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">createActionGroup()</span></strong><span class="koboSpan" id="kobo.1273.1"> function, but you can always read about it yourself in the official NgRx </span><span class="No-Break"><span class="koboSpan" id="kobo.1274.1">documentation: </span></span><a href="https://ngrx.io/docs"><span class="No-Break"><span class="koboSpan" id="kobo.1275.1">https://ngrx.io/docs</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1276.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1277.1">We’ll start with a simple task: defining an action to fetch the expenses from the API. </span><span class="koboSpan" id="kobo.1277.2">You don’t have to provide any </span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.1278.1">argument to fetch the expenses, so the action will only contain a description. </span><span class="koboSpan" id="kobo.1278.2">The descriptions of NgRx actions commonly use the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1279.1">naming conventions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1280.1">
[Unique State Name] Description of the action</span></pre> <p><span class="koboSpan" id="kobo.1281.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">expenses.actions.ts</span></strong><span class="koboSpan" id="kobo.1283.1"> file, define the action to fetch expenses, </span><span class="No-Break"><span class="koboSpan" id="kobo.1284.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1285.1">
export const fetchExpenses = createAction(`[Expenses] Fetch Expenses`);</span></pre> <p><span class="koboSpan" id="kobo.1286.1">Commonly, when defining NgRx actions that include API requests, you also define a success and failure action. </span><span class="koboSpan" id="kobo.1286.2">So, go ahead and define an action for when fetching the expenses succeeds </span><span class="No-Break"><span class="koboSpan" id="kobo.1287.1">or fails:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1288.1">
export const fetchExpensesSuccess = createAction(`[Expenses] Fetch Expenses Success`, props&lt;{ expenses: ExpenseModel[] }&gt;());
export const fetchExpensesFailed = createAction(`[Expenses] Fetch Expenses Failed`);</span></pre> <p><span class="koboSpan" id="kobo.1289.1">Here, we declared two actions; both received a description, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1290.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1291.1"> action also received the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">props()</span></strong><span class="koboSpan" id="kobo.1293.1"> function. </span><span class="koboSpan" id="kobo.1293.2">Inside the arrow brackets, we defined the type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">props()</span></strong><span class="koboSpan" id="kobo.1295.1"> function – in this case, an object with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">expenses</span></strong><span class="koboSpan" id="kobo.1297.1"> property containing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">ExpenseModel</span></strong><span class="koboSpan" id="kobo.1299.1"> array. </span><span class="koboSpan" id="kobo.1299.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1301.1"> action needs </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">expenses</span></strong><span class="koboSpan" id="kobo.1303.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">props()</span></strong><span class="koboSpan" id="kobo.1305.1"> because we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1307.1"> action to update the state with the expenses that are retrieved from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1308.1">API request.</span></span></p>
<p><span class="koboSpan" id="kobo.1309.1">Now that you’ve added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1310.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1311.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1313.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1314.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">fetch</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">
ExpensesFailed</span></strong><span class="koboSpan" id="kobo.1317.1"> actions, let’s update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">index.ts</span></strong><span class="koboSpan" id="kobo.1319.1"> file inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">state/expenses</span></strong><span class="koboSpan" id="kobo.1321.1"> folder by defining an export for our </span><span class="No-Break"><span class="koboSpan" id="kobo.1322.1">expense actions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1323.1">
export * as ExpenseActions from './expenses.actions';</span></pre> <p><span class="koboSpan" id="kobo.1324.1">After adding the export to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1325.1">index.ts</span></strong><span class="koboSpan" id="kobo.1326.1"> file, we can move on to the next piece of the puzzle. </span><span class="koboSpan" id="kobo.1326.2">The next step is to create an NgRx effect that will make an API request to fetch the expenses and dispatch the</span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.1327.1"> success of the failed </span><span class="No-Break"><span class="koboSpan" id="kobo.1328.1">action accordingly.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.1329.1">Creating your first NgRx effect</span></h2>
<p><span class="koboSpan" id="kobo.1330.1">You will create your </span><strong class="bold"><span class="koboSpan" id="kobo.1331.1">NgRx effects</span></strong><span class="koboSpan" id="kobo.1332.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">expenses.effects.ts</span></strong><span class="koboSpan" id="kobo.1334.1"> file. </span><span class="koboSpan" id="kobo.1334.2">Effects allow you to perform side effects when an action is dispatched. </span><span class="koboSpan" id="kobo.1334.3">Effects are commonly used for tasks such as fetching </span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.1335.1">data, dispatching other </span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.1336.1">events, or updating local storage. </span><span class="koboSpan" id="kobo.1336.2">Side effects isolate some logic away from your components, allowing you to keep the component classes as simple </span><span class="No-Break"><span class="koboSpan" id="kobo.1337.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.1338.1">The first effect you will create is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">fetchExpeses$</span></strong><span class="koboSpan" id="kobo.1340.1"> effect. </span><span class="koboSpan" id="kobo.1340.2">This effect will run whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1342.1"> action is dispatched. </span><span class="koboSpan" id="kobo.1342.2">The effect will then make an API request to fetch the expenses and map the result of the API call into a newly dispatched action – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1343.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1344.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">fetchExpensesFailed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1346.1"> action.</span></span></p>
<p><span class="koboSpan" id="kobo.1347.1">To get started, create an injectable class inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1348.1">expenses.effects.ts</span></strong><span class="koboSpan" id="kobo.1349.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.1350.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">ExpensesEffects</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1352.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1353.1">
@Injectable({ providedIn: 'root' })
export class ExpensesEffects {}</span></pre> <p><span class="koboSpan" id="kobo.1354.1">After creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">ExpensesEffects</span></strong><span class="koboSpan" id="kobo.1356.1"> class, you need to inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">Actions</span></strong><span class="koboSpan" id="kobo.1358.1"> class from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1359.1">@ngrx/effects</span></strong><span class="koboSpan" id="kobo.1360.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">ExpensesHttpService</span></strong><span class="koboSpan" id="kobo.1362.1"> inside your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">ExpensesEffects</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1364.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1365.1">
private readonly actions = inject(Actions);
private readonly expensesApi = inject(ExpensesHttpService);</span></pre> <p><span class="koboSpan" id="kobo.1366.1">Next, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">createEffect()</span></strong><span class="koboSpan" id="kobo.1368.1"> function that’s exposed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1369.1">@ngrx/effects</span></strong><span class="koboSpan" id="kobo.1370.1"> to create your </span><span class="No-Break"><span class="koboSpan" id="kobo.1371.1">first effect:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1372.1">
fetchExpeses$ = createEffect(() =&gt;
  this.actions.pipe(
    ofType(ExpenseActions.fetchExpenses.type),
    switchMap(() =&gt; this.expensesApi.get().pipe(
      map((expenses: ExpenseModel[]) =&gt; ExpenseActions.fetchExpensesSuccess({ expenses })),
      catchError(() =&gt; of(ExpenseActions.fetchExpensesFailed()))
    ))
  )
);</span></pre> <p><span class="koboSpan" id="kobo.1373.1">In the preceding code snippet, you created your first effect named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">fetchExpenses$</span></strong><span class="koboSpan" id="kobo.1375.1">. </span><span class="koboSpan" id="kobo.1375.2">As you can see, there is quite a lot going on there, so let’s break it down line </span><span class="No-Break"><span class="koboSpan" id="kobo.1376.1">by line.</span></span></p>
<p><span class="koboSpan" id="kobo.1377.1">We started by defining a property </span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.1378.1">named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">fetchExpenses$</span></strong><span class="koboSpan" id="kobo.1380.1"> and assigned it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1381.1">createEffect()</span></strong><span class="koboSpan" id="kobo.1382.1"> function. </span><span class="koboSpan" id="kobo.1382.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1383.1">createEffect()</span></strong><span class="koboSpan" id="kobo.1384.1"> function, we defined a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1385.1">callback</span></strong><span class="koboSpan" id="kobo.1386.1"> function that returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1387.1">this.actions.pipe()</span></strong><span class="koboSpan" id="kobo.1388.1"> method. </span><span class="koboSpan" id="kobo.1388.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1389.1">this.actions</span></strong><span class="koboSpan" id="kobo.1390.1"> instance refers</span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.1391.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">Actions</span></strong><span class="koboSpan" id="kobo.1393.1"> class we injected in the previous code block. </span><span class="koboSpan" id="kobo.1393.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">Actions</span></strong><span class="koboSpan" id="kobo.1395.1"> class emits the actions we dispatched and extends the Observable class, meaning you can use the RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.1396.1">pipe()</span></strong><span class="koboSpan" id="kobo.1397.1"> function on </span><span class="No-Break"><span class="koboSpan" id="kobo.1398.1">the class.</span></span></p>
<p><span class="koboSpan" id="kobo.1399.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">pipe()</span></strong><span class="koboSpan" id="kobo.1401.1"> function’s chained-on actions, we defined a couple of operators, starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">ofType()</span></strong><span class="koboSpan" id="kobo.1403.1"> operator. </span><span class="koboSpan" id="kobo.1403.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">ofType()</span></strong><span class="koboSpan" id="kobo.1405.1"> operator is a filter operator that filters out actions by the action type. </span><span class="koboSpan" id="kobo.1405.2">Inside the function brackets of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">ofType()</span></strong><span class="koboSpan" id="kobo.1407.1"> operator, you defined the type of an action. </span><span class="koboSpan" id="kobo.1407.2">In our case, we provided it with the type of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1409.1"> action. </span><span class="koboSpan" id="kobo.1409.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1410.1">ExpenseAction</span></strong><span class="koboSpan" id="kobo.1411.1"> is used to export and import our actions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1412.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1413.1"> is the property name we gave our action, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1414.1">type</span></strong><span class="koboSpan" id="kobo.1415.1"> is a property that’s exposed on all the actions we created with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1416.1">createAction()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1417.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.1418.1">Whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1420.1"> action is dispatched, we will move on to the next operator inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1421.1">pipe()</span></strong><span class="koboSpan" id="kobo.1422.1"> function of our effect. </span><span class="koboSpan" id="kobo.1422.2">The next operator is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">switchMap()</span></strong><span class="koboSpan" id="kobo.1424.1"> operator, which is used to flatten the additional Observable stream that was created by the HTTP request to fetch </span><span class="No-Break"><span class="koboSpan" id="kobo.1425.1">the expenses.</span></span></p>
<p><span class="koboSpan" id="kobo.1426.1">Inside the callback of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">switchMap()</span></strong><span class="koboSpan" id="kobo.1428.1"> operator, we made the HTTP request and added an additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">pipe()</span></strong><span class="koboSpan" id="kobo.1430.1"> function to the HTTP request. </span><span class="koboSpan" id="kobo.1430.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1431.1">pipe()</span></strong><span class="koboSpan" id="kobo.1432.1"> function of the HTTP request, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1433.1">map()</span></strong><span class="koboSpan" id="kobo.1434.1"> operator to map a successful HTTP response to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1435.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1436.1"> action, and we provided the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1438.1"> action with the expenses that were retrieved from the API response. </span><span class="koboSpan" id="kobo.1438.2">If the API request fails, we </span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.1439.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1440.1">catchError</span></strong><span class="koboSpan" id="kobo.1441.1"> operator to map it to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1442.1">fetchExpensesFailed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1443.1"> action.</span></span></p>
<p><span class="koboSpan" id="kobo.1444.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1445.1">createEffect()</span></strong><span class="koboSpan" id="kobo.1446.1"> function will automatically dispatch the returned action; this is why we don’t have to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1447.1">dispatch()</span></strong><span class="koboSpan" id="kobo.1448.1"> function explicitly but simply return an Observable with the action we want to dispatch. </span><span class="koboSpan" id="kobo.1448.2">In our case, this is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1449.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1450.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1451.1">fetchExpensesFailed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1452.1"> action.</span></span></p>
<p><span class="koboSpan" id="kobo.1453.1">Lastly, you need to export the</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.1454.1"> effects inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">index.ts</span></strong><span class="koboSpan" id="kobo.1456.1"> file inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">state/expenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1458.1"> folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1459.1">
export * from './expenses.effects';</span></pre> <p><span class="koboSpan" id="kobo.1460.1">Now that we’ve defined the actions and created an effect to handle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1462.1"> action and dispatch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1464.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">fetchExpensesFailed</span></strong><span class="koboSpan" id="kobo.1466.1"> actions, let’s cover the next building block of our NgRx state by creating our state and </span><span class="No-Break"><span class="koboSpan" id="kobo.1467.1">reducer functions.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.1468.1">Creating your initial state and first reducer functions</span></h2>
<p><span class="koboSpan" id="kobo.1469.1">Now that you’ve created some actions </span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.1470.1">and your first effect, you need a state to perform these actions on and </span><strong class="bold"><span class="koboSpan" id="kobo.1471.1">reducers</span></strong><span class="koboSpan" id="kobo.1472.1"> to adjust the </span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.1473.1">state. </span><span class="koboSpan" id="kobo.1473.2">In NgRx and the Redux pattern, reducers are responsible for adjusting your </span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.1474.1">state properties. </span><span class="koboSpan" id="kobo.1474.2">Inside your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1475.1">expenses.reducer.ts</span></strong><span class="koboSpan" id="kobo.1476.1"> file, you will define your initial state object and reducers to adjust the state when actions </span><span class="No-Break"><span class="koboSpan" id="kobo.1477.1">are dispatched.</span></span></p>
<p><span class="koboSpan" id="kobo.1478.1">Start by creating a new interface for your state object inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1479.1">expenses.interface.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1480.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1481.1">
export interface ExpensesState {
  expenses: ExpenseModel[];
  selectedExpense: ExpenseModel | null;
  isLoading: boolean;
  inclVat: boolean;
  error: string | null;
}</span></pre> <p><span class="koboSpan" id="kobo.1482.1">After creating the interface, you can </span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.1483.1">create your initial state object inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1484.1">expenses.reducer.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1485.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1486.1">
export const initialExpensesState: Readonly&lt;ExpensesState&gt; = {
  expenses: [],
  selectedExpense: null,
  isLoading: false,
  inclVat: false,
  error: null
};</span></pre> <p><span class="koboSpan" id="kobo.1487.1">After defining the interface and initial state object, you can create the reducer by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1488.1">createReducer()</span></strong><span class="koboSpan" id="kobo.1489.1"> function. </span><span class="koboSpan" id="kobo.1489.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1490.1">createReducer()</span></strong><span class="koboSpan" id="kobo.1491.1"> function takes in your initial state as a parameter and</span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.1492.1"> reduces your state based on </span><span class="No-Break"><span class="koboSpan" id="kobo.1493.1">dispatched actions.</span></span></p>
<p><span class="koboSpan" id="kobo.1494.1">Let’s start by defining the reducer function and providing it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1495.1">initial state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1496.1">
export const expensesReducer = createReducer&lt;ExpensesState&gt;(initialExpensesState);</span></pre> <p><span class="koboSpan" id="kobo.1497.1">In the preceding code snippet, we created a property named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1498.1">expensesReducer</span></strong><span class="koboSpan" id="kobo.1499.1"> and assigned it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1500.1">createReducer()</span></strong><span class="koboSpan" id="kobo.1501.1"> function. </span><span class="koboSpan" id="kobo.1501.2">Inside the arrow brackets, we provided the type the reducer will modify; in our case, this is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1502.1">ExpensesState</span></strong><span class="koboSpan" id="kobo.1503.1"> interface. </span><span class="koboSpan" id="kobo.1503.2">Inside the function brackets, we provided the initial state </span><span class="No-Break"><span class="koboSpan" id="kobo.1504.1">object, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1505.1">initialExpensesState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1506.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1507.1">Next, you need to add functions inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1508.1">createReducer()</span></strong><span class="koboSpan" id="kobo.1509.1"> function to update the state when an action is dispatched, starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1510.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1511.1"> action. </span><span class="koboSpan" id="kobo.1511.2">To update the state, you must define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1512.1">on()</span></strong><span class="koboSpan" id="kobo.1513.1"> function and provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1514.1">on()</span></strong><span class="koboSpan" id="kobo.1515.1"> function with a reference to the action it needs to react on, as well as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1516.1">callback</span></strong><span class="koboSpan" id="kobo.1517.1"> function to modify </span><span class="No-Break"><span class="koboSpan" id="kobo.1518.1">the state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1519.1">
createReducer&lt;ExpensesState&gt;(
  initialExpensesState,
  on(ExpenseActions.fetchExpenses, (state) =&gt; ({
    ...state,
    isLoading: true
  }))
)</span></pre> <p><span class="koboSpan" id="kobo.1520.1">Here, we’ve added an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1521.1">on()</span></strong><span class="koboSpan" id="kobo.1522.1"> function underneath the initial state object inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1523.1">createReducer()</span></strong><span class="koboSpan" id="kobo.1524.1"> function. </span><span class="koboSpan" id="kobo.1524.2">We</span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.1525.1"> provided the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1526.1">on()</span></strong><span class="koboSpan" id="kobo.1527.1"> function with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1528.1">ExpenseActions.fetchExpenses</span></strong><span class="koboSpan" id="kobo.1529.1"> so that it reacts when </span><strong class="source-inline"><span class="koboSpan" id="kobo.1530.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1531.1"> actions </span><span class="No-Break"><span class="koboSpan" id="kobo.1532.1">are dispatched.</span></span></p>
<p><span class="koboSpan" id="kobo.1533.1">After the reference to the action, we declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1534.1">callback</span></strong><span class="koboSpan" id="kobo.1535.1"> function to modify the state. </span><span class="koboSpan" id="kobo.1535.2">Inside the function brackets of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">callback</span></strong><span class="koboSpan" id="kobo.1537.1"> function, you can define a parameter that will be populated with the current state object for you; it’s the convention to name this </span><span class="No-Break"><span class="koboSpan" id="kobo.1538.1">parameter </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1539.1">state</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1540.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1541.1">Lastly, we return a new state object by spreading the current state into the object and setting the state properties we</span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.1542.1"> want to change. </span><span class="koboSpan" id="kobo.1542.2">In the case of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1543.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1544.1"> action, we only want to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1545.1">isLoading</span></strong><span class="koboSpan" id="kobo.1546.1"> state property </span><span class="No-Break"><span class="koboSpan" id="kobo.1547.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1548.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1549.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1550.1">Next, we can add the reducer function for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1551.1">fetchExpensesSuccess</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1552.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1553.1">fetch</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.1554.1">
ExpensesFailed</span></strong><span class="koboSpan" id="kobo.1555.1"> actions underneath the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1556.1">reducer</span></strong><span class="koboSpan" id="kobo.1557.1"> function for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1558.1">fetchExpenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1559.1"> action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1560.1">
on(ExpenseActions.fetchExpensesSuccess, (state, { expenses }) =&gt; ({
  ...state,
  isLoading: false,
  expenses,
  error: null
})),
on(ExpenseActions.fetchExpensesFailed, (state) =&gt; ({
  ...state,
  isLoading: false,
  error: ‹Failed to fetch expenses!›
})),</span></pre> <p><span class="koboSpan" id="kobo.1561.1">Here, we’ve declared two more </span><strong class="source-inline"><span class="koboSpan" id="kobo.1562.1">on()</span></strong><span class="koboSpan" id="kobo.1563.1"> functions and provided them with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1564.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1565.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1566.1">fetchExpensesFailed</span></strong><span class="koboSpan" id="kobo.1567.1"> actions. </span><span class="koboSpan" id="kobo.1567.2">Inside the function brackets of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1568.1">callback</span></strong><span class="koboSpan" id="kobo.1569.1"> function of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1570.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1571.1"> action reducer, we used destructuring to </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.1572.1">extract the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1573.1">expenses</span></strong><span class="koboSpan" id="kobo.1574.1"> object from the dispatched action. </span><span class="koboSpan" id="kobo.1574.2">As you might remember, you defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1575.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1576.1"> action to take the expenses that were fetched from</span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.1577.1"> the API request as </span><span class="No-Break"><span class="koboSpan" id="kobo.1578.1">a parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.1579.1">Next, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1580.1">callback</span></strong><span class="koboSpan" id="kobo.1581.1"> function, we updated the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1582.1">expenses</span></strong><span class="koboSpan" id="kobo.1583.1"> property of the state, set </span><strong class="source-inline"><span class="koboSpan" id="kobo.1584.1">isLoading</span></strong><span class="koboSpan" id="kobo.1585.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1586.1">false</span></strong><span class="koboSpan" id="kobo.1587.1">, and set </span><strong class="source-inline"><span class="koboSpan" id="kobo.1588.1">error</span></strong><span class="koboSpan" id="kobo.1589.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1590.1">null</span></strong><span class="koboSpan" id="kobo.1591.1">. </span><span class="koboSpan" id="kobo.1591.2">If we fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1592.1">expenses</span></strong><span class="koboSpan" id="kobo.1593.1"> property successfully, there will be no errors to show to </span><span class="No-Break"><span class="koboSpan" id="kobo.1594.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.1595.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.1596.1">fetchExpensesFailed</span></strong><span class="koboSpan" id="kobo.1597.1">, we don’t provide parameters when we dispatch the action, so we only provide the state object in the callback, just like we did with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1598.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1599.1"> action reducer. </span><span class="koboSpan" id="kobo.1599.2">Inside the callback of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1600.1">fetchExpensesFailed</span></strong><span class="koboSpan" id="kobo.1601.1"> reducer, we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.1602.1">isLoading</span></strong><span class="koboSpan" id="kobo.1603.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1604.1">false</span></strong><span class="koboSpan" id="kobo.1605.1"> and set an </span><span class="No-Break"><span class="koboSpan" id="kobo.1606.1">error message.</span></span></p>
<p><span class="koboSpan" id="kobo.1607.1">With that, you’ve created your initial state and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1608.1">reducer</span></strong><span class="koboSpan" id="kobo.1609.1"> function for each of the actions you defined. </span><span class="koboSpan" id="kobo.1609.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1610.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1611.1"> action is dispatched, you use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1612.1">reducer</span></strong><span class="koboSpan" id="kobo.1613.1"> function to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">isLoading</span></strong><span class="koboSpan" id="kobo.1615.1"> state to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1616.1">true</span></strong><span class="koboSpan" id="kobo.1617.1">. </span><span class="koboSpan" id="kobo.1617.2">When you’re done fetching, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1618.1">fetchExpensesSuccess</span></strong><span class="koboSpan" id="kobo.1619.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1620.1">fetchExpensesFailed</span></strong><span class="koboSpan" id="kobo.1621.1"> action is dispatched, you use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1622.1">reducer</span></strong><span class="koboSpan" id="kobo.1623.1"> function to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1624.1">isLoading</span></strong><span class="koboSpan" id="kobo.1625.1"> state to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1626.1">false</span></strong><span class="koboSpan" id="kobo.1627.1"> and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1628.1">expenses</span></strong><span class="koboSpan" id="kobo.1629.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1630.1">error</span></strong><span class="koboSpan" id="kobo.1631.1"> state accordingly. </span><span class="koboSpan" id="kobo.1631.2">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1632.1">isLoading</span></strong><span class="koboSpan" id="kobo.1633.1"> state to show a spinner, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1634.1">error</span></strong><span class="koboSpan" id="kobo.1635.1"> state to show an error message, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1636.1">expenses</span></strong><span class="koboSpan" id="kobo.1637.1"> to display your list </span><span class="No-Break"><span class="koboSpan" id="kobo.1638.1">of expenses.</span></span></p>
<p><span class="koboSpan" id="kobo.1639.1">Now, underneath </span><strong class="source-inline"><span class="koboSpan" id="kobo.1640.1">expensesReducer</span></strong><span class="koboSpan" id="kobo.1641.1">, you need to define a unique key for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1642.1">expenses state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1643.1">
export const expensesFeatureKey = 'expenses';</span></pre> <p><span class="koboSpan" id="kobo.1644.1">As a last step, you need to add the</span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.1645.1"> reducer file inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1646.1">index.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1647.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1648.1">
export * from './expenses.reducer';</span></pre> <p><span class="koboSpan" id="kobo.1649.1">After exporting the file inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1650.1">index.ts</span></strong><span class="koboSpan" id="kobo.1651.1"> file, your reducer file is ready. </span><span class="koboSpan" id="kobo.1651.2">Before moving on to the last building </span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.1652.1">block of NgRx state management, which is selectors, we will add our reducer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1653.1">ApplicationConfig</span></strong><span class="koboSpan" id="kobo.1654.1"> object of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1655.1">expenses-registration</span></strong><span class="koboSpan" id="kobo.1656.1"> app. </span><span class="koboSpan" id="kobo.1656.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1657.1">app.config.ts</span></strong><span class="koboSpan" id="kobo.1658.1"> file, add the following inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1659.1">providers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1660.1"> array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1661.1">
provideStore(),
provideState({ name: expensesFeatureKey, reducer: expensesReducer }),</span></pre> <p><span class="koboSpan" id="kobo.1662.1">In the preceding code, we added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1663.1">provideStore()</span></strong><span class="koboSpan" id="kobo.1664.1"> function and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1665.1">provideState()</span></strong><span class="koboSpan" id="kobo.1666.1"> function inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1667.1">providers</span></strong><span class="koboSpan" id="kobo.1668.1"> array. </span><span class="koboSpan" id="kobo.1668.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1669.1">provideState()</span></strong><span class="koboSpan" id="kobo.1670.1"> function, we added an object with a name and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1671.1">reducer</span></strong><span class="koboSpan" id="kobo.1672.1"> property. </span><span class="koboSpan" id="kobo.1672.2">The name receives the unique key we provided inside the reducer file and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1673.1">reducer</span></strong><span class="koboSpan" id="kobo.1674.1"> property receives the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1675.1">expensesReducer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1676.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.1677.1">Now that you’ve created the reducer and added the configuration inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1678.1">ApplicationConfig</span></strong><span class="koboSpan" id="kobo.1679.1"> object, it’s time to move on to the last part of our NgRx </span><span class="No-Break"><span class="koboSpan" id="kobo.1680.1">state: selectors.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.1681.1">Defining NgRx selectors</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.1682.1">Selectors</span></strong><span class="koboSpan" id="kobo.1683.1"> are the last building</span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.1684.1"> block of </span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.1685.1">our NgRx state solution. </span><span class="koboSpan" id="kobo.1685.2">They are used to retrieve the parts of the state you’re interested in. </span><span class="koboSpan" id="kobo.1685.3">We’ll start by defining a selector that retrieves the entire </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1686.1">expenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1687.1"> state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1688.1">
export const selectExpensesState = createFeatureSelector&lt;ExpensesState&gt;(expensesFeatureKey);</span></pre> <p><span class="koboSpan" id="kobo.1689.1">Here, we used a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1690.1">createFeatureSelector()</span></strong><span class="koboSpan" id="kobo.1691.1"> function and provided it with the key we declared inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1692.1">expenses.reducer.ts</span></strong><span class="koboSpan" id="kobo.1693.1"> file. </span><span class="koboSpan" id="kobo.1693.2">Next, we can define additional selectors with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1694.1">createSelector()</span></strong><span class="koboSpan" id="kobo.1695.1"> function to retrieve specific parts of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1696.1">expenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1697.1"> state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1698.1">
export const selectExpenses = createSelector(selectExpensesState, (state) =&gt; state.expenses);
export const selectError = createSelector(selectExpensesState, (state) =&gt; state.error);
export const selectIsLoading = createSelector(selectExpensesState, (state) =&gt; state.isLoading);</span></pre> <p><span class="koboSpan" id="kobo.1699.1">In the preceding code snippet, we</span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.1700.1"> declared three additional selectors – one to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1701.1">expenses</span></strong><span class="koboSpan" id="kobo.1702.1"> state, one to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1703.1">error</span></strong><span class="koboSpan" id="kobo.1704.1"> state, and one to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1705.1">isLoading</span></strong><span class="koboSpan" id="kobo.1706.1"> state. </span><span class="koboSpan" id="kobo.1706.2">To finish the selectors, let’s export the file inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1707.1">index.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1708.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1709.1">
export * as ExpenseSelectors from './expenses.selectors';</span></pre> <p><span class="koboSpan" id="kobo.1710.1">After adding this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1711.1">export</span></strong><span class="koboSpan" id="kobo.1712.1">, also export the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1713.1">index.ts</span></strong><span class="koboSpan" id="kobo.1714.1"> file from your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1715.1">state</span></strong><span class="koboSpan" id="kobo.1716.1"> folder; this can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1717.1">index.ts</span></strong><span class="koboSpan" id="kobo.1718.1"> file of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1719.1">data-access</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1720.1"> library:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1721.1">
export * from './lib/state/expenses/index';</span></pre> <p><span class="koboSpan" id="kobo.1722.1">Now that we have all the parts of our NgRx state management system in place, it’s time to adjust the </span><span class="No-Break"><span class="koboSpan" id="kobo.1723.1">facade services.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.1724.1">Adjusting the facade service so that they use NgRx state management</span></h2>
<p><span class="koboSpan" id="kobo.1725.1">We will adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1726.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1727.1"> method and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1728.1">expenses</span></strong><span class="koboSpan" id="kobo.1729.1"> Signal inside the facade service. </span><span class="koboSpan" id="kobo.1729.2">We haven’t created </span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.1730.1">actions, effects, reducers, and selectors for all the other properties yet. </span><span class="koboSpan" id="kobo.1730.2">To convert the facade service, we need to start by injecting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1731.1">Store</span></strong><span class="koboSpan" id="kobo.1732.1"> class, which is exposed to you by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1733.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1734.1">ngrx/store</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1735.1"> package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1736.1">
protected readonly store = inject(Store);</span></pre> <p><span class="koboSpan" id="kobo.1737.1">After injecting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1738.1">Store</span></strong><span class="koboSpan" id="kobo.1739.1"> class, we can adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1740.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1741.1"> function in the facade service. </span><span class="koboSpan" id="kobo.1741.2">Simply remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.1742.1">this.expensesStore.fetchExpenses()</span></strong><span class="koboSpan" id="kobo.1743.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1744.1">fetchExpenses</span></strong><span class="koboSpan" id="kobo.1745.1"> function and dispatch the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1746.1">fetchExpenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1747.1"> action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1748.1">
this.store.dispatch(ExpenseActions.fetchExpenses());</span></pre> <p><span class="koboSpan" id="kobo.1749.1">Here, you used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1750.1">Store</span></strong><span class="koboSpan" id="kobo.1751.1"> class and called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1752.1">dispatch()</span></strong><span class="koboSpan" id="kobo.1753.1"> function on it to dispatch an action. </span><span class="koboSpan" id="kobo.1753.2">After adjusting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1754.1">fetchExpenses()</span></strong><span class="koboSpan" id="kobo.1755.1"> method, it’s time to adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1756.1">expenses</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1757.1">computed Signal.</span></span></p>
<p><span class="koboSpan" id="kobo.1758.1">Inside this computed Signal, we’re using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1759.1">expenses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1760.1">Subject</span></strong><span class="koboSpan" id="kobo.1761.1"> class from the store. </span><span class="koboSpan" id="kobo.1761.2">We need to change this for a Signal</span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.1762.1"> based on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1763.1">expenses</span></strong><span class="koboSpan" id="kobo.1764.1"> from your </span><span class="No-Break"><span class="koboSpan" id="kobo.1765.1">NgRx state.</span></span></p>
<p><span class="koboSpan" id="kobo.1766.1">To adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1767.1">expenses</span></strong><span class="koboSpan" id="kobo.1768.1"> computed Signal, you need to create a new property to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1769.1">expenses</span></strong><span class="koboSpan" id="kobo.1770.1"> state from the NgRx state and transform it into </span><span class="No-Break"><span class="koboSpan" id="kobo.1771.1">a Signal.</span></span></p>
<p><span class="koboSpan" id="kobo.1772.1">We can retrieve </span><strong class="source-inline"><span class="koboSpan" id="kobo.1773.1">expenses</span></strong><span class="koboSpan" id="kobo.1774.1"> from the NgRx state through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1775.1">selectExpenses</span></strong><span class="koboSpan" id="kobo.1776.1"> selector using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1777.1">select()</span></strong><span class="koboSpan" id="kobo.1778.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1779.1">Store</span></strong><span class="koboSpan" id="kobo.1780.1"> class. </span><span class="koboSpan" id="kobo.1780.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1781.1">select()</span></strong><span class="koboSpan" id="kobo.1782.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1783.1">Store</span></strong><span class="koboSpan" id="kobo.1784.1"> class combined with our selector will return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1785.1">expenses</span></strong><span class="koboSpan" id="kobo.1786.1"> state as an Observable, so we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1787.1">toSignal()</span></strong><span class="koboSpan" id="kobo.1788.1"> function to transform it into </span><span class="No-Break"><span class="koboSpan" id="kobo.1789.1">a Signal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1790.1">
expensesSignal = toSignal(this.store.select(ExpenseSelectors.selectExpenses), { initialValue: [] });</span></pre> <p><span class="koboSpan" id="kobo.1791.1">Now that we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1792.1">expenses</span></strong><span class="koboSpan" id="kobo.1793.1"> state from the NgRx state as a Signal inside the facade service, we can adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1794.1">expenses</span></strong><span class="koboSpan" id="kobo.1795.1"> computed Signal so that it uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1796.1">expenses</span></strong><span class="koboSpan" id="kobo.1797.1"> from the NgRx state instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1798.1">expenses</span></strong><span class="koboSpan" id="kobo.1799.1"> from the store. </span><span class="koboSpan" id="kobo.1799.2">Simply replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1800.1">this.expensesStore.expenses()</span></strong><span class="koboSpan" id="kobo.1801.1"> instances inside the computed Signal with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1802.1">this.expensesSignal()</span></strong><span class="koboSpan" id="kobo.1803.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.1804.1">that’s it.</span></span></p>
<p><span class="koboSpan" id="kobo.1805.1">With that, you’ve changed everything you need to change and are fetching and retrieving the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1806.1">expenses</span></strong><span class="koboSpan" id="kobo.1807.1"> state through the NgRx actions and state. </span><span class="koboSpan" id="kobo.1807.2">Before moving on, let’s add one more piece of NgRx state together so that you can understand everything that’s going on in NgRx </span><span class="No-Break"><span class="koboSpan" id="kobo.1808.1">state management.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.1809.1">Adding additional actions, effects, reducers, and selectors</span></h2>
<p><span class="koboSpan" id="kobo.1810.1">To get a better grasp of the NgRx state management we’ve built, let’s extend it a bit with additional actions, effects, reducers, </span><span class="No-Break"><span class="koboSpan" id="kobo.1811.1">and selectors.</span></span></p>
<p><span class="koboSpan" id="kobo.1812.1">We will start by adding an action to adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1813.1">inclVat</span></strong><span class="koboSpan" id="kobo.1814.1"> state, just like we did before, by adding an action. </span><span class="koboSpan" id="kobo.1814.2">Because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1815.1">inclVat</span></strong><span class="koboSpan" id="kobo.1816.1"> state only entails a state change and no HTTP request, you only need an </span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.1817.1">action to adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1818.1">inclVat</span></strong><span class="koboSpan" id="kobo.1819.1"> state and no success and failed actions because you aren’t making an HTTP request that can succeed or fail. </span><span class="koboSpan" id="kobo.1819.2">The action to adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1820.1">inclVat</span></strong><span class="koboSpan" id="kobo.1821.1"> state also doesn’t need a parameter because we will simply change the</span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.1822.1"> state to what it </span><span class="No-Break"><span class="koboSpan" id="kobo.1823.1">currently isn’t.</span></span></p>
<p><span class="koboSpan" id="kobo.1824.1">You can simply create an action and</span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.1825.1"> provide it with </span><span class="No-Break"><span class="koboSpan" id="kobo.1826.1">a description:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1827.1">
export const adjustVat = createAction(`[Expenses] Adjust incl vat`);</span></pre> <p><span class="koboSpan" id="kobo.1828.1">No effect is needed for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1829.1">inclVat</span></strong><span class="koboSpan" id="kobo.1830.1"> state change because you don’t perform an HTTP request or need to dispatch additional actions. </span><span class="koboSpan" id="kobo.1830.2">However, you do need a new reducer function inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1831.1">expensesReducer</span></strong><span class="koboSpan" id="kobo.1832.1"> to adjust the </span><span class="No-Break"><span class="koboSpan" id="kobo.1833.1">state object.</span></span></p>
<p><span class="koboSpan" id="kobo.1834.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1835.1">createReducer()</span></strong><span class="koboSpan" id="kobo.1836.1"> function of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1837.1">expensesReducer</span></strong><span class="koboSpan" id="kobo.1838.1">, add an additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.1839.1">on()</span></strong><span class="koboSpan" id="kobo.1840.1"> function to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1841.1">inclVat</span></strong><span class="koboSpan" id="kobo.1842.1"> state when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1843.1">adjustVat</span></strong><span class="koboSpan" id="kobo.1844.1"> action </span><span class="No-Break"><span class="koboSpan" id="kobo.1845.1">is dispatched:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1846.1">
on(ExpenseActions.adjustVat, (state) =&gt; ({
  ...state,
  inclVat: !state.inclVat
})),</span></pre> <p><span class="koboSpan" id="kobo.1847.1">As you can see, upon dispatching the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1848.1">adjustVat</span></strong><span class="koboSpan" id="kobo.1849.1"> action, we will change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1850.1">inclVat</span></strong><span class="koboSpan" id="kobo.1851.1"> state to what it currently isn’t. </span><span class="koboSpan" id="kobo.1851.2">After adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1852.1">reducer</span></strong><span class="koboSpan" id="kobo.1853.1"> function, you need to add a selector to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1854.1">inclVat</span></strong><span class="koboSpan" id="kobo.1855.1"> property from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1856.1">state object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1857.1">
export const selectInclVat = createSelector(selectExpensesState, (state) =&gt; state.inclVat);</span></pre> <p><span class="koboSpan" id="kobo.1858.1">Now, the only thing that is left to do is adjust the facade service and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1859.1">inclVat</span></strong><span class="koboSpan" id="kobo.1860.1"> property from the NgRx state instead of the Signal </span><span class="No-Break"><span class="koboSpan" id="kobo.1861.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1862.1">expenses.store.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1863.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1864.1">To adjust the facade service, start</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.1865.1"> by adding an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1866.1">inclVat</span></strong><span class="koboSpan" id="kobo.1867.1"> property</span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.1868.1"> and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1869.1">toSignal()</span></strong><span class="koboSpan" id="kobo.1870.1"> function to convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1871.1">selectInclVat</span></strong><span class="koboSpan" id="kobo.1872.1"> selector into </span><span class="No-Break"><span class="koboSpan" id="kobo.1873.1">a Signal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1874.1">
inclVat = toSignal(this.store.select(ExpenseSelectors.selectInclVat), { initialValue: false });</span></pre> <p><span class="koboSpan" id="kobo.1875.1">After adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1876.1">inclVat</span></strong><span class="koboSpan" id="kobo.1877.1"> property, all you have to do is change </span><strong class="source-inline"><span class="koboSpan" id="kobo.1878.1">this.expensesStore.inclVat()</span></strong><span class="koboSpan" id="kobo.1879.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1880.1">this.inclVat()</span></strong><span class="koboSpan" id="kobo.1881.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1882.1">expenses</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1883.1">computed Signal.</span></span></p>
<p><span class="koboSpan" id="kobo.1884.1">Lastly, you need to adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1885.1">adjustVat()</span></strong><span class="koboSpan" id="kobo.1886.1"> function inside the facade service. </span><span class="koboSpan" id="kobo.1886.2">Remove what is currently in the function and replace it with a dispatch of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1887.1">adjustVat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1888.1"> action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1889.1">
this.store.dispatch(ExpenseActions.adjustVat());</span></pre> <p><span class="koboSpan" id="kobo.1890.1">After adding the preceding code, you’ve made all necessary changes and you’re now using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1891.1">inclVat</span></strong><span class="koboSpan" id="kobo.1892.1"> property from the NgRx state instead of the Signal from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1893.1">expenses.store.ts</span></strong><span class="koboSpan" id="kobo.1894.1">. </span><span class="koboSpan" id="kobo.1894.2">Now, all you need to do is add the rest of the actions, effects, reducers, and selectors so that you can remove the store from the facade service entirely and use the NgRx state </span><span class="No-Break"><span class="koboSpan" id="kobo.1895.1">for everything.</span></span></p>
<p><span class="koboSpan" id="kobo.1896.1">As an exercise, you can try to add the additional actions, effects, reducers, and selectors yourself based on what we did for the list of expenses. </span><span class="koboSpan" id="kobo.1896.2">After adding the additional actions, effects, reducers, and selectors, you should be able to fully adjust the expenses facade and remove the store implementation completely. </span><span class="koboSpan" id="kobo.1896.3">If you get stuck or simply want to copy the code, you can get it from this book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.1897.1">repository: </span></span><a href="https://github.com/PacktPublishing/Effective-Angular"><span class="No-Break"><span class="koboSpan" id="kobo.1898.1">https://github.com/PacktPublishing/Effective-Angular</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1899.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1900.1">In this section, you explored NgRx and learned how to use it to manage the state of your application. </span><span class="koboSpan" id="kobo.1900.2">We discussed the default NgRx implementation to manage the state. </span><span class="koboSpan" id="kobo.1900.3">Note that the library has more solutions and packages to offer, but this is outside the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.1901.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.1902.1">Some of the other things NgRx has to offer are </span><strong class="source-inline"><span class="koboSpan" id="kobo.1903.1">signalStore</span></strong><span class="koboSpan" id="kobo.1904.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1905.1">signalState</span></strong><span class="koboSpan" id="kobo.1906.1">, two solutions that you can use to manage your state using NgRx and signals without having to convert Observables using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1907.1">toSignal()</span></strong><span class="koboSpan" id="kobo.1908.1">, which is what we did in this section. </span><span class="koboSpan" id="kobo.1908.2">There are useful RxJS operators in the NgRx library. </span><span class="koboSpan" id="kobo.1908.3">We only used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1909.1">ofType()</span></strong><span class="koboSpan" id="kobo.1910.1"> operators, but NgRx offers more</span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.1911.1"> utility operators, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1912.1">concatLatestFrom()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1913.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1914.1">tapResponse()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1915.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1916.1">NgRx also offers solutions to manage component state and to dispatch actions of access state on route changes. </span><span class="koboSpan" id="kobo.1916.2">I highly recommend exploring NgRx and other state management libraries on </span><span class="No-Break"><span class="koboSpan" id="kobo.1917.1">your own.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.1918.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1919.1">You’ve learned a lot in this chapter and brought everything we learned in </span><a href="B21625_07.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1920.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.1921.1"> together. </span><span class="koboSpan" id="kobo.1921.2">You learned what state management is and why you need a good state management solution. </span><span class="koboSpan" id="kobo.1921.3">You also learned about immutability, unidirectional data flow, and side effects. </span><span class="koboSpan" id="kobo.1921.4">After some theory, you started building a state management solution using RxJS’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1922.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.1923.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1924.1">Subject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1925.1"> classes.</span></span></p>
<p><span class="koboSpan" id="kobo.1926.1">When you finished building the state management solution using RxJS, you created a facade service that connects your component layer to the data-access and state management layers of your application. </span><span class="koboSpan" id="kobo.1926.2">To end your custom state management solution, you converted the RxJS state implementation into a Signals implementation, further simplifying your component layer and </span><span class="No-Break"><span class="koboSpan" id="kobo.1927.1">facade service.</span></span></p>
<p><span class="koboSpan" id="kobo.1928.1">Finally, you learned about the shortcomings of using RxJS and Signals for your state management solution and replaced them with an NgRx implementation that uses actions, effects, reducers, </span><span class="No-Break"><span class="koboSpan" id="kobo.1929.1">and selectors.</span></span></p>
<p><span class="koboSpan" id="kobo.1930.1">In the next chapter, you’ll learn how to improve the performance and security of your </span><span class="No-Break"><span class="koboSpan" id="kobo.1931.1">Angular applications.</span></span></p>
</div>


<div class="Content" id="_idContainer031">
<h1 id="_idParaDest-152" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.1.1">Part 3:Getting Ready for Production with Automated Tests, Performance, Security, and Accessibility</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In the last part, you’ll learn how to improve the performance of your Angular applications and make them more secure and accessible for everyone. </span><span class="koboSpan" id="kobo.2.2">Starting with performance, you’ll do a deep dive into Angular’s change detection mechanism, learning how Angular detects changes and what actions you can take to reduce the number of change detection cycles. </span><span class="koboSpan" id="kobo.2.3">When you know how change detection works in detail, you’ll learn how to prevent other factors from impacting the performance of your Angular applications. </span><span class="koboSpan" id="kobo.2.4">Then, you will explore some common security risks when developing Angular applications and how to mitigate them. </span><span class="koboSpan" id="kobo.2.5">Furthermore, you’ll dive into accessibility, making your application content translatable using Transloco and learning how to develop applications accessible to users from different locations and abilities. </span><span class="koboSpan" id="kobo.2.6">Additionally, you’ll learn how to write and run unit tests using Jest, and end-to-end tests using Cypress, giving you the confidence to deploy your changes without breaking anything. </span><span class="koboSpan" id="kobo.2.7">Finally, you’ll make some final improvements, learn how to analyze and optimize your bundle sizes, and automate your </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">deployment process.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B21625_09.xhtml#_idTextAnchor170"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Enhancing the Performance and Security of Angular Applications</span></em></li>
<li><a href="B21625_10.xhtml#_idTextAnchor185"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Internationalization, Localization, and Accessibility of Angular Applications</span></em></li>
<li><a href="B21625_11.xhtml#_idTextAnchor200"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Testing Angular Applications</span></em></li>
<li><a href="B21625_12.xhtml#_idTextAnchor219"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Deploying Angular Applications</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer032">
</div>
</div>
</body></html>