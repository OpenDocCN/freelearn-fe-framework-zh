- en: '*Chapter 7*: Testing and Auditing Your Site'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about what unit testing is, why it's useful,
    and how to start unit testing your Gatsby site. We will then learn how we can
    use Git hooks to trigger your unit tests and other commands when running common
    Git commands. Following this, we will investigate how we can measure core web
    vitals to understand how well our Gatsby site's page experience is performing,
    both in lab and field environments. By the end of this chapter, you should feel
    comfortable that you can analyze how well a Gatsby site is working locally by
    using unit tests and looking at web vitals when it is out there on the web.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Git hooks for tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing core web vitals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you will need to have completed [*Chapter 6*](B15983_06_ePub_RK.xhtml#_idTextAnchor092),
    *Improving Your Site's Search Engine Optimization*. You will also need Google
    Chrome installed.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter07](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is a way of testing the smallest piece of code that you have logically
    defined within your application. During unit testing, we isolate a small part
    of the code and verify that it is behaving as intended independently from the
    rest of the code base. We instantiate this piece of code, invoke it, and then
    observe its behavior. If the observed behavior matches what we expected, then
    we know that our code is doing what it should be. By setting up a multitude of
    these tests, we can have a better understanding of where something has broken
    when we edit large parts of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within React and Gatsby, there are multiple different ways in which you can
    set up unit tests. Here, we will focus on one of the most popular combinations
    – **Jest** and **React Testing Library**. Let''s create a structure within our
    repository that will allow us to test our site using these tools:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the necessary dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `jest.config.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Both Gatsby and Jest use Babel under the hood. However, unlike Gatsby, Jest
    does not handle its own Babel configuration. We use the `jest.config.js` file
    to manually set up Jest with Babel, as well as configure our tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s break down the contents of this file so that we understand what each
    part is doing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'a. `transform`: This tells Jest that all the files that end in `.js` or `.jsx`
    need to be handled with a `jest-preprocess.js` file, which we will create in the
    next step.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b. `moduleNameMapper`: When testing, it is uncommon to test static assets such
    as images. As such, Jest does not care for them. But it is still important that
    it knows how to handle them as they may be embedded in your code. Here, we are
    giving Jest a mock for handling stylesheets that uses the `identity-obj-proxy`
    package, which we installed in the first step, and another mock that handles common
    image, video, and sound files. We will create this second mock later in this section.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'c. `testPathIgnorePatterns`: This tells Jest to ignore any tests found within
    `node_modules` as we do not want to bring in tests that have been found within
    our packages and the `.cache` directory.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'd. `transformIgnorePatterns`: Here, we tell Jest to ignore Gatsby when it is
    transforming code, as Gatsby includes untranspiled ES6 code.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'e. `globals`: This is where we define a global variable called `__PATH_PREFIX__`
    that Gatsby uses behind the scenes. We need to define it here too as some Gatsby
    components will break without it being present.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'f. `setupFiles`: Here, we list the configuration files that we would like to
    use to configure the testing environment. It is run once per test. Here, we tell
    it to run `loadershim.js`, which we will create later in this section.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'g. `setupFilesAfterEnv`: Here, we specify the configuration files we would
    like to use to set up our tests. Crucially, these files run after the testing
    environment has been set up.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `jest-preprocess.js` file within your root directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is where we define our Babel configuration. As we are working with Gatsby,
    we are using the `babel-preset-gatsby` preset. You can expand this preset list
    as necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `loadershim.js` file within your root directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use this file to mock a global `loader.enqueue` function using a Jest mock
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new folder in your root directory called `__mocks__`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `file-mock.js` file within the `__mocks__` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we mentioned in *Step 2*, this file mocks out static asset file types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `gatsby.js` file within the `__mocks__` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are mocking out any components or functions that we are using from
    the `gatsby` package. We strip the props from the `Link` component and return
    an `<a/>` tag instead. We return a `div` in place of the `StaticQuery` component.
    Finally, we also mock out the `useStaticQuery` function with a Jest mock function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `gatsby-plugin-image.js` file within the `__mocks__` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are mocking out any components or functions that we are using from
    the `gatsby-plugin-image` package. We return a `div` in place of the `StaticImage`
    component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `jest.setup.js` file within your root directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before each test, we need to mock a return value for `useStaticQuery`. Any page
    components that make use of the SEO component will fail unless they can retrieve
    this data from the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `test-utils.js` file within your `src` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file is not required but is helpful. Much of your application might make
    use of a provider, which we would normally wrap our root element in, within `gatsby-browser.js`.
    We can't do that in Jest. So, instead of defining `wrapper` in every test, it
    is preferable to create a custom `render` function that wraps any content in the
    required providers. We then call this `render` instead of the one that's exported
    from `@testing-library/react` when required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a test script within your `package.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have everything in place to start testing! This book does not have space
    for a full guide on unit testing. However, let's create a few example tests for
    a few different component types, such as simple components, SEO components, and
    our Gatsby page components.
  prefs: []
  type: TYPE_NORMAL
- en: Testing simple components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing simple components can be done in the same way you would do so in any
    standard react project. Let's take a look at how we would test our header component,
    as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Header.test.js` file next to your header component using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are rendering our `Header` component to the screen. We are then testing
    that the screen contains some text stating `Site Header` to ensure that the `Header`
    component is rendered. We do this by using the `screen.getByText` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to test simple components, let's look at a more complex
    example – your site's SEO component.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the SEO component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common component among Gatsby pages that is important to test is the SEO component.
    It is important to ensure that the meta tags we are adding using the component
    are being correctly applied to the document's head so that we know that when that
    page is shared, it will have the rich previews that we set up in [*Chapter 6*](B15983_06_ePub_RK.xhtml#_idTextAnchor092),
    *Improving Your Site's Search Engine Optimization*. Let's look at how we could
    test this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `SEO.test.js` file next to your SEO component using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, we inform `react-helmet-async` from `HelmetProvider` that it cannot use
    the `SEO` component. After rendering, we check that the context's helmet object
    contains meta, and if it does, we make sure it matches the snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's understand how we would test whole site pages.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Gatsby page components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you ever want to test pages, you can make use of the custom `render` function
    we set up in *Step 10* of the *Exploring unit testing* section. Let's take a look
    at how we would test our site's index page as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike our component tests, it is best to avoid placing your page tests in the
    same directory as the page files. This is because Gatsby will automatically try
    and create pages for every exported React component in the `pages` directory.
    Instead, create a folder alongside the `pages` directory called `pages-lib` that's
    specifically for Gatsby page tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `index.test.js` file in the `pages-lib` directory using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, we are making use of the custom render function that we set
    up in the `test-utils.js` file. This is because page components typically also
    contain an `SEO` component, which uses the `Helmet` component, and, as such, needs
    to be wrapped in `HelmetProvider`. It's also important to pass any data to the
    `data` prop that the page would normally retrieve via GraphQL, as GraphQL queries
    on the page will not run.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to write tests, let's understand how we can trigger
    them with Git hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Git hooks for tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `push` our code, and if they fail, we can stop the push. By implementing this
    feature, it's unlikely that the code being pushed will break any functionality
    we test for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this functionality now by creating a Git hook that is triggered
    by a `git push`. This will ensure our unit tests pass before allowing the `push`
    command to run. We will be using the `husky` package to do this as it is easy
    to set up and maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the necessary dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `postinstall` script in your `package.json` file with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will add a new script to our `package.json` file called `postinstall`
    that causes `husky` to be installed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run this new script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we are setting this up for the first time, we will need to trigger the `husky`
    install manually by running the `postinstall` script via the command line. Every
    subsequent developer will never need to run this manually.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This adds a `pre-push` hook that runs our npm `test` script. After running this
    command, every subsequent push will run the `test` script and only push on success.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Running tests on push is not always the best test. We may have uncommitted code
    locally that is causing the tests to pass, which are not included in the push.
    This can cause the same tests to fail in **continuous integration/continuous deployment**
    (**CI/CD**) environments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we understand how to trigger unit tests with Git hooks, let's turn
    our attention to a different kind of test – auditing core web vitals.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing core web vitals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web vitals ([https://web.dev/vitals](https://web.dev/vitals)) are an initiative
    by Google to provide unified guidance for quality signals that are essential to
    delivering a great user experience on the web. These directly tie into the signals
    discussed in [*Chapter 6*](B15983_06_ePub_RK.xhtml#_idTextAnchor092), *Improving
    Your Site's Search Engine Optimization*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core web vitals are a small group of Google''s web vitals that focus on
    three pillars – how fast the page loads, how soon you can interact with the page,
    and how stable the page is while it is loading and while the user is interacting
    with it. These three pillars are encompassed in the following three metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Largest Contentful Paint**: A representation of load time. It is the measure
    of the time the browser takes to make the majority of a page''s content visible
    from the moment you start navigating to it. This is the moment at which a user
    perceives the site to have finished loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First Input Delay**: Measures the response time to interact. First input
    delay is the time the browser takes from navigation to a point where you can interact
    with any element on the page, such as a form or button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cumulative Layout Shift**: A measurement of how stable the page is while
    it loads. The less your elements shift around the page while the page loads, the
    higher your score will be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we understand these core web vitals, how do we measure them? There
    are two different methods we can use to retrieve these metrics. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab Test Data**: Data generated on demand by you for testing. This is less
    accurate as it is based on approximations of user data. But while developing,
    it is often incredibly useful as we can use it to develop our site iteratively,
    without ever having to deploy it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Field Data**: Data collected from users when viewing your site. This is the
    most accurate source of data as it directly corresponds to how your users are
    perceiving your site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at how we can retrieve lab test data using the lighthouse tool and
    field data using the `web-vitals` package.
  prefs: []
  type: TYPE_NORMAL
- en: Using Chrome's lighthouse tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The lighthouse tool will analyze your website for performance, accessibility,
    search engine optimization, and progressive web app features. Not only does it
    give you a score in each of these categories, but it will also tell you how to
    improve your site to increase these scores. The best part? It's built into Google
    Chrome – no other downloads or tooling installation is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s generate a lighthouse report for our site using the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Build your site using the `gatsby build` command. As we saw in [*Chapter 1*](B15983_01_ePub_RK.xhtml#_idTextAnchor013),
    *An Overview of Gatsby.js for the Uninitiated*, this creates a production build
    of your website. It is *vitally* important that we audit a production build of
    the site instead of a development build, since the development tools that Gatsby
    adds into the build drastically increase your site's bundle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serve your build using the `gatsby serve` command. With the default settings,
    your site should be live on http://localhost:9000/.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Google Chrome in incognito mode and navigate to http://localhost:9000/.
    You should see the index page of your site. By loading this page in incognito
    mode, we ensure that no Chrome extensions you have installed interfere with the
    test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click anywhere on the page and click **Inspect**. This will bring up **Developer
    Tools** on the right-hand side of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the chevron in the center of the top bar and select **Lighthouse**:![Figure
    7.1 – Lighthouse location Within Developer Tools
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B15983.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.1 – Lighthouse location Within Developer Tools
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will present you with the lighthouse report generator window, which looks
    like this:![Figure 7.2 – Lighthouse report generator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B15983.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.2 – Lighthouse report generator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the categories you would like to audit, all of which will be switched
    on by default. All of these categories are important, and it is advised to keep
    them all on unless you are specifically trying to improve a single metric and
    want the report to be generated more quickly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You must also select a **Device** type. By default, this setting is set to **Mobile**.
    Lighthouse will try to emulate a mobile device attempting to access the page,
    which includes using a smaller viewport and throttling the network connection.
    Running multiple reports – one for each device type – is a great idea as it ensures
    that your site has a great experience on every device. Note that for SEO purposes,
    Google uses mobile metrics in their site rankings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clicking **Generate report** will start lighthouse. You may see the page flash
    a few times during this process. This is nothing to worry about. Congratulations
    – you've just run your first lighthouse report!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once lighthouse has finished running, you will see that the report generator
    window has been replaced with a report that contains a section for each category.
    Let''s take a look at the **Performance** category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Lighthouse Performance report'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B15983.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Lighthouse Performance report
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice some familiar items within these metrics. Lighthouse has audited
    each of the three core web vitals as part of its audit. Each metric will be color-coded
    to give you an indication of where you need to focus your efforts. Green means
    good, orange means that it needs improvement, while red means that the score for
    this metric is considered poor. In cases where your scores are not optimal, lighthouse
    will propose changes that you can make to your site to improve the score. Let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Lighthouse Accessibility report with suggested improvements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B15983.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Lighthouse Accessibility report with suggested improvements
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see that our buttons are not currently accessible
    as they do not have accessible names. Hovering over the failing element will highlight
    it within the site so that we can rectify it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to retrieve lab test data, let's investigate how
    we can retrieve field data using the `web-vitals` JavaScript package.
  prefs: []
  type: TYPE_NORMAL
- en: Using the web-vitals JavaScript package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `web-vitals` package is a 1 KB package that's developed by the Google Chrome
    team. This package monitors web vitals, including core web vitals on real users
    as they visit your site. It aims to measure them in a way that is incredibly similar
    to other Google reporting tools.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The `web-vitals` package makes use of browser APIs that are not supported in
    all browsers. The package only guarantees complete support in Google Chrome. If
    you are gathering metrics using this tool, please consider that the results will
    only be retrievable on supported browsers. If you are collating these metrics,
    it is important to remember that they do not necessarily represent all your site
    visitors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how to use `web-vitals` within our application, let''s create
    a rudimentary example where we simply log the vitals when the user navigates to
    our site:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `web-vitals` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that utilizes the `web-vitals` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we retrieve the metrics and then simply log them to the console.
    It is important to wrap them in a `try catch` block to avoid crashing the page
    when the APIs are not supported. This also allows you to handle the error accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the following code within your `gatsby-browser.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By calling the function within this file, it will run once when the user initially
    navigates to our site from an external source, but not on every page navigation
    within the site.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Starting your development server and navigating to your site via Google Chrome,
    you should see the metrics logged in the console. In this example, we are simply
    displaying them, but we could be sending these to our analytics platform. We will
    look at this in more detail in [*Chapter 8*](B15983_08_ePub_RK.xhtml#_idTextAnchor116),
    *Web Analytics and Performance Monitoring*.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a good understanding of how to measure web vitals both in the field
    and during development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about unit testing – what it is and why it is important.
    Then, we integrated unit testing into our Gatsby site. We also looked at a few
    different recipes for unit tests that we can use to test different types of react
    components. We then learned about Git hooks and implemented a Git hook that runs
    unit tests using `husky`. Finally, we investigated core web vitals. We used web
    vitals to test our page experience both locally using lighthouse, and in the field
    using the `web-vitals` package. Using what you've learned, you should now feel
    that you can test a site locally, as well as audit its performance, accessibility,
    and SEO once it is out on the web.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discover how we can add analytics to our site,
    including how we can track `web-vitals` field data.
  prefs: []
  type: TYPE_NORMAL
