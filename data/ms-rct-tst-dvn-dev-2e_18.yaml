- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Adding Features Guided by Cucumber Tests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由Cucumber测试引导的特性
- en: In the last chapter, we studied the basic elements of writing Cucumber tests
    and how to use Puppeteer to manipulate our UI. But we haven’t yet explored how
    these techniques fit into the wider development process. In this chapter, we’ll
    implement a new application feature, but starting the process with Cucumber tests.
    These will act as acceptance tests that our (imaginary) product owner can use
    to determine whether the software works as required.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了编写Cucumber测试的基本元素以及如何使用Puppeteer操作我们的UI。但我们还没有探讨这些技术如何融入更广泛的开发生成过程。在本章中，我们将实现一个新的应用程序功能，但首先从Cucumber测试开始。这些将作为验收测试，我们的（虚构的）产品负责人可以使用它来确定软件是否按要求工作。
- en: Acceptance testing
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试
- en: An **acceptance test** is a test that a product owner or customer can use to
    decide whether they accept the delivered software. If it passes, they accept the
    software. If it fails, the developers must go back and adjust their work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**验收测试**是一个产品负责人或客户可以使用来决定是否接受交付的软件的测试。如果它通过，他们接受软件。如果它失败，开发者必须回去调整他们的工作。'
- en: We can use the term **Acceptance-Test-Driven Development (ATDD)** to refer to
    a testing workflow that the whole team can participate in. Think of it as like
    TDD but it is done at the wider team level, with the product owner and customer
    involved in the cycle. Writing BDD tests using Cucumber is one way—but not the
    only way—that you can bring ATDD to your team.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用术语**验收测试驱动开发（ATDD）**来指代一个整个团队都可以参与的测试工作流程。将其视为类似于TDD，但它是在更广泛的团队层面上进行的，产品负责人和客户都参与其中。使用Cucumber编写BDD测试是将ATDD引入团队的一种方式——但不是唯一的方式。
- en: In this chapter, we’ll use our BDD-style Cucumber tests to act as our acceptance
    tests.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用我们的BDD风格的Cucumber测试作为我们的验收测试。
- en: 'Imagine that our product owner has seen the great work that we’ve done building
    **Spec Logo**. They have noted that the share screen functionality is good, but
    it could do with an addition: it should give the presenter the option of resetting
    their state before sharing begins, as shown:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们的产品负责人已经看到了我们构建**Spec Logo**所做的出色工作。他们注意到共享屏幕功能很好，但还可以添加一些功能：它应该给演讲者提供在开始共享之前重置其状态的选择，如下所示：
- en: '![Figure 18.1 – The new sharing dialog ](img/Figure_18.01_B18423.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图18.1 – 新的共享对话框](img/Figure_18.01_B18423.jpg)'
- en: Figure 18.1 – The new sharing dialog
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1 – 新的共享对话框
- en: The product owner has provided us with some Cucumber tests that are currently
    red for implementation—both the step definitions and the production code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 产品负责人为我们提供了一些目前为红色以供实施的Cucumber测试——包括步骤定义和生成代码。
- en: 'This chapter covers the following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Adding Cucumber tests for a dialog box
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为对话框添加Cucumber测试
- en: Fixing Cucumber tests by test-driving production code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过测试驱动生产代码修复Cucumber测试
- en: Avoiding timeouts in test code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在测试代码中使用超时
- en: By the end of the chapter, you’ll have seen more examples of Cucumber tests
    and how they can be used as part of your team’s workflow. You’ll also have seen
    how to avoid using specific timeouts within your code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将看到更多关于Cucumber测试的示例以及它们如何作为团队工作流程的一部分被使用。你还将了解到如何避免在代码中使用特定的超时设置。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter18](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter18)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter18](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter18)'
- en: Adding Cucumber tests for a dialog box
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为对话框添加Cucumber测试
- en: In this section, we’ll add a new Cucumber test that won’t yet pass.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一个新的Cucumber测试，它目前不会通过。
- en: 'Let’s start by taking a look at the new feature:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看这个新功能：
- en: 'Open the `features/sharing.feature` file and take a look at the first feature
    that you’ve been given. Read through the steps and try to understand what our
    product owner is describing. The test covers quite a lot of behavior—unlike our
    unit tests. It tells a complete story:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`features/sharing.feature`文件，看看你被给出的第一个特性。阅读步骤并尝试理解我们的产品负责人在描述什么。测试覆盖了很多行为——与我们的单元测试不同。它讲述了一个完整的故事：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first `the presenter navigated to the application page`, already works,
    and you can verify this if you run `npx cucumber-js`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个`the presenter navigated to the application page`已经工作，如果你运行`npx cucumber-js`，你可以验证这一点。
- en: 'The next step, `the presenter entered the following instructions at the prompt`,
    is very similar to a step from the last chapter. We could choose to extract the
    commonality here, just as we did with the `browseToPageFor` function; however,
    we’ll wait until our test and implementation are complete before refactoring.
    For now, we’ll just duplicate the code. Open `features/support/sharing.steps.js`
    and add the following step definition at the bottom of the code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个步骤 `the presenter entered the following instructions at the prompt` 与上一章的一个步骤非常相似。我们本可以选择在这里提取共性，就像我们处理
    `browseToPageFor` 函数那样；然而，我们将等待测试和实现完成后再进行重构。现在，我们只是复制代码。打开 `features/support/sharing.steps.js`
    并在代码底部添加以下步骤定义：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next up is a `the presenter clicked the button ''startSharing''`. The line
    that appears after this is the first `npx cucumber-js` and you’ll be given template
    code for this function. Copy and paste the template code into your step definition
    file, as shown in the following code block:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是 `the presenter clicked the button 'startSharing'`。在这之后出现的行是第一个 `npx cucumber-js`，你将获得这个函数的模板代码。将模板代码复制并粘贴到你的步骤定义文件中，如下面的代码块所示：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Two When phrases
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 When 语句
- en: This scenario has *two* `When` phrases, which is unusual. Just as with your
    unit tests in the **Act** phase, you generally want just one **When** phrase.
    However, since there are two users working together at this point, it makes sense
    to have a single action for both of them, so we’ll let our product owner off the
    hook on this occasion.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景有两个 `When` 语句，这是不寻常的。就像你在 **Act** 阶段的单元测试一样，你通常只想有一个 **When** 语句。然而，由于此时有两个用户一起工作，为这两个用户有一个单一的操作是有意义的，所以我们将在这个场合让我们的产品所有者免责。
- en: 'This step definition is very similar to the ones we’ve written before. Fill
    out the function as shown in the following code block. There is a new call to
    `waitForSelector`. This waits for the button to appear on the page before we continue,
    which gives the dialog time to render:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个步骤定义与我们之前编写的非常相似。按照以下代码块所示填写函数。这里有一个新的 `waitForSelector` 调用。这个调用在我们继续之前等待按钮出现在页面上，这给了对话框渲染的时间：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second `Then` clauses. The first is `the observer should see no lines`;
    run `npx cucumber-js` and copy and paste the template function that Cucumber provides,
    as shown in the following code block:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个 `Then` 子句。第一个是 `the observer should see no lines`；运行 `npx cucumber-js` 并复制
    Cucumber 提供的模板函数，如下面的代码块所示：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For this step, we want to assert that there are no line elements on the page:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个步骤，我们想要断言页面上没有线元素：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running `npx cucumber-js`, you should see that this step passes, and the next
    one is very similar. Copy the step definition you just wrote and modify it to
    work for the presenter, as shown in the following code block. Again, we can clean
    up the duplication later:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npx cucumber-js`，你应该会看到这个步骤通过了，下一个步骤非常相似。复制你刚才编写的步骤定义，并修改它以适用于演示者，如下面的代码块所示。同样，我们稍后可以清理重复的部分：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run Cucumber now, and you’ll see that this step fails; this is the first failure
    that we’ve got. It points to the specific change that we’ll need to make in the
    code base:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行 Cucumber，你会看到这个步骤失败了；这是我们遇到的第一次失败。它指向我们需要在代码库中做出的具体更改：
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since we have hit a red step, we could now go back and start working on our
    code to make this green. However, because we just have two almost identical clauses
    to complete, I’m going to choose to complete these definitions before continuing.
    Cucumber tells us the template function that we should use, so add that now, as
    follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经遇到了一个红色步骤，我们现在可以回过头来开始编写代码，使其变为绿色。然而，因为我们只有两个几乎相同的子句需要完成，我将选择在继续之前完成这些定义。Cucumber
    告诉我们应使用哪个模板函数，所以现在添加如下：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need to define a couple of helpers that can tell us the current *x*, *y*,
    and angle values of the turtle. We need this because all we have is the SVG `polygon`
    element, which uses a `points` string and a `transform` string to position the
    turtle. Our helpers will take these strings and convert them back to numbers for
    us. As a reminder, here’s how the turtle is initially positioned:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要定义几个辅助函数，可以告诉我们海龟当前的 *x*、*y* 和角度值。我们需要这样做，因为我们只有 SVG `polygon` 元素，它使用 `points`
    字符串和 `transform` 字符串来定位海龟。我们的辅助函数将把这些字符串转换回数字。作为提醒，以下是海龟初始的位置：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can use the first `points` coordinate to calculate *x* and *y*, by adding
    `5` to the first number and subtracting `5` from the second. The angle can be
    calculated by taking the first parameter to rotate and subtracting `90`. Create
    a new file named `features/support/turtle.js`, and then add the following two
    definitions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用第一个`points`坐标来计算*x*和*y*，通过将第一个数字加5，从第二个数字减5。角度可以通过将旋转的第一个参数减去90来计算。创建一个名为`features/support/turtle.js`的新文件，然后添加以下两个定义：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In `feature/sharing.steps.js`, update the step definition, as shown in the
    following code block:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`feature/sharing.steps.js`中，更新步骤定义，如下面的代码块所示：
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, repeat this step definition for the presenter, as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按照以下方式为演示者重复此步骤定义：
- en: '[PRE12]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That’s the first test; now, let’s move on to the second scenario:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那是第一个测试；现在，让我们继续到第二个场景：
- en: 'Nearly all of the step definitions for our second scenario are already implemented;
    there are only two that aren’t:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们第二个场景的大部分步骤定义已经实现；只有两个还没有：
- en: '[PRE13]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We already have a step definition that is very similar to these two in `features/support/drawing.steps.js`.
    Let’s extract that logic into its own module so that we can reuse it. Create a
    new file named `features/support/svg.js` and then duplicate the following code
    from the drawing step definitions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`features/support/drawing.steps.js`中有一个与这两个非常相似的步骤定义。让我们将这个逻辑提取到一个单独的模块中，这样我们就可以重用它。创建一个名为`features/support/svg.js`的新文件，然后从绘图步骤定义中复制以下代码：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In `features/support/drawing.steps.js`, modify the `these lines should have
    been drawn` step definition so that it now uses this function:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`features/support/drawing.steps.js`中，修改`这些行应该已经被绘制`步骤定义，使其现在使用此函数：
- en: '[PRE15]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The two new step definitions for our latest sharing scenario are now straightforward.
    In `features/support/sharing.steps.js`, add the following `import` statement and
    step definitions:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最新共享场景的两个新步骤定义现在很简单。在`features/support/sharing.steps.js`中，添加以下`import`语句和步骤定义：
- en: '[PRE16]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You’ve now seen how to write longer step definitions and how to extract common
    functionality into support functions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了如何编写较长的步骤定义以及如何将公共功能提取到支持函数中。
- en: With the step definitions complete, it’s time to make both these scenarios pass.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤定义完成后，是时候让这两个场景都通过了。
- en: Fixing Cucumber tests by test-driving production code
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过测试驱动生产代码来修复Cucumber测试
- en: In this section, we’ll start by doing a little up-front design, then we’ll write
    unit tests that cover the same functionality as the Cucumber tests, and then use
    those to build out the new implementation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将先进行一些初步设计，然后编写单元测试，以覆盖Cucumber测试的功能，然后使用这些测试来构建新的实现。
- en: 'Let’s do a little up-front design:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一些初步设计：
- en: When the user clicks on **Start sharing**, a dialog should appear with a **Reset**
    button.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击**开始共享**时，应该弹出一个带有**重置**按钮的对话框。
- en: 'If the user chooses to reset, the Redux store is sent a `START_SHARING` action
    with a new `reset` property that is set to `true`:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户选择重置，Redux存储将发送一个带有新`reset`属性设置为`true`的`START_SHARING`动作：
- en: '[PRE17]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If the user chooses to share their existing commands, then the `START_SHARING`
    action is sent with `reset` set to `false`:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户选择共享他们的现有命令，则`START_SHARING`动作将带有`reset`设置为`false`发送：
- en: '[PRE18]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When the user clicks on `RESET` action should be sent to the Redux store.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击`RESET`动作应该发送到Redux存储。
- en: Sharing should not be initiated until *after* the `RESET` action has occurred.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`RESET`动作发生之后，才应该开始共享。
- en: That’s all the up-front design we need. Let’s move on to integrating the `Dialog`
    component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们所需要的所有初步设计。让我们继续集成`Dialog`组件。
- en: Adding a dialog box
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加对话框
- en: 'Now that we know what we’re building, let’s go for it! To do so, perform these
    steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道我们要构建什么，那就让我们开始吧！为此，执行以下步骤：
- en: 'Open `test/MenuButtons.test.js` and skip the test that is titled `dispatches
    an action of START_SHARING when start sharing is clicked`. We’re going to sever
    this connection for the moment. But we’ll come back to fix this later:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`test/MenuButtons.test.js`并跳过标题为`当点击开始共享时触发START_SHARING动作`的测试。我们暂时将这个连接断开。但我们会回来修复它：
- en: '[PRE19]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the same file, add a new `import` statement for the `Dialog` component,
    and mock it out using `jest.mock`. The `Dialog` component already exists in the
    code base but has remained unused until now:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加一个新的`import`语句用于`Dialog`组件，并使用`jest.mock`进行模拟。`Dialog`组件已经在代码库中存在，但直到现在还没有被使用：
- en: '[PRE20]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add this new test just below the one you’ve skipped. Very simply, it checks
    that we display the dialog when the appropriate button is clicked:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你跳过的测试下面添加这个新测试。非常简单，它检查在点击适当的按钮时显示对话框：
- en: '[PRE21]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In `src/MenuButtons.js`, add a new `Dialog` element to the JSX, including the
    `import` statement at the top of the file. The new component should be placed
    at the very bottom of the returned JSX. The test should then pass:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/MenuButtons.js`中，向JSX添加一个新的`Dialog`元素，包括文件顶部的`import`语句。新组件应放置在返回的JSX的底部。然后测试应该通过：
- en: '[PRE22]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, let’s set the `message` prop to something useful for the user. Add this
    to your test suite:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们设置`message`属性以对用户更有用。将此添加到你的测试套件中：
- en: '[PRE23]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To make that pass, add the `message` prop to your implementation:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，向你的实现添加`message`属性：
- en: '[PRE24]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we need to make sure the dialog isn’t shown until the sharing button is
    clicked; add the following test:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要确保在点击分享按钮之前不显示对话框；添加以下测试：
- en: '[PRE25]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Make this pass by adding a new state variable, `isSharingDialogOpen`. The sharing
    button will set this to `true` when it’s clicked. You’ll need to add the `import`
    statement for `useState` at the top of the file:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一个新的状态变量`isSharingDialogOpen`来使这个测试通过。分享按钮在点击时将此设置为`true`。你需要在文件顶部添加`useState`的`import`语句：
- en: '[PRE26]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let’s add a test for adding buttons to the dialog. This is done by specifying
    the `buttons` prop on the `Dialog` component:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个测试来添加按钮到对话框。这是通过在`Dialog`组件上指定`buttons`属性来完成的：
- en: '[PRE27]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Make this pass by adding a `buttons` prop to the `Dialog` component, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向`Dialog`组件添加`buttons`属性来使这个测试通过，如下所示：
- en: '[PRE28]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For the next test, we’ll test that the dialog closes. Start by defining a new
    `closeDialog` helper in your test suite:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个测试，我们将测试对话框是否关闭。首先在你的测试套件中定义一个新的`closeDialog`辅助函数：
- en: '[PRE29]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the next test, which checks that the `Dialog` component disappears once
    the dialog has had its `onClose` prop invoked:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加下一个测试，检查一旦对话框调用了`onClose`属性，`Dialog`组件就会消失：
- en: '[PRE30]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Make that pass by adding the following line to the `Dialog` JSX:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`Dialog` JSX中添加以下行来使这个测试通过：
- en: '[PRE31]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now go back to the test that you skipped and modify it so that it reads the
    same as the following code block. We’re going to modify the `START_SHARING` Redux
    action to take a new `reset` Boolean variable:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在回到你跳过的测试，并修改它，使其与以下代码块相同。我们将修改`START_SHARING` Redux动作以接受一个新的`reset`布尔变量：
- en: '[PRE32]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To make this pass, move to `src/MenuButtons.js` and modify the `startSharing`
    function to add a `reset` property to the created Redux action. Notice how we
    hardcode the value to `true` for now—we’ll need to **triangulate** in the upcoming
    test:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，转到`src/MenuButtons.js`并修改`startSharing`函数，为创建的Redux动作添加一个`reset`属性。注意我们目前将值硬编码为`true`——我们将在即将到来的测试中进行三角测量：
- en: '[PRE33]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Triangulation within tests
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中的三角测量
- en: See [*Chapter 1*](B18423_01.xhtml#_idTextAnchor017)*, First Steps with Test-Driven
    Development*, for a reminder on triangulation and why we do it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[*第一章*](B18423_01.xhtml#_idTextAnchor017)*，使用测试驱动开发的第一步*，以了解三角测量的提醒以及为什么我们要这样做。
- en: 'In the `MenuButtons` component, set the `onChoose` prop on the `Dialog` component:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MenuButtons`组件中，设置`Dialog`组件的`onChoose`属性：
- en: '[PRE34]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we need to add a new test for sending a value of `false` through for
    the `reset` action property:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个新的测试，用于发送`false`值给`reset`动作属性：
- en: '[PRE35]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To make that pass, modify `startSharing` to take a `button` parameter and then
    use that to set the `reset` property:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，修改`startSharing`以接受一个`button`参数，然后使用它来设置`reset`属性：
- en: '[PRE36]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, finally, in the `MenuButtons` component JSX, set the `onChoose` prop
    on the `Dialog` element:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，最后，在`MenuButtons`组件JSX中，设置`Dialog`元素的`onChoose`属性：
- en: '[PRE37]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You’ve now completed the first new piece of functionality specified in the Cucumber
    test. There’s a dialog box being displayed and a `reset` Boolean flag being sent
    through to the Redux store. We are inching toward a working solution.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经完成了Cucumber测试中指定的第一个新功能。有一个对话框正在显示，并且一个`reset`布尔标志正在通过Redux存储发送。我们正在逐步接近一个可工作的解决方案。
- en: Updating sagas to a reset or replay state
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新sagas到重置或回放状态
- en: 'Now, we need to update the sharing saga to handle the new reset flag:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新分享saga以处理新的重置标志：
- en: 'Open `test/middleware/sharingSagas.test.js` and add the following test to the
    end of the `START_SHARING` nested `describe` block:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`test/middleware/sharingSagas.test.js`，并在`START_SHARING`嵌套`describe`块的末尾添加以下测试：
- en: '[PRE38]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In `src/middleware/sharingSagas.js`, modify `startSharing` so that it reads
    the same as the following code block. Don’t forget to add the new `action` parameter
    to the top line:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/middleware/sharingSagas.js`中修改`startSharing`，使其与以下代码块相同。别忘了将新的`action`参数添加到第一行：
- en: '[PRE39]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now for the tricky second test. If `reset` is `false`, we want to replay all
    the current actions:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是棘手的第二个测试。如果`reset`是`false`，我们希望重新播放所有当前的动作：
- en: '[PRE40]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To make this pass, we can use the `toInstructions` function from the `export`
    namespace. We also need to make use of two new `redux-saga` functions: `select`
    and `all`. The `select` function is used to retrieve the state and the `all` function
    is used with `yield` to ensure that we wait for all the passed calls to complete
    before continuing. Add those `import` statements now to `src/middleware/sharingSagas.js`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这通过，我们可以使用`export`命名空间中的`toInstructions`函数。我们还需要使用两个新的`redux-saga`函数：`select`和`all`。`select`函数用于检索状态，而`all`函数与`yield`一起使用，以确保在继续之前等待所有传递的调用完成。现在将那些`import`语句添加到`src/middleware/sharingSagas.js`中：
- en: '[PRE41]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, modify the `startSharing` function by tacking on an `else` block to the
    conditional:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过在条件语句后面添加一个`else`块来修改`startSharing`函数。
- en: '[PRE42]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you run the tests now, you’ll notice that there are a couple of unrelated
    failures. We can fix these by adding a default value for the `reset` property
    to the `startSharing` helper method in our tests:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行测试，你会注意到有几个无关的失败。我们可以通过在我们的测试中的`startSharing`辅助方法中为`reset`属性添加一个默认值来修复这些问题：
- en: '[PRE43]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That completes the feature; both the unit tests and the Cucumber tests should
    be passing. Now would be a great time to try things out manually, too.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了功能；单元测试和Cucumber测试都应该通过。现在手动尝试一下也是个不错的选择。
- en: In the next section, we’ll focus on reworking our Cucumber tests to make them
    run much faster.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将专注于重构我们的Cucumber测试，使它们运行得更快。
- en: Avoiding timeouts in test code
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免测试代码中的超时
- en: In this section, we’ll improve the speed at which our Cucumber tests run by
    replacing `waitForTimeout` calls with `waitForSelector` calls.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过用`waitForSelector`调用替换`waitForTimeout`调用，来提高我们的Cucumber测试运行的速度。
- en: 'Many of our step definitions contain waits that pause our test script interaction
    with the browser while we wait for the animations to finish. Here’s an example
    from our tests, which waits for a period of 3 seconds:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大多数步骤定义都包含等待，在等待动画完成的同时暂停我们的测试脚本与浏览器的交互。以下是我们测试中的一个示例，它等待了3秒钟：
- en: '[PRE44]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Not only will this timeout slow down the test suite, but this kind of wait is
    also brittle as there are likely to be occasions when the timeout is slightly
    too short and the animation hasn’t finished. In this case, the test will intermittently
    fail. Conversely, the wait period is actually quite long. As more tests are added,
    the timeouts add up and the test runs suddenly take forever to run.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这个超时会减慢测试套件，这种等待方式也很脆弱，因为可能存在超时稍微太短而动画尚未完成的情况。在这种情况下，测试将间歇性失败。相反，等待期实际上相当长。随着更多测试的添加，超时累积，测试运行突然变得非常慢。
- en: Avoiding timeouts
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 避免超时
- en: Regardless of the type of automated test, it is a good idea to avoid timeouts
    in your test code. Timeouts will substantially increase the time it takes to run
    your test suite. There are almost always methods you can use to avoid using them,
    such as the one highlighted in this section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 无论自动化测试的类型如何，避免在测试代码中使用超时都是一个好主意。超时将显著增加运行测试套件所需的时间。几乎总是有方法可以避免使用它们，就像本节中突出显示的那样。
- en: What we can do instead is modify our production code to notify us when it is
    animating, by setting an `isAnimating` class when the element is animating. We
    then use the Puppeteer `waitForSelector` function to check for a change in the
    value of this class, replacing `waitForTimeout` entirely.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的替代方案是修改我们的生产代码，在元素动画时通知我们，通过设置一个`isAnimating`类。然后我们使用Puppeteer的`waitForSelector`函数来检查这个类值的改变，完全替换`waitForTimeout`。
- en: Adding HTML classes to mark animation status
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加HTML类以标记动画状态
- en: We do this by adding an `isAnimating` class to the viewport `div` element when
    an animation is running.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是通过在动画运行时给viewport的`div`元素添加一个`isAnimating`类。
- en: 'Let’s start by adding the `isAnimating` class when the `Drawing` element is
    ready to animate a new Logo command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`Drawing`元素准备好动画一个新Logo命令时添加`isAnimating`类开始：
- en: 'In `test/Drawing.test.js`, add a new nested `describe` block within the main
    `Display` context, just below the context for resetting. Then, add the following
    test:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/Drawing.test.js`中，在主`Display`上下文中的重置上下文下方添加一个新的嵌套`describe`块。然后，添加以下测试：
- en: '[PRE45]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In `src/Drawing.js`, update the JSX to include this class name on the `viewport`
    element:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/Drawing.js`中，更新JSX以在`viewport`元素上包含这个类名：
- en: '[PRE46]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let’s triangulate in order to get this state variable in place. To do this,
    add the following test:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进行三角测量，以便将这个状态变量放在合适的位置。为此，添加以下测试：
- en: '[PRE47]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To make this pass, update `className` to only set `isAnimating` if `commandToAnimate`
    is not null:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，将`className`更新为仅在`commandToAnimate`不为null时设置`isAnimating`：
- en: '[PRE48]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As a final flourish, we’ll add an arguably unnecessary test. We want to be
    careful about removing the `isAnimating` class once the animation is finished.
    However, our implementation already takes care of this as `commandToAnimate` will
    be set to `undefined` when that happens. In other words, we don’t need an explicit
    test for this, and we’re done with this addition. However, for completeness’ sake,
    you can add the test:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的点缀，我们将添加一个可能不必要的测试。我们想要在动画完成后小心地移除`isAnimating`类。然而，我们的实现已经处理了这个问题，因为当发生这种情况时，`commandToAnimate`将被设置为`undefined`。换句话说，我们不需要为此进行显式的测试，这个添加就完成了。然而，为了完整性，你可以添加这个测试：
- en: '[PRE49]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That completes adding the `isAnimating` class functionality. Now we can use
    this class as a means of replacing the `waitForTimeout` calls.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了添加`isAnimating`类功能。现在我们可以使用这个类作为替换`waitForTimeout`调用的手段。
- en: Updating step definitions to use waitForSelector
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新步骤定义以使用waitForSelector
- en: 'We’re ready to use this new behavior in our step definitions, bringing in a
    new call to `waitForSelector` that waits until the `isAnimating` class appears
    (or disappears) on an element:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好在我们的步骤定义中使用这种新行为，引入一个新的`waitForSelector`调用，等待元素上的`isAnimating`类出现（或消失）：
- en: 'In `features/support/world.js`, add the following two methods to the `World`
    class. The first waits for the `isAnimating` selector to appear within the DOM
    and the second waits for it to disappear:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`features/support/world.js`中，向`World`类添加以下两个方法。第一个方法等待`isAnimating`选择器在DOM中出现，第二个方法等待它消失：
- en: '[PRE50]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In `features/support/drawing.steps.js`, search for the single `waitForTimeout`
    invocation in this file and replace it with the code in the following block:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`features/support/drawing.steps.js`中，搜索这个文件中的单个`waitForTimeout`调用，并将其替换为以下代码块：
- en: '[PRE51]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Being careful about class transitions
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类转换
- en: We’re waiting for animation after *each* instruction is entered. This is important
    as it mirrors how the `isAnimating` class will be added and removed from the application.
    If we only had one `waitForAnimationToEnd` function as the last instruction on
    the page, we may end up exiting the step definition early if the wait catches
    the removal of an `isAnimating` class in the *middle* of a sequence of instructions,
    rather than catching the *last* one.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个指令输入后等待动画。这很重要，因为它反映了`isAnimating`类将在应用程序中添加和删除的方式。如果我们只有一个`waitForAnimationToEnd`函数作为页面上的最后一个指令，那么如果在一系列指令的*中间*捕获到`isAnimating`类的移除，而不是捕获*最后一个*，我们可能会提前退出步骤定义。
- en: 'Now, open `features/support/sharing.steps.js`; this file has a similar step
    in it as the previous one, so update that one now, in the same way:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`features/support/sharing.steps.js`；这个文件中有一个与上一个类似的步骤，所以现在以相同的方式更新它：
- en: '[PRE52]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Toward the bottom of the file, update the two step definitions that check the
    turtle position:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件底部，更新检查海龟位置的两个步骤定义：
- en: '[PRE53]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Open `features/support/svg.js` and update the function within it, as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`features/support/svg.js`并更新其中的函数，如下所示：
- en: '[PRE54]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you run `npx cucumber-js` now, you’ll see that we have one test failure,
    which is related to the output on the observer’s screen. It indicates that we
    need to wait for the animations when we load the observer’s page. In this case,
    we need to wait for the animation to start before we can wait for it to finish.
    We can fix this by adding a new step to the feature. Open `features/sharing.feature`
    and modify the last test to include a *third* entry in the **When** section:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行`npx cucumber-js`，你会看到我们有一个测试失败，这与观察者的屏幕输出有关。它表明我们需要在加载观察者页面时等待动画。在这种情况下，我们需要在等待动画开始之前等待动画结束。我们可以通过向功能添加一个新的步骤来修复这个问题。打开`features/sharing.feature`并修改最后一个测试，在**When**部分包含一个*第三个*条目：
- en: '[PRE55]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Encapsulating multiple When clauses
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 封装多个When子句
- en: If you aren’t happy with having three **When** clauses, then you can always
    combine them into a single step.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对有三个**When**子句不满意，那么您总是可以将它们合并为一个单独的步骤。
- en: 'Back in `features/support/sharing.steps.js`, add this new step definition just
    underneath the other **When** step definitions:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`features/support/sharing.steps.js`中，在其他的**When**步骤定义之下添加这个新的步骤定义：
- en: '[PRE56]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Your tests should now be passing, and they should be much faster. On my machine,
    they now only take a quarter of the time than they did before.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您的测试现在应该通过了，并且它们应该运行得更快。在我的机器上，它们现在只需要之前四分之一的时间。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how you can integrate Cucumber into your team’s
    workflow.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何将Cucumber集成到您团队的日常工作流程中。
- en: You saw some more ways that Cucumber tests differ from unit tests. You also
    learned how to avoid using timeouts to keep your test suites speedy.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到了一些Cucumber测试与单元测试不同的方式。您还学习了如何避免使用超时来保持测试套件快速运行。
- en: We’re now finished with our exploration of the **Spec Logo** world.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了对**Spec Logo**世界的探索。
- en: In the final chapter of the book, we’ll look at how TDD compares to other developer
    processes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章，我们将探讨TDD与其他开发者流程的比较。
- en: Exercise
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Remove as much duplication as possible from your step definitions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地从您的步骤定义中移除重复内容。
