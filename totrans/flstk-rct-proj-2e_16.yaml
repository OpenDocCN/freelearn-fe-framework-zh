- en: Customizing the Media Player and Improving SEO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users visit a media-streaming application mainly to play media and explore other
    related media. This makes the media player—and the view that renders the related
    media details—crucial to a streaming application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on developing the play media page for the MERN Mediastream
    application that we started building in the previous chapter, [Chapter 11](d3f14062-4c41-497c-9627-dc22075fb8fb.xhtml),
    *Building a Media Streaming Application*. We will address the following topics
    to bolster the media-playing functionalities and to help boost the presence of
    the media content across the web so that it reaches more users:'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing player controls on `ReactPlayer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing the next video from a list of related videos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoplaying a list of related media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-side rendering** (**SSR**) of the `PlayMedia` view with data to improve
    **search engine optimization** (**SEO**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing these topics, you will be more adept at designing complex interactions
    between React components in a frontend user interface, and also at improving SEO
    across your full-stack React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom media player to MERN Mediastream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MERN Mediastream application developed in the previous chapter implemented
    a simple media player with default browser controls that played one video at a
    time. In this chapter, we will update the view that plays media with a customized
    `ReactPlayer` and a related media list that can be set to play automatically when
    the current video ends. The updated view with the custom player and related playlist
    will resemble the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/630604d3-93f9-4f02-baaa-248ca5940adf.png)'
  prefs: []
  type: TYPE_IMG
- en: The code for the complete MERN Mediastream application is available on GitHub
    at [https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream). You
    can clone this code and run the application as you go through the code explanations
    for the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following component tree diagram shows all the custom components that make
    up the MERN Mediastream frontend, including the components that will be improved
    or added in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73c7dd59-4cba-4d9c-96da-8e44f3063c1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Modified components and new components added in this chapter include the `PlayMedia`
    component, which houses all the media player functionalities; the `MediaPlayer`
    component, which adds a `ReactPlayer` with custom controls; and a `RelatedMedia`
    component, which contains a list of related videos. In the following section,
    we will discuss the play media page structure, and how it will accommodate all
    the media viewing and interaction features to be extended in the MERN Mediastream
    application throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The play media page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When visitors want to view specific media on MERN Mediastream, they will be
    taken to the play media page, which will contain the media details, a media player
    to stream the video, and a list of related media that can be played next. We will
    implement this `PlayMedia` view in a React component named `PlayMedia`. In the
    following section, we discuss how this component will be structured to enable
    these functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The component structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will compose the component structure in the play media page in a way that
    allows the media data to trickle down to the inner components from the parent
    component. In this case, the `PlayMedia` component will be the parent component,
    containing the `RelatedMedia` component and also the `Media` component, which
    will have a nested `MediaPlayer` component, as sectioned and highlighted in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fffc2bf-bea3-481b-bbb3-5310a6ba7106.png)'
  prefs: []
  type: TYPE_IMG
- en: When individual media links are accessed in the frontend of the application,
    the `PlayMedia` component will retrieve and load the corresponding media data
    and list of related media from the server. Then, the relevant details will be passed as
    props to the `Media` and `RelatedMedia` child components.
  prefs: []
  type: TYPE_NORMAL
- en: The `RelatedMedia` component will list and link other related media, and clicking
    any media in this list will re-render the `PlayMedia` component and its inner
    components with the new data.
  prefs: []
  type: TYPE_NORMAL
- en: We will update the `Media` component we developed in Chapter 11, *Building a
    Media-Streaming Application*, to add a customized media player as a child component.
    This customized `MediaPlayer` component will also utilize the data passed from
    `PlayMedia` to stream the current video and link to the next video in the related
    media list.
  prefs: []
  type: TYPE_NORMAL
- en: In the `PlayMedia` component, we will add an autoplay toggle that will let users
    choose to autoplay the videos in the related media list, one after the other.
    The autoplay state will be managed from the `PlayMedia` component, but this feature
    will require the data available in the parent component's state to re-render when
    a video ends in the `MediaPlayer` nested child component, so it can be ensured
    that the next video starts playing automatically while keeping track of the related
    list.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, the `PlayMedia` component will need to provide a state updating
    method as a prop that will be used in the `MediaPlayer` component to update the
    shared and interdependent state values across these components.
  prefs: []
  type: TYPE_NORMAL
- en: Taking this component structure into consideration, we will extend and update
    the MERN Mediastream application to implement a functional play media page. In
    the next section, we will start by adding the feature that provides a list of
    related media to the user in this `PlayMedia` view.
  prefs: []
  type: TYPE_NORMAL
- en: Listing related media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user is viewing an individual media on the application, they will also
    see a list of related media on the same page. The related media list will consist
    of other media records that belong to the same genre as the given video and is
    sorted by the highest number of views. For this feature, we will need to integrate
    a full-stack slice that retrieves the relevant list from the Media collection
    in the backend and renders it in the frontend. In the following sections, we will
    add a related media list API in the backend, along with a way to fetch this API
    in the frontend, and a React component that renders the list of media retrieved
    by this API.
  prefs: []
  type: TYPE_NORMAL
- en: The related media list API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement an API endpoint in the backend to retrieve the list of related
    media from the database. The API will receive a `GET` request at `''/api/media/related/:mediaId''`,
    and the route will be declared with the other media routes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `:mediaId` parameter in the route path will be processed by the `mediaByID`
    method implemented in *The video API* section of [Chapter 11](d3f14062-4c41-497c-9627-dc22075fb8fb.xhtml), *Building
    a Media Streaming Application*. It retrieves the media corresponding to this ID
    from the database and attaches it to the `request` object, so it can be accessed
    in the next method. The `listRelated` controller method is the next method invoked
    for the `GET` request at this API route. This method will query the Media collection
    to find records with the same genre as the media provided, and also exclude this
    given media record from the results returned. The `listRelated` controller method
    is defined as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The results returned from the query will be sorted by the highest number of
    views and limited to the top four media records. Each `media` object in the returned
    results will also contain the name and ID of the user who posted the media, as
    specified in the `populate` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, we will set up a corresponding `fetch` method that will
    be used in the `PlayMedia` component to retrieve the related list of media using
    this API. This method will be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/api-media.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This `listRelated` fetch method will take a media ID and make a `GET` request
    to the related media list API in the backend. We will use this method in the `PlayMedia`
    component to retrieve a list of media related to the current media loaded in the
    media player. Then this list will be rendered in the `RelatedMedia` component.
    In the next section, we will look at the implementation of this `RelatedMedia`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The RelatedMedia component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the play media page, beside the media loaded in the player, we will load
    a list of related media in the `RelatedMedia` component. The `RelatedMedia` component
    will take the list of related media as a prop from the `PlayMedia` component and
    render the details along with a video snapshot of each video in the list, as pictured
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0422916-b6e8-43d1-bcec-3d100fed2f54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the implementation of the `RelatedMedia` view, we iterate through the media
    array received in the props using the `map` function and render each media item''s
    details and video snapshot, as shown in the following code structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/RelatedMedia.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this structure, to render the video snapshot for each media item, we will
    use a basic `ReactPlayer` without the controls, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/RelatedMedia.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We wrap the `ReactPlayer` with a link to the individual view of this media.
    So, clicking on the given video snapshot will re-render the `PlayMedia` view to
    load the linked media''s details. Beside the snapshot, we will display the details
    of each video including title, genre, created date, and the number of views, with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/RelatedMedia.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will render the details next to the video snapshot for each media in the
    related media list that is received in the props.
  prefs: []
  type: TYPE_NORMAL
- en: To render this `RelatedMedia` component in the play media page, we have to add
    it to the `PlayMedia` component. The `PlayMedia` component will use the related
    media list API implemented earlier in this section to retrieve the related media
    from the backend, and then pass it in the props to the `RelatedMedia` component.
    In the next section, we will discuss the implementation of this `PlayMedia` component.
  prefs: []
  type: TYPE_NORMAL
- en: The PlayMedia component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `PlayMedia` component will render the play media page. This component consists
    of the `Media` and `RelatedMedia` child components along with an autoplay toggle,
    and it provides data to these components when it loads in the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render the `PlayMedia` component when individual media links are accessed
    by the user, we will add a `Route` in `MainRouter` and mount `PlayMedia` at `''/media/:mediaId''`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/MainRouter.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When the `PlayMedia` component mounts, it will fetch the media data and the
    related media list from the server with `useEffect` hooks based on the `mediaId` parameter
    in the route link.
  prefs: []
  type: TYPE_NORMAL
- en: 'In one `useEffect` hook, it will fetch the media to be loaded in the media
    player, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The media ID from the route path is accessed in the `props.match` received from
    the React Router components. It is used in the call to the `read` API fetch method
    to retrieve the media details from the server. The received `media` object is
    set in the state so that it can be rendered in the `Media` component.
  prefs: []
  type: TYPE_NORMAL
- en: In another `useEffect` hook, we use the same media ID to call the `listRelated`
    API fetch method, as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `listRelated` API fetch method retrieves the related media list from the
    server and sets the values to the state so that it can be rendered in the `RelatedMedia`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The media and related media list values stored in the state are used to pass
    relevant props to these child components that are added in the view. For example,
    in the following code, the `RelatedMedia` component is only rendered if the list
    of related media contains any media, and the list is passed to it as a prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Later in the chapter, in the *Autoplaying related media* section, we will add
    the `Autoplay` toggle component above the `RelatedMedia` component only if the
    length of the related media list is greater than `0`. We will also discuss the implementation
    of the `handleAutoPlay` method that will be passed as a prop to the `Media` component.
    It will also receive the `media` detail object, and the video URL for the first
    item in the related media list, which will be treated as the next URL to play.
    The `Media` component is added to `PlayMedia`, along with these props, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This `Media` component renders the media details on the play media page, and
    also a customized media player that allows viewers to control the streaming of
    the video. In the next section, we will discuss the implementation of this customized
    media player and complete this core feature of the play media page.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the media player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In MERN Mediastream, we want to provide users with a media player with more
    controls than those available in the default browser options, and with a look
    that matches the rest of the application. We will customize the player controls
    on `ReactPlayer` to replace these default controls with a custom look and functionality,
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c92cc00-464d-4493-9dc3-2a059ef9bdfa.png)'
  prefs: []
  type: TYPE_IMG
- en: The controls will be added below the video and will include the progress seeking
    bar; the play, pause, next, volume, loop, and fullscreen options; and will also
    display full duration of the video and the amount that's been played. In the following
    sections, we will first update the `Media` component discussed in the previous
    chapter, [Chapter 11](d3f14062-4c41-497c-9627-dc22075fb8fb.xhtml), *Building a
    Media Streaming Application*, to accommodate the new player features. Then, we
    will initialize a `MediaPlayer` component that will contain the new player, before
    implementing functionality for the custom media controls in this player.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Media component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The existing `Media` component contains a basic `ReactPlayer` with default
    browser controls for playing a given video. We will replace this `ReactPlayer`
    with a new `MediaPlayer` component that we will begin implementing in the next
    section. The `MediaPlayer` component will contain a customized `ReactPlayer`,
    and it will be added to the `Media` component code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While adding this `MediaPlayer` component to the `Media` component, it will
    be passed the current video's source URL, the next video's source URL, and the `handleAutoPlay` method,
    which are received as `props` in the `Media` component from the `PlayMedia` component.
    These URL values and the autoplay handling method will be used in the `MediaPlayer`
    component to add various video-playing options. In the next section, we will begin
    implementing this `MediaPlayer` component by initializing the different values
    needed for adding functional controls to the custom media player.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the media player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will implement the customized media player in the `MediaPlayer` component.
    This player will render the video streamed from the backend and provide the user
    with different control options. We will incorporate this media-playing functionality
    and the custom control options in the `MediaPlayer` using a `ReactPlayer` component.
    The `ReactPlayer` component, as discussed in the previous chapter, provides a
    range of customizations that we will leverage for the media player features to
    be added in this application.
  prefs: []
  type: TYPE_NORMAL
- en: While defining the `MediaPlayer` component, we will begin by initializing the `ReactPlayer`
    component with starting values for the controls, before we add the custom functionalities
    and corresponding user-action handling code for each control.
  prefs: []
  type: TYPE_NORMAL
- en: The control values we customize will correspond to the props allowed in the
    `ReactPlayer` component. To see a list of available props and an explanation of
    each, visit [github.com/CookPete/react-player#props](https://github.com/CookPete/react-player#props).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to set the initial control values in the component''s state.
    We will start with control values that correspond to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The playing state of the media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The volume of the audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The muted state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The duration of the video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The seeking state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The playback rate of the video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fullscreen value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Video errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The played, loaded, and ended states of the video getting streamed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code to initialize these values in the component will be added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These values set in the state will allow us to customize the functionalities
    of the corresponding controls in the `ReactPlayer` component, which we discuss
    in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MediaPlayer` component''s view code, we will add this  `ReactPlayer`
    with these control values and source URL, using the prop sent from the `Media`
    component, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides setting the control values, we will also add styling to the player,
    depending on whether it is in fullscreen mode. We also need to get a reference
    to this player element rendered in the browser so that it can be used in the change-handling
    code for the custom controls. We will use the `useRef` React hook to initialize
    the reference to `null` and then set it to the corresponding player element using
    the `ref` method, as defined in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The value in `playerRef` will give access to the player element rendered in
    the browser. We will use this reference to manipulate the player as required,
    to make the custom controls functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final step for initializing the media player, we will add code for handling
    errors thrown by the player if the specified video source cannot be loaded for
    any reason. We will define a `showVideoError` method that will be invoked when
    a video error occurs. The `showVideoError` method will be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will render an error message in the view above the media player.
    We can show this error message conditionally by adding the following code in the
    view above the `ReactPlayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render the video error message when an error occurs. As we will allow
    users to play another video in the player from the related media list, we will
    reset the error message if a new video is loaded. We can hide the error message when
    a new video loads with a `useEffect` hook, by ensuring the `useEffect` only runs
    when the video source URL changes, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure the error message isn't shown when a new video is loaded and
    streaming correctly.
  prefs: []
  type: TYPE_NORMAL
- en: With these initial control values set and the `ReactPlayer` added to the component, in
    the next section, we can begin customizing how these controls will appear and
    function in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Custom media controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add custom player control elements below the video rendered in the `MediaPlayer`
    component and manipulate their functionality using the options and events provided
    by the `ReactPlayer` library. In the following sections, we will implement the
    play, pause, and replay controls; the play next control; the loop functionality;
    volume control options; progress control options; fullscreen option, and also
    display full duration of the video and the amount that's been played.
  prefs: []
  type: TYPE_NORMAL
- en: Play, pause, and replay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Users will be able to play, pause, and replay the current video. We will implement
    these three options using `Material-UI` components bound to `ReactPlayer` attributes
    and events. The play, pause, and replay options will render as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5af8e3ab-a683-446a-835a-cb00744750c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To implement the play, pause, and replay functionality, we will add a play,
    pause, or replay icon button conditionally depending on whether the video is playing,
    is paused, or has ended, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The play, pause, or replay icons are rendered in this `IconButton` based on
    the outcome of the ternary operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks the button, we will update the `playing` value in the
    state, so the `ReactPlayer` is also updated. We achieve this by invoking the `playPause`
    method when this button is clicked. The `playPause` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The updated value of `playing` in the state will play or pause the video in
    the `ReactPlayer` component accordingly. In the next section, we will see how
    we can add a control option that will allow us to play the next video from the
    list of related media.
  prefs: []
  type: TYPE_NORMAL
- en: Play next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Users will be able to play the next video in the related media list using a
    play next button, which will render depending on whether the next video is available
    or not. The two versions of this play next button will display as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cc4eac6-e97b-4698-abff-0219052c85f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The play next button will be disabled if the related list does not contain
    any media. The play next icon will basically link to the next URL value passed
    in as a prop from `PlayMedia`. This play next button will be added to the `MediaPlayer`
    view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Clicking on this play next button will reload the `PlayMedia` component with
    the new media details and start playing the video. In the next section, we will
    add a control option that will allow the current video to be played in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Loop when a video ends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Users will be able to set the current video to keep playing in a loop, using
    a loop button. The loop button will render in two states, set and unset, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/403de211-6868-4820-ad12-9a04ba0594b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This loop icon button will display in a different color to indicate whether
    it has been set or unset by the user. The code for rendering this loop button
    will be added to the `MediaPlayer`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The loop icon color will change based on the value of `loop` in the state.
    When this loop icon button is clicked, we will update the `loop` value in the
    state by invoking the `onLoop` method, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The video will play on loop when this `loop` value is set to `true`. We will
    need to catch the `onEnded` event, to check whether `loop` has been set to `true`,
    so the `playing` value can be updated accordingly. When a video reaches the end,
    the `onEnded` method will be invoked. This `onEnded` method will be defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, if the `loop` value is set to `true`, when the video ends it will start
    playing again; otherwise, it will stop playing and render the replay button. In
    the next section, we will add controls for setting the volume of the video.
  prefs: []
  type: TYPE_NORMAL
- en: Volume control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to control the volume of the video being played, users will have the
    option to increase or decrease the volume, as well as to mute or unmute. The rendered
    volume controls will be updated based on the user action and current value of
    the volume. The different states of the volume controls will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A volume-up icon will be rendered if the volume is raised, as shown in the
    following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/22206b2a-35d7-497c-aa01-48aca0e8d71f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A volume-off icon will be rendered if the user decreases the volume to zero,
    as pictured next:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8495d831-b880-40d1-b4fb-27618760c109.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A volume-mute icon button will be shown if the user clicks the icon to mute
    the volume, as shown next:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/faff96a6-8595-43c1-aa3b-22a71517126a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To implement this, we will conditionally render the different icons in an `IconButton`,
    based on the `volume`, `muted`, `volume_up`, and `volume_off` values, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When this `IconButton` is clicked, it will either mute or unmute the volume
    by invoking the `toggleMuted` method, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The volume will be muted or unmuted, depending on the current value of `muted`
    in the state. To allow users to increase or decrease the volume, we will add an
    input element of type `range` that will allow users to set a volume value between
    `0` and `1`. This input element will be added to the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the `value` on the input range will set the `volume` value in the
    state accordingly by invoking the `changeVolume` method. This `changeVolume` method
    will be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `volume` value changed in the state will be applied to the `ReactPlayer`,
    and this will set the volume of the current media being played. In the next section,
    we will add options to control the progression of the video being played.
  prefs: []
  type: TYPE_NORMAL
- en: Progress control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the media player, users will see how much of the video has been loaded and
    played in a progress bar. To implement this feature, we will use a Material-UI
    `LinearProgress` component to indicate how much of the video has buffered, and
    how much has been played already. Then, we'll combine this component with an input element
    of type `range` to give users the ability to move the time slider to a different
    part of the video and play from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time slider and progress bar will render as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d00bcb88-028b-41be-8992-1f5c6f04412f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `LinearProgress` component will use the `played` and `loaded` values in
    the state to render these bars. It will take the `played` and `loaded` values
    to show each in a different color, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The look and color for each progress bar will be determined by the styles you
    define for the `primaryColor`, `dashedColorPrimary`, and `dashed` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the `LinearProgress` component when the video is playing or loading,
    we will use the `onProgress` event listener to set the current values for `played`
    and `loaded`. The `onProgress` method will be defined as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We only want to update the time slider if we are not currently seeking, so we
    first check the `seeking` value in the state before setting the `played` and `loaded`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For time-sliding control, we will add the range input element and define styles,
    as highlighted in the following code, to place it over the `LinearProgress` component.
    The current value of the range will update as the `played` value changes, so the
    range value seems to be moving with the progression of the video. This input element
    representing the time slider will be added to the media player, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the case where the user drags and sets the range picker on their own, we
    will add code to handle the `onMouseDown`, `onMouseUp`, and `onChange` events
    to start the video from the desired position.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user starts dragging by holding the mouse down, we will set `seeking`
    to `true` so that the progress values are not set in `played` and `loaded`. This
    will be achieved with the `onSeekMouseDown` method, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As the range value change occurs, we will invoke the `onSeekChange` method
    to set the `played` value and also the `ended` value, after checking whether the
    user dragged the time slider to the end of the video. This `onSeekChange` method
    will be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user is done dragging and lifts their click on the mouse, we will
    set `seeking` to `false`, and set the `seekTo` value for the media player to the
    current value set in the input range. The `onSeekMouseUp` method will be executed
    when the user is done seeking, and it is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This way, the user will be able to select any part of the video to play from,
    and also get visual information on the time progress of the video being streamed.
    In the next section, we will add a control that will allow the user to view the
    video in fullscreen mode.
  prefs: []
  type: TYPE_NORMAL
- en: Fullscreen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Users will be able to view the video in fullscreen mode by clicking the fullscreen
    button in the controls. The fullscreen button for the player will be rendered
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/872dafe3-3d9a-4cda-9b0f-a188110d13a3.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to implement a fullscreen option for the video, we will use the `screenfull` Node
    module to track when the view is in fullscreen, and `findDOMNode` from `react-dom`
    to specify which **Document Object Model** (**DOM**) element will be made fullscreen
    with `screenfull`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the `fullscreen` code, we first install `screenfull`, by running
    the following command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will import `screenfull` and `findDOMNode` into the `MediaPlayer`
    component, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `MediaPlayer` component mounts, we will use a `useEffect` hook to
    add a `screenfull` change event listener that will update the `fullscreen` value
    in the state to indicate whether the screen is in fullscreen or not. The `useEffect`
    hook will be added as follows, with the `screenfull` change listener code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This `fullscreen` value set in the state will be updated when the user interacts
    with the button for rendering the video in fullscreen mode. In the view, we will
    add an `icon` button for `fullscreen` with the other control buttons, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user clicks this button, we will use `screenfull` and `findDOMNode`
    to make the video player fullscreen by invoking the `onClickFullscreen` method,
    which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We access the element that renders the media player in the browser by using
    the `playerRef` reference in `findDOMNode` and make it fullscreen by using `screenfull.request`.
    The user can then watch the video in fullscreen, where they can press *Esc* at
    any time to exit fullscreen and get back to the `PlayMedia` view. In the next
    section, we will implement the final customization in the media player controls
    to display the total length of the video, and how much of it was already played.
  prefs: []
  type: TYPE_NORMAL
- en: Played duration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the custom media controls section of the media player, we want to show the
    time that has already passed and the total duration of the video in a readable
    time format, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65044ac0-2632-46a7-ab82-0b093bf2227b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To show the time, we can utilize the HTML `time` element, which takes a `datetime`
    value, and add it to the view code in `MediaPlayer`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `dateTime` attribute for these `time` elements, we provide the total
    rounded-off seconds that represent the played duration or the total duration of
    the video. We will get this total `duration` value for a video by using the `onDuration`
    event and then set it to the state, so it can be rendered in the `time` element.
    The `onDuration` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the duration and already played time values readable, we will use the
    following `format` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This `format` function takes the duration value in seconds and converts it to
    the `hh/mm/ss` format, using methods from the JavaScript Date API.
  prefs: []
  type: TYPE_NORMAL
- en: The controls added to this custom media player are all mostly based on some
    of the available functionality provided in the `ReactPlayer` module, and its examples
    in the official documentation. While implementing the custom media player for
    this application, we updated and added the associated playing controls, looping
    option, volume controls, progress seeking control, fullscreen viewing option,
    and a display of the video duration. There are more options available for further
    customizations and extensions in `ReactPlayer` that may be explored depending
    on specific feature requirements. With the different functionalities of the customized
    media player implemented, in the next section, we can start discussing the implementation
    of autoplaying videos in this player from a list of available media.
  prefs: []
  type: TYPE_NORMAL
- en: Autoplaying related media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the play media page, users will have the option to autoplay one video after
    the other from the related media list. To make this feature possible, the `PlayMedia`
    component will manage the autoplay state, which will determine the data and how
    it will be rendered next in the `MediaPlayer` and `RelatedMedia` components after
    the current video finishes streaming in the player. In the following sections,
    we will complete this autoplay functionality by adding a toggle in the `PlayMedia` component
    and implementing the `handleAutoplay` method, which needs to be called when a
    video ends in the `MediaPlayer` component.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling autoplay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the play media page, we will add an autoplay toggle option above the related
    media list. Besides letting the user set autoplay, the toggle will also indicate
    whether it is currently set or not, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a49efbd-9bdd-4004-8eea-1c0df87803ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To add the autoplay toggle option, we will use a Material-UI `Switch` component
    along with a `FormControlLabel`, and add it to the `PlayMedia` component over
    the `RelatedMedia` component. It will only be rendered when there are media in
    the related media list. We will add this `Switch` component representing the autoplay
    toggle as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The autoplay toggle label will render according to the current value of `autoPlay`
    in the state. To handle the change to the toggle when the user interacts with
    it, and to reflect this change in the state''s `autoPlay` value, we will use the
    following `onChange` handler function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This `autoPlay` value, which represents whether the user chose to autoplay all
    the media, will determine what happens when the current video finishes streaming.
    In the next section, we will discuss how the autoplay behavior will be integrated
    with the child components in `PlayMedia`, depending on the toggled value set for
    `autoPlay` by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Handling autoplay across components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user selects to set the Autoplay toggle to ON, the functionality desired
    here is that when a video ends, if `autoPlay` is set to `true` and the current
    related list of media is not empty, `PlayMedia` should load the media details
    of the first video in the related list.
  prefs: []
  type: TYPE_NORMAL
- en: In turn, the `Media` and `MediaPlayer` components should update with the new
    media details, start playing the new video, and render the controls on the player
    appropriately. The list in the `RelatedMedia` component should also update with
    the current media removed from the list, so only the remaining playlist items
    are visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to handle this autoplay behavior across the `PlayMedia` component
    and its child components, `PlayMedia` passes a `handleAutoPlay` method to the
    `Media` component as a prop to be used by the `MediaPlayer` component when a video
    ends. The `handleAutoPlay` method is defined as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This `handleAutoplay` method takes care of the following when a video ends
    in the `MediaPlayer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: It takes a callback function from the `onEnded` event listener in the `MediaPlayer`
    component. This callback will be executed if autoplay is not set or the related
    media list is empty so that the controls on the `MediaPlayer` are rendered to
    show that the video has ended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If autoplay is set and there are more than one related media in the list, then:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first item in the related media list is set as the current `media` object
    in the state so it can be rendered.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The related media list is updated by removing this first item, which will now
    start playing in the view.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If autoplay is set and there is only one item in the related media list, this
    last item is set to `media` so it can start playing, and the `listRelated` fetch
    method is called to repopulate the `RelatedMedia` view with the related media
    for this last item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these steps covered within this `handleAutoplay` method, all the aspects
    of the play media page can be updated accordingly at the end of a video, if autoplay
    is set to `true`. In the next section, we will see how the `MediaPlayer` component
    utilizes this `handleAutoplay` method when the current video ends, in order to
    make the autoplay feature functional.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the state when a video ends in MediaPlayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MediaPlayer` component receives the `handleAutoplay` method as a prop
    from `PlayMedia`. This method will be utilized when the current video finishes
    playing in the player. Hence, we will update the listener code for the `onEnded`
    event to execute this method only when the `loop` is set to `false` for the current
    video. We don''t want to play the next video if the user has decided to loop the
    current video. The `onEnded` method in `MediaPlayer` will be updated with the
    highlighted code shown in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this code, a callback function is passed to the `handleAutoplay` method,
    in order to set the `playing` value to `false` and render the replay icon button
    instead of the play or pause icon button, after it is determined in `PlayMedia`
    that the autoplay has not been set or that the related media list is empty.
  prefs: []
  type: TYPE_NORMAL
- en: The autoplay functionality will continue playing the related videos one after
    the other with this implementation. This implementation demonstrates another way
    to update the state across the components when the values are interdependent.
  prefs: []
  type: TYPE_NORMAL
- en: With this autoplay functionality implemented, we have a complete play media
    page with a customized media player and a related media list that the user can
    choose to autoplay through like a playlist. In the next section, we will make
    this page SEO-friendly by SSR of this view with the media data populated in the
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering with data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SEO is important for any web application that delivers content to its users
    and wants to make the content easy to find. Generally, content on any web page
    will have a better chance of getting more viewers if the content is easily readable
    to search engines. When a search-engine bot accesses a web URL, it will get the
    SSR output. Hence, to make the content discoverable, the content should be part
    of the SSR output.
  prefs: []
  type: TYPE_NORMAL
- en: In MERN Mediastream, we will use the case of making media details popular across
    search engine results, to demonstrate how to inject data into an SSR view in a
    MERN-based application. We will focus on implementing SSR with data injected for
    the `PlayMedia` component that is returned at the `'/media/:mediaId'` path. The
    general implementation steps outlined here can be used to implement SSR with data
    for other views.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will extend the SSR implementation discussed in
    [Chapter 4](6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml), *Adding a React Frontend
    to Complete MERN*. We will first define a static route configuration file and
    use it to update the existing SSR code in the backend to inject the necessary
    media data from the database. Then, we will update the frontend code to render
    this server-injected data in the view, and, finally, check if this SSR implementation
    works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a route configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to load data for the React views when these are rendered on the server,
    we will need to list the frontend routes in a route configuration file. This file
    may then be used with the `react-router-config` module, which provides static
    route configuration helpers for React Router.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first install the module by running the following command from the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will create a route configuration file that will list frontend React
    Router routes. This configuration will be used on the server to match these routes
    with incoming request URLs, to check whether data must be injected before the
    server returns the rendered markup in response to this request.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the route configuration in MERN Mediastream, we will only list the route
    that renders the `PlayMedia` component and demonstrate how to server-render a
    specific component with data injected from the backend. The route configuration
    will be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/routeConfig.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For this frontend route and `PlayMedia` component, we specify the `read` fetch
    method from `api-media.js` as the `loadData` method. This can then be used to
    retrieve and inject the data into the `PlayMedia` view when the server generates
    the markup for this component, after receiving a request at `/media/:mediaId`.
    In the next section, we will use this route configuration to update the existing
    SSR code on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Updating SSR code for the Express server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will update the existing basic SSR code in `server/express.js` to add the
    data-loading functionality for the React views that will get rendered server-side.
    In the following sections, we will first see how to use the route configuration
    to load the data that needs to be injected when the server renders React components.
    Then, we will integrate `isomorphic-fetch` so the server is able to make the `read`
    fetch call to retrieve the necessary data, using the same API fetching code from
    the frontend. Finally, we will inject this retrieved data into the markup generated
    by the server.
  prefs: []
  type: TYPE_NORMAL
- en: Using route configuration to load data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the routes defined in the route configuration file to look for
    a matching route when the server receives any request. If a match is found, we
    will use the corresponding `loadData` method declared for this route in the configuration
    to retrieve the necessary data, before it is injected into the server-rendered
    markup representing the React frontend. We will perform these route-matching and
    data-loading actions in a method called `loadBranchData`, which is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/express.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This method uses `matchRoutes` from `react-router-config`, and the routes defined
    in the route configuration file, to look for a route matching the incoming request
    URL, which is passed as the `location` argument. If a matching route is found,
    then any associated `loadData` method will be executed to return a `Promise` containing
    the fetched data, or `null` if there were no `loadData` methods. The `loadBranchData`
    defined here will need to be called whenever the server receives a request, so
    if any matching route is found, we can fetch the relevant data and inject it into
    the React components while rendering server side. In the next section, we will
    ensure the fetch methods defined in the frontend code also work on the server
    side, so these same methods also load the corresponding data from the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Isomorphic-fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will ensure that any fetch method we defined for the client code can also
    be used on the server by using the `isomorphic-fetch` Node module. We will first
    install the module by running the following command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will simply import `isomorphic-fetch` in `express.js`, as shown in
    the following code, to ensure fetch methods now work isomorphically both on the
    client and the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/express.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This `isomorphic-fetch` integration will make sure that the `read` fetch method,
    or any other fetch method that we defined for the client, can now be used on the
    server as well. Before this integration becomes functional, we need to ensure
    the fetch methods use absolute URLs, as discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Absolute URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One issue with using `isomorphic-fetch` is that it currently requires the fetch
    URLs to be absolute. So, we need to update the URL used in the `read` fetch method,
    defined in `api-media.js`, into an absolute URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of hardcoding a server address in the code, we will set a `config`
    variable in `config.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/config/config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to define and use separate absolute URLs for the API routes
    in development and in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will update the `read` method in `api-media.js` to make sure it uses
    an absolute URL to call the `read` API on the server, as highlighted in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/api-media.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This will make the `read` fetch call compatible with `isomorphic-fetch`, so
    it can be used without a problem on the server side to retrieve the media data
    while server-rendering the `PlayMedia` component with data. In the next section,
    we will discuss how to inject this retrieved data into the server-generated markup
    representing the rendered React frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting data into the React app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the existing SSR code in the backend, we use `ReactDOMServer` to convert
    the React app to markup. We will update this code in `express.js` to inject the
    retrieved data into the `MainRouter`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/express.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We utilize the `loadBranchData` method to retrieve the relevant data for the
    requested view, then pass this data as a prop to the `MainRouter` component. For
    this data to be added correctly in the rendered `PlayMedia` component when the
    server generates the markup, we need to update the client-side code to consider
    this server-injected data, as discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Applying server-injected data to client code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will update the React code in the frontend to add considerations for the
    data that may be injected from the server if the view is being rendered server-side.
    For this MERN Mediastream application, on the client side, we will access the
    media data passed from the server, and add it to the `PlayMedia` view when the
    server receives a direct request to render this component. In the following sections,
    we will see how to pass the data received in the `MainRouter` to the `PlayMedia`
    component, and render it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data props to PlayMedia from MainRouter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While generating markup with `ReactDOMServer.renderToString`, we pass the preloaded
    data to `MainRouter` as a prop. We can access this data prop in the `MainRouter` component
    definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/MainRouter.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To give `PlayMedia` access to this data from the `MainRouter`, we will change
    the `Route` component added originally to declare the route for `PlayMedia`, and
    pass this data as a prop, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/MainRouter.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The data prop sent to `PlayMedia` will need to be rendered in the view, as discussed
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering received data in PlayMedia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `PlayMedia` component, we will check for data passed from the server
    and set the values to the state so the media details are rendered in the view
    when the server is generating the corresponding markup. We will do this checking
    and assignment as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If media data is received in the props from the server, we assign it to the
    `media` value in the state. We also set the `relatedMedia` value to an empty array,
    as we do not intend to render the related media list in the server-generated version.
    This implementation will produce server-generated markup with media data injected
    in the `PlayMedia` view when the corresponding frontend route request is received
    directly on the server. In the next section, we will see how to ensure this implementation
    is actually working and successfully rendering server-generated markup with the
    data populated.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the implementation of SSR with data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For MERN Mediastream, any of the links that render `PlayMedia` should now generate
    markup on the server side with media details preloaded. We can verify that the
    implementation for SSR with data is working properly by opening the app URL in
    a browser, with JavaScript turned off. In the following section, we will look
    into how to achieve this check in the Chrome browser, and what the resulting view
    should show to the user and to a search engine.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Chrome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing this implementation in Chrome just requires updating the Chrome settings
    and loading the application in a tab, with JavaScript blocked. In the following
    sections, we will go over the steps to check whether the `PlayMedia` view renders
    with data when it is just server-generated markup.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a page with JavaScript enabled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, open the MERN Mediastream application in Chrome, then browse to any media
    link and let it render normally with JavaScript enabled. This should show the
    implemented `PlayMedia` view with the functioning media player and the related
    media list. Leave this tab open as we move on to the next step, to disable JavaScript
    in Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling JavaScript from settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test how the server-generated markup is rendered in the view, we need to
    disable JavaScript on Chrome. For this, you can go to the advanced settings at
    `chrome://settings/content/javascript`, and use the toggle to block JavaScript,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f60e09a3-e532-4a03-a84b-b43dcdab701e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, refresh the media link in the MERN Mediastream tab, and there should be
    an icon next to the address URL, as shown in the following screenshot, indicating
    that JavaScript is indeed disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b727426e-3006-417b-b8ae-863f5ed033d1.png)'
  prefs: []
  type: TYPE_IMG
- en: The view that will be displayed in the browser at this point will only render
    the server-generated markup received from the backend. In the next section, we
    will discuss what the expected view is when JavaScript is blocked on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: PlayMedia view with JavaScript blocked
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When JavaScript is blocked in the browser, the `PlayMedia` view should render
    with only the media details populated. But the user interface is no longer interactive
    as JavaScript is blocked, and only the default browser controls are operational,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7726da83-d4db-4ace-a46a-0970824d4ebb.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the markup that a search-engine bot will read for media content, and
    also what a user will see when no JavaScript loads on the browser. If this implementation
    for SSR with data was not added to the application, then this view would render
    without the associated media details in this scenario, and hence the media information
    would not be read and indexed by search engines.
  prefs: []
  type: TYPE_NORMAL
- en: MERN Mediastream now has fully operational media-playing tools that will allow
    users to browse and play videos with ease. In addition, the media views that display
    individual media content items are now search-engine-optimized because of SSR
    with preloaded data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completely upgraded the play media page on MERN Mediastream.
    We first added custom media player controls, utilizing options available in the `ReactPlayer` component.
    Then, we incorporated the autoplay functionality for a related media playlist,
    after retrieving the related media from the database. Finally, we made the media
    details search-engine-readable by injecting data from the server when the view
    is rendered on the server.
  prefs: []
  type: TYPE_NORMAL
- en: You can apply the techniques explored in this chapter to build the play media
    page, to compose and build your own complex user interface with React components
    that are interdependent, and to add SSR with data for views that need to be SEO-friendly
    in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: We have now explored advanced capabilities, such as streaming and SEO, with the
    MERN stack technologies. In the next two chapters, we will test the potential
    of this stack further by incorporating **virtual reality** (**VR**) elements into
    a full-stack web application using React 360.
  prefs: []
  type: TYPE_NORMAL
