- en: Chapter 7. Explaining Pipes and Communicating with RESTful Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 解释管道和与RESTful服务通信
- en: 'In the last chapter, we covered some very powerful features of the framework.
    However, we can go even deeper into the functionality of Angular''s forms module
    and router. In the next sections, we''ll explain how we can:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了框架的一些非常强大的功能。然而，我们可以更深入地了解Angular表单模块和路由的功能。在接下来的几节中，我们将解释我们如何：
- en: Develop model-driven forms.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发模型驱动表单。
- en: Define parameterized routes.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义参数化路由。
- en: Define child routes.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义子路由。
- en: Use the HTTP module for communication with RESTful APIs.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP模块与RESTful API进行通信。
- en: Transform data with custom pipes.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义管道转换数据。
- en: We will explore all these concepts in the process of extending the functionality
    of the "Coders repository" application. At the beginning of the preceding chapter,
    we mentioned that we will allow the import of developers from GitHub. However,
    before we implement this feature, let's extend the functionality of the form.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在扩展“Coders仓库”应用程序功能的过程中探索所有这些概念。在前一章的开始，我们提到我们将允许从GitHub导入开发者。然而，在我们实现此功能之前，让我们扩展表单的功能。
- en: Developing model-driven forms in Angular
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中开发模型驱动表单
- en: These will be the last steps for finishing the "Coders repository". You can
    build on top of the code available at `ch6/ts/step-1/` (or `ch6/ts/step-2`, depending
    on your previous work), in order to extend the application's functionality with
    the new concepts we will cover. The complete example is located at `ch7/ts/multi-page-model-driven`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将是完成“Coders仓库”的最后几步。您可以在`ch6/ts/step-1/`（或根据您之前的工作`ch6/ts/step-2`）提供的代码基础上构建，以扩展应用程序的功能，我们将介绍的新概念。完整的示例位于`ch7/ts/multi-page-model-driven`。
- en: 'This is the result that we will achieve by the end of this section:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们本节结束时将要实现的结果：
- en: '![Developing model-driven forms in Angular](img/1-2.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![在Angular中开发模型驱动表单](img/1-2.jpg)'
- en: Figure 1
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: 'In the preceding screenshot, there are two forms:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，有两种形式：
- en: 'A form that contains the following controls for importing existing users from
    GitHub:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含以下控件以从GitHub导入现有用户的形式：
- en: The input for the GitHub handle.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub处理器的输入。
- en: A checkbox that points out whether we want to import the developer from GitHub
    or enter it manually.
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个复选框，指出我们是否想从GitHub导入开发者或手动输入。
- en: A form for entering new users manually.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于手动输入新用户的形式。
- en: 'The second form looks exactly the way we left it in the last chapter. However,
    this time, its definition looks a little bit different:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个表单看起来与我们上章离开时完全一样。然而，这次，它的定义看起来略有不同：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that, this time, we don't have the `submit` handler or the `#f="ngForm"`
    attribute. Instead, we bind the `[formGroup]` property to `addDevForm` defined
    inside the component's controller. Using this attribute, we can bind to something
    called `FormGroup`. As its name states, the `FormGroup` class consists of a list
    of controls grouped together with the sets of validation rules associated with
    them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次我们没有`submit`处理程序或`#f="ngForm"`属性。相反，我们将`[formGroup]`属性绑定到组件控制器中定义的`addDevForm`。使用此属性，我们可以绑定到称为`FormGroup`的东西。正如其名称所示，`FormGroup`类由一组与它们关联的验证规则一起组合的控件列表组成。
- en: 'We need to use a similar declaration in the form used for importing a developer.
    However, this time, we will provide a different value of the `[formGroup]` property,
    as we will define a different form group in the component''s controller. Place
    the following snippet above the form we introduced earlier:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在用于导入开发者的表单中使用类似的声明。然而，这次，我们将提供不同的`[formGroup]`属性值，因为我们将在组件控制器中定义不同的表单组。将以下片段放置在我们之前引入的表单上方：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s declare the `importDevForm` and `addDevForm` properties in the
    component''s controller:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在组件控制器中声明`importDevForm`和`addDevForm`属性：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Initially, we import the `FormGroup` class from the `@angular/forms` module
    and, later, declare the required properties in the controller. Note that we have
    one additional parameter of the constructor of `AddDeveloper` called `fb` of the `FormBuilder` type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们从`@angular/forms`模块导入`FormGroup`类，稍后，在控制器中声明所需的属性。请注意，我们有一个额外的`AddDeveloper`构造函数参数，称为`fb`，它是`FormBuilder`类型。
- en: '`FormBuilder` provides a programmable API for the definition of `FormGroup` where
    we can attach validation behavior to each control in the group. Let''s use the
    `FormBuilder` instance for the initialization of the `importDevForm` and `addDevForm`
    properties:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormBuilder`提供了一个可编程API，用于定义`FormGroup`，我们可以将验证行为附加到组中的每个控件。让我们使用`FormBuilder`实例初始化`importDevForm`和`addDevForm`属性：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `FormBuilder` instance has a method called `group` that allows us to define
    properties, such as the default values and the validators for the individual controls
    in a given form.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormBuilder`实例有一个名为`group`的方法，它允许我们定义给定表单中各个控件的属性，例如默认值和验证器。'
- en: 'According to the previous snippet, `importDevForm` has two fields: `githubHandle`
    and `fetchFromGitHub`. We declare that the value of the `githubHandle` control
    is required, and set the default value of the control `fetchFromGitHub` to `false`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码片段，`importDevForm`有两个字段：`githubHandle`和`fetchFromGitHub`。我们声明`githubHandle`控制器的值是必需的，并将控制器`fetchFromGitHub`的默认值设置为`false`。
- en: 'In the second form, `addDevForm`, we declare four controls. For the `realName`
    control as the default value, we set the empty string and use `Validators.requred`
    in order to introduce validation behavior (which is exactly what we did for the
    `githubHandle` control). As a validator for the e-mail input, we will use the
    `validateEmail` function and set the control''s initial value to an empty string.
    The `validateEmail` function used for validation is the one we defined in the
    last chapter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个表单`addDevForm`中，我们声明了四个控件。对于默认值为空字符串的`realName`控件，我们使用`Validators.requred`来引入验证行为（这正是我们对`githubHandle`控件所做的那样）。作为电子邮件输入的验证器，我们将使用`validateEmail`函数，并将控件初始值设置为空字符串。用于验证的`validateEmail`函数是我们上一章中定义的：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last two controls we define here are the `technology` control, for which
    a value is required and has an empty string as its initial value, and the `popular`
    control, with its initial value set to `false`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的最后两个控件是`technology`控件，它需要一个值并且其初始值为空字符串，以及`popular`控件，其初始值设置为`false`。
- en: Using composition of control validators
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用控件验证器的组合
- en: 'We took a look at how we can apply a single validator to form controls. Using
    model-driven approach, we applied the `Validators.required` validator in a way
    equivalent to what we did in the preceding chapter, where we used template-driven
    forms and added the `required` attribute. However, in some applications, the domain
    may require a more complex validation logic. For example, if we want to apply
    both the required and the `validateEmail` validators to the e-mail control, we
    should do the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了一下如何将单个验证器应用于表单控件。使用模型驱动方法，我们以与上一章中使用模板驱动表单并添加`required`属性相同的方式应用了`Validators.required`验证器。然而，在某些应用程序中，领域可能需要更复杂的验证逻辑。例如，如果我们想将`required`和`validateEmail`验证器都应用于电子邮件控件，我们应该做以下操作：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `compose` method of the `Validators` object accepts an array of validators
    as an argument and returns a new validator. The new validator's behavior will be
    a composition of the logic defined in the individual validators passed as an argument,
    and they will be applied in the same order as they were introduced in the array.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validators`对象的`compose`方法接受一个验证器数组作为参数，并返回一个新的验证器。新验证器的行为将是作为参数传递的各个验证器中定义的逻辑的组合，并且它们将按照在数组中引入的顺序应用。'
- en: 'The property names in the object literal passed to the `group` method, of the
    `FormBuilder`, should match with the values that we set to the `formControlName` attributes
    of the inputs in the template. This is the complete template of `importDevForm`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`FormBuilder`的`group`方法的对象字面量中的属性名应与我们在模板中设置的输入的`formControlName`属性值相匹配。这是`importDevForm`的完整模板：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding template, we can note that, once the `submitted` flag has the
    value `true`, the form will be hidden from the user. Next to the first input element,
    we will set the value of the `formControlName` attribute to `githubHandle`. The
    `formControlName` attribute associates an existing form input in the template
    with one declared in the `FormGroup`, corresponding to the form element where
    HTML input resides. This means that the key associated with the controls' definition
    inside the object literal, which we pass to the `group` method of the `FormBuilder`,
    must match with the name of the corresponding control in the template, set with
    `formControlName`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们可以注意到，一旦 `submitted` 标志的值为 `true`，表单将隐藏给用户。在第一个输入元素旁边，我们将 `formControlName`
    属性的值设置为 `githubHandle`。`formControlName` 属性将模板中现有的表单输入与在 `FormGroup` 中声明的输入关联起来，对应于包含
    HTML 输入的表单元素。这意味着我们传递给 `FormBuilder` 的 `group` 方法的对象字面量中与控件定义关联的键必须与模板中设置 `formControlName`
    的相应控件名称匹配。
- en: 'Now we want to implement the following behavior:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要实现以下行为：
- en: When the **Fetch from GitHub** checkbox is checked, disable the form for entering
    a new developer and enable the form for importing a developer from GitHub.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 **从 GitHub 获取** 复选框被勾选时，禁用输入新开发者的表单，并启用从 GitHub 导入开发者的表单。
- en: When the current active (or enabled) form is invalid, disable the submit button.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当当前活动（或启用）的表单无效时，禁用提交按钮。
- en: We'll explore how we can achieve this functionality using Angular's reactive
    forms (also known as model-driven forms) API.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用 Angular 的响应式表单（也称为模型驱动表单）API 实现此功能。
- en: 'Inside the `AddDeveloper` class, add the following methods definitions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AddDeveloper` 类内部，添加以下方法定义：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that in `ngOnInit`, we invoke the `toggleControls` method with the current
    value of the `fetchFromGitHub` checkbox. We can get reference to the `AbstractControl`,
    which represents the checkbox, by getting the `fetchFromGitHub` property of the
    `controls` within the `importDevForm`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `ngOnInit` 中，我们通过获取 `importDevForm` 中 `controls` 的 `fetchFromGitHub` 属性来引用表示复选框的
    `AbstractControl`。我们可以通过传递一个回调给其 `subscribe` 方法来订阅复选框的 `valueChange` 事件。每次复选框的值改变时，我们传递给
    `subscribe` 的回调将被调用。
- en: After that, we subscribe to the `valueChange` event of the checkbox by passing
    a callback to its `subscribe` method. Each time the value of the checkbox is changed,
    the callback we've passed to `subscribe` will be invoked.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过传递一个回调给其 `subscribe` 方法来订阅复选框的 `valueChange` 事件。每次复选框的值改变时，我们传递给 `subscribe`
    的回调将被调用。
- en: Later, in `ngOnDestroy`, we unsubscribe from the `valueChange` subscription
    in order to prevent our code from memory leaks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在 `ngOnDestroy` 中，我们取消订阅 `valueChange` 订阅，以防止我们的代码出现内存泄漏。
- en: Finally, the most interesting thing happens in `toggleControls`. To this method,
    we pass a flag that indicates whether we want the `importDevForm` to be enabled
    or not. If we want the form to be enabled, all we need to do is to invoke the
    `enable` method of the `githubHandle` control and disable all the controls in
    the `addDevForm`. We can disable all the controls in `addDevForm` by iterating
    over the control names (that is, the keys of the `controls` property of the `addDevForm`), getting
    the corresponding control instance for each individual name, and invoking its
    disable method. In case the `importEnabled` flag has value `false`, we do the
    exact opposite, by invoking the `enable` method of the controls from the `addDevForm`
    and the `disable` method of the control from `importDevForm`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最有趣的事情发生在 `toggleControls` 方法中。我们向这个方法传递一个标志，用来指示我们是否想要启用 `importDevForm`。如果我们想要启用这个表单，我们只需要调用
    `githubHandle` 控件的 `enable` 方法，并禁用 `addDevForm` 中的所有控件。我们可以通过遍历控件名称（即 `addDevForm`
    的 `controls` 属性的键）来禁用 `addDevForm` 中的所有控件，获取每个名称对应的控件实例，并调用其 `disable` 方法。如果 `importEnabled`
    标志的值为 `false`，我们将执行完全相反的操作，通过调用 `addDevForm` 中的控件的 `enable` 方法和 `importDevForm`
    中控件的 `disable` 方法。
- en: Exploring the HTTP module of Angular
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Angular 的 HTTP 模块
- en: Now, after we have developed both forms – for importing existing and adding
    new developers, it is time to implement the logic behind them in the controller
    of the component.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们已经开发了两个表单——用于导入现有开发者和添加新开发者之后，是时候在组件的控制器中实现它们背后的逻辑了。
- en: 'For this purpose, we will need to communicate with the GitHub API. Although
    we can do this directly from the component''s controller, by approaching the problem this
    way, we would couple the component with the RESTful API of GitHub. In order to
    enforce better separation of concerns, we can extract the logic for communication
    with GitHub into a separate service called `GitHubGateway`. Open the file called
    `github_gateway.ts`, and enter the following content:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们需要与 GitHub API 进行通信。虽然我们可以直接从组件的控制器中这样做，但通过这种方式解决问题，我们将组件与 GitHub 的
    RESTful API 相耦合。为了更好地分离关注点，我们可以将用于与 GitHub 通信的逻辑提取到一个单独的服务中，称为 `GitHubGateway`。打开名为
    `github_gateway.ts` 的文件，并输入以下内容：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Initially, we import the `Http` class from the `@angular/http` module. All the
    HTTP-related functionalities are externalized and are outside the Angular's core.
    Since `GitHubGateway` accepts a dependency, which needs to be injected through
    the DI mechanism of the framework, we will decorate it with the `@Injectable`
    decorator.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们从 `@angular/http` 模块导入 `Http` 类。所有与 HTTP 相关的功能都被外部化，并且位于 Angular 的核心之外。由于
    `GitHubGateway` 接受一个依赖项，该依赖项需要通过框架的 DI 机制进行注入，因此我们将它装饰为 `@Injectable`。
- en: The only functionality from the GitHub's API we use is the one for fetching
    users, so we define a single method called `getUser`. As an argument, it accepts
    the GitHub handle of the developer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的 GitHub API 的唯一功能是用于获取用户的功能，因此我们定义了一个名为 `getUser` 的单个方法。它接受开发者的 GitHub
    处理符作为参数。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, if you make more than 60 requests per day to the GitHub's API, you
    might get the error **GitHub API Rate limit exceeded**. This is due to the rate
    limits for requests without a GitHub API token. For further information, visit
    [https://github.com/blog/1509-personal-api-tokens](https://github.com/blog/1509-personal-api-tokens)
    .
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你每天向 GitHub 的 API 发起超过 60 次请求，你可能会遇到错误 **GitHub API Rate limit exceeded**。这是由于没有
    GitHub API 令牌的请求速率限制。有关更多信息，请访问 [https://github.com/blog/1509-personal-api-tokens](https://github.com/blog/1509-personal-api-tokens)。
- en: Inside the `getUser` method, we use the instance of the `Http` service that
    we received in the `constructor`. The `Http` service's API stays as close to the
    HTML5 fetch API as possible. However, there are a couple of differences. The most
    significant one of them is that, at the moment of writing this content, all the
    methods of the `Http` instances return `Observables` instead of `Promises`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getUser` 方法内部，我们使用在 `constructor` 中接收到的 `Http` 服务实例。`Http` 服务的 API 尽可能接近
    HTML5 fetch API。然而，有一些差异。其中最显著的一个是，在撰写本文时，`Http` 实例的所有方法都返回 `Observables` 而不是
    `Promises`。
- en: 'The `Http` service instances have the following API:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Http` 服务实例具有以下 API：'
- en: '`request(url: string | Request, options: RequestOptionsArgs)`: This makes a
    request to the specified URL. The request can be configured using `RequestOptionsArgs`,
    as follows:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request(url: string | Request, options: RequestOptionsArgs)`: 这将向指定的 URL 发起一个请求。请求可以使用
    `RequestOptionsArgs` 进行配置，如下所示：'
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`get(url: string, options?: RequestOptionsArgs)`: This makes a get request
    to the specified URL. The request headers and other options can be configured
    using the second argument.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(url: string, options?: RequestOptionsArgs)`: 这将向指定的 URL 发起一个 get 请求。请求头和其他选项可以使用第二个参数进行配置。'
- en: '`post(url: string, options?: RequestOptionsArgs)`: This makes a post request
    to the specified URL. The request body, headers, and other options can be configured
    using the second argument.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post(url: string, options?: RequestOptionsArgs)`: 这将向指定的 URL 发起一个 post 请求。请求体、头和其他选项可以使用第二个参数进行配置。'
- en: '`put(url: string, options?: RequestOptionsArgs)`: This makes a put request
    to the specified URL. The request headers and other options can be configured
    using the second argument.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put(url: string, options?: RequestOptionsArgs)`: 这将向指定的 URL 发起一个 put 请求。请求头和其他选项可以使用第二个参数进行配置。'
- en: '`patch(url: string, options?: RequestOptionsArgs)`: This makes a patch request
    to the specified URL. The request headers and other options can be configured
    using the second argument.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch(url: string, options?: RequestOptionsArgs)`: 这将向指定的 URL 发起一个 patch 请求。请求头和其他选项可以使用第二个参数进行配置。'
- en: '`delete(url: string, options?: RequestOptionsArgs)`: This makes a delete request
    to the specified URL. The request headers and other options can be configured
    using the second argument.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete(url: string, options?: RequestOptionsArgs)`: 这将向指定的 URL 发起一个 delete
    请求。请求头和其他选项可以使用第二个参数进行配置。'
- en: '`head(url: string, options?: RequestOptionsArgs)`: This makes a head request
    to the specified URL. The request headers and other options can be configured
    using the second argument.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head(url: string, options?: RequestOptionsArgs)`: 这将向指定的 URL 发送一个头部请求。请求头和其他选项可以使用第二个参数进行配置。'
- en: Using Angular's HTTP module
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Angular 的 HTTP 模块
- en: 'Now, let''s implement the logic for importing the existing developers from
    GitHub. First, we will need to import the `HttpModule` in our `AppModule`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现从 GitHub 导入现有开发者的逻辑。首先，我们需要在我们的 `AppModule` 中导入 `HttpModule`：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After that, open the `ch6/ts/step-2/add_developer.ts` file and enter the following
    imports:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开 `ch6/ts/step-2/add_developer.ts` 文件并输入以下导入：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add `GitHubGateway` to the list of providers of the `AddDeveloper` component:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `GitHubGateway` 添加到 `AddDeveloper` 组件提供者列表中：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As the next step, we have to include the following parameters in the constructor
    of the class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们必须在类的构造函数中包含以下参数：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This way, the `AddDeveloper` class' instances will have a private property called
    `githubAPI`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`AddDeveloper` 类的实例将会有一个名为 `githubAPI` 的私有属性。
- en: The only thing left is to implement the `addDeveloper` method and allow the
    user to import the existing developers using the `GitHubGateway` instance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是实现 `addDeveloper` 方法，并允许用户使用 `GitHubGateway` 实例导入现有的开发者。
- en: 'Once the user presses the **Add** button, we will need to check whether we
    need to import an existing GitHub user or add a new developer. For this purpose,
    we can use the value of the `fetchFromGitHub` control:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下 **添加** 按钮时，我们需要检查是否需要导入现有的 GitHub 用户或添加新的开发者。为此，我们可以使用 `fetchFromGitHub`
    控件的值：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If it has a truthy value, then we can invoke the `getUser` method of the `githubAPI`
    property and pass the value of the `githubHandle` control as an argument:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它有一个真值，那么我们可以调用 `githubAPI` 属性的 `getUser` 方法，并将 `githubHandle` 控件的值作为参数传递：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `getUser` method of the `GitHubGateway` instance, we delegate the call
    to the `Http` service''s `get` method, which returns an observable. In order to
    get the result that the observable will push, we will need to pass a callback
    to its `subscribe` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GitHubGateway` 实例的 `getUser` 方法中，我们将调用委托给 `Http` 服务器的 `get` 方法，该方法返回一个可观察对象。为了获取可观察对象将要推送的结果，我们需要传递一个回调给它的
    `subscribe` 方法：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding snippet, we first establish the HTTP `get` request. After this,
    we get the corresponding observable that, in general cases, will emit a series
    of values (in this case, only a single one-the response of the request) and map
    them to their JSON representations. If the request fails, or the response's body
    is not a valid JSON string, then we will get an error.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先建立了 HTTP `get` 请求。之后，我们获取相应的可观察对象，在一般情况下，它将发出一系列值（在这种情况下，只有一个——请求的响应）并将它们映射到它们的
    JSON 表示形式。如果请求失败，或者响应体不是一个有效的 JSON 字符串，那么我们将得到一个错误。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that, in order to reduce the bundle size of Angular, the team at Google
    has included only the core of RxJS in the framework. In order to use the `map`
    and `catch` methods, you will need to add the following imports at `add_developer.ts`:
    `import ''rxjs/add/operator/map'';` `import ''rxjs/add/operator/catch'';`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了减少 Angular 的包大小，谷歌团队在框架中只包含了 RxJS 的核心。为了使用 `map` 和 `catch` 方法，你需要在 `add_developer.ts`
    文件中添加以下导入：`import 'rxjs/add/operator/map';` `import 'rxjs/add/operator/catch';`
- en: 'Now, let''s implement the body of the callback we pass to `subscribe`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现传递给 `subscribe` 方法的回调函数体：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, we set the properties of a new `Developer` instance.
    Here, we establish the mapping between the object returned from GitHub's API and
    the developer's representation in our application. We consider a developer as
    popular if they have more than 1,000 followers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们设置了新 `Developer` 实例的属性。在这里，我们建立了 GitHub API 返回的对象与我们在应用程序中开发者表示之间的映射。我们认为如果一个开发者拥有超过
    1,000 个关注者，那么他就是受欢迎的。
- en: The entire implementation of the `addDeveloper` method can be found at `ch7/ts/multi-page-model-driven/add_developer.ts`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`addDeveloper` 方法的整个实现可以在 `ch7/ts/multi-page-model-driven/add_developer.ts`
    文件中找到。'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to handle failed requests, we can use the `catch` method of the observable
    instances: `this.githubAPI.getUser(model.githubHandle)` `.catch((error, source,
    caught) => {`    `console.log(error)`    `return error;` `});`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理失败的请求，我们可以使用可观察实例的 `catch` 方法：`this.githubAPI.getUser(model.githubHandle)`
    `.catch((error, source, caught) => {` `console.log(error)` `return error;` `});`
- en: Defining parameterized views
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义参数化视图
- en: 'As the next step, let''s dedicate a special page for each developer. On it,
    we''ll be able to take a detailed look at their profile. Once the user clicks
    on the name of any of the developers on the home page of the application, they should
    be redirected to a page with a detailed profile of the selected developer. The
    end result will look as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们为每个开发者分配一个专门的页面。在这个页面上，我们将能够详细查看他们的资料。一旦用户点击应用程序主页上的任何开发者的名字，他们应该被重定向到一个显示所选开发者详细资料的页面。最终结果将如下所示：
- en: '![Defining parameterized views](img/2-2.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![定义参数化视图](img/2-2.jpg)'
- en: Figure 2
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: 'In order to do this, we will need to pass an identifier of the developer to
    the component that shows the developer''s detailed profile. Open `app.ts`, and
    add the following import:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要将开发者的标识符传递给显示开发者详细资料的组件。打开`app.ts`，并添加以下导入：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We haven''t developed the `DeveloperDetails` component yet, so, if you run
    the application, you will get an error. We will define the component in the next
    paragraph, but before this, let''s alter the routes'' definition of the `app.ts`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有开发`DeveloperDetails`组件，所以如果你运行应用程序，你会得到一个错误。我们将在下一段定义该组件，但在那之前，让我们修改`app.ts`中路由的定义：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We add a single route with the `dev-details/:id` path and associate the `DeveloperDetails`
    component with it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个带有`dev-details/:id`路径的单个路由，并将其与`DeveloperDetails`组件关联。
- en: Note that, in the `path` property, we declare that the route has a single parameter
    called `id` and also set the `children` property to the `devDetailsRoutes`. The
    `devDetailsRoutes` contains the nested routes, which should be rendered within
    the `router-outlet` located in `DeveloperDetails` component.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`path`属性中，我们声明该路由有一个名为`id`的单个参数，并将`children`属性设置为`devDetailsRoutes`。`devDetailsRoutes`包含嵌套路由，这些路由应该在`DeveloperDetails`组件中的`router-outlet`内渲染。
- en: 'Now, let''s pass the `id` of the current developer as a parameter to the `routerLink`
    directive. Open `home.html` in your working directory and replace the table cell,
    where we display the developer''s `realName` property with the following content:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将当前开发者的`id`作为参数传递给`routerLink`指令。在你的工作目录中打开`home.html`，并将显示开发者`realName`属性的表格单元格替换为以下内容：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The value of the `routerLink` directive is an array with the following three
    elements:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`routerLink`指令的值是一个包含以下三个元素的数组：'
- en: '`''/dev-details''`: A string that shows the root route.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''/dev-details''`：显示根路由的字符串。'
- en: '`dev.id`: The ID of the developer whose details we want to see.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev.id`：我们想要查看其详细信息的开发者的ID。'
- en: '`''dev-basic-info''`: The path of a route that shows which component within
    the nested route should be rendered.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''dev-basic-info''`：显示嵌套路由中应该渲染哪个组件的路由路径。'
- en: Defining nested routes
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义嵌套路由
- en: 'Now, let''s jump to the `DeveloperDetails` definition. In your working directory,
    create a file called `developer_details.ts` and enter the following content:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳转到`DeveloperDetails`的定义。在你的工作目录中，创建一个名为`developer_details.ts`的文件，并输入以下内容：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For the sake of simplicity, in order to not introduce a complex directory/file
    structure in the examples for this book, we have a few component and route declarations
    in a single file. Keep in mind that, according to best practices, the individual declarations
    should be placed into separate files. For further information, visit [https://angular.io/styleguide](https://angular.io/styleguide).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，为了避免在本书的示例中引入复杂的目录/文件结构，我们在单个文件中有几个组件和路由声明。请记住，根据最佳实践，单个声明应该放置在单独的文件中。有关更多信息，请访问[https://angular.io/styleguide](https://angular.io/styleguide)。
- en: In the previous snippet, we define a component with controller called `DeveloperDetails`.
    Note that, within the controller's constructor, through the DI mechanism of Angular,
    we inject a parameter associated with the `ActivatedRoute` token. The injected
    parameter provides us with access to the parameters visible by the current route. In
    `ngOnInit`, we apply an imperative approach, where we subscribe changes in the
    value of the route's `params` property, get the first set of parameters, and assign
    the `dev` property to the result of the invocation of `this.developers.getUserById`
    with the selected developer's identifier as an argument.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个名为`DeveloperDetails`的控制器组件。注意，在控制器的构造函数中，通过Angular的依赖注入机制，我们注入了一个与`ActivatedRoute`令牌关联的参数。注入的参数为我们提供了访问当前路由可见参数的能力。在`ngOnInit`中，我们采用命令式方法，订阅路由`params`属性值的变化，获取第一组参数，并将`dev`属性赋值为调用`this.developers.getUserById`的结果，该结果以所选开发者的标识符作为参数。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Note that a more declarative and reactive approach would be to take advantage
    of the higher-order functions provided by RxJS, where we''d be able to get access
    to the selected developer using code similar to the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，更声明性和响应式的方法是利用RxJS提供的高阶函数，这样我们就能通过类似以下代码的方式访问所选的开发者：
- en: '`...` `get dev$() {` `return this.route.params.map((params: any) =>` `    this.developers.getUserById(parseInt(params[''id''])));`
    `}` `...`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`...` `get dev$() {` `return this.route.params.map((params: any) =>` `    this.developers.getUserById(parseInt(params[''id''])));`
    `}` `...`'
- en: Later, we can bind to the result of the invocation with the Angular's async
    pipe, that we will explain later in this chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用Angular的异步管道绑定到调用结果，我们将在本章稍后解释。
- en: Since the parameter we got from `routeParams.params['id']` is a string, we will
    need to parse it to a number in order to get the developer associated with the
    given route.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从`routeParams.params['id']`获取的参数是一个字符串，我们需要将其解析为数字，以便获取与给定路由关联的开发者。
- en: 'Now, let''s define the child routes, which will be rendered in the template
    of `DeveloperDetails`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义子路由，这些路由将在`DeveloperDetails`的模板中渲染：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, there is nothing new for us. The route definition follows
    the exact same rules we're already familiar with.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，对我们来说没有新的内容。路由定义遵循我们已熟悉的完全相同的规则。
- en: 'Now, to the template of the component, let''s add links associated with the
    individual nested routes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向组件的模板中添加与单个嵌套路由关联的链接：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Within the template, we declare two relative to the current path links. The
    first one points to `dev-basic-info`, which is the path of the first route defined
    within `devDetailsRoutes`, and the second one points to `dev-details-advanced`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们声明了两个相对于当前路径的链接。第一个链接指向`dev-basic-info`，这是在`devDetailsRoutes`中定义的第一个路由的路径，第二个链接指向`dev-details-advanced`。
- en: 'Since the implementations of the components associated with both routes are
    quite similar, let''s take a look only at `DeveloperBasicInfo`. As an exercise,
    you can develop the second one or take a look at its implementation at `ch7/ts/multi-page-model-driven/developer_advanced_info.ts`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与两个路由关联的组件实现相当相似，让我们只看看`DeveloperBasicInfo`。作为练习，你可以开发第二个组件或查看其实现，位置在`ch7/ts/multi-page-model-driven/developer_advanced_info.ts`：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding snippet, we inject the parent component using the `@Inject`
    parameter decorator. Inside `@Inject`, we use `forwardRef`, since we have a circular
    dependency between the `developer_basic_info` and `developer_details` packages
    (inside `developer_basic_info`, we import `developer_details`, and within `developer_details`,
    we import `developer_basic_info`).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`@Inject`参数装饰器注入父组件。在`@Inject`内部，我们使用`forwardRef`，因为我们有`developer_basic_info`和`developer_details`包（在`developer_basic_info`中导入`developer_details`，在`developer_details`中导入`developer_basic_info`）之间的循环依赖。
- en: We need a reference to the instance of the parent component in order to get
    the instance of the current developer that corresponds to the selected route.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个指向父组件实例的引用，以便获取与所选路由对应的当前开发者的实例。
- en: Transforming data with pipes
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道转换数据
- en: It is time to take a look at the last building block that Angular provides for
    the development of applications that we haven't covered in detail yet-the pipes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看Angular为我们开发应用程序提供的最后一个构建块了——管道，这是我们尚未详细讨论的。
- en: 'Just like the filters in AngularJS, pipes are intended to encapsulate all the
    data transformation logic. Let''s take a look at the template of the home page
    of the application we have just developed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 AngularJS 中的过滤器一样，管道旨在封装所有的数据转换逻辑。让我们看看我们刚刚开发的应用程序的首页模板：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding snippet, depending on the value of the `popular` property,
    we show different data using the `NgSwitch` and `NgSwitchCase` directives. Although
    this works, it is redundant.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，根据 `popular` 属性的值，我们使用 `NgSwitch` 和 `NgSwitchCase` 指令显示不同的数据。虽然这可行，但它是多余的。
- en: Developing stateless pipes
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发无状态管道
- en: 'Let''s develop a pipe that transforms the value of the `popular` property and
    uses it in place of `NgSwitch` and `NgSwitchCase`. The pipe will accept three
    arguments: a value that should be transformed, a string that should be displayed
    when the value is truthy, and another string that should be displayed in case
    of a falsy value.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发一个管道，将 `popular` 属性的值进行转换，并用它来代替 `NgSwitch` 和 `NgSwitchCase`。这个管道将接受三个参数：一个需要转换的值，一个当值为真时应该显示的字符串，以及一个在值为假时应该显示的字符串。
- en: 'With the use of an Angular custom pipe, we will be able to simplify the template
    to the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular 自定义管道，我们可以将模板简化为以下形式：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We could even use emojis, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用表情符号，如下所示：
- en: '`<td>{{dev.popular | boolean: ''![Developing stateless pipes](img/yes.jpg)'':
    ''![Developing stateless pipes](img/no.jpg)''}}</td>`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`<td>{{dev.popular | boolean: ''![开发无状态管道](img/yes.jpg)'': ''![开发无状态管道](img/no.jpg)''}}</td>`'
- en: We apply the pipe to the value the same way we would do in AngularJS. The arguments
    we pass to the pipe should be separated by the colon (`:`) symbol.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将管道应用于值的方式与在 AngularJS 中做的方式相同。传递给管道的参数应该由冒号（`:`）符号分隔。
- en: 'In order to develop an Angular pipe, we will need the following imports:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发 Angular 管道，我们需要以下导入：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Pipe` decorator can be used for adding metadata to the class that implements
    the data transformation logic. The `PipeTransform` is an interface with a single
    method, called `transform`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pipe` 装饰器可以用来为实现数据转换逻辑的类添加元数据。`PipeTransform` 是一个接口，它有一个名为 `transform` 的单方法：'
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding snippet is the entire implementation of `BooleanPipe`. The `name` that
    we pass to the `@Pipe` decorator determines how we should reference it in templates.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是 `BooleanPipe` 的整个实现。我们传递给 `@Pipe` 装饰器的 `name` 决定了我们在模板中如何引用它。
- en: 'The last thing we need to do before being able to use the `BooleanPipe` is
    to add it to the list of declarations in our `AppModule`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够使用 `BooleanPipe` 之前，我们需要将其添加到 `AppModule` 的声明列表中：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using Angular's built-in pipes
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Angular 内置管道
- en: 'Angular provides the following set of built-in pipes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供以下内置管道集：
- en: '`CurrencyPipe`: This pipe is used for formatting currency data. As an argument,
    it accepts the abbreviation of the currency type (that is, `"EUR"`, `"USD"`, and
    so on). It can be used in the following way:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrencyPipe`：这个管道用于格式化货币数据。它接受的参数是货币类型的缩写（即 `"EUR"`、`"USD"` 等）。它可以按以下方式使用：'
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`DatePipe`: This pipe is used for the transformation of dates. It can be used
    in the following way:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatePipe`：这个管道用于日期的转换。它可以按以下方式使用：'
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`DecimalPipe`: This pipe is used for transformation of decimal numbers. The
    argument it accepts is of the following form: `"{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}"`.
    It can be used in the following way:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DecimalPipe`：这个管道用于十进制数字的转换。它接受的参数形式如下：`"{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}"`。它可以按以下方式使用：'
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`JsonPipe`: This transforms a JavaScript object into a JSON string. It can
    be used in the following way:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsonPipe`：这个管道将 JavaScript 对象转换为 JSON 字符串。它可以按以下方式使用：'
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`LowerCasePipe`: This transforms a string to lowercase. It can be used in the
    following way:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LowerCasePipe`：这个管道将字符串转换为小写。它可以按以下方式使用：'
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`UpperCasePipe`: This transforms a string to uppercase. It can be used in the
    following way:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpperCasePipe`：这个管道将字符串转换为大写。它可以按以下方式使用：'
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`PercentPipe`: This transforms a number into a percentage. It can be used in
    the following way:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PercentPipe`：这个管道将数字转换为百分比。它可以按以下方式使用：'
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`SlicePipe`: This returns a slice of an array. The pipe accepts the start and
    the end indexes of the slice. It can be used in the following way:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SlicePipe`：这个管道返回一个数组的切片。它接受切片的起始和结束索引。它可以按以下方式使用：'
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`AsyncPipe`: This is a `stateful` pipe that accepts an observable or a promise;
    we will take a look at it at the end of the chapter.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncPipe`：这是一个 `stateful` 管道，它接受一个可观察对象或一个承诺；我们将在本章末尾探讨它。'
- en: Developing stateful pipes
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发有状态的管道
- en: There is one common thing among all the pipes mentioned earlier – all of them
    return exactly the same result each time we apply them to the same value and pass
    them the same set of arguments. Such pipes, which hold the referentially transparency
    property, are called **pure pipes**.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所提到的所有管道中有一个共同点——每次我们将它们应用于相同的值并传递相同的参数集时，它们都会返回完全相同的结果。这样的管道，具有引用透明性属性，被称为
    **纯管道**。
- en: 'The `@Pipe` decorator accepts an object literal of the `{ name: string, pure?:
    boolean }` type, where the default value for the `pure` property is `true`. This
    means that, when we define any given pipe, we can declare whether it is stateful
    or stateless. The pure property is important because, in case the pipe is stateless
    (that is, it returns the same result in case it is applied over the same value
    with the same set of arguments), the change detection can be optimized.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Pipe` 装饰器接受一个 `{ name: string, pure?: boolean }` 类型的对象字面量，其中 `pure` 属性的默认值是
    `true`。这意味着，当我们定义任何给定的管道时，我们可以声明它是有状态的还是无状态的。纯属性很重要，因为如果管道是无状态的（即，在应用相同的值和相同的参数集时返回相同的结果），则可以优化变更检测。'
- en: Now, let's build a stateful pipe. Our pipe will make an HTTP `get` request to
    a JSON API. For this purpose, we will use the `@angular/http` module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个有状态的管道。我们的管道将向 JSON API 发起 HTTP `get` 请求。为此，我们将使用 `@angular/http`
    模块。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that having business logic in a pipe is not considered as a best practice.
    This type of logic should be extracted into a service. The example here is for
    learning purposes only.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在管道中包含业务逻辑不被视为最佳实践。这种类型的逻辑应该提取到服务中。这里的例子仅用于学习目的。
- en: 'In this case, the pipe needs to hold a different state depending on the status
    of the request (that is, whether it is pending or completed). We will use the
    pipe in the following way:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，管道需要根据请求的状态（即，它是挂起还是完成）保持不同的状态。我们将以下方式使用管道：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This way, we apply the `fetchJson` pipe over the URL. Once we have the body
    of the response, we can apply the `json` pipe over it. This example also shows
    how we can chain pipes with Angular.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就在 URL 上应用了 `fetchJson` 管道。一旦我们有了响应体，我们就可以在它上面应用 `json` 管道。这个例子还展示了我们如何使用
    Angular 连接管道。
- en: 'Similar to stateless pipes, for the development of stateful pipes, we have
    to decorate the class that implements the pipe''s logic with `@Pipe` and implement
    the `PipeTransform` interface. This time, because of the HTTP request functionality,
    we will also need to import the `Http` and `Response` classes from the `@angular/http` module:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与无状态管道类似，为了开发有状态的管道，我们必须用 `@Pipe` 装饰实现管道逻辑的类，并实现 `PipeTransform` 接口。这次，由于 HTTP
    请求功能，我们还需要从 `@angular/http` 模块导入 `Http` 和 `Response` 类：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Each time it happens to apply the `fetchJson` pipe to an argument with a different
    value, we will need to make a new HTTP `get` request. This means that, as the
    state of the pipe, we need to keep at least the values of the response of the
    remote service and the last URL:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每次当我们将 `fetchJson` 管道应用于具有不同值的参数时，我们都需要发起一个新的 HTTP `get` 请求。这意味着，作为管道的状态，我们需要至少保留远程服务的响应值和最后一个
    URL：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The only piece of logic we need to implement is the `transform` method:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的唯一逻辑部分是 `transform` 方法：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Inside of it, we initially compare the URL passed as an argument with the one
    we already have (by default, it's value will be `null`). If they are different,
    we initiate a new HTTP `get` request using the local instance of the `Http` class,
    which was passed to the `constructor` function. Once the request is completed,
    we parse the response to JSON and set the `data` property to the result.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们首先比较作为参数传递的 URL 与我们已有的 URL（默认值为 `null`）。如果它们不同，我们将使用传递给 `constructor`
    函数的 `Http` 类的本地实例发起一个新的 HTTP `get` 请求。一旦请求完成，我们将响应解析为 JSON 并将 `data` 属性设置为结果。
- en: Now, let's suppose that the pipe has started an `Http` `get` request, and before
    it is completed, the change detection mechanism invokes the pipe again. In this
    case, we will compare the `prevUrl` property with the `url` parameter. If they
    are the same, we won't perform a new `http` request and will immediately return
    the value of the `data` property. If `prevUrl` has a different value from `url`,
    we will start a new request.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设管道已经启动了一个 `Http` `get` 请求，并且在它完成之前，变更检测机制再次调用管道。在这种情况下，我们将比较 `prevUrl`
    属性与 `url` 参数。如果它们相同，我们不会执行新的 `http` 请求，并将立即返回 `data` 属性的值。如果 `prevUrl` 的值与 `url`
    不同，我们将启动一个新的请求。
- en: Using stateful pipes
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用有状态的管道
- en: 'Now, let''s use the pipe that we developed. The application that we will implement
    provides a text input and a button with label **Get Avatar** to the user. Once
    the user enters a value in the text input and presses the button, the avatar corresponding
    to the GitHub user will appear below the text input, as shown in the following
    screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们开发的管道。我们将要实现的程序提供了一个文本输入和一个带有标签 **获取头像** 的按钮给用户。一旦用户在文本输入中输入一个值并按下按钮，GitHub
    用户的头像将出现在文本输入下方，如下面的截图所示：
- en: '![Using stateful pipes](img/3-2.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![使用有状态的管道](img/3-2.jpg)'
- en: Figure 3
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3
- en: 'Now, let''s develop a sample component, which will allow us to enter the GitHub
    user''s handle:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发一个示例组件，它将允许我们输入 GitHub 用户的昵称：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The only thing left is to show the GitHub avatar of the user. We can easily
    achieve this by altering the template of the preceding component with the following
    `img` declaration:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是显示用户的 GitHub 头像。我们可以通过修改前面组件的以下 `img` 声明来实现这一点：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Initially, we append the GitHub handle to the base URL used for fetching users
    from the API. Later, we will apply the `fetchJson` filter over it and get the
    `avatar_url` property from the returned result.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们将 GitHub 昵称追加到用于从 API 获取用户的基 URL。稍后，我们将对其应用 `fetchJson` 过滤器，并从返回的结果中获取
    `avatar_url` 属性。
- en: Using Angular's AsyncPipe
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Angular 的 AsyncPipe
- en: 'Angular''s `AsyncPipe` `transform` method accepts an observable or a promise
    as an argument. Once the argument pushes a value (that is, the promise has been
    resolved or the `subscribe` callback of the observable is invoked), `AsyncPipe`
    will return it as a result. Let''s take a look at the following example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的 `AsyncPipe` `transform` 方法接受一个可观察对象或一个承诺作为参数。一旦参数推送一个值（即承诺已解决或可观察对象的
    `subscribe` 回调被调用），`AsyncPipe` 将将其作为结果返回。让我们看看以下示例：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we define an Angular component that has two properties, that is, `greetingPromise`
    of the type `Promise<string>` and `resolve` of the type `Function`. We initialized
    the `greetingPromise` property with a new `Promise<string>` instance, and as the
    value of the `resolve` property, we set the `resolve` callback of the `promise`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个 Angular 组件，它有两个属性，即 `greetingPromise` 类型为 `Promise<string>` 和 `resolve`
    类型为 `Function`。我们使用一个新的 `Promise<string>` 实例初始化了 `greetingPromise` 属性，并将 `resolve`
    属性的 `resolve` 回调设置为 `promise` 的值。
- en: In the constructor of the class, we start a time-out with the duration of 3,000
    ms, and inside of its callback, we resolve the promise. Once the promise is resolved,
    the value of the expression `{{ greetingPromise | async }}` will be evaluated
    to the string `Foobar!`. The end result that the user will see on the screen is
    the text **"Hello Foobar!"**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的构造函数中，我们开始一个 3,000 毫秒的定时器，并在其回调中解决承诺。一旦承诺被解决，表达式 `{{ greetingPromise | async
    }}` 的值将被评估为字符串 `Foobar!`。用户最终将在屏幕上看到的最终结果是文本 **"Hello Foobar!"**。
- en: The `async` pipe is extremely powerful when we combine it with an `Http` request
    or with an observable, which pushes a sequence of values.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `async` 管道与 `Http` 请求或与推送一系列值的可观察对象结合使用时，它非常强大。
- en: Using AsyncPipe with observables
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 AsyncPipe 和可观察对象
- en: 'We''re already familiar with the concept of observables from the previous chapters.
    We can say that an observable object allows us to subscribe to the emission of
    a sequence of values, for instance:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从前面的章节中熟悉了可观察的概念。我们可以这样说，一个可观察的对象允许我们订阅一系列值的发射，例如：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once we subscribe to the observable, it will start emitting values each second,
    which will be printed in the console. Let''s combine this snippet with component
    definition and implement a simple timer:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们订阅了可观察对象，它将开始每秒发射一个值，这些值将被打印在控制台上。让我们将这个片段与组件定义结合起来，实现一个简单的计时器：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The only thing left in order to be able to use the timer component is to add
    its template. We can subscribe to the observable directly in the template using
    the `async` pipe:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用计时器组件，我们只需添加其模板。我们可以在模板中使用`async`管道直接订阅可观察对象：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This way, each second we will get the new value emitted by the observable, and
    the `date` pipe will transform it into a readable form.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们每秒都会接收到由可观察对象发出的新值，而`date`管道将把它转换成可读的形式。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a deep dive into the Angular's forms module, by developing
    a model-driven (reactive) form and combining it with the HTTP module. We took
    a look at some advanced features of the new component-based router and saw how
    we can use and develop custom stateful and stateless pipes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了Angular的表单模块，通过开发一个模型驱动（响应式）表单并将其与HTTP模块结合使用。我们查看了一些基于组件的新路由器的先进功能，并了解了我们如何使用和开发自定义的有状态和无状态管道。
- en: The next chapter will be dedicated to how we can make our Angular applications
    SEO-friendly by taking advantage of the server-side rendering that the module
    Universal provides. Another thing that we'll take a look at is angular-cli and
    other tools that make our experience as developers better. Finally, we'll explain
    what Ahead-of-Time compilation is in the context of Angular, and why we should take
    advantage of it in our applications.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专门介绍我们如何通过利用模块Universal提供的服务器端渲染功能，使我们的Angular应用程序对搜索引擎优化（SEO）友好。我们还将探讨一些其他工具，如angular-cli，这些工具可以让我们作为开发者的体验变得更好。最后，我们将解释在Angular的上下文中，什么是即时编译（Ahead-of-Time
    compilation），以及为什么我们应该在我们的应用程序中利用它。
